<html>

<head>
	<meta http-equiv="Content-Language" content="ru">
	<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">   
<title>Архитектура виртуальной машины языка Ява</title>
</head>

<body bgcolor="#FFFFFF">
<font SIZE="6">

<p>1<a Name="арх"> Архитектура виртуальной машины </a>языка
Ява</p>
</font>

<blockquote>
  <u><b><p><a href="1-doc.htm#1.1">1.1 - </b>Поддерживаемые типы данных</a><br>
  <a href="1-doc.htm#1.2"><b>1.2 - </b>Регистры</a><br>
  <a href="1-doc.htm#1.3"><b>1.3 - </b>Локальные переменные</a><br>
  <a href="1-doc.htm#1.4"><b>1.4 -</b> Стек операндов</a><br>
  <a href="1-doc.htm#1.5"><b>1.5 -</b> Среда выполнения</a><br>
  <font COLOR="#000000"><a href="1-doc.htm#1.6"><b>1.6</b> - Куча и сборщик мусора</a></font><br>
  <font COLOR="#000000"><a href="1-doc.htm#1.7"><b>1.7 - </b>Область метода</a></font><br>
  <a href="1-doc.htm#1.8"><b>1.8 - </b>Набор инструкций Ява</a><br>
  <a href="1-doc.htm#1.9"><b>1.9 - </b>Ограничения</a></p>
  </u>
</blockquote>

<hr>
<font SIZE="5"><b>

<p><a Name="1.1">1.1 Поддерживаемые типы данных</a></p>
</b></font>

<p>Типы данных виртуальной машины содержат
основные типы данных языка Ява:</p>

<p><tt><small>byte&nbsp;&nbsp; // 1-байтовое со
знаком,представленное в дополнительном обратном
коде</small><br>
<small>short&nbsp; // 2-байтовое со знаком,представленное в
дополнительном обратном коде</small><br>
<small>int&nbsp;&nbsp;&nbsp; // 4-байтовое со
знаком,представленное в дополнительном обратном
коде</small><br>
<small>long&nbsp;&nbsp; // 8-байтовое со
знаком,представленное в дополнительном обратном
коде</small><br>
<small>float&nbsp; // вещественное число одинарной
точности стандарта IEEE 754, занимающее 4 байта</small><br>
<small>double // вещественное число двойной точности
стандарта IEEE 754, занимающее 8 байт</small><br>
<small>char&nbsp;&nbsp; // символ Unicode, занимающий 2 байта</small></tt></p>

<p><font COLOR="#000000">В Яве проверка почти всех типов
производится во время компиляции. Данные
элементарных типов, указанных выше, не
требуют&nbsp; аппаратной поддержки тегов чтобы
обеспечит исполнение Ява-кода. Вместо этого,
существуют байткоды, которые работают с
элементарными значениями и указывают типы
операндов, например, каждая из инструкций <tt><font
COLOR="#000000">iadd, ladd, fadd</font>, и <font COLOR="#000000">dadd</font></tt>
складывает два числа имеющих типы <tt><font COLOR="#000000">int,
long, float,</font> и <font COLOR="#000000">double</font>,</tt>
соответственно.</p>

<p>Виртуальная машина не содержит отдельных
инструкций для типов <tt>boolean.</tt> Вместо этого,
используются инструкции для целых, включающие
целочисленный return, используемый для работы с
логическими переменными; массивы из байтов
используются для массивов из</font> логических. </p>

<p>Виртуальная машина устанавливает, что
вещественные соответствуют формату IEEE 754 с
поддержкой постепенной потери значимости. На
более ранних компьютерных архитектурах<font
COLOR="#000000">, не поддерживающих</font> IEEE формат,
числовые программы Явы работают очень медленно.</p>

<p>Другие типы данных виртуальной машины
включают:</p>

<p><tt>object // ссылка на объект Явы, занимающая 4 байта<br>
returnAddress // 4 байта, используемые с инструкциями
jsr/ret/jsr_w/ret_w</tt></p>

<p>Заметьте<b>:</b> в Яве массивы трактуются как
объекты.</p>

<p>Эта спецификация не определяет <font COLOR="#000000">никакой
внутренней структуры для объектов. В нашей
реализации объектная ссылка - это дескриптор</font>,
который является парой указателей: один на
таблицу методов для объекта, и другой на данные,
соответствующие объекту. Другие реализации
могут использовать встроенное кэширование<font
COLOR="Black"> </font>вместо таблицы методов; такие методы,
вероятно, будут работать быстрее на аппаратных
средствах ЭВМ, которые будут появляться до 2000
года.</p>

<p>Программы, представленные байткодами Виртуальной
Машины Ява, предполагают соблюдение
соответствующей дисциплтны тип<font COLOR="#000000">ов, и
реализация может отказаться выполнять
байткод-программу, если есть вероятность того,
что она нарушает эту дисциплину.</p>
</font>

<p>Может показаться, что Виртуальная Машина языка
Ява предусматривает исполнение байткода только
на компьютерах 32-битной адресацией. Однако
возможно построение версии Виртуальной Машины
языка Ява, которая автоматически переводит
байткоды в 64-битную форму. Описание такого
преобразования не содержится в этой
спецификации.</p>

<hr>
<font SIZE="5"><b>

<p><a Name="1.2">1.2 Регистры</a></p>
</b></font>

<p>Виртуальная машина в любой момент времени
выполняет код отдельного метода, и регистр PC
содержит адрес следующего байткода, который
будет выполнятся.</p>

<p>Для каждого метода выделяется место в памяти
для хранения: 

<ul>
  <font COLOR="#000000">
  <li>набора локальных переменных, на который
    ссылается регистр <tt>vars,</tt></li>
  <li>стека операндов, на который ссылается регистр <tt>optop</tt>,
    и</li>
  <li>структуры среды выполнения, на которую
    ссылается регистр <tt>frame.</tt></li>
</ul>

<p>Все эти места могут быть отведены сразу,
начиная с размера локальных переменных и стека
операндов, определяемых во время компиляции, и
размера структуры окружающей среды выполнения
известного интерпретатору.</p>
</font>

<p>Все эти регистры 32 битные.</p>

<hr>
<font SIZE="5"><b>

<p><a Name="1.3">1.3 Локальные переменные</a></p>
</b></font><font COLOR="#000000">

<p>Каждый Ява-метод использует набор локальных
переменных фиксированного размера. Они
адресуются, как смещения слова от регистра<tt> vars</tt>.
Ширина локальных переменных 32 бита.<i> </p>
</i>

<p>Длинные целые и вещественные двойной точности
рассматриваются, как располагающиеся в двух
локальных переменных, и адресуются индексом
первой локальной переменной. (Например,
локальная переменная с индексом<b> </b><i>n</i>
содержащая вещественное двойной точности
фактически занимает место, соответствующее
индексам <i>n</i> и <i>n</i> + 1.) Спецификация
виртуальной машины не требует выравнивания
64-битных значений локальных переменных на 64 битную
границу. Разработчикам предоставляется право
самим разделять длинные целые и вещественные
двойной точности на два слова.</p>

<p>Инструкции обеспечивают загрузку значения
локальных переменных в стек операндов и
сохранение значений из стека операндов в
локальных переменных.</p>
</font>

<hr>
<font SIZE="5" COLOR="#000000"><b>

<p><a Name="1.4">1.4 Стек операндов</a></p>
</b></font><font COLOR="#000000">

<p>Все инструкции машины берут операнды от стека
операндов, работают с ними, и возвращают
результат обратно в стек. Мы выбрали стековую
организацию так, чтобы было легко эффективно
эмулировать машину на машинах</font> с немногими
регистрами или при нерегулярном наборе регистров
типа Intel 486.</p>
<font COLOR="#000000">

<p>Ширина стека операндов 32 бита. Он используется
для передачи параметров методам и получения
результатов метода, а также и для обеспечения
действий с параметрами и сохранения результатов
действий.</p>

<p>Например, инструкция<tt> iadd </tt>складывает два
целых. Для этого ей необходимо, чтобы целые были в
двух словах на вершине стека, помещенные туда
предыдущими инструкциями. Оба целых извлекаются
из стека, складываются, и их сумма помещается
обратно в стек операндов. Промежуточные значения
хранятся в стеке опреандов, что обеспечивает
поддержку вложенных вычислений.</p>
</font>

<p>Каждый простейший тип данных имеет
специализированные инструкции, которые знают
как работать с операндами этого типа. Каждый
операнд требует одной ячейки на стеке, кроме<tt> long</tt>
и <tt>double</tt>, которым необходимо две ячейки.</p>
<font COLOR="#000000">

<p>Операнды должны использоваться операциями,
соответствующими их типу. Например, нельзя
помещать на стек два целых и потом использовать
их как длинный целый. в реализации Sun это
ограничение контролируется верификатором
байткода. Однако, нескоторые операции (коды
операции <tt>dup</tt> и <tt>swap</tt>) работают с областями
данных как со значениями данной ширины, не
обращая внимания на тип. </p>

<p>Ниже в нашем описании инструкций виртуальной
машины результат выполнения инструкции на стеке
операндов представлен текстуально, каждое
32-битное слово на стеке записывается отдельно, в
порядке слева направо. Таким образом:</p>
</font>

<p><tt>Стек: ..., value1, value2 = &gt; ..., value3</tt></p>

<p><font COLOR="#000000">показывает действие, которое
начинается при наличии <i>value2<b> </b></i>на вершине
стека и </p>
<i>

<p>value1</i> под ним. В результате выполнения
инструкции, <i>value1</i> и <i>value2</i> извлекаются из
стека и заменяются на <i>value3</i>, которое было
вычислено инструкцией. Остаток стека,
представленный многоточием, не затрагивается
при выполнении инструкции.</p>
</font>

<p>Типы <tt>long</tt> и <tt>double</tt> занимают два 32-битных
слова на стеке операндов:</p>

<p><tt>Стек: ... = &gt; ..., value-word1, value-word2</tt></p>

<p><font COLOR="#000000">Эта спецификация не описывает, как
два слова выделяются из 64-битного<tt> long</tt> или <tt>double</tt>;
надо только учитывать, чтобы конкретная
реализация была внутренне непротиворечивой.</p>
</font>

<hr>
<font SIZE="5"><b>

<p><a Name="1.5">1.5 Среда выполнения</a></p>
</b></font><font COLOR="#000000">

<p>Информация, содержащаяся в среде выполнения
используется для динамической компоновки,
нормальных возвратов из методов, и
распространения исключений.</p>
</font><font SIZE="4"><b>

<p>Динамическая компоновка</p>
</b></font><font COLOR="#000000">

<p>Среда выполнения содержит ссылки на таблицу
символов интерпретатора для текущего метода и
класса, для поддержки динамической компоновки
кода метода. Код файла класса для метода
обращается к методам, которые будут вызваны и к
переменным, используя символические ссылки .
Динамическая компоновка переводит эти
символические вызовы методов в фактические
вызовы методов, загружая классы по мере
необходимости, для разрешения неопределенных ссылок,
и переводит обращения к переменным в
соответствующие смещения</font> в структурах
хранения, соответствующие размещению этих
переменных во время выполнения. </p>

<p>Это позднее связывание методов и переменных
делает менее вероятным нарушения в данном методе
при изменениях классов, которые использует этот
метод. </p>
<font SIZE="4"><b>

<p>Нормальные возвраты из методов</p>
</b></font>

<p>Если выполнение текущего метода заканчивается,
то значение возвращается в вызывающий метод. Это
происходит когда вызываемый метод выполняет
инструкцию возврата, соответствующую&nbsp; возвращаемому
типу. </p>
<font COLOR="#000000">

<p>Среда выполнения используется в этом случае,
чтобы восстановить регистры вызывающей
программы и увеличить программный счетчик
вызывающей программы для пропуска инструкции
вызова метода. Выполнение продолжается в среде
выполнения вызывающего метода. </p>
</font><font SIZE="4"><b>

<p>Исключение и распространение ошибки</p>
</b></font><font COLOR="#000000">

<p>Исключительные состояния, известные в Яве как <tt>Error</tt>
или<tt> Exception</tt>, являются подклассами <tt>Throwable</tt> и
могут возникать в программе из-за: 

<ul>
  <li>нарушения при динамическй компоновке, таких как
    ошибка при поиске необходимого файл класса,</li>
  <li>ошибки во время выполнения, такой как ссылка
    через пустой указатель,</li>
  <li>асинхронного события, такого как генерирование
    Thread.stop, от другого потока,</li>
  <li>программы, использующей опереатор throw.</li>
</ul>
</font>

<p>Когда генерируется исключение: 

<ul>
  <font COLOR="#000000">
  <li>Исследуется список предложений<tt> catch</tt>,
    связанных с текущим методом. Каждое предложение<tt>
    catch</tt>, определяет диапазон инструкции для которого
    оно активно, описывает тип исключения,&nbsp; которое
    оно обрабатывает, и содержит адрес кода для
    обработки.</li>
  <li>Исключение соответствует предложению<tt> catch</tt>,
    если инструкция, вызвавшая исключение находится
    в соответствующем диапазоне инструкции, и тип
    исключения - подтип типа исключения предложения<tt>
    catch</tt>. Если соответствующее предложение<tt> catch</tt>
    найдено, то система обращается к обработчику
    исключительных ситуаций. Если никакой
    обработчик не найден, то процесс повторяется до
    тех пор, пока не иссякнут все вложенные
    предложения<tt> catch</tt>&nbsp; текущего метода</li>
  <li>Важен порядок предложений<tt> catch</tt> в списке.
    Работа виртуальной машины продолжается с первого
    найденного предложения<tt> catch</tt>. Так как код Явы
    структурирован, то всегда возможно
    отсортировать все обработчики исключений для
    одного метода в одном списке так, что для любого
    значения программного счетчика можно искать в
    линейном порядке до нахождения нужного (самого
    внутреннего из тех<font COLOR="#000000">,</font> которые
    применимы) обработчика исключений,
    соответствующего этому значению программного
    счетчика.</li>
  <li>Если не найдено соответствующего предложения <tt>catch</tt>,
    то результатом текущего метода является
    исключение. Состояние выполнения метода, который
    вызвал данный метод восстанавливается по среде
    выполнения, и распространение исключения
    продолжается, как если бы исключение только что
    произошло в этом вызывающем методе.</li>
</ul>
</font><font SIZE="4" COLOR="#000000"><b>

<p>Дополнительная информация</p>
</b></font><font COLOR="#000000">

<p>Среда выполнения может быть расширена</font>
дополнительной информацией специфической
реализации, <font COLOR="#000000">такой как отладочная
информация.</p>
</font>

<hr>
<font SIZE="5" COLOR="#000000"><b>

<p><a Name="1.6">1.6 Куча и сборка мусора</a></p>
</b></font><font COLOR="#000000">

<p>Куча в Яве является областью данных времени
выполнения, в которой размещаются экземпляры
классов (объекты). В языке Ява предусмотрен
сборщик мусора - это&nbsp; дает программисту
возможность не освобождать память для объектов
явно. Ява не предполагает никакого конкретного
варианта сборщика мусора; могут</font>
использоваться различные алгоритмы в
зависимости от требований системы.</p>

<hr>
<font SIZE="5"><b>

<p><a Name="1.7">1.7 Область метода</a></p>
</b></font><font COLOR="#000000">

<p>Область метода аналогична месту в памяти,
которое отводится для компилируемого кода в
обычных языках или текстовому сегменту в
процессе UNIX. Она хранит код метода
(скомпилированный Ява-код) и таблицы символов. В
текущей реализации Явы код метода - это не часть
кучи, обслуживаемой сборщиком мусора, хотя это
планируется сделать в следующем выпуске.</p>
</font>

<hr>
<font SIZE="5"><b>

<p><a Name="1.8">1.8 Набор инструкций языка Ява</a></p>
</b></font>

<p>Инструкция в наборе инструкций языка Ява
состоит из однобайтового кода операции<font
COLOR="Black">, </font>определяющего действие, которое
будет выполнено, и также может содержать
операнды, являющиеся параметрами или данными,
которые будут использоваться этой операцией.
Многие инструкции не содержат операндов и
состоят только из кода операции.</p>

<p>Внутренний цикл исполнения виртуальной машины
эффективен:</p>

<p><tt>do {<br>
<font COLOR="#000000">&nbsp;&nbsp;&nbsp; выбор байт кода операции<br>
&nbsp;&nbsp;&nbsp; выполнение действия в зависимости от
значения кода<br>
} while (еще нужно выполнять);</font></tt></p>
<font COLOR="#000000">

<p>Число и размер дополнительных операндов
определяется кодом операции. Если
дополнительный операнд содержит более одного
байта, то они хранятся в порядке от старшего к
младщему - первым является старший байт.
Например, 16-битный параметр хранится как два
байта, значение которого:</p>
</font>

<p><tt>first_byte * 256 + second_byte</tt></p>

<p><font COLOR="#000000">Поток команд байткода
выравнивается только по границе байта, за
исключением инструкций <tt>tableswitch</tt> и<tt> lookupswitch</tt>,
которые выравниваются по 4-байтовой границе в
пределах этих инструкций.</p>

<p>Эти соглашения сохраняют код виртуальной
машины для скомпилированных&nbsp; Ява-программ
компактным и отражают преимущественное
стремление к компактности.</p>
</font>

<hr>
<font SIZE="5"><b>

<p><a Name="1.9">1.9 Ограничения</a></p>
</b></font>

<p>На один класс в константном пуле отводится
максимум 65535 элементов. Это ограничение является
внутренним пределом для общей сложности одного
класса. </p>
<font COLOR="#000000">

<p>Длина кода метода ограничена 65535 байтами,
определяемыми размерами индексов в коде, в
таблице исключений, таблице номеров строк и
таблице локальных переменных. Это может быть
зафиксировано для 1.0beta2.</p>

<p>Кроме этого предела, существует только одно
ограничение - число слов аргументов в вызове
метода ограничено 255.</p>
</font>
</body>
</html>
