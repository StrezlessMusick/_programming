<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
	<title>Daemoniada, или За свободный десктоп</title>
	<meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
	<meta http-equiv="Keywords" content="POSIX,UNIX,BSD,FreeBSD,DragonFlyBSD,Linux">
</head>
<body>

<div align="center">
<font size="-1">
<a href="../oway/index.html">OpenWay</a>|<a href="../saga/index.html">POSIX-saga</a>|<a href="../bsd/index.html">FreeBSD etc.</a>|<a href="../linux/index.html">All Linux</a>|<a href="../apps/index.html">Apps</a>|<a href="../live/index.html">POSIX-live</a>|<a href="../sitemap.html">SiteMap</a>
<br>
<a href="../index.html"><img src="../img/d-logo.gif" width="251" height="40" border="0"></a>
</font>
</div>


<div align="center">
<strong>Все Linux'ы</strong>
<br>
<font size="-2">
(C) Указанные авторы, 2004, отныне и вовек
</font>
</div>


<div align="center">
<font size="-2">
<a href="links.html">Links</a>|<a href="base000.html">Base</a>|<A href="sb000.html">SB</A>|<a href="pkg000.html">Packett</a>|<a href="lcd000">LiveCD</a>
</font>
</div>


<div align="center">
<hr>
</div>

<h1>
Самостройный Linux
</h1>

<p>
Алексей Федорчук
</p>

<p>
Этот материал сочинялся где-то на протяжении первой поливны 2003 г. и по ряду причин так и остался неоконченным. Тем не менее, надеюсь, что кое-что здесь не утралито актуальности.
</p>

<p>
Я столько времени писал о всяких Linux'ах, а также Free- и прочих BSD, что однажды в голову закралась шальная мысль - а не замахнуться ли на сборку своей собственной системы? Той самой, которая станет
очередной ступенькой на пути к недосягаемому идеалу? А что, и замахнемся, - ответил я себе, и, по мере сил и возможностей, приступил к изучению вопроса. Результаты вылились в нечто похожее на
</p>

<h2>
Исторические изыскания
</h2>

<p>
Оказалось, что я не одинок в своем стремлении: мысль стать обладателем собственной уникальной системы приходила в голову многим. В Сети обнаружились упоминания о двух проектах под значимыми названиями
Linux from Scratch (что в данном случае я перевел бы как "Linux по сусекам скребеный", сокращенно - LFS) и BYO Linux (то есть нечто вроде - "Построй свой собственный Linux").
</p>

<p>
Основоположник LFS - Герард Бикманс (Gerarg Beekmans). Устав, по его словам, от изобилия дистрибутивов, ни один из которых не удовлетворял его в полной мере, он решил собрать систему, в которой было бы только то, что он сам установил - и ни граном больше. Что и не замедлил претворить в жизнь.
</p>

<p>
Произведение Герарда назвать дистрибутивом в общепринятом понимании термина трудно. Это - не distribution на все случаи жизни, а, скорее,
сборник рецептов, как, опираясь на исходники base Linux, построить собственную систему. Забегая вперед, замечу - построение это будет стопроцентно удачным только в том случае, если следовать писанию
Герарда (знаменитой <a href="http://www.linuxfromscratch.org/">LFS Book</a>, разные версии которой доступны ныне и в русском переводе (например, <a href="http://multilinux.sakh.com/lfs/">один</a>), аки священному. И при этом пользоваться именно теми версиями базового софта, которые описаны им в соответствующей версии книги - в противном случае возможны всякие неожиданности.
</p>

<p>
Менее известен другой проект - <a href="http://www.byolinux.org/">BYOLinux</a>.
Начатый Джонатаном Торпом (Jonatan Thorpe) практически одновременно с LFS, ныне он прекратил свое развитие. Впрочем, описание Джонатана можно использовать как руководство к действию и до сих пор (с поправкой на
версии софта, разумеется). Оно не столь детально, как LFS Book, однако, уже с силу этого, носит несколько более общий характер.
</p>

<p>
Однако выясняется, что исторически первым примером самостройного Linux'а был RockLinux Клиффорда Вольфа. Хотя и распространяется он обычно в виде прекомпилированных дистрибутивов, однако методически это - именно сборка "с нуля", дополненная системой автоматизированного обновления.
</p>

<p>
А вообще говоря, основоположник системного самосбора - не кто иной, как Линус Торвальдс: не из (собственноручно написанных) исходников ли собирал он свою первую Linux-систему? Впрочем, разработчики Free- и NetBSD также были вынуждены воссоздавать свои системы с нуля после запрета использования кода System V в BSD4.4...
</p>

<h2>
Постановка проблемы
</h2>

<p>
Как собирать Linux из исходников? Тут возникает извечная проблема курицы и яйца. Действительно, чтобы собрать компилятор, нужно как минимум иметь компилятор, а чтобы собрать шелл - требуется этот
компилятор запустить (из командной строки шелла, разумеется). А и то, и другое требует библиотечных функций из главной системной библиотеки <code>glibc</code>. Которую, как нетрудно догадаться, также следует предварительно скомпилировать. Иными словами, как говорил мой бывший любимый начальник, "чтобы сварить суп из курицы, нужно как минимум иметь
курицу". Что в данном случае означает - чтобы собрать работоспособную Linux-систему, ее уже нужно иметь в установленном (и работоспособном) виде.
</p>

<p>
Получается заколдованный круг, выход из которого - не столь очевиден. Линус на заре создания своей ОС решил эту систему просто: первые варианты Linux'а собирались под управлением другой операционной системы (волею судеб ею оказалась Minix знаменитого теоретика
осестроения Энди Таненбаума). Однако ныне можно обойтись без этого, собирая Linux из Linux'а же.
</p>

<p>
Этим путем пошли и Герард, и Джонатан. То есть имея работоспособную Linux-машину в произвольном исполнении и полный набор исходников base Linux. Установленный дистрибутив может быть любым (при условии
достаточной свежести компилятора <code>gcc</code> и библиотеки <code>glibc</code>, прочие компоненты не столь критичны). Ну и ядро родительской системы должно
поддерживать все опции, желательные для системы дочерней (в первую очередь файловую систему, на которой предполагается разместить корень ее файловой иерархии).
</p>

<p>
По первоначальному методу Герарда сначала собирается (на отдельном дисковом разделе) некий самодостаточный минимум - <code>bash</code>, <code>gcc</code>, <code>binutils</code> и т.д., причем - статически слинкованные. Далее выполняется операция <code>chroot</code> и посредством этих программ собирается библиотека glibc. А потом - перекомпилируется, уже в динамически связанном виде, все ранее собранное хозяйство, плюс дособирается остальное из base Linux, ядро системы и средства загрузки. Причем позднее он перешел на двухэтапную сборку (т.н. метод pure LFS).
</p>

<p>
Основная трудность здесь - в сборке библиотеки <code>glibc</code>: если она завершится успешно, с остальными компонентами также все будет в (относительном) порядке. Однако именно в этом-то деле успех (по причинам, о которых речь пойдет в одной из следующих частей) и не гарантирован. Так что Джонатан вообще отказывается от этого шага, предлагая просто перенести бинарный пакет <code>glibc</code> родительской в дочернюю и установить его обычным для прекомпилированных пакетов образом.
</p>

<p>
Собственно говоря, основная заслуга Герарда, на мой взгляд, в разработке идеологически чистого метода сборки <code>glibc</code>, осуществляемого с
помощью разработанных им специальных патчей. Однако метод этот жестко привязан к версии главной системной библиотеки: текущие патчи его, как правило, не работают с более свежими версиями <code>glibc</code>.
</p>

<p>
Мне же хотелось осуществить самострой системы а) идеологически чисто (то есть без заимствования компонентов родительской системы, б) из базовых компонентов произвольных (то есть наиболее свежих на текущий момент) версий (ведь не секрет, что многие из них обновляются достаточно часто), и, главное, в) на чистую машину. Не то чтобы у меня на винчестере не было какого-либо Linux'а. Более того, я даже осуществил самосбор, используя в разное время различные дистрибутивы (Gentoo, CRUX, Archlinux)
дистрибутив в качестве родительских, - и осуществил успешно. Но вследствие этого успеха появилось желание разработать общий метод самосбора действительно с нуля (в том числе и на только что купленный компьютер).
</p>

<p>
Проблема казалась неразрешимой. Тут настало время вспомнить, как злые языки в нашей Партии (не подумайте плохого - геолого-поисковой) трактовали цитировавшуюся выше сентенцию нашего начальника. А толковали они ее в том смысле, что минимальным системным требованием для куриного супа является все же кошка. И, дабы "зарамсить проблему", я занялся поисками такой кошки.
</p>

<p>
Интуитивно было понятно, что собрать систему с нуля на голой машине можно было бы с помощью какого-либо LiveCD дистрибутива из числа расплодившихся в последнее время. Однако в большинстве из них
декларировались в первую очередь легкость настройки и совместимость с оборудованием, а отнюдь не изобилие инструментальных средств. Однако и подходящий LiveCD нашелся быстро - некто lonix, сам собранный на базе
LFS, о котором не так давно было рассказано на <a href="sb004.html">этих страницах</a>. Он комплектовался не только полным сборочным инструментарием, но и средствами настройки доступа к Сети - как через локалку, так (что было важно в моих условиях) и по модему: на тот случай, если в ходе сборки понадобится докачать какую-нибудь забытую мелочь.
</p>

<p>
Таким образом, Lonix идеально подходил на роль слесарного чемоданчика. Однако для этой цели подошел бы, вероятно, и knoppix. А также многие из более современных Live-систем...
</p>

<h2>
Выбор компонентов
</h2>

<p>
Это - второй вопрос системного самостроя. Очевидно, что в такой системе, как в рюкзаке хорошего туриста, не должно быть ничего лишнего (на то десятидисковые дистрибутивы имеются), но все необходимое - должно быть. То есть содержимое моего рюкзака должно обеспечивать не только загрузку системы, но и средства для ее наращивания, а также решения насущных практических задач. В результате сложился (пока у меня
в голове) некоторый самодостаточный набор, который можно назвать <a href="base001.html">Base Linux</a>.
</p>

<p>
Base Linux естественным образом распадается на две части - обязательную, необходимую для сборки системы и ее запуска, и опциональную, обеспечивающую минимальную пользовательскую функциональность. Хотя четкой границы между ними нет - многие утилиты для работы с файлами и текстами, обязательные для выполнения установочных сценариев, вполне могут использоваться и в мирных целях
(то есть для решения пользовательских задач, в том числе и весьма сложных). А такое пользовательское приложение, как текстовый редактор, практически незаменимо не только при начальном конфигурировании
системы, но и ее компиляции.
</p>

<p>
В свою очередь, непременные компоненты также можно разделить на безальтерантивные и те, для которых возможен выбор из нескольких вариантов. В число первых попадают ядро Linux (еще бы - если бы у бабущки был... сами знаете что, она звалась бы дедушкой) и тесно
связанный с ним комплекс утилит управления дисковыми разделами (<code>linux-utils</code>), загружаемыми модулями (<code>modutils</code>), обязательно
задействуемыми  файловыми системами (ext2fsprogs, procinfo и родственными, чисто волюртаристически я включил бы сюда и devfsd - без файловой системы устройств нынче не житье). Фактически нет выбора и для
инструментов работы с файлами, от <code>fileutils</code> (в то время этот пакет еще не слился с <code>sh-utils</code> и <code>textutils</code> в единый <code>coreutils</code>) до архиватора <code>tar</code> и компрессоров <code>gzip</code> и <code>bzip2</code> (причем последние два - не альтернатива, а неизбежность), утилит обработки текстов (<code>grep</code>, <code>gawk</code>, <code>sed</code>, <code>diffutils</code>,
<code>patch</code> - в данном контексте они выступают как средства обеспечения работы установочных сценариев), базовых средств поддержки сети (<code>netkit</code> и т.д.). Ну и конечно инструментарий собственно для сборки (<code>gcc</code>,
<code>binutils</code>, <code>make</code> и тому подобный) плюс основные системные библиотеки (от
<code>glibc</code> до <code>ncurses</code> и <code>zlib</code>).
</p>

<p>
Альтернативно-обязательные компоненты определяются пользовательскими предпочтениями и потребностями. Среди них в первую очередь упомяну патчи ядра для расширения его функциональности. Далее - инструментарий для работы с файловыми системами, отличными от ext2fs, начиная с той же xfsprogs и
заканчивая системами управления логическими томами (пакеты <code>lvm-user</code> и <code>evms</code>) и программными raid-массивами, пакеты управления консолью (традиционный выбор между <code>kbd</code> и
<code>console-tools</code>), средства управления системными сообщениями (<code>sysklogd</code> или его более продвинутые аналоги типа <code>metalog</code>) и контроля над пользовательскими аккаунтами (впрочем, в Linux этой цели обычно служит пакет shadow).
</p>

<p>
Как ни странно, достаточно альтернативен и выбор средств обеспечения загрузки системы, начиная с собственно загрузчиков (GRUB или LILO, не говоря уже о сторонних), и заканчивая системами инициализации: конечно, в Linux обычно традиционно используется пакет sysvinit (стартовая система в стиле System V), но никто ведь не может запретить и старт в BSD-стиле.
</p>

<p>
Наконец, последний штрих к обязательному натюрморту - командная оболочка (шелл, по простому). Здесь теоретически также не обязательно замыкаться на <code>bash</code>, можно бы взять любую POSIX Shell-совместимую. Однако на практике весь процесс сборки Linux оказывается настолько тесно завязанным именно на bash-скриптинг, что альтернативный выбор
выходит себе дороже (не зря же это была одна из первых программ, которую Линус запустил на своем ядре).
</p>

<p>
Что касается опциональной части Base Linux, то здесь по определению альтернативно все. Начать с наипервейшего пользовательского приложения - текстового редактора: для целей конфигурирования вполне можно ограничится чем-то предельно простым, типа <code>nano</code>. Если же требуется вся мощь системы обработки текста - на очереди будет скорее всего <code>vim</code> (к тому же - стандарт для всех Unix-систем вообще). Ну, а из промежуточных решений - я лично обеими руками за <code>joe</code>.
</p>

<p>
Далее потребуются: ftp-клиент для скачивания исходников (как же иначе наращивать мускулы), текстовый браузер и почтовый клиент для
коммуникабельности, программа дозвона при модемном соединении. Каждой из этих целей служит достаточно широкий спектр приложений, перечислять которые было бы неуместно.
</p>

<p>
В итоге мы получаем список чуть более чем в полсотни пакетов, общий объем которых укладывается в сотню мегабайт. Их можно скачать заблаговременно. А можно, поскольку, как я уже сказал, Lonix позволяет настроить подключение к Сети, тянуть и по ходу дела. Возникает вопрос - какие версии? На мой взгляд - самые свежие из стабильных (или самые стабильные из свежих:-)). Правда, в этом случае схема установки LFS Герарда не сработает в полной мере (она довольно жестко привязана к версиям пакетов), и в нетривиальных ситуация придется искать собственное решение, но не это ли - самое интересное?
</p>

<p>
Так что остается засучить рукава и приступить к работе. Но сначала - важное предупреждение: будьте готовы уделить этому занятию достаточное количество времени. Даже если все пойдет как надо (а по первому разу на такое можно только надеяться, но никак не следует рассчитывать), сам по себе процесс компиляции займет несколько часов чистого времени на мощной машине. И не говорите, что вас не предупреждали...
</p>

<h2>
А на кой все это?
</h2>

<p>
Возможно, с этого следовало бы начать, но лучше поздно, чем никогда: прежде чем провести в сборке целый день (при не самом худшем раскладе), стоит задаться вопросом, а за каким это нужно?
</p>

<p>
Действительно, существует немалое количество прекрасных пакетных дистрибутивов, на инсталляцию которых в полном объеме нынче (с настройками) уходит меньше времени, чем на установку Windows. Есть и
дистрибутивы Source Based, их развертывание требует несколько большего времени, но зато позволяет держать процесс (почти) под полным контролем. Стоит ли тратить время на собирание очередного велосипеда? Да еще и без гарантии (по первому разу, по крайней мере) адекватного
затраченным усилиям результата...
</p>

<p>
Навязывать свое мнение не буду (а мой ответ, как легко догадаться, сугубо положительный). Просто постараюсь перечислить резоны, которые могут подвигнуть на системный самострой.
</p>

<p>
Первый резон очевиден: создание системы, в которой будет установлено только то, что нужно именно вам, и только так, как это для вас подходит. Ибо ни один из существующих дистрибутивов не обходится без того, чтобы добавить хоть что-нибудь от себя (хотя в Source Based дистрибутивах отсебятина сведена к практически достижимому минимуму).
</p>

<p>
Второй резон - чисто познавательный. Сборка системы - самый эффективный (хотя и самый трудоемкий) способ понять ее внутренности и их взаимосвязи. Уже просто процесс подбора компонентов дает в этом плане больше, чем чтение любых руководств. Сужу по себе: только после
первой сборки я наконец осознал, что Linux - это некое системное единство, а не конгломерат из ядра и утилит GNU, как его подчас трактуют.
</p>

<p>
Ну и последнее по счету - спортивный интерес. Хотя по значению этот резон я поставил бы на первое место. Ибо без него все остальные просто теряют силу.
</p>

<h2>
Об источниках и исходниках
</h2>

<p>
В первом варианте этих заметок я явно недостаточно уделил внимание а) источникам информации о
системном самострое и б) принципам подбора пакетов. Задним числом исправляю упущение.
</p>

<p>
Для начала хотел бы подчеркнуть, что LFS Book Герарда - не догма, а руководство к действию (предваряемому размышлениями). По крайней мере, мне кажется, что автор рассматривал ее именно так. Действительно, мало
радости, затратив полные астрономические сутки (а именно столько уйдет на самострой работоспособной системы при самом благоприятном расположении звезд), получить в точности то же самое, что получил Герард (или кто угодно другой) - тогда уж проще развернуть за считанные минуты тот же CRUX. Ибо суть самостроя - реализовать собственные представления об идеальной Linux-системе.
</p>

<p>
Во всяком случае, именно такой позиции придерживается уже сформировавшееся LFS community - это те, кто каждый собирает свой собственный Linux. И результатами своих изысканий члены его регулярно делятся посредством т.н. <a href="http://www.linuxfromscratch.org/hints">намеков</a> - такой перевод слова <em>hints</em> кажется мне наиболее удачным в данном случае. Здесь можно найти намек на то, как прикрутить к файловую систему devfs, как мигрировать на XFS, как использовать GRUB вместо
LILO, и многое, многое другое. В частности, для ярых нелюбителей SysV стиля (к коим отношу и себя), - как заменить Герардовский <code>bootscripts</code> на <code>BSD init</code>. Немало там можно найти и об особенностях установки отдельных приложений на голый base Linux.
</p>

<p>
Раз уж речь зашла о devfs - должен заметить, что <code>MAKEDEV</code> Герарда работает не во всех случаях. В то же время подключение в ядре файловой
системы устройств и ее автомонтирование при старте прошло у меня безошибочно.
</p>

<p>
Об ошибках при компиляции отдельных пакетов... Я собирал самостройный Linux несколько раз, используя как материнскую систему и Gentoo Linux, и Lonix (LiveCD, сам собранный по мотивам LFS), и CRUX. И, по моим наблюдениям, ошибки сборки а) жестко привязаны к конкретным версиям пакетов), и б) особенностям материнской системы (вероятно, к тому, как в ней собрана <code>glibc</code>). Так, из Gentoo мне не удалось собрать <code>fileutils</code>, причем не
статически (об этом Герард предупреждает, и даже соответствующий патч у него есть), а именно динамически. Вернее, собираться-то они собирались,
но при попытке дать команду <code>ls</code> появлялось сообщение об ошибке сегментации. И потому пришлось поначалу пользовать статически собранные версии первой стадии.
</p>

<p>
Так вот, для полного предотвращения воздействия <code>glibc</code>'а материнской системы в hint'ах можно найти метод сборки "чистого" (pure, по
утверждению авторов, неких Райана Оливера и Грега Шафера) LFS. Правда, при <a href="http://hints.no.linuxfromscratch.org/hints/pure_lfs.txt">знакомстве с ним</a> вспоминается анекдот про удаление гланд через... ну, сами знаете, через что, но - опять же по заявлению авторов, - работает (самому проверить пока не удалось). И, замечу задним числом, в текущих (5.X) версиях LFS Book именно метод pure LFS принят в качестве канонического.
</p>

<p>
Ну и о выборе пакетов... Канонический набор Герарда можно, с одной стороны, спокойно урезать за счет <code>ed</code>, <code>bin86</code>, <code>MAKEDEV</code>, а как показывает пример CRUX - и за счет <code>Texinfo</code> (info-документация, по моему скромному мнению, есть самое GNU'тое изобретение мрачных бородатых GNU-хакеров). С другой стороны, он (опять же ИМХО) должен быть расширен инструментарием для работы с файловыми системами, отличными от ext2fs,
и, конечно же, логическими томами (LVM) - гораздо проще создавать файловые системы типа <code>/usr/(local)</code>, <code>/opt</code>, <code>/var</code> или <code>/home</code> сразу на
логике, чем потом заниматься их переносом. Опять же, devfs, на мой взгляд, ныне - абсолютно необходимый компонент Base Linux (попробуйте без нее регулярно работать с USB-накопителями). И, конечно же, замена
для <code>vim</code> может быть любой - при условии, что это будет <code>joe</code> :-)(любой другой редактор потянет за собой дополнительные библиотеки).
</p>

<p>
Это я все к тому, что Base Linux - такая же системная целостность, как и Distributions FreeBSD. И должна включать в себя все то, что необходимо любому пользователю Linux, и исключать - то, что должно
выбираться в индивидуальном порядке (или - отдаваться на откуп составителям дистрибутивов).
</p>

<p>
Так что можно выделить две составляющие успеха Linux-самостроя: 1) внимательное чтение предшественников (включая hint'ы) и 2) собственные
размышления о том, какой бы вы хотели видеть идеальную систему.
</p>

<h2>Этапы большого пути</h2>

<p>
Итак, необходимость самостройного Linux'а осознана, конецепция сборки (в первом приближении) обдумана, пакеты собраны, LiveCD вставлен в привод, руки тянутся к трем сакраментальным клавишам для перезагрузки машины. Однако - по рукам себе, по рукам: прежде
необходимо наметить план дальнейших мероприятий.
</p>

<p>
А план этот, подобно советской пятилетке, сводится к следующим этапам, назовем их: начинальник, продолжальник, определяльник, решальник и завершальник (почти как в старом анекдоте - правда, без субботника и воскресника).
</p>

<p>
Начальный этап - выполнение комплекса подготовительных действий типа создания дисковых разделов и файловых систем на них, их монтирования, развертывания файловой структуры, получения и (или) размещения исходников и т.д.
</p>

<p>
Продолжением этого становится довольно нудный процесс компиляции некоего минимума пакетов. Пакеты собираются в статически связанном виде, то есть разделяемые функции (из <code>glibc</code> и тому подобных библиотек) встраиваются непосредственно в исполняемые бинарники, а не подгружаются по мере надобности. В результате пакеты разбухают в объеме и становятся
неповоротливыми. Однако это - единственная возможность обеспечить их функционирование на третьем, определяющем, этапе.
</p>

<p>
А назван третий этап определяющим потому, что от него зависит успех или провал всей операции. Он начинается с процедуры т.н. смены корня (что это такое - расскажу своевременно) и завершается сборкой главной системной библиотеки <code>glibc</code>.
</p>

<p>
Четвертый этап - решающий, в ходе его будет собран и установлен должным образом почти весь набор Base Linux.
</p>

<p>
Наконец, пятый этап - завершающие (но очень ответственные) штрихи, призванные обеспечить загрузку новообразованной системы.
</p>

<p>
Вот теперь все цели ясны, задачи определены. За работу, товарищи!
</p>

<h2>
Начало всех начал
</h2>

<p>
Абу Талиб сказал: все имеет свое начало, и все начинается с дороги. В нашем случае первый шаг по этой дороге - разметка диска.
</p>

<p>
Собственно, ничего необычного тут нет - стратегия и тактика разбиения диска описывалась на <a href="base006.html">этих страницах</a>.
Два обязательных раздела - корневой и под своппинг. Необходимый объем для установки Base Linux (включая архивы исходников, место для временной их распаковки, и так далее) превышает полтора гигабайта. Плюс некий запас свободного пространства (как известно, производительность файловых операций в любых Unix-системах резко деградирует, если объем такового падает ниже 10%) - итого 2 Гбайт абсолютного минимума. Ну а swap-раздел - стандартно, между 128 Мбайт и 2 Гбайт (рекомендуется - удвоенный объем ОЗУ).
</p>

<p>
Впрочем, своя рука - владыка, и мы имеем возможность гибкого варьирования разделов. Например, можно создать маленький загрузочный раздел под <code>/boot</code> - это настоятельно рекомендуется, если в планах у нас
использование <strong>GRUB</strong> в качестве начального загрузчика (а в моих планах - всегда именно так, никаких преимуществ перед ним у Lilo нынче не
осталось).
</p>

<p>
Далее, и корневой раздел можно сделать не очень большим, выделив из его состава такие каталоги, как <code>/var</code>, <code>/usr/X11R6</code>, <code>/usr/local</code> и <code>/opt</code>. Последние три раздела в данном случае очень даже целесообразно
обособить, ведь именно в них будет по умолчанию устанавливаться весь софт из числа Base Linux inside - мы же не для того собираем собственную систему, чтобы ограничится спартанскими минимумом обязательных компонентов. С другой стороны, в обособлении раздела под <code>/usr</code> в данном случае не видно резона - ведь большая часть Base Linux соберется именно в нем, после чего он станет своего рода read only. При
большом объеме оперативной памяти нет необходимости и в отдельном разделе под <code>/tmp</code> - лучше будет в дальнейшем подмонтировать в него файловую систему tmpfs. Ну и конечно, каталог <code>/home</code> всегда должен лежать в отдельной патриции, это следует затвердить, как догмат веры.
</p>

<p>
С файловыми системами - также никакой специфики, выходящей за рамки <a href="base007.html">ранее описанного</a>.
Для раздела под <code>/boot</code> практически обязательна классика жанра - ext2fs. Под корень, если сделать его небольшим, также рекомендуется отвести (не
извести) ext2fs или, для страховки, ее журналируемый вариант ext3fs. Файловые системы на прочих разделах - в соответствии с пристрастиями, потребностями и возможностями. Так, XFS не поддерживалась в то время каноническим ядром и, соответственно, дистрибутивом Lonix - но она и целесообразна для (очень) больших разделов, например, под <code>/home</code>, который на этом этапе отнюдь не обязательно задействовать.
</p>

<p>
Теперь раздел, которому суждено стать корневым в нашей грядущей системе, следует подмонтировать к Live файловой системы, загруженной с нашего CD. Создав предварительно для этого соответствующую точку монтирования (в Lonix для этой цели служит каталог <code>/fake/needwrite</code> - прочие ветви файловой системы отнюдь не Live, а, напротив, очень даже
read only). Ну и переходим в этот раздел - например, <code>cd
/fake/needwrite/basix</code>.
</p>

<p>
Следующий шаг - развертывание файловой иерархии, что мы будем делать более-менее в соответствии с заветами документа, описывающего одноименный стандарт - Filesystem Hierarchy Standard (благодаря Виктору Костромину мы имеем возможность ознакомиться с ним и <a href="http://rus-linux.net/MyLDP/file-sys/fhs-2.2-rus">по русски</a>). А именно: в корне создаем файлового древа создаем каталоги
</p> 

<pre>
$ mkdir bin boot dev etc \
	home lib mnt opt root \
	sbin usr/{X11R,local} var
</pre>

	
<p>
Напомню - все пути даются относительно точки монтирования будущего корневого раздела, в данном примере - <code>/fake/needwrite/basix</code>. Далее, при необходимости, подмонтируем к соответствующим точкам - <code>opt</code>, <code>tmp</code>, <code>usr/{X11R,local}</code>, <code>var</code>, - предопределенные для них разделы:
</p>

<pre>
$ mount /dev/hd?# opt
</pre>

<p>
и так далее. В каталогах <code>usr</code>, <code>usr/X11R</code>, <code>usr/local</code> развертываем их внутреннюю иерархию - с подкаталогами <code>~/bin</code>, <code>~/etc</code>, <code>~/include</code>, <code>~/lib</code>, <code>~/sbin</code>, <code>~/share</code>, <code>~/src</code> и еще глубже (типа <code>~/share/man</code>, <code>~/share/man/man1</code> и так далее).
</p>

<p>
Проделываем ту же процедуру для каталога <code>opt</code> - здесь согласно стандарту следует выполнить нечто вроде
</p>

<pre>
$ mkdir opt/{bin,doc,include,info,lib,man}
</pre>

<p>
Далее - каталоги <code>var</code> и <code>tmp</code>. В первом случае нам потребуются подкаталоги
</p>

<pre>
$ mkdir var/{cache,lib,local,lock,log,opt,run,spool}
</pre>

<p>
А вот каталог <code>tmp</code> оставляем пустым - просто как точку монтирования для грядущей tmpfs после того, как будет собрано ядро с поддержкой оной.
</p>

<p>
Теперь создаем символические ссылки - минимум одна, <code>usr/tmp -&gt; var/tmp</code>, нам потребуется:
</p>

<pre>
ln -s var/tmp usr
</pre>

<p>
Наконец, изменяем атрибуты доступа для каталога <code>/root</code> - он должен быть закрыт для доступа обычных пользователей:
</p>

<pre>
$ chmod 0750 root
</pre>
 

<p>
То же - для хранилищ временных файлов: в них, напротив, любой пользователь должен иметь возможность записи, но не - удаления чужих файлов. Последнее достигается установкой дополнительного бита суидности:
</p>

<pre>
$ chmod 1777 tmp var/tmp
</pre>

<p>
Теперь можно приступить к развертыванию архивов исходников, предварительно скачав их из сети и разместив в каком-либо подходящем
каталоге (например, <code>usr/src</code> - но обязательно в дереве каталога <code>basix</code>).
Создаем каталог под собственно дерево исходников (скажем, <code>usr/src/tmp</code>) и переходим в него. Для статической сборки второго этапа все программы
Base Linux нам не потребуются. Поэтому разворачиваем только необходимый минимум: <code>bash</code>, <code>gcc</code>, <code>make</code>, <code>binutils</code> и еще несколько (общим числом 18 - в него обязательно должен входить выбранный текстовый редактор). На этом подготовительный этап самостроя системы можно считать законченным.
</p>

<h1>
Продолжение банкета
</h1>

<p>
Как я уже говорил, продолжальник, в полном соответствии со своим названием, - это нудный этап однообразной (ну ладно, дву-образной) статической сборки некоторого количества пакетов. Цель этого этапа - разрешить пресловутую проблему курицы для супа, создав своего рода ее суррогат (ту самую кошку): набор статически скомпилированных программ, в исполнимые файлы которых встроены все необходимые библиотечные
функции. И, следовательно, способных функционировать автономно, вне материнской системы. Ведь разделяемые библиотеки с нашего LiveCD станут недоступными после того, как в начале третьего этапа мы проведем процедуру т.н. смены корня.
</p>

<p>
Чтобы статически связанные программы в дальнейшем не путались с нормально (то есть динамически) слинкованными (они будут собраны на одном из следующих  этапов), отведем для них специальный каталог в
дереве <code>/mount_point/basix</code> (будущем корне нашей системы), например, <code>static</code>. И предпишем, чтобы все именно в него помещались результаты компиляции.
</p>

<p>
Обе задачи - статическая линковка и размещение в каталоге <code>/mount_point/basix/static</code> для ряда наших программ достигаются указанием
соответствующих опций конфигурирования:
</p>

<pre>
$ ./configure --enable-static \ 						--prefix=/mount_point/basix/static
</pre>

<p>
Форма команды приведена в предположении, что мы находимся в корневом каталоге дерева исходников собираемой программы. Для некоторых программ
(из нашего статического набора это <code>binutils</code> и <code>gcc</code>) сборку рекомендуется выполнять из специально созданного каталога, изолированного от дерева исходников (типа <code>binutils-build</code> и <code>gcc-build</code>, соответственно). В этом случае после создания такого каталога следует перейти в него, а команда
конфигурирования примет вид вроде
</p>

<pre>
$ ../binutils-X.XX/configure [options]
</pre>

<p>
Однако многие из собираемых программ не реагируют на опцию конфигурирования <code>--enable-static</code> (это можно проверить по команде <code>./configure --help</code>). В этом случае, понятно, она опускается, а статическая линковка задается на стадии компиляции.
</p>

<p>
Некоторые программы могут потребовать включения или отключения дополнительных опций. Из последних особенно важна опция <code>--disable-nls</code>, поскольку поддержка национальных языков а) не нужна на этом этапе и б) часто вызывает проблемы в статически слинкованных пакетах.
</p>

<p>
Компиляция программ и установка их в соответствующие ветви каталога <code>basix/static</code> выполняются, как обычно, последовательностью команд
</p>

<pre>
$ make &amp;&amp; make install
</pre>

<p>
Для программ, не понимающих опции <code>--enable-static</code>, в строке make следует указать дополнительные флаги компиляции, предписывающие
статическую сборку, в большинстве случаев таковым выступает флаг <code>LDFLAGS=-static</code>, или:
</p>

<pre>
$ make LDFLAGS=-all-static
</pre>

<p>
Префикс также может указываться как флаг компиляции, например:
</p>

<pre>
$ make PREFIX=/mount_point/basix/static
</pre>

<p>
Порядок при сборке статически слинкованных пакетов значения не имеет. По завершении мы получаем в каталоге <code>static</code> нечто вроде слепка корня - с подкаталогами <code>bin</code>, <code>i686-pc-linux-gnu</code>, <code>include</code>, <code>info</code>, <code>lib</code>, <code>libexec</code>, <code>man</code>, <code>share</code>, <code>var</code>. Ну а дерево исходников, из которых все это
собиралось (то есть <code>usr/src/tmp</code>), лучше просто целиком удалить - собрать в нем же динамически связанные пакеты не рекомендуется.
</p>

<p>
Да, вот что. Герард настоятельно рекомендует выполнять статическую сборку от имени специально для того созданного пользователя, но не как администратор. В его Писании это вполне резонно - при элементарной
ошибке набора в указании префикса можно легко затереть важные файлы материнской системы. Если же в качестве последней выступает LiveCD, то необходимости в новом пользователе нет, это избавит от нескольких промежуточных действий.
</p>

<p>
И еще. Пожалуйста, не воспринимайте эту часть как руководство к действиям, которые описаны здесь в самом общем виде. Ибо, ей-же богу, не вижу смысла дублировать Герардово Писание или, паче того вывод
<code>./configure --help</code> для каждой программы. Так что именно к этим источникам и следует обратиться за деталями.
</p>

<h2>
Определяющий этап
</h2>

<p>
Для начала я должен извиниться перед читателями за некоторую скомканность изложения. Дело в том, что заметки эти были начаты до появления русского перевода LFS Book. И я собственно хотел в них совместить изложение рекомендаций Герарда с собственными
впечатлениями от этого увлекательного процесса. Однако неожиданно поймал себя на мысли, что чем к более конкретным вещам я перехожу, тем больше скатываюсь на пересказ LFS Book. Что теперь не интересно даже тем, кто не очень хорошо владеет английским. Поэтому по возможности именно конкретные детали я буду опускать. Если что покажется неясным - обращайтесь к первоисточнику, информация в нем практически
исчерпывающая. Хотя и касается лишь одного из возможных путей самостроя.
</p>

<p>
Определяющий этап самостроя - сборка главной системной библиотеки <code>glibc</code>. Однако прежде нам предстоит еще одно чрезвычайно ответственное дело - смена корневого каталога на <code>/mount_point/basix</code>, осуществляемая
командой <code>chroot</code>. Выполнив ее, мы остаемся наедине с нашими статически собранными программами, и на помощь материнской LiveCD-системы рассчитывать уже не сможем. А потому нам следует озаботится созданием
соответствуюшего окружения в новой среде обитания.
</p>

<p>
В этом окружении должны существовать: пути к исполнимым файлам относительно нового корня (то есть переменная <code>PATH</code>), и домашнему каталогу суперпользователя (переменная <code>HOME</code>), указание на тип терминала (переменная <code>TERM</code>), желательный вид приглашения командной строки (переменная <code>PS1</code>). Ну и о самой командной оболочке забывать не следует (ею на время будет <code>/static/bin/bash</code> - в отсчете от нового корня). Да и освободиться от прежнего окружения не помешает - дабы не путать новую шерсть со старой (это делается командой <code>/static/bin/env -i</code> - ясно, что она должна предществовать установке новых переменных). В итоге полная команда по смене корня приобретет вид вроде следующего:
</p>

<pre>
$ chroot /mount_point/basix/static/bin/env -i \
	HOME=/root TERM=$TERM PS1='u:w$ ' \
	PATH=/bin:/usr/bin:/sbin:/usr/sbin:/static/bin \
	/static/bin/bash --login
</pre>

<p>
Сборка собственной системы дает практически неограниченные возможности по ее оптимизации. Правда, Герард Бикманс делать этого не рекомендует во избежание проблем. Однако буде такое желание все же
возникнет - флаги оптимизации для компилятора <code>gcc</code> можно также определить в качестве переменных при смене корня, дабы потом каждый раз не вводить их вручную. Мой опыт показывает, что оптимизация под процессор (собиралось на Pentium 4) проходит безболезненно почти во всех случаях, немало способствуя итоговому быстродействию. Я использовал следующие значения флагов оптимизации:
</p>

<pre>
CFLAGS="-march=pentium4 -O3 -pipe \
	 -fomit-frame-pointer"
CXXFLAGS="$CFLAGS"
</pre>

<p>
При желании прибегнуть к более жестким флагам оптимизации настоятельно рекомендуется ознакомиться с документацией по <code>gcc</code>
наличной версии (ее можно найти <a href="http://www.gnu.org/software/gcc/onlinedocs/">здесь</a>).
</p>

<p>
Итак, вводим команду <code>chroot</code> со всеми ее атрибутами и ждем <strong>Enter</strong>. Все, мосты сожжены: на время окружающий мир за пределами каталога <code>basix</code> для нас как бы перестал существовать. Правда, выход в него возможен через другие виртуальные консоли - благо lonix поддерживает их аж шесть штук. Но, во избежание путаницы, на это лучше не полагаться. Да и необходимости в том не возникнет - если, конечно, все предществующие шаги были сделаны правильно.
</p>

<p>
Еще одно необходимое подгтовительное действие - монтирование файловой системы proc как разделяемой в соответствующий каталог будущей корневой файловой системы:
</p>

<pre>
$ mount proc /proc -t proc
</pre>

<p>Кроме того, вспоминаем, что не зря создавался нами каталог <code>/mount_point/basix/tmp</code> - очень не вредно было бы подмонтировать в него файловую систему tmpfs, если таковая поддерживается дром материнской
системы, это сдорово увеличит скорость компиляции (для небольших пакетов - в разы):
</p>

<pre>
# mount tmpfs /mnt/tmpfs -t tmpfs
</pre>

<p>
Теперь Герард рекомендует создать несколько символических ссылок - <code>/etc/mtab</code> -&gt; <code>/proc/mounts</code>, <code>/bin/bash</code> -&gt; <code>/static/bin/bash</code>, <code>/bin/sh</code> -&gt; <code>/static/bin/bash</code>. Не вижу причин не последовать его совету. Напомню только, что здесь и далее отсчет корня идет от того каталога, в который мы переместились командой <code>chroot</code>.
</p>

<p>
Вслед за этим создаются файлы <code>/etc/passwd</code> и <code>/etc/group</code> - командой <code>echo</code> или в текстовом редакторе (не зря же мы его также собрали статически. В первый заносится пока единственный аккаунт - для администратора (root), с символом <code>x</code> вместо пароля (он пока ни к чему). А состав групп - более или менее произвольный. Тот список групп, который дает Герард, используется его сценарием <code>MAKEDEV</code>, чтобы не
ломать голову, сделаем, как приказано. При желании же проявить самодеятельность нужно помнить, что в списке групп обязательно должна присуствтвовать  группа <code>tty</code> - иначе в дальнейшем не установятся
некоторые пакеты (в частности, <code>util-linux</code>).
</p>

<p>
Ну и собственно создание файлов устройств в каталоге <code>/dev</code>. Правда, мы же планируем использовать файловую систему devfs, которая создает
все необходимые устройства автоматически - однако без файлов устройств не обойтись на стадии сборки программ.</p>

<p>
Теперь - внимание, последний из подготовительных перед сборкой <code>glibc</code> шагов. Распаковываем (непосредственно в каталоге <code>/usr/src</code>) архив выбранной нами версии ядра системы, получая каталог вида <code>/usr/src/linux-2.6.XX</code>, делаем на него символическую ссылку <code>/usr/src/linux</code> -&gt; <code>/usr/src/linux-2.6.XX</code>.
</p>

<p>
Теперь т.н. заголовочные файлы ядра (header-файлы) следует скопировать туда, где они будут искаться при компиляции <code>glibc</code> (да и других пакетов тоже). Делать это следует очень внимательно, поэтому я
не буду приводить соответствующих команд во избежание опечаток - лучше просто обратиться к труду Герарда. Где заодно можно прочитать обоснование того, почему header'ы следует именно копировать, а не устанавливать на них символические ссылки.
</p>

<p>
Теперь можно заняться собственно <code>glibc</code>. Распаковываем архив (например, в каталог <code>/usr/src/tmp2</code>), переходим в новообразованный каталог <code>glibc-2.X.X</code> и распаковываем в нем <code>glibc-linuxthreads</code>. А теперь потребуется внести некоторые изменения в исходники. У Герарда для этого предназначен специальный патч, однако он, естественно, привязан к
конкретной версии <code>glibc</code>, мы же собраем ее произвольную (наиболее свежую на данный момент) версию. Так что придется вооружиться текстовым
редактором (именно поэтому я настаивал на его включении в набор статически собранных пакетов).
</p>

<p>
Необходимость модификации исходников обусловлена следующим. Во-первых, в нашей недоношенной chroot-системе пакета <code>glibc</code> еще нет - и
потому определение идентификатора пользователя по его имени (login'у) невозможно, а в исходниках <code>glibc</code> как аргумент команды <code>chown</code> фигурирует один пользователь (догадайтесь, како? - правильно, root). Так что все
упонминания root'а следует заменить на его ID - то есть на 0.
</p>

<p>
Далее, при установке <code>glibc</code> используется Perl, если таковой доступен, и сслыки на его местонахождение даны в виде переменной <code>$PERL</code>. Однако в нашем случае Perl именно недоступен, поэтому переменную следует заменить на абсолютный путь - <code>/usr/bin/perl</code>, в результате он при конфигурировании просто игнорируется.
</p>

<p>
Итак, ищем, где же имеют место быть скараментальные символьные последовательности:
</p>

<pre>
$ grep -R root *;
$ grep -R $PERL *
</pre>

<p>
Наперед скажу, что в той версии <code>glibc</code>, которая собиралась мной (2.3.1), да и в более ранних, слово <code>root</code> мы найдем в файле <code>login/Makefile</code>, а переменную <code>$PERL</code> - в файле <code>malloc/Makefile</code> (команды даются в предположении, что мы находимся в каталоге <code>glibc-2.3.X</code>). Так что открываем их в текстовом редакторе и зменяем соответствующие
вхождения, как сказано выше.
</p>

<p>
Все остальное выполняем в точном соответствие с заветами Герарда. Правда, он советует отключить флаги оптимизации, если таковые были ранее определены как переменные окружения. Однако, на мой взшляд, это
следует делать только в том случае, если сборка <code>glibc</code> закончилась ошибкой. Я уже говорил, что при тех флагах, которые были приведены в начале этого раздела, я собирал <code>glibc</code> неоднократно - и с неизменно превосходным результатом. Надеюсь, что и у вас все окончится благополучно. Но если нет - вспомнить об отключении флагов никогда не
поздно.
</p>


<div align="center">
<hr>
<font size="-1">
Обсуждение проекта
<br>
<a href="http://linuxforum.ru"><img src="../img/lbaner88.jpg" width="88" height="31" border="0"></a>
<br>
<!--Rating@Mail.ru COUNTER--><script language="JavaScript" type="text/javascript"><!--
d=document;var a='';a+=';r='+escape(d.referrer)
js=10//--></script><script language="JavaScript1.1" type="text/javascript"><!--
a+=';j='+navigator.javaEnabled()
js=11//--></script><script language="JavaScript1.2" type="text/javascript"><!--
s=screen;a+=';s='+s.width+'*'+s.height
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth)
js=12//--></script><script language="JavaScript1.3" type="text/javascript"><!--
js=13//--></script><script language="JavaScript" type="text/javascript"><!--
d.write('<a href="http://top.mail.ru/jump?from=683019"'+
' target=_top><img src="http://top.list.ru/counter'+
'?id=683019;t=135;js='+js+a+';rand='+Math.random()+
'" alt="Рейтинг@Mail.ru"'+' border=0 height=40 width=88/><\/a>')
if(11<js)d.write('<'+'!-- ')//--></script><noscript><a
target=_top href="http://top.mail.ru/jump?from=683019"><img
src="http://top.list.ru/counter?js=na;id=683019;t=135"
border=0 height=40 width=88
alt="Рейтинг@Mail.ru"/></a></noscript><script language="JavaScript" type="text/javascript"><!--
if(11<js)d.write('--'+'>')//--></script><!--/COUNTER-->
</font>
</div>

</body>
</html>