<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"> 
<html xmlns="http://www.w3.org/1999/xhtml"> 
  <head> 
    <meta http-equiv="Content-Type" content= 
    "application/xhtml+xml; charset=koi8-r" /> 
    <title> 
      5.3.&nbsp; 
    </title> 
    <link rel="stylesheet" href="../stylesheets/lfs.css" type="text/css" /> 
    <meta name="generator" content="DocBook XSL Stylesheets V1.65.1" /> 
    <link rel="stylesheet" href="../stylesheets/lfs-print.css" type= 
    "text/css" media="print" /> 
  </head> 
  <body id="lfs" class="6.0"> 
    <div class="navheader"> 
      <div class="headertitles"> 
        <h4> 
          Linux From Scratch - Версия 6.0 
        </h4> 
        <h3> 
          Глава&nbsp;5.&nbsp;Построение временной системы 
        </h3> 
      </div> 
      <ul class="headerlinks"> 
        <li class="prev"> 
          <a accesskey="p" href="hostreqs.html" title= 
          "Host System Requirements">Назад</a> 
          <p> 
            Требования к системе 
          </p> 
        </li> 
        <li class="next"> 
          <a accesskey="n" href="binutils-pass1.html" title= 
          "Binutils-2.15.91.0.2 - Pass 1">Далее</a> 
          <p> 
            Binutils-2.15.91.0.2 - Шаг 1 
          </p> 
        </li> 
        <li class="up"> 
          <a accesskey="u" href="chapter05.html" title= 
          "Глава&nbsp;5.&nbsp;Построение временной системы">Наверх</a>. 
        </li> 
        <li class="home"> 
          <a accesskey="h" href="../index.html" title= 
          "Linux From Scratch - Версия 6.0">В начало</a> 
        </li> 
      </ul> 
    </div> 
    <div class="sect1" lang="en" xml:lang="en"> 
      <div class="titlepage"> 
        <h1 class="sect1"> 
          5.3.  
        </h1> 
      </div> 
      <p> 
        Этот раздел предназначен для объяснения некоторых логических и 
	технических моментов рационального метода сборки. 
	Ничего страшного, если вы не поймете все, что написано здесь. Большая 
	часть из них имеет значение при выполнении сборки конкретных пакетов. 
	Вы можете вернуться сюда в любое время. 
      </p> 
      <p> 
        Основной целью <a href="chapter05.html">Главы 5</a> является подготовка 
	окружения для входа через chroot для создания полноценной системы в 
	 <a href="../chapter06/chapter06.html">Главе 6</a>. По ходу дела мы 
	 соберем, используя основную систему, самодостаточные средства. Это 
	 будет сделано для обеспечения минимального риска и максимальной 
	 независимости одновременно. Другими словами, мы соберем инструменты для 
	 сборки системы. 
      </p> 
      <div class="important"> 
        <div class="admonhead"> 
          <img alt="[Important]" src="../images/important.png" /> 
          <h3 class="admontitle"> 
            Важно 
          </h3> 
        </div> 
        <div class="admonbody"> 
          <p> 
            Перед дальнейшей работой вы должны знать название вашей платформы, 
	    которое также называется target triplet. В некоторых случаях target 
            triplet может быть, к примеру: <span class= 
            "emphasis"><em>i686-pc-linux-gnu</em></span>. Простейшим способом 
	    определения вашего target triplet является запуск скрипта 
            <span><b class="command">config.guess</b></span> который содержится 
            во многих пакетах. Распакуйте тарбол с исходниками Binutils, запустите 
            скрипт: <b class= 
            "userinput"><tt>./config.guess</tt></b> и запомните вывод. 
          </p> 
          <p> 
            Вам также необходимо знать имя динамичаского компоновщика для вашей 
	    платформы, его также называют динимическим загрузчиком 
            (не спутайте его со стандартным компоновщиком 
            <span><b class="command">ld</b></span> который является частью 
            Binutils). Динамический компоновщик является частью Glibc и служит 
	    для поиска и загрузки библиотек, в которых нуждается программа, 
	    подготовки программы к запуску и ее запуска. Как правило, динамический 
	    компоновщик называется <tt class="filename">ld-linux.so.2</tt>. 
            На некоторых не очень распространенных платформах он называется <tt class= 
            "filename">ld.so.1</tt>, а на некоторых 64-битных платформах - по другому. 
            Вы можете определить имя динамического компоновщика для вашей платформы,
	    заглянув в директорию <tt class="filename">/lib</tt> вашей основной
	    системы. Безошибочным способом проверки случайной библиотеки на вашей
	    основной системе является запуск: <b class="userinput"><tt>readelf -l 
            &lt;name of binary&gt; | grep interpreter</tt></b> и просмотр вывода. 
            Ссылка, описывающая все платвормы, находится в файле 
            <tt class="filename">shlib-versions</tt> в корне дерева исходников Glibc. 
          </p> 
        </div> 
      </div> 
      <p> 
        Некоторые технические моменты, которые позволяют методам сборки из 
	<a href="chapter05.html">Главы 5</a> работать: 
      </p> 
      <div class="itemizedlist"> 
        <ul> 
          <li> 
            <p> 
              Принципиальное сходство перекрестной компиляции, посредством чего
	      установленные средства работают с одним префиксом и, таким образом,
	      используют маленькое &ldquo;<span class= 
              "quote">волшебство</span>&rdquo; GNU. 
            </p> 
          </li> 
          <li> 
            <p> 
              Осторожная манипуляция путями поиска библиотек стандартным 
	      компоновщиком для того, чтобы убедиться, что программы были 
	      скомпонованы с использованием выбранных нами библиотек. 
            </p> 
          </li> 
          <li> 
            <p> 
              Осторожная манипуляция <tt class="filename">specs</tt>-файлом 
	      <span><b class="command">gcc</b></span> для передачи компилятору 
	      информации об используемом динамическом компоновщике. 
            </p> 
          </li> 
        </ul> 
      </div> 
      <p> 
        Binutils устанавливаются первыми потому, что GCC и Glibc выполняют 
	тестирование ассемблера и компоновщика во время запуска <span><b class= 
        "command">./configure</b></span> для определения того, какие настройки 
	программного обеспечения выбраны или отключены. Это очень важно при 
	первой реализации. Неверно сконфигурированые GCC и Glibc могут испортить 
	всю сборку средств и дистрибутив будет с ошибками. Благодаря тестированию 
	мы можем опрделить это своевременно. 
      </p> 
      <p> 
        Binutils устанавливают ассемблер и компоновщик в два места: 
        <tt class="filename">/tools/bin</tt> и <tt class= 
        "filename">/tools/$TARGET_TRIPLET/bin</tt>. Точнее, средства в одной 
	из директорий являются жесткими ссылками на другие. Очень важным для 
	компоновщика является порядок поиска библиотек. Точную информацию о нем 
	можно получить от <span><b class="command">ld</b></span> указав параметр 
	 <i class="parameter"><tt>--verbose</tt></i>. Например: <b class= 
        "userinput"><tt>ld --verbose | grep SEARCH</tt></b> покажет текущие пути 
	поиска и их порядок. Вы можете увидеть, какие файлы скомпонованы с помощью 
        <span><b class="command">ld</b></span> при компиляции программы-пустышки и 
	используя переключатель <i class="parameter"><tt>--verbose</tt></i>. 
        Например: <b class="userinput"><tt>gcc 
        dummy.c -Wl,--verbose 2&gt;&amp;1 | grep succeeded</tt></b> покажет 
        все файлы, удачно открытые в процессе компоновки. 
      </p> 
      <p> 
        Следующим пакетом мы установим GCC и в процессе работы 
        <span><b class="command">./configure</b></span> вы увидите, например: 
      </p> 
      <pre class="screen"> 
<tt class="computeroutput">checking what assembler to use...  
        /tools/i686-pc-linux-gnu/bin/as 
checking what linker to use... /tools/i686-pc-linux-gnu/bin/ld</tt> 
</pre> 
      <p> 
        Это важно по причинам, описаным выше. И это также показывает, что 
	скрипт конфигурации GCC не ищет в директориях $PATH какие средства 
	использовать. Тем не менее, текущий процесс 
	<span><b class="command">gcc</b></span> не использует эти пути поиска. 
	Вы можете определить, какой стандартный комполновщик <span><b class= 
	"command">gcc</b></span> используется, запустив: 
        <b class="userinput"><tt>gcc -print-prog-name=ld</tt></b>. 
      </p> 
      <p> 
        Детальная информация получается от <span><b class= 
        "command">gcc</b></span> добавлением параметра <i class= 
        "parameter"><tt>-v</tt></i> при компиляции. Например: 
        <b class="userinput"><tt>gcc -v 
        dummy.c</tt></b> покажет полную информацию о препроцессоре, компиляторе 
	и ассемблере, включая пути поиска 
        <span><b class="command">gcc</b></span> и другую информацию. 
      </p> 
      <p> 
	Следующим устанавливаемым пакетом будет Glibc. Наиболее важными 
	зависимостями сборки Glibc являются компилятор, средства для бинарных 
	файлов и заголовки ядра. Компилятор не представляет проблемы, Glibc 
	всегда использует <kbd class="userinput">gcc</kbd> из директории 
	$PATH. Бинарные средства и заголовки ядра могут привести к некоторым 
	проблемам. Поэтому мы не рискуем и используем переключатели 
	конфигурации для правильного выбора. После запуска <kbd class= 
	"userinput">./configure</kbd> вы можете проверить содержимое файла 
	<tt class="filename">config.make</tt> в директории <tt class= 
	"filename">glibc-build</tt> для получения информации. Вы будете 
	использовать некотоые интересные параметры, такие как <kbd class= 
	"userinput">CC="gcc -B/tools/bin/"</kbd>, которые определяют 
	используемые средства, а также флаги <em>-nostdinc</em> и 
	<em>-isystem</em> для контроля за путем поиска для компилятора. 
	Эти параметры показывают важный аспект пакета Glibc: он не 
	обязательно полагается на средства по умолчанию.</p> 
      </p> 
      <p> 
	После установки Glibc мы создадим некоторые установки для того, 
	чтобы убедиться, что пути для поиска содержат только в директории 
	<tt class="filename">/tools</tt>. Мы установим откорректированный 
	<kbd class="userinput">ld</kbd>, в котором будет жестко указан путь 
	поиска в <tt class="filename">/tools/lib</tt>. Задем мы исправим 
	specs-файл <kbd class="userinput">gcc</kbd> для указания на наш новый 
	динамический компоновщик в <tt class="filename">/tools/lib</tt>. 
	Этот последний шаг жизненно важен для нашего процесса. Как указано 
	выше, путь к динамическому компоновщику будет жестко вшит в каждый 
	исполняемый файл ELF. Вы можете убедиться в этом, запустив <kbd class= 
	"userinput">'readelf -l &lt;name of binary&gt; | grep interpreter' 
	</kbd>. Благодаря исправлению specs-файла <kbd class="userinput">gcc 
	</kbd>, мы убедимся, что все программы из оставшейся части <a href= 
	"../chapter05/chapter05.html">Главы 5</a> будут использовать новый 
	динамический комполовщик из <tt class="filename">/tools/lib</tt>. 
      </p> 
      <p> 
	Необходимость использования нового динамического компоновщика также 
	является причиной, по которой мы применяем Specs патч на втором этапе 
	сборки GCC. Опускание этого патча приведет к тому, что программы GCC 
	будут использовать системный динамический компоновщик из директории 
	<tt class="filename">/lib</tt> основной системы, а это будет означать 
	зависимость от основной системы. 
      </p> 
      <p> 
	В ходе второго шага сборки Binutils мы будем использовать переключатель 
	<em>--with-lib-path</em> для контроля пути поиска библиотек для 
	<kbd class="userinput">ld</kbd>. С этого момента все наши средства будут 
	самодостаточными. Остальные пакеты из <a href="chapter05.html"> 
	Главы 5</a> будут собраны с новым Glibc из <tt class="filename">/tools</tt>. 
      </p> 
      <p> 
	После входа в окружение chroot в <a href="../chapter06/chapter06.html"> 
	Главе 6</a>, мы первым делом установим Glibc по вышеописаным причинам. 
	Теперь Glibc будет установлен в <tt class="filename">/usr</tt> и мы 
	будем использовать средства по умолчанию для сборки остальных пакетов 
	для LFS системы. 
      </p> 
      <div class="sect2" lang="en" xml:lang="en"> 
        <div class="titlepage"> 
          <h2 class="sect2"> 
            5.3.1. О статической компоновке 
          </h2> 
        </div> 
        <p> 
	Многие программы выполняют помимо своей основной задачи и многие 
	другие операции. Это включает распределение памяти, поиск директорий, 
	четение и запись файлов, манипуляции со строками, использование 
	шаблонов, арифметические операции и многое другое. Вместо того, чтобы 
	включать все это в программу, GNU система поддерживает простые функции 
	в библиотеках. Самой главной из них для любой Linux системы 
	является Glibc. 
        </p> 
        <p> 
	Есть два варианта использования библиотечных функций: статически и 
	динамически. Когда программа скомпонована статически, код используемых 
	функций включается в программу и она становится более громоздкой. 
	Когда же программа скомпонована динамически, в программу включаются 
	только ссылка на динамический компоновщик, имя библиотеки и имя 
	функции, в результате мы получаем более маленький исполняемый файл. 
	(Есть еще третий путь - использование программного интерфейса для 
	динамического компоновщика. Смотрите мануал по <span class="emphasis"> 
	<em>dlopen</em></span> для более полной информации.) 
        </p> 
        <p> 
	Динамическая компоновка является компоновкой по умолчанию в Linux и 
	имеет три главных преимущества перед статической компоновкой. Первое: 
	вам достаточно иметь только одну копию исполняемого кода библиотеки на 
	жестком диске в отличие от нескольких копий в каждом исполняемом 
	файле в противном случае - вы экономите место на диске. Второе: когда 
	несколько программ используют одну и ту же библиотечную фунцию 
	одновременно, только одна копия этой функции находится в памяти - вы 
	экономите оперативную память. Третье: если вы обнаружили ошибку в 
	функции, достаточно перекомпилировать одну библиотеку в отличие от 
	необходимости перекомпилировать все программы, использующие эту 
	функцию, в противном случае. 
        </p> 
        <p> 
	Если динамическая компоновка настолько лучше, то почему мы ее не 
	используем, а статически компонуем первые два пакета в этой главе? Есть 
	тройственная причина для этого: историческая, образовательная и 
	техническая. Историческая: потому что простейшая версия LFS статически 
	компонует все программы из этой главы. Образовательная: потому что надо 
	знать отличие между статической и динамической компоновкой. 
	Техническая: потому что мы получаем элемент независимости от основной 
	системы - наши программы не должны от нее зависеть, они должны иметь 
	возможность работать самостоятельно. Таким образом, если мы хотим 
	построить LFS систему, нам необходимо отказаться от динамической 
	компоновки первых двух пакетов. 
        </p> 
      </div> 
    </div> 
    <div class="navfooter"> 
      <ul> 
        <li class="prev"> 
          <a accesskey="p" href="hostreqs.html" title= 
          "Host System Requirements">Назад</a> 
          <p> 
            Требования к системе 
          </p> 
        </li> 
        <li class="next"> 
          <a accesskey="n" href="binutils-pass1.html" title= 
          "Binutils-2.15.91.0.2 - Pass 1">Далее</a> 
          <p> 
            Binutils-2.15.91.0.2 - Шаг 1 
          </p> 
        </li> 
        <li class="up"> 
          <a accesskey="u" href="chapter05.html" title= 
          "Глава&nbsp;5.&nbsp;Построение временной системы">Наверх</a>. 
        </li> 
        <li class="home"> 
          <a accesskey="h" href="../index.html" title= 
          "Linux From Scratch - Версия 6.0">В начало</a>. 
        </li> 
      </ul> 
    </div> 
  </body> 
</html> 
