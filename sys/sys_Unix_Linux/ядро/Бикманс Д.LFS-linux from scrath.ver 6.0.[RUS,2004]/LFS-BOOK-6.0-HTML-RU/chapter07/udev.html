<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content=
    "application/xhtml+xml; charset=koi8-r" />
    <title>
      7.4.&nbsp;Поддержка устройств и модулей в LFS системе
    </title>
    <link rel="stylesheet" href="../stylesheets/lfs.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.65.1" />
    <link rel="stylesheet" href="../stylesheets/lfs-print.css" type=
    "text/css" media="print" />
  </head>
  <body id="lfs" class="6.0">
    <div class="navheader">
      <div class="headertitles">
        <h4>
          Linux From Scratch - Версия 6.0
        </h4>
        <h3>
          Глава&nbsp;7.&nbsp;Установка системных скриптов загрузки
        </h3>
      </div>
      <ul class="headerlinks">
        <li class="prev">
          <a accesskey="p" href="usage.html" title=
          "How Do These Bootscripts Work?">Назад</a>
          <p>
            Как эти стартовые скрипты работают?
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="setclock.html" title=
          "Configuring the setclock Script">Далее</a>
          <p>
            Настройка скрипта setclock
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="chapter07.html" title=
          "Глава&nbsp;7.&nbsp;Setting Up System Bootscripts">Наверх</a>.
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - Версия 6.0">В начало</a>
        </li>
      </ul>
    </div>
    <div class="sect1" lang="en" xml:lang="en">
      <div class="titlepage">
        <h1 class="sect1">
          7.4. Поддержка устройств и модулей в LFS системе
        </h1>
      </div>
      <p>
        В <a href="../chapter06/chapter06.html">Главе 6</a> мы установили
        пакет Udev. Сначала мы детально расмотрим, как это работает и
        короткую историю предыдущих методов поддержки устройств.
      </p>
      <p>
        Системы Linux в основном традиционно используют метод создания статических
        устройств, из-за чего создается огромное количество нод устройств в директори
        <tt class="filename">/dev</tt> (иногда буквально сотни нод),
        не смотря на наличие соответствующих реальных аппаратных устройств.
        Это типично для работы скрипта <span><b class=
        "command">MAKEDEV</b></span>, который содержит большое количество вызовов
        к программе <span><b class="command">mknod</b></span> с уместными
        старшими и младшими номерами устройств для каждого возможного устройства,
        которое может существовать в мире. Используя метод udev, только те устройства,
        которые обнаружены ядром, получат ноды устройств, созданные для них.
        Поскольку эти ноды устройств будут создаваться при каждой загрузке системы,
        они будут сохраняться в <tt class="systemitem">ramfs</tt> (файловой системе,
        которая размещается непосредственно в памяти и не занимает места на диске).
        Ноды устройств не требуют много места на диске, поэтому используемая ими память
        незначительна.
      </p>
      <div class="sect2" lang="en" xml:lang="en">
        <div class="titlepage">
          <h2 class="sect2">
            7.4.1. История
          </h2>
        </div>
        <p>
          В феврале 2000 года новая файловая система, названная <tt class=
          "systemitem">devfs</tt>, была добавлена в ядро 2.3.46 и стала
          доступной в стабильных ядрах серии 2.4. Хотя сама она присутствовала в
          исходниках ядра, метод динамического создания устройств никогда не получал
          подавляющую поддержку разработчиков ядра.
        </p>
        <p>
          Основные проблемы к такому подходу, заимствованые <tt class=
          "systemitem">devfs</tt> - это способ поддержки определения,
          создания и именования устройств. Возможно, последняя проблема именования нод
          устройств была более критичной. Обычно принималось, что имена устройств
          доступны для конфигурации, затем политика именования устройств
          должна быть передана системному администратору, не навязана ему
          любым разработчиком. Файловая система <tt class=
          "systemitem">devfs</tt> также страдала от обстоятельств, связанных с ее
          разработкой, и не могла быть исправлена без обоснования пересмотра ядра.
          Для нее также не хватало новых разработчиков.
        </p>
        <p>
          С разработкой нестабильной ветки ядра 2.5, в конце выпущенной как
          серия 2.6 стабильных ядер, появилась новая виртуальная файловая система,
          названная <tt class="systemitem">sysfs</tt>. Работа <tt class=
          "systemitem">sysfs</tt> - это экспорт видимой для процессов системной
          структуры в пространстве пользователя. С таким пространством пользователя
          замена <tt class="systemitem">devfs</tt> стала более реальной.
        </p>
      </div>
      <div class="sect2" lang="en" xml:lang="en">
        <div class="titlepage">
          <h2 class="sect2">
            7.4.2. Внедрение Udev
          </h2>
        </div>
        <p>
          Файловая система <tt class="systemitem">sysfs</tt> была коротко
          упомянута выше. Одно может удивлять, как <tt class="systemitem">sysfs</tt>
          знала о присутствующих в системе устройствах и какие номера устройств
          должны быть использованы. Драйвера, которые были вкомпилированы прямо в
          ядро, регистрировали свои объекты при помощи <tt class=
          "systemitem">sysfs</tt>, поскольку они определялись ядром. Для драйверов,
          скомпилированных в виде модулей это произойдет после загрузки модулей.
          Как только файловая система <tt class="systemitem">sysfs</tt>
          примонтирована (в <tt class="filename">/sys</tt>), данные, встроеные
          в драйвера и зарегистрированные <tt class="systemitem">sysfs</tt>,
          становятся доступными для процессов пространства пользователя и для
          <span><b class="command">udev</b></span> для создания нод устройств.
        </p>
        <p>
          Стартовый скрипт <span><b class="command">S10udev</b></span> заботится
          о создании этих нод устройств во время загрузки Linux. Этот скрипт
          запускается с регистрацией <span><b class="command">/sbin/udev</b></span>
          в качестве руководителя событий hotplug (горячих подключений). События hotplug
          (обсуждаемые ниже) не должны быть генерированы на этом этапе,
          но <span><b class="command">udev</b></span> регистрируется только в случае,
          если они происходят. Затем программа <span><b class=
          "command">udevstart</b></span> проходит по файловой системе
          <tt class="systemitem">/sys</tt> и создает устройства в директории
          <tt class="filename">/dev</tt>, которые соответствуют описаниям.
          Например, <tt class="filename">/sys/class/tty/vcs/dev</tt>
          содержит строку &ldquo;<span class="quote">7:0</span>&rdquo;.
          Эта строка используется <span><b class="command">udevstart</b></span>
          для созданиия <tt class="filename">/dev/vcs</tt> со старшим номером
          <span class="emphasis"><em>7</em></span> и младшим <span class=
          "emphasis"><em>0</em></span>. Права доступа каждого из устройств,
          создаваемых <span><b class="command">udevstart</b></span>,
          устанавливаются, используя файлы в директории <tt class=
          "filename">/etc/udev.d/permissions.d/</tt>. Они пронуменованы
          в стиле, похожем на стартовые скрипты LFS. Если
          <span><b class="command">udev</b></span> не может найти файл с правами
          доступа для создаваемых устройств, то по умолчанию будут установлены права
          доступа <span class="emphasis"><em>600</em></span> и владелец
          <span class="emphasis"><em>root:root</em></span>. Имена созданных в
          директории <tt class="filename">/dev</tt> нод устройств сконфигурированы
          соответственно правилам, описанным в файлах в директории
          <tt class="filename">/etc/udev/rules.d/</tt>.
        </p>
        <p>
          Как только выше описанный этап выполниться, все присутствующие устройства
          и имеющие вкомпиливованные в ядро драйвера будут доступны для использования.
          А что с устройствами, имеющими модульные драйвера?
        </p>
        <p>
          Ранее мы описали концепцию &ldquo;<span class=
          "quote">поддержки событий hotplug</span>&rdquo;. Когда подключение
          нового устройства обнаружено ядром, ядро сренерирует событие
          hotplug и обратится к файлу <tt class=
          "filename">/proc/sys/kernel/hotplug</tt> для поиска программы,
          поддерживающей подключение устройств. Стартовый скрипт <span><b class=
          "command">udev</b></span> зарегистрирован <span><b class=
          "command">udev</b></span> в качестве такой программы. Когда эти события
          hotplug сгенерированы, ядро скажет <span><b class=
          "command">udev</b></span> проверить файловую систему <tt class=
          "filename">/sys</tt> для поиска информации, принадлежащей этому
          новому устройству, и создать для него объект в <tt class="filename">/dev</tt>.
        </p>
        <p>
          Это подводит нас к проблеме, которая присутствует с <span><b class=
          "command">udev</b></span>, а также перед ней с <tt class=
          "systemitem">devfs</tt>. Для нас это похоже на проблему
          &ldquo;<span class="quote">курицы и яйца</span>&rdquo;.
          Большинство Linux дистрибутивов поддерживают загрузку модулей через
          содержимое файла <tt class="filename">/etc/modules.conf</tt>. Доступ к
          нодам устройств вызывает загрузку подходящего модуля ядра. С
          <span><b class="command">udev</b></span> этот метод не будет работать,
          так как нода устройства отсутствует во время загрузки модуля.
          Для решения этой задачи в пакет lfs-bootscripts был добавлен загрузочный
	  скрипт <span><b class="command">S05modules</b></span> вместе с файлом
          <tt class="filename">/etc/sysconfig/modules</tt>. Добавив
          имена модулей в файл <tt class="filename">modules</tt>, эти модули
          будут загружены при старте компьютера. Это позволяет<span><b class=
          "command">udev</b></span> определить устройства и создать подходящие
          ноды устройств.
        </p>
        <p>
          Зметьте, что на медленных машинах или для драйверов, создающих много
          нод устройств, процессы создания устройств могут занять несколько
          секунд. Это означает, что некоторые ноды устройств могут не быть
          доступны немедленно.
        </p>
      </div>
      <div class="sect2" lang="en" xml:lang="en">
        <div class="titlepage">
          <h2 class="sect2">
            7.4.3. Поддержка динамических устройств и устройств с горячим подключением
          </h2>
        </div>
        <p>
          Если вы подключаете устройство, такое как Universal Serial Bus (USB)
          MP3 проигрыватель, ядро определяет, что устройство подключилось и
          генерирует событие hotplug. Если драйвер уже загружен (потому
          что он был вкомпилирован в ядро или был загружен как модуль через
          скрипт <span><b class="command">S05modules</b></span>), будет вызван
          <span><b class="command">udev</b></span> для создания уместной
          ноды устройства согласно данным <tt class="systemitem">sysfs</tt>,
          доступным в <tt class="filename">/sys</tt>. Если драйвер для только что
          подключенного устройства доступен в виде модуля, но в данный момент
          выгружен, то присоединение устройства к системе только вызовет
          драйвер шины ядра для генерации события hotplug, которое сообщает
          пространству пользователя о новом подключении устройства и
          присоединения к драйверу не будет. В результате ничего не происходит
          и само устройство еще не готово к использованию.
        </p>
        <p>
          Если для собираемой системы, имеющей много драйверов, исполнение их в виде
          модулей лучше, чем прямое встраивание в ядро, использование скрипта
          <span><b class="command">S05modules</b></span> может быть не практичным.
          Пакет Hotplug (смотрите <a href=
          "http://linux-hotplug.sourceforge.net/"><i>http://linux-hotplug.sourceforge.net/</i></a>)
          может быть более предпочтительным в этом случае. Когда пакет Hotplug установлен,
          он будет отвечать на вышеупомянутые события hotplug драйвера шины ядра.
          Пакет Hotplug загрузит подходящий модуль и сделает это устройство доступным
          созданием для него ноды(нод) устройства.
        </p>
      </div>
      <div class="sect2" lang="en" xml:lang="en">
        <div class="titlepage">
          <h2 class="sect2">
            7.4.4. Проблемы с созданием устройств
          </h2>
        </div>
        <p>
          Есть несколько известных проблем при автоматическом создании
          нод устройств:
        </p>
        <p>
          1) Драйвер ядра может не экспортировать свои данные для <tt class=
          "systemitem">sysfs</tt>.
        </p>
        <p>
          Это часто встречается с драйверами, не входящими в дерево ядра.
          Используйте файл конфигурации <tt class=
          "filename">/etc/sysconfig/createfiles</tt> для ручного создания
          устройств. Проконсультируйтесь в файле <tt class=
          "filename">devices.txt</tt> в документации ядра или в документации
          для этого драйвера для поиска правильных старших/младших номеров.
        </p>
        <p>
          2) Требуется не аппаратное устройство.
        </p>
        <p>
	    Это часто встречается с
          модулем совместимости Open Sound System (OSS) проекта Advanced
          Linux Sound Architecture (ALSA). Такой тип устройств может поддерживаться
          двумя способами:
        </p>
        <div class="itemizedlist">
          <ul>
            <li>
              <p>
                Добавлением имен модулей в <tt class=
                "filename">/etc/sysconfig/modules</tt>
              </p>
            </li>
            <li>
              <p>
                Используя строку &ldquo;<span class="quote">install</span>&rdquo;
                в <tt class="filename">/etc/modprobe.conf</tt>. Это говорит
                команде <span><b class="command">modprobe</b></span>
                &ldquo;<span class="quote">когда загружаеш тот модуль, также
                одновременно загрузи и этот другой модуль</span>&rdquo;.
                Например:
              </p>
              <pre class="userinput">
<kbd class="command">install snd-pcm modprobe -i snd-pcm ; modprobe \
    snd-pcm-oss ; true</kbd>
</pre>
              <p>
                Это заставит систему загружать оба модуля <span class=
                "emphasis"><em>snd-pcm</em></span> и <span class=
                "emphasis"><em>snd-pcm-oss</em></span> когда сделан запрос
                для загрузки драйвера <span class="emphasis"><em>snd-pcm</em></span>.
              </p>
            </li>
          </ul>
        </div>
      </div>
      <div class="sect2" lang="en" xml:lang="en">
        <div class="titlepage">
          <h2 class="sect2">
            7.4.5. Полезное чтение
          </h2>
        </div>
        <p>
          Дополнительная полезная документация доступна на следующих сайтах:
        </p>
        <div class="itemizedlist">
          <ul>
            <li>
              <p>
                Реализация devfs <a href=
                "http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf">
                <i>http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf</i></a>
              </p>
            </li>
            <li>
              <p>
                udev FAQ <a href=
                "http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev-FAQ">
                <i>http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev-FAQ</i></a>
              </p>
            </li>
            <li>
              <p>
                Модель драйвера ядра Linux <a href=
                "http://public.planetmirror.com/pub/lca/2003/proceedings/papers/Patrick_Mochel/Patrick_Mochel.pdf">
                <i>http://public.planetmirror.com/pub/lca/2003/proceedings/papers/Patrick_Mochel/Patrick_Mochel.pdf</i></a>
              </p>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <ul>
        <li class="prev">
          <a accesskey="p" href="usage.html" title=
          "How Do These Bootscripts Work?">Назад</a>
          <p>
            Как эти стартовые скрипты работают?
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="setclock.html" title=
          "Configuring the setclock Script">Далее</a>
          <p>
            Настройка скрипта setclock
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="chapter07.html" title=
          "Глава&nbsp;7.&nbsp;Setting Up System Bootscripts">Наверх</a>.
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - Версия 6.0">В начало</a>.
        </li>
      </ul>
    </div>
  </body>
</html>
