<html>
<head>
<title>ГЛАВА 4. Управление программной документацией </title>
			<style type="text/css">
A.noneline { font-family: Arial, Serif; text-decoration: none; }
FONT.arial { font-family: Arial, Serif; }
TD.arial   { font-family: Arial, Serif; }
TH.arial   { font-family: Arial, Serif; }
PRE		{ font-family: Arial, Serif; }
SAMP	   { font-family: Courier; color: navy; }
TT		 { font-family: Monospace; color: navy; }
VAR		{ font-family: Monospace; color: navy; }
CODE	   { font-family: Monospace; color: navy; }
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<basefont size="3">
<center>
<table width=100% border=0 cellpadding=0>
<table cellspacing=0 cellpadding=0 border=0 background="../pic/logo1.jpg" width="100%">
<tr valign=top><td class=arial><a href="http://www.mgul.ac.ru/"><img height=80 width=109 src="../pic/logo.gif" alt="Server of laboratory of space computer science MGUL" border=0></a><br>
</td>
<td align=right class=arial>
<font size="-2">
141001 г.Мытищи МО<br>
<a class=noneline href="http://www.mgul.ac.ru">Ул.Институтская д:1 ком:101</a><br>
(095) 588-32-09, 588-55-62<br>
E-mail: <a class=noneline href="mailto:T-Alex@mgul.ac.ru?Subject='From page topic CIT-FORUM'">T-Alex@mgul.ac.ru</a></font>
</tr>
<tr>
<th colspan=2 class=times>
<font color=#000080 size=2><a href="http://www.mgul.ac.ru" class=noneline>Сервер Лаб. Космической информатики каф.ВТ</a> Московский Государственный Университет Леса</font>
<hr noshade>
</th>
</tr>
</table>
</center>
<A HREF="chap03.htm">Назад.</A>
<A HREF="chap05.htm">Вперёд.</A>
<A HREF="chap00.htm#toc4.1">Оглавление.</A><hr>

<ul><a name=140></a><h2><FONT COLOR="#69BCCB"> * ГЛАВА 4. Управление программной документацией * </FONT></h2></ul>
<P><BL>
 <LI>	  <A HREF="chap04.htm#141">	   ВВЕДЕНИЕ</LI>
 <LI>	  <A HREF="chap04.htm#142">4.1.   ПРОГРАММИРОВАНИЕ и УПРАВЛЕНИЕ ДОКУМЕНТАЦИЕЙ</LI>
 <LI>	  <A HREF="chap04.htm#143">4.2.   ИЗВЛЕЧЕНИЕ ДОКУМЕНТИРУЮЩИХ ЗАГОЛОВКОВ</LI>
 <LI>	  <A HREF="chap04.htm#144">4.2.1. stripc - из файла на языке Си</LI>
 <LI>	  <A HREF="chap04.htm#148">4.2.2. stripf - из Си-функции</LI>
 <LI>	  <A HREF="chap04.htm#151">4.2.3. strips - из командного файла Shell</LI>
 <LI>	  <A HREF="chap04.htm#157">4.3.   ctags - создание файла признаков исходного кода проекта</LI>
</BL> </P>
	
<pre>
<BIG><ul><a name=141></a><h2>ВВЕДЕНИЕ</h2></ul>

			Вы решили  рискнуть.  Продукт  на  три  месяца опаздывает в произ-
	   водство и нуждается лишь в крохотной доработке. Вы уверены, что знаете,
	   как  работает функция,  которая открывает входной буфер.  Вы ее недавно
	   использовали. Вы увеличиваете размер буфера в вызове функции и запуска-
	   ете  быстрый тестик.  Все в порядке,  поэтому вы окончательно собираете
	   поставку на диске и отправляете ее в производство.  Месяц спустя, начи-
	   нают поступать сообщения от разгневанных заказчиков.  Похоже,  что если
	   текстовый процессор,  электронная таблица и  база  данных  открыты  все
	   вместе  и  активны одновременно (что является одним из больших товарных
	   достоинств вашего продукта), то просто новый буфер настолько велик, что
	   поглощает  ключевой раздел памяти и превращает высоко летающее чудо ин-
	   тегрированного программного обеспечения в яркую руину.
			Почему вы не проверили документацию по этой функции? Выяснение то-
	   го, в каком файле находится документация, заняло бы определенное время,
	   а  поскольку  документацию так трудно сопровождать,  то связанные с ней
	   вещи так или иначе устаревают.  Тем не менее,  аналогичные  провалы  не
	   должны возникать.
			Программирование - тяжелая работа,  но это только половина работы.
	   Хорошая документация очень важна, если вы собираетесь иметь возможность
	   сопровождать ваш программный код,  но и управление всей  документацией,
	   связанной  с  большим программным проектом также является тяжелой рабо-
	   той. Происходят постоянные изменения, и обычно отсутствует единообразие
	   подхода.  Документирование  исходных файлов на Сикак в целом,  так и по
	   каждой функции является хорошим первым шагом,  но такая документация не
	   очень полезна, если вы вынуждены пробираться через дюжины файлов, чтобы
	   обнаружить, как называется конкретная функция или какие функции состав-
	   ляют данный модуль.
			Если вы хотели бы изучить еще одно средство, связанное с разработ-
	   кой, см. программу cg в главе 10.


<ul><a name=142></a><h2>4.1. ПРОГРАММИРОВАНИЕ И УПРАВЛЕНИЕ ДОКУМЕНТАЦИЕЙ</h2></ul>

			В данной главе представлен набор командных файлов командного  про-
	   цессора  для  извлечения  документирующей  информации из исходного кода
	   программ на Си и командных файлов командного  процессора.  Используются
	   две стратегии.  Первая состоит в том,  что,  следуя стандартной "модели
	   документации" в исходном коде, вы можете придумать командные файлы, ко-
	   торые просто "вытягивают" самые новые разделы с заголовочной информаци-
	   ей из файлов с исходным кодом и собирают их затем в новый  файл.  Такие
	   файлы служат в качестве каркаса для документации по программе. Следова-
	   тельно,  при условии,  что заголовки исходного кода изменяются  разными
	   программистами стандартным образом,  простая команда UNIX может извлечь
	   полностью новый каркас руководства.
			Этот подход  реализуют  командные  файлы stripc,  stripf и strips.
	   Stripc и stripf предоставляют листинги блоков документации уровня файла
	   и уровня функций из ваших исходных файлов на Си,  а strips извлекает доку-
	   ментацию из командных файлов командного процессора.
			Второй подход  -  доступ  к определенным видам структур (таким как
	   функции на Си) в теле самого программного кода.  Этим методом вы можете
	   точно найти, как называется данная функция, без сосредоточенного изуче-
	   ния горы листингов. Командный файл ctags является и полезным инструмен-
	   том,  и  моделью  применения  этого  подхода к другим видам программных
	   структур.
			Ctags объединяет  свой  выводной  файл  с редактором vi/ex с целью
	   предоставления простого способа доступа к любой заданной функции  и  ее
	   просмотра,  копирования  или редактирования в текущей программе.  Ctags
	   делает это путем предоставления признаков,  которые  понимает  vi,  для
	   каждой функции, обнаруженной в любом указанном наборе файлов. Таким об-
	   разом, вы можете использовать простую команду редактора, чтобы получить
	   то,  что вам нужно.  Вы больше не обязаны заботиться о том,  какой файл
	   содержит какую функцию.  Ctags - отличный пример применения мощи UNIX в
	   полном объеме.
			Имея такие инструментальные средства,  вам не нужно изобретать ко-
	   лесо,  так как вы можете легко находить и выбирать те средства, которые
	   необходимы вам в конкретном приложении.  Вы уже написали программу  уп-
	   равления терминалом Trantor TR-101? Примените ctags и найдите ее. Более
	   того,  самодокументируемый напечатанный файл и документация о функциях,
	   полученная  с помощью этих командных файлов,  дают другим программистам
	   хороший старт в понимании того,  что вы сделали.  Это даже может слегка
	   произвести впечатление на вашего начальника.
			Каким в общих чертах будет наш подход к созданию  таких  командных
	   файлов?  У  нас  есть некоторые потенциальные преимущества в применении
	   такого вида доступа в системе UNIX. Прежде всего, исходные файлы не от-
	   личаются от других текстовых файлов,  поэтому мы можем использовать все
	   имеющиеся в UNIX средства поиска и распознавания шаблонов (sed,  awk  и
	   т.д.),  чтобы находить символьные строки. Во-вторых, мы освоили технику
	   обхода файловых деревьев и работы с отобранными типами файлов,  описан-
	   ную в предыдущих главах.  Наш подход состоит в объединении этих средств
	   таким образом,  чтобы они обеспечивали доступ к структурированной доку-
	   ментации, содержащейся в программных файлах.

<a name=143></a><CENTER><H2>4.2. Извлечение документирующих заголовков</H2></CENTER>
<a name=144></a><CENTER><H2>4.2.1. stripc - из файла на языке Си</H2></CENTER>


<hr>
			ИМЯ: stripc
<hr>

	 stripc	 Извлекает документирующий заголовок
				из исходного файла на языке Си.

<ul><h2>НАЗНАЧЕНИЕ</h2></ul>

			Печатает первый блок строк комментария в файле с исходным кодом на
	   Си так,  чтобы вы могли быстро идентифицировать назначение программы на
	   Си.

<ul><h2>ФОРМАТ</h2></ul>
</BIG>
<CODE>			stripc файл [...]</CODE>

<BIG><ul><a name=145></a><h2>ПРИМЕР ВЫЗОВА</h2></ul></BIG>

<CODE>			stripc prog*.c > header</CODE>

<BIG>			Извлекает начальные блоки комментариев из всех файлов и помещает в
	   один файл с именем header.

			ИСХОДНЫЙ КОД ДЛЯ stripc
</BIG>
<CODE>
1  :
2  # @(#) stripc v1.0  Strip comment header  Author: Russ Sage

4  if [ "$#" -eq "0" ]
5	then  echo "stripc: arg count error"  >&2
6		  echo "usage: stripc file [...]" >&2
7		  exit 1
8  fi

10 for FILE in $@
11 do
12		 if [ ! -s $FILE ]
13		   then  echo "file \"$FILE\" does not exist" >&2
14				 continue
15		 fi

17		 awk '/^\/\*/, /^ \*\// { if ($0 != " */")
18										 print
19									else {print;exit}
20		 }' $FILE
21		 echo "^L"
22 done
</CODE>
<BIG>			(Перед тем как вводить этот исходный код, обратите внимание, что в
	   строке 21 должен быть действительно символ control- L,  введенный между
	   двумя кавычками, по причинам, рассмотренным ниже.)

<ul><a name=146></a><h2>ПЕРЕМЕННАЯ СРЕДЫ</h2></ul>

	 FILE	Хранит имя файла, полученное из командной строки.

	   <b>ОПИСАНИЕ</b>
			ЗАЧЕМ НАМ НУЖЕН stripc?

			В больших  проектах  по разработке программного обеспечения требу-
	   ется обычно много времени для работы с документацией. Имеются программ-
	   ные файлы для документирования, функциональные спецификации для написа-
	   ния программ и,  наконец,  руководства и справочные  карты,  глоссарии,
	   указатели и т.д.  Настоящий программный код должен иметь свою собствен-
	   ную встроенную документацию,  иначе управление  этим  кодом  становится
	   очень трудным.
			Чтобы избежать путаницы,  нужно создать модель документации, а за-
	   тем сделать ее стандартом,  которому должны следовать все программисты.
	   Даже если эта модель не будет абсолютно идеальной,  ее наличие является
	   первым шагом по созданию среды, которой вы можете управлять.
			Следующие два инструментальные средства,  которые  мы  предлагаем,
	   следуют модели документации,  описанной в дальнейшем тексте. Эта модель
	   последовательна и понятна,  ее можно дополнить или изменить  по  вашему
	   усмотрению.

			ЧТО ДЕЛАЕТ stripc?

			Stripc печатает  только  первый  заголовочный блок комментариев из
	   начала исходного файла на языке Си.  Желательно, чтобы этот блок содер-
	   жал  всю  важную информацию о файле:  его официальное имя,  для чего он
	   предназначен,  кто его создал,  когда он был создан и т.д. Внутри файла
	   может  размещаться одна или несколько функций или даже главная програм-
	   ма. Эта модель предполагает, что весь ваш код содержит очень мало глав-
	   ных программ и много независимых модулей.
			Рассмотрим на модельном исходном файле,  какого рода информацию мы
	   должны извлечь из исходных файлов.
</BIG>
<CODE>
/*
 *  Это документирующий заголовок для файла
 *  с исходным кодом на языке Си.
 *  Он поясняет, что содержится в файле (программы, функции,
 *  библиотеки и т.д.) и идентифицирует проект.
 *
 */ Это отметка конца заголовочного комментария.
^L  Инструменты извлечения применяют control-L как разделитель.
/*  Это документирующий заголовок для главной части программы.
 *  Главная пометка должна объяснять, что это за программа
 *  и что она делает. Здесь могут быть также указаны автор,
 *  дата и история изменений.
 */
main()
{
		/* Здесь находится главная Си-программа */
}
^L
/*  Это документирующий заголовок для определенной функции,
 *  которая за ним следует. Документируется последователь-
 *  ность вызова, вход и выход и общее назначение этой
 *  функции.
 */
func(arg1,arg2)
int arg1;
char arg2;
{
		/* Текст функции находится здесь */
}
^L
/*  Аналогично, этот блок комментариев документирует
 *  следующую функцию. Наличие документации вместе с кодом
 *  сокращает объем накладных расходов при чтении и
 *  изменении кода.
 */
func(arg1,arg2)
int arg1, arg2;
{
		/* Текст функции находится здесь */
}

</CODE>			<BIG>Как указывалось ранее,  функция main не обязательна  и,  вероятно,
	   встречается только в одном или двух файлах, в зависимости от вида прог-
	   рамм, которые вы пишете. Один файл может иметь столько функций, сколько
	   вы  хотите,  но рекомендуемое максимальное число - от одной до трех,  в
	   зависимости от того,  как эти функции  взаимосвязаны.  В  каждом  файле
	   имейте дело только с одной программируемой идеей и ее реализацией.
			При изучении этой модели вы видите,  что обеспечивается три уровня
	   документации.  Заголовок  в  начале файла извлекается с помощью stripc.
	   Этот заголовок относится ко всему файлу в  целом.  Заголовок  в  начале
	   главной  программы  относится  ко всей программе и поддерживается с по-
	   мощью stripf.  Заголовок для каждой функции относится к  этой  функции.
	   Эти  заголовки обслуживаются командным файлом stripf,  который обсужда-
	   ется ниже.
			Отметим, что   между  функциями  имеется  прогон  формата  (символ
	   control-L кода ASCII).  В предыдущем листинге мы указали эту комбинацию
	   клавиш с помощью символа ^L,  чтобы наши текстовые процессоры не произ-
	   водили лишних страниц при форматировании  рукописи  данной  книги.  Вам
	   нужно  в  каждом  случае  действительно вводить control-L вместо ^L при
	   размещении комментариев в ваших файлах и при вводе исходного кода  дан-
	   ного  и последующих командных файлов.  Символ прогона формата использу-
	   ется в модели заголовка для отметки верхней границы  первой  функции  в
	   файле  и  для  прогона  страниц  на  печатающем устройстве при чистовой
	   распечатке, чтобы каждая функция появлялась на новой странице.
			В начале каждой функции (перед main или перед именем функции) дол-
	   жен существовать документирующий заголовок. Этот заголовок обычно отра-
	   жает наиболее недавние изменения в этом модуле, и его можно считать бо-
	   лее  достоверным,  чем  заголовок  документа,  который  был   напечатан
	   несколько недель или даже месяцев назад.
			Входом для stripc является последовательность имен файлов с исход-
	   ным кодом. Для каждого файла в командной строке проверяется, существует
	   ли он и имеет ли размер больше, чем ноль байт. Если он не удовлетворяет
	   этим критериям, то печатается сообщение об ошибке и проверяется следую-
	   щий файл. Каждый файл читается с первого байта, и в нем ищется символь-
	   ная  строка начала комментария (/*).  Когда она найдена,  информация до
	   символьной строки конца комментария (*/) построчно выводится в  stdout.
	   Если правые символы не найдены,  ничего не печатается,  но сообщение об
	   ошибке не выводится, чтобы не испортить выводную информацию. После того
	   как каждый файл обработан,  в конце печатается прогон формата,  который
	   разбивает выводную информацию на страницы-разделы.  Это  применяется  в
	   основном,  когда  документирующие заголовки очень длинные и нуждаются в
	   визуальной разбивке.
			Отметим, что  "извлечение" ("strip") здесь и в следующих двух ути-
	   литах означает не УДАЛЕНИЕ,  а копирование соответствующей  информации.
	   Никаких изменений во входных файлах не делается.
			Когда все файлы в командной строке обработаны,  командный файл за-
	   вершается.

<ul><a name=147></a><h2>ПРИМЕРЫ</h2></ul>
</BIG>		<CODE>1.  $ stripc test?.c > test.filehdrs
</CODE>		   <BIG> Извлекает блок файловых комментариев из всех файлов, соответствую-
	   щих строке "test", за которой следуют один произвольный символ, а затем
	   .c. Сюда подходят test1, testA, testb и т.д. Все блоки комментариев по-
	   мещаются в файл test.filehdrs в таком порядке,  как они  обрабатывались
	   бы в цикле for.
</BIG>		<CODE>2.  $ for DIR in src1 src2 src3
			> do
			>		   stripc $DIR/*.c > /tmp/$DIR.hdrs
			> done
</CODE>		  <BIG>  Этот цикл проходит каждый из трех каталогов src1,  src2 и src3.  В
	   каждом из них имеются исходные файлы, из которых нужно извлечь докумен-
	   тирующие заголовки.  Каждый раз берется один каталог,  и stripc вызыва-
	   ется  для всех исходных файлов на языке Си из данного каталога.  Выход,
	   т.е.  все документирующие заголовки из файлов в этом каталоге,  помеща-
	   ется  в файл в каталоге /tmp.  Файлы в /tmp имеют имена /tmp/src1.hdrs,
	   /tmp/src2.hdrs и /tmp/src3.hdrs.  Отметим, что число файлов, передавае-
	   мых  stripc,  имеет  ограничение в 255 символов.  После этого командная
	   строка переполняется и выполнение командного  файла  аварийно  заверша-
	   ется.

	   ПОЯСНЕНИЯ

			Строки 4-8 делают проверку на ошибки.  Если число параметров в ко-
	   мандной строке нулевое, возникает ошибка. При вызове stripc должно быть
	   хотя бы одно имя файла.
			Цикл for  в  строках  10-22  пробегает  по  каждому имени файла из
	   списка позиционных параметров в командной строке.
			Первым делом,  в  строках  12-15  проверяется существование файла.
	   Если файл не существует, выдается соответствующее сообщение об ошибке и
	   цикл продолжается со следующим файлом.
			Строки 17-20 - это цикл awk,  который делает  всю  важную  работу.
	   Входным  для  awk является имя файла,  которое сейчас обрабатывает цикл
	   for.
			Если вы не очень знакомы с программой awk,  сообщим, что она вызы-
	   вается так:
			awk программа имя-файла
			где программа состоит из последовательности  предложений,  имеющих
	   вид:
			шаблон { действие }
			Указанное действие  применяется  к  тексту,  который соответствует
	   шаблону.  Для того чтобы утилита awk работала корректно, вы должны зак-
	   лючить всю программу в одинарные кавычки.
			В stripc для указания начала комментария (/*) и конца  комментария
	   (*/) используются соответственно шаблоны
			/^\/\*/ и /^ \*\//
			Для интерпретации  этих обозначений нужно вспомнить регулярные вы-
	   ражения ed, sed и grep. Регулярные выражения (РВ) должны быть ограниче-
	   ны (символом /).  awk воспринимает два выражения, разделенные запятыми,
	   как начальный и конечный шаблоны для квалификации вводных строк.
			В данном  примере  начальное  выражение означает "от начала строки
	   (^),  вслед за действительным символом косой черты (который должен быть
	   экранирован, чтобы убрать его специальное значение, т.е. \/) и действи-
	   тельной звездочкой (\*),  использовать все строки,  обнаруженные вплоть
	   до  конечного  выражения".  Этим выбирается только первое вхождение со-
	   поставляемого шаблона (т.е.  первого блока комментариев), так как прог-
	   рамма  awk  заканчивает  работу  при  обнаружении  завершающей  строки.
	   (Остальные блоки комментариев выбираются с помощью stripf вместе с име-
	   нем функции и аргументами.)
			Для каждой строки,  которая соответствует набору выражений от  на-
	   чального до конечного, выполняются предложения, указанные в "действии".
	   Строки 17, 18 и 19 содержат предложение if-then= else, которое выполня-
	   ет  всю работу.  Если $0 (что является всей строкой) НЕ равно пробелу и
	   концу комментария (*/),  печатается вся строка.  Формируя таким образом
	   предложение if, мы печатаем первую строку и все последующие строки, по-
	   ка не доберемся до конца комментария.
			Когда обнаружена  последняя строка,  результатом проверки является
	   значение "ложь",  поэтому выполняется else-часть.  Поскольку мы  знаем,
	   что  это последняя строка,  мы печатаем ее для завершенности блока ком-
	   ментария,  а затем выходим из awk. Отметим, что благодаря вложению этих
	   двух команд вместе в фигурные скобки ({}), они рассматриваются как одно
	   составное предложение.
			После завершения  awk производится эхо-отображение прогона формата
	   на экран и берется следующий файл.  Так продолжается до тех  пор,  пока
	   все файлы в командной строке не будут обработаны.

<ul><a name=148></a><H2><CENTER>4.2.2. stripf - из Си-функции</CENTER></H2>


<hr>
			ИМЯ: stripf
<hr>

	 stripf	 Извлекает документирующий заголовок
				Си-функции.

	   <b>ФУНКЦИЯ</b>

			Извлекает и печатает комментирующий заголовок, имя функции с пара-
	   метрами вызова и объявление типов параметров для всех функций в  исход-
	   ном файле на Си.
</BIG>
	   <BIG><b>ФОРМАТ</b></BIG>
<CODE>	 stripf file [...]</CODE>
<BIG>	   <b>ПРИМЕР ВЫЗОВА</b></BIG>
<CODE>	 stripf lib1.c</CODE>
<BIG>		Извлекает документирующие заголовки для всех функций  в
файле lib1.c.</BIG>

<BIG>ИСХОДНЫЙ КОД ДЛЯ stripf</BIG>
<CODE>
1  :
2  # @(#) stripf v1.0  Strip function header  Author: Russ Sage

4  for FILE in $@
5  do
6		  sed -n -e '
7		  /^L$/ {
8				   s/^L$/.bp/p
9		  : loop
10				  n
11				  /^{/b exit
12				  p
13				  b loop
14		 : exit
15				  i\
16  {}
17				  b
18		 }' $FILE
19 done

</CODE>
<BIG><h2>ПЕРЕМЕННАЯ СРЕДЫ</h2></ul>

	 FILE	   Хранит имя файла для каждого файла
				из командной строки.

	   <b>ОПИСАНИЕ</b>
			ЗАЧЕМ НАМ НУЖЕН stripf?

			Предположим, что наш код на языке Си соответствует модели докумен-
	   тации, представленной ранее при описании stripc. Тогда нам нужен способ
	   поддержания изменений в документации по ходу изменений кода. Мы видели,
	   что при хранении документации в исходных файлах более вероятно, что она
	   будет изменена, когда изменится код. Проблема возникает, когда нам нуж-
	   на твердая копия документации, которая находится внутри исходного кода.
	   Как нам получить ее из файлов?

			ЧТО ДЕЛАЕТ stripf?

			Командный файл stripf решает эту проблему.  Он просматривает  весь
	   файл и печатает всю документацию для каждой ФУНКЦИИ,  которая размещена
	   в этом файле (включая "main", если она есть).
			Входом для stripf являются имена файлов,  переданные  в  командной
	   строке. Stripf обрабатывает файлы по очереди и помещает выход в stdout.
	   Этот выход можно перенаправить, но вход должен быть в командной строке.
			К выходу  применяются дополнительные модификации,  чтобы сформиро-
	   вать данные для среды утилиты nroff,  поэтому выводные файлы можно фор-
	   матировать  с  помощью этой утилиты.  Все прогоны формата заменяются на
	   команду .bp,  принятую в nroff для начала страницы.  Эта команда  nroff
	   прогоняет страницу и увеличивает на единицу счетчик страниц.  Возможно,
	   вы не хотите менять нажатие клавиш control-L на  это  значение,  но  вы
	   всегда можете указать в командном файле такие действия,  какие вам нуж-
	   ны.
<ul><a name=149></a><h2>ПРИМЕРЫ</h2></ul>
		1.  $ stripf module1.c | grep >"^\.bp$" | wc -l
			Печатает число  модулей-функций,  содержащихся  в файле module1.c,
	   путем поиска каждого появления команд новой страницы программы nroff  и
	   их  подсчета.  Мы знаем,  что одна из таких команд является выходом для
	   каждой обнаруженной функции.  Данную строку можно вложить в предложение
	   echo, которое говорит "имеется X модулей в файле $FILE".
</BIG><CODE>		2.  $ for FILE in *.c ../*.c $HOME/src/*.c
			> do
			>		stripf $FILE
			> done >> /tmp/func.hdrs

</CODE><BIG>			Данный цикл  for распространяется на все файлы в текущем каталоге,
	   которые оканчиваются на .c,  все файлы в родительском каталоге с  таким
	   же суффиксом и все файлы в подкаталоге src моего home-каталога с тем же
	   суффиксом.  Из каждого файла извлекается документация о функциях и нап-
	   равляется  в  стандартный вывод.  Весь цикл перенаправлен с помощью >>,
	   поэтому выход каждого вызова stripf ДОБАВЛЯЕТСЯ к файлу в /tmp.

<ul><a name=150></a><h2>ПОЯСНЕНИЯ</h2></ul>

			Вся программа - это один большой цикл for  в  строках  4-19.  Этот
	   цикл  присваивает  переменной  FILE  каждое имя,  имеющееся в командной
	   строке. Данный командный файл не имеет опций и обработки ошибок.
			Команда sed системы UNIX вызывается для каждого имени файла. Прог-
	   рамма sed читает весь вход и выводит измененный текст в стандартный вы-
	   вод.
			Опция -n используется в sed для подавления всего вывода,  в проти-
	   воположность действию по умолчанию, когда все печатается. Мы используем
	   этот флаг по той причине, что мы хотим указать программе sed, когда пе-
	   чатать выход.  Опция -e применяется,  чтобы сообщить программе sed, что
	   следующая последовательность текста между одинарными кавычками является
	   выражением, которое нужно вычислить.
			Напомним, что sed - потоковый редактор,  который читает одну стро-
	   ку,  сверяет  ее с выражениями,  затем читает следующую строку и делает
	   все сначала.  Первое,  что мы ищем - символ control-L, стоящий в строке
	   самостоятельно.  Если мы не находим его, проверяется следующая строка и
	   так далее,  пока не будет обнаружен control-L.  (Еще раз напомним,  что
	   вместо обозначения ^L в коде должен быть введен настоящий control-L.)
			Когда обнаружен control-L,  он активизирует все выражение,  заклю-
	   ченное в фигурные скобки. Первым действием является подстановка команды
	   начала страницы программы nroff, как описано ранее. Эта подстановка пе-
	   чатается, что является самым первым выводом. В строке 9 объявлена метка
	   "loop".  Это не приводит ни к каким действиям,  но устанавливает  точку
	   перехода,  которая  впоследствии  используется.  (Управляющие структуры
	   программы sed довольно примитивны, но они позволяют описать выполняемую
	   работу.)
			Строка 8 использует команду n программы sed,  чтобы вызвать чтение
	   следующей  строки.  Мы разобрались с первой строкой - строкой,  которая
	   содержит control-L - так что мы можем ее отбросить. В случае выполнения
	   цикла мы видим,  что sed продвигается по нашему требованию, но не прод-
	   вигается сам.
			Вспомним модель  документации,  рассмотренную  ранее.  Эта  модель
	   включает документирующий заголовок для файла  в  целом,  выполненный  в
	   обычном  стиле  языка Си.  Модель завершается символом control-L.  Этот
	   первый блок обрабатывается с помощью stripc,  как описано ранее.  Мы не
	   хотим  использовать  его здесь при работе со stripf.  Поэтому мы сейчас
	   должны спозиционироваться после файлового документирующего заголовка.
			Вслед за  символом  control-L  имеется еще один набор из одной или
	   более строк комментария языка Си,  которые описывают функцию, следующую
	   за ними. Далее идет само имя функции, объявление параметров и открываю-
	   щий символ самой функции, которым является левая фигурная скобка (}).
			Строка 11 ищет эту фигурную скобку.  Если она найдена,  выполнение
	   переходит на метку exit (строка 14). Мы можем полагать, что мы все сде-
	   лали,  если  найдена левая фигурная скобка,  так как этот символ должен
	   появляться только в начале функциимодуля.  Когда  мы  находим  фигурную
	   скобку, мы уже напечатали к этому моменту всю комментирующую информацию
	   и заголовок функции посредством строки 12,  которую мы сейчас опишем. А
	   что  если  фигурная скобка появляется в поле комментария?  Нет проблем,
	   поскольку поиск фигурной скобки привязан к началу строки с помощью сим-
	   вола ^. Он производит выражение, означающее "от первого символа в стро-
	   ке". Мы только тогда сопоставляем фигурную скобку этому выражению, ког-
	   да она встречается в качестве самого первого символа в строке.
			Затем строка 12 предполагает,  что мы еще не  обнаружили  фигурную
	   скобку и поэтому мы должны напечатать строку. Оператор p печатает теку-
	   щую строку, которую обрабатывает sed. Этот вывод направляется на экран.
			Строка 13 - безусловный переход на метку loop.  Отметим,  что этот
	   переход только изменил процесс выполнения и не привел к чтению еще  од-
	   ной вводной записи. С этим мы должны быть осторожны при управлении про-
	   цессом выполнения в программе sed. Мы только что напечатали текущую за-
	   пись,  поэтому  теперь  мы должны отбросить ее и получить следующую за-
	   пись, что означает возврат в строку 9. Этот цикл печати и чтения следу-
	   ющей записи продолжается до обнаружения фигурной скобки,  которая пере-
	   водит выполнение на метку exit.
			Строка 14  - это метка exit.  Когда мы попадаем на нее,  мы знаем,
	   что был обнаружен control-L,  напечатан комментирующий заголовок, напе-
	   чатаны  имя функции и объявления ее параметров и найдена фигурная скоб-
	   ка.  Заметим,  что фигурная скобка еще не напечатана.  Когда мы находим
	   ее, мы только делаем ветвление.
			Строка 15 завершает вывод, вставляя некоторый текст в выводной по-
	   ток.  Мы не можем сказать "печатать это в буквенном виде", поэтому про-
	   исходит движение вправо по тексту,  как по команде echo. Мы должны сыг-
	   рать на правилах, установленных программой sed. Любой вывод должен быть
	   порожден обычными командами в стиле редактора ed.  Вставка текста с по-
	   мощью команды "i" делает нам это.  Отметим, что мы также вставляем сим-
	   вол возврата каретки (или перевода строки, в зависимости от вашей осве-
	   домленности).  Он  может  быть  определен символом обратной косой черты
	   (\).  Обратная косая черта убирает специальное значение символов и  при
	   использовании в конце строки, как здесь, означает, что специальный сим-
	   вол,  вставленный в выражение,  является возвратом каретки.  Вдобавок к
	   возврату  каретки,  мы  вставляем пару фигурных скобок.  Это обозначает
	   объявление начала-конца функции,  которую мы обрабатываем. Поскольку мы
	   вставляем текст, мы не должны говорить программе sed, что его нужно пе-
	   чатать.
			Строка 17 - безусловный переход на себя, указывающий программе sed
	   переход на вершину всего обрабатываемого выражения.  Когда это происхо-
	   дит,  мы  завершаем  поиск еще одного control-L и начинаем весь процесс
	   снова.  Таким образом,  мы можем обработать все функции из одного файла
	   независимо от того, сколько их там.
			Строка 18 является концом sed-выражения и содержит также имя  фай-
	   ла,  которое  должно  быть передано программе sed.  Это является частью
	   обычного синтаксиса, принятого в sed, но выглядит несколько неуместным,
	   так  как не выделено специальным отступом.  Когда все файлы обработаны,
	   завершается внешний цикл и заканчивается работа командного файла.

<a name=151></a><CENTER><H2>4.2.3. strips - из командного файла Shell</H2></CENTER>


<hr>
			ИМЯ: strips
<hr>


	 strips	 Извлекает документирующий заголовок
				командного процессора.

<ul><h2>ФУНКЦИЯ</h2></ul>

			Печатает начальные строки комментария к командному файлу командно-
	   го процессора, что выражено буквой "s" в имени. Первая строка игнориру-
	   ется для совместимости с командным процессором языка Си.

<ul><a name=152></a><h2>ФОРМАТ</h2></ul>
</BIG><CODE>			strips файл [...]</CODE>
<BIG><ul><a name=153></a><h2>ПРИМЕР ВЫЗОВА</h2></ul></BIG>
<CODE>			strips *.sh</CODE>
<BIG>			Извлекает комментарии из всех командных файлов в текущем каталоге.

			ИСХОДНЫЙ КОД ДЛЯ strips
</BIG><CODE>
1  :
2  # @(#) strips v1.0  Strip shell comment header
										Author: Russ Sage

4  for FILE in $@
5  do
6		cat $FILE | (read LINE; echo $LINE
7		while read LINE
8		do
9			  if [ "`echo $LINE|cut -c1`" = "#" ]
10			   then echo "$LINE"
11			   else exit
12			 fi
13	   done)
14 done

</CODE>
<BIG><ul><a name=154></a><h2>ПЕРЕМЕННЫЕ СРЕДЫ</h2></ul>

	 FILE	   Хранит каждое имя файла, полученное из
				командной строки.
	 LINE	   Хранит каждую строку вводного текста,
				полученную из читаемого файла.

	   <b>ОПИСАНИЕ</b>
			ЗАЧЕМ НАМ НУЖЕН strips?

			Так же  как нам нужны средства обработки документации для файлов с
	   исходным кодом на Си,  нам нужны и аналогичные средства  для  командных
	   файлов командного процессора. Разница между извлечением комментариев из
	   кода на языке Си и их извлечением из кода командных  файлов  командного
	   процессора  -  в  способе  разграничения комментариев в исходном файле.
	   Исходный файл на Си использует пару /* */, а командные файлы командного
	   процессора применяют #, чтобы выделить остаток строки как комментарий.
			Обработка документации облегчается,  когда командные файлы следуют
	   некоторой форме стандартизованной документации.  В действительности нет
	   формального стандарта, но наиболее близкий стандарт приходит со страниц
	   руководств по самой системе UNIX.  Стандартными полями являются имя ко-
	   мандного файла, способ его вызова, что он делает и, возможно, некоторые
	   пометки о том,  как он работает,  ссылки на другие места для поиска ин-
	   формации и сведения о том,  какие  файлы  использует  данный  командный
	   файл. Пример формата выглядит так:</BIG>
<CODE>	   
:
# ИМЯ
#	   strips   Извлекает поля shell-комментариев
#
# ФОРМАТ ВЫЗОВА
#	   strips файл [...]
#
# АВТОР
#	   Russ Sage   mm/dd/yy
#
# ОПИСАНИЕ
#	   Данный командный файл извлекает комментирующие
#	   заголовки из командных файлов интерпретатора shell.
#
# СМ. ТАКЖЕ
#	   sh(1), cat(1)

</CODE><BIG>			Отметим, что в первой строке имеется оператор :,  который является
	   для командного процессора нулевым оператором.  Он ничего не делает,  но
	   всегда  возвращает  успешный  статус  выхода.  Он находится в отдельной
	   строке,  поскольку это обозначает командный файл для Bourne shell. Если
	   вы  запускаете  /bin/csh вместо /bin/sh,  командные файлы могут вызвать
	   путаницу. C Shell ищет символ # в первой колонке первой строки. Если он
	   там  есть,  командный  процессор считает этот файл командным файлом ин-
	   терпретатора csh.  Чтобы указать интерпретатору csh, что командный файл
	   предназначен  для  интерпретатора  Bourne shell,  мы можем оставить эту
	   строку пустой (что будет не слишком хорошо печататься и подлежит удале-
	   нию)  или поместить оператор,  который сообщает интерпретатору C Shell,
	   что это командный файл для Bourne shell, но ничего не делает под управ-
	   лением Bourne shell.

			ЧТО ДЕЛАЕТ strips?

			Strips читает  командный  файл и печатает все комментарии с начала
	   файла,  которые являются непрерывными (т.е. печатает, пока не достигнет
	   строки, не являющейся комментарием). Первая строка игнорируется, но пе-
	   чатается.  Когда строка не имеет символа # в первой символьной позиции,
	   strips прекращает чтение этого файла.
			Командный файл должен  иметь  структуру  комментария,  аналогичную
	   структуре, показанной в нашем предыдущем примере. Символы # должны быть
	   в первой позиции,  и каждая строка должна иметь символ #.  Если  у  вас
	   есть  пустая  строка где-нибудь в начальном блоке комментариев,  strips
	   печатает только первую часть блока.
<ul><a name=155></a><h2>ПРИМЕРЫ</h2></ul>
</BIG><CODE>		1.  $ strips `kind /bin /usr/bin`</CODE>
<BIG>			Блоки комментариев извлекаются из текстовых файлов,  размещенных в
	   каталогах /bin и /usr/bin.</BIG>
<CODE>		2.  $ find / -name "*.sh" -print | while read FILE
			> do
			> strips $FILE > /tmp/doc/$FILE
			> done</CODE>
<BIG>			Find порождает список всех имен файлов, который попадает в strips.
	   Выход strips направляется в каталог документации в /tmp.  Окончательный
	   выход попадает в файл с точно таким же именем, как исходный файл, толь-
	   ко выход помещается в /tmp,  поэтому никаких случайных удалений не про-
	   исходит.

<ul><a name=156></a><h2>ПОЯСНЕНИЯ</h2></ul>

			Строки 4 и 14 окаймляют внешний цикл,  который подает имена файлов
	   данному командному файлу. Обработки или проверки ошибок нет. Пока в ко-
	   мандной строке есть файлы,  цикл продолжается. Вы можете, конечно, про-
	   верить наличие аргументов,  правильность и  существование  файлов.  Для
	   этого,  мы думаем, вы видели достаточно примеров проверки ошибок, чтобы
	   добавить их, куда вам нужно. Поэтому мы иногда опускаем такие фрагменты
	   в нашем коде, чтобы сэкономить место и выделить главную функцию.
			Строка 6 применяет команду cat к файлу, который сейчас обрабатыва-
	   ется.  Выход направляется в конвейер,  чтобы его прочитал другой shell.
	   Новый shell получает длинную командную строку (обозначенную скобками  в
	   строках  6  и  13).  Первая  команда  read  читает самую первую строку.
	   Поскольку мы не собираемся проверять эту строку,  мы отображаем  ее,  а
	   затем опускаемся в цикл последовательного чтения.  Предполагается,  что
	   первая строка начинается с двоеточия,  но если она начинается с символа
	   #, она все равно печатается, так что вы не будете терять текст.
			Строки 7-13 являются  внутренним  циклом  while,  читающим  строки
	   текста  со стандартного ввода,  который был выходом команды cat.  Когда
	   текст заканчивается, прекращается и цикл while.
			Строки 9-12  - это строки принятия решения.  Сначала мы отображаем
	   текущую вводную строку и передаем ее по конвейеру команде cut.  Выреза-
	   ется первый символ,  затем команда сравнения проверяет, совпадает ли он
	   с символом комментария. Если да, строка отображается на стандартный вы-
	   вод.  Если это не символ комментария, то нужно достичь конца блока ком-
	   ментариев,  поэтому происходит выход из внутреннего  цикла.  Управление
	   возвращается во внешний цикл (for),  который стартует и берет следующее
	   имя файла. Когда все файлы обработаны, strips завершается.

<a name=157></a><H2><CENTER>4.3. ctags - создание файла признаков исходного кода проекта</CENTER></H2>


<hr>
			ИМЯ: ctags
<hr>

	 ctags	  Делает файл признаков исходного кода для
				простоты доступа с помощью утилиты vi.

<ul><h2>ФОРМАТ</h2></ul>
</BIG><CODE>			ctags [файл ...]</CODE>

<BIG><ul><a name=158></a><h2>ПРИМЕР ВЫЗОВА</h2></ul></BIG>
<CODE>			ctags proj*.c</CODE>
<BIG>			Делает файл признаков для всего исходного кода проекта.

			ИСХОДНЫЙ КОД ДЛЯ ctags</BIG>
<CODE>
1  :
2  # @(#) ctags v1.0  Create a C source code tag file
										 Author: Russ Sage

4  awk -F'(' '/^[a-zA-Z_][a-zA-Z0-9_]*\(/ {
5		printf ("%s\t%s\t/^%s$/\n", $1, FILENAME, $0) }'
										 $@ | sort -u +0 -1

</CODE><BIG>	   <b>ПЕРЕМЕННАЯ СРЕДЫ</b>

			FILENAME awk  Переменная, содержащая имя файла.

	   <b>ОПИСАНИЕ</b>
			ЗАЧЕМ НАМ НУЖЕН ctags?

			UNIX создан как среда для разработки программного обеспечения. Она
	   поддерживает  и поощряет модульность исходного кода программы.  Модуль-
	   ность - это концепция разбиения проекта на отдельные файлы, превращения
	   идей  в  подпрограммы  и компиляции отдельных файлов с исходным кодом в
	   перемещаемые модули для последующей их сборки в исполняемый модуль.
			Такая философия разработки программного обеспечения может, однако,
	   породить некоторые проблемы.  Главная проблема - попытка получить неко-
	   торого рода сцепку из всех маленьких кусков головоломки. Делаются вызо-
	   вы подпрограмм, которые находятся в других файлах, возможно даже в дру-
	   гих каталогах.  Нужен инструмент, позволяющий нам, людям, посмотреть на
	   программное обеспечение человеческим взглядом, т.е. содержательно, а не
	   с  точки  зрения физического размещения.  Этот подход чем-то аналогичен
	   чтению книги в сравнении с чтением компьютерной распечатки.  Распечатка
	   заставляет вас делать последовательный просмотр, а книга допускает пря-
	   мой доступ (и обычно предоставляет оглавление  и  предметный  указатель
	   для поиска специфических пунктов).
			Ctags преодолевает этот разрыв,  создавая файл специального форма-
	   та,  который распознают редакторы vi и ex.  Этот файл содержит "призна-
	   ки",  которые могут быть  использованы  при  работе  с  редактором  для
	   обеспечения автоматического доступа к любой нужной функции,  не требую-
	   щего от вас знаний о том, в каком файле находится функция.
			Фактически, ctags предоставляет вам предметный указатель для груп-
	   пы файлов с исходным кодом на языке Си.  Когда вы объединяете его с ре-
	   дактором,  вы можете быстро найти любую функцию по известному вам имени
	   и посмотреть тело функции.  Это значит также, что вы можете легко копи-
	   ровать  и вставлять функции в любой исходный файл,  с которым вы сейчас
	   работаете.
			Если редактор  не  имел  возможности работы с признаками или мы не
	   построили инструментальное средство,  использующее такое  преимущество,
	   то мы должны запускать grep для имени функции на наборе исходных файлов
	   на Си (в надежде,  что у нас есть подходящие файлы!),  отмечать,  какой
	   файл  имеет требуемую функцию,  входить в этот файл редактором (вручную
	   вводя все символы имени файла),  а затем набирать символы  шаблона  по-
	   иска. Это большая работа, которая может занять много времени. Благодаря
	   использованию возможности работы с признаками, для файла признаков, из-
	   влеченных из исходного кода, вся эта ручная работа сокращается.
			Это сочетание возможностей иллюстрирует то,  чему не часто  прида-
	   ется  значение:  владельцы UNIX всегда настороженно относятся к возмож-
	   ности использовать преимущества многочисленных средств, уже имеющихся в
	   таких программах, как vi или ex. Зачастую от 90 до 95 процентов необхо-
	   димых вам возможностей уже имеются,  ожидая относительно  простого  ко-
	   мандного  файла  интерпретатора shell,  связывающего их вместе в мощный
	   новый инструмент.
			Ctags уже  существует в виде исполняемого модуля в системе Berkely
	   (BSD) и в нынешней AT&T System V.  Он происходит из системы Berkely, но
	   поддерживается теперь в System V.  Это иллюстрация взаимодействия между
	   этими двумя источниками в мире UNIX, поскольку они взаимствуют полезные
	   идеи друг у друга.  Данное конкретное воплощение ctags является команд-
	   ным файлом утилиты awk,  имитирующим исполняемую программу  из  системы
	   Berkely,  а  это  значит,  что  пользователи  систем XENIX и предыдущих
	   версий AT&T могут теперь извлечь пользу от применения ctags.  Еще  одно
	   преимущество версии в виде командного файла в том,  что его можно легко
	   модифицировать,  чтобы обрабатывать другие особенности языка Си.  Такое
	   вы не можете делать с исполняемым модулем,  если только у вас нет доро-
	   гостоящей лицензии на исходный код.

			ЧТО ДЕЛАЕТ ctags?

			Ctags просматривает файлы с исходным кодом на Си, переданные в ко-
	   мандной строке, и печатает список имен функций в каждом исходном файле.
	   Имена функций имеют специальный синтаксис и должны быть именно в  таком
	   формате,  иначе awk не распознает их как таковые.  Эти правила заключа-
	   ются в том, что имя функции должно находиться в начале строки, состоять
	   из разрешенных символов и за ним должна следовать левая скобка. Пробелы
	   в имени функции не допускаются.  Вот пример модуля программы на Си, по-
	   даваемого на рассмотрение командному файлу ctags:
</BIG>
<CODE>main()
{
}

func1(arg1,arg2)
int arg1,arg2;
{
}

func2(arg1,arg2)int arg1,arg2;
{
}

</CODE><BIG>			Результат работы ctags направляется в стандартный  вывод  (на  эк-
	   ран),  поэтому он должен быть перенаправлен, чтобы попасть в файл. Вхо-
	   дом для ctags является любое число имен файлов.  Напомним,  что если на
	   входе имеется несколько файлов, то выход представляет собой один непре-
	   рывный поток данных,  попадающий в один файл.  Если вам нужен  выводной
	   файл  для каждого входного файла,  то для управления ctags можно приме-
	   нить такой командный файл с циклом:
</BIG>
<CODE>for F in *.c
do
		ctags $F > $F.tags
done

	 Выход ctags состоит из трех полей в таком формате:

признак   имя_файла   шаблон_поиска

			Реальный выход для примера программы на Си, приведенного выше, был бы
	   таким:

main   /usr/russ/src/program.c  /^main()$/
func1  /usr/russ/src/program.c  /^func1(arg1,arg2)$/
func2  /usr/russ/src/program.c  /^func2(arg1,arg2)$/

</CODE><BIG>			Первое поле является именем признака (которое совпадает  с  именем
	   функции).  Второе поле - маршрутное имя файла, содержащего данную функ-
	   цию.  Третье поле - шаблон поиска, используемый признаковыми средствами
	   редактора  для доступа к функции внутри файла (более подробно об этом -
	   позже).
			Предположим, вы  можете  сгенерировать  правильный файл признаков.
	   Как согласовать файл признаков с редакторами таким  образом,  чтобы  вы
	   могли  найти интересующую вас функцию?  Редактор vi предоставляет много
	   путей для этого.  Первый способ -  поместить  имя  используемого  файла
	   признаков  в  файл .exrc.  (Файл .exrc является аналогом файла .profile
	   для редактора ex и работает также с редактором vi,  что не удивительно,
	   так как vi построен na ex.  Поскольку vi - наиболее популярный редактор
	   системы UNIX,  мы применяем его здесь для наших  примеров.)  Вы  можете
	   иметь файл .exrc, который выглядит примерно так:
</BIG><CODE>			set tags=/usr/russ/mytags</CODE>
			<BIG>Впоследствии, когда вы обращаетесь к некоторому признаку,  исполь-
	   зуется данный файл признаков. Другой способ - установить файл признаков
	   после того,  как вы вошли в редактор.  Чтобы посмотреть, каким является
	   ваш файл признаков по умолчанию, введите, находясь в vi, следующее:
</BIG><CODE>			:set tags
</CODE>			<BIG>Эта команда печатает файл признаков,  о котором она знает. Для из-
	   менения  определенного в настоящий момент файла признаков,  используйте
	   синтаксис, который был в примере файла .exrc:
</BIG><CODE>			:set tags=/usr/russ/mytags
</CODE>			<BIG>Теперь, когда редактор знает, в каком файле искать признаки, к ко-
	   торым  вы  обращаетесь,  давайте рассмотрим,  как обращаться к признаку
	   (т.е. к имени функции). Первый способ - объявить его в командной строке
	   при вызове редактора. Например:
</BIG><CODE>			$ vi -t tag
</CODE><BIG>			Если вы уже находитесь в редакторе vi,  можете применить такую ко-
	   манду для поиска признака:
</BIG><CODE>			:ta tag
</CODE><BIG>			Двоеточие означает, что мы направляемся в ex, чтобы выполнить этот
	   поиск.  Мы просим ex найти указанную строку как признак, который разме-
	   щается в текущем файле признаков.  Когда этот признак  найден  в  файле
	   признаков, редактор vi редактирует файл с соответствующим именем, кото-
	   рое он берет из поля 2.  Это аналогично команде ":e  имя_файла".  Когда
	   новый  файл  внесен  в буфер редактора,  последнее поле файла признаков
	   используется в качестве строки шаблона поиска.  Синтаксис  точно  такой
	   же,  как если бы вы набирали его вручную. Курсор перемещается в позицию
	   в файле,  которая соответствует строке поиска, при этом вы попадаете на
	   интересующую вас функцию.

			ВЗАИМОСВЯЗЬ МЕЖДУ ex И vi

			Несколько отклоняясь  от  темы,  рассмотрим два файла:  /bin/ ex и
	   /bin/vi.  Небольшое исследование обнаруживает,  что на самом  деле  это
	   один и тот же файл.  Мы можем проверить это,  посмотрев на их индексные
	   описатели файлов. Введите такую команду:
</BIG><CODE>			$ ls -li `path ex vi`
</CODE><BIG>			Выход показывает, что два числа в первой колонке одинаковы.
</BIG><CODE>
510 -rwx--x--t   5 bin	bin	121412 Sep 19  1985 /bin/ex
510 -rwx--x--t   5 bin	bin	121412 Sep 19  1985 /bin/vi

</CODE><BIG>			Это число и есть индексный описатель файла (inode).  Поскольку оба
	   файла являются одним и тем же, вызов любого из них запускает один и тот
	   же  исполняемый  модуль.  Каким  образом он знает,  как вы его вызвали?
	   Программа смотрит на строку argv[0] и видит,  какое имя вы использовали
	   для  вызова файла.  Затем редактор устанавливает свой интерфейс в соот-
	   ветствии с тем, как вы его вызвали.
			Обратите внимание,  что  эта программа имеет пять связей.  Как нам
	   найти все другие имена,  которыми можно  вызвать  vi  и  ex?  Мы  можем
	   использовать команду системы UNIX ncheck.  Эта команда воспринимает ин-
	   дексный описатель файла и печатает все файлы,  имеющие такой  описатель
	   файла . Примеры таких команд:
			$ ncheck -i 510 /dev/root
			$ ncheck -i 510
			Первый синтаксис указывает команде ncheck искать  файлы  с  inode,
	   равным 510,  только в корневой файловой системе.  Ncheck ограничена по-
	   иском в одной файловой системе.  Это подкрепляет тот факт, что файлы не
	   могут  быть  привязаны к различным файловым системам,  поскольку каждая
	   файловая система начинается с inode 2 и  последовательно  наращивается.
	   Каждая  файловая  система имеет inode 510,  который уникален для каждой
	   файловой системы. Выход предыдущей команды выглядит так:
</BIG><CODE>
dev/root:
510	 /bin/edit
510	 /bin/ex
510	 /bin/vedit
510	 /bin/vi
510	 /bin/view
</CODE>
<BIG>			Если файловая система не указана,  как во втором примере, выполня-
	   ется поиск по всем файловым системам, смонтированным в настоящее время.
	   Это  не  слишком хорошо для нас,  поскольку пять связей vi должны нахо-
	   диться в одной и той же файловой системе. В противном случае файлы были
	   бы  связаны поперек границ файловых систем.  Мы уже можем сказать,  что
	   никаких файлов редактора нет в каталоге  /usr,  размещенном  во  втором
	   разделе диска от корневой файловой системы.

<ul><a name=159></a><h2>ПРИМЕРЫ</h2></ul>
</BIG><CODE>			1. $ ctags *.c
</CODE><BIG>			Генерирует файл признаков для всех файлов с исходным кодом на Си в
	   текущем каталоге. Выход направляется на экран в отсортированном порядке
	   для каждого файла.  Порядок файлов алфавитный, так как указано расшире-
	   ние файла. Конечно, в большинстве случаев вы захотите перенаправить вы-
	   ход ctags в файл.
</BIG>
<CODE>			2. $ ctags `Find /usr/src -name "*.c" -print`
</CODE>
<BIG>			Этот синтаксис  использует командную подстановку,  чтобы найти все
	   имена файлов,  оканчивающиеся на .c и поместить их в командную  строку.
	   Проблема в том, что если найдено слишком много файлов, командная строка
	   ctags может переполниться и испортить всю  команду.  В  зависимости  от
	   серьезности переполнения, она может испортить и весь ваш процесс shell.
</BIG>
<CODE>			3. $ find /usr/src -name "*.c" -exec ctags {} \; > tags
</CODE>
<BIG>			Находит все  исходные файлы на Си в сегменте дерева /usr/src.  Для
	   каждого подходящего файла запускает  программу  ctags  на  этом  файле.
	   Использование  такой  формы записи предотвращает порчу вашей команды (о
	   которой только что шла речь), а также запускает ctags для каждого имени
	   файла.  Весь  выход помещается в файл tags для последующего использова-
	   ния.
</BIG><CODE>			4. $ find /usr/src -type f -print | sort |
			> while read FILE
			> do
			> ctags $FILE
			> done >> tags
</CODE>
<BIG>			Используя преимущество множественных каталогов, находит и сортиру-
	   ет все файлы из каталога /usr/src и  печатает  их  маршрутные  имена  в
	   стандартный  вывод.  Затем  они  сортируются и поступают по конвейеру в
	   цикл while. Цикл while используется для обслуживания сколь угодно боль-
	   шого числа файлов без переполнения буферов.  Выход цикла while добавля-
	   ется к одному файлу - tags. Этот цикл громоздкий и медленный, но он вы-
	   полняет свою работу.
</BIG>
<CODE>			5. $ find /usr/src -print | ctags
</CODE>
<BIG>			Это неправильный способ использования ctags.  Выходом команды find
	   являются маршрутные имена.  Ctags читает стандартный ввод,  поскольку в
	   командной  строке нет файлов.  Получается,  что данные,  которые читает
	   awk,  являются маршрутными именами от find, которые не имеют корректных
	   полей для соответствия шаблонам функций. Никакого сопоставления не про-
	   исходит.
			Аналогичную проблему могла бы вызвать такая командная строка:
</BIG>
<CODE>			find /usr -print | wc -l
</CODE>
<BIG>			Вы могли  бы интерпретировать это так:  "посчитать,  сколько строк
	   имеется во всех файлах каталога /usr". Но в действительности здесь ска-
	   зано:  "сколько имен файлов имеется в древовидной структуре /usr".  Для
	   подсчета общего количества строк в этих файлах нужен такой синтаксис:
</BIG><CODE>			find /usr -exec cat {} \; | wc -l
</CODE><BIG>			который гласит:  "найти  все  файлы в /usr,  распечатать каждый из
	   них, затем посчитать, сколько строк в них имеется". Чтобы так же посту-
	   пить с ctags, нужен такой синтаксис:
</BIG><CODE>			find /usr/src -name "*.c" -exec cat {} \; | ctags
</CODE><BIG>			В отличие от результата,  который мы получили бы в предыдущих при-
	   мерах:
</BIG><CODE>
func1  /usr/russ/src/program.c  /^func1(arg1,arg2)$/
func2  /usr/russ/src/program.c  /^func2(arg1,arg2)$/

			теперь выход будет выглядеть так:

func1		 -		  /^func1(arg1,arg2)$/
func2		 -		  /^func2(arg1,arg2)$/
</CODE>
<BIG>
<ul><a name=160></a><h2>ПОЯСНЕНИЯ</h2></ul>

			Символы "-" вместо имени файла появляются из-за  того,  что  ctags
	   читает из стандартного ввода. Awk автоматически присваивает своей внут-
	   ренней переменной FILENAME значение "-", так как знает, что в командной
	   строке не было файлов.
			Весь командный файл есть программа awk. Входом для командного фай-
	   ла утилиты awk является $@, что представляет все позиционные параметры.
	   Каждый параметр считается именем исходного файла на  Си.  Если  никакие
	   файлы  не передаются в командной строке,  awk ищет данные в стандартном
	   входном потоке,  но это создает некорректный выход,  так как переменная
	   FILENAME  в awk имеет по умолчанию значение "-".  Поскольку awk требует
	   имена файлов,  мы должны вызывать ctags с именами файлов,  а не переда-
	   вать  ему  данные  по конвейеру через стандартный ввод,  как показано в
	   предыдущем примере.
			Awk читает  каждый  раз одну строку из файла данных и сверяет ее с
	   шаблоном,  пытаясь установить соответствие.  Для каждой  строки,  соот-
	   ветствующей шаблону,  awk выполняет заданную программу. Первое, что де-
	   лает ctags,- изменяет подразумеваемый разделитель полей утилиты  awk  с
	   пробела  на  левую скобку.  Благодаря использованию этого символа в ка-
	   честве разделителя полей, строка определения функции разбивается на два
	   поля: имя функции и остаток строки.
			Шаблон поиска утилиты awk соответствует синтаксису имени  Си-функ-
	   ции.  Оно может начинаться с символов a-z,  A-Z или символа подчеркива-
	   ния.  Далее в имени могут быть любые символы из набора a-z,  A-Z, 0-9 и
	   _. Между именем и скобкой нельзя использовать пробелы. Поиск начинается
	   от начала строки (^),  за которым следует последовательность допустимых
	   символов (a-z, A-Z, 0-9), а затем левая скобка.
			Когда строка соответствует данному шаблону,  генерируется выход  с
	   помощью оператора printf.  Первое поле - строка, представленная обозна-
	   чением $1.  В данном случае $1 - это только имя функции, исключая левую
	   скобку.  Печатается символ табуляции,  затем следующая строка,  которая
	   является переменной FILENAME из утилиты awk. Эта переменная должна быть
	   получена из командной строки, иначе awk не будет знать имя файла, в ко-
	   тором размещена данная функция,  и файл признаков потеряет  информацию,
	   необходимую  для доступа к файлу,  содержащему функцию.  Печатается еще
	   одна табуляция,  затем строка поиска.  Строкой поиска является $0,  что
	   представляет  всю строку,  с которой работает awk.  Строке предшествует
	   символ ^, а за строкой следует символ $.
			Выход пропускается по конвейеру через sort с той целью,  чтобы все
	   признаки шли в отсортированном порядке. Опции сортировки указывают ути-
	   лите sort проверять только первое поле и печатать только одно появление
	   строки, если имеется несколько записей.

			МОДИФИКАЦИИ ДЛЯ ctags

			Теперь, когда мы знакомы с  общим  форматом  редактируемого  файла
	   признаков, можем ли мы применить его для других полезных целей? Мы зна-
	   ем,  что мы можем идентифицировать регулярные структуры в программах на
	   Сии  создать  признаки,  с помощью которых можно получить доступ к этим
	   структурам в редакторе.  В программах на Си  имеются  не  только  имена
	   функций,  но и другие интересные конструкции,  например имена структур.
	   Их  можно  обслуживать  с  помощью   модифицированной   версии   ctags.
	   Единственное, что нам нужно знать,- это официальный синтаксис структуры
	   данных.  Структура данных,  которая нас бы заинтересовала,  часто имеет
	   такой формат:
</BIG><CODE>
struct name {
		int val1;
		char val2;
};
</CODE>
<BIG>			Все, что мы должны сделать,- это заставить awk искать все  появле-
	   ния определения структуры.  Затем мы можем построить файл признаков,  в
	   котором признаком является имя структуры.  Этот файл, видимо, будет та-
	   ким  же,  как и прежде,  а строка поиска будет обнаруживать определение
	   структуры,  а не имя функции. Фактически, комбинация утилиты awk, приз-
	   наков  и  редактора может быть использована для любого вида информации,
	   которую вы можете захотеть хранить в файле специального формата, напри-
	   мер для адресов,  заметок,  библиографических ссылок и т.д.  Вам просто
	   нужно подобрать соответствующие разделители и  правильно  их  использо-
	   вать.
			Мы надеемся,  что облегчили сопровождение ваших программ и предло-
	   жили  вам  идеи для других способов автоматической обработки документа-
	   ции.  Вы можете без особого труда учреждать  и  поддерживать  локальные
	   соглашения  о  документации  с  помощью  командных файлов,  аналогичных
	   представленным здесь.  Примером проекта,  за который вы можете взяться,
	   является  согласование  наших  программ  извлечения информации (stripf,
	   stripc,  strips) и других программ,  которые вы пишете,  таким образом,
	   чтобы они могли читать файл-формирователь (makefile, см. Make(1)) и вы-
	   давать полную документацию по всем исходным файлам,  участвующим в дан-
	   ном проекте.
</BIG></pre><hr>
<A HREF="chap03.htm">Назад.</A>
<A HREF="chap05.htm">Вперёд.</A>
<A HREF="chap00.htm#toc4.1">Оглавление.</A><hr>

<BR>
<table cellspacing="2" cellpadding="2" border="0">
<tr VALIGN=TOP>
<td>
<!-- BEGIN MGUL-COUNTER CODE -->
<img src="http://ns.mgul.ac.ru/cgi-bin/counter.cgi?Linux" border=0 height=31 width=88 alt="LSCS">
<!-- END MGUL-COUNTER CODE -->
</td>
	<td rowspan="2">
<!--begin of Top100-->
<a href="http://top100.rambler.ru/top100/">
<img src="http://counter.rambler.ru/top100.cnt?124566" alt="Rambler's Top100" width=1 height=1

border=0></a>
<!--end of Top100 code-->

<!--begin of Top100 logo-->
<a href="http://top100.rambler.ru/top100/">
[AD-SIZE]<AD- ://images.rambler.ru/top100/banner-88x31-rambler-blue3.gif" alt="Rambler's Top100"

width=88 height=31 border=0></a>
<!--end of Top100 logo -->
</td>
<td>
<!--TopList COUNTER--><script language="JavaScript"><!--
d=document;a='';a+=';r='+escape(d.referrer)
js=10//--></script><script language="JavaScript1.1"><!--
a+=';j='+navigator.javaEnabled()
js=11//--></script><script language="JavaScript1.2"><!--
s=screen;a+=';s='+s.width+'*'+s.height
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth)
js=12//--></script><script language="JavaScript1.3"><!--
js=13//--></script><script language="JavaScript"><!--
d.write('<a href="http://top.list.ru/jump?from=61405"'+
' target=_top><img src="http://top.list.ru/counter'+
'?id=61405;t=99;js='+js+a+';rand='+Math.random()+
'" alt="TopList"'+' border=0 height=18 width=88></a>')
if(js>11)d.write('<'+'!-- ')//--></script><noscript><a
target=_top href="http://top.list.ru/jump?from=61405"><img
src="http://top.list.ru/counter?js=na;id=61405;t=99"
border=0 height=18 width=88
alt="TopList"></a></noscript><script language="JavaScript"><!--
if(js>11)d.write('--'+'>')//--></script><!--TopList COUNTER-->
</td>
</tr>
</TABLE>
</body></html>
