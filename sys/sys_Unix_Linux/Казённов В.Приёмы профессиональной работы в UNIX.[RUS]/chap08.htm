<html>
<head>
<title>ГЛАВА 8. Коммуникации в системе UNIX</title>
			<style type="text/css">
A.noneline { font-family: Arial, Serif; text-decoration: none; }
FONT.arial { font-family: Arial, Serif; }
TD.arial   { font-family: Arial, Serif; }
TH.arial   { font-family: Arial, Serif; }
PRE		{ font-family: Arial, Serif; }
SAMP	   { font-family: Courier; color: navy; }
TT		 { font-family: Monospace; color: navy; }
VAR		{ font-family: Monospace; color: navy; }
CODE	   { font-family: Monospace; color: navy; }
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<basefont size="3">
<center>
<table width=100% border=0 cellpadding=0>
<table cellspacing=0 cellpadding=0 border=0 background="../pic/logo1.jpg" width="100%">
<tr valign=top><td class=arial><a href="http://www.mgul.ac.ru/"><img height=80 width=109 src="../pic/logo.gif" alt="Server of laboratory of space computer science MGUL" border=0></a><br>
</td>
<td align=right class=arial>
<font size="-2">
141001 г.Мытищи МО<br>
<a class=noneline href="http://www.mgul.ac.ru">Ул.Институтская д:1 ком:101</a><br>
(095) 588-32-09, 588-55-62<br>
E-mail: <a class=noneline href="mailto:T-Alex@mgul.ac.ru?Subject='From page topic CIT-FORUM'">T-Alex@mgul.ac.ru</a></font>
</tr>
<tr>
<th colspan=2 class=times>
<font color=#000080 size=2><a href="http://www.mgul.ac.ru" class=noneline>Сервер Лаб. Космической информатики каф.ВТ</a> Московский Государственный Университет Леса</font>
<hr noshade>
</th>
</tr>
</table>
</center>
<A HREF="chap07.htm">Назад.</A>
<A HREF="chap09.htm">Вперёд.</A>
<A HREF="chap00.htm#toc8.1">Оглавление.</A><hr>

<ul><a name=340></a><h2><FONT COLOR="#69BCCB"> * ГЛАВА 8. Коммуникации в системе UNIX * </FONT></h2></ul>

<H6><BL>
 <LI><A HREF="#341">ВВЕДЕНИЕ</LI>
 <LI><A HREF="#342">ФИЗИЧЕСКОЕ ПОДКЛЮЧЕНИЕ</LI>
 <LI><A HREF="#343">ПОДКЛЮЧЕНИЕ БЕЗ КОММУНИКАЦИОННЫХ УСТРОЙСТВ</LI>
 <LI><A HREF="#344">ПРЯМОЕ ПОДКЛЮЧЕНИЕ</LI>
 <LI><A HREF="#345">ДИСТАНЦИОННОЕ ПОДКЛЮЧЕНИЕ</LI>
 <LI><A HREF="#346">ОБНАРУЖЕНИЕ МОДЕМОВ В СИСТЕМЕ</LI>
 <LI><A HREF="#347">ИСПОЛЬЗОВАНИЕ И КОНФИГУРИРОВАНИЕ ЛИНИИ</LI>
 <LI><A HREF="#348">ИЗМЕНЕНИЕ СКОРОСТЕЙ ОБМЕНА</LI>
 <LI><A HREF="#349">ЗАХВАТ ДАННЫХ</LI>
 <LI><A HREF="#350">ИНСТРУМЕНТАЛЬНЫЕ СРЕДСТВА ДЛЯ КОММУНИКАЦИОННЫХ ЛИНИЙ</LI>
 <LI><A HREF="#362">ДОСТУП ИЗ UNIX В UNIX</LI>
 <LI><A HREF="#364">СЕТЕВАЯ БЕЗОПАСНОСТЬ</LI>
 <LI><A HREF="#365">ОГРАНИЧИТЕЛЬНЫЕ ФАЙЛЫ</LI>
 <LI><A HREF="#366">ОТЛАДКА КОММУНИКАЦИЙ</LI>
 <LI><A HREF="#381">КОНФИГУРАЦИОННЫЕ РЕШЕНИЯ</LI></H6>
 <LI><A HREF="#351">" cuchk "-Cu check - проверка свободной линии для cu</LI>
 <LI><A HREF="#353">" cuchk "-Сообщить, когда cu освободит линию</LI>
 <LI><A HREF="#356">" talk "-Обращение к последовательному порту</LI>
 <LI><A HREF="#367">" uust "-Состояние uucp и служебные действия</LI>
 <LI><A HREF="#374">" uutrans "-Передача файловых деревьев из одной системы в другую</LI>
</BL>

<pre>
<BIG>
<ul><a name=341></a><h2>ВВЕДЕНИЕ</h2></ul>

	 В данной главе мы рассматриваем средства коммуникации  в системе
UNIX.  В  то  время  как в мире MS-DOS коммуникации ограничены обычно
"черным  ящиком"  (программными  пакетами  и  довольно   стандартными
модемами),  коммуникации в системе UNIX более сложны. UNIX предлагает
несколько уровней коммуникаций,  включая передачу  файлов,  удаленную
регистрацию в системе,  дистанционную почту и развитые системы обмена
сообщениями, которые могут связывать между собой сотни систем UNIX.

	 Однако, в  большинстве  систем  UNIX  нет  удобно   оформленных,
управляемых с помощью меню средств коммуникации. Вместо этого имеются
сложные системные команды и необходимость поддерживать  много файлов.
Обычно  требуется  также владеть многими подробностями конфигурации и
использования модемов.  Мы  предлагаем  теоретическое  обоснование  и
практические рекомендации, а также инструментальные средства, которые
помогут  вам  освоить  данный  аспект  системы  UNIX   и   обеспечить
работоспособность  коммуникаций  в  вашей  системе.  Мы рассмотрим не
только  прямую  связь  между  машинами,  но  и  связь  с   удаленными
терминалами и модемами.

	 Сначала мы  займемся  физическими  соединениями,  что   является
первым этапом установки линии связи.  Мы рассмотрим модель интерфейса
RS232-C и выясним, как подключить прямую межмашинную связь.

	 Затем мы обсудим обращение к системе UNIX с микро-ЭВМ. Поговорим
о том,  какие  существуют  виды  протоколов  и  какие  из  них  лучше
использовать.

	 Далее мы рассмотрим,  как пользоваться модемом, чтобы вызвать из
UNIX другие системы, например доски объявлений и системы, отличные от
UNIX. Вы можете изучить, как найти все модемные соединения в системе,
подключиться  к  последовательному  порту  и  управлять модемом.  При
обращении  к  другой  системе  вы  можете  перехватить  все   данные,
поступающие на ваш терминал,  и сохранить их в файле для последующего
использования. Командные  файлы  (cuchk  и  talk),  представленные  в
данном разделе,  следят за доступностью линии связи  и  устанавливают
связь с модемом.

	 В завершение  мы рассмотрим связь между системами UNIX с помощью
утилиты uucp. Мы увидим, как и куда передавать файлы между системами,
как файлы  защиты  данных  управляют  средой  uucp  и  изучим способы
отладки механизма передачи файлов с помощью uucp.  Здесь представлены
командные  файлы  uust для выполнения рутинной работы по обслуживанию
uucp и uutrans для копирования  древовидной  структуры  каталогов  из
одной системы в другую.


<ul><a name=342></a><h2>ФИЗИЧЕСКОЕ ПОДКЛЮЧЕНИЕ</h2></ul>

	 Большинство машин,  на которых работает  UNIX,  имеют  один  или
несколько последовательных  портов.  Эти  порты  - глаза и уши машин,
позволяющие  системе  связываться   с   внешним   миром.   Их   можно
использовать для подключения любого устройства с интерфейсом RS-232-C
и для связи или управления.  В  данном  разделе  мы  рассмотрим,  как
подключить  интерфейс RS -232-C для обеспечения связи типа UNIX-UNIX,
терминал-UNIX и модем-UNIX.

	 Начнем с рассмотрения базовой  модели  RS-232-C,  показанной  на
рис.  8-1.  Эта модель иллюстрирует, как могут общаться друг с другом
две машины и/или терминалы либо через модемы  по  телефонным  линиям,
либо  по  прямой  (проводной)  связи.  Хотя последующее обсуждение мы
ведем преимущественно в терминах телефонных соединений, те же базовые
принципы относятся  и  к  прямой  связи,  за  исключением  того,  что
коммуникационные устройства (DCE,  data  communication  equipment)  в
этом случае не нужны.


	  Рис. 8-1.	 Стандартная модель интерфейса RS-232-C</BIG>
<CODE><hr>

								_||_
  +-------+   2	*****		_||_		*****	2   +-------+
  |	   |------>*	 *----\   ||   /----*	 *<------|	   |
  | DTE-1 |	   * DCE *	  \ || /	  * DCE *	   | DTE-2 |
  |	   |<------*	 *	  / || \	  *	 *------>|	   |
  +-------+   3   *	 *<---/   ||   \--->*	 *   3   +-------+
				   *****		 ||		 *****

<hr></CODE>
<BIG>
	 На каждом конце находятся  терминальные  устройства,  называемые
DTE   (data  terminating  equipment).  В  роли  DTE  может  выступать
терминал,  например,  VT-100, или центральный процессор микро-, мини-
или большой ЭВМ.

	 Каждое терминальное	устройство	DTE   должно   использовать
коммуникационное  устройство  DCE,  называемое  обычно  модемом,  для
модуляции  и  демодуляции сигналов,  проходящих по телефонным линиям.
Каждое DTE использует вывод номер 2 для передачи данных и вывод номер
3  для  получения  данных.  Поскольку то,  что передано с вывода 2 на
каждой машине,  принимается на  выводе  3  другой  машины,  возникает
перекрещивание телефонных линий между устройствами DCE.

	 Подсоединение и обработка сигнала  между  DTE  и  DCE  полностью
соответствуют  стандарту RS-232-C.  Аппаратный протокол позволяет DTE
использовать DCE для посылки и приема данных от другого DTE.

	 Кабель, связывающий	физически	DTE	и   DCE,   называется
"прямолинейным" кабелем. Он позволяет устройству DTE посылать команды
(или  сигналы с выводов) на DCE,  а устройству DCE отправлять команды
обратно на DTE.  Подключение DCE одной машины  к  DCE  другой  машины
производится через обычные телефонные линии.

	 Устройства DCE необходимы по той  причине,  что  устройства  DTE
являются  цифровыми,  а телефонные линии - аналоговыми.  Единственный
способ  передать  цифровую  информацию   по   аналоговым   линиям   -
закодировать  цифровую  информацию в аналоговый сигнал,  послать этот
сигнал по телефонным линиям,  а затем декодировать аналоговый  сигнал
обратно в цифровую информацию.


<ul><a name=343></a><h2>ПОДКЛЮЧЕНИЕ БЕЗ КОММУНИКАЦИОННЫХ УСТРОЙСТВ</h2></ul>

	 Если ваши машины расположены  довольно  близко  (в  пределах  50
футов /  15  метров.  Один  фут  составляет около 30.5 см.  - Примеч.
перев./), вам не нужен модем, вы можете использовать кабель "нулевого
модема"  вместо  DCE.  Кабель  нулевого  модема  имитирует  такой  же
протокол,  что и DCE,  но не требует наличия модема для коммуникаций.
Основная	задача   подключения   нулевого   модема   -   обеспечить
перекрещивание между передающими и принимающими сигналами. На рис. 8-
2 показана общая схема подключения без устройств DCE.


			Рис. 8-2.	  Конфигурация с нулевым модемом</BIG>
<<CODE>hr>

		   +-------+   2			   2   +-------+
		   |	   |------>...   ...<------|	   |
		   |  DTE  |   3	  \./	  3   |  DTE  |
		   |	   |<------.../ \...------>|	   |
		   +-------+					   +-------+

<hr>
</CODE>
<BIG>
	 Для того чтобы выполнить подключение, имитирующее DCE, требуются
некоторые   манипуляции   с   сигналами.   Эти   манипуляции	также
стандартизованы  в  кабеле  нулевого  модема.  По схеме этого кабеля,
показанной на рис. 8-3, рассмотрим, как он имитирует сигналы DCE.


			  Рис. 8-3. Кабель нулевого модема RS-232-C</BIG>
<CODE><hr>

							  DTE-1					  DTE-2
							  ||						 ||
ЗАЩИТНАЯ ЗЕМЛЯ			  1 ||-------------------------|| 1
(PROTECTIVE GROUND)		   ||						 ||
							  ||						 ||
СИГНАЛЬНАЯ ЗЕМЛЯ			7 ||-------------------------|| 7
(SIGNAL GROUND)			   ||						 ||
							  ||						 ||
ПЕРЕДАЧА ДАННЫХ			 2 ||----------\   /----------|| 2
(TRANSMIT DATA)			   ||			.			||
ПРИЕМ ДАННЫХ				3 ||<---------/   \--------->|| 3
(RECEIVE DATA)				||						 ||
							  ||						 ||
ЗАПРОС ПЕРЕДАЧИ			 4 ||-----			   -----|| 4
(REQUEST TO SEND)			 ||	 |			 |	 ||
							  ||	 |			 |	 ||
ГАШЕНИЕ ПЕРЕДАЧИ			5 ||<----\			 /---->|| 5
(CLEAR TO SEND)			   ||	  \---\   /---/	  ||
							  ||			.			||
ИДЕТ ПЕРЕДАЧА ДАННЫХ		8 ||<---------/   \--------->|| 8
(DATA CARRIER DETECT)		 ||						 ||
							  ||						 ||
ГОТОВНОСТЬ НАБОРА ДАННЫХ	6 ||<---------\   /--------->|| 6
(DATA SET READY)			  ||			.			||
ГОТОВНОСТЬ ТЕРМИНАЛА	   20 ||----------/   \----------|| 20
(DATA TERMINAL READY)		 ||						 ||
							  ||						 ||

<hr></CODE>
<BIG>
	 Линии 1   и   7   используются  для  шасси  и  сигнальной  земли
соответственно.  Линии 2 и 3 пересекаются таким образом,  чтобы когда
одна  сторона  говорит,  другая  слушала.  Обе стороны могут говорить
одновременно  (это  называется  полнодуплексным  режимом),  если   мы
используем различные наборы проводов.

	 Для имитации управляющих сигналов линии 4,  5 и 8 подсоединяются
так,  как показано на рис.  8-3.  Каждый раз,  когда устройство DTE-1
активизирует  линию  "Request  to  Send"  ("Запрос  передачи"),  т.е.
передает  по  ней  сигнал,  оно получает назад сигнал "Clear to Send"
("Гашение передачи"),  указывающий, что другая сторона готова принять
данные.  Затем,  посылая сигнал по линии "Dаta Carrier Detect" ("Идет
передача данных"),  устройство DTE-1  сообщает  другой  стороне,  что
поступают   данные.   Такое   методичное   "аппаратное   рукопожатие"
гарантирует,  что никакие данные не  будут  отправлены,  пока  другая
сторона не будет готова их принять.

	 Линии 6  и  20  подсоединяются  так,  чтобы обеспечить последние
управляющие сигналы нулевого модема. Пока DTE активно ("Data Terminal
Ready" - "Готовность терминала",  линия 20),  другая сторона считает,
что имеет дело с активным модемом ("Data  Set  Ready"  -  "Готовность
набора данных",  линия 6).  При таком способе соединения линий 6 и 20
всякий  раз,  когда  вы  выдергиваете  ваш  кабель  из   машины   или
переключаете  его  на  другой  канал  соединительной коробки,  другая
сторона теряет ваш сигнал активности и  отключается  (или  генерирует
сигнал HUP - hangs up, повесить трубку телефона). Чтобы сделать такой
кабель,  который не вызывает отключения при вынимании штепселя  (т.е.
NOHUP),  присоедините  выход "Data Terminal Ready" ко входу "Data Set
Ready" на том же устройстве  DTE.  Это  заставляет  систему  сообщать
самой себе, что модем всегда готов.

	 Заметим, что рассмотренная  схема  подключения  нулевого  модема
является  рекомендуемой,  но существуют и другие способы,  поэтому не
думайте, что все нулевые модемы одинаковы. В каждом конкретном случае
для  нулевых  модемов учитывается определенное окружение или функция,
например наличие безобрывного (nohup) варианта подключения.

	 Теперь, когда  мы  знаем два различных способа соединения машин,
мы можем рассмотреть способы коммуникаций и типы подключения, которые
могут нам пригодиться.


		  ДОСТУП МИКРО-ЭВМ ИЛИ ТЕРМИНАЛА К СИСТЕМЕ UNIX

	 В этом разделе мы рассмотрим различные способы общения микро-ЭВМ
и  автономных терминалов с системой UNIX.  Мы предполагаем,  что одно
устройство DTE работает  не  под  управлением  UNIX  и  обращается  к
другому устройству, управляемому системой UNIX.


<ul><a name=344></a><h2>ПРЯМОЕ ПОДКЛЮЧЕНИЕ</h2></ul>

	 В простейшем   случае   имеется	терминал	или	микро-ЭВМ,
подсоединенные  непосредственно  к  системе  UNIX.  Это  очень  часто
встречается в системах разработки, когда UNIX используется в качестве
кросс-компилятора,  а  результирующий  код  загружается  в микро-ЭВМ.
Другая  ситуация  -  когда  терминалы  находятся  на  рабочих  столах
сотрудников  и  применяются для выполнения бумажной работы,  отправки
почты,  печати документов  и  т.д.  Типичные  конфигурации  с  прямым
подсоединением показаны на рис. 8-4.

	 Обычный сценарий  подключения  терминала выглядит примерно таким
образом.  Пользователь с  помощью  терминала,  например  DEC  VT-100,
регистрируется   в   системе   UNIX  по  прямой  связи.  Терминальное
устройство DTE должно быть установлено в  соответствии  с  правильной
внутренней  конфигурацией,  включая  скорость  в  бодах,  стартовые и
стоповые биты,  число битов данных и четность.  Это обычные установки
терминала,  которые  можно  задать  либо тумблерными переключателями,
либо при помощи терминальной микропрограммы "SETUP".

	 Микро-ЭВМ, в отличие от терминала,  должна  запустить  некоторое
коммуникационное  программное  обеспечение для корректного управления
аппаратурой.  Эти программы обычно снабжены меню или каким-то  другим
способом   указания   параметров   -  таких  же,  как  у  терминалов.
Действительно,  имеются программные пакеты, обеспечивающие полную или
почти  полную  эмуляцию  популярных  терминалов,  таких  как  VT-100.
Коммуникацинное   программное   обеспечение,	используемое	вами,
устанавливается  не  специально  для  UNIX,  а для обработки сигналов
RS-232-C,  которые обычно не зависят от того, прямое ли подсоединение
или через модем.


	 Рис. 8-4. Прямое подключение терминалов и микро-ЭВМ к UNIX</BIG>
<CODE><hr>

	 DTE-1				   DTE-2
		ДЕЙСТВИЕ											 ДЕЙСТВИЕ
				 +----------+			  +--------+
Микропрограмма   |		  | Нулевой модем|		| getty 9600 tty00
	SETUP		| терминал |--------------| tty00  | login имя_польз
				 |		  |			  |		| sh
				 +----------+			  |		|
										   |  UNIX  |
				 +----------+			  |		|
Коммуникационное |		  | Нулевой модем|		|
  программное	| микро-ЭВМ|--------------| tty01  |
  обеспечение	|		  |			  |		|
				 +----------+			  +--------+

<hr></CODE>
<BIG>
	 В качестве  кабеля,  соединяющего  терминал  (или  микро-ЭВМ)  с
системой	UNIX,	нужно	использовать   нулевой   модем.   Когда
коммуникационное  устройство  DCE  отсутствует,  применяется   кабель
нулевого модема.

	 В системе  UNIX  на  терминальном  устройстве  DTE  должна  быть
утилита getty (что первоначально означало "get teletype" -  доступ  к
телетайпу),  которая  работает  с  определенным портом и обнаруживает
момент, когда кто-то пытается зарегистрироваться в системе. Программа
getty  (описанная  в init(M) и getty(M)) выводит подсказку "login:" и
читает символы, поступающие по линии.

	 При прямом подключении процесс getty может работать со скоростью
9600 бод,  поэтому пользователи могут получить выигрыш от  применения
этой скорости.  Это значительно быстрее, чем 1200 или иногда 2400 бод
- скоростей,  которые используются чаще всего при работе  с  обычными
телефонными  линиями.  В  зависимости  от  того,  как установлен файл
gettydefs,  вы можете обычно изменить скорость работы getty,  нажимая
клавишу break.  Клавиша break генерирует не символ, а сигнал в линию,
который длится определенный интервал времени.  Драйверы  устройств  в
системе  UNIX  распознают  этот  сигнал  и  действуют соответствующим
образом.  Рассмотрение  самого  метода,  с  помощью  которого   getty
работает  на  различных  скоростях,  выходит за пределы данной книги.
Важно знать,  что если getty работает на  скорости  9600  бод,  а  вы
используете  терминал,  установленный  на  1200  бод,  то  вам  нужно
прокрутить  переключение  скоростей  getty  с  9600  бод  через   все
промежуточные  скорости  до  достижения  значения  1200 бод.  Держите
клавишу break нажатой до тех пор, пока getty не установится на нужную
вам скорость.  Следующий пример взят из файла gettydefs  в  OC  XENIX
System V и показывает, как связаны между собой скорости обмена.</BIG>
<CODE>
<hr>
|  5# B9600 PARENB CS7 OPOST ONLCR # B9600 SANE IXANY #Login: #1
|  4# B4800 PARENB CS7 OPOST ONLCR # B4800 SANE IXANY #Login: #5
|  3# B2400 PARENB CS7 OPOST ONLCR # B2400 SANE IXANY #Login: #4
|  2# B1200 CS8 OPOST ONLCR # B1200 SANE IXANY #Login: #3
|  1# B300 CS7 OPOST ONLCR # B300 SANE IXANY #Login: #2
|</CODE><BIG>
	 Здесь указание  #5  в  файле  inittab  (или  в  файле  ttys  для
пользователей XENIX и System III) порождает процесс getty, работающий
на скорости 9600 бод.  Если вы нажимаете клавишу break,  следующим по
порядку  является номер 1 (как указано в конце строки номер 5).  Если
вы нажимаете break еще раз,  то следующей является строка номер 2,  и
т.д. Если вы нажмете break достаточное количество раз, скорость getty
вернется по циклу к значению 9600 бод.

	 Вся последовательность  действий,  связанных  с  регистрацией  в
системе,  выглядит примерно так. Сначала init порождает процесс getty
(инициируемый из файла /etc/inittab) на определенном номере терминала
и  с определенной скоростью.  При этом устанавливаются характеристики
линии и выдается регистрационная подсказка. Когда пользователь вводит
регистрационное  имя,  getty  проверяет его на правильность,  а затем
выполняет программу login.  Login запрашивает  пароль,  зашифровывает
его  и  сверяет  с  зашифрованным  паролем в файле /etc/passwd.  Если
пароли совпадают,  login запускает процесс  shell,  который  печатает
shell-подсказку и читает ваши команды, поступающие с терминала. Какой
именно shell будет запущен - определяется записью  в  файле  паролей,
соответствующей	 данному	 регистрационному	 имени.	 Моему
регистрационному имени соответствует такая запись:</BIG>

<CODE> russ:j9egLecqEpXLg:201:51:Russ Sage:/usr/russ:/bin/shV</CODE>
<BIG>
	 В этом  случае  запускается  System  V  shell,  один  из   новых
shell-интерпретаторов фирмы AT&T.


<ul><a name=345></a><h2>ДИСТАНЦИОННОЕ ПОДКЛЮЧЕНИЕ</h2></ul>

	 Альтернативой прямому   подключению	является	дистанционное
подключение через модемную линию,  показанное на рис.  8-5. Установка
терминала или конфигурирование микро-ЭВМ выглядят  примерно  так  же,
как и в предыдущем случае, за исключением скорости обмена, на которой
работает терминал.  Для большинства модемов она должна равняться 1200
бодам.


	Рис. 8-5. Дистанционное подключение терминалов и микро-ЭВМ к UNIX</BIG>
<CODE><hr>
ДЕЙСТВИЕ
Команды модема
	DTE-1												   DTE-2
+----------+		 *****							   +--------+
|		  | прямой *	 *							  |		|
| терминал |-------* модем *\							|		|
|		  | кабель *	 *  \			 *****		 |  UNIX  |
+----------+		 *****	\  _||_	 *	 * прямой |		|
							   \ _||_ ---* модем *-------| tty00  |
							   /  ||	  *	 * кабель |		|
+----------+		 *****	/   ||	   *****		 |		|
|		  | прямой *	 *  /						   +--------+
| микро-ЭВМ|-------* модем */					  getty 1200 tty00
|		  | кабель *	 *						login имя_польз
+----------+		 *****						 sh
Коммуникационное обеспечение,
команда набора телефонного номера
<hr></CODE>
<BIG>
	 Терминал (когда	он   установлен   на   1200   бод)   общается
непосредственно с модемом.  При этом задействованы  модемные  команды
"набрать телефонный номер" (dial), "повесить трубку" (hang up) и т.д.
Микро-ЭВМ,  запускающая  коммуникационное  программное   обеспечение,
обычно  имеет  команду набора номера,  которая генерирует команду для
модема.  Соединение между терминалом/микро-ЭВМ и модемом должно  быть
выполнено в виде прямолинейного кабеля.  Модем имеет также телефонный
кабель, идущий в телефонную систему.

	 Поскольку мы имеем дело с UNIX,  последовательность действий при
регистрации в  системе  такая  же,  как  и  рассмотренная  ранее,  за
исключением  того,  что  getty  инициируется обычно со скоростью 1200
бод,  чтобы соответствовать скорости модема.  Если getty имеет другую
скорость,  переключите  ее  с  помощью клавиши break на значение 1200
бод.

	 Как только все действия по конфигурированию  завершены, терминал
или микро-ЭВМ может связаться с системой UNIX.  Как это сделать?  При
регистрации  пользователя  в   системе   структура   данных   termcap
используется  для  поддержки  управления экраном.  Если у вас еще нет
записи в файле termcap,  обратитесь к предыдущей главе,  где описано,
как   подготовить  такую  запись.  Терминалы  (поскольку  обычно  они
являются просто аппаратурой)  не  слишком  гибки  и  дружественны  по
отношению   к   пользователю.   Они   не  обладают  широким  спектром
возможностей  помимо  регистрации  в  системе  и  запуска   некоторых
программ. Микро-ЭВМ, с другой стороны, имеют большую гибкость и могут
многое добавить к пользовательскому интерфейсу с системой UNIX.

	 Коммуникационные программы  имеют  обычно  буфер памяти с прямой
адресацией (RAM),  который вы можете  использовать  для  того,  чтобы
захватить  данные и поместить их на диск.  Благодаря применению этого
буфера,  вы   можете   избавиться   от   необходимости   использовать
специальные команды UNIX для передачи файлов.  Вы можете дать команду
включения захвата данных,  затем отобразить файл на экран (используя,
например,  команду cat или просматривая файл редактором), если только
этот файл не слишком большой для буфера.

	 Следует иметь в виду,  однако,  что программные файлы или другие
файлы,   требующие   стопроцентной   точности   при  передаче,  нужно
передавать  с  явным  использованием   протокола   проверки   ошибок,
поскольку  телефонные линии или даже прямое подключение могут вносить
"шумы" и один неверный символ может  сделать  программу  бесполезной.
Некоторые протоколы, поддерживаемые в мире микро-ЭВМ, приспособлены к
машинам с системой UNIX, например программы xmodem и kermit.

	 Из этих двух протоколов xmodem более широко распространен в мире
микро-ЭВМ   и   поддерживается   почти  всеми  системами  типа  досок
объявлений.  Kermit очень  популярен  в  мире  UNIX,  имеет  растущую
популярность  в  мире  микро-ЭВМ  и  доступен почти для каждой модели
микро-ЭВМ за цену, немногим большую стоимости диска.

	 Используя эти  протоколы,  микро-ЭВМ  может посылать и принимать
файлы из системы UNIX,  и вам не нужно заботиться о  контроле  ошибок
при  передаче  данных.  Чтобы  подробнее  узнать  об этих протоколах,
проконсультируйтесь  у  администраторов  вашей  системы  UNIX   и   у
пользователей микро-ЭВМ, имеющих те же проблемы.


				ДОСТУП ИЗ СИСТЕМЫ UNIX К МИКРО-ЭВМ

	 Обратная ситуация,   в  отличие  от  только  что  рассмотренной,
состоит в обращении из системы UNIX  к  системе,  отличной  от  UNIX,
функционирующей  на  микро-ЭВМ или на большой машине.  Для того чтобы
это   сделать,   необходимо   знать,   как	получить	доступ	к
последовательному порту, какую команду модема использовать для набора
телефонного номера,  как зарегистрироваться в той системе,  в которую
мы обращаемся. Модель этой ситуации показана на рис. 8-6.

	 Терминальное устройство  DTE-1,  т.е.  система UNIX,  использует
прямой кабель для подключения  модема.  Для  последовательной  линии,
которой  в  нашем примере является tty00,  не нужно запускать процесс
getty.  Программа getty нужна только для регистрации в системе,  а не
для  обращения к другой системе.  Последовательным портом UNIX-машины
управляет  программа   cu.   Система,   отличная   от   UNIX,   имеет
регистрационную   последовательность   некоторого   вида.   Если   вы
обращаетесь к   микро-ЭВМ,   на  которой  функционирует  программное
обеспечение типа доски объявлений,  то система,  отличная  от  UNIX,
обычно запрашивает ваше имя,  город и т.д.,  а также пароль. (Обычно
вы  можете  зарегистрироваться  как  новый  пользователь  и  завести
пароль,  но это зависит от конкретной доски объявлений.) Если другой
системой   является   большая   машина,   то   ее	регистрационную
последовательность нужно знать заранее.

	 Как уже отмечалось,  основной программой,  которую предоставляет
UNIX  для  обращения к другой системе,  является cu(1),  что означает
"call unix" ("вызвать UNIX").  На практике,  как и в  нашем  примере,
другая  система не обязана быть системой UNIX,  поэтому эту программу
было  бы  более  правильно   характеризовать   как   "подключение   к
UNIX-порту".


		Рис. 8-6. Обращение UNIX к системе, отличной от UNIX</BIG>
<CODE><hr>

   DTE-1											DTE-2
+--------+										+------+
|		|		 *****	_||_	*****		 |	  |
| UNIX   | прямой *	 *   _||_   *	 * прямой |  Не  |
|		|-------* модем *-- || --* модем *-------| UNIX |
| tty00  | кабель *	 *	||	*	 * кабель |	  |
|		|		 *****	 ||	 *****		 |	  |
+--------+										+------+

ДЕЙСТВИЕ		  ДЕЙСТВИЕ

  Вместо команды getty tty00					   Специфическая
  команда cu -ltty00 dir						   регистрационная
   последовательность

<hr></CODE>
<BIG>
	 Программа cu открывает последовательный порт  и  помещает  "файл
занятости" ("lock file") в каталог /usr/spool/uucp. Присутствие этого
файла  занятости  просто   означает,   что   порт   задействован,   и
препятствует  доступу  к  нему других пользователей.  Вы имеете право
исключительного доступа до тех пор, пока не выйдете из программы cu и
не отдадите этот порт кому-нибудь другому.

	 При вызове утилиты cu начинают работать два  процесса:  читатель
(который читает из последовательного порта) и писатель (который пишет
в последовательный порт).  Когда вы вводите символы для программы cu,
она проверяет наличие среди них специальных символов,  на которые она
должна  реагировать.  Обычно  cu  сразу   реагирует   на   специально
предназначенные  ей  командные символы.  Остальные символы передаются
через последовательный порт другой стороне.  Помимо передачи символов
вперед   и   назад,   программа   cu  предоставляет  многие  функции,
аналогичные функциям коммуникационного пакета микро-ЭВМ.


<ul><a name=346></a><h2>ОБНАРУЖЕНИЕ МОДЕМОВ В СИСТЕМЕ</h2></ul>

	 Если вы работаете на большой машине,  вам нужно выяснить,  какие
порты в вашей системе подсоединены к модему и внешней линии.  Если вы
администратор, то вы должны знать, как сконфигурировать эти линии.

	 Начинать нужно с  файла  /usr/lib/uucp/L-devices.  Это  основной
файл,  определяющий,  какие  порты  используются  и каким образом они
используются. Вот пример распечатки с информацией о портах:</BIG>

<CODE><hr>
|
|   ACU	cul0	cua0	1200
|   DIR	tty00	0	  300
|   DIR	tty00	0	  1200
|   DIR	tty00	0	  2400
|   DIR	tty00	0	  4800
|   DIR	tty00	0	  9600
|</CODE>
<BIG>
	 В файле L-devices  каждый  порт  определяется  либо  как  прямое
подключение   (DIR   -   direct  connection),  либо  как  специальное
устройство,  называемое устройством  автоматического  вызова  (ACU  -
automatic  call  unit).  Об  устройствах  вызова  мы поговорим позже.
Сейчас нам нужно рассмотреть только записи  типа  DIR.  Программа  cu
использует записи типа прямого подключения, а uucp - типа ACU. Теперь
очень просто идентифицировать каждый  последовательный  порт:  как  к
нему  обращаться,  на  какой  скорости  он  работает  и  можем  ли мы
осуществить вызов через этот порт.

	 Данные файла	 L-devices	 показывают,	 например,	 что
последовательный  порт  tty00  используется как линия прямого вызова.
Вам разрешается использовать для вызова через этот порт  скорости  от
300  до  9600 бод.  Это полный диапазон используемых обычно скоростей
обмена,  причем  более  высокие  скорости  применяются  для   прямого
подключения к другим машинам, а не к модему.

	 А как насчет модемных линий,  которые ВХОДЯТ в машину?  Для того
чтобы их найти, нужно посмотреть каталог /etc. Там два файла dialin и
dialup  определяют,  на  каких  линиях  tty   применяется   вторичная
регистрационная	парольная	последовательность	для   удаленных
пользователей. Эти линии tty предназначены только для обращения извне
в  данную  систему и обычно не могут быть использованы для доступа из
этой системы во внешний мир.


<ul><a name=347></a><h2>ИСПОЛЬЗОВАНИЕ И КОНФИГУРИРОВАНИЕ ЛИНИИ</h2></ul>

	 Теперь, когда мы знаем,  по какой линии осуществить  вызов,  нам
необходима  команда  вызова.  В последних версиях System V утилита cu
более развита,  чем в предыдущих версиях.  Нам, как правило, не нужны
особо  мощные  возможности,  поэтому  наши  командные строки довольно
просты и смогут работать практически с любым вариантом  программы cu.

	 К основным возможностям,  которые  мы  имеем,  относятся:  выбор
номера  линии  (т.е.  устройства  tty),  скорости  функционирования и
подключаться ли к устройству напрямую для ручного набора  номера либо
же  набирать номер автоматически.  Самый простой способ - чтобы номер
набирала  программа  cu,  но  если  это  невозможно,  то  вы   должны
подключиться  непосредственно к модему.  Следующий пример показывает,
как непосредственно подключиться к  устройству  и  вручную  управлять
модемом с целью набора номера.  В данном случае используется довольно
широко распространенный модем  Hayes  1200  Smartmodem.  Если  у  вас
модем,  который  не является "Hayes-совместимым",  то вы должны найти
эквивалентные управляющие последовательности в вашей документации.
</BIG>
<CODE>
$ cu -ltty00 dir		# Получить прямой доступ к терминальной
						# линии со скоростью 1200 бод
Connected			   # Отзыв программы cu
ATdt555-1212			# Внимание модему, установка связи путем
						# набора следующего номера
CONNECT				 # Модем подтверждает факт подключения
<cr>					# Отправка возврата каретки в систему-адресат
Welcome to Micro BBS	# Получение приветствия от микро-ЭВМ
	 .
	 .
выполнение сеанса работы с удаленной системой
	 .
	 .
exit					# Выйти из микро-системы ИЛИ,
+++					 # если вы этого не хотите, временно
# выйти из модемного подключения
# (по команде escape, а не exit)
OK					  # Ответ модема на временный выход
ATh0					# Попросить модем занять телефон
OK					  # Ответ модема
~.					  # Завершить работу с cu
</CODE>
<BIG>
	 Для того чтобы указать программе cu автоматический набор номера,
используйте   другой  синтаксис  в  командной  строке.  Мы  применяем
устройство автоматического вызова ACU для того,  чтобы сделать вызов.
Фактическая	команда	набора   номера   генерируется   программой
/usr/lib/uucp/dial. Пример вызова выглядит так:</BIG>

<CODE>$ cu -acua0 555-1212</CODE>

<BIG>
<ul><a name=348></a><h2>ИЗМЕНЕНИЕ СКОРОСТЕЙ ОБМЕНА</h2></ul>

	 Модемы типа  Smartmodem  могут работать со скоростями 300 и 1200
бод.  По умолчанию,  программа cu  подключается  к  последовательному
порту  на  скорости 1200 бод.  Если вы подключаетесь с использованием
умолчаний,  проверьте скорость,  временно выйдя из программы  cu  (по
команде  escape,  а  не  exit),  и  применив  команду  stty,  которая
отображает скорость обмена:</BIG>

<CODE>~!stty < /dev/tty00</CODE>
<BIG>
Эта команда   должна   сообщить   обычные	установки	stty	для
последовательного порта /dev/tty00.  Скорость обмена должна равняться
1200.  Модемы типа Smartmodem автоматически понижают скорость до  300
бод  при  ответе по телефону.  При вызове вы можете понизить скорость
модема до 300 бод двумя различными способами.

	 Первый способ - заставить cu открыть линию со скоростью 300 бод,
указав 300 в командной строке программы cu.  Заметим,  что  когда  вы
применяете  альтернативную скорость (отличную от 1200 бод),  запись о
скорости обмена ДОЛЖНА присутствовать в файле L-devices И в командной
строке cu, как в следующем примере:</BIG>

<CODE>$ cu -ltty00 -s300 dir</CODE>
<BIG>

	 Второй метод хитрее,  но зато предоставляет больше гибкости.  Мы
можем  вызвать cu со значением по умолчанию 1200,  затем временно (по
команде escape) выйти из cu и вызвать программу stty,  чтобы  указать
скорость  обмена последовательного порта равной 300 бодам.  Это нужно
сделать после того,  как вы обратились к  линии  с  помощью  cu.  Эта
измененная  скорость  обмена  действительна  до  тех пор,  пока вы не
закроете линию (т.е.  окончательно выйдете из cu по команде exit).  В
этот момент порт инициализируется заново. Например:</BIG>

<CODE>
$ cu -ltty00 dir		   # Захватить линию на 1200 бод
Connected				  # Отзыв программы cu
~!stty 300 < /dev/tty00	# Временно выйти из cu и
						   # установить для линии tty
						   # скорость 300 бод
</CODE>
<BIG>
	 Отметим, что этот метод НЕ требует наличия записи о скорости 300
бод  в  файле  L-devices,  поскольку  мы  работаем с последовательным
портом вне области действия программы cu.

	 Попутно заметим,  что временный выход (по команде escape) из  cu
совершенно  аналогичен  временному  выходу  из  любой команды системы
UNIX.  Вы можете временно выйти  для  запуска  определенной  команды,
например:
</BIG>
<CODE>~!echo "you can run any command here"</CODE>
<BIG>
Вы можете  также  перейти  в  shell  и  работать  так,  как вы всегда
работаете:
</BIG>
<CODE>~!sh</CODE>
<BIG>
	 Вы должны,  однако, помнить, что вы все еще подключены с помощью
программы   cu  к  последовательному  порту,  а  телефон  по-прежнему
подсоединен к удаленной системе до тех пор, пока вы не дадите вручную
команду выхода или отключения телефона, или пока удаленная система не
отключит телефон по тайм-ауту.


<ul><a name=349></a><h2>ЗАХВАТ ДАННЫХ</h2></ul>

	 Теперь мы  умеем  найти  модем,  подключиться к последовательной
линии и установить связь с другой системой.  Если мы  вызываем  доску
объявлений,   нам   может  понадобиться  захватывать  файлы  с  целью
последующего  использования.  Программа  cu  не  предоставляет  такой
возможности.  Как  мы  уже отмечали,  микро-ЭВМ делают это обычно при
помощи  RAM-буфера,  который   сохраняется   на   диске,   когда   он
заполняется. А UNIX не может действовать таким образом.

	 Простейший способ, придуманный мною для захвата данных из другой
системы  -  пропустить  по  конвейеру все,  что выдается на терминал,
через команду tee системы UNIX.  Весь  ввод  с  вашей  клавиатуры  не
перехватывается,  а  все,  что  идет на стандартное устройство вывода
(stdout) попадает в выходной файл утилиты tee. Это выглядит так:
</BIG>
<CODE>cu -ltty00 dir | tee файл_перехвата</CODE>
<BIG>
	 Одно из последствий перехвата информации таким методом состоит в
том,  что  все  символы  возврата  каретки,  печатаемые  из удаленной
системы,  попадают в выводной файл команды tee. Вы обнаруживаете их в
виде  "^M"  в  конце  каждой  строки  файла.  Избавиться от всех этих
возвратов	каретки	легко,	 попробуйте	 выполнить	 такую
последовательность команд редактора ed:</BIG>
<CODE>
ed файл_перехвата
1,$s/^M//g
w
q
</CODE><BIG>
	 Смысл этих команд следующий. Для каждой строки во всем файле (1,
$)  заменить  возврат  каретки  (^M) на ничего (//).  Сделать это для
произвольного количества символов возврата каретки в отдельной строке
("g"  означает  глобальную  замену  в  строке).  Вы можете превратить
control-M в заменяемую строку  либо  вводом  символа  обратной  косой
черты  (\)  и настоящим нажатием на клавишу возврата каретки,  либо в
редакторе vi использовать  префикс  control-V  для  разрешения  ввода
управляющих символов. После редактирования запишите файл и выйдите из
редактора ed.

	 Конечно, все   это  вы  можете  для  удобства  оформить  в  виде
командного файла интерпретатора shell.


<ul><a name=350></a><h2>ИНСТРУМЕНТАЛЬНЫЕ СРЕДСТВА ДЛЯ КОММУНИКАЦИОННЫХ ЛИНИЙ</h2></ul>

	 Две утилиты,  которые мы здесь предлагаем,  связаны с доступом к
последовательному порту.  Когда  линия  освобождается,  вы  сразу  же
узнаете  об  этом  и  можете  управлять  линией  с помощью нескольких
нажатий клавиш.

<hr>
ИМЯ: cuchk
<hr>

<a name=351></a>cuchk		Cu check - проверка свободной линии для cu


<ul><h2>НАЗНАЧЕНИЕ</h2></ul>

	 Опрашивает таблицу состояния процессов и ищет процессы cu. Когда
они   завершаются,  на  ваш  экран  выдается  сообщение  и  программа
прекращает работу.

<ul><a name=352></a><h2>ФОРМАТ ВЫЗОВА</h2></ul>

<a name=353></a>cuchk		   -   Сообщить, когда cu освободит линию


<ul><h2>ПРИМЕР ВЫЗОВА</h2></ul>
</BIG>
<CODE>cuchk</CODE>

<BIG>
<ul><a name=354></a><h2>ТЕКСТ ПРОГРАММЫ</h2></ul></BIG>
<CODE>
1   :
2   # @(#) cuchk v1.0  Check for a free cu line  Author: Russ Sage
	   Проверка свободной линии для cu

4   if [ "$#" -gt "0" ]
5	 then  echo "cuchk: too many arguments" >&2
6		   echo "usage: cuchk"			  >&2
7		   exit 1
8   fi

10  while :
11  do
12	ps -e | fgrep cu > /dev/null  \
13				&& sleep 5
14				|| { echo "\ncu is free"; exit; }
15  done &
</CODE>
<BIG>
	   <b>ОПИСАНИЕ</b>

			  ЗАЧЕМ НАМ НУЖЕН КОМАНДНЫЙ ФАЙЛ cuchk?

	 Похоже, что  большинство  систем  UNIX скупы на последовательные
порты.  Это становится важным моментом,  когда  имеется  только  один
выводной порт для шести или семи человек.  Опыт показывает,  что если
вы не получите доступ к порту сразу,  то вам прийдется ждать снова  и
снова и вы не будете знать, как долго собирается текущий пользователь
занимать  определенный  порт.  Вместо  того  чтобы  терять  время  на
постоянную  проверку  занятости  порта,  почему бы не поручить машине
сообщить вам, когда этот порт освободится?


						ЧТО ДЕЛАЕТ cuchk?

	 При вызове программы cuchk она запускается в фоновом режиме. Она
управляется бесконечным циклом,  обеспечивающим ее работоспособность.
Программа cuchk наблюдает за системой, ведя поиск среди всех активных
процессов. Если она обнаруживает процесс cu (который может работать с
интересующим нас портом,  а может и нет),  она засыпает на 5 секунд и
снова ведет поиск.  Если нет процессов cu, функционирующих на машине,
она  выдает  сообщение  "cu  is  free" ("cu свободна") и завершается.
Таким образом,  мы не обязаны вручную следить за работой  cuchk,  она
сама запускается и сама завершается.  Это имеет смысл,  поскольку вся
ценность этой утилиты свелась бы на нет,  если бы ее саму нужно  было
периодически проверять!


<ul><a name=355></a><h2>ПОЯСНЕНИЯ</h2></ul>

	 В строках 4-8 выполняется проверка на ошибки. Поскольку cuchk не
имеет  никаких  опций,  в  командной  строке  не  должно быть никаких
параметров. Если параметры присутствуют, это считается ошибкой.
	 Строки 10-15  организуют  вечный цикл while.  Обратите внимание,
что амперсанд в строке 15 автоматически  запускает  cuchk  в  фоновом
режиме,   ведь   нет   никакого  резона  выполнять  эту  программу  в
приоритетном режиме.
	 В строке   12   выполняется  команда  "ps  -e",  которая  выдает
информацию о состоянии всех значительных  пользовательских процессов.
Эти данные пропускаются по конвейеру через fgrep.  Утилита fgrep ищет
наличие символов "cu".  Мы надеемся,  что эти  символы  соответствуют
только процессам cu, которые мы ищем. Они могут, однако, относиться к
чему-то совершенно неожиданному,  например "picuser" или к  какому-то
аналогично   построенному   имени.  Результат  работы  команды  fgrep
направляется на устройство  /dev/null,  чтобы  избавиться  от  лишней
информации. Нас интересует только статус завершения команды fgrep. Он
сообщает нам, найдено ли вхождение символов "cu" или нет.
	 В конце  строки  12  присутствует  символ  обратной косой черты,
указывающий интерпретатору shell,  что следующая  физическая  строчка
является  на  самом деле частью той же самой программной строки и что
нужно добавить  ее  к  строке  12,  а  не  выполнять  самостоятельно.
Разбиение длинных строк на несколько меньших строк с помощью символов
обратной косой черты  позволяет  нам  получать  красиво  оформленный,
более наглядный исходный код.
	 Строка 13  выполняется  в  том  случае,  если  fgrep  отработала
успешно  (т.е.  если  она  выдает  нулевой  статус  завершения).  Это
означает,  что символы "cu" найдены, а значит процесс cu работает и в
настоящее  время  не  доступен.  Поэтому  процесс cuchk засыпает на 5
секунд.  Когда он пробуждается, выполнение продолжается со строки 10,
возобновляется вечный цикл и проверка процессов продолжается.
	 Если fgrep  не  находит  символы  "cu"  (возвращается  ненулевой
статус   завершения),   то  выполняется  строка  14,  которая  выдает
сообщение о том,  что  программа  cu  свободна,  и  работа  программы
завершается.  Таким образом,  мы сразу же знаем, что линия cu открыта
для использования, поэтому мы можем поскорее занять ее.


<hr>
ИМЯ:  talk
<hr>

<a name=356></a>talk	  Обращение к последовательному порту


<ul><h2>НАЗНАЧЕНИЕ</h2></ul>

	 Выполняет командную строку,   подготавливающую  последовательный
порт для общения с другой системой.

<ul><a name=357></a><h2>ФОРМАТ ВЫЗОВА</h2></ul>
</BIG><CODE>
talk [-bBAUD] [-l] [-tTTY] [-u]

	 Опции:
	  -b	 установить новую скорость обмена

	  -l	 протоколировать все поступающие данные

	  -t	 использовать другой порт tty

	  -u	 использовать принятую в UNIX скорость обмена 9600
</CODE>
<BIG><ul><a name=358></a><h2>ПРИМЕР ВЫЗОВА</h2></ul></BIG>

<CODE>talk -b300 -t01 -l</CODE>
<BIG>
	 Обратиться к последовательному порту tty01 на скорости 300 бод и
протоколировать выводные данные в текстовый файл.


<ul><a name=359></a><h2>ТЕКСТ ПРОГРАММЫ</h2></ul></BIG>
<CODE>
1   :
2   # @(#) talk v1.0  Talk to the serial port  Author: Russ Sage
	  Обращение к последовательному порту

4   BAUD="1200"
5   TTY="tty11"
6   PIPE=""

8   for ARG in $@
9   do
10		  case $ARG in
11		  -b*) BAUD="`echo $ARG|cut -c3-`";;
12		  -l)  echo "logging in /tmp/talk.$$"
13			   PIPE="| tee /tmp/talk.$$";;
14		  -t*) TTY="tty`echo $ARG|cut -c3-`";;
15		  -u)  BAUD="9600";;
16		  *)   echo "talk: invalid argument $ARG"			>&2
17			   echo "usage: talk [-bBAUD] [-l] [-tTTY] [-u]" >&2
18			   echo "		 -b   baud rate"				>&2
19			   echo "		 -l   log the output"		   >&2
20			   echo "		 -t   use another tty"		  >&2
21			   echo "		 -u   9600 baud to UNIX"		>&2
22			   exit 1;;
23		  esac
24  done

26  eval cu -s$BAUD -l$TTY dir $PIPE
</CODE>
<BIG>
<ul><a name=360></a><h2>ПЕРЕМЕННЫЕ СРЕДЫ ВЫПОЛНЕНИЯ</h2></ul>

ARG	 Аргумент из командной строки
BAUD	Скорость обмена, которую нужно указать программе cu
PIPE	Содержит строку, создающую конвейер для захвата данных
TTY	 Номер используемого порта tty


	   <b>ОПИСАНИЕ</b>

			   ЗАЧЕМ НАМ НУЖЕН КОМАНДНЫЙ ФАЙЛ talk?

	 Регистрация в   удаленной   системе  расширяет  горизонты  ваших
вычислительных возможностей.  Учитывая, что UNIX становится все более
распространенной  системой среди микро-ЭВМ,  системы UNIX,  пригодные
для связи,  скоро будут везде. Кроме того, вы можете вызвать из вашей
системы  UNIX много систем типа досок объявлений,  функционирующих на
микро-ЭВМ.
	 Нам нужен  хороший  интерфейс  для  управления модемной линией и
облегчения ее использования.  Нам необходимо захватывать данные, если
это  возможно,  изменять  скорость обмена и менять терминальный порт,
если в этом есть потребность. Все это делает командный файл talk.


						 ЧТО ДЕЛАЕТ talk?

	 Программа talk  генерирует  командную  строку,   основанную   на
подразумеваемой  конфигурации.  Эта  конфигурация  такова:  1200 бод,
подключение к терминальной линии /dev/tty11 (последовательный  порт 1
в   системе   SCO   XENIX),   захват   данных   не  производить.  Все
подразумеваемые параметры можно изменить в тексте исходного  файла, а
терминальная  линия  должна быть установлена с учетом специфики вашей
системы.
	 Если вы хотите изменить скорость обмена, укажите с помощью опции
-b нужную вам скорость (подразумевается,  что это одна из стандартных
скоростей,  поддерживаемых  программой  cu).  Например,"talk  -b2400"
устанавливает  скорость  2400  бод.  Указанная  скорость   передается
команде  cu,  которая  непосредственно изменяет характеристики вашего
подключения.
	 Важно иметь в виду,  что эта скорость должна быть  определена  в
файле L-devices.
	 Если вы  хотите  захватить  все данные,  выводимые на ваш экран,
включите опцию  протоколирования,  указав  -l.  Файл  с  захваченными
данными   будет   называться   /tmp/talk.$$,   где  $$  -  уникальный
идентификатора процесса вашего текущего интерпретатора shell. Это имя
выдается на экран при вызове данной опции,  так что вы увидите его на
вашем экране. Уникальность имен файлов обеспечивается для того, чтобы
вы  не  потеряли  по  недосмотру  регистрационные файлы от предыдущих
сеансов работы (или чтобы,  по крайней мере,  было очень мало шансов,
что это произойдет).
	 Если у вас факультативный последовательный порт  с  модемом  или
если  вы  хотите  подключаться к любой из возможных линий,  примените
опцию -t. Вместе с этой опцией укажите номер tty, который будет затем
передан  в  команду  cu.  Это очень полезная опция,  если у вас много
различных линий для использования cu.
	 Если вы не используете ваш последовательный порт для подключения
модема, а имеете прямое подсоединение к другой системе UNIX, опция -u
тотчас  же установит скорость обмена 9600 бод.  Заметим,  что того же
эффекта можно было бы достичь,  указав  -b9600,  но  опцию  -u  проще
вводить и запоминать.



<ul><a name=361></a><h2>ПРИМЕРЫ</h2></ul>
</BIG>
<CODE>1.  $ talk -l -t12</CODE>
<BIG>
	 Подключиться к   дополнительному   последовательному   порту   и
захватывать данные, которые проходят на экране.
</BIG>
<CODE>2.  $ talk -u</CODE>
<BIG>
	 Подключиться к	основному	последовательному	 порту	 с
использованием скорости 9600 бод. Не включать захват данных.
</BIG>
<CODE>3.  $ talk -b2400 -t04 -u</CODE>
<BIG>
	 Внимание! Сначала опция -b устанавливает скорость 2400, но далее
следует опция -u,  которая  переустанавливает  значение  скорости  на
9600.
</BIG>
<CODE>4.  $ talk -u -l -b4800</CODE>
<BIG>
	 Снова будьте внимательны! Сначала линия подключается напрямую со
скоростью  9600  бод.  Затем  включается  протоколирование.  Наконец,
значение скорости меняется с 9600 на 4800.  Если на самом деле линия,
к которой вы обращаетесь,  работает на скорости 9600 бод,  вы должны,
если  это  возможно,  понизить  скорость,  нажимая  ~%b для генерации
сигнала break.


<ul><h2>ПОЯСНЕНИЯ</h2></ul>

	 В строках  4-6 устанавливаются действия,  выполняемые программой
talk по  умолчанию.  Эти  действия  можно  полностью  изменить  путем
редактирования исходного файла.  Главное достоинство этих умолчаний в
том,  что если такую конфигурацию вы используете чаще всего,  то  вам
достаточно просто ввести "talk", без всяких опций.
	 Строка 4 инициализирует  переменную  BAUD  значением  1200,  это
значение по  умолчание  для  скорости  модема.  Строка  5 присваивает
переменной   TTY   значение   tty11,   что   соответствует	первому
последовательному порту аппаратуры.  Обычно нужно tty00, но SCO XENIX
имеет виртуальную консоль,  причем  tty02-tty10  являются  отдельными
экранами,  доступ  к  которым  осуществляется  с  одного  консольного
устройства. Если это не так в вашей системе, укажите здесь правильное
значение  TTY.  В  строке  6  переменная PIPE инициализируется пустой
строкой,  так как конвейер применяется для протоколирования данных, а
по умолчанию захват данных не выполняется.
	 Строки 8-24 представляют  собой  цикл,  который  перебирает  все
аргументы  командной  строки.  В  строках 10-23 используется оператор
выбора среди опций для выполнения требуемых функций.
	 Строка 11  проверяет,  начинается ли данная опция с символов -b,
после которых следует что-то еще.  Если  да,  то  символы,  следующие
после   -b,  вырезаются  и  заносятся  в  переменную  BAUD.  Обратите
внимание,  что именно поэтому вы должны набирать "-b2400",  а не  "-b
2400".
	 В строке 12 проверяется, хотите ли вы включить протоколирование.
Если да,  то на экран выводится имя протокольного файла, а переменная
PIPE  устанавливается  так,  чтобы  направить  стандартный  вывод  по
конвейеру программе   tee   системы   UNIX.   Программа   tee  -  это
универсальная  конвейерная  программа  расщепления,   которую   можно
использовать  для  посылки  копии  потока данных в определенный пункт
назначения,  не воздействуя на основной конвейер.  В данном случае мы
применяем   программу   tee  для  посылки  данных,  проходящих  через
последовательный  порт,  на  экран  и  в  наш  регистрационный   файл
/tmp/talk/.$$.  (Если  вы представите себе водяную трубу с T-образным
стыком, то поймете, что происходит.)
	 Строка 14 проверяет,  начинается ли опция с -t. Если это так, то
вырезается номер терминала.  Здесь можно передать любое значение tty,
но  не  забывайте,  что  этот номер tty должен также присутствовать в
файле /usr/lib/uucp/L-devices.  Благодаря этому файлу,  программа  cu
знает, что терминальное устройство подключено к разрешенному порту.
	 В строке  15  проверяется,  собираетесь  ли  вы  подключаться  к
системе   UNIX  напрямую.  Если  да,  скорость  обмена  автоматически
устанавливается на 9600 бод в целях повышения  пропускной способности
терминала.
	 Строки 16-22 выполняют проверку ошибок.  Если какая-либо  опция,
переданная   в   командной   строке,  не  соответствует  никакому  из
предыдущих образцов оператора  case,  этот  факт  фиксируется  здесь,
выдаются сообщения об ошибках и командный файл завершается.
	 Строка 26 - это волшебная строка. Поскольку все shell-переменные
получили свои значения,  мы можем использовать их в командной строке,
чтобы подставить в  нее  необходимые  значения.  Сначала  применяется
команда  eval.  Она  раскрывает  все имена переменных,  заменяя их на
соответствующие значения.
	 В данном случае мы формируем полную командную строку утилиты cu:
скорость берется из переменной BAUD,  линия из TTY,  а  подсоединение
прямое.  Если  мы  не  ведем  протоколирование данных,  значение PIPE
нулевое и оно будет отброшено при  синтаксическом  разборе.  Если  же
переменная  PIPE  содержит команду для отправки данных в протокольный
файл,  команда eval обеспечивает это,  организовывая такой  конвейер,
как мы указали.


<a name=362></a>					  ДОСТУП ИЗ UNIX В UNIX

	 Теперь давайте рассмотрим полновесное общение двух  систем UNIX.
Имеется  область,  в которой UNIX опередила свое время.  Система uucp
позволяет связать  несколько  машин  воедино  и  создать  то,  что  в
некоторых отношениях является виртуальным окружением, позволяющим вам
работать на любой машине.  Функционирование такой  сети  основано  на
удаленной  регистрации  в  системе (cu(1)),  дистанционном выполнении
команд  (uux(1)),  электронной  почте  (mail(1)),   передаче   файлов
(uucp(1),   uucico(1))   и   опознавании  узла  системы  (uname(1)  и
uuname(1)).
	 Поскольку мы занимаемся реализацией коммуникаций типа UNIX-UNIX,
давайте   рассмотрим   некоторые   способы   физического   соединения
UNIX-машин в одну рабочую среду.


					  СВЯЗЫВАНИЕ UNIX-МАШИН

	 В рабочей обстановке машинные конфигурации постоянно  меняются в
целях   тестирования,  из-за  аппаратных  изменений,  перестановок  и
переездов и т.д.  Планировать конфигурацию  ваших  машин  нужно  так,
чтобы  она  была  максимально  гибкой,  это  поможет избежать хаоса и
разлада.
	 Ваши потребности  влияют  на  то,  как  вы  соедините  различные
UNIX-машины.  Если  имеется  блок определения приоритетного запроса к
порту (port contender),  вам приходится иметь с ним дело.  Одни линии
могут быть подсоединены напрямую,  другие напрямую через блок опреде-
ления приоритетного запроса к порту, третьи через модемные коммутато-
ры. Для того чтобы научиться иметь дело со всеми этими возможностями,
попробуем представить эти конфигурации в графическом виде.
	 Первый тип подключения -  прямое  подключение  (см.  рис.  8-7).
Слева  показана  вызывающая  система,  справа вызываемая.  Вызывающая
система использует последовательный порт для вывода,  поэтому на этом
порту не должно быть процесса getty. Инициирующая команда "cu -ltty00
-s9600 dir" обеспечивает подключение к последовательному  порту tty00
на   очень   высокой  скорости  обмена.  Прямые  подсоединения  могут
поддерживать такую скорость.  Сам кабель должен быть выполнен в  виде
нулевого  модема (рассмотренного ранее в данной главе).  В вызываемой
системе задействованы процессы getty,  работающие со  скоростью  9600
бод   на  входящей  терминальной  линии.  Когда  пользователь  вводит
регистрационное имя,  getty выполняет  процесс  login,  запрашивающий
пароль, и если этот пароль верный, запускается shell.

   Рис. 8-7.   Прямое подключение одной системы UNIX к другой
</BIG>
<CODE><hr>

   DTE-1						   DTE-2
+---------+					 +---------+
|		 |					 |		 |
| UNIX 1  |					 |  UNIX 2 |
|		 |  Нулевой модем	  |		 |
|   tty00 |-------------------->| tty00   |
|		 |					 |		 |
|		 |					 |		 |
+---------+					 +---------+

ДЕЙСТВИЯ								ДЕЙСТВИЯ

1. Нет getty							1. getty 9600 tty00
   cu -ltty00 -s9600 dir				   login имя_пользователя
   sh

2. uucp файл							2. getty 9600 tty00
   unix 2!~/user						   login uucp
   uucico

<hr>
</CODE><BIG>
	 При использовании uucp происходят аналогичные вещи. Команда uucp
генерирует процесс uucico,  инициирующий  вызов  системы,  показанной
справа.   Регистрационная   последовательность   та   же   самая,  за
исключением того,  что вместо запуска интерпретатора  shell  в  конце
этой последовательности действий запускается еще один процесс uucico,
который общается с вызывающим процессом.
	 Следующая конфигурация - прямое подключение через селектор порта
- показана на  рис.  8-8.  Здесь  тоже  кабель,  идущий  от  DTE-1  к
селектору порта, должен быть нулевым модемом.

   Рис. 8-8.  Прямое подключение через селектор порта</BIG>
<CODE><hr>

	+---------+		  +----------+		 +---------+
	|		 |		  |		  |		 |		 |
	| UNIX 1  |		  |		  |		 |  UNIX 2 |
	|		 | Нулевой  | Селектор | Прямой  |		 |
	|   tty00 |--------->| порта	|-------->| tty00   |
	|		 | модем	|		  | кабель  |		 |
	|		 |		  |		  |		 |		 |
	+---------+		  +----------+		 +---------+


ДЕЙСТВИЯ								ДЕЙСТВИЯ
1. cu -ltty00 -s9600 dir				1. getty tty00 9600
   login имя_пользователя
   sh
2. uucp файл							2. getty 9600 tty00
   unix 2!~/user						   login uucp
   uucico
<hr>
</CODE><BIG>
	 Селектор порта  принимает  любое  количество  входных  линий   и
переключает  их  на  меньшее  количество  фиксированных входных линий
компьютера.  Таким образом, можно получить доступ ко всем терминалам,
не  имея  входной  линии,  которая часто бы пустовала,  поскольку она
предназначена определенному лицу.  Регистрационная последовательность
в точности такая же,  как и для прямого подключения, кроме каких-либо
дополнительных нажатий на клавиши,  применяемых для прохождения через
селектор.  Обычно возврат каретки активизирует линию,  чтобы получить
регистрационную подсказку.
	 Последняя конфигурация   (на   рис.   8-9)   представляет  собой
дистанционное  подключение  двух  систем  UNIX.  Каждое  терминальное
устройство  DTE  соединяется  со своим модемом прямым кабелем.  DTE-1
вызывает DTE-2 либо вручную с помощью  cu,  либо  с  помощью  утилиты
uucp,  использующей  uucico  и  программу  набора телефонного номера.
Самое большое отличие  в  том,  что  это  подсоединение  работает  на
скорости 1200 бод.  Это значит, что либо DTE-2 запускает 1200-бодовый
процесс getty,  либо если getty имеет скорость  9600,  то  вам  нужно
сбросить  ее.  Для  того  чтобы  понизить  скорость,  в  программе cu
требуется ввести ~%b в качестве сигнала break. Или, если вы работаете
с  помощью  uucp,  можно поместить строку BREAK в файле L.sys,  чтобы
отправить ее в вызванную систему.

   Рис. 8-9.	Дистанционное соединение двух систем UNIX</BIG>
<CODE><hr>

+---------+											+---------+
|		 |											|		 |
| UNIX 1  |		  *****	 _||_	 *****		  |  UNIX 2 |
|		 | Прямой  *	 *	_||_	*	 *  Прямой |		 |
|   tty00 |------->* модем *--  ||  --* модем *------->| tty00   |
|		 | кабель  *	 *	 ||	 *	 *  кабель |		 |
|		 |		  *****	  ||	 *****		   |		 |
+---------+											+---------+

ДЕЙСТВИЯ								ДЕЙСТВИЯ

1. cu -ltty00 -s9600 dir				1. getty 1200 tty00
   login имя_пользователя
   sh

2. uucp файл							2. getty 1200 tty00
   unix 2!~/user						   login uucp
   uucico
<hr>
</CODE>
<BIG>
<ul><a name=363></a><h2>ОБЛАСТИ ДЛЯ ПЕРЕДАВАЕМЫХ ФАЙЛОВ</h2></ul>

	 Когда вы пересылаете файлы между машинами,  uucp  придерживается
определенных  протоколов  и  стандартов.  Один  из  них связан с тем,
откуда  и  куда  могут  поступать  файлы.  Чтобы   свести   возможную
неразбериху  к  минимуму  и  обеспечить  определенную степень защиты,
создаются защищенный и публичный  каталоги  для  хранения  стоящих  в
очереди заданий и переданных файлов.

	 Наиболее важен каталог /usr/spool/uucp. Он содержит LOGFILE, что
дает  возможность  с  помощью  команды  "tail -f LOGFILE" заглянуть в
операции передачи во время их  выполнения.  Транзакции  uucp  и  mail
попадают  в  этот каталог.  Обычно транзакция состоит из управляющего
файла (C.*) и файла данных (D.*).  Когда одна машина  используется  в
качестве  центрального узла,  ее каталог uucp может заполниться очень
большим  количеством  файлов.  Необходимо  обычное  сопровождение   и
постоянное  слежение за файлами занятости (LCK* и STST*),  чтобы быть
уверенным, что все работает правильно.
	 Следующий интересный  каталог /usr/spool/uucppublic,  чаще всего
известный под названием PUBDIR (это  shell-переменная).  Он  содержит
каталоги,  названные  по  имени  каждого пользователя,  чтобы хранить
файлы,  проходящие транзитом с одной машины  на  другую.  Большинство
каталогов   имеют   все   права   доступа,  что  обеспечивает  другим
пользователям  возможность  копировать  файлы.  Я  посчитал  полезным
создать  переменную  среды  интерпретатора  shell,  которая  содержит
маршрутный  префикс  моего  каталога  в  /usr/spool/uucppublic,  т.е.
P=/usr/spool/uucppublic/russ.  Теперь  я  могу  обращаться  к файлам,
вводя $P/*.  Это значительно  сокращает  ввод  и  упрощает  пересылку
файлов в этот каталог и из него.
	 Переменная PUBDIR  поддерживается  синтаксисом  uucp.  В  данном
примере используется синтаксис uucp:
</BIG>
<CODE>$ uucp * remote!~/user</CODE>
<BIG>
	 Эта команда  копирует  каждый  файл  текущего каталога в систему
"remote",   затем   обозначение	~/	превращается	в	префикс
/usr/spool/uucppublic.   Если   в   этой  команде  user  не  является
каталогом,  копируемые файлы получают имя user,  а  не  копируются  в
каталог  с  именем user.  Вы должны сами создать каталог,  после чего
применить  к  нему  команду  chmod  777,  чтобы  в  него  можно  было
копировать.  Для  справки  отметим,  что  указание ^user превращается
программой  uucp  в  $HOME/user,  а  ^/user   превращается   uucp   в</BIG>
<CODE>$PUBDIR/user.</CODE><BIG>
	 Еще один  способ  ввода  команды  с   помощью   shell-переменных
выглядит так:</BIG>
<CODE>
$ uucp * remote!$P

	 Такая команда  копирует  все файлы в мой каталог PUBDIR.  Если я
зарегистрировался в этой системе, я могу ввести:

$ ls -al $P

или

$ cd $P
$ ls -al</CODE>
<BIG>
для того, чтобы увидеть все скопированные файлы.

	 Один из моментов,  за которым вы должны следить,- разрушительные
командные файлы типа  "uuclean".  Эти  программы  обычно  запускаются
процессом  cron  или  некоторыми  другими  фоновыми программами.  Они
проходят по всем областям системы, связанным с uucp, находят файлы, к
которым не было обращений определенный период времени,  и удаляют их.
Это  может  быть  катастрофическим,  если  вы  используете  PUBDIR  в
качестве временной области хранения.  Вот как может выглядеть одна из
таких "очищающих" операций:</BIG>
<CODE>
	 PATH=/usr/bin:/bin
	 export PATH
	 cd /usr/spool/uucp
	 find C. D. TM. X. XTMP -type f -mtime +7 -exec rm {} \;
	 cd /usr/spool/uucppublic
	 find . -type f -mtime +7 -exec rm {} \;</CODE>
<BIG>
	 Если в вашей системе работают такие очищающие  командные  файлы,
имеется   несколько   способов  сохранения  файлов  от  неумышленного
уничтожения.  Первый  способ  -  постоянно  обрабатывать  все   файлы
утилитой touch,  чтобы они не распознавались оператором find, который
ищет старые файлы. Это можно сделать так:
</BIG>
<CODE>	 $ find $P -exec touch {} \;</CODE>
<BIG>
	 Утилита touch обновляет дату доступа и изменения файла. Фигурные
скобки   означают,   что  нужно  поместить  в  них  литеральное  имя,
соответствующее оператору find.  Вам желательно оформить это  в  виде
запланированного  процесса,  который запускается чаще,  чем программа
очистки!
	 Другая стратегия  -  проанализировать  очищающую  программу (или
командный файл). Она запускается суперпользователем (root)? Если нет,
то  команда  "chmod 000 $P" может помешать ей вести поиск имен внутри
моего	каталога.	Если	же	программа	очистки	 запущена
суперпользователем,  то, конечно, никакие ограничения прав доступа ее
не остановят.  В какое время она запускается?  Могу ли я приказать ей
пройти мимо меня,  не заглядывая в мои файлы?  Что является стартовым
каталогом для очищающего командного файла?  Углубляясь в эти вопросы,
мы  можем  собрать много информации о том,  что делает этот командный
файл и какие действия мы можем предпринять, чтобы он нам не навредил.
	 Может показаться,  что  самый  легкий  способ  -  просто удалить
программу очистки (в предположении, что вы имеете на это право). Это,
однако,  не  способствует  поддержке свободного пространства и чистых
каталогов.  К тому же если вы  хотите  запретить  очистку  каталогов,
которые очень важны для вас, то вы должны нести ответственность за их
сопровождение.


<ul><a name=364></a><h2>СЕТЕВАЯ БЕЗОПАСНОСТЬ</h2></ul>

	 Каталог uucppublic,   как   мы   уже   видели,  содержит  файлы,
передаваемые транзитом между  системами.  Обычно  все  подкаталоги  в
uucppublic  имеют  режим  доступа  rwxrwxrwx.  Это сразу же порождает
проблему  защиты,  ведь  кто  угодно  может  создать,  разрушить  или
изменить файлы в этих каталогах.
	 Такие права доступа  должны  соблюдаться  для  любого  каталога,
который является источником или адресатом для файлов,  передаваемых с
помощью uucp.  Uucp требует,  чтобы все промежуточные каталоги  имели
разрешение на чтение и запись для всех пользователей. Если uucp берет
из каталога исходные файлы,  должны быть обеспечены права на  чтение.
Если же uucp записывает файлы в этот каталог, нужны права на запись в
каталог-адресат.  Если вы хотите,  чтобы файлы uucp попадали прямо  в
ваш регистрационный каталог, вы должны разрешить запись в ваш каталог
для всех окружающих.
	 Широко открытый  доступ  на  запись  позволяет  доставлять файлы
прямо к вашему порогу,  но вы не знаете,  кому вы  открываете  двери.
Если вы заботитесь о безопасности,  вам не пон			  ПРИЕМЫ П.
может записать все,  что угодно, в ваше рабочее пространство. Одно из
решений	-   разблокировать   ваш   регистрационный   каталог,   но
заблокировать все ваши подкаталоги,  кроме  тех,  которые  нужны  для
uucp.  Основная проблема при этом - так установить все права доступа,
чтобы каждый файл обрабатывался надлежащим образом.
	 Более простое решение  -  держать  ваши  каталоги  для  uucp  за
пределами вашего регистрационного дерева каталогов. Это избавляет вас
от  проблемы  безопасности,  но  означает,  что  вы  должны   вручную
копировать файлы после их попадания в каталог туда,  где вы хотите их
фактически разместить.


<ul><a name=365></a><h2>ОГРАНИЧИТЕЛЬНЫЕ ФАЙЛЫ</h2></ul>

	 Когда удаленная система регистрируется в центральной  системе  с
помощью  uucp,  несколько  файлов  в  центральной системе определяют,
какие возможности имеет удаленная система. Эти конфигурационные файлы
размещаются в каталоге /usr/lib/uucp.
	 Первый из таких файлов называется L.cmds. Он содержит имена всех
команд  центральной  системы,  которые  можно  выполнить из удаленной
системы.  Если удаленная система посылает команду посредством uux, то
команда   выполняется  только  при  условии,  что  имя  этой  команды
присутствует в файле L.cmds.
	 Следующий файл  -  USERFILE  -  определяет,  к  каким  каталогам
центральной системы может иметь доступ удаленная система.  Вы  можете
ограничить  пересылки  одним  каталогом или разрешить доступ к любому
файлу системы. По умолчанию в файле USERFILE имеется такая запись:
</BIG>
<CODE>	 uucp, /</CODE>
<BIG>
что позволяет пользователю uucp  (подразумеваемому  пользовательскому
имени  процесса  uucico)  читать и писать файлы в любом месте дерева,
начиная от корня и двигаясь вниз,  т.е.  фактически во всей  системе.
Это открывает лазейки в системе защиты, например:
</BIG>
<CODE>	 uucp central!/etc/passwd /tmp</CODE>
<BIG>
	 Здесь извлекается парольный файл из другой  системы.  С  помощью
этого  файла  можно  найти имена пользователей без паролей,  и другие
люди могут прорваться в вашу систему.  Более  строгий  файл  USERFILE
выглядит так:
</BIG>
<CODE>	 uucp /usr/spool/uucppublic /tmp</CODE>
<BIG>
что ограничивает файловые пересылки только указанными каталогами. Это
препятствует предыдущей попытке пересылки парольного файла.
	 Последний файл L.sys,  вероятно, наиболее важен для uucp с точки
зрения  системы защиты.  Он содержит имена узлов,  телефонные номера,
регистрационные имена и пароли для всех удаленных  систем,  известных
центральной  системе.  Если  бы  какая-то  часть этой информации была
доступна широкой публике,  кто-нибудь смог бы выполнить  пересылку  с
помощью  uucp из удаленной системы и претендовать на роль центральной
системы. Новая система HoneyDanber uucp в System V кое-что делает для
того,  чтобы  не  давать  удаленным  системам  перехватывать  почту и
пересылки данных путем маскировки под  другие  удаленные  системы.  В
главе 9 более подробно рассматриваются вопросы безопасности программы
uucp и коммуникаций вообще.
	 В следующем примере показан файл L.sys, в котором определены два
разных вида систем:  системы типа  прямого  подключения  и  удаленные
системы с номеронабирателем (dial-up systems).

remote Any ACU 1200 5551212 ogin:--ogin: uucp word: uucp
selector Any ACU 1200 5551213 \d--CLASS--CLASS A ogin:--ogin: uucp word:
uucp
direct Any tty00 9600 tty00 ogin:-@-ogin: uucp word: uucp

	 Запись для системы "remote" отражает,  что это линия  с  набором
номера,  может  быть  вызвана  произвольное  число  раз ("any time"),
доступна через ACU (automatic call unit -  автоматическое  устройство
вызова)  со  скоростью 1200 бод и по номеру 5551212.  Регистрационная
последовательность определена в виде регистрационного  имени  uucp  и
пароля  uucp.  Слово "ogin" - не опечатка.  Uucp использует подсказку
"ogin:" для того,  чтобы  отличить  ее  от  обычной  подсказки  login
системы  UNIX.  Распознавание  шаблона  "ogin:"  более  надежно,  чем
использование "Login:" или "login:".
	 Указание "Any" можно заменить на определенные интервалы времени,
если 24-часовый доступ не разрешен.  Заметим,  что обозначение  "ACU"
соответствует записи ACU в файле L-devices (как рассмотрено ранее). В
следующей  записи  файла  L-devices  имена  cua0  и  cul0  связаны  с
устройством, присоединенным к модему, в данном случае /dev/tty00:

	 ACU cul0 cua0 1200

	 Эту связь  можно  проверить  с помощью команды "ls -li /dev/tty*
/dev/cul* /dev/cua*".
	 Система "selector" в нашем файле L.sys также имеет набор номера,
только  подключается  через   коммутатор   порта.   Для   общения   с
коммутатором  порта  необходима  дополнительная  информация,  которая
начинается с символов "\d".  Поля  в  файле  L.sys  следуют  в  таком
порядке:  "ожидание посылка ожидание посылка ...".  Когда мы в первый
раз подключаемся к селектору порта, в нашу линию ничего не выводится.
Просто  он  так  работает.  Селектору нужен символ <cr>,  чтобы стать
активным,  а первое поле uucp означает ожидание.  Как нам  ничего  не
дождаться  и  послать  возврат  каретки?  Путем указания uucp ожидать
невозможный символ,  например control-D (\d). Uucp никогда не получит
его, поэтому по тайм-ауту эта программа выдаст возврат каретки (-).
	 Если слово  CLASS  приходит назад,  когда мы посылаем CR,  то мы
отправляем   символ   "A",   который   означает	класс	системной
идентификации,	указанный	в	данной	записи.   Когда   связь
устанавливается,  мы  ищем   "ogin:"   в   качестве   регистрационной
подсказки.  Если  мы  не  находим  ее,  то  посылаем символы возврата
каретки.  Это может потребоваться по той  причине,  что  инициирующий
процесс  getty в системе A может быть настроен на 9600 бод.  Тогда мы
должны будем послать либо  символы  возврата  каретки,  либо  символы
break, чтобы сбросить скорость обмена до 1200 бод.
	 Последняя системная   запись   "direct"   не  использует  ACU  и
телефонный номер.  Она собирается  обращаться  к  терминальной  линии
tty00   на   скорости   9600   бод,  чтобы  получить  регистрационную
последовательность.  Здесь нет селектора порта,  через который  нужно
пройти,  а  есть  просто  прямая  линия.  В файле L-devices эта линия
описана так:

	 DIR tty00 0 9600


<ul><a name=366></a><h2>ОТЛАДКА КОММУНИКАЦИЙ</h2></ul>

	 В тех   случаях,   когда   uucp   работает   неправильно,  можно
воспользоваться  некоторыми  хитростями  отладки.  Последовательность
действий  по  отладке  обычно  проходит  по такому циклу:  попытаться
передать файл,  локализовать проблему, разрешить ее, сделать еще одну
передачу.  Здесь  мы рассмотрим локализацию проблемы и выполнение еще
одной пересылки.
	 Если после  проверки и перепроверки всех конфигурационных файлов
имеют место отказы при передаче файлов, запустите вручную программу
/usr/lib/uucico с   некоторыми  активными  отладочными  флагами.  Они
помогут увидеть, как происходит рукопожатие. Вот командная строка для
отладочного режима:</BIG>

<CODE>	 /usr/lib/uucp/uucico -r1 -x9 -ssystem_name</CODE>
<BIG>
где r1  указывает  программе  uucico  стартовать  в  ведущем (master)
режиме,  вызывая  system_name,  а  x9  указывает  уровень  отладочных
сообщений.  Если  вы хотите получать от uucico поменьше подробностей,
можете  понизить  уровень  отладки  до  x4  или   другого   значения.
Отладочный вывод варьируется в диапазоне от x1 до x9.
	 Типичная последовательность для этой команды  выглядит  так.  Во
-первых,   поставить  некоторые  файлы  в  очередь  для  того,  чтобы
направить их в другую систему. Благодаря постановке файлов в очередь,
вы избегаете автоматического запуска процесса uucico.  После того как
файлы поставлены в очередь и готовы к передаче,  запустите отладочный
режим и следите за происходящим. Это выглядит примерно так:</BIG>
<CODE>
<hr>
|
|   $ uucp -r *.c remote!~/src
|   $ /usr/lib/uucp/uucico -r1 -x4 -sremote
|</CODE>
<BIG>
	 Если вам  нужно  только активизировать передачу с помощью uucp в
обычном режиме,  то проще всего  применить  команду  mail.  Направьте
почтой  некоторый текст пользователю другой системы - и механизм uucp
сразу же начнет работу.  Следующая команда приводит к тому,  что этот
механизм  вызывает  систему  "remote"  и  запускает утилиту rmai(1) в
другой системе,  чтобы передать по почте  файл  "dummy"  пользователю
"user":
</BIG>
<CODE>	 $ mail remote!user < dummy</CODE>
<BIG>
	 Есть команда,  которая  явно вызывает /usr/lib/uucp/uucico - это
команда  uusub(1M),  размещенная  в   каталоге   /usr/lib/uucp.   Она
вызывается с указанием имени системы,  с которой вы хотите связаться.
Большинство  систем  имеют  такую  команду.  Если  у  вас   ее   нет,
пользуйтесь  uucico.  Если  такая  команда  есть,  вы имеете еще один
способ запуска uucico. Синтаксис выглядит так:
</BIG>
<CODE>	 $ /usr/lib/uucp/uusub -c system</CODE>
<BIG>
	 Теперь когда мы знаем, как использовать все эти команды вручную,
мы	можем	рассмотреть   некоторые   инструментальные   средства,
автоматизирующие большую часть вашей работы с uucp.
</BIG>
<CODE>
<hr>
ИМЯ: uust
<hr>
</CODE><BIG>
<a name=367></a>uust	  Состояние uucp и служебные действия


<ul><h2>НАЗНАЧЕНИЕ</h2></ul>

	 Предоставляет управляемый   с  помощью  меню  доступ  ко  многим
служебным функциям, связанным с утилитой uucp и передачей файлов.

<ul><a name=368></a><h2>ФОРМАТ ВЫЗОВА</h2></ul>
</BIG>
<CODE>uust

	 Опции меню:
	 c - подключиться к другой системе в отладочном режиме
	 d - показать файлы в вашем каталоге PUBDIR
	 f - длинноформатный список файлов в каталоге подкачки
		 (spool directory)
	 l - динамически отображать регистрационный файл
	 r - повторное подключение к другой системе
	 s - дать пользователю сводку о транзакциях
	 u - разблокировать все терминальные линии (ОСТОРОЖНО:
		 это может нарушить сеанс работы)
	 w - отобразить регистрационный файл за последнюю неделю
</CODE>
<BIG>
<ul><a name=369></a><h2>ПРИМЕР ВЫЗОВА</h2></ul>

uust	Динамически отображать регистрационный файл, чтобы
		следить за транзакциями uucp


<ul><a name=370></a><h2>ТЕКСТ ПРОГРАММЫ</h2></ul></BIG>
<CODE>
1   :
2   # @(#) uust v1.0   Uucp status utility   Author: Russ Sage

4   if [ $# -gt 0 ]
5	 then  echo "uust: argument error" >&2
6		   echo "usage: uust"		  >&2
7		   exit 1
8   fi

10  UUNODE=`uuname -l`
11  echo "
12				   UUST MENU				system node: $UUNODE
13				   ---------
14	  c - connect with another system in debug mode
15	  d - show files in your directory under PUBDIR
16	  f - long list files in the spool directory
17	  l - display the logfile dynamically
18	  r - reconnect with another system
19	  s - give user summary of transactions
20	  u - unlock the tty line
21	  w - display logfile for the last week
22	 <cr> - exit program

24  Press c,d,f,l,r,s,u,w,or <cr>: \c"
25  read CMD

27  case $CMD in
28  "")	 exit 0;;
29  c)	  echo "\nSystem name (<cr> to exit): \c"
30		  read SYSTEM
31		  if [ "$SYSTEM" = "" ]
32			then exit 0
33		  fi
34		  echo "\nrm /usr/spool/uucp/STST.$SYSTEM : \c"
35		  rm /usr/spool/uucp/STST.$SYSTEM 2>/dev/null \
36					&& echo "" || echo "no STST files"
37		  echo "\n/usr/lib/uucp/uucico -r1 -x4 -s$SYSTEM:"
38		  /usr/lib/uucp/uucico -r1 -x4 -s$SYSTEM;;
39  d)	  echo "\n/usr/spool/uucppublic/$LOGNAME:"
40		  ls -l /usr/spool/uucppublic/$LOGNAME;;
41  f)	  echo "\n/usr/spool/uucp:"
42		  ls -l /usr/spool/uucp | more;;
43  l)	  echo "\n/usr/spool/uucp/LOGFILE:"
44		  tail -20f /usr/spool/uucp/LOGFILE;;
45  r)	  echo "\nSystem name (<cr> to exit): \c"
46		  read SYSTEM
47			if [ "$SYSTEM" = "" ]
48			then exit 0
49		  fi
50		  echo "\nrm /usr/spool/uucp/STST.$SYSTEM : \c"
51		  rm /usr/spool/uucp/STST.$SYSTEM 2>/dev/null \
52					&& echo "" || echo "no STST files"
53		  echo "uusub -c$SYSTEM:"
54		  if [ -f /xenix ]
55			then /usr/bin/uusub -c$SYSTEM
56			else /usr/lib/uucp/uusub -c$SYSTEM
57		  fi
58		  tail -20f /usr/spool/uucp/LOGFILE;;
59  s)	  echo "\nuulog -u$LOGNAME:"
60		  uulog -un$LOGNAME | more;;
61  u)	  echo \\nrm /usr/spool/uucp/LCK* :
62		  rm /usr/spool/uucp/LCK* 2>/dev/null || echo "no lock files";;
63  w)	  echo "\n/usr/spool/uucp/Log-WEEK:"
64		  more /usr/spool/uucp/Log-WEEK;;
65  *)	  echo "uust: invalid argument '$CMD'" >&2;;
66  esac
</CODE>
<BIG>
<ul><a name=371></a><h2>ПЕРЕМЕННЫЕ СРЕДЫ ВЫПОЛНЕНИЯ</h2></ul>

CMD		Содержит символ входной команды, поступивший из
		   стандартного ввода
LOGNAME	Содержит ваше регистрационное имя
SYSTEM	 Узловое имя uucp той системы, в которую вы обращаетесь
UUNODE	 Узловое имя uucp локальной системы


	   <b>ОПИСАНИЕ</b>

			   ЗАЧЕМ НАМ НУЖЕН КОМАНДНЫЙ ФАЙЛ uust?

	 Многие области системы UNIX являются фактически самостоятельными
подсистемами.  Uucp одна  из  них.  Она  использует  конфигурационные
файлы,  файлы подкачки (spool files), файлы блокировки (lock files) и
имеет много исполняемых модулей,  образующих целую систему.  Если  вы
интенсивно   используете   uucp,   вы  часто  занимаетесь  просмотром
регистрационных файлов, очисткой каталогов после аварийных завершений
работы  uucp  и наблюдением за системой в целом.  Если делать все это
вручную, требуется запоминать каталоги, файлы, команды, опции. Трудно
запомнить  так  много  символов  для  ввода команд.  Uust значительно
сокращает издержки и облегчает использование утилиты uucp.


						 ЧТО ДЕЛАЕТ uust?

	 Uust - это управляемый с помощью меню интерфейс, предоставляющий
основные  служебные  функции,  необходимые для среды uucp.  Вам нужно
набрать только команду uust, а затем требуемые опции.
	 Вполне возможно   также,   что  вы  обнаружите  трудосберегающие
функции, о которых вы не знали раньше.
	 Первое, что печатает данные командный файл - это главное меню:
</BIG>

<CODE>
<hr>
|
|				   UUST MENU				system node: russ
|					 ---------
|	  c - connect with another system in debug mode
|	  d - show files in your directory under PUBDIR
|	  f - long list files in the spool directory
|	  l - display the logfile dynamically
|	  r - reconnect with another system
|	  s - give user summary of transactions
|	  u - unlock the tty line
|	  w - display logfile for the last week
|	 <cr> - exit program
|
|  Press c,d,f,l,r,s,u,w,or <cr>:</CODE>
<BIG>
	 Первая опция  'c'  предназначена  для  подключения  линии uucp в
отладочном режиме.  Эта опция генерирует такую же  командную  строку,
как  при  ручном  способе  запуска  процесса  uucico (см.  предыдущий
раздел).  Uust запрашивает у вас имя системы,  к  которой  вы  хотите
подключиться.
	 Следующая опция 'd' дает длинноформатный листинг  файлов  вашего
каталога,	определяемого	вашей	переменной	$PUBDIR,	т.е.
/usr/spool/uucppublic/$LOGNAME.  Если вы часто  делаете  пересылки  с
помощью  uucp,  здесь  может  собраться  много  файлов.  Данная опция
предоставляет вам простой способ их просмотра.
	 Опция 'f'	выдает   длинноформатный   листинг   всех   файлов,
находящихся в каталоге подкачки.  Выход команды "ls -l" передается по
конвейеру  команде  more,  что удобно при наличии большого количества
файлов. Этот каталог является сердцем исполняющей системы uucp. Почти
все находится или в этом каталоге, или как-то связано с ним.
	 Опция 'l',  видимо, наиболее часто используемая во всей утилите.
Она  позволяет увидеть в динамике функционирование uucp,  наблюдая за
регистрационным файлом.  При первом вызове она печатает последние  20
строк   этого   файла,  а  затем  ведет  наблюдение,  пока  не  будет
остановлена ее работа. Общее количество нажатий на клавиши для вызова
этой  команды  с  помощью  uust  равно  5:  4 для вызова uust и 1 для
указания опции меню.  Для того чтобы набрать ту же  команду  вручную,
требуется 31 символ.  Вот где экономия времени и избавление от лишних
проблем!
	 Очень интересна  опция  'r'.  Укажите  ей  имя  системы  - и она
установит связь с этой системой при  помощи  uucp.  Используемый  при
этом  метод  отличается  от  метода,  применяемого  в  опции 'c',  но
работает в System  V.  Отметим,  однако,  что  в  большинстве  систем
команда	uusub,   задействованная   здесь,   требует   возможностей
суперпользователя.  Uusub  возвращает   управление   обратно   вашему
интерпретатору shell, но затем запускает uucp в фоновом режиме. Когда
это произойдет,  uust продвигается вперед и  показывает  динамический
хвост регистрационного файла, как описано выше. После этого вы можете
наблюдать все действия uucp по вызову,  передаче файлов и  завершению
работы.
	 Опция 's' показывает все ваши транзакции к утилите uucp, выбирая
из  регистрационного  файла только то,  что относится к вашему имени.
Обычно имеется много записей,  поэтому вывод передается по  конвейеру
команде more в целях удобства чтения.
	 Следующую опцию 'u' нужно использовать с  большой осторожностью.
Она удаляет файлы блокировки, устанавливаемые системой uucp для самой
себя.  Если в это время  uucp  работает,  другой  пользователь  может
обратиться  при  помощи  cu  к  линии  и  все  разрушить.  Эти  файлы
блокировки  существуют  также,   когда   кто-то   применяет   cu   на
последователной линии. Данная опция предусмотрена по той причине, что
иногда uucp или cu  завершается  аварийно.  Когда  такое  происходит,
нужно удалить файлы блокировки,  чтобы начать все сначала.  Эту опцию
следует использовать только для этой цели либо  для  запланированного
эксперимента, чтобы посмотреть, что при этом может произойти.
	 Последняя опция   'w'   предназначена   для	отображения	из
регистрационного  файла  тех  транзакций  uucp,  которые  относятся к
последней  неделе.  Это  нетрудно  сделать,  но  если  бы  вы  искали
определенную  транзакцию,  вы  могли  бы применить для этого средства
поиска символьных строк команды more.


<ul><a name=372></a><h2>ПРИМЕР</h2></ul></BIG>
<CODE>
	 $ uust
	 r
</CODE><BIG>
	 Это попытка  повторного  подключения  к  линии  uucp.  Ее  можно
использовать  для  опроса  другой системы или для отправки или приема
данных,  стоящих в очереди. Первым делом запрашивается имя системы, к
которой  нужно  обратиться.  Затем  эта  команда пытается удалить все
файлы, оставшиеся после предыдущих аварийных завершений, и произвести
вызов.


<ul><a name=373></a><h2>ПОЯСНЕНИЯ</h2></ul>

	 Uust является однопроходной утилитой,  т.е.  не имеет внутренних
циклов.   Вы  выбираете  опцию,  и  после  завершения  ее  выполнения
завершается весь командный файл.  Таким способом это сделано  главным
образом  по  той причине,  что вы должны обрывать вывод команды tail,
коорая используется некоторыми опциями меню.  Однако,  клавиша  break
прекращает   все,  даже  выполнение  uust.  Не  имеет  смысла  делать
внутренний цикл, так как этот цикл редко смог бы повториться.
	 В строках  4-8  выполняется проверка командной строки на наличие
ошибок.  Если переданы  какие-то  аргументы,  выдается  сообщение  об
ошибке и командный файл завершается.
	 Строка 10 инициализирует переменную UUNODE текущим  именем  uucp
той  системы,  в  которой  вы  работаете.  Это обеспечивается вызовом
утилиты uuname.
	 Строки 11-24  отображают  главное  меню одним большим оператором
echo.  Имя системы,  поступившее в переменную  UUNODE,  выдается  для
справки в правой верхней части экрана.
	 В строке  25  читается  ответ  пользователя,  а   строки   27-66
проверяют  команду  и  выполняют  ее.  Если  вы  ввели только возврат
каретки, это соответствует строке 28, и программа завершается.
	 Строки 29-38 обрабатывают команду 'c' - подключение в отладочном
режиме.  Запрашивается имя системы и проверяется,  не пустое ли  оно.
Если  оно  пустое,  командный  файл  завершается.  В противном случае
строка 34 сообщает, что uust пытается удалить все файлы STST, которые
создавались  при  неудачных  вызовах.  Перед  тем  как  обратиться  к
системе,  вы должны удалить все файлы STST.  Если таких  файлов  нет,
команда rm не срабатывает и выдается сообщение "no STST files".
	 Строки 39-40  выполняют  опцию  'd'.  Сначала  отображается  для
справки   название   каталога,   который   мы   просматриваем.  Затем
распечатывается  каталог  PUBDIR  в  длинном  формате.  Заметим,  что
LOGNAME   соответствует   любому  пользователю,  запустившему  данную
программу,  поэтому нет необходиvости  вписывать  в  текст  программы
какое-то значение.
	 В строках 41-42 аналогичным образом обрабатывается опция 'f'. Мы
распечатываем здесь каталог подкачки.
	 Команда 'l'   в   строках   43-44   сообщает,  что  отображается
регистрационный файл.  Затем используется команда "tail -f". Опция -f
означает,  что  нужно  производить отображение того,  что находится в
файле следующим образом: как только транзакции печатаются в файл, они
отображаются  на ваш экран.  Пользователь должен нажать клавишу break
для выхода из программы.
	 Строки 45-58 выполняют команду 'r',  которая пытается произвести
повторное   подключение.   Сначала   запрашивается   имя   системы  и
сравнивается с пустой строкой.  Если имя введено, мы пытаемся удалить
файлы  STST и выдаем сообщение о том,  было ли это удаление успешным.
Затем печатается сообщение о том,  что запускается процесс  uusub.  В
строке  54 проверяется,  является ли корневым файлом XENIX.  Если это
так, то утилита uusub вызывается с учетом ее нового местонахождения в
системе  XENIX.  В  противном  случае  она  вызывается с указанием ее
обычного местонахождения  -  /usr/lib/uucp.  После  выполнения  uusub
отображается   динамический   хвост   регистрационного   файла,  пока
пользователь не нажмет  клавишу  break,  после  чего  командный  файл
завершается.
	 В строках  59-60  выполняется  проверка  сводки  о  транзакциях.
Используется   команда   uulog,   ей   передается   LOGNAME  текущего
пользователя. Подробности о команде uulog можно найти в документации.
	 Опция 'u' рассматривается в строках 61-62.  Сначала отображается
команда  rm,  которая  будет  выполнена,  чтобы  уведомить  об   этом
пользователя. Затем эта команда выполняется, чтобы попытаться удалить
файлы  блокировки.  Если  команда  удаления   завершается   неудачей,
выдается  сообщение  об  ошибке,  указывающее  на  отсутствие  файлов
блокировки.
	 Строки 63-64 запускают опцию 'w',  чтобы посмотреть деятельность
uucp за последнюю неделю.  С помощью  команды  more  печатается  файл
LogWEEK.  Этот файл создается утилитой uucp,  чтобы обеспечить сжатую
сводку о работе в течение недели.
	 Строка 65   соответствует   любым   командам,  которые  не  были
распознаны ранее.  Такие  команды  являются  ошибочными,  и  выдается
сообщение об этом. Когда выполнение программы доходит до этого места,
она завершается.

<hr>
ИМЯ: uutrans
<hr>

<a name=374></a>uutrans	  Передача файловых деревьев из одной системы
			 UNIX в другую систему UNIX


<ul><h2>НАЗНАЧЕНИЕ</h2></ul>

	 Копирует полную  иерархию  файловой  системы  с  помощью  uucp в
другую систему UNIX и поддерживает структуру файлового дерева.


<ul><a name=375></a><h2>ФОРМАТ ВЫЗОВА</h2></ul>
</BIG>
<CODE>uutrans</CODE>
<BIG>
<ul><a name=376></a><h2>ПРИМЕР ВЫЗОВА</h2></ul></BIG>
<CODE>
cd $HOME/backup
uutrans
remote
~russ
</CODE><BIG>
	 Начиная с  подкаталога  backup  моего регистрационного каталога,
запустить uutrans с целью передачи всех моих файлов. Файлы посылаются
в систему remote и размещаются там в моем регистрационном каталоге
(/usr/russ).

<ul><a name=377></a><h2>ТЕКСТ ПРОГРАММЫ</h2></ul></BIG>
<CODE>
1   :
2   # @(#) uutrans v1.0  Transfer file trees via uucp
3   #					Author: Russ Sage
4   if [ $# -gt 0 ]
5	 then  echo "uutrans: argument count error" >&2
6		   echo "usage: uutrans"				 >&2
7		   exit 1
8   fi

10  SELF=`uuname -l`

12  echo "source directory(<cr> to exit): \c"
13  read SOURCE
14  if [ "$SOURCE" = "" -o ! -d "$SOURCE" ]
15	then  exit 1
16  fi

18  echo "\ndestination system(<cr> for $SELF): \c"
19  read SYSTEM
20  echo "\ndestination directory(<cr> for ~/$LOGNAME): \c"
21  read DEST

23  : ${SYSTEM:="$SELF"}
24  : ${DEST:="~/$LOGNAME"}

26  echo "\nQUEUEING:"

28  find $SOURCE -type f -print | sort | while read FILE
29  do
30		  echo $FILE
31		  uucp -c -d -r $FILE $SYSTEM!$DEST/$FILE
32  done
</CODE>
<BIG>
<ul><a name=378></a><h2>ПЕРЕМЕННЫЕ СРЕДЫ ВЫПОЛНЕНИЯ</h2></ul>

DEST		Место назначения, куда нужно копировать файлы
FILE		Определенный копируемый файл
LOGNAME	 Содержит регистрационное имя
SELF		Содержит узловое имя текущей системы
SOURCE	  Источник всех копируемых файлов
SYSTEM	  Имя системы, в которую нужно копировать


	   <b>ОПИСАНИЕ</b>

			 ЗАЧЕМ НАМ НУЖЕН КОМАНДНЫЙ ФАЙЛ uutrans?

	 Копирование файлов из одной системы в другую с  помощью  uucp  -
довольно простая задача:  достаточно указать,  какие файлы куда нужно
направить. Но как быть в случае, когда вам нужно скопировать иерархию
файлов?  Как гарантировать, что файлы расположатся в системе-адресате
в виде иерархии,  а не будут  засунуты  в  один  и  тот  же  каталог?

Единственное предложение в документации по uucp (даже не на страницах
руководства) говорит о том,  как это  сделать.  Если  вы  никогда  не
читали его, то скорее всего ваши пересылки завершатся неудачей.
	 Нам нужно   инструментальное	средство,	которое	передает
древовидные структуры в другие системы,  сохраняя при этом форму этих
структур.  Мы хотим обеспечить простой способ выполнения этой работы,
чтобы не искать каждый раз припрятанную информацию.


					   ЧТО ДЕЛАЕТ uutrans?

	 Uutrans предоставляет гибкий интерфейс, гарантирующий правильное
копирование файловых иерархий. Этот командный файл знает, какие файлы
передавать,  в  какую систему их направить и где их разместить в этой
системе.
	 Когда вы   запускаете   uutrans,  первым  делом  он  запрашивает
исходный каталог для пересылки файлов.  Если вы не хотите продолжать,
нажмите   возврат   каретки   для   выхода.  Обратите  внимание,  что
используется команда find,  поэтому путь,  который  вы  указываете  в
ответ  на  подсказку,  является  префиксом маршрутного имени для всех
передаваемых файлов.  Например, если вашим текущим каталогом является
$HOME  и  вы  хотите  сделать его каталогом-источником,  введите ".".
Оператор  find  сгенерирует  для  файла   /src/f.c   маршрутное   имя
./src/f.c.   Если   же   вы  введете,  например,  имя  /usr/russ,  то
результирующим  маршрутным  именем  будет  /usr/russ/src/f.c.   Таким
образом,  требуется  небольшая  предусмотрительность,  чтобы избежать
создания лишних уровней каталога в системе-адресате.
	 Затем запрашивается имя системы-адресата.  Если вы хотите, чтобы
это была ваша  собственная  система,  нажмите  возврат  каретки.  Это
позволит  скопировать  файлы  в пределах того же жесткого диска или в
другие файловые системы.
	 В запросе каталога-адресата умолчанием является PUBDIR. Если вам
это не подходит,  укажите точное маршрутное имя каталога,  с которого
вы  хотите начать иерархию в системе-адресате.  (Напомним также,  что
многие  системы  накладывают  ограничения  на  то,  куда  вы   можете
копировать   файлы   с   помощью   uucp.)   Способ,  которым  uutrans
поддерживает правильное файловое дерево -  это  указание  абсолютного
маршрутного   имени   в   системе-адресате,   ниже   которого   будут
располагаться все передаваемые файлы. Единственный способ сделать это
-  занести  маршрутное  имя в переменную и использовать ее в качестве
путей как источника, так и адресата при вызове uucp.
	 Когда вся входная информация введена, используется команда find,
чтобы найти все файлы,  относящиеся к данной иерархии.  Затем  каждое
маршрутное имя передается по конвейеру в цикл, который отображает имя
и передает файл адресату при помощи uucp.
	 Для того  чтобы  ускорить  весь  процесс  и сэкономить свободное
пространство,  файлы ставятся в очередь в каталоге подкачки (т.е.  не
делается  попытка  вызвать  удаленную  систему),  и  никакие файлы не
копируются в каталог подкачки. Это экономит время, которое ушло бы на
копирование  больших количеств файлов,  и даже может обезопасить вашу
машину от аварийных завершений работы,  так как копирование  большого
числа файлов забирает все свободное пространство.
	 Когда все  файлы  поставлены  в  очередь,  вам   нужно   вручную
подсоединиться к uucp с помощью команды 'c' или 'r' утилиты uust. Все
каталоги в системе-адресате должны создаваться автоматически  по мере
пересылки файлов.
	 Несколько неприятный вопрос - права собственности  и  доступа  к
файлам  на  принимающей стороне.  Обычная последовательность действий
такова:

	 1. Поставить файлы в очередь к uucp, используя инструментальное
		средство uutrans.
	 2. Выйти из системы-источника.
	 3. Войти в систему-адресат.
	 4. Запустить uust и повторно подключиться к uucp.

	 Если вы придерживаетесь такой технологии постановки в  очередь и
передачи,   то   вы   полностью   контролируете,   какие  файлы  куда
направляются. Имеется побочный эффект, заключающийся в том, что права
доступа к файлам в каталоге-адресате устанавливаются в соответствии с
маской интерпретатора shell  (shell  umask)  того  процесса,  который
производит повторное подключение.
	 Необходимо отметить, что если у вас нет прав доступа на запись в
вашей  umask,  то создается пересылочный каталог,  но в него не могут
быть помещены никакие файлы,  что подрывает передачу файлов с помощью
uucp.  Для  разрешения этой проблемы измените вашу umask на "000" (по
умолчанию она равняется 777 для каталогов и 644 для  обычных файлов).


<ul><a name=379></a><h2>ПРИМЕРЫ</h2></ul></BIG>
<CODE>
1.  cd $P
	uutrans
	.
	remote
	<cr></CODE>
<BIG>
	 Сменить каталог  на  PUBDIR.  Передать  все  файлы  из  текущего
каталога (.) в  удаленную  систему,  размещая  их  в  подразумеваемом
каталоге ~/$LOGNAME, т.е. в моем каталоге PUBDIR.</BIG>
<CODE>
2.  uutrans
	/etc
	remote
	/tmp/etc</CODE>
<BIG>
	 Передать все файлы из каталога /etc в систему remote, помещая их
в каталог /tmp/etc.


<ul><a name=380></a><h2>ПОЯСНЕНИЯ</h2></ul>

	 Строки 4-8  проверяют  наличие  ошибок.  Если в командной строке
есть аргументы, печатается сообщение об ошибке.
	 Строка 10   инициализирует   переменную   SELF   именем   вашего
системного узла, используемого утилитой uucp.
	 Строки 12-16  запрашивают  каталог-источник  и  читают  ответ  в
переменную  SOURCE.  Если  ничего  не  введено или указан не каталог,
программа завершается.
	 Строки 18-21   запрашивают  систему-адресат  и  каталог-адресат.
Умолчаниями являются ваша собственная система и  каталог  PUBDIR  для
размещения   файлов.   Эти   умолчания   облегчают  конфигурирование,
связанное  с  пересылкой  информации,  чтобы  не  было  необходимости
вводить много данных.
	 В строках 23 и 24 проверяется,  инициализированы ли  переменные.
Если  переменной  SYSTEM  присвоен  возврат каретки,  в нее заносится
значение  SELF.  Если  переменная  DEST  пустая,   ей   присваивается
~/$LOGNAME. Эти операторы устанавливают значения по умолчанию.
	 Строка 26  печатает  сообщение  о  том,  что  файлы  ставятся  в
очередь.  Весь фокус заключается фактически в строках 28-32.  Команда
find начинает работать с каталога SOURCE и находит все обычные файлы.
Этот список передается утилите sort,  так что uucp пересылает файлы в
отсортированном порядке. Это облегчает отслеживание того, какие файлы
были переданы, если возникают какие-то проблемы.
	 Отсортированный список попадает в  цикл  while,  читающий  имена
файлов. Каждое имя отображается на экран для справки, и файл ставится
в очередь к удаленной системе.  В строке 31 указаны такие опции uucp:
-r для постановки в очередь, -c для того, чтобы не копировать файлы в
каталог  подкачки,  и  -d  для  создания  каталогов,  необходимых   в
удаленной системе.
	 Для поддержки  древовидной  структуры  мы  применяем  магический
синтаксис $SYSTEM!$DEST/$FILE.  Нам нужно не только скопировать файлы
в систему и в каталог,  но и  определить  маршрутное  имя  вплоть  до
самого  файла.  Это  гарантирует,  что  файлы  будут  расфасованы  по
каталогам.  Если бы был использован синтаксис $SYSTEM!$DEST,  то  все
файлы  попали  бы в один каталог и их иерархическая структура была бы
утеряна.
	 После того  как все файлы поставлены в очередь,  они находятся в
этой очереди до тех пор,  пока их не позовет удаленная система. Тогда
файлы будут скопированы в эту систему.


<ul><a name=381></a><h2>КОНФИГУРАЦИОННЫЕ РЕШЕНИЯ</h2></ul>

	 Зачастую на практике вокруг  нашей  системы  UNIX  накапливается
много   не   особенно   совместимой  аппаратуры,  включая  терминалы,
микро-ЭВМ и модемы. Как заставить их работать совместно? Теперь когда
мы   рассмотрели  основные  особенности  аппаратуры  и  программмного
обеспечения для коммуникаций в системе UNIX,  мы  готовы  представить
некоторые  примеры  работы коммуникаций в комплексах с системой UNIX.
Мы  хотим  рассмотреть  ряд  конфигураций,   использующих   различные
комбинации   аппаратуры.  Проблемы  меняются,  но  наш  общий  подход
остается.


			ПОДКЛЮЧЕНИЕ UNIX К МОДЕМУ И ГЛАВНОЙ МАШИНЕ

	 Первая задача,   которую   мы   рассмотрим,   это  использование
"персональной" системы UNIX,  модема и главной  машины.  У  нас  есть
система UNIX с одним последовательным портом,  но мы имеем как модем,
так и линию прямого подключения к системе большего размера.  Как  нам
использовать  один последовательный порт и для модема,  и для главной
машины? Решение показано на рис. 8-10.


		Рис. 8-10. Подключение системы UNIX к модему и главной машине</BIG>
<CODE><hr>

		  *****					 +----------------+
		 *	 *					|				|
		* модем *				   | главная машина |
		 *	 *					|				|
		  *****					 +----------------+
			^							   ^
			| Прямой кабель				 | Нуль-модем
			|							   |
			|	   +---------------+	   |
			 ------>|			   |-------
					| переключатель |
					|			   |
					 \			 /
					  \___________/
							^
							|
							| Прямой кабель
							|
							v
					 +-------------+
					 |			 |
					 |	 UNIX	|
					 |			 |
					 +-------------+

<hr></CODE>
<BIG>
	 Нам нужен блок переключения.  Этот блок имеет один вход на одной
стороне и два входа на другой. Мы подсоединяем UNIX к главному входу,
что позволяет переключаться либо на модем,  либо на  главную  машину.
Здесь два различных подсоединения:

UNIX <-- --> модем
				Вызов из UNIX при помощи cu, uucp и обращение в UNIX
				с удаленного терминала

UNIX --> главная машина
				UNIX обращается к главной машине, как прямо
				подключенный терминал


			  ПОДКЛЮЧЕНИЕ UNIX И ТЕРМИНАЛА К МОДЕМУ

	 Эта конфигурация аналогична предыдущей, за исключением того, что
вся   аппаратура  локальна.  Мы  хотим  использовать  модем  как  для
терминала, так и для UNIX. Конфигурация показана на рис. 8-11.
	 Порт системы  UNIX подсоединяется к одной стороне переключателя,
а терминал к другой.  Отметим,  что терминал НЕ  будет  обращаться  в
систему  UNIX.  Все кабели прямолинейные.  В таком комплексе возможны
следующие конфигурации:


UNIX <-- --> модем
				Обращение в UNIX с удаленного терминала и вызов из
				UNIX с помощью cu, uucp

терминал --> модем
				Для вызова из UNIX только в качестве немого терминала


		Рис. 8-11.	  Подключение UNIX и терминала к модему</BIG>
<CODE><hr>

						*****
					   *	 *
					  * модем *
					   *	 *
						*****
						  ^
						  |
						  | Прямой кабель
						  |
						  v
					/-----------\
				   /			 \
				  |			   |
				  | переключатель |
				  |			   |
		  ------->|			   |<-------
		  |	   |_______________|		|
   Прямой |								| Прямой
   кабель |								| кабель
		  |								|
		  v								|
	+-----------+				   +--------------+
	|		   |				   |			  |
	|   UNIX	|				   |   терминал   |
	|		   |				   |			  |
	+-----------+				   +--------------+

<hr>
</CODE>
<BIG>
	  ПОДКЛЮЧЕНИЕ UNIX К ТЕРМИНАЛУ, МОДЕМУ И ГЛАВНОЙ МАШИНЕ

	 Эта ситуация довольно сложна и требует двух блоков переключения.
Соответствующая архитектура показана на рис. 8-12.


   Рис. 8-12. Подключение системы UNIX к терминалу,
					   модему и главной машине</BIG>
<CODE><hr>

						   *****				 +----------------+
						  *	 *				|				|
						 * модем *			   | главная машина |
						  *	 *				|				|
						   *****				 +----------------+
							 ^							^
					  Прямой |							| Нуль-
					  кабель |							| модем
							 |	  +---------------+	 |
	 +-------------+		  ----->|			   |-----
	 |			 |				| переключатель |
	 |   терминал  |				|	   2	   |
	 |			 |				 \			 /
	 +-------------+				  \___________/
			|							   ^
			| Нуль-модем					| Прямой кабель
			|							   |
			|	   +---------------+	   |
			 ------>|			   |<------
					| переключатель |
					|	   1	   |
					 \			 /
					  \___________/
							^
							|
							| Прямой кабель
							|
							v
					 +-------------+
					 |			 |
					 |	 UNIX	|
					 |			 |
					 +-------------+

<hr>
</CODE><BIG>
	 Начнем с   системы   UNIX.   В   ней  имеется  линия,  идущая  в
переключатель  1  в  качестве   главного   входа.   Переключатель   1
осуществляет  переключение  между терминалом и блоком переключения 2.
Это позволяет системе UNIX либо получать терминал для  регистрации  в
системе  (в предположении,  что работает getty),  либо получать модем
для регистрации  в  системе,  либо  посылать  информацию  модему  или
главной машине (предполагается, что процесса getty нет). Заметим, что
между терминалом и UNIX должен быть нулевой модем,  но  мы  не  можем
сделать  нуль-модем  сразу  после  UNIX,  потому что нам нужен прямой
кабель для подсоединения к модему.
	 Затем блок переключения 2 выполняет коммутацию между  модемом  и
главной машиной. Линия к модему должна быть прямой, а линия в главную
машину должна быть нуль-модемом. Возможны следующие взаимосвязи:

UNIX <-- терминал
				Обращение в UNIX с терминала по линии getty

UNIX <-- --> переключатель <-- --> модем
				Вызов из UNIX с помощью cu, uucp и обращение в
				UNIX с удаленного терминала

UNIX --> переключатель --> главная машина
				Обращение из UNIX при помощи cu, uucp



				 СИСТЕМА UNIX, МИКРО-ЭВМ И МОДЕМ

	 В этой конфигурации также требуется два  блока  переключения.  У
нас  есть  машина  с  двумя  последовательными  линиями,  на  которой
работает UNIX,  автономная микро-ЭВМ  и  модем,  который  они  должны
совместно использовать.  UNIX-машина также воспринимает регистрацию с
автономной машины,  позволяя ей эмулировать терминал, если у нас есть
соответствующее  программное  обеспечение.  Решение  показано на рис.
8-13.

		  Рис. 8-13.   Система UNIX, микро-ЭВМ и модем</BIG>
<CODE><hr>

							   *****
							  *	 *
							 * модем *
							  *	 *
							   *****
								 ^
								 | прямой кабель
								 |
								 v
						  ______________
						 /			  \
						/				\
						|  переключатель  |
						|		2		|
						-------------------
							^		 ^
							|		 |
							|		 |
			-----------------		 -------------------
			|										   |
			|  -------------------------------		  |
			|  |							 |		  |
			|  |							 |		  |
			|  |						  -------------------
			|  |						  |				 |
			|  |						  |  переключатель  |
			|  |						   \	   1	   /
			|  |							\_____________/
  Прямой	|  | Нуль-модем						^
  кабель	|  |								   |
			v  v								   |
		 +--------+						 +-------------+
		 |		|						 |			 |
		 |  UNIX  |						 |  микро-ЭВМ  |
		 |		|						 |			 |
		 +--------+						 +-------------+

<hr>
</CODE><BIG>
	 Микро-ЭВМ может работать двумя способами:  либо как  терминал  в
системе UNIX,  либо как терминал для обращения к модему. Система UNIX
имеет один последовательный порт, позволяющий связываться с микро-ЭВМ
через  переключатель  1.  Другая  последовательная  линия идет в блок
переключения 2,  подсоединенный к модему.  По этой линии  можно  либо
обращаться  из  системы  UNIX во внешний мир,  либо принимать внешние
вызовы  с  целью  удаленной  регистрации  в  системе   через   модем.
Переключатель  2  коммутирует  модем между микро-ЭВМ и системой UNIX.
Возможны такие комбинации:

микро-ЭВМ --> переключатель --> модем
				Обращение вовне с помощью коммуникационных средств

микро-ЭВМ --> переключатель --> UNIX
				Регистрация в системе путем эмуляции терминала

UNIX <-- переключатель <-- микро-ЭВМ
				Регистрация с терминала, подключенного напрямую

UNIX <-- --> переключатель <-- --> модем
				Вызов из UNIX при помощи cu, uucp, удаленная
				регистрация

модем <-- переключатель <-- микро-ЭВМ
				Вызов модема с микро-ЭВМ

модем <-- --> переключатель <-- --> UNIX
				Вызов из UNIX или обращение в UNIX; требуется
				изменение getty для последовательной линии и
				автоответа модема


<ul><a name=382></a><h2>АЛЬТЕРНАТИВНОЕ РЕШЕНИЕ</h2></ul>

	 Возможно еще одно  решение  предыдущей  задачи.  Оно  использует
несколько больше возможностей, чем предыдущее решение. Те же основные
проблемы решены, но подход при этом сильно отличается.
	 В конфигурации,  показанной  на  рис.  8-14,  блоки переключения
подсоединяются иначе, чем в предыдущем комплексе. Доступны те же пути
передачи информации, а также некоторые новые.

			  Рис. 8-14. Система UNIX, микро-ЭВМ и модем
					в альтернативной конфигурации</BIG>
<CODE><hr>

												  *****
												 *	 *
										------->* модем *
									   |		 *	 *
		   --------------------		|		  *****
		  |					|	   |
		  |					|	   | прямой кабель
		  |					|	   v
		  |					_______________
		  |				   |			   |
		  | нулевой		   | переключатель |
		  | модем			  \	 2	   /
		  |					 \-----------/
		  |						   ^
		  |						   | прямой кабель
		  |						   |
		  |						   v
		  |					 /-----------\
		  |					/			 \
		  |				   | переключатель |
		  |				   |	   1	   |
		  |				   +_______________+
		  |						^	^
		  |						|	|
		  |		прямой кабель   |	| прямой кабель
		  |	 -------------------	  --------------
		  |	|									  |
		  v	v									  |
		+--------+							+---------------+
		|		|							|			   |
		|  UNIX  |							|   микро-ЭВМ   |
		|		|							|			   |
		+--------+							+---------------+

<hr>
</CODE><BIG>
	 Как микро-ЭВМ,  так и система UNIX подключены к переключателю 1.
Этот переключатель присоединен к блоку переключения 2 главным входом.
Линии от микро-ЭВМ,  от UNIX,  между переключателями и модемная линия
должны быть прямыми  кабелями.  Только  входная  линия  системы  UNIX
должна быть нуль-модемом.
	 Переключатель 2  коммутирует  один  из  центральных  процессоров
между модемом и второй последовательной линией системы UNIX. Модемная
линия может идти от модема или к нему,  но линия системы UNIX  должна
быть  только  входящей,  потому  что в UNIX работает getty.  Возможны
такие комбинации:

микро-ЭВМ --> переключатель --> модем
				Обращение вовне при помощи коммуникационных средств

микро-ЭВМ --> переключатель --> UNIX
				Регистрация в системе путем эмуляции терминала

UNIX <-- --> переключатель <-- --> модем
				Обращение из или в UNIX с помощью cu, uucp

UNIX --> переключатель --> UNIX
				Выход с первой линии идет во вторую линию для
				регистрации в системе

модем <-- --> переключатель <-- --> процессор
				Выбор центрального процессора зависит от
				переключателя 1

UNIX <-- переключатель <-- процессор
				В зависимости от переключателя 1, один из
				процессоров может зарегистрироваться в системе


						 ТРИ СИСТЕМЫ UNIX

	 Последняя конфигурация,  которую мы рассмотрим,  это  соединение
трех  систем  UNIX.  Данное  решение  было подсказано конфигурацией с
прямым подсоединением  16-разрядной  машины  PC  XENIX,  32-разрядной
машины PC XENIX и главной машины VAX.  Для того чтобы выполнить такое
подключение, нам нужно три двунаправленных блока переключения.
	 Не так  важно,  какая  из микро-ЭВМ 1 и микро-ЭВМ 2 является 32-
или 16-разрядной машиной. Они могут быть в вашем помещении, а главная
машина  может  стоять  где-то  в другом месте и соединяться кабелем с
вашим помещением.  При этом предполагается,  что  кабель  от  главной
машины  уже  является  нуль-модемом  в  вашем  подключении.  Еще один
нулевой кабель располагается между двумя системами UNIX на микро-ЭВМ,
чтобы  можно  было зарегистрироваться с одной из этих систем в другой
системе в качестве  терминала.  Остальные  кабели  прямые  (см.  рис.
8-15).

	   Рис. 8-15. Три системы UNIX</BIG>
<CODE><hr>

					 +------------------+
					 |				  |
					 |	   UNIX	   |
					 |  главная машина  |
					 |				  |
					 +------------------+
							   ^
							   | нуль-модем
							   |
						______________
					   /			  \
					  /				\
					 |  переключатель   |
					 |		3		 |
					 |__________________|
							^	^
							|	|
			 прямой кабель  |	|  прямой кабель
			----------------	  ----------------
		   |									  |
		   |			-----------------------   |
		   |		   |	  нуль-модем	   |  |
		   |		   v					   v  |
		---------------				 ---------------
	   |			   |			   |			   |
	   | переключатель |			   | переключатель |
		\	  1	  /				 \	  2	  /
		 \___________/				   \___________/
			   ^							   ^
	   прямой  |							   | прямой
	   кабель  |							   | кабель
			   v							   v
		+-------------+				 +-------------+
		|			 |				 |			 |
		|	UNIX	 |				 |	UNIX	 |
		| Микро-ЭВМ 1 |				 | Микро-ЭВМ 2 |
		|			 |				 |			 |
		+-------------+				 +-------------+

<hr>
</CODE><BIG>
	 Каждая микро-ЭВМ подсоединена к блоку переключения через главное
соединение.  Эти переключатели 1 и 2 коммутируются друг с другом и  с
блоком переключения 3.
	 Микро-ЭВМ 1  может  переключаться  на  микро-ЭВМ  2  в  качестве
интерфейса  терминал/uucp  и  на главную машину в качестве удаленного
терминала. В этом случае линия главной машины проходит через селектор
порта.  Микро-ЭВМ  2  может переключаться между микро-ЭВМ 1 и главной
машиной аналогичным  образом.  Переключатель  3  коммутирует  главную
машину   между   микро-ЭВМ   1  и  микро-ЭВМ  2.  Возможны  следующие
комбинации:

микро-ЭВМ 1 --> переключатель --> главная машина
				Зарегистрироваться в качестве удаленного терминала

микро-ЭВМ 1 <-- --> переключатель <-- --> микро-ЭВМ 2
				Обращение в UNIX или из UNIX в зависимости от getty

микро-ЭВМ 2 <-- --> переключатель <-- --> микро-ЭВМ 1
				Обращение в UNIX или из UNIX в зависимости от getty

микро-ЭВМ 2 --> переключатель --> главная машина
				Зарегистрироваться в качестве удаленного терминала

главная машина <-- переключатель <-- микро-ЭВМ 1
				Зарегистрироваться с удаленного терминала

главная машина <-- переключатель <-- микро-ЭВМ 2
				Зарегистрироваться с удаленного терминала

								***


	 Вероятно, рассмотренные  нами  конфигурации  могут не в точности
соответствовать вашим потребностям.  Однако мы представили их  с  той
целью,  чтобы  вы  увидели  разнообразие типовых решений,  которые вы
можете адаптировать для себя.  В следующей главе мы несколько отойдем
от  всех  этих  гаек  и  болтиков  и  подробнее  рассмотрим  вопросы,
связанные   с   администрированием	системы,	особенно	вопросы
безопасности.
</BIG>
</pre><hr>
<A HREF="chap07.htm">Назад.</A>
<A HREF="chap09.htm">Вперёд.</A>
<A HREF="chap00.htm#toc8.1">Оглавление.</A><hr>

<BR>
<table cellspacing="2" cellpadding="2" border="0">
<tr VALIGN=TOP>
<td>
<!-- BEGIN MGUL-COUNTER CODE -->
<img src="http://ns.mgul.ac.ru/cgi-bin/counter.cgi?Linux" border=0 height=31 width=88 alt="LSCS">
<!-- END MGUL-COUNTER CODE -->
</td>
	<td rowspan="2">
<!--begin of Top100-->
<a href="http://top100.rambler.ru/top100/">
<img src="http://counter.rambler.ru/top100.cnt?124566" alt="Rambler's Top100" width=1 height=1

border=0></a>
<!--end of Top100 code-->

<!--begin of Top100 logo-->
<a href="http://top100.rambler.ru/top100/">
[AD-SIZE]<AD- ://images.rambler.ru/top100/banner-88x31-rambler-blue3.gif" alt="Rambler's Top100"

width=88 height=31 border=0></a>
<!--end of Top100 logo -->
</td>
<td>
<!--TopList COUNTER--><script language="JavaScript"><!--
d=document;a='';a+=';r='+escape(d.referrer)
js=10//--></script><script language="JavaScript1.1"><!--
a+=';j='+navigator.javaEnabled()
js=11//--></script><script language="JavaScript1.2"><!--
s=screen;a+=';s='+s.width+'*'+s.height
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth)
js=12//--></script><script language="JavaScript1.3"><!--
js=13//--></script><script language="JavaScript"><!--
d.write('<a href="http://top.list.ru/jump?from=61405"'+
' target=_top><img src="http://top.list.ru/counter'+
'?id=61405;t=99;js='+js+a+';rand='+Math.random()+
'" alt="TopList"'+' border=0 height=18 width=88></a>')
if(js>11)d.write('<'+'!-- ')//--></script><noscript><a
target=_top href="http://top.list.ru/jump?from=61405"><img
src="http://top.list.ru/counter?js=na;id=61405;t=99"
border=0 height=18 width=88
alt="TopList"></a></noscript><script language="JavaScript"><!--
if(js>11)d.write('--'+'>')//--></script><!--TopList COUNTER-->
</td>
</tr>
</TABLE>
</BODY>
</html>

