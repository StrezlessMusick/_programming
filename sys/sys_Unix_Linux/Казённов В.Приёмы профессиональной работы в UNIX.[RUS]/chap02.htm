<html>
<head>
<title>ГЛАВА 2. Доступ к файлам</title>
			<style type="text/css">
A.noneline { font-family: Arial, Serif; text-decoration: none; }
FONT.arial { font-family: Arial, Serif; }
TD.arial   { font-family: Arial, Serif; }
TH.arial   { font-family: Arial, Serif; }
PRE		{ font-family: Courier; color: navy; }
SAMP	   { font-family: Monospace; color: navy; }
TT		 { font-family: Monospace; color: navy; }
VAR		{ font-family: Monospace; color: navy; }
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<basefont size="3">
<center>
<table width=100% border=0 cellpadding=0>
<table cellspacing=0 cellpadding=0 border=0 background="../pic/logo1.jpg" width="100%">
<tr valign=top><td class=arial><a href="http://www.mgul.ac.ru/"><img height=80 width=109 src="../pic/logo.gif" alt="Server of laboratory of space computer science MGUL" border=0></a><br>
</td>
<td align=right class=arial>
<font size="-2">
141001 г.Мытищи МО<br>
<a class=noneline href="http://www.mgul.ac.ru">Ул.Институтская д:1 ком:101</a><br>
(095) 588-32-09, 588-55-62<br>
E-mail: <a class=noneline href="mailto:T-Alex@mgul.ac.ru?Subject='From page topic CIT-FORUM'">T-Alex@mgul.ac.ru</a></font>
</tr>
<tr>
<th colspan=2 class=times>
<font color=#000080 size=2><a href="http://www.mgul.ac.ru" class=noneline>Сервер Лаб. Космической информатики каф.ВТ</a> Московский Государственный Университет Леса</font>
<hr noshade>
</th>
</tr>
</table>
</center>
<A HREF="chap01.htm">Назад.</A>
<A HREF="chap03.htm">Вперёд.</A>
<A HREF="chap00.htm#toc2.1">Оглавление.</A><hr>

<ul><a name=34></a><h1><FONT COLOR="#69BCCB"> * ГЛАВА 2. Доступ к файлам * </FONT></h1></ul>

	   <H2><b>СОДЕРЖАНИЕ</b></H2>


<BLOCKQUOTE><BL>
 <LI>	<A HREF="chap02.htm#35">	 Введение</LI>
 <LI>	<A HREF="chap02.htm#39">2.1. Поиск файлов</LI>
 <LI>	<A HREF="chap02.htm#40">2.1.1. tree - визуализация файлового дерева</LI>
 <LI>	<A HREF="chap02.htm#46">2.1.2. thead - печать начала каждого файла</LI>
 <LI>	<A HREF="chap02.htm#55">2.1.3. tgrep - поиск строк в дереве файловой системы</LI>
 <LI>	<A HREF="chap02.htm#63">2.1.4. paths  -  нахождение пути доступа к исполняемым файлам, со специальными опциями</LI>
 <LI>	<A HREF="chap02.htm#71">2.2.   Вывод информации</LI>
 <LI>	<A HREF="chap02.htm#72">2.2.1. lc - вывод файловой информации на экран по столбцам</LI>
 <LI>	<A HREF="chap02.htm#79">2.2.2. ll - вывод файловой информации в длинном формате</LI>
 <LI>	<A HREF="chap02.htm#86">2.2.3. kind - вывод однотипных файлов</LI>
 <LI>	<A HREF="chap02.htm#94">2.2.4. m - простой доступ к команде more</LI>
 <LI>	<A HREF="chap02.htm#100">2.2.5. mmm - обработка программой nroff макрокоманд для рукописей</LI>
 <LI>	<A HREF="chap02.htm#108">2.2.6. pall - печать всех файлов в дереве</LI>
</BL></BLOCKQUOTE>

<ul><a name=35></a><h2>ВВЕДЕНИЕ</h2></ul>

<P>	 В главе 1 был представлен обзор общей структуры  системы  UNIX  и
показано, как взаимодействуют ее различные части. Это похоже на введение 
в географию, когда на глобусе показывают континенты и крупные водные 
пространства.  Такая информация, хотя и является хорошим фундаментом 
для  общих  знаний,  вряд  ли  поможет  найти  наилучший  путь  из
Сан-Франциско в Лос-Анжелес.  Необходим следующий уровень детализации:
названия поселений, дорог, развилок, улиц, адресов.</P>
<P>	 Файловая система  UNIX  похожа на континент со множеством городов
и,  действительно,  с адресами внутри городов.  Каталоги  и  различные
уровни подкаталогов можно сравнить с маршрутами между различными пунктами 
назначения,  названия файлов - с адресами.  Большое число путей и
мест  назначения может выглядеть пугающе,  но благодаря регулярности и
логичности,  файловая система UNIX   позволяет вам легко  перемещаться
из  одного  места в другое,  если вы знаете несколько основополагающих
принципов.</P>
<P>	 Будучи пользователями UNIX,  все мы научились пользоваться основными 
командами файловой информации, как, например, ls с различными опциями.  
Мы  знаем,  как перемещаться между каталогами и копировать или
перемещать файлы. Тем не менее, находить нужную информацию о файлах из
всей массы информации не так-то легко.  Нам необходимо создать инструментальные 
средства, которые используют древовидную структуру файлов в
UNIX,  чтобы находить то, что мы ищем, и, соответственно, выводить информацию 
о файлах на экран,  печатать листинги  содержимого  файлов  и т.д.
</P>
<P>	 Эта глава знакомит с инструментальными средствами, которые облегчают  
задачу  поиска  и  доступа к файлам.  Доступ к файлам может быть
обеспечен различными способами,  поэтому техника и стиль  меняются  от
одного командного файла к другому.  Например,  в некоторых случаях вам
нужно найти имена всех файлов в данном сегменте  файлового  дерева,  в
других  случаях  вас  будут  интересовать файлы только заданного типа:
текстовые файлы вообще или исходные файлы на языке Си в частности.</P>

<ul><a name=36></a><h2>КОМБИНИРОВАНИЕ ПРОДУКТИВНЫХ ИДЕЙ</h2></ul>

<P>	 Две концепции являются общими почти для всех файловых  инструментальных 
средств.  Первая - это идея рекурсивного поиска, которая означает, 
что некоторые команды системы UNIX (например, find) просматривают  
все файловое дерево,  начиная с некоторой заданной начальной точки
(или с текущего каталога). Если в данном каталоге встречается подкаталог,  
то  его  содержимое тоже исследуется - и так далее вниз к самому
нижнему под-подкаталогу.  Так проходятся маршруты ко всем файлам в целом дереве.
</P>
<P>	 Стандартные команды системы UNIX обеспечивают только ограниченное
число  основных  функций,  которые  могут работать рекурсивно по всему
файловому дереву. Наша стратегия при создании инструментальных средств
в  этой главе - воспользоваться преимуществами такого рекурсивного поиска 
и распространить их на многие другие функции.</P>
<P>	 Вторая ключевая идея,  связанная с полезными файловыми 
инструментальными средствами - это возможность соединения команд с программными
каналами и управление потоком данных с помощью переадресации.  Вероятно,  
вы уже встречались с подобными особенностями в вашей  собственной
работе с UNIX и эффективно их использовали.  Возможно, вы еще не осознали,  
что соединение рекурсивного поиска, предоставляемого некоторыми
стандартными командами,  со специфическими функциями, предоставляемыми
другими командами,  позволяет нам создать команды,  которые  автоматически 
обходят обширные файловые деревья и извлекают нужную информацию.
(В следующей главе мы выйдем за пределы распечатки и  отображения  
информации на экран и научимся работать с файлами так, что мы сможем 
копировать, перемещать и восстанавливать их по мере надобности.)
</P>
<P>	 Для удобства  мы сгруппируем инструментальные средства в два 
раздела:  поиск файлов и  распечатка  файловой  информации.  Имеет  смысл
представлять их в таком порядке, так как вы сначала должны найти файл,
чтобы потом с ним работать.</P>


<ul><a name=37></a><h2>ПОИСК ФАЙЛОВ</h2></ul>

<P>	 Этот раздел посвящен поиску файлов, где бы они ни находились, 
выводу на экран выбранной информации и поиску  символьных  строк  внутри
файлов.</P>
<P>	 Первая программа,  tree,  обходит все файловое дерево и  печатает
имена всех файлов в формате визуального дерева. Она рекурсивно спускается 
в каждый каталог и находит все его файлы,  обеспечивая тем  самым
глобальный осмотр файловых областей и их вложенной по глубине структуры.
</P>
<P>	 Другое инструментальное  средство  -  это  thead.  Thead печатает
несколько первых строк текстовых файлов,  которые находятся  в  данном
сегменте   файлового   дерева.  Просматривая  заголовок,  т.е.  первые
несколько строк файла, вы можете получить достаточно информации, чтобы
идентифицировать содержимое файла. При вызове thead вы можете явно задать 
каталог либо передать команде thead по  конвейеру  список  полных
имен  файлов.  Это делает команду thead фильтром - особым видом команд
системы UNIX, который мы обсудим позже.</P>
<P>	 Следующее инструментальное средство - tgrep.  Как следует из наз-
вания,  это еще одна команда,  связанная с файловым  деревом,  которая
использует утилиту grep.  Tgrep ищет символьные строки в каждом файле,
который находится в данном сегменте файлового дерева.  Tgrep также является 
фильтром,  так что имена файлов можно передавать ей по конвейеру.
</P>
<P>	 В нашем последнем проекте в этом разделе мы обратимся к использованию 
каталогов как средства "навигации".  Сначала мы опишем  основной
алгоритм  для  утилиты,  которая для каждого файла из заданного списка
файлов проверяет, находится ли этот файл в каком-либо каталоге по указанному  
маршруту поиска.  Затем мы построим paths - утилиту,  которая
дополняет функцию поиска полезными опциями.</P>

<ul><a name=38></a><h2>РАСПЕЧАТКА ФАЙЛОВОЙ ИНФОРМАЦИИ</h2></ul>

<P>	 Этот раздел знакомит вас с инструментальными средствами, 
предназначенными для вывода на экран имен файлов и их содержимого. 
Инструменты такого рода весьма полезны, так как они могут значительно уменьшить
количество  необходимых символов,  набираемых с клавиатуры при запуске
команды, и внести больше смысла в одну команду.</P>
<P>	 Первые два  командных  файла являются пре- и постпроцессорами для
команды ls. Команда lc выводит файловую информацию по столбцам, команда 
ll перечисляет файлы в длинном формате.  Эти командные файлы дополнены 
опциями команды ls,  чтобы сделать распечатки более информативны-
ми.  Так как команда ls используется довольно часто, упаковка наиболее
часто применяемых нажатий клавиш в командные файлы представляется  
целесообразной.  Упаковка уменьшает количество постоянно набираемых 
символов и упрощает использование команд, исключает необходимость 
запоминания подробного синтаксиса.</P>
<P>	 Третье инструментальное средство - это kind.  Kind - еще один 
командный  файл  препроцессорного типа,  использующий команду UNIX file.
Команда file читает указанный файл и затем сообщает,  является ли этот
файл текстовым, архивным или исполняемым. Поскольку распечатки команды
file не выбирают файлы заданного типа,  возникает необходимость в создании 
для этого специальной утилиты. Команда kind работает с распечаткой 
команды file.  Kind выводит на экран имена файлов только заданного типа.
</P>
<P>	 Еще один командный файл - m,  который облегчает работу  со  
стандартной  командой  more системы UNIX,  уменьшая количество необходимых
для запуска команды символов и упрощая интерфейс. Делается это без потери  
гибкости:  так  же,  как вы можете использовать команду more для
файла или передать команде more данные по программному каналу,  вы можете 
сделать то же самое для m.</P>
<P>	 Следующий командный файл - это mmm.  Он состоит из одной 
заготовленной  командной строки для программы nroff системы UNIX.  Существует
много способов вызова команды nroff и множество различных опций к ней.
Если же вы редко используете nroff, у вас могут возникнуть трудности в
запоминании специфических опций, необходимых для вашей работы с командой. 
Эти проблемы отпадут, если у вас есть команда mmm. Определите оп-
ции,  которые вы обычно используете, и введите их в командный файл mmm
(о том,  как это сделать практически, речь пойдет ниже). Теперь достаточно 
набрать mmm - и вы имеете возможность работать с вашей  командой nroff.
</P>
<P>	 Последняя утилита - pall.  Pall обходит файловое дерево, ведя поиск 
файлов заданного типа,  и готовит их к выводу на принтер.  Команда
pr системы UNIX используется для  разбивки  на  страницы  всех  файлов
вместе и включения заголовков.  Эта команда предлагает на рассмотрение
принтеру один большой файл и наиболее полезна в тех случаях,  когда  у
вас  имеется  множество каталогов с текстовыми файлами или с исходными
файлами программ.</P>
<P>	 Определив в общем основные наши задачи, перейдем к более близкому
знакомству с упомянутыми инструментальными средствами.</P>


<ul><a name=39></a><h2>2.1. ПОИСК ФАЙЛОВ</h2></ul>

			 <H2><CENTER><a name=40></a>2.1.1. tree - визуализация файлового дерева</CENTER></H2>


<hr>
ИМЯ:  TREE
<hr>

<P>tree - вывод на экран структуры файлового дерева</P>


<ul><h2>НАЗНАЧЕНИЕ</h2></ul>

<P>	 Находит все файлы в файловом дереве и выводит на экран имена фай-
лов, показывая иерархическую структуру файлового дерева.</P>

<ul><a name=41></a><h2>ФОРМАТ ВЫЗОВА</h2></ul>

<PRE>tree [dir]</PRE>

<ul><a name=42></a><h2>ПРИМЕР ВЫЗОВА</h2></ul>

<PRE>$ tree $HOME</PRE>

	<P> Выводит структуру файлового дерева регистрационного каталога.</P>


<ul><a name=43></a><h2>ТЕКСТ ПРОГРАММЫ</h2></ul>
<PRE>
1  :
2  # @(#) tree v1.0  Visual display of a file tree Author: Russ Sage
2а				   вывод на экран структуры файлового дерева

4  if [ "$#" -gt 1 ]
5	then echo "tree: wrong arg count">&2
6		 echo "usage: tree [dir]"	>&2
7		 exit 2
8  fi
9  if [ "$#" -eq 1 ]
10 then if [ ! -d $1 ]
11   then echo "$0: $1 not a directory">&2
12		echo "usage: tree [dir]"	 >&2
13		exit 2
14		 fi
15 fi

17 find ${1:-.} -print | sort | sed -e "1p" -e "1d"		  \
18								  -e "s|[^/]*/|	  /|g"  \
19								  -e "s|[^ */|/|"		  \
20								  -e "s|/\([^/]*\)$|\1|"
</PRE>
	   <H3><b>ОПИСАНИЕ</b></H3>


				 <H4><P>ЗАЧЕМ НАМ НУЖЕН КОМАНДНЫЙ ФАЙЛ tree?</P></H4>


<P>	 Как мы  уже  отмечали,  вся система UNIX строится вокруг файловой
системы,  которая похожа на дерево.  Дерево,  с которым мы работаем  в
системе UNIX,  растет вверх ногами: корень находится вверху, а ветви и
листва растут вниз от корня.  Физическая структура реальных деревьев и
файловых деревьев, используемых в системе UNIX, очень сходна: один корень 
(начальная точка) и один ствол.  Как глубоко и как  далеко  могут
уходить ветви от основного ствола - не ограничивается ничем, кроме 
ограничений физического пространства. Аналогично, число листьев, которые
может иметь каждая ветвь, фактически не ограничено.</P>
<P>	 Многое в системе UNIX задумано для того,  чтобы приспособиться  к
дереву. Некоторые команды обходят дерево и сообщают о его компонентах,
но обычно их сообщения выдаются в форме,  не очень удобной для  чтения
человеком.  Это  делает  командные файлы весьма мощными инструментами.
Перевести необработанные, недружественные сообщения командных файлов в
удобный, информативный вид довольно легко.</P>
<P>	 Команда tree является комбинацией команд  системы  UNIX,  которые
представляют логическую файловую структуру в наглядной форме.  Эта команда 
полезна для получения глобальной картины файлов, их расположения
в иерархической структуре файлового дерева,  гнездовой структуры каталогов 
и подкаталогов.</P>

						   <H4><CENTER>ЧТО ДЕЛАЕТ tree?</CENTER></H4>


<P>	 Команда tree - это постпроцессор  для  команды  UNIX  find.  Find
просматривает сегмент файлового дерева и полные имена всех файлов, которые 
соответствуют заданному критерию. Команда tree использует утилиту  sed  
системы UNIX,  чтобы перевести выход команды find в наглядную
форму.  Входным параметром для команды tree является имя каталога,  которое  
может  быть  указано   в   любом   абсолютном   виде,   например,
/usr/spool/uucp,  или в относительном, например, ../../bin. Если никакого 
имени не указано, подразумевается ., что является текущим каталогом.
</P>
<P>	 Имя каталога является началом (или корнем) отображаемого  дерева.
Чтобы показать глубину дерева,  все файлы, подчиненные данному каталогу,  
отображаются с отступом.  Для  удобства  представления  гнездовой
структуры,  между  следующими  друг за другом ответвлениями печатается
косая черта (/).</P>
<P>	 Рассмотрим пример  структуры  каталога.  Пусть корневым каталогом
будет /tmp с двумя каталогами:  a и b. В каталоге a находится подкаталог aa,  
который содержит файл file1, а в каталоге b , соответственно,
подкаталог bb,  содержащий файл file2.  Команда find выдаст распечатку
такого вида:</P>
<PRE>
# find /tmp -print
/tmp
/tmp/a
/tmp/a/aa
/tmp/a/aa/file1
/tmp/b
/tmp/b/bb
/tmp/b/bb/file2
</PRE>
<P>	 Как видно из этого листинга,  файлы a и aa есть каталоги,  а файл
file1 находится внизу файлового дерева.  Сравните этот результат с результатом, 
который выдает команда tree, используя утилиту sed.</P>
<PRE>
# tree /tmp
/tmp
/	 a
/	 /	 aa
/	/	  /	  file1
/	b
/	/	 bb
/	/	  /	  file2
</PRE>
<P>	 Корневым каталогом  в  этом листинге является каталог /tmp.  Там,
где дерево переходит на более глубокий уровень, печатаются только символы  
косой черты.  Первый уровень - /tmp,  под этим уровнем находятся
файлы-каталоги a и b,  затем,  соответственно, их подкаталоги aa и bb.
Исходя из этого листинга,  мы делаем вывод, что на первом уровне каталога 
находятся два файла (и эти файлы в действительности являются  каталогами) 
и что два файла находятся в подчиненных каталогах.  Отметим,
что мы смогли идентифицировать aa и bb как каталоги только потому, что
в них присутствуют файлы file1 и file2.</P>
<P>	 Сравните этот листинг с выходом  "необработанной"  команды  find.
Выход команды tree исключает отвлекающее внимание повторение элементов
путей доступа при каждом переходе к более  низкому  уровню.  Благодаря
этому,  сразу же видно СУЩЕСТВЕННУЮ информацию. Вот что мы имеем в виду,  
когда говорим о создании более наглядного для человека интерфейса
с системой UNIX.</P>

<ul><a name=44></a><h2>ПРИМЕРЫ</h2></ul>

1.<PRE> $ tree</PRE>
<P>	 Использует подразумеваемый  каталог  (текущий  каталог,  
что равносильно команде "$ tree .") в качестве начала файлового дерева.</P>

2. <PRE>$ tree /</PRE>

<P>	 Печатает древовидный листинг для КАЖДОГО файла всей системы.  
Команда find при таком ее запуске начинает с корневого каталога и выдает
информацию о всех файлах системы.</P>

3. <PRE>$ tree $HOME/..</PRE>

<P>	 Показывает древовидный  формат  для  всех  других   пользователей
системы (предполагается, что все пользовательские каталоги находятся в
одном и том же каталоге, например /usr/*).</P>

<ul><a name=45></a><h2>ПОЯСНЕНИЯ</h2></ul>

<P>	 Первая строка  содержит  только знак двоеточия (:) - "нулевую команду". 
Это связано с тем, что все командные файлы, описываемые в этой
книге,  сделаны так, чтобы их можно было запускать в среде интерпретатора 
Bourne  shell.  Наш  комментарий  в  строке  2,  идентифицирующий
версию,  начинается со знака решетки (#).  Си-shell ищет этот знак как
первый знак командного файла.  Если он найден,  то предпринимается попытка 
выполнить данный командный файл. В противном случае Си-shell передает 
командный файл интерпретатору Bourne shell.  Вот почему  мы  не
хотим начинать первую строку со знака #.  Мы,  конечно, могли бы оставить 
первую строку чистой, но чистая строка невидима и может быть случайно  
удалена.  Соответственно  мы будем использовать чистые строки в
других случаях, чтобы выделить важные участки программы.</P>
<P>	 Строка 2 идентифицирует версию.  Символьная строка @(#) есть 
специальная последовательность в строке комментария, которая распознается
как строка "what" ("что").  Команда what в системе UNIX читает файл  и
печатает сообщение, которое следует за строкой "what". Чтобы идентифицировать 
версию данного командного файла, наберите</P>

<PRE># what tree</PRE>

<P>и  будет напечатано следующее сообщение:</P>

<PRE>tree:</PRE>
	 <CENTER><P>tree v1.0  Visual display of a file tree Author: Russ Sage</P></CENTER>

<P>	 Строки 4-7 проверяют, не слишком ли много аргументов было передано 
командной строке.  Это осуществляется путем исследования переменной
$#,  которая  представляет  собой счетчик числа позиционных параметров
командной строки.  Если насчитывается более одного параметра,  печатается  
соответствующее  сообщение  об  ошибке в стандартный файл ошибок
(stderr) и программа останавливается с плохим значением статуса.</P>
<P>	 Отметим, что  команда  echo  обычно  печатает в стандартный выход
(stdout).  Мы можем перенаправить stdout в другой файловый дескриптор,
указав его. В данном случае мы собираемся печатать в stderr. Синтаксис
переводится так:  "вывести эту строку и перенаправить  ее  в  файловый
дескриптор  (&)  стандартного  файла ошибок (2)".  Печать сообщений об
ошибках в stderr обеспечивает согласованное поведение командного файла
независимо от среды, в которой он запущен.</P>
<P>	 Отметим также,  что  коды  статуса  выхода в интерпретаторе shell
противоположны тем, которые используются при программировании на языке
Си. В Си истинное значение есть 1, ложное отлично от 1. При программировании 
на языке shell успешным статусом выхода (истиной) является  0,
а плохим статусом (ложью) ненулевое значение.</P>
<P>	 Вы, возможно,  удивитесь,  почему мы так беспокоимся о том, чтобы
вернуть ложный статус выхода,  если командный файл  собирается  просто
напечатать  сообщение об ошибке и прекратить работу.  Дело в том,  что
все инструментальные средства системы UNIX должны быть  спроектированы
так,  чтобы они могли быть связаны с другими командами и процессами, в
которые они могут быть встроены.  Возможно, что другой команде необходимо 
будет вызвать команду tree и проверить,  корректно ли она отработала. 
Хорошим стилем проектирования программных средств является прогнозирование 
и разрешение многих способов использования программы.</P>
<P>	 Строки 9-15 проверяют,  чтобы любые параметры,  передаваемые  
командной  строке,  были  действительно каталогами,  как указано в нашем
синтаксисе. Напомним, что в командной строке может быть помещен только
один каталог.  Если мы используем только один параметр и этот параметр
не является каталогом,  то мы печатаем сообщение об ошибке и  выходим.
Таким образом,  операторы проверки гарантируют,  что либо не используется 
ни один параметр,  либо единственный используемый параметр  является 
корректным каталогом.</P>
<P>	 Мы подошли к сердцу команды tree  -  это  строки  17-20.  Главным
здесь является команда find системы UNIX.  Каталог,  в котором ведется
поиск,  определяется при запуске команды.  Синтаксис ${1:-.}  является
формой параметрической подстановки и означает следующее:  если $1 (что
является первым позиционным  параметром)  установлен  (иными  словами,
если аргумент был передан командной строке и был ненулевым),  то нужно
использовать это значение. В противном случае следует использовать каталог .  
(текущий каталог).  Этот тип подстановки дает нам возможность
запускать команду tree без указания имени каталога (когда  после  tree
на командной строке ничего не следует),- то есть работать в режиме "по
умолчанию", что часто используется в различных файловых инструментах.</P>
<P>	 Команда find выводит на печать полное имя каждого файла,  который
ей встречается.  Поскольку не используется никакая  специальная  опция
для селекции файлов, печатаются все имена. После этого все полные имена 
файлов сортируются для  более  удобного  чтения.  Такая  сортировка
несколько увеличивает время работы команды, однако наглядность результата 
говорит о том, что это время было потрачено с пользой.</P>
<P>	 Далее, отсортированные  полные  имена  файлов передаются по 
программному каналу команде sed системы Unix.  Sed - это "потоковый 
редактор", очень гибкое средство, которое может быть использовано для 
идентификации и обработки различных образцов текста.  Опции -e  являются
операциями редактирования,  применяемыми к поступающим данным.  Первый
оператор просто сообщает команде  sed,  что  нужно  напечатать  первую
строку,  затем удалить строку 1.  Это делается для того, чтобы напечатать 
название корневого каталога,  который исследуется. Этой строке не
требуется никакой дальнейшей модификации,  так как корневой каталог не
имеет никаких дополнительных элементов путей  доступа,  которые  нужно
было  бы  трансформировать  в символы косой черты для показа отступов.
Удаление первой строки связано с тем,  что она не нужна  в  дальнейшей
работе.</P>
<P>	 Вторая операция редактирования является командой подстановки. Она
заменяет  каждый  символ,  отличный  от символа косой черты (вплоть до
первого символа /) на последовательность пробелов и затем один  символ
(/).  Это избавляет нас от печатания имен промежуточных каталогов впереди 
полного имени файла.  Буква g в конце этой строки  означает,  что
эта операция выполняется глобально,  то есть для всех считываемых символов. 
Итак, теперь строка состоит из начального элемента пути и одной
или  более  последовательностей пробелов,  разделенных символами косой
черты.  Символы обратной косой черты (\) в конце операций редактирования - это 
символы продолжения, которые сообщают команде sed, что нужно
продолжить работу со следующей строкой в текущем пакете  операций  редактирования.
</P>
<P>	 Третья операция редактирования (строка 19) также является  
командой подстановки и заменяет каждый символ, который не является пробелом
(вплоть до символа /) на "не символ" и один символ косой  черты.  Этот
оператор  удаляет  пробелы  из предыдущего результата редактирования и
смещает символ в самую левую позицию. Это создает гнездовую индикацию,
которую мы видели в предыдущем примере.</P>
<P>	 Последняя операция редактирования (в строке 20)  заменяет  символ
косой черты и все отличные от него символы (до конца строки) просто на
символы, отличные от /. Отметим, что это устраняет самый правый символ
/, который присутствует в листинге команды find. В результате остается
имя подчиненного файла, сдвинутое вправо.</P>
<P>	 Отметим синтаксис \1 команды sed - признак, относящийся к первому
(в данном случае единственному) регулярному выражению в скобках, кото-
рое ему предшествует.  В данном случае команде sed указано пройти сим-
волы, соответствующие регулярному выражению - символы, отличные от /.</P>

			  <a name=46></a><CENTER><H2>2.1.2. thead - печать начала каждого файла</H2></CENTER>


<hr>
ИМЯ: thead
<hr>

<P>thеаd	  Печатает заголовок (первые несколько строк) файлов.</P>

<ul><h2>НАЗНАЧЕНИЕ</h2></ul>

<P>	 Пройти файловое дерево и напечатать первые несколько строк каждого 
файла. Если не указан каталог, то thead действует как фильтр.</P>


<ul><a name=47></a><h2>ФОРМАТ ВЫЗОВА</h2></ul>

<PRE>thead [dir...]</PRE>

<ul><a name=48></a><h2>ПРИМЕР ВЫЗОВА</h2></ul>

<PRE>$ find $HOME/src -name "*.c" -print | sort | thead</PRE>

<P>	 Печатает заголовки  (первые  несколько  строк) всех моих исходных
файлов на языке Си.</P>

<ul><a name=49></a><h2>ТЕКСТ ПРОГРАММЫ</h2></ul>
<PRE>
1 :
2 #  @(#)  thead v1.0 Prints head of files in tree Author: Russ Sage
2а					Печатает заголовки файлов в дереве

4 if [ "`echo $1|cut -c1`" = "-" ]
5  then  echo "$0: arg error"
6		echo "usage: $0 [dir ...]"
7		exit 1
8   fi

10 case $# in
11 0)  while read FILE
12	 do
13		 if file $FILE | fgrep text >/dev/null 2>&1
14		   then  echo "\n:::::::::::::::::::::"
15				 echo " $FILE"
16				 echo "\n:::::::::::::::::::::"
17				 head -15 $FILE
18		 fi
19	   done;;
20  *)  for NAME in $*
21	  do
22			 find $NAME -type f -print | sort | wile read FILE
23			 do
24					 if file $FILE | fgrep text >/dev/null 2>&1
25					   then  echo "\n:::::::::::::::::::::"
26							 echo " $FILE"
27							 echo "\n:::::::::::::::::::::"
28							 head -15 $FILE
29					 fi
30			 done
31	  done;;
32  esac
</PRE>
<ul><a name=50></a><h2>ПЕРЕМЕННЫЕ СРЕДЫ ВЫПОЛНЕНИЯ</h2></ul>
<BL>
 <LI></LI>
 <LI>FILE	  Содержит имя каждого файла</LI>
 <LI>NAME	  Имя каталога, заданное в командной строке</LI>
</BL>

	   <H3><b>ОПИСАНИЕ</b></H3>


				  <CENTER><H3>ЗАЧЕМ НУЖЕН КОМАНДНЫЙ ФАЙЛ thead?</H3></CENTER>

<P>	 Как уже объяснялось ранее в этой  главе,  иерархическая  файловая
система является очень значительной частью системы UNIX. Однако, только 
несколько команд в UNIX имеют дело  непосредственно  с  рекурсивным
поиском  файлов.  Единственный  способ расширить возможности системы -
создать новые рекурсивные утилиты, работающие с файлами. В данном слу-
чае мы соединим нашу стратегию поиска по дереву с командой head системы 
UNIX для упрощения идентификации содержимого всех файлов в выделен-
ном сегменте файлового дерева.</P>
<P>	 Иногда у нас, возможно, будет возникать желание просмотреть файлы
в более чем одном каталоге. В больших проектах разработки программного
обеспечения файлы обычно создаются в нескольких иерархических  каталогах. 
Thead может работать со множеством путей доступа и выводить заголовки 
(несколько первых строк файлов) в виде непрерывного потока.</P>

						  <CENTER><H3>ЧТО ДЕЛАЕТ thead?</H3></CENTER>

<P>	Thead - это препроцессорная команда к команде head системы  UNIX.
Команда head очень примитивна, но, добавляя к ней управляющую структуру  
и  логику,  мы  можем  создать  очень  полезное   инструментальное
средство, которого нет в стандартной среде UNIX.</P>
<P>	 Например, мы захотели просмотреть заголовки всех текстовых файлов
в  нашем  регистрационном  каталоге.  Если у нас имеется большое число
подкаталогов,  нам необходимо все их пройти и просмотреть  все  файлы,
содержащиеся в них. Мы можем сделать это с помощью команды</P>

<PRE>$ thead $HOME</PRE>

<P>	 Если мы  хотим  просмотреть  только  исходные  файлы  на языке Си
(*.c),  то представленный выше синтаксис не годится для этого.  Он  не
обладает  достаточной  гибкостью.  Нам необходимо иметь способ указать
(или квалифицировать) файлы в $HOME перед тем,  как просматривать  их.
Так как команда thead может воспринимать полные имена файлов, мы можем
использовать следующую команду:</P>

<PRE>$ find $HOME -name "*.c" -print | sort | thead</PRE>

<P>	 Команда find генерирует список файлов с  расширением  C,  который
сортируется и подается по каналу на вход команде thead.</P>
<P>	 Как видно из представленных двух примеров,  весьма  полезной  для
командного  файла является возможность получать входные данные либо из
аргументов командной строки (как в первом примере),  либо по программному  
каналу  (как во втором примере).  Способность использовать программный 
канал позволяет вам применять какие-либо другие команды системы 
UNIX,  которые могут отбирать входные данные для вашего командного
файла. Команда с такой двойной возможностью называется ФИЛЬТРОМ. Среди
стандартных команд системы UNIX вы найдете лишь несколько команд-фильтров, 
таких как wc, awk, sort.</P>
<P>	 Эти два способа поступления входных данных в программы делают 
интерфейс с командными файлами очень гибким. Мы можем подстраивать 
програмные  средства  под  наши нужды,  а не подстраивать наши желания под
имеющееся программное обеспечение.</P>
<P>	 Аргументами для  команды thead являются каталоги.  Никаких опций,
начинающихся со знака "-" нет, только каталог или полные имена файлов.
Команда thead знает из синтаксиса,  какой способ запуска команды будет
использоваться.  Если  командная  строка  содержит  имя  файла,  thead
просмотрит  все позиционные параметры.  Если никакие имена не указаны,
thead читает стандартный ввод (stdin) и останавливается,  когда встречает 
EOF. (Такое бывает в случае, когда команда thead получает входные
из программного канала.)</P>
<P>	 Для каждого файла, с которым работает thead, выполняется контроль
- текстовый ли это файл. Применение команды head к исполняемым модулям
приводит к выводу "таинственных" символов на экран и иногда может вызвать 
дамп оперативной памяти.</P>

<ul><a name=51></a><h2>ПРИМЕРЫ</h2></ul>

1. <PRE>$ thead /etc</PRE>

<P>	 Печатает данные из каждого текстового файла, находящегося в 
каталоге /etc.  Очень полезная команда,  так как большинство файлов в /etc
являются исполняемыми модулями. Удобно иметь возможность быстро изолировать 
текстовые файлы.</P>

2.<PRE> $ thead /usr/include</PRE>

<P>	 Просматривает все подключаемые файлы (*.h), даже в системном подкаталоге sys.</P>

3. <PRE>$ find $HOME -ctime 0 -print | thead</PRE>

<P>	 Ищет все файлы в вашем регистрационном каталоге, которые были 
изменены  в  течении последних 24 часов.  Для каждого файла проверяется,
текстовый ли он. Если файл текстовый, то он печатается.</P>

<ul><a name=52></a><h2>ПОЯСНЕНИЯ</h2></ul>

<P>	 Строки 4-8 выполняют проверку ошибок.  Так как команда  thead  не
имеет никаких опций, любые позиционные параметры, которые начинаются с
дефиса (-) являются неверными.  Если первым символом первого позиционного  
параметра  оказывается  "-",  то  печатается сообщение "argument
error" (ошибка аргумента) вместе с сообщением о способе запуска и  команда 
thead прекращает работу.</P>
<P>	 Некоторые приемы  программирования  для   интерпретатора   shell,
используемые в этих строках,  довольно часто встречаются в данной книге, 
поэтому имеет смысл остановиться на них подробнее.</P>
<P>	 Проанализируем строку 4,  работающую изнутри наружу. Команда echo
выдает содержимое $1 (текущий параметр командной строки),  которое 
передается по программному каналу команде cut.  Команда cut используется
для того,  чтобы выделить определенные символы или группы символов  из
строки.  В  данном  случае опция -c1 используется для получения только
первого символа.</P>

						 <CENTER><H3>КОМАНДА cut ДЛЯ BSD</H3></CENTER>


<P>	 В системе BSD нет команды cut, но следующий командный файл все же
"вырезает" первое непустое поле в текущем аргументе.</P>
<P>	 Предположим, мы используем команду для  генерации  целого  набора
строк. В данном случае это команда who:</P>
<PRE>
for NAME in 'who | sed "s/^\([^ ]*\).*/\1/"'
do
done
</PRE>
<P>	 Для каждой  обнаруженной  строки  (аргумента)  команда sed должна
подставить вторую строку символов вместо первой строки.  Первая строка
- это строка, которая вырезается. Мы ищем от начала строки (^) символ,
отличный от пробела ([^ ]),  за которым следует любое  число  непустых
символов  (*).  Эта операция прерывается по достижении пробела.  Набор
непустых символов ограничивается обратными косыми  чертами  \(  и  \).
Впоследствии ссылка на этот набор дается в виде \1. Символы .* означают,  
что после того, как найден пробел, необходимо считать подходящими
все символы до конца строки. Мы находимся фактически сразу после того,
что заключено в пару символов \( и \).  Группируя первый набор  символов, 
отличных от пробела, мы получаем то, что является результатом работы 
команды "cut -f1".</P>
<P>	 В этом  месте мы подходим к знакам ударения (`),  окаймляющим все
выражение. Они берут результат работы всех команд, заключенных в знаки
ударения  и  передают на следующую охватывающую структуру в наших вложенных 
выражениях. Этот следующий уровень окаймления указан кавычками.
Кавычки  превращают  символ в строку,  чтобы его можно было сравнить с
символом "-".  Следующий слой - квадратные скобки, указывающие условие
для оператора if. Это приводит к тому, что генерируется нулевое (истина) 
или ненулевое (ложь) условие,  которое управляет тем, будет ли выполнена 
часть then оператора if-then.</P>
<P>	 Мы не собираемся подробно анализировать много строк данного командного 
	 файла, но мы хотим показать вам, как читать выражение или всю
строку текста программы так, чтобы это имело смысл.</P>
<P>	 Остальная часть командного файла представляет собой один огромный
оператор выбора (case).  Аргументом, используемым для ветвления, является 
число позиционных параметров в командной строке. Если позиционных
параметров нет,  то в строках 11-19 активируется цикл while.  Заметим,
что цикл while выполняет оператор чтения, но не указывает, откуда должен 
быть взят его вход. Это связано с тем, что входом по умолчанию является 
стандартный ввод (stdin).  Для каждого имени файла, которое читается 
из стандартного ввода,  запускается команда file системы  UNIX.
Выход  команды file передается по программному каналу команде fgrep (а
не grep, что увеличивает скорость), чтобы посмотреть, является ли файл
текстовым.</P>
<P>	 Фактический выход команды fgrep перенаправляется на нулевое  
устройство (в бесконечную область памяти), поскольку он нам не нужен.</P>
<P>	 Нас интересует лишь код возврата после выполнения всего  конвейе-
ра. Если команды file и fgrep отработали успешно, кодом возврата является 
ноль.  Это истинное значение,  поэтому выполняется участок  цикла
после  then  (строки  14-17).  Если файл не существует или не является
текстовым, то код возврата ненулевой, и условный оператор завершается.
Это  приводит нас в конец цикла,  выполняется следующая итерация цикла
while и мы рассматриваем следующий аргумент из стандартного ввода.</P>
<P>	 Теперь рассмотрим обработку,  выполняемую по then (строки 14-17).
Для каждого файла, который является текстовым, печатается строка двоеточий 
(:) до и после имени файла, а команда head системы UNIX печатает
первые 15 строк.  Такой сценарий продолжается, пока не закончатся данные 
в стандартном вводе.</P>
<P>	 Рассмотрим другую альтернативу, покрываемую данным оператором 
выбора.  Она обрабатывает ситуацию,  когда имеется несколько позиционных
параметров (что указано символом * в операторе case).  Цикл for 
пробегает все параметры (строка 20). Звездочка (*) в операторе case 
означает, что подходит любое значение, которое не подошло ранее. Это 
улавливающая  (catchall)  опция.  Цикл for использует аргумент $* в качестве
своего входа.  Он представляет значения всех  позиционных  параметров,
что является фактически всей командной строкой, исключая имя утилиты.</P>
<P>	 Команда find используется для поиска всех нормальных файлов в 
каталоге.  "Нормальные" файлы не означает "только текстовые файлы", поэтому 
мы проверим это позже.  Выход команды find передается  по  каналу
команде  sort,  чтобы  сделать  его  более наглядным.  Отсортированный
список передается по каналу в цикл while, который помещает имя файла в
переменную FILE (строка 27).  Проверяется, текстовый ли файл, затем он
печатается командой head.</P>
<P>	 Если мы  сравним строки 13-18 и строки 24-29,  то мы увидим,  что
это один и тот же код. В большинстве языков программирования это означало  
бы,  что  мы должны оформить эти строки как процедуру и вызывать
ее,  когда нужно.  Язык программирования интерпретатора shell,  хотя и
довольно  мощный,  не  имеет  хорошего  способа  реализации  процедур.
Последний интерпретатор shell в System V имеет функции, которые позволяют 
решить эти проблемы.</P>
<P>	 Отметим, что внутренний цикл while повторяется на  каждом  файле,
который существует в определенном каталоге,  а внешний цикл for проходит 
от каталога к каталогу.</P>

<ul><a name=53></a><h2>ВОЗМОЖНЫЕ МОДИФИКАЦИИ</h2></ul>

<P>	 Для увеличения гибкости хорошо бы добавить опции,  чтобы вы могли
переходить  на команду find непосредственно из thead.  Полезными аргументами 
были бы -name для изолирования образцов имен файлов  и  -ctime
для обработки изменений, связанных со временем.</P>
<P>	 Еще одной привлекательной особенностью было бы  добавление  опции
грамматического разбора (основанной на -) и опции -n, указывающей, что
из команды head должно быть напечатано n строк.</P>

<ul><a name=54></a><h2>ВОЗМОЖНЫЕ ИССЛЕДОВАНИЯ</h2></ul>

	<P> В чем отличие между двумя следующими операторами?</P>

<PRE>$ find $HOME -name "*.c" -print | thead</PRE>

<P>и</P>

<PRE>$ find $HOME -name "*.c" -exec head {} \;</PRE>

<P>	 Они выглядят очень похоже,  и они действительно похожи. 
Они обрабатывают  одни и те же файлы и печатают одни и те же данные из каждого
файла.  Основное отличие в том,  что строка, которая использует thead,
печатает хорошее оформление вокруг имени файла,  а чистая команда find
печатает непрерывный поток текста так,  что очень  трудно  определить,
какой файл вы просматриваете.</P>

		 <a name=55></a><CENTER><H2>2.1.3. tgrep - поиск строк в дереве файловой системы</H2></CENTER>


<hr>
ИМЯ: tgrep
<hr>

<P>tgrep		Поиск строки по шаблону в дереве файлов</P>

<ul><h2>НАЗНАЧЕНИЕ</h2></ul>

<P>	 Обходит файловое дерево и ищет в каждом файле  указанную  строку.
Если не указан никакой каталог, tgrep действует как фильтр.</P>

<ul><a name=56></a><h2>ФОРМАТ ВЫЗОВА</h2></ul>

	 <PRE>tgrep [-c|-h] string [file ...]</PRE>

<ul><a name=57></a><h2>ПРИМЕР ВЫЗОВА</h2></ul>

	<PRE> # tgrep "profanity" /</PRE>

<P>	 Поиск слова  "profanity" по всей системе (суперпользователь снова
на тропе войны!)</P>

<ul><a name=58></a><h2>ТЕКСТ ПРОГРАММЫ</h2></ul>
<PRE>
1   :
2   # @(#) tgrep v1.0  Search for string in tree Author: Russ Sage
2а					 Поиск строки в дереве

4   OPT=""

6   for ARG in $@
7   do
8		   if [ "`echo $ARG|cut -c1`" = "-" ]
9			 then case $ARG in
10				 -c)  OPT="-name \"*.c\""
11					  shift;;
12				 -h)  OPT="-name \"*.h\""
13					  shift;;
14				 *)   echo "$O: incorrect argument"			 >&2
15					  echo "usage: $O [-c|-h] string [file ...] >&2
16					  exit 1;;
17				 esac
18		   fi
19  done

21  case $# in
22  0)  echo "$O: argument error"				 >&2
23	  echo "usage: $O [-c|-h] string [dir ...]" >&2
24	  exit 2
25	  ;;
26  1)  while read FILE
27	  do
28			  grep -y "$1" $FILE /dev/nul
29	  done
30	  ;;
31  *)  STRING=$1; shift
32	  eval find "$@" -type f $OPT -print | sort | while read FILE
33	  do
34			  grep -y "$STRING" $FILE /dev/null
35	  done
36	  ;;
37  esac
</PRE>
<ul><a name=59></a><h2>ПЕРЕМЕННЫЕ СРЕДЫ ВЫПОЛНЕНИЯ</h2></ul>
<BL>
 <LI>FILE	  Содержит имя каждого файла</LI>
 <LI>OPT	   Содержит специальные опции команды find</LI>
 <LI>STRING	Временная переменная, в которой содержится строка</LI>
</BL>		  поиска

	   <H3><b>ОПИСАНИЕ</b></H3>


				<CENTER><H3>ЗАЧЕМ НАМ НУЖЕН КОМАНДНЫЙ ФАЙЛ tgrep?</H3></CENTER>


<P>	 Как мы могли видеть на примере двух предыдущих утилит,  рекурсивный 
просмотр файлов очень полезен.  Он сохраняет время, поскольку позволяет 
избежать поиска файлов вручную, а также создает средства, которые  могут 
быть использованы в более мощных утилитах.  Чем больше имеется созданных 
нами средств, тем больше новых средств мы можем построить  с  их  помощью.  
Единственная проблема заключается в том,  что вы
должны  позаботиться  об  их  взаимозависимости  (каким  утилитам  или
средствам требуются другие утилиты или средства и кто на кого влияет).</P>
<P>	 Еще одна область,  где UNIX не имеет "родной" рекурсивной команды
- это обработка строк. Семейство команд типа grep очень велико, но все
они работают только по одному фиксированному маршрутному имени  файла.
Нам  необходим  препроцессор для команды grep.  Правда,  мы можем дать
запрос на все файлы во всей системе или какой-либо ее части по  нашему
выбору.  Если мы попытаемся сделать это вручную,  то это означает, что
мы должны много раз нажимать на клавиши,  что может  привести  к  синтаксической  
ошибке.  Вы также должны точно помнить,  как вы создавали
командную строку,  если вы в следующий раз захотите выполнить такую же
задачу.  Зачем  выполнять грязную работу?  Для этого существует компьютер.
</P>
<P>	 Создавая программу автоматического обхода дерева файлов, мы 
освобождаемся для того,  чтобы направить нашу энергию на более важные вещи
вместо того, чтобы выпутываться из ситуации в случае какого-либо слишком 
специфичного  синтаксиса.  Один  раз  создав  достаточно  мощные
средства доступа к файлам,  мы можем посвятить  наше  время  написанию
программ, обрабатывающих файлы данных для решения каких-либо задач.</P>

						  <H3><CENTER>ЧТО ДЕЛАЕТ tgrep?</CENTER></H3>


<P>	 Основным предназначением tgrep является обеспечение большей  
гибкости и легкости использования возможностей команды grep. Ее синтаксис
точно такой же,  как и у grep, за исключением допустимых типов файлов.
В команде grep UNIX в качестве аргумента может указываться практически
любой файл, но указание текстового файла имеет наибольший смысл. В команде 
tgrep также могут использоваться текстовые файлы,  но наибольший
смысл имеет указание каталогов, поскольку мы ищем имена файлов. Команда 
find работала бы не очень хорошо, если бы пыталась извлечь множество 
имен файлов из текстового файла.  В командной строке  может  указываться  
множество  имен каталогов,  поскольку все они используются как
начальное место поиска оператора find.</P>
<P>	 По умолчанию  tgrep  находит все обычные файлы.  В этой программе
нет никакой проверки на то,  текстовый файл или нет,  поскольку мы  не
пытаемся  напечатать все на экран.  Поэтому мы ищем строки символов во
всех файлах, начиная от архивных и заканчивая исполняемыми.</P>
<P>	 Если вы хотите выбрать типы файлов,  используйте две опции,  -c и
-h. Опция -c заставляет команду UNIX find искать только файлы с именами 
вида *.c.  Аналогично, опция -h соответствует файлам *.h. Эти опции
могут быть полезны для управления программами на языке Си,  с которыми
мы  более детально познакомимся в главе 4.  Эти опции не самое важное,
но они показывают, как легко добавить новые опции в программу.</P>
	<P> Если при вызове была указана какая-то иная опция,  кроме упомянутых, 
	 выводится сообщение об ошибке и программа останавливается. Подобно 
	 thead, tgrep является фильтром.</P>

<ul><a name=60></a><h2>ПРИМЕРЫ</h2></ul>

1. <PRE> $ tgrep unix $HOME</PRE>

<P>	 Поиск любого вхождения слова unix во всех файлах моего 
регистрационного каталога.</P>

2. <PRE> $ tgrep -c "^sleep()$" $HOME/src</PRE>

<P>	 Поиск выражения (начало строки,  символьная строка, конец строки)
во  всех  исходных  файлах  на  языке  Си в регистрационном каталоге с
исходными текстами (опция -c).</P>

3. <PRE> # find /usr/src -name "*.c" -print | tgrep "ioctl"</PRE>

<P>	 Поиск всех вызовов ioctl в исходных Си-файлах, начиная с каталога
/usr/src.  (Обратите внимание,  что я являюсь суперпользователем.  Это
видно из того, что я занимаюсь поиском в ограниченной части системы, а
именно в исходных дистрибутивах,  а также из того, что в качестве символа 
приглашения используется символ "#".)</P>

4. <PRE> $ tgrep "| more" `find . -type f -print`</PRE>

<P>	 Поиск символа вертикальной черты (|), после которого следует слово 
more,  в списке имен файлов, генерируемом оператором find. Find печатает 
имена всех файлов текущего каталога и всех подкаталогов,  которые являются 
обычными файлами.</P>

5.  <PRE>$ tgrep trap /bin /usr/bin /etc</PRE>

<P>	 Поиск команды  прерывания (trap) во всех командных файлах 
интерпретатора shell, которые имеются в трех каталогах.</P>

<ul><a name=61></a><h2>ПОЯСНЕНИЯ</h2></ul>

<P>	 В строке 4 переменная OPT,  в которой хранятся необязательные 
команды оператора find, инициализируется в нулевое значение.</P>
<P>	 Строки 6-18 выполняют проверку на  наличие  ошибок.  Проверяется,
является ли первым символом каждого позиционного параметра символ "-".
Если проверка успешна,  то проверяется на корректность  сам  аргумент.
Возможными опциями являются -c и -h. Если указано что-либо другое, 
выводится сообщение об ошибке и программа завершается.  Обратите  
внимание, что с помощью команды shift допустимые опции удаляются из 
командной строки. Это сделано для того, чтобы впоследствии выражение $@ 
могло  быть  использовано для получения только аргументов строки поиска и
маршрута. Выражение $@ является другой формой выражения $ *, в которой
оно распространяется на все позиционные параметры.  Однако в последующем 
тексте мы увидим одно большое отличие между ними.</P>
<P>	 Еще один  трюк  сделан  при  присвоении значения переменной OPT в
строке 10.  Этой переменной нам необходимо присвоить значение, которое
включает  в  себя  пару кавычек,  поскольку кавычки должны быть частью
строки поиска,  которая в конце концов используется  оператором  find.
Однако обнаружение второй кавычки обычно ЗАВЕРШАЕТ оператор присваивания, 
а мы этого в данном случае не хотим. Выходом из ситуации является
использование символа \, который отменяет специальное значение следующего 
за ним символа. В данном случае специальное значение было бы концом 
строки присваивания.</P>
<P>	 Таким образом,  кавычка перед звездочкой (*) в строке 10 
рассматривается как часть значения переменной OPT,  вместо того, чтобы 
завершать операцию присваивания. Следующая встреченная кавычка также должна
быть  сохранена  в  значении переменной,  чтобы указать конец хранимой
здесь строки  поиска,  поэтому  она  также  экранирована  символом  \.
Последняя кавычка в этой строке не экранирована обратной косой чертой.
Эта кавычка соответствует своей обычной функции в смысле интерпретатора 
shell и завершает оператор присваивания.</P>
<P>	 Вам нужно поэкспериментировать с  использованием  кавычек,  чтобы
понять его.  Когда какой-то командный файл не желает работать правильно, 
но ошибок не видно, проверьте правильность использования кавычек.</P>
<P>	 Оставшаяся часть  командного  файла  -  это оператор case (строки
21-37),  который имеет дело с числом аргументов командной строки. Если
нет никаких аргументов, печатается сообщение об ошибке и мы выходим из
программы. Мы ведь не можем делать никакого поиска командой grep, если
мы даже не знаем, какую строку нужно искать.</P>
<P>	 Если указан только один аргумент,  то это должна быть строка  
поиска. Это также означает, что в командной строке не указаны имена 
файлов и поэтому мы читаем их со стандартного устройства ввода,  т.е. 
командный файл действует как фильтр. Цикл while (строки 26-29) читает со
стандартного ввода имя каждого файла для поиска в  нем  командой  grep
нужной строки. Опция -y команды grep означает нечувствительность к 
регистру символов при поиске.  Использование этой опции дает нам хорошие
шансы попасть на нужную строку.</P>
<P>	 Другой интересной особенностью этого цикла являются  две  команды
grep  в строках 28 и 34.  Мы ищем нужную строку не только в файле,  но
также в каталоге /dev/null.  Это кажется странным? Да. Проблема заключается 
в самой команде grep. Grep знает, когда в командной строке указано более 
одного файла. Если имеется более одного файла, то имя файла
выводится  на  экран  до вывода найденной строки.  Если же в командной
строке указан только один файл,  то его имя  не  выводится,  поскольку
считается,  что пользователь должен помнить это имя. Это создает проблемы 
при написании командных файлов,  когда вы имеете много имен  файлов, 
но они обрабатываются по одному. Мы обрабатываем файлы по одному,
поскольку если бы мы использовали указание группового имени  файлов  с
помощью метасимволов,  то могло бы оказаться слишком много имен файлов
в одной командной строке для команды grep.  Поэтому вместо использования 
некоторой замысловатой схемы для сокращения количества аргументов,
мы избегаем этого путем обработки в цикле каждого  файла  по  очереди.
Поскольку на самом деле мы ищем большое количество разных строк, то мы
хотим видеть имена файлов, в которых они были найдены.</P>
<P>	 При указании  в  командной  строке grep каталога /dev/null,  grep
всегда печатает имя файла до вывода найденной строки  в  нашем  цикле,
поскольку теперь имеется два имени файла в качестве аргументов. Конечно, 
в /dev/null ничего нельзя найти, поскольку он пуст по определению.</P>
<P>	 Последний образец  в операторе case (строки 31-36) - это ловушка.
Он соответствует любому количеству позиционных параметров сверх  одного, 
что  позволяет  нам  иметь переменное число каталогов в командной строке.
</P>
<P>	 Даже хотя  мы можем указать несколько каталогов в командной 
строке, первым аргументом по-прежнему является строка поиска. Не так легко
сказать:  "начиная со второго параметра",  поэтому мы сохраняем строку
поиска (в переменной STRING - Прим.  перев.)  и  убираем  ее  командой
shift.  Теперь  мы  можем  получить доступ к остальной части командной
строки с помощью выражения $@.</P>
<P>	 Давайте посмотрим, что происходит, когда мы ссылаемся на переменную 
$OPT для получения опций команды find.  Допустим, мы вызвали tgrep
с опцией -c.  Когда мы присваиваем значение переменной OPT,  мы ставим
строку c в виде "*.c" внутри двойных кавычек,  поскольку мы не желаем,
чтобы  shell  раскрывал  эту строку (т.е.  трактовал ее как имена всех
файлов,  соответствующих данному образцу) именно сейчас.  Теперь,  как
только к переменной $OPT есть обращение в команде find,  значением OPT
является *.c,  что означает поиск  файлов,  символьные  имена  которых
соответствуют  *.c.  Для  отмены  символьной  интерпретации  мы должны
использовать команду eval. Перед выполнением команды find команда eval
заставляет  shell повторно анализировать команду в отношении распространения 
значения переменной. На этом проходе выражение "*.c" превращается в *.c,  
что разрешает генерацию имен файлов таким образом,  чтобы
были просмотрены все эти файлы.</P>
<P>	 Указывая $@  в  команде find,  мы можем производить поиск во всех
каталогах сразу.  Таким образом,  нам нужно вызвать find  только  один
раз, что позволяет сберечь время центрального процессора. Одной из интересных 
проблем,  возникших при разработке данного  командного  файла
было то,  что выражение вида $* не работало.  В команде find возникала
ошибка сохранения. Даже запуск shell'а в режиме -x (установленный флаг
разрешения выполнения) не разрешил проблему. Изменение синтаксиса, кажется,  
помогло разобраться с ней. Оказывается, причина в том, что выражение
  $*  раскрывается  в "$1 $2 ...",  в то время как выражение $@
превращается в "$1" "$2" (т.е. в отдельные аргументы). Происходило то,
что  выражение  $*  передавало имена нескольких каталогов команде find
как одну строку.  Команда find не могла обнаружить файл  такого  типа,
поэтому прекращала выполнение. Когда же вместо этого было использовано
выражение $@, команда find получила несколько независимых строк с именами.  
Это вполне подошло команде find, и все заработало. Такие мелкие
детали всегда требуют много времени для изучения!</P>

<ul><a name=62></a><h2>ВОЗМОЖНЫЕ ИССЛЕДОВАНИЯ</h2></ul>

	 <H3><CENTER>В чем разница между двумя следующими операторами?</CENTER></H3>

<PRE>grep "$1" `find "$2" -print`</PRE>

и
<PRE>
find "$2" -print | while read F
do
		grep "$1" $F
done
</PRE>
<P>	 Они кажутся  совершенно похожими,  но существует различие в 
главном.  Первый оператор - это один вызов команды grep. Аргументами 
являются множество имен файлов, поставляемых командой find. Если find 
сгенерирует слишком много имен файлов,  то выполнение команды завершится.
О том,  что сгенерировано слишком много имен файлов,  никакого предупреждения 
не выдается,  но большое количество файлов фатально для grep.
Поэтому мы должны рассматривать такой синтаксис как недопустимый в общем случае.
</P>
<P>	 Второй оператор - это цикл. Он работает медленнее и вызывает grep
много раз,  что забирает много времени центрального процессора. Однако
положительным моментом является то, что цикл получает данные по конвейеру, 
который фактически не имеет ограничений на число данных, которое
он может иметь.  Наша программа никогда неожиданно не прекратит выполнение.
</P>

  <a name=63></a><CENTER><H2>2.1.4. paths  -  нахождение пути доступа к исполняемым файлам,  со
				   специальными опциями</H2></CENTER>


<hr>
ИМЯ:  paths
<hr>

<P>paths   Определитель маршрутных имен файлов со специальными
		опциями</P>

<ul><h2>НАЗНАЧЕНИЕ</h2></ul>

<P>	 Выводит на экран каталог,  в котором располагается  файл,  выдает
имя файла в длинном формате или ищет файлы с установленным битом 
пользовательского идентификатора (setuid bit files) в каталогах по указанному маршруту.
</P>

<ul><a name=64></a><h2>ФОРМАТ ВЫЗОВА</h2></ul>
<PRE>
	 <PRE>paths [-l] [-s] file [file ...]</PRE>

<ul><a name=65></a><h2>ПРИМЕР ВЫЗОВА</h2></ul>

	<PRE> $ paths -l ed ex vi</PRE>

<P>	 Выдает в длинном формате имена файлов, которые являются исполняемыми 
модулями редакторов ed, ex и vi</P>

<ul><a name=66></a><h2>ТЕКСТ ПРОГРАММЫ</h2></ul>

1   :
2   # @(#) paths v1.0 Path locator with special options Author: Russ Sage
2а	Определитель местонахождения файлов со специальными опциями

4   FORMAT="path"

6   for ARG in $@
7   do
8		   if [ '`echo $ARG | cut -c1`" = "-" ]
9			 then case $ARG in
10				 -l)  FORMAT="ls"
11					  shift;;
12				 -s)  FORMAT="set"
13					  set "1";;
14				 *)   echo $0: arg error"						>&2
15					  echo "usage: $0 [-l] [-s] file [file ...]" >&2
16					  exit 1;;
17				 esac
18		  fi
19  done

21  IFS="${IFS}:"

23  for FILE in $@
24  do
25		   for DIR in $PATH
26		   do
27				   case $FORMAT in
28				   path)  if [ -f $DIR/$FILE ]
29							 then echo $DIR/$FILE
30						  fi;;
31				   ls)	if [ -f $DIR/$FILE ]
32							then ls -l $DIR/$FILE
33						  fi;;
34				   set)   echo "\n:::::::::::::::::::"
35						  echo "$DIR"
36						  echo "::::::::::::::::::::"
37						  ls -al $DIR | grep "^[^ ]*s[^ ]*";;
38				   esac
39			done
40  done
</PRE>
<ul><a name=67></a><h2>ПЕРЕМЕННЫЕ СРЕДЫ ВЫПОЛНЕНИЯ</h2></ul>
<BL>
 <LI>ARG	   Содержит каждый аргумент командной строки</LI>
 <LI>DIR	   Элемент с именем каталога в переменной PATH</LI>
 <LI>FILE	  Содержит имя каждого файла в командной строке</LI>
 <LI>FORMAT	Тип требуемого формата выходных данных</LI>
 <LI>IFS	   Переменная shell'а, разделитель полей</LI>
 <LI>PATH	  Переменная shell'а, пути к каталогам исполняемых модулей</LI>
</BL>
	   <H3><b>ОПИСАНИЕ</b></H3>


				<CENTER><H3>ЗАЧЕМ НАМ НУЖЕН КОМАНДНЫЙ ФАЙЛ paths?</H3></CENTER>


<P>	  В нашей среде интерпретатора shell переменная с именем PATH 
содержит имена каталогов,  отделенные друг от друга символами  двоеточия
(:).  Каждый раз,  когда вы вводите команду после приглашения shell'а,
интерпретатор shell, начиная с первого каталога, указанного в переменной 
PATH,  смотрит, находится ли введенная вами команда в этом каталоге. 
Если да, то команда выполняется. Если нет, то shell идет в следующий 
каталог,  указываемый переменной PATH,  и так далее, пока не будут
проверены все каталоги.  Если команда все же не будет найдена,  то  вы
получите следующее сообщение об ошибке:</P>
<hr>
<PRE>
|
|	$ whatchamacallit
|	sh: whatchamacallit: not found
|
|
</PRE>
<P>	 Такой поиск команды осуществляется автоматически, но сама система 
не
собщает вам,  ГДЕ размещена команда. Нам необходима утилита, кото
рая  ищет  и  выводит на экран маршрут к указанному файлу.  Имея такую
утилиту,  вы можете использовать кратчайшие пути получения  того,  что
вам нужно,  и выполнять множество различных трюков. Вы можете комбинировать 
подобную команду с другими командами для создания гораздо более
мощных  средств.  С  маршрутом можно также комбинировать команды more,
ls,  file и cd системы UNIX.  Возможно, вы обнаружите и другие команды
по мере экспериментирования</p>
<P>	 Команда, несколько похожая на ту,  которую  мы  ищем,  существует
где-то в мире системы UNIX Systev V.  Например, в системе AT&T это команда 
where. В системе UNIX Berkeley это команда which (текст на языке
Си-shell'а) или whereis (исполняемая программа). Whereis дает дополнительную 
информацию,  такую как место  размещения  файлов  с  исходными
текстами (в каталоге /usr/src).  Увидев, как мы создаем нашу собственную 
команду поиска маршрута, вы можете модифицировать ее для обеспечения  
работы с особенностями некоторых других команд и приспособить такие 
вещи к вашим нуждам.</P>
<P>	 Прежде чем мы удовлетворим свои прихоти,  давайте бегло глянем на
команду path, более простую, чем paths. Вся программа выглядит примерно так:
</P>
<PRE>
IFS="${IFS}:"
for FILE in $@
do
		for DIR in $PATH
		do
			if [ -f $DIR/$FILE ]
			  then  echo $DIR/$FILE
			fi
		done
done
</PRE>
<P>	 Основная идея очень проста.  Сперва мы добавляем двоеточие (:)  к
разделителю  полей.  Нам  необходимо  сохранить значения,  принятые по
умолчанию (пробелы,  табуляции,  символы новой строки),  так, чтобы мы
могли  все-таки  обрабатывать  командную строку с пробелами в качестве
символов-разделителей. Символ : дает нам возможность отдельно рассматривать 
каждый маршрут, хранимый в переменной PATH.</P>
<P>	 Вся программа представляет собой  два  цикла  for.  Внешний  цикл
просматривает имена всех файлов,  указанных в командной строке.  Внутренний 
цикл последовательно обходит все каталоги, содержащиеся в переменной  PATH.  
Для  каждого файла просматриваются все каталоги с целью
определения,  содержит ли этот каталог файл  с  таким  именем.  Полное
маршрутное имя представляет собой комбинацию префикса-каталога и имени
файла (называемых именем каталога и  базовым  именем  соответственно).
Встроенная  shell-команда test использована для определения того,  
существует ли файл в определенном каталоге.</P>

	 <P><CENTER>Если ваша переменная PATH выглядит так:</CENTER></P>

<PRE>PATH=.:/bin:/usr/bin:/etc/:$HOME/bin</PRE>

<P>то внутренний цикл выполнит пять итераций в таком  порядке:  .,  /bin,
/usr/bin,  /etc и,  наконец,  $HOME/bin. Если бы запрос имел вид "path
ll" для поиска утилиты, которую мы создадим позже в этой главе, то результат 
мог бы выглядеть так:</P>

<hr>
<PRE>
|
|	/usr/bin/ll
|	/usr/russ/bin/ll
|
|
</PRE>
<P>Это значит, что команда ll была найдена в двух местах из вашего набора
маршрутов поиска.
</P>
						  <CENTER><H3>ЧТО ДЕЛАЕТ paths?</H3>
</CENTER>

<P>	 Теперь, когда мы знаем,  как работает более простая команда path,
мы можем по достоинству оценить дополнительные возможности специальной
команды  получения маршрута - команды paths.  Paths имеет три основные
функции.  Она может выполняться как основная команда path,  которую мы
уже  рассмотрели,  и давать полное маршрутное имя исполняемого модуля.
Она может выдавать маршрут файла в длинном формате.  Она  также  может
выдать список всех файлов с установленным пользовательским идентификатором 
(setuid bit files),  которые есть в ваших маршрутных  каталогах.
(См. главу 8, где описаны биты setuid.)</P>
<P>	 Синтаксис вызова немного отличается для разных  опций.  Для  того
чтобы использовать формат выдачи маршрута или формат команды ls, нужна
такая командная строка:</P>

<PRE>paths [-l] file [file ...]</PRE>

<P>как, например,  в командах "paths ls who date" или "paths -l ll".  Для
поиска файлов с установленным пользовательским идентификатором (setuid
files) не нужно указывать имена файлов в командной строке. Вся команда
должна быть такой:</P>

<PRE>paths -s</PRE>

<P>	 Формат setuid  и форматы выдачи маршрута являются взаимоисключающими,  
поскольку предполагается,  что вы хотите узнать от  компьютера,
какие и где находятся файлы, а не отгадывать имена файлов.</P>
<P>	 Если в командной строке находится какая-то  другая  опция,  то  в
стандартный  вывод  выводится сообщение об ошибке и командный файл завершается. 
Опции устанавливают флаг формата вывода в одно из трех значений. 
Весь дальнейший вывод из командного файла управляется выбранным
форматом вывода.</P>

<ul><a name=68></a><h2>ПРИМЕРЫ</h2></ul>

<PRE>  $ paths ls more who paths
	/bin/ls
	/usr/bin/more
	/bin/who
	/usr/russ/bin/paths
</PRE>
<P>	 Поиск маршрутов к командам ls,  more, who, paths. При выводе указываются 
полные абсолютные маршрутные имена.  Обратите внимание, что в
конце имени каждого файла печатается символ новой строки,  чтобы получить 
распечатку, в которой каждое имя файла стоит в отдельной строке.</P>

  <PRE>$ more `paths gettydefs termcap paths`</PRE>


<P>	 Если ваша  переменная PATH содержит каталог /etc,  то этот пример
будет работать. Если нет, то первые два файла не будут найдены. Сначала  
запускается  команда paths,  и ее вывод помещается на свое место в
командной строке команды more.  Когда запускается команда more, она не
знает,  что ее аргументы получены от другой команды.  После завершения
работы команды paths команда more принимает вид:</P>

<PRE>more /etc/gettydefs /etc/termcap /usr/russ/bin/paths</PRE>

<P>с полными маршрутными именами каждого файла.  Этот пример  показывает,
как можно заставить команду paths выполнять всю работу по поиску и показу 
файлов, которые вы хотите увидеть.</P>

  <PRE>$ ll `paths ll`</PRE>

<P>	 В этом примере в длинном формате выводятся файлы  с  именами  ll,
которые  найдет path.  (Мы представим нашу версию команды ll несколько
позже в этой же главе.) Как и в предыдущем случае,  сначала  генерируется 
информация о маршруте, затем она помещается в командную строку, а
затем запускается команда ll.</P>

 <PRE> $ m `paths paths`</PRE>

<P>	 В данном примере генерируется маршрутное  имя  самого  командного
файла paths и передается программе m,  которая использует команду more
для распечатки. (Командный файл m мы также покажем вам позже.)
</P>

<ul><a name=69></a><h2>ПОЯСНЕНИЯ</h2></ul>

<P>	 В строке 4 инициализируется переменная FORMAT,  указывая маршрутный 
тип поиска. Выполняется действие по умолчанию, точно такое же, как
в командном файле path, который мы рассмотрели ранее.</P>
<P>	 В строках 6-19 все аргументы командной строки проверяются на корректность.  
Критерием того,  что аргумент есть опция, является дефис в
роли первого символа.  Заметим,  что здесь не разрешено  использование
синтаксиса "-xyz".  Это заставляет вас пользоваться синтаксисом "-x -y
-z".  Хотя этот момент может показаться несущественным,  на самом деле
он важен. Всегда нужно достигать компромисса между быстрой разработкой
командного файла при согласии на недостатки жесткого  синтаксиса  -  и
разрешением гибкого формата за счет дополнительных усилий по кодированию 
и отладке и за счет более медленного выполнения. Ваш выбор зависит
от ваших приоритетов,  от количества людей,  использующих ваше инструментальное 
средство,  и от того,  насколько критична скорость выполнения. 
Конечно, если скорость критична, вы, вероятно, захотите использовать 
каким-то образом язык Си.  Мы оставляем обработку конкатенированных опций в 
качестве упражнения для читателя.</P>
<P>	 Цикл for проходит по всем  позиционным  параметрам.  Если  первым
символом аргумента является "-", то он сверяется со списком допустимых
аргументов с помощью оператора case в строках 9-17. Опция "-l" изменяет 
переменную формата, после чего убирается из рассмотрения. Это делается 
для освобождения этой позиции,  чтобы конечным  результатом  были
просто имена файлов в командной строке.</P>
<P>	 Опция "-s" также изменяет переменную формата.  Однако, вместо того,  
чтобы  убрать опцию из командной строки,  она ликвидирует всю командную 
строку и заменяет ее символом "l".  Это  заставляет  цикл  for
проходить  только  одну  итерацию,  так  как в командной строке теперь
только один параметр.  Благодаря такому обращению с командной строкой,
нам не нужен другой цикл:  мы можем использовать тот же цикл,  что и в
определении маршрута,  без всяких модификаций. Поскольку после опции s
не ожидается никаких имен файлов, мы больше не хотим рассматривать командную строку.
</P>
<P>	 Если использована опция,  которая не является ни l, ни s, то этой
опции соответствует звездочка (*) и в стандартный  файл  ошибок  выводится 
сообщение об ошибке. Затем командный файл завершается.</P>
<P>	 Мы бы могли просто проверить первый  параметр  командной  строки,
чтобы выяснить,  является ли он опцией, и если является, то установить
эту опцию. Поскольку можно использовать только одну опцию за один раз,
мы могли бы предполагать,  что в остальной части командной строки были
имена файлов.  Тем не менее,  этот цикл допускает  простое  добавление
других опций, которые могли бы действовать в дополнение к одной основной. 
Это более предпочтительно, и оно не влияет на производительность.</P>
<P>	 В строке  21  мы добавляем символ двоеточия (:) к другим символам
разделителя полей.  Мы должны именно добавить двоеточие,  а не превратить 
разделитель полей только в двоеточие.  Если бы мы сделали последнее, то 
это запутало бы разбор имен файлов в командной строке.</P>
<P>	 Основной цикл представлен в строках 23-40.  Это двойной цикл for.
Внешний цикл проходит по каждому файлу в командной строке,  а внутренний  
цикл  обрабатывает  каждый каталог,  указанный в вашей переменной
PATH.  Обратите внимание, что внешний цикл идет по именам файлов, а не
по записям каталогов. Если бы мы выбрали второе, то в распечатке нарушился 
бы порядок имен файлов,  поскольку поиск шел бы сначала по каталогам.
</P>
<P>	 Следовательно, для каждого имени файла и  каталога  действие  зависит  
от  требуемого формата.  Маршрутный формат печатает полное имя,
листинговый формат выполняет команду ls,  а формат set не ищет указанные  
имена файлов,  но проверяет права доступа и ищет файлы с установленным 
пользовательским идентификатором.</P>
					 <H2><CENTER>ПРИЕМЫ ПРОФЕССИОНАЛЬНОЙ РАБОТЫ В UNIX</CENTER></H2>

<P>  Опция ls есть дополнение,  которое сокращает объем  работы
при  вызове.  Наличие комбинации поиска и команды ls освобождает того,
кто вызывает этот командный файл от  необходимости  применять  команду
подстановки. Старая и новая команды выглядят примерно так:</P>

<PRE>ll `path ll`</PRE>
	<P> Находит путь к ll, а затем запускает на нем команду ls -l.</P>

<PRE>paths -l ll</PRE>
	 <P>Находит путь и вместо того, чтобы его напечатать,
	 выполняет команду ls -l применительно к этому пути.</P>

<P>	 Формат setuid в строке 34 прощается с подходом "один файл за один
раз" и включает каталоговую машину.  Поскольку внешний цикл установлен
на одну итерацию,  внутренний цикл становится главным. Для каждого каталога,  
указанного  в PATH,  печатаются оформление из двоеточий и имя
каталога. Это делает распечатку приятной, информативной и наглядной.</P>
<P>	 Ключевой командой является комбинация ls-grep. Каждое имя файла в
каталоге распечатывается в длинном формате,  затем просматривается бит
установки пользовательского идентификатора. Модель такова, что команда
ls -al $DIR печатает следующее:</P>

<hr>
<PRE>
|
|  -rws--x--x   1 root	bin	   16235 Sep 13  1985 /bin/su
|
|
</PRE>
<P>	 Аргумент "^[^ ]*s[^ ]*" означает поиск от начала строки  символа,
отличного от пробела,  за которым следует один или более символов, отличных 
от пробела, затем символ s и затем один или более символов, отличных 
от пробела. Это выражение ограничивает поиск битами прав доступа в начале 
строки.  Если имеется символ s где-либо в  правах  доступа
(либо  в  пользовательском  идентификаторе процесса,  либо в групповом
идентификаторе процесса), то команда grep отрабатывает успешно и печатается 
вся строка.</P>
<P>	 Такой вид поиска установленного пользовательского  идентификатора
несколько "легковесен" в том смысле, что поиск ведется только согласно
переменной PATH,  которая у вас есть.  Файлы с установленным пользовательским 
идентификатором могут находиться в каталогах, которые не указаны в PATH. 
Однако в такой реализации данная опция обеспечивает быстрое  обращение  
к  вашим  локальным  файлам  с установленным пользовательским идентификатором.
</P>

<ul><a name=70></a><h2>ВОЗМОЖНЫЕ МОДИФИКАЦИИ</h2></ul>

<P>	 Данный командный файл открыт для многих различных видов модификации.  
Поиск полного имени файла является фундаментальной задачей программного 
обеспечения по сопровождению файлов. Эта возможность позволяет нам полагаться 
на саму программу paths или использовать paths в качестве куска более объемной 
программы.</P>
<P>	 При разработке ваших собственных программ следует обратить внимание 
на гибкость командного файла paths,  которая выражается в  отличии
между обрабатываемыми форматами. Первые два формата используют отдельные 
файлы,  а формат set использует каталоги.  Дальнейшие дополнения к
командному  файлу  paths  могут касаться любой из этих строк или могут
комбинировать их. Если есть необходимость, программное обеспечение может 
приспособиться к этому.</P>

<ul><a name=71></a><h2>2.2. ВЫВОД ИНФОРМАЦИИ</h2></ul>
	  <a name=72></a><CENTER><H2>2.2.1. lc - вывод файловой информации на экран по столбцам</H2>
</CENTER>

<hr>
ИМЯ:		lc
<hr>

<P>	 lc				Выдает список файлов в колоночном формате</P>


<ul><h2>НАЗНАЧЕНИЕ</h2></ul>

<P>	 Выдает информацию о файлах в формате колонок,  показывая каталоги
и исполняемые модули.  Этот листинг  можно  пропустить  через  команду
more.</P>

<ul><a name=73></a><h2>ФОРМАТ ВЫЗОВА</h2></ul>

	<PRE> lc [-m] [ls options] file [file ...]</PRE>

<ul><a name=74></a><h2>ПРИМЕР ВЫЗОВА</h2></ul>

	 <PRE>lc -R $HOME</PRE>

<P>		Выдает список всех файлов во всех подкаталогах моего регистра-
ционного каталога.</P>

<ul><a name=75></a><h2>ТЕКСТ ПРОГРАММЫ</h2></ul>
<PRE>
1   :
2   # @(#) lc v1.0   List files in a column   Author: Russ Sage
2а					 Выводит список файлов в колоночном виде

4   if [ "$1" = "-m" ]
5	 then  MORE="| /usr/bin/more"
6		   shift
7	 else  MORE=""
8   fi

10   eval "/bin/ls -a $@ | /bin/pr -5t" $MORE   # pre System V
11   eval /bin/ls -aCF $@ $MORE				 # System V
</PRE>
<ul><a name=76></a><h2>ПЕРЕМЕННЫЕ СРЕДЫ ВЫПОЛНЕНИЯ</h2></ul>

   <P>  MORE		Содержит программный канал к команде more</P>

	   <H3><b>ОПИСАНИЕ</b></H3>

				 <CENTER> <H3>ЗАЧЕМ НАМ НУЖЕН КОМАНДНЫЙ ФАЙЛ lc?</H3></CENTER>


<P>	 В мире  компьютеров многие люди изобретают колесо,  а другие люди
изобретают его снова.  Если первое колесо не того размера или не  того
цвета,  делается  другое колесо.  В нашей конкретной ситуации исходным
колесом является команда ls системы UNIX,  которая имеет некоторые недостатки 
в своих ранних реализациях. Она выдает хорошую информацию, но
она печатает имена файлов только в одну колонку,  что приводит к нерациональному 
расходованию места и затрудняет чтение имен файлов. Поэтому мы создаем версию  
команды  ls,  которая  отображает  распечатки  в 
несколько колонок.</P>
<P>	 Как видно из предыдущего листинга, lc имеет две формы. Одна 
предназначена для систем,  более ранних,  чем System V,  а  другая  
-  для
System V и последующих версий UNIX. Причина в том, что System V версии
2 имеет новую команду ls,  которая делает именно то,  что  мы  хотим.
Система  Berkeley также имеет версию команды ls,  которая по умолчанию
использует несколько колонок при выводе на терминал.  Но для  XENIX  и
ранних версий System V мы должны делать это сами. Дело в том, что хотя
в вашей версии UNIX,  XENIX или чего-либо еще могут отсутствовать  команды,  
имеющиеся в других версиях, вы обычно можете построить то, что
вам нужно. Это может потребовать определенных усилий, и ваши программы
могут  работать не так быстро и не так эффективно,  но вы МОЖЕТЕ получить 
нужное средство.</P>
<P>	 Пользователям интерпретаторов csh и последнего sh, имеющего 
функции, видимо, лучше бы заменить весь этот сценарий на то, чтобы сделать
lc псевдонимом (alias). Использовать возможность введения псевдонимов,
чтобы  присвоить имя любой корректной командной строке UNIX (например,
вызову команды ls с указанными опциями). Это легче, чем писать командный 
файл, но ограничивает вас необходимостью работать с уже имеющимися
командами или опциями.  Это быстрее,  так как не создается никаких 
дополнительных процессов.</P>
<P>	 При работе со старым интерпретатором sh мы  должны  пройти  через
обычную процедуру изготовления командного файла и размещения его в каталоге 
bin.  С другой стороны, SCO XENIX System V решает эту проблему,
связывая эти же имена (lc,  lf,  l) с обычной командной ls и используя
вызывающее имя для определения формы распечатки.</P>
<P>	 Итак, зачастую имеется много альтернатив. Мастера UNIX, сталкиваясь 
с какой-либо проблемой,  не борются с ней с помощью Си или командного файла 
интерпретатора shell. Поскольку они знакомы с существующими
ресурсами системы UNIX, они могут рассмотреть проблему и выбрать стратегию,  
использующую наименее сложное средство, выполняющее данную работу с 
приемлемым уровнем производительности.  В  порядке  возрастания
сложности,  это  могут быть непонятная,  но существующая команда и/или
опция, псевдоним, командный файл интерпретатора shell или программа на
языке Си.</P>

							<H3><CENTER>ЧТО ДЕЛАЕТ lc?</CENTER></H3>


<P>	 Общий подход  к разработке этой команды заключается в том,  чтобы
собрать вместе некоторые опции и сделать новую команду с более  мощным
интерфейсом.  Чтобы достичь этой мощи, мы можем сделать пре- или 
постпроцессор для обычной команды системы UNIX.</P>
<P>	 Главная задача здесь - печать колонок,  поэтому мы смотрим на опции 
команды ls, чтобы задействовать их. Конечно, мы включаем опцию -C.
Какие еще опции ls нам нужны? Обычно UNIX не печатает файлы, имена которых 
начинаются с точек, например, .profile, если только вы не указываете 
ls -a.  Это забывается при просмотре этих важных файлов, поэтому
мы конструируем нашу команду так,  чтобы она печатала их по умолчанию.
Никакие  файлы не скрываются от нас.  Для пользователей System V и BSD
(или для любого, кто имеет опцию -F), листинг улучшается за счет вывода 
"/" после имени каталога и "*" после исполняемого файла. Ранняя команда 
ls системы UNIX не имела возможности печатать в таком стиле. Отметим,  
что  данное использование термина "исполняемый" означает показ
того, что флаги прав доступа имеют бит "x", а не то, что это файл типа
a.out с магическим числом.  Это отличие важно тем,  что делает наш командный 
файл более полезным.</P>
<P>	 Если ожидается длинная распечатка,  как это бывает обычно для 
рекурсивных каталогов,  то вы хотите иметь доступ  к  команде  more.  Мы
встраиваем  команду  more так,  чтобы ее можно было активировать с помощью 
опции -m.  Опция -m должна быть первой опцией после имени команды,  
из-за способа, которым она проверяется внутри программы. Если она
передается после первой опции,  она переходит к команде UNIX ls и  
интерпретируется как печать в потоковом формате. Это такой формат, в 
котором все имена расположены в строках,  разделенных запятыми (,).  Как
мы  уже  отмечали,  вы можете сделать интерфейс этого командного файла
более гибким за счет дополнительной работы над ним.</P>

<ul><a name=77></a><h2>ПРИМЕРЫ</h2></ul>

<PRE>  $ lc `path lc`</PRE>

<P>	 Получает полное имя для lc и распечатывает файловую информацию  в
виде колонок.</P>
<PRE>
  $ lc -m -R /</PRE>

<P>	 Печатает колоночный список ВСЕХ файлов в системе, рекурсивно 
проходя вниз по иерархии системного дерева и пропуская  распечатку  через
команду more.</P>
<P>	 Еще один маленький фокус: этот синтаксис был использован для создания 
другой команды, названной expose. Командная строка "lc -m -R $@"
давала бы рекурсивный список всех файлов в любом  каталоге  по  вашему
выбору в приятном постраничном формате.</P>

<PRE>  $ lc -m -R /usr/lib</PRE>

<P>	 Рекурсивно распечатывает  список  всех  файлов во всех каталогах,
начиная с /usr/lib, и пропускает листинг через команду more.</P>

<PRE>  $ lc -m . | more</PRE>

<P>	 Выдает список файлов в текущем каталоге и пропускает листинг  
через команду more, а затем снова пропускает все через more. Работает ли
это ?  Никоим образом. Возникает полная путаница, и клавиша прерывания
обычно является наилучшим способом выхода из данной ситуации.</P>


<ul><a name=78></a><h2>ПОЯСНЕНИЯ</h2></ul>

<P>	 В строках 4-8 проверяется,  является ли первым аргументом командной 
строки -m - опция команды more. Если эта опция найдена, то в переменную 
MORE заносится указание конвейера и  команда  more.  Тем  самым
устанавливается постобработка,  которую следует применить к выходу команды ls.  
Затем эта опция убирается из командной строки. Это делается
для  того,  чтобы остаток командной строки можно было передать команде
ls,  не вызвав при этом нежелательных эффектов.  Если первой опцией не
является -m, переменной MORE присваивается нулевое значение, чтобы она
впоследствии не влияла на командную строку.</P>
<P>	 Строка 10  - это командная строка,  которую вы бы использовали на
старой UNIX-машине типа Version 7 или System  III.  Она  не  имеет  ни
встроенной  опции для печати символов косой черты (/) и звездочек (*),
ни возможности печати в виде колонок.  Вы должны  пожертвовать  первой
возможностью,  а распечатки в виде нескольких колонок можно получить с
помощью команды pr системы UNIX.  Команда  pr  использована  с  опцией
"-5t",  поэтому она печатает в пять колонок (что обычно приемлемо,  но
если встречаются длинные имена файлов, то пяти колонок может оказаться
слишком  много) и не печатает верхний и нижний колонтитулы.  Благодаря
отказу от колонтитулов,  24-строчный формат не  слишком  неудобен  для
вас.</P>
<P>	 Отметим, что здесь использована  команда  eval.  Это  специальная
встроенная  команда  интерпретатора  shell,  которая выполняет перевычисление 
текущей строки,  подлежащей выполнению.  Интерпретатор  shell
повторно анализирует эту строку, чтобы раскрыть значение имен переменных 
в командной строке и обеспечить распознавание переменных как таковых. 
Здесь мы перевычисляем переменную MORE. Напомним, что мы поместили в 
эту переменную конвейер.  Если мы не перевычислим командную строку,  
то  команда pr попытается открыть файлы "|" и "more",  которые не
существуют.  Для того, чтобы shell вместо этого воспринял эти  символы
как указания конвейеров и программ, и используется команда eval.</P>
<P>	 Строка 10 имеет еще одну особенность. В командной строке уже есть
один  конвейер.  Откуда shell знает,  трактовать ли символ "|" как имя
файла или как конвейер? Благодаря тому, что аргумент команды eval заключен 
в кавычки.  Это указывает команде eval сохранить все,  что находится 
в кавычках,  без изменений, но раскрыть значение переменной MORE
и  поместить  его  в  конец командной строки,  находящейся в кавычках.
Несколько непонятно,  но если вы думаете об этом пару лет,  оно становится 
осмысленным.</P>
<P>	 Для тех из вас,  кто имеет новую команду ls (System V,  версия  2
или  BSD  4.2),  не требуется два конвейера в команде.  Как показывает
строка 11,  мы получаем подходящий колоночный формат из самой  команды
ls,  вместе  с  показом всех файлов и специальными символами / и * для
каталогов и исполняемых файлов.  Обозначение $@ относится ко всему содержимому 
командной строки, т.е. к вашим дополнительным опциям команды
ls и к именам файлов,  список которых вы хотите распечатать.  Поступая
таким  образом,  мы  создаем  фундамент  (опции  a,C,F),  а  вы можете
надстраивать его (используя опции R,t и т.д.). Скромный, но элегантный
фокус  заставить ls сообщить свои опции заключается в том,  чтобы вызвать 
ее с неверной опцией.  Большинство команд не используют  опции  z
или ?, поэтому вызов "ls -z" или "ls -?" приведет к такому результату:</P>

<hr>
<PRE>
|
|   ls: illegal option -- z
|   usage:  -1ACFRabcdfgilmnopqrstux [files]
|
</PRE>
<P>	 Все эти  опции  представляют определенный интерес.  Если вы часто
используете какие-либо из них,  поместите их в командный файл lc, и вы
получите вашу собственную адаптированную команду.</P>
<P>	 Вы обратили внимание,  что  все  обычные  команды  системы  UNIX,
используемые  в нашем командном файле,  имеют полные маршрутные имена?
Это может показаться несколько странным,  но причина  указания  полных
маршрутных имен в том, что когда shell запускает команду, он не должен
возвращаться к анализу переменной PATH и искать,  где расположена  команда.  
Если  вы обращаетесь к командам относительным способом,  время
поиска файлов представляет собой большие накладные расходы.  Когда  вы
вызываете lc,  интерпретатор shell ищет эту команду, затем lc вызывает
ls, которую тоже нужно найти. Если после этого результаты пропускаются
через more или pr,  то требуется дополнительный поиск.  А полные маршрутные 
имена распознаются интерпретатором shell сразу  же  (он  видит,
что  первым символом является /),  и нужная команда может быть вызвана
быстро. Издержки на поиск - единственные издержки команды lc.</P>
<P>	 Использование полных имен,  естественно, требует, чтобы вы знали,
где в системе размещены утилиты,  к которым вы хотите  обратиться.  Вы
можете применить команду paths, чтобы получить корректные полные имена
для жесткого указания их в тексте вашего командного  файла,  а  можете
переписать  данный  командный файл при переходе в другую систему.  Это
просто еще одна иллюстрация универсального компромисса между скоростью
и эффективностью,  с одной стороны, и гибкостью и мобильностью, с другой.
</P>

	   <a name=79></a><CENTER><H2>2.2.2. ll - вывод файловой информации в длинном формате</H2>
</CENTER>

<hr>
ИМЯ:		ll
<hr>

	 <P>ll		 Выдает список файлов в длинном формате</P>

<ul><h2>НАЗНАЧЕНИЕ</h2></ul>

<P>	 Выдает список  файлов  в  длинном формате (-l).  Распечатку можно
пропустить через команду more.</P>


<ul><a name=80></a><h2>ФОРМАТ ВЫЗОВА</h2></ul>

<PRE>	 ll [-m] [ls options] file [file...]</PRE>

<ul><a name=81></a><h2>ПРИМЕР ВЫЗОВА</h2></ul>

<PRE>	 ll *.c		Выдача списка файлов с исходными текстами на
				языке Си в длинном формате.</PRE>

<ul><a name=82></a><h2>ТЕКСТ ПРОГРАММЫ</h2></ul>
<PRE>
1  :
2  # @(#) ll v1.0   Long listing of files   Author: Russ Sage
2а					Выводит список файлов в длинном формате

4  if [ "$1" = "-m" ]
5	then MORE="| /usr/bin/more"
6		  shift
7	else MORE=""
8  fi

10 eval /bin/ls -al $@ MORE
</PRE>
<ul><a name=83></a><h2>ПЕРЕМЕННЫЕ СРЕДЫ ВЫПОЛНЕНИЯ</h2></ul>

<PRE>		MORE	Содержит строку передачи результатов по
				конвейеру команде more</PRE>

	   <H3><b>ОПИСАНИЕ</b></H3>

				  <CENTER><H3>ЗАЧЕМ НАМ НУЖЕН КОМАНДНЫЙ ФАЙЛ ll?</H3></CENTER>


<P>	 Мотивы для  создания команды ll те же,  что мы обсудили ранее для
команды lc.  Мы можем использовать ll для нескольких целей. Она уменьшает 
количество требуемых нажатий на клавиши, позволяет избежать необходимости 
помнить специальные опции и вообще настраивает систему соответственно 
нашим требованиям вместо того чтобы нам приспосабливаться к
системе.</P>

							<H3><CENTER>ЧТО ДЕЛАЕТ ll?</CENTER></H3>

<P>	 Основой этой команды является известная  команда  "ls  -l".  Она,
если вы помните,  дает очень емкую информацию о каждом файле,  включая
права доступа,  связи,  имя владельца,  размер и так  далее.  (Кстати,
программисты,  использующие язык Си, могут получить эту информацию при
помощи системного вызова stat(2).) Поскольку такой список при  наличии
множества файлов может легко переполнить экран, то предоставляется опция 
-m.  Она обеспечивает постраничный вывод с помощью  команды  more.
Отметим, что если используется эта опция, то она должна стоять первой.
Строка символов, соответствующая этой опции, удаляется командой shift,
так что она не смешивается с именами файлов и обычными опциями команды
ls, которые передаются как аргументы.</P>
<P>	 После опции -m (если она есть) ll допускает указание любых других
допустимых опций команды ls. Можно также использовать любую комбинацию
имен файлов.  Здесь применимы обычные средства порождения имен файлов:
* соответствует любым символам, ? - одному символу, а символы [] задают 
диапазон из некоторого набора символов. В итоге мы получили команду
ls, которая по умолчанию работает как "ls -l", вызывает команду more с
помощью  одной опции вместо необходимости указания конвейера в командной 
строке и при этом сохраняет гибкость команды ls.</P>

<ul><a name=84></a><h2>ПРИМЕРЫ</h2></ul>

<PRE>  $ ll /etc/*mount*</PRE>

<P>	 Выводит список всех файлов в каталоге /etc,  имена которых содержат   
в   каком-либо  месте  слово  mount  (например,  mount,  umount,
unmountable).</P>
<PRE>
  $ ll -i `who|awk '{print "/dev/" $2}'`</PRE>

<P>	 Сперва выполняется команда who, затем результат ее работы по конвейеру 
передается команде awk,  которая вырезает имя устройства и приписывает 
ему префикс /dev/. В результате список полных маршрутных имен
ко  всем терминальным устройствам,  зарегистрированным в настоящий момент,  
помещается в командную строку команды ls -li. В распечатке указана 
вся информация об индексном дескрипторе файла (inode) для каждого
терминального устройства.</P>

<PRE>  $ ll `kind -a /lib`</PRE>

<P>	 Выводит в длинном формате список всех файлов  архива  в  каталоге
/lib. Этот каталог содержит библиотеки компиляторов всех языков системы 
UNIX.  (Команда kind, которая отбирает файлы по их типу, рассматривается 
в следующем разделе.)</P>

<PRE>  $ ll -m -i /dev</PRE>

<P>	 Выводит всю  обычную информацию плюс номер индексного дескриптора
для всех файлов в каталоге /dev.  Выдача на экран происходит с помощью
команды more.</P>

<ul><a name=85></a><h2>ПОЯСНЕНИЯ</h2></ul>

<P>	 Если первым  позиционным  параметром  является -m,  то в строке 4
инициализируется переменная MORE для подключения конвейера и программы
/usr/bin/more.  (Вопрос о том, почему используется абсолютное маршрутное 
имя,  обсуждался в предыдущем разделе.) Затем символьная строка -m
командой shift убирается из командной строки. Если же первой опцией не
является -m,  то переменная MORE устанавливается в нуль, чтобы не влиять 
на повторный разбор командной строки, выполняемый с помощью команды 
eval (строка 10).</P>
<P>	 В строке  10 команда eval использована для получения результирующей 
командной строки.  Команда ls вызывается  с  опциями  -al  (выдача
списка всех файлов в длинном формате),  которые мы установили по умолчанию.  
Затем берутся аргументы командной строки (минус  первый  аргумент,  
если это был -m, который мы убрали командой shift). Этими аргументами 
могут быть дополнительные опции команды ls плюс  имена  файлов
или  каталогов.  В  конце строки значение переменной MORE обеспечивает
конвейер с командой more, если была указана опция -m. В противном случае  
значение переменной MORE равно нулю и не оказывает никакого влияния 
на анализ содержимого командной строки.</P>
<P>	 Что произошло бы, если бы пользователь указал опцию -m в качестве
второй (или последующей) опции?  В этом случае опция -m передалась  бы
команде ls.  Команда ls трактовала бы эту опцию как "потоковый вывод",
а это совсем не то, что мы хотели. Однако команда ls была вызвана так-
же  с  опцией  -l,  которая отменяет опцию -m в соответствии с текстом
программы ls.  Вы не получили бы вывод с помощью команды more, но ваши
выходные данные по-прежнему были бы выведены в правильном формате.</P>

				<a name=86></a><H2<CENTER>2.2.3. kind - вывод однотипных файлов</CENTER></H2>


<hr>
ИМЯ:		kind
<hr>

<P>	 kind		Выдача списка имен файлов определенного вида</P>


<ul><h2>НАЗНАЧЕНИЕ</h2></ul>

<P>	 Выбирает и выводит имена всех файлов в указанном каталоге  (каталогах),  
имеющих указанный тип. Если не указан никакой тип, выбираются
текстовые файлы.</P>

<ul><a name=87></a><h2>ФОРМАТ ВЫЗОВА</h2></ul>

<PRE>	 kind [-a] [-d] [-t] [-x] [file...]</PRE>

<ul><a name=88></a><h2>ПРИМЕР ВЫЗОВА</h2></ul>

<PRE>	 more `kind /etc/*`

		Вывод командой more всех текстовых файлов, имеющихся в катало-
		ге /etc.
</PRE>
<ul><a name=89></a><h2>ТЕКСТ ПРОГРАММЫ</h2></ul>
<PRE>
1   :
2   # @(#) kind v1.0   Prints files of the same kind  Author: Russ Sage
2а					   Выводит список файлов определенного вида

4   if [ $# -gt 0 ]
5	 then if [ `echo $1 | cut -c1` = "-" ]
6			then case #1 in
7				 -a)   KIND='archive'
8					   shift;;
9				 -d)   KIND='data'
10					  shift;;
11				-t)   KIND='text'
12					  shift;;
13				-x)   KIND='executable'
14					  shift;;
15				 *)   echo "kind: arg error"						   >&2
16					  echo "usage: kind [-a] [-d] [-t] [-x] [file...]" >&2
17					  echo "	   -a  archive"						>&2
18					  echo "	   -d  data"						   >&2
19					  echo "	   -t  text, default"				  >&2
20					  echo "	   -x  executable"					 >&2
21					  echo "	   if no args, reads stdin"			>&2
22					  exit 1;;
23				esac
24		 fi
25   fi

27  : ${KIND:='text'}

29  case $# in
30  0)   while read FILE
31	   do
32		   file $FILE | fgrep $KIND | cut -d: -f1
33	   done;;
34  *)   file $@ | fgrep $KIND | cut -d: -f1;;
35  esac
</PRE>
<ul><a name=90></a><h2>ПЕРЕМЕННЫЕ СРЕДЫ ВЫПОЛНЕНИЯ</h2></ul>

	 FILE   Содержит имена файлов по мере их чтения из stdin
			(стандартного ввода)
	 KIND   Содержит строку, определяющую тип файла

	   <H3><b>ОПИСАНИЕ</b></H3>

				  <CENTER><H3>ЗАЧЕМ  НУЖЕН КОМАНДНЫЙ ФАЙЛ kind?</H3></CENTER>
<P>
	 Файловая система UNIX имеет строгие  стандарты  при  рассмотрении
файлов. Имеется три вида файлов: обычные файлы (тексты, данные, исполняемые 
файлы),  каталоги и устройства.  Каждый вид файлов  имеет  свое
предназначение и обычно имеет особые команды или файлы данных, которые
работают с ним.</P>
<P>	 Давайте рассмотрим,  как некоторые из существующих команд системы
UNIX рассматривают типы файлов. Команда ls делает различие между каталогами 
и другими файлами,  поэтому она может быть полезна. Другой важной 
командой является команда file.  Она сообщает вам, какой тип имеет
данный файл, что потенциально полезно, но слишком мало. Для того чтобы
извлечь из команды file  какую-либо  полезную  информацию,  вы  должны
надстроить  над ней некоторую программу.  Что нам действительно нужно,
так это некий гибрид команд ls и file,  т.е.  утилита, которая выводит
имена всех файлов указанного типа.</P>
<P>	 Примером полезности такого рода утилиты может служить анализ  
содержимого  каталогов.  Возьмем,  например,  каталог /etc.  Он содержит
программы,  файлы данных и текстовые файлы.  Для каждого из этих типов
требуется свой собственный тип анализа. Программы анализируются командами 
ls,  size,  nm и file.  Файлы данных анализируются  командой  od.
Текстовые файлы анализируются командами more,  wc, head, tail и другими. 
Таким образом, обычно вам необходимо работать в данный момент времени 
с файлами какого-нибудь одного типа.</P>

						   <CENTER><H3>ЧТО ДЕЛАЕТ kind?</H3></CENTER>


<P>	 Командный файл  kind  - это утилита,  которая распечатывает имена
всех файлов,  имеющих указанный тип.  Она имеет интерфейс,  похожий на
интерфейс команды ls,  т.е. вы можете передать ей опции и имена файлов
или символы расширения имен файлов.  При  выводе  отображаются  полные
имена,  если они были указаны,  но вы можете избежать появления лишней
информации при выводе,  если предварительно перейдете в нужный каталог
с помощью команды cd. Например, если бы я находился в моем регистраци-
онном каталоге (/usr/russ) и ввел команду</P>

<PRE>		$ kind -d /etc/*</PRE>

то вывод мог бы выглядеть так:

<hr>
<PRE>
|
|   /etc/mnttab
|   /etc/utmp
|   /etc/wtmp
|
</PRE>
<P>	 То есть,  вывелся список всех файлов данных. А если бы я выполнил
такую последовательность команд:</P>
<PRE>
		$ cd /etc
		$ kind -d *
</PRE>
<P>то при выводе убрался бы маршрут, использованный в вызывающей 
последовательности, и напечаталось бы следующее:</P>

<hr>
<PRE>
|
|	mnttab
|	utmp
|	wtmp
|
</PRE>
<P>	 Затем выход в таком виде может быть использован во внешней команде 
для распечатки и анализа файловой информации.</P>
<P>	 Допустимыми опциями  команды kind являются -a для файлов архивов,
-d для файлов данных,  -t для текстовых файлов (что является умолчанием) 
и -x для исполняемых файлов.  Определение этих типов соответствует
команде UNIX file.  Заметим,  что критерии  того,  что  файл  является
исполняемым,  в команде file отличаются от тех,  которые применяет команда 
ls: ls проверяет биты x в индексном дескрипторе файла, в то время 
как file проверяет, являются ли первые несколько байтов содержимого
файла "магическим числом". Это магическое число является идентификатором  
структуры a.out (см.  /usr/include/a.out.h),  который сообщает "Я
являюсь скомпилированной Си-программой".</P>
<P>	 Имена файлов появляются в командной строке после опций. Эти имена
могут быть порождены любым стандартным методом системы  UNIX.  Если  в
командной строке нет имен файлов,  то kind превращается в фильтр и читает 
стандартный ввод для получения списка имен файлов. (Обратите внимание,  
что я сказал "имен файлов",  а не "файлов". Можно использовать
опции,  поскольку они убираются из командной строки командой shift  по
мере того, как они встречаются.) Таким образом, вы можете использовать
другие команды для того,  чтобы передать по  конвейеру  список  файлов
утилите kind.  Она отфильтровывает и выводит только те из них, которые
соответствуют нужному вам типу.</P>

<ul><a name=91></a><h2>ПРИМЕРЫ</h2></ul>
<PRE>   $ od `kind -d /etc/*`</PRE>

<P>	 Выглядит так, как будто это должно работать, но команда od не 
работает с набором имен файлов.  Она может обрабатывать только один файл
в данный момент времени.</P>
<PRE>   $ ll `sh -x kind -a /lib/*` | m</PRE>

<P>	 Это длинный пример.  Выводит в длинном формате список всех файлов
архивов, которые находятся в каталоге /lib. Мы запускаем shell в отладочном 
режиме выполнения,  так что вы можете увидеть каждую  командную
строку перед ее выполнением. Результат по конвейеру передается команде
more.</P>
<PRE>
   # find / -print | kind -x | while read FILE
	 > do
	 >		ll $FILE
	 > done > /tmp/filelist
</PRE>
<P>	 Данный цикл обнаруживает все действительно исполняемые файлы. Для
каждого из них выполняется команда "ls -l". Отметим, что здесь команда
ll вызывается для каждого имени файла.</P>
<P>	 Вы могли бы выполнить ту же операцию при помощи такого  оператора
find:</P>

<PRE># find / -perm -0111 -exec ll {} \;</PRE>

<P>но опция  perm  в данном случае опять же проверяет биты прав доступа в
индексном дескрипторе файла,  а не ищет магическое число  в  структуре
a.out, как описано ранее. Кстати, для того, чтобы вы могли успешно 
запустить команду file (и тем самым kind) на системных файлах, вы должны
иметь права чтения, чтобы можно было прочитать магическое число.</P>
<PRE>
   $ for F in `kind /bin/* /usr/bin/* /etc/*`
   > do
   >	  fgrep "trap" $F /dev/null
   > done
   $ fgrep "trap" `kind /bin/* /usr/bin/* /etc/*`
   $ find /bin /usr/bin /etc -exec fgrep "trap" {} \;
</PRE>
<P>	 Это три различных способа поиска слова "trap" во  всех  текстовых
файлах.
</P>
<ul><a name=92></a><h2>ПОЯСНЕНИЯ</h2></ul>

<P>	 Опции, которые могут быть указаны в командной строке, должны быть
самым первым аргументом. Это создает более строгий синтаксис, по которому  
можно  выловить ошибку.  Но это несколько ограничивает гибкость.
Как было ранее отмечено,  вы можете,  если хотите, по-своему разрешить
компромисс  между  эффективностью  и  гибкостью  путем дополнительного
программирования.</P>
<P>	 В строке 4  проверяется,  включены ли какие-либо параметры.  Если
параметры есть,  то они обрабатываются.  Если не используются  никакие
параметры, ничего не делается и управление передается на строку 27.</P>
<P>	 Если были использованы какие-либо аргументы и первым символом 
является  знак минуса (-),  то выполняется оператор case для определения
того,  какой тип файла указан. Переменная KIND устанавливается в соответствии 
с типом файла, и данный параметр удаляется из командной строки 
командой shift. Если аргумент не совпадает ни с одной из допустимых
опций,  то ему соответствует случай *,  что означает ошибку.  На стандартное 
устройство регистрации ошибок выводится соответствующее  сообщение 
об ошибке и синтаксическая подсказка,  после этого kind завершается 
с плохим статусом выполнения.</P>
<P>	  В строке  27 производится проверка того,  установлена переменная
KIND или равна нулю. Если она равна нулю, в нее подставляется символьная 
строка "text".  Если KIND уже установлена, то она не меняется. Это
неплохой оператор присвоения значения  по  умолчанию.  Таким  образом,
пользователь не обязан указывать опцию -t в командной строке.  Если же
опция -t была указана, то ей есть что сопоставить в операторе case.</P>
<P>	 Оставшаяся часть программы в строках 29-35 представляет собой еще
один оператор case,  который проверяет количество  аргументов,  оставшихся 
в командной строке после обработки ошибок. Если была указана какая-либо 
опция, то переменная KIND установлена и опция убрана командой
shift. В командной строке могли остаться только аргументы, которые 
являются именами файлов или маршрутами.  Если к тому времени,  когда  мы
уже готовы к заключительной обработке, не осталось никаких аргументов,
то значит в командной строке не было указано ни одного имени файла.</P>
<P>	 В этом случае в строках 30-33 организовывается цикл,  который чи-
тает имена файлов из стандартного  ввода,  запускает  команду  file  и
использует  команду  fgrep для определения того,  соответствует ли тип
файла, выданный командой file, интересующему нас типу (хранимому в 
переменной  KIND).  Затем  мы используем команду cut для выделения того,
что нам нужно.  Обычный вывод команды file содержит имя файла, двоеточие 
и затем описание.  Нам нужно только имя файла, поэтому мы вырезаем
первое поле, используя разделитель ":". Когда никакие данные больше не
поступают,  цикл while завершается, мы попадаем в конец оператора case
и выходим из программы.</P>
<P>	 Если же  аргументы  НАЙДЕНЫ  в командной строке,  то вместо всего
этого выполняется ветвь оператора case в строке 34.  С помощью обозначения  
$@,  имена  всех  файлов  в командной строке включены в команду
file. Таким образом, не нужен никакой цикл. Во всем остальном обработка 
идентична строке 32.</P>

<ul><a name=93></a><h2>ВОЗМОЖНЫЕ МОДИФИКАЦИИ</h2></ul>

<P>	 Было бы неплохо,  если бы командный файл kind мог работать одновременно 
с разными типами файлов.  Это означает наличие несколько опций
в  командной  строке,  например  -a  и  -d.  Вам могла бы понадобиться
составная строка,  в которой каждая часть была бы отделена символом |.
Затем эта строка могла бы быть использована в команде egrep, например,
"egrep 'archive|data'". Вам пришлось бы организовать цикл по командной
строке  вместо  использования фиксированных позиций и убедиться в том,
что вы не получите зациклившийся конвейер,  когда задана  только  одна
опция.</P>

			 <a name=94></a><H3><CENTER>  2.2.4. m - простой доступ к команде more</CENTER></H3>


<hr>
ИМЯ:   m
<hr>
<P>	 m				Простой доступ к команде more</P>

<ul><h2>НАЗНАЧЕНИЕ</h2></ul>

	<P> Обеспечивает быстрый и простой способ постраничного вывода</P>

<ul><a name=95></a><h2>ФОРМАТ ВЫЗОВА</h2></ul>

<PRE>	 m [more options] [file ...]</PRE>

<ul><a name=96></a><h2>ПРИМЕР ВЫЗОВА</h2></ul>

<PRE>	 m *   Вывод командой more всех файлов текущего каталога</PRE>

<ul><a name=97></a><h2>ТЕКСТ ПРОГРАММЫ</h2></ul>
<PRE>
1   :
2   # @(#)  m v1.0	Easy access to more
2а					Простой доступ к команде more

4   /usr/bin/more $@
</PRE>
	   <H3><b>ОПИСАНИЕ</b></H3>

					<CENTER><H3>ЗАЧЕМ  НУЖЕН КОМАНДНЫЙ ФАЙЛ m?</H3></CENTER>

<P>	 Система UNIX сильно загромождается по мере своего  функционирования. 
В ней обычно имеется множество текстов и данных. Просмотр громадного 
количества данных требует многократного нажатия на клавиши,  если
вы  должны вручную управлять постраничным выводом или периодически вызывать 
команду more.  Нам необходимы программные средства, которые помогут 
нам ускорить эту работу.  Одним из таких средств является m. Оно
очень короткое и простое, но это не значит, что оно бесполезно.</P>
<P>	 Имеется два  основных  способа  вывода  данных  на экран.  Первый
способ - непосредственный вызов команды, например, "more datafile". Вы
направляете данные на экран самой командой.  Второй способ - использовать 
какую-нибудь команду для получения данных, а затем в конце перехватить 
их командой more,  например "od -c . | more". В обоих этих случаях 
мы вводим с клавиатуры много символов.  Сделав так, чтобы команда
more вызывалась по одному символу, мы могли бы уменьшить последние две
команды на шесть нажатий на клавиши.  За целый день это  хоть  немного
предохранит клавиатуру от разрушения!  (Если ваша система поддерживает
вызов команд по псевдонимам (aliasing),  то, как указывалось ранее, вы
могли бы использовать в этом случае команду alias: "alias m more".)</P>

						   <H3> <CENTER>ЧТО ДЕЛАЕТ m?</CENTER></H3>

<P>	 Надеемся, все  ваши системы имеют команду more или хотя бы ее замену.  
Постраничный вывод имеет важное значение при работе  с  текстом
большого объема.</P>
<P>	 Все опции и аргументы передаются в командной  строке.  Вы  можете
указать  опции команды more в командной строке команды m.  Они передаются 
без изменений.  Можно указать имена файлов. Если они указаны, команда 
more выводит их. В противном случае ожидается поступление данных
со стандартного ввода.  Таким образом, m может быть использована в качестве 
"перехватчика" или как фильтр, как и команда more.</P>
<P>	 Для тех,  кто не слишком знаком с опциями команды more,  отметим,
что  существуют  две изящные возможности:  1) вход в редактор vi в том
месте, где находится курсор при выводе командой more; 2) выход из more
для запуска команды shell и возврат в то место,  откуда вы вышли. Первая 
опция выполняется при нажатии клавиши "v" в строке  состояния  команды 
more.  (То есть когда more отобразила полный экран текста и ждет
продолжения.) Вторая опция запускается при вводе ":!cmd"  или  "!cmd".
Когда команда выполнится, more вернется в то же место. Как видите, это
синтаксис командной строки ex. Команда more в самом деле имеет небольшую  
часть  редактора ex,  спрятанную внутри нее.  Вы можете выполнить
многие команды редактора, указывая их после подсказки в строке состояния 
команды more.</P>

	 <P>Обычный сеанс работы выглядит так:</P>

<hr>
<PRE>
|
|	m `path termcap`			<-поиск таблицы описания тер-
|								  минала (termcap) и вывод
|		  .					   ее командой more
		   .
		   .
  --More--(5%)				   <-строка состояния more
  v								vi /etc/termcap
  vi +210 /etc/termcap		   <-командная строка для редак-
								   тора vi получена от more
		   .
		   .
  :q							 <-выход из vi
  --More--(5%)				   <-возврат в more
  :!sh							 порождение нового shell'а
  $ date						   запуск команды date
  Wed Apr 23 07:15:04 PST 1986
  $ ^d						   <-убрать порожденный shell
  --More--(5%)				   <-возврат в more
  :f							   распечатка имени файла,
								   выводимого командой more
  "/etc/termcap" line 54		   выход команды f
  --More--(5%)
  f							  <-команда more для пропуска
								   полного экрана
   .skipping 23 lines
		   .
		   .
  --More--(9%)				   <-пропуск и выдача текста
  q								выход из команды more
</PRE>

<ul><a name=98></a><h2>ПРИМЕРЫ</h2></ul>

<PRE>  $ ll -R / | m</PRE>

<P>	 Начиная с корневого каталога (/),  вывести в длинном формате (ll)
все  файлы (опция -a подразумевается в ll) всей системы (-R) и постранично 
распечатать на экран (| m).</P>

<PRE>  $ m `path inittab rc passwd`</PRE>

<P>	 Обнаружить и вывести с помощью more системные файлы inittab, rc и
passwd.  Неприятность здесь заключается в том, что данный маршрут скорее 
всего относится к каталогу /bin/passwd, а не /etc/passwd (поскольку 
каталог /etc размещается в конце каталогов), а это означает, что вы
можете попытаться вывести на экран исполняемый файл.  В зависимости от
того,  какую из версий команды more вы запустили, это может привести к
чему угодно начиная с сообщения команды more о том,  что  это  был  не
текстовый файл,  и заканчивая тем,  что ваш терминал начнет показывать
непонятные символы и даже зависнет.</P>

<ul><a name=99></a><h2>ПОЯСНЕНИЯ</h2></ul>

<P>	 Поскольку в этом командном файле не так много текста,  то все 
довольно понятно,  нет ни обработки ошибок, ни других дополнений. Просто
нехитрый вызов команды more.  Полное имя здесь указано с целью повышения  
быстродействия,  как мы обсуждали ранее.  Вы должны перепроверить
местонахождение вашей команды more. В системе Berkeley она может находиться  
в  каталоге /usr/ ucb/more.  Воспользуйтесь командой path more
для определения этого места и вставьте соответствующий маршрут  вместо
указанного нами.</P>
<P>	 Кстати, фокус попадания этой символьной строки в текст вашего командного
 файла состоит в том, чтобы войти в редактор и вызвать следующую команду:
 </P>

<PRE>:.!path more</PRE>

<P>	 Здесь происходит переход в shell и запуск команды path (:!),  затем
  выход  команды path (который представляет собой полное маршрутное
имя) помещается в буфер редактора в самом начале текущей  строки  (.).
После этого вы имеете эти данные в вашем редактируемом файле и при 
необходимости можете отредактировать их.
</P>
  <a name=100></a><CENTER><H3>2.2.5. mmm - обработка программой nroff макрокоманд для рукописей</H3>
</CENTER>

<hr>
ИМЯ:	  mmm
<hr>
<PRE>
	 mmm		Командная строка nroff для макросов обработки
				рукописей
</PRE>
<ul><h2>НАЗНАЧЕНИЕ</h2></ul>

<P>	 Вызывает текстовый процессор nroff со специальными опциями, которые 
инициализируют макросы обработки рукописей.</P>

<ul><a name=101></a><h2>ФОРМАТ ВЫЗОВА</h2></ul>

<PRE>	 mmm file [...]</PRE>

<ul><a name=102></a><h2>ПРИМЕР ВЫЗОВА</h2></ul>
<PRE>
	 mmm memo	Обработать с помощью nroff файл моих заметок
				 memo и отобразить его на экран
</PRE>
<ul><a name=103></a><h2>ТЕКСТ ПРОГРАММЫ</h2></ul>
<PRE>
1   :
2   # @(#)  mmm v1.0 Nroff command line with mm macros Author: Russ Sage
2а				   Командная строка nroff с макросами mm

4   if [ "$#" -eq 0 ]
5	 then echo "mmm: wrong arg count"   >&2
6		  echo "usage: mmm file [...]"  >&2
7		  exit 1
8   fi

10  LIST=""
11  for ARG in $*
12  do
13		  if [ ! -f $ARG ]
14			then echo "mmm: $ARG is not a regular file" >&2
15			else LIST="$LIST $ARG"
16		  fi
17  done

19  nroff -r0O -mm $LIST
</PRE>
<ul><a name=104></a><h2>ПЕРЕМЕННЫЕ СРЕДЫ ВЫПОЛНЕНИЯ</h2></ul>
<BL>
 <LI>	 ARG	 Содержит каждый позиционный параметр командной строки</LI>
 <LI>	 LIST	Содержит список проверяемых имен файлов</LI>
</BL>
	   <H3><b>ОПИСАНИЕ</b></H3>

				   <P><H3>ЗАЧЕМ  НУЖЕН КОМАНДНЫЙ ФАЙЛ mmm?</H3></P>

<P>	 Одним из фактов делового мира является работа с бумагами. Мы 
производим заметки,  письма,  контракты, документы, руководства и так 
далее.  Если  вы  знакомы  со стилем производства документации в системе
UNIX,  то ваши текстовые файлы в основном представлены в одном из 
форматов программы nroff.</P>
<P>	 Однако различные программы форматирования текстов служат  различным  
целям.  Имеется стандартный nroff и nroffс дополнениями,  такими
как макросы ms и mm.  Для подготовки графической информации и выполнения 
типографских работ разработана программа troff. Система AT&T имеет
целую программную среду под названием  Writers  Workbench,  и  система
Berkeley имеет аналогичные возможности.</P>
<P>	 Большинство наших задач по  написанию  каких-либо  текстов  может
быть сведено к нескольким стандартным форматам,  таким как письма, 
рукописи вообще, страницы руководств и так далее. Не так легко запомнить
опции команды nroff (или другой команды), которые следует использовать
в данном случае, да мы и не должны делать это. Наша команда mmm служит
иллюстрацией программы,  которую мы можем запускать всякий раз,  когда
нам нужен определенный формат.  Вы  можете  создать  несколько  версий
программы,  которые удовлетворяют вашим собственным нуждам при написании 
текстов.</P>
<P>	 Использование заготовленных заранее команд означает, что мы можем
делать полезную работу,  даже если некоторое время мы не выполняли работу 
определенного вида.  Мы также можем избежать многократных нажатий
на клавиши. Мастера UNIX'а периодически уединяются в своих горных убежищах,  
где  штудируют  справочные руководства в поисках полезных,  но
доселе незамеченных опций,  которые могут быть встроены в  программные
средства  для повседневной работы.  Если слишком некритично полагаться
на ваш текущий набор инструментальных средств, то можно пропустить полезные 
возможности.</P>

						  <H3> <CENTER>ЧТО ДЕЛАЕТ mmm?</CENTER></H3>

<P>	 Командный файл  mmm  -  это  интерфейсный  процессор  для команды
nroff. Под словом "интерфейсный" мы подразумеваем, что он обрабатывает
вызывающую командную строку и устанавливает все опции для вызова программы 
nroff. Некоторые из опций nroff жестко запрограммированы в вызове. 
Эти опции инициализируют отдельные части программы nroff.</P>
<P>	 Если вы не включаете никакие аргументы,  mmm распознает  это  как
ошибку и выводит синтаксическую подсказку. Обратите внимание, что если
вы передадите mmm такой аргумент,  как  -z,  то  этот  аргумент  будет
рассматриваться как имя файла,  а не как подлежащая передаче опция,  и
это снова вызовет ошибку.  Вторая ошибка не является фатальной,  в  то
время как первая фатальна.</P>
<P>	 После обработки всех аргументов программа nroff использует  имена
файлов в качестве файлов с входными данными. По умолчанию вывод производится 
в stdout (стандартный вывод). Обычно это экран вашего терминала, но вывод 
может быть переадресован или передан по конвейеру на устройство печати или 
куда-либо еще.</P>

<ul><a name=105></a><h2>ПРИМЕРЫ</h2></ul>

<PRE>  $ mmm nroffile | m</PRE>

<P>	 Запуск команды nroff применительно к файлу  nroffile,  вывод  
результата  на экран с передачей по конвейеру команде more.  Это полезно
при изучении утилиты nroff,  проведении экспериментов с различными 
командами и наблюдения за соответствующими результатами.</P>
<PRE>
	$ for F in proj.?
	do
			mmm $F > $F.rf
	done
</PRE>
<P>	 Обработка в цикле всех файлов,  имена которых содержат символьную
строку "proj.", за которой следует один символ. Это могут быть proj.1,
proj.2 и так далее по всему набору символов вплоть до proj.z,  proj.{,
proj.|, proj.} и proj.~, если считать, что у вас есть файлы, имена которых 
содержат эти символы.  Каждый файл обрабатывается, и выход nroff
перенаправляется в файл с таким же именем, дополненным символами .rf.</P>

<PRE>  $ mmm status[12] | lpr -o5</PRE>

<P>	 Обработка командой nroff файлов status1 и status2.  Выход в стандартный 
вывод передается по конвейеру программе lpr. Программа lpr является  фильтром 
и принимает или имена файлов в командной строке,  или
непосредственно данные,  передаваемые ей по конвейеру (но не то и другое сразу). 
Опция -o5 указывает lpr сместить страницу на 5 символов.</P>

<ul><a name=106></a><h2>ПОЯСНЕНИЯ</h2></ul>

<P>	 В строке 4 проверяется, равно ли нулю количество аргументов в 
командной строке.  Если да, в стандартный файл ошибок выдается сообщение
об ошибке. Выводится также синтаксическая подсказка, и mmm завершается
с плохим статусом.</P>
<P>	 Переменная LIST  инициализируется  нулевым значением в строке 10.
Обычно переменные интерпретатора shell и так в начале равны  нулю,  но
предварительная  установка значения является хорошим стилем программирования.
</P> 
<P>	Затем мы  обрабатываем  каждый  аргумент командной строки в цикле
(строки 11-17). Все аргументы должны быть именами файлов, поэтому каждый 
из них проверяется на то,  существует ли он как обычный файл. Если
это не файл, то в стандартный файл ошибок выводится сообщение об ошибке. 
Тем не менее программа не завершается. Не следует аварийно прекращать 
всю программу только потому,  что нет указанного файла.  Мы  пропускаем 
его и идем до конца списка аргументов. Это особенно актуально,
если данная команда используется как фоновая во время выполнения  другой 
работы. Пользователь скорее согласится с тем, чтобы было выполнено
побольше работы, чем не сделано вообще ничего. Это решение, принятое в
данной программе, и вы можете изменить его, если оно не подходит в вашей ситуации.
</P>
<P>	 Если имени  соответствует  допустимый  файл,  оно  добавляется  в
список хороших имен файлов. Этот список становится главным списком для
команды nroff.</P>
<P>	 После того как все аргументы проверены,  мы в строке 9  строим  и
выполняем командную строку nroff.</P>
<P>	 Опция -rO0 для nroff указывает макросам обработки рукописей  
(пакету mm) установить регистр,  который имеет дело с отступом текста,  в
состояние,  соответствующее отступу в 0 символов. Это значит, что весь
текст начинается с крайней левой позиции,  т.е.  выровнен слева. Путем
проведения экспериментов я обнаружил,  что левое  выравнивание  текста
программой nroff и установка отступа для принтера дает наиболее надежный 
вывод на печать.  В противном случае,  если вы  установите  отступ
текста в nroff и отступ в принтере, то может произойти настоящее столкновение,  
когда дело коснется вывода колонок в странице. Вы можете изменить это 
место, если ваши программы вывода или устройства печати ведут себя 
как-то иначе. Опция -mm указывает программе nroff просмотреть
библиотеку макросов обработки рукописей,  чтобы определить,  используются 
ли какие-либо из них во  входном  документе.  Эти  макросы  очень
большие и требуют много времени центрального процессора.  Если вам необходимо 
использовать их,  то вам потребуется  большой  компьютер  или
компьютер,  специально  предназначенный для этой цели,  чтобы добиться
хорошего времени получения результата.</P>
<P>	 Последним аргументом является $LIST.  В этой переменной находится
строка имен файлов,  разделенных пробелами. Эти имена помещаются в командную 
строку nroff. Можете быть уверенными, что в этом месте нет никаких ошибок.
</P>

<ul><a name=107></a><h2>ВОЗМОЖНЫЕ МОДИФИКАЦИИ</h2></ul>

<P>	 Поскольку все аргументы рассматриваются как имена  файлов,  то  у
нас нет способа передачи дополнительных команд пакету mm.  Наличие такой 
возможности было бы желательным, поскольку при экспериментировании
с командой nroff вам необходимо пробовать различные опции,  чтобы увидеть,  
как они действуют. Было бы тяжелой работой выполнять редактирование 
текста mmm,  чтобы добавить одноразовые опции, которые могут вам
никогда не понадобиться или опции, которые вы должны постоянно менять.</P>
<P>	 Один из путей достижения большей гибкости - посмотреть,  имеет ли
какой-либо аргумент дефис в качестве первого символа.  Если да, перехватить 
эту опцию и убрать ее из списка имен файлов.  После этого вы бы
имели список опций,  которые нужно  включить  в  командную  строку,  и
список имен файлов, подлежащих обработке.</P>
<P>	 Отметим, что место, занятое в нашем командном файле указанием пакета
  mm,  можно вместо этого заполнить ссылкой на другие макропакеты,
имеющиеся в вашей системе, например -ms или -me, в зависимости от нужного  
вам  формата.  Отказ  от поиска макросов,  которые вам не нужны,
ускорит обработку:  подробности вы найдете в документации по nroff или
troff.</P>

			  <a name=108></a><H2><CENTER>2.2.6. pall - печать всех файлов в дереве</CENTER></H2>


<hr>
ИМЯ:  pall
<hr>

	<P> pall	  Распечатка всех файлов в дереве каталогов</P>

<ul><h2>НАЗНАЧЕНИЕ</h2></ul>

<P>	 Находит все  файлы в заданном каталоге в соответствии с некоторым
критерием,  разбивает файлы на страницы и помещает  результат  в  один
файл, готовый к распечатке на принтере.</P>

<ul><a name=109></a><h2>ФОРМАТ ВЫЗОВА</h2></ul>

<PRE>	 pall [-t|-d] directory</PRE>

<ul><a name=110></a><h2>ПРИМЕР ВЫЗОВА</h2></ul>

<PRE>	 pall /usr/lib</PRE>

<P>	 Выводит на  печать  постранично  все  текстовые  файлы в каталоге
/usr/lib</P>

<ul><a name=111></a><h2>ТЕКСТ ПРОГРАММЫ</h2></ul>
<PRE>
1.  :
2   # @(#) pall v1.0 Print all files in a tree Author: Russ Sage
2а				   Печатает все файлы в дереве

4   if [ $# -eq 0 -o $# -gt 2 ]
5	 then echo "pall: wrong argument count"  >&2
6		  echo "usage: pall [-t|-d] dir"	 >&2
7		  echo "  -t text (default)"		 >&2
8		  echo "  -d dev (.c,.h,.mk,.s)"	 >&2
9		  exit 1
10  fi

12  NAME=""
13  if [ `echo $1 | cut -c1` = "-" ]
14   then case $1 in
15		-t)	 NAME=""
16				shift;;
17		-d)	 NAME="-name \"*.[chms]*\""
18				shift;;
19		 *)	 echo "pall: invalid arg $1"	>&2
20				echo "usage: pall [-t|-d] dir" >&2
21				echo " -t text (default)"	  >&2
22				echo " -d dev (.c,.h,.mk,.s)"  >&2
23				exit 1;;
24		esac
25  fi

27  echo "creating output file: /tmp/lpr$$"

29  eval find $1 -type f $NAME -print | sort | while read FILE
30  do
31		  if file $FILE |
32			egrep 'exec|data|empty|reloc|cannot open' >/dev/null 2>&1
33		  then continue
34		  else file $FILE > /dev/tty
35			   pr $FILE
36		  fi
37  done >> /tmp/lpr$$

39  echo "\nSend /tmp/lpr$$ to line printer (y/n): \c"
40  read CMD
41  if [ "$CMD" = "y" ]
42	then lpr /tmp/lpr$$
43  fi
</PRE>
<ul><a name=112></a><h2>ПЕРЕМЕННЫЕ СРЕДЫ ВЫПОЛНЕНИЯ</h2></ul>
<BL>
 <LI>	 FILE	  Содержит имя каждого файла, который должен быть  обработан в цикле while</LI>
 <LI>	 NAME	  Содержит строку поиска для определения местонахождения указанных файлов</LI>
 <LI>	 CMD	   Содержит команду выдачи результатов на принтер</LI>
</BL>

	   <H3><b>ОПИСАНИЕ</b></H3>

				  <CENTER><H3>ЗАЧЕМ  НУЖЕН КОМАНДНЫЙ ФАЙЛ pall?</H3></CENTER>


<P>	 Эта утилита  объединяет  концепции  обхода дерева файлов и вывода
содержимого файлов.  Даже когда файлы упрятаны в подкаталогах,  мы все
равно хотим найти их.  Нам необходима для этого утилита, которая обходит 
древовидную структуру файлов,  находит файлы нужного нам типа, готовит 
их к распечатке и ставит в очередь для вывода на принтер.</P>
<P>	 Такого рода утилита особенно полезна,  если исходные  тексты  или
файлы  с документацией хранятся в иерархическом дереве.  Дело осложняется 
тем, что обычно эти текстовые файлы смешаны с исполняемыми файлами 
(откомпилированными программами), файлами данных и, возможно, с архивными 
файлами. Необходимо иметь возможность отфильтровать все непригодные  для  
печати  файлы и подготовить текстовые файлы.  Должны быть
проверены все файлы с тем, чтобы ни один не был пропущен.</P>
<P>	 Для выполнения  всего этого процесса вручную требуется,  чтобы вы
по команде cd переходили в  каждый  уровень  дерева  файлов,  находили
текстовые файлы,  обрабатывали их (обычно командой pr системы UNIX или
каким-либо другим текстовым процессором) и распечатывали их. После выполнения  
всей  этой работы вы еще должны собрать все отдельные распечатки 
вместе в строго определенном порядке.  Это большая работа,  подверженная  
ошибкам со стороны человека.  Почему бы не позволить машине
выполнять эту работу?  Сейчас мы имеем концепции и средства, необходимые 
для создания такой утилиты.</P>
<P>	 В дополнение к возможности управления файлами,  pall также  может
управлять  устройством печати.  Обычно каждое задание,  поставленное в
очередь на выполнение к принтеру,  имеет заголовок, который печатается
первым.  Это значит,  что если вы поставили в очередь на печать десять
отдельных заданий,  то впереди каждого из них будет две-три  страницы,
которые должны быть убраны вручную.  Помножьте это на сотни файлов,  и
вы будете иметь кучу бумаг, которые должны быть выброшены.</P>
<P>	 Pall исключает эти потери,  поскольку все обработанные данные 
собираются в один большой текстовый файл. Когда вся обработка выполнена,
этот  один  файл может быть поставлен в очередь на печать или сохранен
для некоторых других целей. Единственное ограничение при таком подходе
заключается  в максимальном размере файла,  который вы можете создать.
Этот размер вычисляется умножением значения ulimit  на  размер  блока.
Например, мое значение ulimit равно 4096. Размер блока в данном случае
равен 512,  а не 1024. Максимальный размер файла равен 2097152. Вы можете 
вычислить это прямо с клавиатуры, как показано ниже:</P>
<PRE>
$ ulimit
4096
$ expr 4096 \* 512
2097152
</PRE>
	 <P>Этого значения достаточно для большинства случаев.</P>

						   <CENTER><H3>ЧТО ДЕЛАЕТ pall?</H3></CENTER>


<P>	 Командный файл pall предназначен для поиска указанных файлов, 
обработки  их  командой  UNIX  pr и сборки всех результатов в один файл.
После того как все исходные файлы будут обработаны  командой  pr,  вам
будет задан вопрос о том,  хотите ли вы поставить выводной файл в очередь 
на печать к принтеру.  Результирующий файл сохраняется в каталоге
/tmp, где его можно использовать для других целей или удалить.</P>
<P>	 Опциями pall являются -t и -d. Опция -t используется по умолчанию
и нет необходимости ее указывать. Она предназначена для документации и
указана в командной строке,  чтобы более ясно показать действие, которое 
будет выполнено.</P>
<P>	 Если выбрана текстовая опция,  ищутся  все  файлы  в  древовидной
структуре и затем отбираются только текстовые файлы.  Если указана опция 
разработки -d (development),  то ищутся только файлы,  связанные с
разработкой программ.  Затем эти файлы отфильтровываются с целью получения 
текстовых файлов. Считается, что к разработке программ относятся
файлы,  имена  которых  имеют вид *.c для исходных файлов на языке Си,
*.h для включаемых файлов заголовков, *.mk для файлов построения программ 
(makefiles) и *.s для исходных файлов на ассемблере.  Если требуются 
какие-либо другие шаблоны,  то такие символы могут быть легко помещены 
в текст программы.</P>
<P>	 Прежде чем начнет выполняться поиск файлов,  на  экран  выводится
имя временного файла,  чтобы вы знали, как обратиться к нему после завершения 
выполнения команды. Все результаты, полученные после обработки  файлов,  
направляются в этот один файл.  Командный файл pall также
выводит на экран сообщения,  когда он обрабатывает файлы. Вывод файлов
выполняется  в  реальном времени по мере обработки файлов.  Распечатка
производится при помощи обычной команды UNIX'а file.  По распечатке вы
можете судить о том, файлы какого типа обрабатываются в данный момент.
Если какой-либо норовистый файл проскользнет,  то вы  знаете,  где  он
размещен и какого он типа. Это делает отладку гораздо более простой.</P>
<P>	 Для файлов выполняется обработка,  которая является действием  по
умолчанию команды pr.  Она разбивает файл на страницы и ставит заголовок 
в начале каждой страницы. Заголовок содержит дату, имя файла и номер 
страницы. Нет никакого иного способа передать заголовок командному
файлу pall во время его работы,  поскольку он предполагает, что вы хотите 
знать имя каждого файла таким,  как оно есть на диске.  Изменение
строки заголовка вызвало бы только неприятности и дополнительную работу.
</P>
<P>	 Способ вызова pall влияет на формат имени файла в заголовке. Если
вы  вызвали pall,  используя абсолютное имя каталога,  то в распечатке
используются полные маршрутные имена.  Если вы вызвали pall с  относительными 
маршрутными именами,  то они и используются при выводе на печать. 
Внутри pall используется команда find системы UNIX. Команда find
использует данные из командной строки, т.е. те, которые ввел пользователь. 
Выводимый заголовок изменяется в зависимости от того, что указа-
но  в  командной  строке,  которую использует find.  Если вы вызываете
pall, используя следующую командную строку, то заголовок содержит полное 
маршрутное имя:</P>

<hr>
<PRE>
|
|	$ pall /usr/include
|
|	May 5 10:39 1986 /usr/include/a.out.h Page 1
|			  .
|			  .
|			  .
|	May 5 10:39 1986 /usr/include/ar.h Page 1
|			  .
|			  .
|			  .
</PRE>
<P>	 Если вы вызываете pall с помощью относительной нотации,  то имена
файлов также являются относительными,  что не очень хорошо. Если у вас
есть несколько каталогов,  в которых имеются одинаковые имена  файлов,
то вы не сможете быть уверены,  что смотрите на правильную распечатку.
Вот как это может выглядеть:</P>

<hr>
<PRE>
|
|	$ cd /usr/include
|	$ pall .
|
|	May 5 10:39 1986 ./a.out.h Page 1
|			  .
|			  .
|			  .
	 May 5 10:39 1986 ./ar.h Page 1
			   .
			   .
			   .
</PRE>
<ul><a name=113></a><h2>ПРИМЕРЫ</h2></ul>

<PRE>  $ pall /usr/include</PRE>

<P>	 Выводит ВСЕ файлы заголовков.  Сюда включаются файлы заголовков в
подкаталоге  sys  и  во всех других каталогах,  которые могут располагаться 
ниже каталога /usr/include.  Это и есть причина, по которой был
написан  командный  файл  pall.  Он создает один огромный листинг всех
файлов заголовков в отсортированном  порядке  с  печатью  в  заголовке
страниц полного имени.</P>

<PRE>  $ pall $HOME/src</PRE>

<P>	 Обходит все каталоги, находящиеся ниже каталога исходных текстов,
и распечатывает все файлы.</P>

<ul><a name=114></a><h2>ПОЯСНЕНИЯ</h2></ul>

<P>	 В самом начале производится проверка на наличие ошибок в  командной  
строке.  Если в ней нет аргументов или их больше двух,  выводится
сообщение об ошибке,  синтаксическая подсказка и программа завершается
с неудачным статусом возврата.</P>
<P>	 В строке 12 инициализируется переменная NAME. Это действие 
выполняется по умолчанию,  поэтому данная строка дает возможность не 
указывать опцию в командной строке. Оператор if в строке 13 означает: "Если
первым символом первого аргумента является дефис", то нужно проверить,
какая это опция.</P>
<P>	 Если установлена  опция  -t,  то переменная NAME инициализируется
нулевым значением,  что совпадает с действием по умолчанию, поэтому на
самом деле ничего не меняется.  Затем эта опция удаляется из командной
строки.</P>
<P>	 Если установлена  опция  -d,  то переменная NAME инициализируется
для поиска символьной строки,  соответствующей именам файлов программной 
разработки. Обратите внимание, что двойные кавычки внутри оператора 
экранированы,  т.е.  впереди них стоят символы наклонной черты. Командный  
интерпретатор shell воспринимает кавычки вокруг строки поиска
на первой фазе синтаксического разбора без отмены присвоения,  тем самым 
оставляя двойные кавычки последующей команде find.</P>
<P>	 Если опцией является  что-либо  другое,  выводится  сообщение  об
ошибке и программа завершается.</P>
<P>	 В строке 27 выводится сообщение о том,  какой файл  содержит  результаты 
работы. Сам этот оператор не создает файл. Он только печатает
имя файла, который будет создан позже.</P>
<P>	 Строки 29-43  -  это  главный цикл всей программы.  Оператор find
должен быть повторно проанализирован командой eval, поскольку переменная 
NAME содержит нужные нам данные.  Если бы не было команды eval, то
подстановка символьных строк выполнялась бы неправильно. Обратите внимание,  
что переменной NAME не требуются кавычки в строке 24.  Они уже
есть в переменной NAME, так как были обработаны командой eval.</P>
<P>	 Оператор find  находит  только  файлы типа f,  или обычные файлы,
т.е.  не каталоги и не символьные или блочные  устройства.  Здесь  под
"обычными  файлами" понимается,  что они еще могут быть файлами данных
или исполняемыми.  Если значение переменной NAME равно  нулю,  оно  не
влияет  на  командную строку.  Если NAME содержит символы файлов программной 
разработки, то они становятся частью команды find при выполнении команды eval. 
Это накладывает ограничения на шаблон поиска команды
find.  Когда файлы найдены,  их имена выводятся в  стандартный  вывод.
Стандартный вывод по конвейеру передается команде sort,  располагающей
имена файлов по порядку.  Это сильно помогает при сортировке горы  выводной  
информации.  Чтение  кипы распечаток толщиной в один фут может
свести с ума кого угодно.</P>
<P>	 Отсортированные имена по конвейеру передаются в цикл while, который 
читает имена файлов по одному.  Обратите внимание, что стандартный
вывод для всего цикла while переадресовывается во временный файл,  что
облегчает сборку всех выходных результатов в одном месте вместо  переадресации 
каждого вызова команды в файл.</P>
<P>	 Для каждого подходящего  файла  выполняется  проверка  в  строках
31-36.  Проверка начинается с запуска команды file. Выход file по конвейеру 
передается команде egrep, которая ищет тип файла, соответствую-
щий  набору нескольких выражений.  Если какое-либо выражение подходит,
то нам не нужно обрабатывать этот файл.  Это не текстовый файл,  и его
нельзя  вывести  на  принтер.  Во многих случаях файлы данных содержат
большое количество символов прогона формата, которые выталкивают страницу 
после каждой пары символов.  Если вы не будете находиться рядом с
принтером,  когда  печатаются  такие  файлы,  то  вы  можете  получить
листинг,  занимающий половину ящика бумаги,  затратив целый лес на ненужную 
работу.</P>
<P>	 Нам не  нужен  выход команды egrep,  а только ее статус возврата.
Если egrep обнаруживает одно из указанных ей выражений,  она  завершается 
со статусом успеха,  или 0. Тем самым проверка if включает выполнение 
оператора then, который в данном случае выводит нас из конструкции  
if-then-else  и  продолжает  цикл while,  пропуская таким образом
файл.</P>
<P>	 Если же  egrep  не  обнаружила  ни  одну  из указанных символьных
строк,  то выполнение продолжается с оператора else, который выполняет
еще одну команду file и переадресовывает ее вывод на устройство с именем 
/dev/tty.  Это универсальное имя устройства,  которое гарантирует
вам вывод на экран вашего терминала.  UNIX обеспечивает,  что указание
/dev/tty обходит любые команды  переадресации  вывода,  действующие  в
данный момент. Поскольку стандартный вывод уже переадресован для всего
цикла while,  то нам нужно попасть на устройство /dev/tty, чтобы вывод
шел  на экран терминала,  а не в файл печати.  Отображение на терминал
имени обрабатываемого файла позволяет пользователю знать,  какой  файл
будет добавлен к распечатке.</P>
<P>	 Если файл удовлетворяет нашим критериям, он обрабатывается командой  
pr.  Результат направляется в стандартный вывод,  который переадресован 
циклом while так,  чтобы результат четко попадал в один  файл.
Отметим, что нам нужно поставить символ добавления в файл вывода (>>).
В противном случае мы получим запись на место существующего файла  печати,  
а значит в файле печати будет находиться только последний обработанный файл.
</P>
<P>	 После того как все файлы обработаны, задается вопрос о том, хотите 
ли вы вывести результирующий файл на печать.  Предлагается ответить
на этот вопрос "да" (yes) или "нет" (no),  однако в программе проверяется 
только положительный ответ (yes).  Это значит,  что нажатие любой
клавиши трактуется как ответ "no", кроме клавиши "y", означающей "да".
Ответ пользователя читается с клавиатуры,  и проверяется,  является ли
он символом "y".  Если да,  то файл ставится в очередь на печать. Если
нет, дальнейшая проверка не производится и командный файл завершается.
</P>
<P>	 Отметим, что запрос о выводе на печать поступил в стандартный вывод.  
Переадресация вывода действовала только во  время  работы  цикла
while,  а затем прекратилась.  Так было сделано потому, что цикл while
был фактически еще одним порожденным shell-процессом (subshell) и  
переадресация  действовала  только в этом те внимание,  что  маршрутная-
установите значения переменных вне цикла,  а затем измените их  внутри
цикла. После завершения цикла переменные по-прежнему имеют свои первоначальные 
значения,  а не измененные в цикле значения. Измененные значения  
касались переменных порожденного интерпретатора shell,  которые
исчезли, когда порожденный shell завершился. Переменные интерпретатора
shell могут передавать значения только вниз, порожденным процессам, но
процессы-потомки не могут передавать значения переменных вверх,  родительскому 
процессу. Обычно передача значений переменных поддерживается
при помощи какого-либо файла,  в котором хранятся  данные  для  обмена
между родительским процессом и процессом-потомком.</P>


<ul><a name=115></a><h2>УПРАВЛЕНИЕ ВЫВОДНЫМИ ФАЙЛАМИ БОЛЬШИХ РАЗМЕРОВ</h2></ul>

<P>	 Как мы уже отмечали,  общий размер выводного файла ограничен. 
Напомним,  что команда find проходит все дерево каталогов вниз до  конца
по  всем поддеревьям,  начиная с каталога,  имя которого указано в 
командной строке.  Если вы находитесь на вершине очень глубокого дерева,
то обрабатываться могут буквально сотни файлов. Поскольку вы ограничены 
максимальным размером выводного файла,  вы можете обработать только
ограниченное число файлов.  Конечно, количество файлов, которое вы можете 
обработать,  зависит также от того, насколько велики входные файлы.
</P>
<P>	 Если выводной файл достигает своего  максимума,  все  добавляемые
после этого данные теряются. Потеря данных весьма болезненна, и обычно
требуется некоторое время,  чтобы ее обнаружить. В медленно работающей
системе  попытка  обработать  большое  дерево,  например  все исходные
тексты системы UNIX,  может занять целый час и даже больше, прежде чем
выходной файл заполнится. Это означает, что вы должны находиться рядом
и следить за тем,  когда файл переполнится.  Если он все-таки переполнился,  
вы должны все выбросить и начать сначала.  Это также означает,
что вы должны перейти вниз по дереву.  Это может быть проблемой в 
сбалансированных деревьях.</P>
<P>	 Например, рассмотрим каталог /usr/lib. Этот каталог содержит мно-
го  файлов на первом уровне и много каталогов первого уровня.  Если бы
мы не обработали все файлы каталога /usr/lib за одну попытку, мы должны  
были бы пойти вниз по подкаталогам каталога /usr/lib.  Попытки делать 
это вручную и запускать pall в каждом подкаталоге заняли бы много
времени  и  могли  бы привести к ошибкам с вашей стороны.  Кроме того,
pall допускает указание только одного имени каталога,  что приведет  к
получению большого количества распечаток и к путанице при их сортировке.
</P>
<P>	 Что же делать?  Радикальным решением является увеличение значения
ulimit.  Вы можете сделать это либо с помощью программы на  языке  Си,
использующей  системный  вызов  ulimit,  либо командой shell'а ulimit.
Техника выполнения такой работы представлена в главе 7.</P>

<ul><a name=116></a><h2>ВОЗМОЖНЫЕ МОДИФИКАЦИИ</h2></ul>

<P>	 Возможно, вы захотите добавить свои собственные штрихи в  некоторых 
местах командного файла.  Первым местом является то,  где указываются 
символы поиска файлов программной разработки.  Символы, использованные  
нами  -  это  наиболее  употребимые  суффиксы в UNIX.  Если вы
используете не Си и ассемблер,  а другие языки,  то вы можете добавить
соответствующие символы.</P>
<P>	 Следующим местом, где могут быть сделаны дополнения, являются опции, 
которые может понимать pall. Вам могут понадобиться файлы с определенными 
именами или определенными типами, например, файлы nroff. Эти
опции могут быть легко добавлены в оператор case, что улучшит команду.
</P>
<P>	 Последним местом возможных изменений является тип файлов, которые
нужно пропускать.  Символьная строка для команды egrep покрывает большинство 
важных нетекстовых типов файлов.  В вашей системе  могут  быть
какие-то особые типы или же имена могут быть другими. Если вам необходимо 
дополнить строку,  сделайте это.  Команда egrep может  обработать
довольно много информации.  Я не знаю ее ограничений. Возможно, вы обнаружите 
их,  просматривая исходный текст утилиты egrep.  Если получается слишком 
длинная строка и не помещается на экране, ничего страшного. Перенос на 
следующие строки экрана не опасен, пока общее количество  символов  не  
превысит 255.  Опасно только указывать переадресацию
символьной строки if на нулевое устройство в следующей  после  команды
egrep строке.  Кажется, что все работает правильно, но это не так. 
Переадресация должна указываться в той  же  строке,  где  стоит  команда
egrep.</P>
<P>	 В данной главе сделано очень много.  Наиболее важно то, что 
получено множество новых идей, которые можно использовать при эксплуатации
программной среды и просмотре файлов любого типа. В следующей главе мы
углубимся  в  рутинную  работу  по  ежедневному сопровождению файлов и
используем изученные средства, чтобы они облегчили нашу жизнь.</P>
<hr>
<A HREF="chap01.htm">Назад.</A>
<A HREF="chap03.htm">Вперёд.</A>
<A HREF="chap00.htm#toc2.1">Оглавление.</A><hr>

<BR>
<table cellspacing="2" cellpadding="2" border="0">
<tr VALIGN=TOP>
<td>
<!-- BEGIN MGUL-COUNTER CODE -->
<img src="http://ns.mgul.ac.ru/cgi-bin/counter.cgi?Linux" border=0 height=31 width=88 alt="LSCS">
<!-- END MGUL-COUNTER CODE -->
</td>
	<td rowspan="2">
<!--begin of Top100-->
<a href="http://top100.rambler.ru/top100/">
<img src="http://counter.rambler.ru/top100.cnt?124566" alt="Rambler's Top100" width=1 height=1

border=0></a>
<!--end of Top100 code-->

<!--begin of Top100 logo-->
<a href="http://top100.rambler.ru/top100/">
[AD-SIZE]<AD- ://images.rambler.ru/top100/banner-88x31-rambler-blue3.gif" alt="Rambler's Top100"

width=88 height=31 border=0></a>
<!--end of Top100 logo -->
</td>
<td>
<!--TopList COUNTER--><script language="JavaScript"><!--
d=document;a='';a+=';r='+escape(d.referrer)
js=10//--></script><script language="JavaScript1.1"><!--
a+=';j='+navigator.javaEnabled()
js=11//--></script><script language="JavaScript1.2"><!--
s=screen;a+=';s='+s.width+'*'+s.height
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth)
js=12//--></script><script language="JavaScript1.3"><!--
js=13//--></script><script language="JavaScript"><!--
d.write('<a href="http://top.list.ru/jump?from=61405"'+
' target=_top><img src="http://top.list.ru/counter'+
'?id=61405;t=99;js='+js+a+';rand='+Math.random()+
'" alt="TopList"'+' border=0 height=18 width=88></a>')
if(js>11)d.write('<'+'!-- ')//--></script><noscript><a
target=_top href="http://top.list.ru/jump?from=61405"><img
src="http://top.list.ru/counter?js=na;id=61405;t=99"
border=0 height=18 width=88
alt="TopList"></a></noscript><script language="JavaScript"><!--
if(js>11)d.write('--'+'>')//--></script><!--TopList COUNTER-->
</td>
</tr>
</TABLE>
</body></html>
