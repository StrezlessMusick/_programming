<html>
<head>
<title>ГЛАВА 1. Среда системы UNIX</title>
			<style type="text/css">
A.noneline { font-family: Arial, Serif; text-decoration: none; }
FONT.arial { font-family: Arial, Serif; }
TD.arial   { font-family: Arial, Serif; }
TH.arial   { font-family: Arial, Serif; }
PRE		{ font-family: Courier; color: navy; }
SAMP	   { font-family: Monospace; color: navy; }
TT		 { font-family: Monospace; color: navy; }
VAR		{ font-family: Monospace; color: navy; }
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<basefont size="3">
<center>
<table width=100% border=0 cellpadding=0>
<table cellspacing=0 cellpadding=0 border=0 background="../pic/logo1.jpg" width="100%">
<tr valign=top><td class=arial><a href="http://www.mgul.ac.ru/"><img height=80 width=109 src="../pic/logo.gif" alt="Server of laboratory of space computer science MGUL" border=0></a><br>
</td>
<td align=right class=arial>
<font size="-2">
141001 г.Мытищи МО<br>
<a class=noneline href="http://www.mgul.ac.ru">Ул.Институтская д:1 ком:101</a><br>
(095) 588-32-09, 588-55-62<br>
E-mail: <a class=noneline href="mailto:T-Alex@mgul.ac.ru?Subject='From page topic CIT-FORUM'">T-Alex@mgul.ac.ru</a></font>
</tr>
<tr>
<th colspan=2 class=times>
<font color=#000080 size=2><a href="http://www.mgul.ac.ru" class=noneline>Сервер Лаб. Космической информатики каф.ВТ</a> Московский Государственный Университет Леса</font>
<hr noshade>
</th>
</tr>
</table>
</center>
<A HREF="chap00.htm">Назад.</A>
<A HREF="chap02.htm">Вперёд.</A>
<A HREF="chap00.htm#toc1.1">Оглавление.</A><hr>
<ul><a name=5></a><h1><CENTER><FONT COLOR="##69BCCB"> * ГЛАВА 1. Среда системы UNIX * </FONT></CENTER></h1></ul>
<BL>
<P> <H2><LI><A NAME="toc1"></A> <A HREF="chap01.htm#ss1">Введение</LI></H2>
 <H2><LI><A NAME="toc2"></A> <A HREF="chap01.htm#ss2">Многообразие сред системы UNIX</LI></H2>
<BLOCKQUOTE><H5><BL>
 <LI> <A HREF="chap01.htm#9"> УРОВЕНЬ 0 - АППАРАТНЫЕ СРЕДСТВА</LI>
 <LI> <A HREF="chap01.htm#10">УРОВЕНЬ 1 - МИКРОКОМАНДЫ</LI>
 <LI> <A HREF="chap01.htm#11">УРОВЕНЬ 2 - УСЛОВНАЯ МАШИНА</LI>
 <LI> <A HREF="chap01.htm#12">УРОВЕНЬ 3 - ЯДРО</LI>
 <LI> <A HREF="chap01.htm#13">УРОВЕНЬ 4 - ОПЕРАЦИОННАЯ СИСТЕМА</LI>
 <LI> <A HREF="chap01.htm#14">УРОВЕНЬ 5 - КОМПИЛЯТОРЫ</LI>
 <LI> <A HREF="chap01.htm#15">УРОВЕНЬ 6 - ПРИКЛАДНЫЕ ПРОГРАММЫ</LI>
 <LI> <A HREF="chap01.htm#16">УРОВЕНЬ 7 - КОМАНДНЫЕ ФАЙЛЫ</LI>
</BL></H5></BLOCKQUOTE>
 <H2><LI><A NAME="toc3"></A> <A HREF="chap01.htm#ss3">Ваш регистрационный каталог: как сделать его комфортным</LI></H2>
<BLOCKQUOTE><H5><BL>
 <LI> <A HREF="chap01.htm#18">ЧТО ТАКОЕ СОСЕДСТВО?</LI>
 <LI> <A HREF="chap01.htm#19">ПЛАНИРОВКА РЕГИСТРАЦИОННОГО КАТАЛОГА</LI>
 <LI> <A HREF="chap01.htm#20">ФАЙЛЫ В РЕГИСТРАЦИОННОМ КАТАЛОГЕ</LI>
 <LI> <A HREF="chap01.htm#21">ФАЙЛЫ System V</LI>
 <LI> <A HREF="chap01.htm#22">ФАЙЛЫ 4.2 BSD</LI>
 <LI> <A HREF="chap01.htm#23">ТРЮКИ С ГЛАВНЫМИ ФАЙЛАМИ</LI>
 <LI> <A HREF="chap01.htm#24">КАТАЛОГИ</LI>
 <LI> <A HREF="chap01.htm#25">АНАЛИЗ ПРИМЕРА ФАЙЛА НАСТРОЙКИ СИСТЕМЫ</LI>
 <LI> <A HREF="chap01.htm#26">КАК РАБОТАЕТ .profile</LI>
 <LI> <A HREF="chap01.htm#27">ПОСТРОЧНЫЙ РАЗБОР ПРИМЕРА ФАЙЛА НАСТРОЙКИ</LI>
</BL></H5></BLOCKQUOTE>
 <H2><LI><A NAME="toc4"></A> <A HREF="chap01.htm#ss4">Теории относительности a la UNIX</LI></H2>
<BLOCKQUOTE><H5><BL>
 <LI> <A HREF="chap01.htm#29">ОБЩАЯ СИСТЕМНАЯ СРЕДА</LI>
 <LI> <A HREF="chap01.htm#30">ОБЩЕЕ ФАЙЛОВОЕ ДЕРЕВО</LI>
 <LI> <A HREF="chap01.htm#31">ПЕРВЫЙ СЛОЙ</LI>
 <LI> <A HREF="chap01.htm#32">ВТОРОЙ СЛОЙ</LI>
</BL></H5></BLOCKQUOTE>
 <H2><LI><A NAME="toc5"></A> <A HREF="chap01.htm#ss5">Жизнь системы UNIX: некоторые метафоры</LI></H2>
</BL></P>

<ul><a name=6></a><h2>СРЕДА СИСТЕМЫ UNIX</h2></ul>

<A NAME="ss1"><ul><a name=7></a><h2>ВВЕДЕНИЕ</h2></ul>

<CITE><P>
 В данной главе рассматривается среда, которая существует в систе
ме UNIX и вокруг нее. Освещение всех аспектов среды UNIX было бы слиш
ком громоздкой задачей и выходит за пределы данной книги. Даже отдель
ным утилитам, таким как fsdb и sdb, нужны свои собственные книги, что
бы отдать им должное.  Мы пытаемся дать читателю  начальные  сведения,
философию  и ощущение системы UNIX,  что лежит в основе исследований и
инструментов, представленных в этой книге.</P></CITE>
<P>	 Читая эту главу,  вы,  возможно,  захотите прочитать (или перечитать) 
команды profile(4),  environ(5), term(5), termcap(5) и termio(7)
в руководствах по UNIX, чтобы ознакомиться с механизмами, которые пре
доставляет UNIX для установки рабочей среды.</P>
<P>	 Внутри системы  UNIX существует множество различных подсред.  Все
вместе они образуют общую картину, в виде которой мы представляем себе
UNIX.  Эта книга посвящена наиболее важным аспектам среды UNIX с целью
закладывания фундамента,  необходимого для понимания всей системы. Это
даст вам контекст,  в котором можно посмотреть на собственную работу в
системе, независимо от того, являетесь вы пользователем, программистом
или администратором системы.</P>
<P>	 В данной главе рассматриваются различные среды  в  компьютерах  с
теоретической  точки зрения,  описывается "домашняя" среда и методы ее
установки,  способы использования условных  обозначений  и  глобальная
среда.</P>


<A NAME="ss2"><ul><a name=8></a><h2>"МНОГООБРАЗИЕ СРЕД"</h2></ul>

<P>	 Каждая компьютерная система поддерживает  много  различных  сред.
Эти  среды  используются  как строительные блоки для создания функциональных 
рабочих систем. Различные уровни необходимы как для сокращения
объема  работы по управлению машиной,  так и для построения такого интерфейса,  
чтобы мы могли использовать компьютер на относительно высоком, удобном для человека уровне.
</P>
<P>	 Мы рассматриваем эту модель, так как она помогает выстроить в ряд
уровни, на которых мы можем работать. Имея больше знаний о том, где мы
находимся в системе, и о том, как она функционирует вокруг нас, мы можем  
легче строить растущие абстрактные модели на вершине тех моделей,
которые уже  имеются.  Компьютеры  -  это  фактически  рабочие  модели
абстракций,  так что чем больше мы понимаем модели, тем лучше мы можем
использовать их для упрощения и ускорения нашей работы.</P>
<P>	 Многообразие моделей на рис.1-1 . демонстрирует различные уровни,
функционирующие внутри компьютера.  Нижний слой - это стартовая точка,
от которой многообразие растет вверх.  Каждый уровень строится на предыдущем 
и используется для поддержки уровня,  расположенного над  ним.
Для  каждого более высокого уровня среда более объемна и более "виртуальна" 
в том смысле,  что имеет  место  меньше  условных  ограничений.
Верхние  уровни  используют для своей работы нижние и,  таким образом,
скрывают подробности,  необходимые для работы этих нижних уровней.  Мы
можем создать модели высокого уровня, которые работают на машине более
низкого уровня, не зная ничего о нижних уровнях.</P>

<P>	 Давайте бросим беглый взгляд на уровни модели и поговорим о  том,
какими из них оперирует данная книга.</P>

<PRE>
						Рис. 1-1
				Многообразие компьютерных сред
<hr>

\				L7				/ Командные файлы  (scripts)
 \________________________________/
  \			  L6			  / Прикладные программы,
   \____________________________/  интерпретатор команд, языковые генераторы
	\			L5			/ Компилятор
	 \________________________/
	  \		  L4		  / Операционная система
	   \____________________/
		\		L3		/ Ядро
		 \________________/
		  \	  L2	  / Условная машина, ассемблер
		   \____________/
			\	L1	/ Микропрограммы
			 \________/
			  \  L0  / Логические схемы, аппаратные средства
			   \____/
</PRE>
<hr>


<ul><a name=9></a><h2>УРОВЕНЬ 0 - АППАРАТНЫЕ СРЕДСТВА</h2></ul>

<P>	 На самом нижнем уровне находятся аппаратные средства и логические
цепи.  Этот  уровень  определяет способ хранения и обработки данных во
всех аппаратных средствах.  Поскольку технология изготовления кремниевых  
микросхем  продолжает развиваться,  этот уровень становится физически 
меньше и проще,  тогда как скорости запоминания и обработки продолжают  расти.  
На этом уровне компонентами являются центральный процессор (ЦП), память, 
микросхемы поддержки и системная шина.</P>
<P>	 Отметим, что хотя прогресс на этом уровне продолжается, это вызывает 
очень малые изменения на верхнем слое пирамиды. Философия системы
UNIX состоит в том, чтобы изолировать низкоуровневый аппаратный слой и
обеспечить единообразные интерфейсы к нему, которые не нуждаются в изменениях  
"наверху".  Верхний слой даже не должен знать о нижнем слое.
Это не значит, что события в мире аппаратуры не важны в реальном мире,
ведь   противоречия  реального  мира  влияют  на  скорость  и  емкость
ресурсов, не говоря уже об их стоимости.</P>

<ul><a name=10></a><h2>УРОВЕНЬ 1 - МИКРОКОМАНДЫ</h2></ul>

<P>	 Этот уровень во многом похож на язык программирования.  Он  является 
инструментом,  который использует архитектор системы для создания
"родного" машинного языка.  Машинный язык сообщает  аппаратуре,  какую
конкретную команду следует выполнить.</P>
<P>	 В начале эволюции ЦП большинство наборов  команд  были  аппаратно
кодированными. Это значит, что когда ЦП получал команду, декодирование
и выполнение производилось непосредственно цепями  в  кремниевой  микросхеме. 
Благодаря прогрессу в технологии ЦП, некоторые микросхемы мо-
гут быть программируемыми на уровне исполнения команд,  что  позволяет
конструкторам  создавать  и  реализовывать новые наборы команд с минимальными усилиями.
</P>

<ul><a name=11></a><h2>УРОВЕНЬ 2 - УСЛОВНАЯ МАШИНА</h2></ul>

<P>	 Данный уровень обеспечивает трансляцию из мнемоник языка  ассемблера  
в коды операций и данные машинного языка.  Язык ассемблера - это
некоторая англо-подобная нотация, которая облегчает человеку понимание
и управление работой компьютеров.</P>
<P>	 Условная машина поддерживается ассемблером. Ассемблер может превращать 
идеи более высокого уровня в цепочки чисел,  которые могут быть
затем выполнены.  Наряду с ассемблером, применяются модели, помогающие
использовать  аппаратуру  компьютера.  Здесь мы можем определить такие
вещи, как стеки, вектора прерываний и периферийный ввод-вывод.</P>


<ul><a name=12></a><h2>УРОВЕНЬ 3 - ЯДРО</h2></ul>

<P>	 Ядро является следующим логическим продвижением вверх и концепцией,  
которую можно теперь реализовать программно на  условной  машине.
Ядро предоставляет среду,  поддерживающую еще большие абстракции,  чем 
те, что рассматривались до сих пор. Двумя наиболее важными абстракциями  
на уровне ядра являются управление процессами для мультипрограммирования 
и многозадачности,  и файловая система, которая управляет хранением, 
форматом, поиском файлов и т.п. Когда эти две области переплетаются,  
мы имеем базовую функцию многопользовательской машины и  ядро
операционной системы.</P>
<P>	 Одной из наиболее важных областей, которыми управляет ядро, является  
безопасность.  Проверки идентификации пользователя выполняются в
системных вызовах внутри ядра. Определенные механизмы используются ядром  
для  управления  безопасностью файлов,  устройств,  памяти и процессов.  
Единственный способ отключить механизмы безопасности состоит
в  изменении  исходного  кода ядра и перекомпиляции всей системы,  что
крайне нежелательно.</P>

<ul><a name=13></a><h2>УРОВЕНЬ 4 - ОПЕРАЦИОННАЯ СИСТЕМА</h2></ul>

<P>	 Данный уровень строится на ядре,  чтобы создать полную операционную среду.  
Потребность в дополнительных функциях системы можно  удов-
летворить  созданием автономных программ,  имеющих конкретное назначение. 
Таким образом, совокупность всех специфических функций определяет
операционную систему.</P>

<ul><a name=14></a><h2>УРОВЕНЬ 5 - КОМПИЛЯТОРЫ</h2></ul>

<P>	 Компилятор - это инструмент (или программа),  построенный на операционной  
системе для дальнейшей разработки более совершенных и более
мощных сред.  Новые среды могут предполагать еще  большие  абстракции,
чем на нижнем уровне, и делать больше допущений о том, что уже существует.  
Это делает возможным символические конструкции  более  высокого
уровня,  такие как структуры данных и управляющие структуры. Результатом 
является прикладная программа.</P>
<P>	 С помощью компилятора мы можем определить совершенно новый язык и
сделать его рабочим на компьютере,  написав  компилирующую  программу,
которая  читает этот новый язык.  Это открывает целые новые области во
взаимодействии человека с машиной.  Высокоуровневые языки могут воплощать 
различные подходы к решению задач,  например,  процедурную модель
или объектно-ориентированную модель, и в конце концов, очевидно, могут
достичь выразительной мощи разговорного языка типа английского.</P>

<ul><a name=15></a><h2>УРОВЕНЬ 6 - ПРИКЛАДНЫЕ ПРОГРАММЫ</h2></ul>

<P>	 В наше  время  прикладные программы могут означать массу разнообразных 
вещей. Мы можем предположить, что любая программа, которая сделана 
с помощью компилятора,  является прикладной программой. Примерами
возможных прикладных программ являются следующее поколение языков, интерпретаторов  
и генераторов прикладных программ.  Интерпретатор - это
программа, написанная на распространенном языке высокого уровня, которая 
может декодировать и исполнять другой синтаксис (или язык). Примером,  
который интересует нас в системе UNIX,  является командный  процессор shell. 
Это программа на языке Си, созданная для чтения и исполнения команд,  
записанных по правилам синтаксиса, определенных командным процессором shell.
</P>
<P>	 Генератор прикладных программ - это программа, написанная на языке 
высокого уровня. Она предназначена для получения достаточной информации от 
пользователя о его приложении и может  использовать  компиляторный язык, 
например Си, для написания прикладной программы, реализующей то,  
что требуется. Пользователь ничего не программирует. Выходом
генератора является рабочая программа.</P>
<P>	 UNIX не делает особых различий между уровнями.  Некоторые особенности  
системы,  например,  конвейеры,  являются частью ядра на нижнем
уровне.  Команда типа cat выполняет довольно простую функцию на уровне
операционной системы.  Нечто подобное ls напоминает простую прикладную
программу с относительно малым набором опций.  Большие программы,  подобные 
семейству roff, определенно являются полновесными приложениями,
а средства типа sed и awk являются фактически интерпретаторами небольших  
языков программирования.  Замечательной особенностью системы UNIX
является единообразие,  которое она вносит  в  этот  широкий  диапазон
функций.</P>

<ul><a name=16></a><h2>УРОВЕНЬ 7 - КОМАНДНЫЕ ФАЙЛЫ</h2></ul>

<P>	 Этот верхний  уровень  является  языком,  который  интерпретирует
программа /bin/sh (в случае командного  процессора  Bourne  shell).  Ее
синтаксис  поддерживает  полный язык программирования.  Хотя этот язык
лишен ряда встроенных структур и функций современного  языка  высокого
уровня,  он  имеет  все  необходимое  для написания полезных программ.
Большим плюсом является то,  что языку командного процессора доступны в
качестве внешних функций любые средства,  утилиты и программы, которые
имеются в системе UNIX.  Это значит, что алгоритмы, которые могут потребовать 
сто или более строк на языке низкого уровня типа Си, язык командного 
процессора может выразить в двадцать строк.  За  счет  потери
производительности, разумеется.</P>


<A NAME="ss3"><ul><a name=17></a><h2>ВАШ "РЕГИСТРАЦИОННЫЙ КАТАЛОГ"</h2></ul>

<P>	 Поскольку UNIX  создавалась  как  многопользовательская  система,
многое  сделано для того,  чтобы система была безопасной и удобной для
каждого  пользователя.  Вам  выделяется  определенная  часть  файловой
системы (т.е.  область на  диске),  которая является полностью вашей и
больше ничей. Вы можете заблокировать вашу область так, чтобы никто не
мог заглянуть вовнутрь, или же можете оставить ее открытой, чтобы другие 
люди могли читать эту область или писать в нее.</P>
<P>	 Помимо определения  вашего места в системе,  можно привязать "домашний" 
каталог (home-catalog) к вашим точным спецификациям.  "Регистрационный  
каталог" - это не только область файловой памяти,  но и вся
ваша среда. Можно установить переменные командного языка для определения путей 
по системе. Можно создать инструментарий, чтобы помочь вам в
работе.
</P>

<ul><a name=18></a><h2>ЧТО ТАКОЕ СОСЕДСТВО?</h2></ul>

<P>	 Во многих более  старых  мини-  и  микрокомпьютерах  среда  имеет
"плоскую"  файловую систему.  Это значит,  что все файлы размещаются в
одной огромной области хранения и нет логических разделов для их разграничения.  
Отсутствие разделов порождает массу файлов,  через которые
нужно пробраться,  когда вы хотите найти определенный элемент. Некоторые  
системы  имели  в  своих файловых системах групповые разделы,  но
обычно такие разделы были  различными  плоскими  файловыми  системами.
Время показало, что такой тип среды (или модели) - не лучшее решение.</P>
<P>Решение, которое использует UNIX,-  перевернутая  модель  дерева.
Корень  системы  находится  наверху,  а ветви растут в стороны и вниз.
Имеется один и только один корень наверху.  Ветви могут исходить в любом 
направлении и простираться вниз на любую глубину.  Кроме того,  вы
можете иметь присоединяемые ветви,  которые можно изъять из системы, а
затем вернуть обратно.  Они монтируются на существующую в системе древовидную структуру.
</P>
<P>	 Когда вы  регистрируетесь  в  системе,  вы можете попасть в любое
место древовидной структуры.  Регистрационный каталог  определяется  в
файле паролей. К ней можно обратиться по имени $HOME, которая является
одной из  предопределенных  переменных  командного  языка  для  вашего
использования.  Теперь  у  вас есть персональная древовидная структура
под этим именем каталога.  Она полностью ваша и может быть сделана недоступной 
для кого угодно, кроме корня. Вы можете организовать ваш регистрационный 
каталог ($HOME) любым приемлемым для вас способом.</P>

<ul><a name=19></a><h2>ПЛАНИРОВКА РЕГИСТРАЦИОННОГО КАТАЛОГА</h2></ul>

<P>	 Как только ваш регистрационный каталог присоединен к определенному  
месту дерева,  вы получаете полное управление структурой,  которая
существует ниже этого места. Вы можете оставить ее плоской или сделать
подобной  дереву.  Эта  структура  зависит фактически от ваших потребностей 
и энтузиазма в эксплуатации вашей собственной области.  Наибольшая  выгода 
для нас состоит в том,  чтобы использовать вашу "домашнюю"
среду для поддержки ваших работ и максимально уменьшить  объем  ручной
работы. В следующих двух главах описано множество средств, которые могут 
работать с вашей личной файловой системой.</P>
<P>	 <STRONG>На рис.1-2</STRONG>  показана древовидная структура вашего 
регистрационного каталога.  Эта планировка представляет каркас среды, который вы 
можете заполнить соответствующей информацией.</P>
<P>	 По мере того,  как растет ваше мастерство использования  системы,
вам могут понадобиться эти типы областей для размещения в них информации. 
Вы обнаружите также, что наш сценарий хранения информации предполагает 
движение по деревьям,  или их обход,  так что вам гарантируется
выгода от использования иерархической конструкции.</P>

<P>	 Давайте пройдемся по этой примерной структуре и определим, каковы
ее части.  Данная структура включает много файлов и каталогов,  но все
они имеют определенное назначение.  Возможно, вы не захотите использовать 
в точности эти имена, но вы получаете совет, какие типы категорий
могут встретиться и как использовать систему для поддержки этой структуры.
</P>
<P>	 Корнем этого дерева является регистрационный каталог, который определен  
в  пятом поле файла /ets/passwd.  Использование файла паролей
описано в passwd(4). Вот пример парольного входа автора:</P>
<PRE>
russ:.pDIPADYfIXBY:103:101:Russ Sage:/usr/russ:/bin/sh
</PRE>
<P>	 Слева направо  вы  видите   имя   пользователя   (russ),   пароль
(.pDI...),  идентификатор  пользователя  (103),  идентификатор  группы
(101), личный комментарий, имя регистрационного каталога (/usr/russ) и
командный процессор shell, получаемый при входе в систему (/bin/ sh).</P>

<ul><a name=20></a><h2>ФАЙЛЫ В РЕГИСТРАЦИОННОМ КАТАЛОГЕ</h2></ul>

<P>	 Файлы, описываемые ниже, разделяются на три категории: файлы, 
которые обычно присутствуют в вашей системе,  если вы работаете в System
V, файлы, которые имеются обычно в Berkeley 4.2, и файлы, которые 
создаются при использовании программ из настоящей книги.</P>

<ul><a name=21></a><h2>ФАЙЛЫ System V</h2></ul>

<P>	 Первый файл - это .news_time.  Дата этого файла соответствует тому,  
когда  вы последний раз читали новости в каталоге /usr/news.  Для
чтения новостей пользуйтесь командой news(1).  Эта команда выдает  новости, 
появившиеся позже даты создания файла .news_time.</P>
<P>	 Следующий файл - .profile.  Этот файл выполняется при каждой  
регистрации в интерпретаторе shell и может быть использован для привязки
вашей собственной среды.  В дальнейшем мы рассмотрим этот  файл  более
подробно.</P>
<P>	 Следующий файл - calendar (календарь).  Этот файл содержит даты и
сообщения. Команда calendar(1) читает в этом файле даты, очень близкие
к текущей дате.  Затем печатаются или посылаются вам по почте  сообщения.
</P>
<P>	 Последний файл - mbox,  ваш системный почтовый ящик.  Когда вы  с
помощью команды mail(1) сохраняете почту,  она направляется по умолчанию в mbox.
</P>

<ul><a name=22></a><h2>ФАЙЛЫ 4.2 BSD</h2></ul>

<P>	 Первым файлом здесь является .cshrc.  Это первая стадия настройки
системы на пользователя, выполняемой интерпретатором cshell. В системе
UNIX присутствие "rc" в имени файла означает "команды  запуска"  ("run
commands") или "запуск при загрузке" ("run on boot up")</P>.
<P>	 Файл .login является синонимом файла .profile интерпретатора  sh.
Этот  файл  содержит команды настройки на среду пользователя,  которая
вам нужна при регистрации в системе.</P>
<P>	 Следующий файл  - .logout.  Он выполняется,  когда вы выходите из
системы. Например, вы можете применить его для печати учетной информации,  
такой  как  время,  в  течение  которого  вы работали в системе,
используемый вами размер дискового пространства и  т.д.  System  V  не
имеет подобного файла.</P>
<P>	 Следующий файл - .msgsrc,  предназначенный  для  команды  msgs(1)
системы  Berkeley.  Файл .msgsrc содержит последний,  прочитанный вами
файл сообщений. Файлы сообщений хранятся в виде последовательно 
пронумерованных файлов в каталоге /usr/msgs.</P>

<ul><a name=23></a><h2>ТРЮКИ С ГЛАВНЫМИ ФАЙЛАМИ</h2></ul>

<P>	 Вот программы  и  файлы,  которые  вы можете разработать во время
использования данной книги.  Файл .lastlog содержит даты каждого вхождения 
в систему с вашими учетными данными. Программа, которая управляет этим файлом, 
называется lastlog и представлена в главе 5.</P>
<P>	 Следующий файл - .trashcan.  Это каталог, который временно хранит
файлы,  удаленные вами.  Если вы уверены,  что они вам не нужны, то их
можно удалить навсегда. Эта особенность рассмотрена в главе 3.</P>
<P>	 Последний файл - .phone.list.  Это ваша  личная  база  данных  со
списком телефонов. Она обслуживается командой phone (см. главу 5).</P>


<ul><a name=24></a><h2>КАТАЛОГИ</h2></ul>

<P>	 Первым каталогом является adm.  Он содержит административные файлы, 
которые вы можете иметь, например расписания, информацию о сотруд-
никах, встречах и т.д.</P>
<P>	 В каталоге bbs имеются подкаталоги для каждой "доски объявлений",
которую вы вызываете.  Когда вы обращаетесь к этим системам, вы имеете
место для размещения всех соответствующих файлов и данных. Необходимая
вам информация - это меню для системы, вспомогательный текст, загрузки
программ и общая информация, которая вас интересует.</P>
<P>	 Каталог bin содержит все инструментальные средства, которые у вас
есть. Это могут быть командные файлы или объектные модули откомпилированных 
программ. Подкаталог src не обязателен. В нем хранится исходный
код на языке Си для объектных модулей, имеющихся в bin, так что исходный 
текст для быстрой фиксации ошибок и изменения всегда под рукой.</P>
<P>	 Каталог doc  - это корень всех видов документации.  Подкаталогами
здесь могут быть формы,  письма,  записки,  разнообразная информация и
отчеты. Каждый подкаталог содержит определенные файлы в этих областях.</P>
<P>	 Каталог etc содержит любые системные или административные команды
и файлы, которыми вы пользуетесь. Если вы имеете административные обязанности,  
типичным содержимым этого каталога может быть резервная копия текущих 
конфигурационных файлов, используемых системой. Вы можете
сделать резервную копию файлов</P>
<PRE>
	 /.profile
	 /etc/bcheckrc
		 brc
		 checklist
		 gettydefs
		 group
		 inittab
		 motd
		 mountable
		 unmountable
		 passwd
		 profile
		 rc
	 /usr/lib/crontab
	 /usr/lib/uucp/L.sys
		 USERFILE
		 uudemon.day
		 uudemon.hr
		 uudemon.wk
</PRE>
или  любой другой информации о системе.</P>
<P>	 Каталог proj предназначен для специальных проектов, которые у вас
есть.  Скорее всего, вы назовете этот каталог не proj, а по имени проекта,  
например,  dev для разработки (development) или qa для чистовой
шлифовки (quality assurance).  Все данные, корреспонденция, документация  и  
исходный  код для каждой работы направляются в главный каталог
проекта. Конечно, у вас может быть более одного каталога проекта.</P>
<P>	 Следующий каталог - mail.  Это хорошее место для размещения вашей
почтовой корреспонденции от других людей,  использующих систему. Имена
файлов в этом каталоге являются пользовательскими. Например, если бы я
получил почту от Боба, то она находилась бы в файле с именем bob.</P>
<P>	 Каталог src  -  для всего исходного кода.  Логически сгруппируйте
ваш исходный код по подкаталогам, чтобы облегчить его поиск в будущем.
Возможными  подкаталогами  являются asm для ассемблерного кода,  c для
исходного кода на Си,  games (игры), misc (разное), script для командных  
файлов  и sys для любого исходного кода,  относящегося к системе.
(Если вы держите исходные тексты ваших личных инструментов в  каталоге
/bin/src, то здесь вы, возможно, продублируете их.)</P>
<P>	 Каталог sys - это склад информации,  имеющей отношение к системе.
Здесь  могут быть резервные копии критических системных файлов,  
документация по областям системы,  куски выводимой информации команд  who,
ps, uucp, регистрационных файлов или что-либо иное.</P>
<P>	 Последний каталог - tmp,  который является рабочей  областью  для
размещения временных файлов.  В основном все,  что находится в tmp, вы
можете в любое время удалить, и средство can, описанное в главе 3, помогает вам в этом.
</P>
<P>	 Отметим, что регистрационный каталог имеет минимальное количество
обычных  файлов.  Это уменьшает путаницу,  которая может происходить с
плоскими файловыми системами.  Каждый файл должен быть на своем месте,
но может быть размещен не только здесь.  Если возникает какой-либо род
задач,  когда файлы, связанные с этой задачей, могут быть перепутаны с
другими файлами, создайте отдельный каталог.</P>


<ul><a name=25></a><h2>АНАЛИЗ ПРИМЕРА ФАЙЛА НАСТРОЙКИ СИСТЕМЫ</h2></ul>

<P>	 Файл .profile, как следует из его названия (профилирование - 
формирование контура, очертаний), функционирует для установки и инициализации 
параметров системы,  которые вам нужны.  Сюда  входит  установка
терминалов, определение переменных, запуск программ и конфигурирование
исполняющей системы. Пример файла настройки можно найти в описании команды 
profile(4).  Рассмотрим .profile, используемый автором. Мы включили 
его на столь ранней стадии,  чтобы предложить вам коснуться понятий,  
которые  более подробно раскрываются далее в этой книге.  Не заботьтесь 
о понимании работы каждой части примера. Пока что просто сделайте 
мысленную отметку возможностей.  Ваш .profile может быть проще и
почти наверняка будет другим.</P>
<PRE>
1   # @(#).profile v1.0  Defines "home" on the system
										   Author: Russ Sage

3   CHOICE="ushort"
4   case $CHOICE in
5   ufull)   PS1="`uuname -l`> ";;
6   ushort)  PS1="`uuname -l|cut -c1-3`> ";;
7   graphic) PS1="^[[12mj^[[10m ";;
8   esac

10  LOGNAME=`logname`
11  HOME=`grep "^$LOGNAME:" /etc/passwd | cut -d: -f6`
12  MAIL=/usr/spool/mail/$LOGNAME
13  export LOGNAME HOME MAIL

15  HA=$HOME/adm
16  HBB=$HOME/bbs
17  HB=$HOME/bin
18  HD=$HOME/doc
19  HE=$HOME/etc
20  HM=$HOME/mail
21  HP=$HOME/proj
22  HSR=$HOME/src
23  HSY=$HOME/sys
24  HT=$HOME/tmp
25  HDIRS="HA HBB HB HD HE HM HP HSR HSY HT"
26  export $HDIRS HDIRS

28  P=/usr/spool/uucppublic/$LOGNAME; export P

30  CDPATH=.:..:$HOME:$HDIRS
31  PATH=.:/bin/:/usr/bin:/etc:$HOME/bin
32  SHELL=`grep "^$LOGNAME:" /etc/passwd|cut -d: -f7`
33  export CDPATH PATH SHELL

35  case "`basename \`tty\``" in
36  console) eval `tset -m ansi:ansi -m :\?ansi -r -s -Q`;;
37  tty00)   eval `tset -m ansi:ansi -m :\?ansi -r -s -Q`;;
38  tty01)   eval `tset -m ansi:ansi -m :\?ansi -r -s -Q`;;
38  esac

41  echo TERM = $TERM
42  TERMCAP=/etc/termcap
43  export TERM TERMCAP

45  HZ=20
46  TZ=PST8PDT
47  export HZ TZ

49  umask 0022

51  echo "\nTime of this login : `date`"
52  lastlog -l

54  RED="^[[31m"
55  GREEN="^[[32m"
56  YELLOW="^[[33m"
57  BLUE="^[[34m"
58  CYAN="^[[35m"

60  case "`date|cut -d' ' -f1`" in
61  Mon)	echo "$RED";;
62  Tue)	echo "$GREEN";;
63  Wed)	echo "$YELLOW";;
64  Thu)	echo "$BLUE";;
65  Fri)	echo "$CYAN";;
66  esac
</PRE>

<ul><a name=26></a><h2>КАК РАБОТАЕТ .profile</h2></ul>

<P>	 Когда вы  входите в систему,  регистрационная программа выполняет
интерпретатор shell с параметром '-' (например, -sh). Это сигнализирует  
интерпретатору  shell,  что сейчас момент регистрации и что должен
быть выполнен файл настройки. Сначала выполняется /etc/profile - общий
файл настройки, установленный системным администратором для всех пользователей,  
а затем файл .profile пользователя.  Каждый  интерпретатор
shell  после  этого больше не запускает эти установочные программы.  В
файле /etc/ profile интересно проверить машинно-зависимую информацию и
посмотреть,  какие умолчания были для вас установлены.  Если вы хотите
выполнить ваш .profile в любой момент после входа в систему,  наберите
".  .profile" (можно писать и ".profile", проверено, что обе формы работают 
- Прим. переводчика).</P>
<P>	 Для поддержки вашего регистрационного каталога, используйте переменные 
командного процессора (переменные shell),  чтобы облегчить  передвижение 
и сократить количество нажатий клавиш при работе с маршрутными именами. 
Переменные shell всегда являются строками и, будучи один
раз определенными, не исчезают, пока вы не выйдете из системы.</P>
<P>	 При использовании переменные shell являются локальными для  
работающего  в  данный момент интерпретатора shell.  Их можно передать 
интерпретаторам shell более глубокого уровня путем их "экспортирования".
Следовательно,  если  вы создаете новый командный процессор,  все ваши
экспортированные переменные будут по-прежнему определены для этого 
интерпретатора shell. Исчерпывающий список переменных shell, установленных 
по умолчанию и используемых системой, см. в приложении 1.</P>
<P>	 Отметим, что в нашем примере файла настройки для каждого подкаталога 
первого уровня, который есть в нашем регистрационном каталоге, мы
также  имеем  переменные shell,  связанные с именем этого подкаталога.
Таким образом,  мы можем легко обращаться к различным областям  нашего
регистрационного каталога.</P>

<ul><a name=27></a><h2>ПОСТРОЧНЫЙ РАЗБОР ПРИМЕРА ФАЙЛА НАСТРОЙКИ</h2></ul>

<P>	 Строки 3-8 делают хитрую установку главной подсказки - переменной
PS1. В строке 3 инициализируется переменная, которая выбирает подсказку.  
Значение ushort жестко закодировано в файле,  но вы всегда можете
запросить его или установить его в зависимости от файла.</P>
<P>	 Первой альтернативой  является ufull,  используемая для установки
подсказки в виде полного имени узла uucp в локальной системе. Вы выбираете 
такую подсказку,  если используете несколько машин и для доступа
к одной машине применяете другую.  Отличительная подсказка  напоминает 
вам, какой машиной вы пользуетесь. Отметим, что подсказка имеет одинаковое 
число символов и для короткой строки, и для длинной. Если же вам
нужно имя узла uucp,  но не нужна длинная строка для подсказки, вы можете 
выбрать ushort, что дает первые три символа имени узла. Как показано в 
строке 6, имя получается применением команды uuname для получения локального 
имени узла (опция -l). Затем это имя пропускается через
команду cut,  которая вырезает символы с первого по третий.  Результат
присваивается переменной подсказки.</P>
<P>	 Последняя альтернатива для тех из вас, кто имеет графические символы.  
Назначение в строке 7 есть греческий символ. Его можно получить
применением специальных управляющих последовательностей,  которые указывают 
терминалам отображение специальных символов.  Символы ^[  явля-
ются визуальным представлением управляющего символа в программе vi. Вы
можете получить этот символ в программе vi,  набрав control-v, а затем
ESC.  Последовательность ESC[12m означает,  что следующий символ будет
напечатан как графический.  Символ j является вашей подсказкой и 
превращается в графический символ,  который выдается на ваш экран. Используя 
различные символы алфавита, вы можете иметь в виде вашей подсказки
почти любой графический символ.  ESC[10m возвращает ваш терминал в режим 
обычного текста,  так что все символы,  печатаемые после того, как
вы набрали ESC[10m, являются нормальными.</P>
<P>	 Если вы хотите сохранить вашу пользовательскую подсказку для всех
подчиненных интерпретаторов shell, экспортируйте ее. Иначе вы получите
$ для всех интерпретаторов shell нижнего уровня.</P>
<P>	 Строка 10	присваивает   переменной   LOGNAME   выход   команды
logname(1).  Команда logname - это обычная команда системы UNIX, которая 
печатает ваше регистрационное имя из файла /etc/passwd. Обычно эта
переменная установлена для вас системой,  но данный пример показывает,
как вы можете установить ее вручную.</P>
<P>	 Строка 11 инициализирует переменную HOME.  Она тоже  устанавливается 
для вас системой, но мы хотим показать, как делать эти вещи осоз-
нанно,  а не по умолчанию.  Сначала мы ищем в  файле  паролей  запись,
соответствующую переменной LOGNAME.  Мы ищем от начала строки имя, которое 
завершается символом :, чтобы убедиться, что найдено только корректное  
соответствие имени пользователя.  Затем вся запись посылается
команде cut,  которая вырезает шестое поле - регистрационный  каталог.
Преимущество такой стратегии в том,  что регистрационный каталог автоматически 
меняется, если меняется запись в файле /etc/passwd.</P>
<P>	 Строка 12 инициализирует переменную MAIL. Определяя MAIL, вы указываете, 
что вы должны быть уведомлены о посылке вам новой почты, если
вы находитесь в режиме on line. Строка 13 экспортирует эти переменные,
так что они доступны нам в порожденных интерпретаторах shell.</P>
<P>	 Строки 15-24  определяют  все каталоги первого уровня в нашем 
регистрационном каталоге. Большинство имен состоят из двух букв, некоторые из 
трех. Теперь мы можем применять команды такого вида:</P>
<PRE>
$ cd $HD
$ ls -R $HSR
$ cu -ltty00 dir | tee $HBB/board/session$$
</PRE>
<P>	 Строка 25  присваивает переменной HDIRS все имена каталоговых 
переменных, что облегчает подключение всех каталогов без повторного ввода  
их  имен.  Мы  можем  просмотреть все каталоги и напечатать размер
используемого дискового пространства:</P>
<PRE>
$ for DIR in $HDIRS
> do
> echo "disk usage for $DIR: `du -s $DIR`"
> done
</PRE>
<P>	 Строка 26  экспортирует переменные так,  чтобы мы могли всегда их
использовать.  Отметим,  что мы экспортировали $HDIRS и  HDIRS.  Перед
тем,  как выполнить экспортирование, $HDIRS было распространено на все
различные имена переменных. Следовательно, фактически мы экспортировали 
все имена плюс саму переменную HDIRS.</P>
<P>	 Строка 28 инициализирует P так,  чтобы  это  был  ваш  каталог  в
PUBDIR,  то  есть  /usr/spool/uucppublic.  Теперь  у  нас есть простой
способ ссылаться на наши файлы при работе с командой uucp.</P>
<P>	 Строка 30  устанавливает CDPATH.  Это путь,  который проверяется,
когда вы выполняете команду cd.  Сначала проверяется  текущий  каталог
(.) на предмет того,  есть ли в нем имя каталога,  в который вы хотите
попасть.  Затем проверяется ..  (родительский  каталог).  После  этого
просматривается  ваш  регистрационный  каталог.  Последним назначением
CDPATH является $HDIRS,  что подключает имена всех подкаталогов.  Цель
этих  имен  -  позволить  команде cd искать в соответствующем каталоге
введенное вами имя.</P>
<P>	 Например, если бы вы были в /etc и набрали "cd doc", вы бы попали
в $HOME/doc, поскольку CDPATH содержало в себе $HOME. Аналогично, если
бы вы имели подкаталог $HOME/doc/status и ввели "cd status" откуда-либо 
из другого места в системе,  вы бы пришли в  $HOME/doc/status,  так
как корень $HOME/doc был в CDPATH.</P>
<P>	 Порядок поиска в каталогах такой же,  как объявлено в  переменной
CDPATH.  Если вы вводите имя каталога, которое встречается более чем в
одном месте,  вы попадаете в первый каталог, обнаруженный при последовательном 
поиске.  Например, если бы вы сказали "cd sys", то попали бы
в $HOME/sys прежде, чем в $HOME/ src/sys.</P>
<P>	 В табл. 1-1 приведен пример эквивалентных команд cd, представленных 
в трех различных формах, которые понимает UNIX. То, какую форму вы 
используете, зависит от того, что считается наиболее удобным и требует
как можно меньше нажатий клавиш.</P>

<PRE>
							 Таблица 1-1
				 Три способа использования команды cd

<hr>
Абсолютный				   CDPATH		 Относительно
											переменной
<hr>
cd /usr/russ				 cd			 cd $HOME
cd /usr/russ/src/asm		 cd asm		 cd $HSR/asm
cd /usr/russ/doc/paper/conf  cd paper/conf  cd $HD/paper/conf
cd /usr/russ/tmp			 cd tmp		 cd $HT
</PRE>
<hr>

<P>	 Строка 31 инициализирует переменную PATH.  PATH работает таким же
образом,  как CDPATH.  Она ищет программы,  которые нужно запустить, в
каждом каталоге, указанном в переменной PATH. Если имя не найдено ни в
одном из этих каталогов, печатается сообщение "<file-name>: not found"
("<имя-файла>: не найдено").</P>
<P>	 Поскольку мы можем установить наш PATH как угодно,  можно указать
все таинственные места в системе,  в которых  расположены  исполняемые
модули.  Когда мы хотим их выполнить,  мы не обязаны их искать и набирать 
полное маршрутное имя.  Чтобы дополнить PATH,  введите, например,
следующее:</P>
<PRE>
PATH=$PATH:/usr/lib/uucp
</PRE>
<P>	 Команда paths,  представленная  далее  в  этой книге,  использует
$PATH,  чтобы сообщить нам,  в каком каталоге размещен исполняемый модуль.
</P>
<P>	 Строка 32 инициализирует переменную SHELL.  Эту переменную  могут
использовать не более чем одна или две утилиты.  Обычно она устанавливается 
системой,  когда вы регистрируетесь. Строка 33 экспортирует переменные 
CDPATH, PATH и SHELL.</P>
<P>	 Строки 35-39 - это хитрый способ установки  определений  терминалов.  
Строка  35  начинается со спрятанной команды tty,  заключенной в
знаки ударения (`...`). Выходом команды tty является "/dev/tty00". Затем 
мы берем основное имя этой строки,  т.е. "tty00". Далее мы используем 
структуру переключателя по этому значению,  чтобы увидеть, что мы
хотим сделать для каждого конкретного терминала.  Команды tset,  показанные 
здесь, относятся к среде XENIX и могут быть неприемлемыми в ва-
шей среде.</P>
<P>	 Строка 41 делает эхо-отображение значения TERM  на  экран,  чтобы
сообщить  вам  тип вашего терминала,  если он вам нужен.  Это значение
доступно, если описанная ранее команда tset устанавливает для вас TERM
как часть своей обычной работы.</P>
<P>	 В строке 42 устанавливается переменная  TERMCAP,  указывающая  на
/etc/termcap.  Это обычный способ установки переменной TERMCAP. Другой
способ - присвоить TERMCAP текущую закодированную строку,  которая находится 
в файле описания терминала. Если TERMCAP установлен на закодированную 
строку, то утилите vi нет необходимости обращаться к файловому 
вводу-выводу, чтобы получить характеристики вашего терминала. Строка 
43 экспортирует эти значения так,  чтобы они были доступны на любом
уровне интерпретатора shell.</P>
<P>	 Строка 45 устанавливает частотную переменную.  Это переменная  из
XENIX и,  возможно, имеется в System V. Она используется для установки
информации о времени.</P>
<P>	 Строка 46 устанавливает информацию о зоне времени, как это требуется 
в библиотечном вызове ctime(3). Имея переменную TZ, вы можете перекрыть  
подразумеваемую  зону времени при доступе ко времени из программы на языке Си. 
Строка 47 экспортирует эти переменные.</P>
<P>	 Строка 49 устанавливает ваше значение маски пользователя (umask).
Она управляет подразумеваемым разрешением доступа для всех файлов, которые 
вы создаете.  Система вычитает значение umask из 777.  Результат
становится правом доступа к файлу,  в данном случае 755. Когда вы создаете 
каталог с правом доступа 755, этот каталог показывается командой
"ls -l" как rwxr-xr-x.  Когда вы создаете некаталоговый файл с  правом
доступа  755,  этот файл показывается как rw-r--r--,  что эквивалентно
644. Некаталоговые файлы не имеют бита x, поэтому их нельзя исполнить.
Каталогам же нужен установленный бит x, чтобы они были доступны по команде cd.
</P>
<P>	 Строки 51  и  52  сообщают  вам  о времени вашего сеанса работы в
системе.  Строка 51 сообщает вам текущее время вашего входа в систему,
а  строка  52 вызывает программу lastlog,  которая печатает дату вашей
последней регистрации в системе. Программа lastlog описана в главе 5.</P>
<P>	 Строки 54-58  инициализируют  переменные,  генерирующие  цвета на
цветном мониторе. Управляющие значения являются стандартными значениями  
кодов ANSI.  Это работает в системе XENIX и может работать в вашей
системе.  Растровая графика не доступна, но имеется символьная графика
и различные основные (foreground) и фоновые (background) цвета. Основные 
цвета кодируются числами,  начиная с 30, а фоновые цвета - числами с 40.
</P>
<P>	 Строки 60-66 - просто для забавы.  Они представляют собой  хитрый
способ устанавливать каждый день на экране различные цвета.  Строка 60
начинается с запуска команды date и передачи ее  выхода  по  конвейеру
команде cut. Вырезается первое поле, которое является днем недели. Затем 
мы создаем структуру переключателя по строке дня, выполняя различные  
действия  для каждого дня.  Благодаря эхо-отображению управляющих
последовательностей, монитор реагирует немедленно.</P>


<ul><A NAME="ss4"></a><h2>ТЕОРИЯ ОТНОСИТЕЛЬНОСТИ ВНУТРИ СИСТЕМЫ UNIX</h2></ul>

<P>	 Теперь, когда мы ознакомились с "домашней" средой,  следующий шаг
- обратиться  к  средам,  находящимся  вне  регистрационного  каталога
($HOME).  Например,  что  представляют собой другие каталоги на том же
уровне,  что ваш $HOME ? Кто еще работает в системе? Как попроще получить  
доступ к их каталогам?  Можете ли вы запускать программы в чужих
каталогах?  Такого рода вопросы и действия относятся к другим людям  в
вашей системе.</P>
<P>	 Единственный способ ответить на эти вопросы -  посмотреть  вокруг
себя.  Никто  не  собирается рассказывать вам,  что такое система.  Вы
должны сами исследовать ее и выяснить,  куда вы можете ходить,  а куда
нет.  Система конечна, так что вы можете себе помочь, делая распечатки
всех каталогов и файлов.</P>
<P>	 Вы можете  маневрировать в системе UNIX,  используя относительную
нотацию. Поскольку системное дерево образовано из каталогов, обозначения  
.  и ..  позволяют нам двигаться вверх и вниз по дереву.  В любой
точке .. означает родительский каталог текущего каталога, в котором мы
находимся.</P>
<P>	 Ниже показаны некоторые примеры относительных команд.
<PRE>
   ls -l $HOME/..	  перечисляет файлы в моем родительском
					   каталоге.

   cd ../../..		 в предположении, что текущим каталогом
					   является /usr/russ/src/c, делает моим
					   текущим каталогом /usr.

   ls .				перечисляет файлы в текущем каталоге.

   ls ..			   перечисляет файлы в моем родительском
					   каталоге.

   $HOME/../../bin/ls  запускает ls в каталоге
					   /usr/russ/../../bin, т.е. в /bin/ls.

   ../fred/bin/ls	  запускает команду ls в каталоге
					   двоичных модулей Фреда, который имеет
					   тот же родительский каталог, что и я,
					   т.е. /usr/fred/bin/ls.
</PRE></P>

<ul><a name=29></a><h2>ОБЩАЯ СИСТЕМНАЯ СРЕДА</h2></ul>

<P>	 Системная среда  не  просто НАХОДИТСЯ в системе UNIX,  а ЯВЛЯЕТСЯ
системой UNIX. Как мы увидим в этой книге, вся система - UNIX, Си, команды,  
файлы и т.д. - это просто логический подход к функционированию
компьютера.  Программное обеспечение - это то,  что определяет система
для конечного пользователя. Мы можем представлять все машины, работающие 
в системе UNIX, как одинаковые и трактовать каждый UNIX как один и
тот же.  Мы предполагаем, что реакция машины будет каждый раз одинаковой.
</P>
<P>	 Мы можем смотреть на UNIX таким же образом, как на физические законы. 
Мы ограничены ими, но мы также вольны применять эти законы в ситуациях и 
областях,  с которыми мы до этого никогда не встречались. Мы
можем доверять этим законам и допускать, что они применимы везде, куда
бы мы ни направились. Такова система UNIX, по крайней мере в идеале.</P>
<P>	 Система имеет много сред. Важно понимать, что они собой представляют,  
как взаимодействуют и для чего могут быть использованы. Так же,
как

		<CENTER>программы = структуры данных + алгоритмы</CENTER>

так и

		<CENTER>UNIX = файловое дерево + утилиты</CENTER>
</P>
<P>	 Среда UNIX - это сочетание двух важнейших вещей: файлового дерева
и  интерфейса  системных  вызовов.  Это  дерево  допускает бесконечное
расширение возможностей, позволяя монтировать внешние дисковые области
в  любой  точке файловой системы.  Дерево помогает также в сборе логически 
связанных файлов, что делает систему более организованной.</P>
<P>	  Интерфейс системных вызовов обеспечивает набор инструментов,  из
которых можно построить большинство других функций. Определение интерфейса  
System V имеется в виде типографской книги и может быть найдено
в книжных магазинах.  Строгое следование этому  стандарту  гарантирует
совместимость с постоянно развивающейся AT&T System V.</P>


<ul><a name=30></a><h2>ОБЩЕЕ ФАЙЛОВОЕ ДЕРЕВО</h2></ul>
<P>
	 Для того чтобы лучше понять мир UNIX, посмотрите пример распечат-
ки структуры UNIX на рис.1-3 . Это наглядное представление полного дерева 
корневой  файловой  системы.  Любые  другие  расширения  файловой
системы монтируются на эту файловую систему.</P>
<P>Точкой временного  монтирования является /mnt.  Более постоянные точки
монтирования должны быть созданы администратором,  например /0,  /1  и
т.д. или /usr1, /usr2 и т.д.</P>

<ul><a name=31></a><h2>ПЕРВЫЙ СЛОЙ</h2></ul>

<P>	 Самым левым каталогом является /bin, который содержит все главные
двоичные утилиты.  Это наибольший из двух основных каталогов  двоичных
модулей.</P>
<P>	 Следующий каталог - /dev,  в котором  размещены  все  файлы  устройств.  
Файлы устройств являются точками доступа к периферии, подсоединенной к системе.  
Этот файл привязан к периферии с помощью  ядра  и
драйвера устройства.</P>
<P>	 Административные утилиты  и  конфигурационные  файлы  хранятся  в
/etc.  Примерами  являются getty и gettydef,  init и inittab,  а также
файл паролей (/etc/passwd).</P>
<P>	 Следующий каталог  - /lib,  где размещены библиотеки компилятора.
Здесь могут храниться и другие типы библиотек.</P>
<P>	 Каталог /lost+found  используется утилитой fsck (главное средство
поддержания файловой системы) для хранения логически удаленных файлов.
Если на самом деле вы хотите сохранить эти файлы,  они могут быть извлечены 
из этой удерживающей области после завершения  уборки  файловой
системы.</P>
<P>	 Следующий каталог - /mnt.  Это временная точка  монтирования  для
файловых  систем.  Мы  часто  монтируем и демонтируем файловые системы
просто для того, чтобы запустить быструю проверку чего-либо. Здесь под-ходящее 
место для этого.</P>
<P>	 Главным временным рабочим каталогом системы является /tmp. Многие
утилиты,  такие как vi, fsck, интерпретаторы shell и программы резервного 
копирования, используют /tmp для хранения рабочих файлов.</P>
<P>	 Следующий каталог - /usr,  который применяется как точка монтирования. 
Файловая система, смонтированная здесь, содержит дополнительную
системную  информацию  и каталоги пользователей.  Это разделение между
загружаемой файловой системой и пользовательской файловой системой было  
сделано,  чтобы сбалансировать загрузку диска.  Если бы все важные
файлы были в одном разделе,  он был бы слишком большим. Производительность  
может быть ухудшена,  если все действия направлены в одну логическую область диска.  
Благодаря разбивке всей системы на две,  каждая
файловая  система  поддерживает  разумное количество свободного пространства. 
Чуть ниже мы рассмотрим каталог /usr более подробно.</P>
<P>	 Последний файл - это само ядро,  /unix. Весь /unix фактически существует 
и представляет собой большой a.out (скомпилированный  объектный файл).  
Ядро изготавливается путем запуска ld на группе библиотек,
которые загружаются по очереди в огромный исполняемый модуль, называемый  /unix.  
Машина  запускается с первых 512 байтов корневой файловой
системы. Программа начальной загрузки, которая находится здесь, загружает  
программу  загрузки  большего размера,  иногда называемую /boot.
/boot загружает и запускает /unix.
</P>

<ul><a name=32></a><h2>ВТОРОЙ СЛОЙ</h2></ul>

<P>	 Второй слой  каталогов размещается под /usr.  Как упоминалось ранее,  
/usr используется как точка  монтирования  для  другой  файловой
системы.  Это значит, что все файлы, которые имеются в /usr, находятся
в другом разделе загружаемого диска или вообще на другом диске.</P>
<P>	 Первым  каталогом  является adm, для администрирования. Он
содержит учетные файлы и регистрационный файл  для  su  (суперпользователя), 
а также другие административные файлы.</P>
<P>	 В каталоге bin имеются исполняемые модули,  которые  используются
менее  часто,  чем модули в двоичном каталоге корневого уровня (/bin).
Почти все исполняемые модули распределены между этими двумя  каталогами.  
Другие  исполняемые  модули  рассеяны  по всей системе,  например
/usr/lib/uucp/uucico и /usr/lib/ ex3.7preserve.</P>
<P>	 Далее games.  UNIX приходит с ассортиментом интересных игр. Большинство 
из них текстовые, но предоставляется несколько программ графического типа, 
например worm, worms и rain.</P>
<P>	 Каталог include  содержит  все  файлы-заголовки.  Файлы-заголовки
используются  в  программах  на  языке  Си  для определения структур и
системных присваиваний,  полезных для программирования.  Здесь имеется
подкаталог sys,  который содержит все файлы= заголовки,  относящиеся к
системе.  Читая эти файлы-заголовки,  можно многое  узнать  о  системе
UNIX.</P>
<P>	 Следующий каталог - lib,  который содержит библиотечные файлы для
всех  видов "имущества":  файлы печатающих устройств,  файлы поддержки
утилиты vi,  другие языки и uucp.  Каталог  /usr/  lib  представляется
складом всяких библиотек,  которые имеются в системе, отличных от библиотек 
компилятора.</P>
<P>	 Каталог lost+found находится здесь для той же цели,  что и однои-
менный каталог корневого уровня.  Каждая файловая система должна иметь
такой файл. Без него fsck не имеет временного места для размещения полуудаленных 
файлов и поэтому удаляет их навсегда.</P>
<P>	 В каталоге  mail находится ваш системный почтовый ящик.  Когда вы
запускаете команду mail,  здесь накапливается очередь сообщений. В каталоге 
usr/mail каждый файл носит имя пользователя.  В этом файле хранится почта 
пользователя, пока он не прочитает ее.</P>
<P>	 Каталог man  предназначен  для  активных  страниц  руководств  по
системе UNIX. Наличие постоянного доступа к страницам руководств является 
хорошим средством.  Однако,  эти страницы занимают много места, и
доступ к ним может потребовать довольно много времени при сильно  загруженной системе.
</P>
<P>	 В каталоге news хранятся все файлы новостей.  Эти файлы именованы
в соответствии с порядком,  в котором они были введены в каталог.  Команда 
news(1) смотрит на дату файла $HOME/ .news_time, чтобы сообщить,
какие новости вы еще не читали.</P>
<P>	 Каталог preserve предназначен для файлов,  связанных  с  утилитой
vi. Они помещаются сюда, когда вы работаете с vi или с редактором ex и
пропадает питание машины либо ваш сеанс работы прерывается в виде "зависания".  
Когда  в  системе восстанавливается питание,  /tmp содержит
файлы  редактора  ex.  Из   каталога   /etc/rc   запускается   утилита
/usr/lib/ex3.7preserve,  которая просматривает /tmp, преобразует его в
сохраненный файл и помещает его в /usr/preserve.  Когда вы  входите  в
систему,  вы получаете почту о том, что у вас имеется сохраненный файл
редактора,  который вы можете восстановить и поместить его на исходное
место.</P>
<P>	 Каталог pub не содержит ничего особенного,  обычно в  нем  просто
некоторые  информационные файлы вроде таблицы ASCII или греческих символов.
</P>
<P>	 Каталог spool  -  это главная точка входа для всех буферизованных
файлов в системе. В этом каталоге имеется много подкаталогов, содержащих  
специфические  типы  буферизованных файлов.  Некоторыми типичными
подкаталогами являются lp, uucp и uucppublic.</P>
<P>	 В каталоге  src хранится исходный код системы UNIX,  если он имеется 
в системе. От этого каталога ответвляется много уровней: команды,
библиотеки,  код ядра, код машинного языка и автономные утилиты. Часто
в /usr/src хранится также исходный код для локальной машины.</P>
	 Каталог sys  традиционно хранит файлы,  необходимые для генерации
нового ядра.  Это файлы-заголовки, конфигурационный файл, библиотеки и
<P>командный файл для создания нового ядра из всех этих файлов.
	 Последний каталог - tmp.  Это вторичная временная область  хранения,  
	 которая используется не так часто, как /tmp. Ее, однако, использует утилита sort.
	 </P>


<ul><A NAME="ss5"><a name=33></a><h2>ЖИЗНЬ СИСТЕМЫ UNIX: НЕКОТОРЫЕ МЕТАФОРЫ</h2></ul>

<P>	 UNIX -  это  особый  мир,  живущий  своей жизнью.  Его социальная
структура имитирует реальную жизнь,  с правительством, содержащим правителя 
(корень root),  штатом поддержки (bin, cron, lp, sys) и массами
(/usr/*).  Массы не имеют доступа к мощи правителя, если не используют
предварительно  установленных средств (/bin/su) или не занимаются 
криминальными действиями и нарушением мер безопасности. Как и в любом 
обществе, большая многопользовательская система UNIX устанавливает права
и обязанности своих пользователей.</P>
<P>	 При входе  в  систему пользователь получает свое "место под солнцем" 
(регистрационный каталог - $HOME ).  Это место зависит  от  того,
что  было  раньше (от родительского каталога ..),  а будущие места зависят 
от того, что происходит позже (каталоги, подчиненные $HOME).</P>
<P>	 Работа распределяется  по  организациям и иерархиям в зависимости
от их функций в обществе (все пользователи в /usr, все транзитные файлы в 
/usr/spool,  все функции безопасности в /etc).  Посмотрите вокруг
себя в вашей системе,  чтобы ознакомиться с  вашим  миром.  Вы  можете
после  этого выбрать,  участвовать ли в некоторой части этого мира или
игнорировать ее.</P>
<P>	 Движение людей  в системе UNIX происходит параллельно.  Некоторые
области (/tmp) доступны всем, а некоторые области сильно охраняются от
большинства  людей (/etc/passwd).  Транспортная служба может перевезти
наши вещи (передача файлов по сетям uucp).  Мы даже  можем  воспользоваться 
общественным транспортом, чтобы добраться в разные части города
(вход в другие системы (rlogin),  эта  особенность  имеется  только  в
BSD).</P>
<P>	 В мире UNIX нам доступны различные пути.  Эти пути  помогают  нам
сформировать  свою  судьбу  (дисковые  разделы,  монтированные в любое
место файлового дерева).  Когда дисковый пакет монтируется,  он становится 
доступным нам. Когда он демонтируется, мы теряем доступ к нему.</P>
<P>	 Когда запускаются процессы,  они проходят через  различные  этапы
своей жизни. Они рождаются (ответвляются), растут (становятся планируемыми 
и помещаются в таблицу процессов) и,  наконец, становятся произ-
водительными  рабочими в обществе (переходят в состояние запуска и выполняются).
</P>
<P>	 Все процессы  имеют фамильное дерево.  Порожденный процесс всегда
имеет родителя, а родительские процессы могут порождать много "детей".
В зависимости от приложения, они могут быть "дедами" и "внуками". Процессы 
"умирают" так же легко,  как создаются. Одной из необычных вещей
в мире UNIX является то, что "дети" почти всегда "умирают" раньше своих "родителей".
</P>
<P>	 Правительство (ядро)  проводит  в жизнь параметры среды,  которые
выглядели бы в довольно тоталитарном духе, если бы это было в реальном
мире.  Только  определенное число рабочих допускается к рабочему месту
одновременно (это максимальное количество ячеек в таблице  процессов).
Рабочие  ограничены  в числе "детей",  которых они могут иметь (максимальное 
количество процессов на пользователя).  Поскольку рабочие  на-
капливают материальные ценности,  они ограничены в количестве товаров,
которые они могут поместить в комнаты своих домов (максимальный размер
файла, или ulimit). Хотя не установлен лимит на число различных файлов
(комнат) максимального размера, которые могут существовать, вся система  
имеет  предел  (df показывает свободное пространство),  и одна ненасытная 
персона может нанести удар  по  окружающим.  Здесь  возникает
своего рода экология.</P>
<P>	 Так же,  как компьютерный век проходит под присмотром электронной
автоматики,  так  и UNIX ведет таблицы о деятельности всех пользователей. 
Механизмы учета организованы правительством (внутри ядра) и всегда 
записывают действия каждого пользователя. Тем не менее, это свободное 
общество в той мере,  что вы можете получить  распечатку  о  вашем
кредитном состоянии (используя acctcom для печати учетных записей).</P>
<P>	 Хотя система UNIX имеет негативные аспекты  (как  и  человеческое
общество),  в  ней  есть также некоторые очень позитивные особенности.
Гибкость системы и богатство инструментов дает нам очень  продуктивную
и детально разработанную рабочую среду. Наша производительность в этом
смысле ограничена в основном нашим собственным воображением. Когда работа 
становится слишком утомительной и скучной, мы всегда можем создать
средства, делающие за нас эту работу. Это обстановка свободной инициативы, 
в которой хорошие идеи могут дать значительное увеличение производительности.
</P><hr>
<A HREF="chap00.htm">Назад.</A>
<A HREF="chap02.htm">Вперёд.</A>
<A HREF="chap00.htm#toc1.1">Оглавление.</A><hr>

<BR>
<table cellspacing="2" cellpadding="2" border="0">
<tr VALIGN=TOP>
<td>
<!-- BEGIN MGUL-COUNTER CODE -->
<img src="http://ns.mgul.ac.ru/cgi-bin/counter.cgi?Linux" border=0 height=31 width=88 alt="LSCS">
<!-- END MGUL-COUNTER CODE -->
</td>
	<td rowspan="2">
<!--begin of Top100-->
<a href="http://top100.rambler.ru/top100/">
<img src="http://counter.rambler.ru/top100.cnt?124566" alt="Rambler's Top100" width=1 height=1

border=0></a>
<!--end of Top100 code-->

<!--begin of Top100 logo-->
<a href="http://top100.rambler.ru/top100/">
[AD-SIZE]<AD- ://images.rambler.ru/top100/banner-88x31-rambler-blue3.gif" alt="Rambler's Top100"

width=88 height=31 border=0></a>
<!--end of Top100 logo -->
</td>
<td>
<!--TopList COUNTER--><script language="JavaScript"><!--
d=document;a='';a+=';r='+escape(d.referrer)
js=10//--></script><script language="JavaScript1.1"><!--
a+=';j='+navigator.javaEnabled()
js=11//--></script><script language="JavaScript1.2"><!--
s=screen;a+=';s='+s.width+'*'+s.height
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth)
js=12//--></script><script language="JavaScript1.3"><!--
js=13//--></script><script language="JavaScript"><!--
d.write('<a href="http://top.list.ru/jump?from=61405"'+
' target=_top><img src="http://top.list.ru/counter'+
'?id=61405;t=99;js='+js+a+';rand='+Math.random()+
'" alt="TopList"'+' border=0 height=18 width=88></a>')
if(js>11)d.write('<'+'!-- ')//--></script><noscript><a
target=_top href="http://top.list.ru/jump?from=61405"><img
src="http://top.list.ru/counter?js=na;id=61405;t=99"
border=0 height=18 width=88
alt="TopList"></a></noscript><script language="JavaScript"><!--
if(js>11)d.write('--'+'>')//--></script><!--TopList COUNTER-->
</td>
</tr>
</TABLE>
</body>
</html>
