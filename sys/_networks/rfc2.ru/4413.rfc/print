<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../4413.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 4413 — Поведение полей TCP/IP</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../4413.rfc">RFC 4413 — Поведение полей TCP/IP</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 4413</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank"><span itemprop="alternativeHeadline">TCP/IP Field Behavior</span></a></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Информационный</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="2006-03-01">Март 2006</time></dd><dd><div class="icon i5"></div> Авторы: <span itemprop="author">Mark A. West</span>, <span itemprop="author">Stephen McCann</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div id="text" itemprop="articleBody"><h3>Статус документа</h3><p>В этом документе содержится информация для сообщества Internet. Документ не задает каких-либо стандартов Internet. Допускается свободное распространение документа.</p><h3>Тезисы</h3><p>В этом документе описано поведение полей TCP/IP в контексте сжатия заголовков. Такое сжатие возможно благодаря тому, что большинство полей заголовка незначительно отличается от пакета к пакету. Многие из полей являются статическими или меняются более или менее предсказуемо. При разработке схем компрессии заголовков весьма важно понимать поведение полей. Примером такого анализа может служить RFC 3095. Данный документ играет аналогичную роль для сжатия заголовков TCP/IP.</p><h2>Оглавление</h2><ul class="map"><li><a href="print#p1" title="Введение">1. Введение</a></li><li><a href="print#p2" title="Общая классификация">2. Общая классификация</a></li><li class="lia"><a href="print#p2.1" title="Поля заголовка IP">2.1. Поля заголовка IP</a></li><li class="lib"><a href="print#p2.1.1" title="Поля заголовка IPv6">2.1.1. Поля заголовка IPv6</a></li><li class="lib"><a href="print#p2.1.2" title="Поля заголовка IPv4">2.1.2. Поля заголовка IPv4</a></li><li class="lia"><a href="print#p2.2" title="Поля заголовка TCP">2.2. Поля заголовка TCP</a></li><li class="lia"><a href="print#p2.3" title="Общие размеры для IP/TCP">2.3. Общие размеры для IP/TCP</a></li><li><a href="print#p3" title="Классификация повторяющихся полей заголовков">3. Классификация повторяющихся полей заголовков</a></li><li class="lia"><a href="print#p3.1" title="Заголовок IPv4 (внутренний и/или внешний)">3.1. Заголовок IPv4 (внутренний и/или внешний)</a></li><li class="lia"><a href="print#p3.2" title="Заголовок IPv6 (внутренний и/или внешний)">3.2. Заголовок IPv6 (внутренний и/или внешний)</a></li><li class="lia"><a href="print#p3.3" title="Заголовок TCP">3.3. Заголовок TCP</a></li><li class="lia"><a href="print#p3.4" title="Опции TCP">3.4. Опции TCP</a></li><li class="lia"><a href="print#p3.5" title="Сводные данные по репликации">3.5. Сводные данные по репликации</a></li><li><a href="print#p4" title="Анализ картины изменения полей заголовков">4. Анализ картины изменения полей заголовков</a></li><li class="lia"><a href="print#p4.1" title="Заголовок IP">4.1. Заголовок IP</a></li><li class="lib"><a href="print#p4.1.1" title="IP Traffic-Class / Type-Of-Service (TOS)">4.1.1. IP Traffic-Class / Type-Of-Service (TOS)</a></li><li class="lib"><a href="print#p4.1.2" title="Флаги ECN">4.1.2. Флаги ECN</a></li><li class="lib"><a href="print#p4.1.2" title="Идентификация IP">4.1.3. Идентификация IP</a></li><li class="lib"><a href="print#p4.1.4" title="Флаг запрета фрагментации (DF)">4.1.4. Флаг запрета фрагментации (DF)</a></li><li class="lib"><a href="print#p4.1.5" title="IP Hop-Limit / Time-To-Live (TTL)">4.1.5. IP Hop-Limit / Time-To-Live (TTL)</a></li><li class="lia"><a href="print#p4.2" title="Заголовок TCP">4.2. Заголовок TCP</a></li><li class="lib"><a href="print#p4.2.1" title="Порядковый номер">4.2.1. Порядковый номер</a></li><li class="lib"><a href="print#p4.2.2" title="Номер подтверждения">4.2.2. Номер подтверждения</a></li><li class="lib"><a href="print#p4.2.3" title="Резерв">4.2.3. Резерв</a></li><li class="lib"><a href="print#p4.2.4" title="Флаги">4.2.4. Флаги</a></li><li class="lib"><a href="print#p4.2.5" title="Контрольная сумма">4.2.5. Контрольная сумма</a></li><li class="lib"><a href="print#p4.2.6" title="Окно (Window)">4.2.6. Окно (Window)</a></li><li class="lib"><a href="print#p4.2.7" title="Указатель срочности (Urgent)">4.2.7. Указатель срочности (Urgent)</a></li><li class="lia"><a href="print#p4.2.8" title="Опции">4.3. Опции</a></li><li class="lib"><a href="print#p4.3.1" title="Обзор опций">4.3.1. Обзор опций</a></li><li class="lib"><a href="print#p4.3.2" title="Поведение поля опций">4.3.2. Поведение поля опций</a></li><li><a href="print#p5" title="Другие наблюдения">5. Другие наблюдения</a></li><li class="lia"><a href="print#p5.1" title="Неявные подтверждения">5.1. Неявные подтверждения</a></li><li class="lia"><a href="print#p5.2" title="Совместно используемые данные">5.2. Совместно используемые данные</a></li><li class="lia"><a href="print#p5.3" title="Доля заголовков TCP">5.3. Доля заголовков TCP</a></li><li class="lia"><a href="print#p5.4" title="Независимость полей и поведение пакетов">5.4. Независимость полей и поведение пакетов</a></li><li class="lia"><a href="print#p5.5" title="Короткоживущие потоки">5.5. Короткоживущие потоки</a></li><li class="lia"><a href="print#p5.6" title="Master Sequence Number">5.6. Master Sequence Number</a></li><li class="lia"><a href="print#p5.7" title="Ограничение размера опций TCP">5.7. Ограничение размера опций TCP</a></li><li><a href="print#p6" title="Вопросы безопасности">6. Вопросы безопасности</a></li><li><a href="print#p7" title="Благодарности">7. Благодарности</a></li><li><a href="print#p8" title="Литература">8. Литература</a></li><li class="lia"><a href="print#p8.1" title="Нормативные документы">8.1. Нормативные документы</a></li><li class="lia"><a href="print#p8.2" title="Дополнительная литература">8.2. Дополнительная литература</a></li></ul><h2 id="p1">1. Введение</h2><p>В этом документе описывается формат заголовков TCP/IP и поведение полей заголовка (т. е., изменение этих полей в потоке TCP). Описание приводится в контексте сжатия заголовков.</p><p>Поскольку поведение заголовков IP несколько отличается от описанного ранее в RFC 3095 [31] для протоколов UDP и RTP, эти заголовки также рассматриваются здесь.</p><p>Этот документ заимствует множество классификационных фрагментов из RFC 3095 вместо включения ссылок на этот документ.</p><p>Согласно формату, представленному в RFC 3095 [31], поля заголовков TCP/IP классифицируются и анализируются в два этапа. Сначала мы проводим общую классификацию (глава 2), в которой поля подразделяются на основе установившихся сведений и допущений. Эта общая классификация не принимает во внимание изменение характеристик полей, в той или иной степени зависящее от реализации или используемого приложения. В главе 3 рассматривается вопрос использования значений полей для оптимизации короткоживущих потоков. Более детальный анализ изменения характеристик приводится в главе 4. В заключение глава 5 описывает обработку полей заголовков с учетом их оптимального сжатия.</p><p>Основным вопросом является определение базы для рассмотрения имеющихся реализаций TCP/IP. Этот обзор основан на анализе развернутых в настоящее время реализаций TCP, которые поддерживают стандартизованные IETF механизмы.</p><p>Представляют интерес также общеие требования в части прозрачности. Множество предложенных недавно расширений TCP используют ранее зарезервированные биты полей в заголовках TCP. Следовательно, не следует полагаться на то, что зарезервированные биты имеют нулевые значения — они могут изменяться. В идеальном варианте схема компрессии должна принимать это во внимание.</p><p>Множество зарезервированных битов доступно для использования в будущих расширениях. Трактовка поведения полей не может предсказать использование этих битов в будущем, но мы ожидаем, что они будут применяться в некоторых случаях. С учетом этого схему компрессии можно оптимизировать для текущей ситуации, но следует обеспечить возможность поддержки любого использования зарезервированных битов. Однако обеспечить оптимизацию для битов, которые еще не определены, не представляется возможным.</p><h2 id="p2">2. Общая классификация</h2><p>Приведенные ниже определения (и часть текста) скопированы из Приложения A в RFC 3095 [31]. Отличия в поведении полей IP от RFC 3095 [31] (например, поведение IP/UDP/RTP для аудио и видео-приложений) явно указываются в этом документе.</p><p>Далее в документе термин «сессия» будет использоваться для потока пакетов TCP, представляющего собой серию пакетов с одинаковыми адресами IP и номерами портов. Поток пакетов определяется некими полями (см. ниже STATIC-DEF) и может рассматриваться как подмножество сессии. Более детально разделение сессий на потоки пакетов для сжатия заголовков рассматривается в документе [31].</p><p>Заголовки пакетов делятся на 5 классов:</p><ul><li class="b">INFERRED — опосредованные</li><li class="lib">Эти поля содержат значения, которые могут быть определены на основе других значений (например, размер кадра, содержащего пакет) и по этой причине не обрабатываются в процессе сжатия.</li><li class="b">STATIC — статические</li><li class="lib">Значения этих полей предполагаются неизменными в течение срока существования потока пакетов. Статическая информация должна тем или иным путем передаваться однократно.</li><li class="b">STATIC-DEF — статические определяющие</li><li class="lib">Поля типа STATIC, значение которых определяют поток пакетов. В общем случае эти значения обрабатываются как STATIC.</li><li class="b">STATIC-KNOWN — статические известные</li><li class="lib">Поля типа STATIC, которые предположительно содержат общепринятые (well-known) значения и, следовательно, могут не передаваться.</li><li class="b">CHANGING — изменяющиеся</li><li class="lib">Предполагается, что такие поля могут принимать произвольные значения из ограниченного набора или диапазона.</li></ul><p>В этой главе каждое поле заголовков IP и TCP относится к тому или иному классу. Для всех полей, кроме класса CHANGING, приводится также обоснование этой классификации. В главе 4 проводится дополнительное рассмотрение и классификация полей CHANGING на основе их предполагаемого поведения.</p><h3 id="p2.1">2.1. Поля заголовка IP</h3><h4 id="p2.1.1">2.1.1. Поля заголовка IPv6</h4><table><tr><td>Поле</td><td>Размер в битах</td><td>Класс</td></tr><tr><td>Version</td><td>4</td><td>STATIC</td></tr><tr><td>DSCP</td><td>6</td><td>ALTERNATING</td></tr><tr><td>Флаг ECT</td><td>1</td><td>CHANGING</td></tr><tr><td>Флаг CE</td><td>1</td><td>CHANGING</td></tr><tr><td>Flow Label</td><td>20</td><td>STATIC-DEF</td></tr><tr><td>Payload Length</td><td>16</td><td>INFERRED</td></tr><tr><td>Next Header</td><td>8</td><td>STATIC</td></tr><tr><td>Hop Limit</td><td>8</td><td>CHANGING</td></tr><tr><td>Source Address</td><td>128</td><td>STATIC-DEF</td></tr><tr><td>Destination Address</td><td>128</td><td>STATIC-DEF</td></tr><tr class="c nobrd"><td colspan="3">Рисунок 1: Поля заголовка IPv6</td></tr></table><p class="note">Differs from RFC 3095 [31]. (The DSCP, ECT, and CE flags were amalgamated into the Traffic Class octet in RFC 3095).</p><ul><li class="b">Version — версия</li><li class="lib">Это поле указывает номер версии протокола IP. Пакеты с отличающимися значениями этого поля должны обрабатываться разными стеками IP. Все пакеты одного потока должны, следовательно, иметь одинаковую версию IP. Это позволяет отнести поле к классу STATIC.</li><li class="b">Flow Label — метка потока</li><li class="lib">Это поле используется для идентификации пакетов, относящихся к одному потоку. Если идентификатор потока не используется, в этом поле следует устанавливать нулевое значение. Во всех остальных случаях пакеты одного потока должны использовать одинаковое значение идентификатора, которое является одним из полей, определяющих поток. Это поле, следовательно, классифицируется как STATIC-DEF.</li><li class="b">Payload Length — размер данных</li><li class="lib">Предполагается, что информация о пакете (включая размер содержащихся в нем данных) обеспечивается канальным уровнем. Это поле, следовательно, относится к классу INFERRED.</li><li class="b">Next Header — следующий заголовок</li><li class="lib">Это поле обычно имеет одинаковое значение во всех пакетах одного потока и указывает тип следующего заголовка. Значение этого поля в течение срока существования потока пакетов может изменяться только в результате отсутствия расширенных заголовков. Следовательно, поле классифицируется как STATIC. Такая классификация унаследована от RFC 3095 [31]. Однако следует отметить, что поле Next Header в действительности определяется типом следующего заголовка. Возможно, что более корректно было бы отнести это поле к типу опосредованных, хотя это зависит от конкретной реализации схемы компрессии.</li><li class="b">Source Addresses и Destination Addresses — адреса отправителя и получателя</li><li class="lib"><p>Эти поля являются частью определения потока пакетов и, следовательно, являются неизменными для конкретного потока. Таким образом, поля классифицируются как STATIC-DEF.</p><p>Такое представление может показаться несколько упрощенным, но в данном документе адреса IP, связанные с соединением транспортного уровня, рассматриваются как часть определения потока. Естественно, что могут существовать и более сложные определения для разделения потоков (дополнительное обсуждение этого вопроса можно найти в RFC 3095 [31]). При использовании туннелей адреса IP во внешних заголовках туннеля также относятся к классу STATIC-DEF.</p></li></ul><p>Суммарные размеры полей каждого класса показаны на рисунке 2:</p><table><tr><td>Класс</td><td>Размер в октетах</td></tr><tr><td>INFERRED</td><td>2</td></tr><tr><td>STATIC</td><td>1,5</td></tr><tr><td>STATIC-DEF</td><td>34,5</td></tr><tr><td>STATIC-KNOWN</td><td>0</td></tr><tr><td>CHANGING</td><td>2</td></tr><tr class="c nobrd"><td colspan="2">Рисунок 2: Размеры полей</td></tr></table><h4 id="p2.1.2">2.1.2. Поля заголовка IPv4</h4><table><tr><td>Поле</td><td>Размер в битах</td><td>Класс</td></tr><tr><td>Version</td><td>4</td><td>STATIC</td></tr><tr><td>Header Length</td><td>4</td><td>STATIC-KNOWN</td></tr><tr><td>DSCP</td><td>6</td><td>ALTERNATING</td></tr><tr><td>Флаг ECT</td><td>1</td><td>CHANGING</td></tr><tr><td>Флаг CE</td><td>1</td><td>CHANGING</td></tr><tr><td>Packet Length</td><td>16</td><td>INFERRED</td></tr><tr><td>Identification</td><td>16</td><td>INFERRED</td></tr><tr><td>Reserved Flag</td><td>1</td><td>CHANGING</td></tr><tr><td>Флаг запрета фрагментирования</td><td>1</td><td>CHANGING</td></tr><tr><td>Флаг наличия дополнительных фрагментов</td><td>1</td><td>STATIC-KNOWN</td></tr><tr><td>Fragment Offset</td><td>13</td><td>STATIC-KNOWN</td></tr><tr><td>Time To Live</td><td>8</td><td>CHANGING</td></tr><tr><td>Protocol</td><td>8</td><td>STATIC</td></tr><tr><td>Header Checksum</td><td>16</td><td>INFERRED</td></tr><tr><td>Source Address</td><td>32</td><td>STATIC-DEF</td></tr><tr><td>Destination Address</td><td>32</td><td>STATIC-DEF</td></tr><tr class="c nobrd"><td colspan="3">Рисунок 3: Поля заголовка IPv4</td></tr></table><ul><li class="b">Version — версия</li><li class="lib">Это поле указывает номер версии протокола IP. Пакеты с отличающимися значениями этого поля должны обрабатываться разными стеками IP. Все пакеты одного потока должны, следовательно, иметь одинаковую версию IP. Это позволяет отнести поле к классу STATIC.</li><li class="b">Packet Length — размер пакета</li><li class="lib">Предполагается, что информация о размере пакета обеспечивается канальным уровнем. Это поле, следовательно, относится к классу INFERRED.</li><li class="b">Flags — флаги</li><li class="lib"><p>Поле резервного флага (Reserved) должно имет значение 0 в соответствии с RFC 791 [1]. Поэтому в RFC 3095 [31] поле классифицируется как STATIC-KNOWN. Однако предполагается возможность использования зарезервированных полей в будущем. Нежелательно выбирать такое представление, которое будет препятствовать использованию профиля компрессии при изменении заголовка в результате использования резервных полей. По этой причине используется классификация поля как CHANGING. Коммуникационный профиль, естественно, может быть оптимизирован с учетом текущей ситуации, когда значение поля известно заранее (0).</p><p>Флаг наличия дополнительных фрагментов (MF) предполагается нулевым, поскольку фрагментации в идеальном случае не ожидается. Однако следует понимать, что в некоторых сценариях работы (например, в некоторых вариантах архитектуры туннелирования) фрагментация может возникать. В общем случае, тем не менее. предполагается отсутствие фрагментации в Internet (благодаря начальному согласованию MSS и последующему применению механизма path-MTU discovery). RFC 3095 [31] указывает, для протокола RTP только первый фрагмент будет содержать заголовок транспортного уровня и последующие фрагменты будут сжиматься с использованием другого профиля. Это нормальная ситуация для TCP. Если возникает фрагментация, первый фрагмент по определению будет относительно большим для минимизации относительного размера заголовков. Последующие фрагменты будут сжиматься с использованием другого профиля. Следовательно, представляется нежелательной оптимизация фрагментирования при сжатии заголовков. Флаг наличия дополнительных фрагментов в результате классифицируется как STATIC- KNOWN.</p></li><li class="b">Fragment Offset — смещение фрагмента</li><li class="lib">В предположении отсутствия фрагментации смещение фрагмента всегда равно нулю. Следовательно, это поле классифицируется как STATIC-KNOWN. Даже если принимать во внимание фрагментацию, только первый фрагмент будет содержать заголовок TCP и смещение фрагмента в этом заголовке будет равно нулю.</li><li class="b">Protocol — протокол</li><li class="lib"><p>Это поле обычно имеет одинаковое значение во всех пакетах одного потока. Данное поле определяет тип последующего заголовка.</p><p>Это поле меняет свое значение лишь в случае изменения последовательности заголовков (например, вставляется или удаляется расширение заголовка или туннельный заголовок). Следовательно, поле относится к классу STATIC. Будет ли такое изменение приводить к тому, что последовательность пакетов станет трактоваться как новый поток (с точки зрения сжатия заголовков) определяется профилем. Профили ROHC должны обеспечивать возможность работы с расширенными заголовками и туннелями, но выбор стратегии не входит в задачи данного документа.</p></li><li class="b">Header Checksum — контрольная сумма заголовка</li><li class="lib"><p>Контрольная сумма заголовка позволяет предотвратить обработку поврежденных пакетов. Когда почти вся информация заголовка IP представлена в сжатом виде, не возникает необходимости в использовании этой дополнительной контрольной суммы. Вместо этого значение контрольной суммы восстанавливается при декомпрессии. Следовательно, поле классифицируется как INFERRED.</p><p class="note">Отметим, что контрольная сумма заголовка TCP защищает не все заголовки TCP/IP, а только псевдо-заголовок TCP (и данные).</p><p>ROHC [31] использует значение CRC для проверки несжатого заголовка. С учетом необходимости проверки корректности всего заголовка TCP/IP, затрат на расчет контрольной суммы TCP с учетом всех данных и известные недостатки контрольных сумм TCP [37] дополнительная проверка является необходимой. Следовательно, весьма желательно использование дополнительной контрольной суммы (такой, как CRC) для проверки корректности декомпрессии.</p></li><li class="b">Source Addresses и Destination Addresses — адреса отправителя и получателя</li><li class="lib">Эти поля являются частью определения потока пакетов и, следовательно, являются неизменными для конкретного потока. Таким образом, поля классифицируются как STATIC-DEF.</li></ul><p>Общие размеры заголовков разного класса показаны на рисунке 4:</p><table><tr><td>Класс</td><td>Размер в октетах</td></tr><tr><td>INFERRED</td><td>4</td></tr><tr><td>STATIC</td><td>1,5</td></tr><tr><td>STATIC-DEF</td><td>8</td></tr><tr><td>STATIC-KNOWN</td><td>2,25</td></tr><tr><td>CHANGING</td><td>4,25</td></tr><tr class="c nobrd"><td colspan="2">Рисунок 4: Размеры полей</td></tr></table><h3 id="p2.2">2.2. Поля заголовка TCP</h3><table><tr><td>Поле</td><td>Размер в битах</td><td>Класс</td></tr><tr><td>Source Port</td><td>16</td><td>STATIC-DEF</td></tr><tr><td>Destination Port</td><td>16</td><td>STATIC-DEF</td></tr><tr><td>Sequence Number</td><td>32</td><td>CHANGING</td></tr><tr><td>Acknowledgement Num</td><td>32</td><td>CHANGING</td></tr><tr><td>Data Offset</td><td>4</td><td>CHANGING</td></tr><tr><td>Резерв</td><td>4</td><td>CHANGING</td></tr><tr><td>Флаг CWR</td><td>1</td><td>CHANGING</td></tr><tr><td>Флаг ECE</td><td>1</td><td>CHANGING</td></tr><tr><td>Флаг URG</td><td>1</td><td>CHANGING</td></tr><tr><td>Флаг ACK</td><td>1</td><td>CHANGING</td></tr><tr><td>Флаг PSH</td><td>1</td><td>CHANGING</td></tr><tr><td>Флаг RST</td><td>1</td><td>CHANGING</td></tr><tr><td>Флаг SYN</td><td>1</td><td>CHANGING</td></tr><tr><td>Флаг FIN</td><td>1</td><td>CHANGING</td></tr><tr><td>Window</td><td>16</td><td>CHANGING</td></tr><tr><td>Checksum</td><td>16</td><td>CHANGING</td></tr><tr><td>Urgent Pointer</td><td>16</td><td>CHANGING</td></tr><tr><td>Options</td><td>0(-352)</td><td>CHANGING</td></tr><tr class="c nobrd"><td colspan="3">Рисунок 5: Поля заголовка TCP</td></tr></table><ul><li class="b">Source Addresses и Destination Addresses — адреса отправителя и получателя</li><li class="lib">Эти поля являются частью определения потока пакетов и, следовательно, являются неизменными для конкретного потока. Таким образом, поля классифицируются как STATIC-DEF.</li><li class="b">Data Offset — смещение данных</li><li class="lib">Число 4-октетных слов в заголовке TCP, показывающее начало данных (всегда выровнено по 4-октетной границе). Это значение может быть восстановлено из размера всех опций, следовательно не возникает необходимости в его явной передаче. В результате поле классифицируется как INFERRED.</li></ul><h3 id="p2.3">2.3. Общие размеры для IP/TCP</h3><p>В целом поля разных классов в заголовках IP/TCP имеют следующие размеры:</p><table><tr><td rowspan="2">Класс</td><td colspan="2">Число октетов</td></tr><tr><td>IPv6</td><td>IPv4</td></tr><tr><td>INFERRED</td><td>2,5</td><td>4,5</td></tr><tr><td>STATIC</td><td>1,5</td><td>1,5</td></tr><tr><td>STATIC-DEF</td><td>38,5</td><td>12</td></tr><tr><td>STATIC-KNOWN</td><td>-</td><td>2,25</td></tr><tr><td>CHANGING</td><td>17,25</td><td>19,75</td></tr><tr><td>Всего</td><td>60</td><td>40</td></tr><tr class="c nobrd"><td colspan="3">Рисунок 6: Суммарные размеры полей</td></tr></table><p>Опции класса CHANGING не учитывались.</p><h2 id="p3">3. Классификация повторяющихся полей заголовков</h2><p>В тех случаях, когда множество потоков перекрываются по времени или используются последовательно в течение короткого времени, приходиться иметь дело с похожими значениями полей заголовков. Такое сходство полей заголовков возникает и в контексте сжатия. Таким образом, следует использовать сходство полей различных потоков для повышения степени сжатия. Для решения этой задачи важно найти «повторяющиеся» характеристики различных полей заголовков.</p><p>Ключевым моментом «репликации» характеристик является использование текущего контекста в качестве базы при создании нового контекста. То, что было изменено, обновляется или переписывается с использованием значений из пакета, вызвавшего репликацию. В этой главе рассматриваются общие характеристики полей из различных потоков.</p><p class="note">Отметим, что репликация основывается на контексте (а не просто на значениях полей) и созданные при сжатии (compressorcreated0 поля также могут включаться в этот контекст. Эти поля, естественно, зависят от используемого протокола сжатия (профиля ROHC).</p><p>Варианты возможности репликации для полей TCP/IP перечислены ниже:</p><ul><li class="b">N/A:</li><li class="lia">поле не рассматривается в процессе репликации, поскольку оно относится к числу опосредованных (inferred) или известно 'a priori' (и, следовательно, не появляется в контексте).</li><li class="b">No:</li><li class="lia">поле не может реплицироваться, поскольку отсутствует корреляция между значениями этого поля в двух потоках пакетов.</li><li class="b">Yes:</li><li class="lia">поле может реплицироваться. Это не гарантирует совпадения значений в двух потоках-кандидатах и лишь позволяет использовать репликацию для повышения коэффициента сжатия. Для повышения эффективности компресии могут применяться различные методы кодирования.</li></ul><h3 id="p3.1">3.1. Заголовок IPv4 (внутренний и/или внешний)</h3><table><tr><td>Поле</td><td>Класс</td><td>Репликация</td></tr><tr><td>Version</td><td>STATIC</td><td>N/A</td></tr><tr><td>Header Length</td><td>STATIC-KNOWN</td><td>N/A</td></tr><tr><td>DSCP</td><td>ALTERNATING</td><td>No (1)</td></tr><tr><td>Флаг ECT</td><td>CHANGING</td><td>No (2)</td></tr><tr><td>Флаг CE</td><td>CHANGING</td><td>No (2)</td></tr><tr><td>Packet Length</td><td>INFERRED</td><td>N/A</td></tr><tr><td>Identification</td><td>INFERRED</td><td>Yes (3)</td></tr><tr><td>Reserved Flag</td><td>CHANGING</td><td>No (4)</td></tr><tr><td>Флаг DF</td><td>CHANGING</td><td>Yes (5)</td></tr><tr><td>Флаг MF</td><td>STATIC-KNOWN</td><td>N/A</td></tr><tr><td>Fragment Offset</td><td>STATIC-KNOWN</td><td>N/A</td></tr><tr><td>Time To Live</td><td>CHANGING</td><td>Yes</td></tr><tr><td>Protocol</td><td>STATIC</td><td>N/A</td></tr><tr><td>Header Checksum</td><td>INFERRED</td><td>N/A</td></tr><tr><td>Source Address</td><td>STATIC-DEF</td><td>Yes</td></tr><tr><td>Destination Address</td><td>STATIC-DEF</td><td>Yes</td></tr><tr class="c nobrd"><td colspan="3">Рисунок 7: Заголовок IPv4</td></tr></table><ol><li><p>Поле DSCP маркируется в соответствии с требованиями приложения. Если можно предположить, что реплицируемые соединения относятся к одному классу diffserv, очевидно, что значения DSCP будут реплицируемыми. Значение DSCP может устанавливать не только отправитель, но и любой, кому позволено маркировать пакеты. Таким образом, пакет может использовать множество значений DSCP в разных точках сети. Однако компрессия заголовках используется на соединениях «точка-точка», поэтому значение данного можно считать сравнительно стабильным. Если выполняется перемаркировка на основе состояния измерителя, значение поля может измениться посреди потока. В целом мы полагаем, что репликация DSCP будет полезна для сжатия заголовков.</p></li><li><p>Поле ECN невозможно реплицировать (отметим, что ожидается использование схемы ECN nonce [19]). Однако представляется очевидным, что все потоки TCP между хостами, поддерживающими ECN, будут применять ECN, поэтому использование ECN (или отказ от него) для потоков между одной парой хостов можно рассматривать как реплицируемое. См. также (4).</p></li><li><p>Реплицируемый контекст для этого поля включает флаги IP-ID, NBO и RND (как описано в ROHC RTP). Это подчеркивает, что репликация происходит для контекста, а не просто для отдельных значений полей и, таким образом, должна рассматриваться с учетом точной природы компрессии, используемой для каждого поля.</p></li><li><p>Поскольку будущее поведение поля Reserved Flag предсказать невозможно, не представляется возможным рассматривать и вопрос его репликации. Однако можно предполагать, что поведение этого поля в разных пакетах между одной парой конечных точек будет похожим. В этом случае любой выбор формата пакетов (например) может передаваться в новый поток. В случае формата пакетов решение может приниматься локально системой сжатия заголовков.</p></li><li><p>Теоретически бит DF можно реплицировать. Однако, практическая польза этого не очевидна. С точки зрения сжатия заголовков очевидно, что явная передача этого 1-битового флага не потребует большего объема, нежели индикация возможности реплицирования. Мы не включаем флаг DF в число реплицируемых.</p></li></ol><h3 id="p3.2">3.2. Заголовок IPv6 (внутренний и/или внешний)</h3><table><tr><td>Поле</td><td>Класс</td><td>Репликация</td></tr><tr><td>Version</td><td>STATIC</td><td>N/A</td></tr><tr><td>Traffic Class</td><td>CHANGING</td><td>Yes (1)</td></tr><tr><td>Флаг ECT</td><td>CHANGING</td><td>No (2)</td></tr><tr><td>Флаг CE</td><td>CHANGING</td><td>No (2)</td></tr><tr><td>Flow Label</td><td>STATIC-DEF</td><td>N/A</td></tr><tr><td>Payload Length</td><td>INFERRED</td><td>N/A</td></tr><tr><td>Next Header</td><td>STATIC</td><td>N/A</td></tr><tr><td>Hop Limit</td><td>CHANGING</td><td>Yes</td></tr><tr><td>Source Address</td><td>STATIC-DEF</td><td>Yes</td></tr><tr><td>Destination Address</td><td>STATIC-DEF</td><td>Yes</td></tr><tr class="c nobrd"><td colspan="3">Рисунок 8: Заголовок IPv6</td></tr></table><ol><li>См. примечание для поля DSCP в заголовке IPv4 (п. 1, выше).</li><li>См. примечание для флагов ECT и CE в заголовке IPv4 (п. 2, выше).</li></ol><h3 id="p3.3">3.3. Заголовок TCP</h3><table><tr><td>Поле</td><td>Класс</td><td>Репликация</td></tr><tr><td>Source Port</td><td>STATIC-DEF</td><td>Yes (1)</td></tr><tr><td>Destination Port</td><td>STATIC-DEF</td><td>Yes (1)</td></tr><tr><td>Sequence Number</td><td>CHANGING</td><td>No (2)</td></tr><tr><td>Acknowledgement Num</td><td>CHANGING</td><td>No</td></tr><tr><td>Data Offset</td><td>CHANGING</td><td>N/A</td></tr><tr><td>Резерв</td><td>CHANGING</td><td>No (3)</td></tr><tr><td>Флаг CWR</td><td>CHANGING</td><td>No (4)</td></tr><tr><td>Флаг ECE</td><td>CHANGING</td><td>No (4)</td></tr><tr><td>Флаг URG</td><td>CHANGING</td><td>No</td></tr><tr><td>Флаг ACK</td><td>CHANGING</td><td>No</td></tr><tr><td>Флаг PSH</td><td>CHANGING</td><td>No</td></tr><tr><td>Флаг RST</td><td>CHANGING</td><td>No</td></tr><tr><td>Флаг SYN</td><td>CHANGING</td><td>No</td></tr><tr><td>Флаг FIN</td><td>CHANGING</td><td>No</td></tr><tr><td>Window</td><td>CHANGING</td><td>Yes</td></tr><tr><td>Checksum</td><td>CHANGING</td><td>No</td></tr><tr><td>Urgent Pointer</td><td>CHANGING</td><td>Yes (5)</td></tr><tr class="c nobrd"><td colspan="3">Рисунок 9: Заголовок TCP</td></tr></table><ol><li><p>Очевидно, что номер порта на серверной стороне относится к числу общепринятых (well-known). На клиентской стороне номер порта обычно выбирается стеком протоколов автоматически. Возможность репликации номера зависит от того, как стек протоколов выбирает номера портов. Хотя наиболее популярные реализации используют последовательное выделение номеров, расчет на такое поведение может оказаться нежелательным.</p></li><li><p>Рекомендация (и ожидаемое развертывание) использования случайных значений для начальных порядковых номеров TCP в соответствии с RFC 1948 [10] делает невозможным совместное использование порядковых номеров. Таким образом, это поле не может считаться реплицируемым.</p></li><li><p>См. выше комментарий (4) для полей заголовка IPv4.</p></li><li><p>См. выше комментарий (2) для флага ECN в заголовке IPv4.</p></li><li><p>Указатель срочности используется очень редко. Это означает, что на практике поле может рассматриваться как реплицируемое.</p></li></ol><h3 id="p3.4">3.4. Опции TCP</h3><table><tr><td>Опция</td><td>Только SYN (1)</td><td>Репликация</td></tr><tr><td>End of Option List</td><td>No</td><td>No (2)</td></tr><tr><td>No-Operation</td><td>No</td><td>No (2)</td></tr><tr><td>Maximum Segment Size</td><td>Yes</td><td>Yes</td></tr><tr><td>Window Scale</td><td>Yes</td><td>Yes</td></tr><tr><td>SACK-Permitted</td><td>Yes</td><td>Yes</td></tr><tr><td>SACK</td><td>No</td><td>No</td></tr><tr><td>Timestamp</td><td>No</td><td>No</td></tr><tr class="c nobrd"><td colspan="3">Рисунок 10: Опции TCP</td></tr></table><ol><li><p>Эта колонка показывает, что данная опция может использоваться только в пакетах SYN (Yes) или в других пакетах также (No). Многие опции TCP используются только в пакетах SYN. Некоторые опции (например, MSS, Window Scale и SACKPermitted) имеют тенденцию сохранять свои значения в потоке пакетов.</p><p>Таким образом, для поддержки контекста совместного использования системе компрессии следует такие опции TCP в контексте (даже если они появляются только в сегментах SYN).</p></li><li><p>Поскольку эти опции имеют фиксированные значения, они могут рассматриваться как реплицируемые. Однако единственно, что интересно передавать об этих опциях — это их присутствие. Если известно, что такая опция существует, ее значение также известно.</p></li></ol><h3 id="p3.5">3.5. Сводные данные по репликации</h3><p>Из приведенного выше анализа можно видеть, что существуют разумные основания для использования избыточности, присутствующей в разных потоках пакетов и в пакетах одного потока. Просто рассмотрите преимущества, которые можно получить, опуская адреса отправителя и получателя для повторяющихся соединений между парой конечных точек IPv6. Существует также цена (в терминах сложности и устойчивости) реплицируемого контекста и она должна приниматься во внимание при выборе решения.</p><p>В заключение отметим, что использование репликации требует, чтобы система компрессии имела уверенность в том, что нужные данные (отправителя) присутствуют и корректны на стороне декомпрессии. Это может вносить некоторые ограничения на использование «изменяемых» полей в процессе репликации.</p><h2 id="p4">4. Анализ картины изменения полей заголовков</h2><p>Для создания подходящего механизма эффективной компрессии всех полей заголовка следует проанализировать картину изменения этих полей. Для такого анализа здесь вводится дополнительная классификация полей, которые в главе 2 были отнесены к классу CHANGING (изменяющиеся).</p><p>Поля класса CHANGING разделены на 5 дополнительных субклассов:</p><ul><li class="b">STATIC — статические</li><li class="lib">Эти поля были отнесены к классу CHANGING при общем рассмотрении, но они квалифицируются как статические с учетом некоторых добавочных допущений.</li><li class="b">SEMISTATIC — полустатические</li><li class="lib">Эти поля относятся к типу STATIC большую часть времени. Однако время от времени значение может меняться и после известного числа пакетов возвращаться к первоначальному.</li><li class="b">RARELY-CHANGING (RC) — редкое изменение</li><li class="lib">Эти поля изменяют свое значение достаточно редко и сохраняют новое значение.</li><li class="b">ALTERNATING — чередование</li><li class="lib">В этих полях чередуется небольшой набор отличающихся значений.</li><li class="b">IRREGULAR — непредсказуемые изменения</li><li class="lib">Это поля, для которых нет возможности идентифицировать ту или иную регулярность изменений.</li></ul><p>Для дополнительного расширения этой классификации без ее усложнения можно использовать значения полей и/или диапазоны их изменения.</p><p>При классификации полей принимались во внимание дополнительные сведения и/или диапазоны возможных изменений. Для полей класса STATIC или SEMISTATIC значение поля может относиться не только к классу STATIC но быть также заранее известным (KNOWN) общепринятым значением (два состояния для полей SEMISTATIC). Для полей с непредсказуемым поведением может быть известно, что обычно изменения происходят в ограниченном (LIMITED) диапазоне всех возможных значений. Для остальных полей значения совершенно неизвестны (UNKNOWN).</p><p>На рисунке 11 показана классификация полей класса CHANGING на основе предполагаемой картины их изменения. (4) относится к полям IPv4, а (6) — к полям IPv6.</p><table><tr><td>Поле</td><td>Значение/диапазон</td><td>Класс</td><td>Дополнительные сведения</td></tr><tr><td>DSCP(4) / Traffic-Class (6)</td><td>Значение</td><td>ALTERNATING</td><td>UNKNOWN</td></tr><tr><td>Флаг IP ECT (4)</td><td>Значение</td><td>RC</td><td>UNKNOWN</td></tr><tr><td>Флаг IP CE (4)</td><td>Значение</td><td>RC</td><td>UNKNOWN</td></tr><tr><td>IP Id (4) последовательный</td><td>Диапазон</td><td>STATIC</td><td>KNOWN</td></tr><tr><td>IP Id (4) — увеличение</td><td>Диапазон</td><td>RC</td><td>LIMITED</td></tr><tr><td>IP Id (4) случайный</td><td>Значение</td><td>IRREGULAR</td><td>UNKNOWN</td></tr><tr><td>Флаг IP DF (4)</td><td>Значение</td><td>RC</td><td>UNKNOWN</td></tr><tr><td>IP TTL(4) / Hop Lim(6)</td><td>Значение</td><td>ALTERNATING</td><td>LIMITED</td></tr><tr><td>Порядковый номер TCP</td><td>Диапазон</td><td>IRREGULAR</td><td>LIMITED</td></tr><tr><td>Номер подтверждения TCP</td><td>Диапазон</td><td>IRREGULAR</td><td>LIMITED</td></tr><tr><td>TCP Reserved</td><td>Значение</td><td>RC</td><td>UNKNOWN</td></tr><tr><td>Флаг ECN</td><td>Значение</td><td>IRREGULAR</td><td>UNKNOWN</td></tr><tr><td>Флаг CWR</td><td>Значение</td><td>IRREGULAR</td><td>UNKNOWN</td></tr><tr><td>Флаг ECE</td><td>Значение</td><td>IRREGULAR</td><td>UNKNOWN</td></tr><tr><td>Флаг URG</td><td>Значение</td><td>IRREGULAR</td><td>UNKNOWN</td></tr><tr><td>Флаг ACK</td><td>Значение</td><td>IRREGULAR</td><td>KNOWN</td></tr><tr><td>Флаг PSH</td><td>Значение</td><td>IRREGULAR</td><td>UNKNOWN</td></tr><tr><td>Флаг RST</td><td>Значение</td><td>IRREGULAR</td><td>UNKNOWN</td></tr><tr><td>Флаг SYN</td><td>Значение</td><td>IRREGULAR</td><td>KNOWN</td></tr><tr><td>Флаг FIN</td><td>Значение</td><td>IRREGULAR</td><td>KNOWN</td></tr><tr><td>Окно TCP</td><td>Значение</td><td>ALTERNATING</td><td>KNOWN</td></tr><tr><td>Контрольная сумма TCP</td><td>Значение</td><td>IRREGULAR</td><td>UNKNOWN</td></tr><tr><td>Указатель срочности TCP</td><td>Значение</td><td>IRREGULAR</td><td>KNOWN</td></tr><tr><td>Опции TCP</td><td>Значение</td><td>IRREGULAR</td><td>UNKNOWN</td></tr><tr class="c nobrd"><td colspan="4">Рисунок 11: Классификация полей CHANGING</td></tr></table><p>В следующих параграфах приведено детальное обсуждение различных полей заголовков. Отметим, что рисунок 11 и и это обсуждение не учитывают потери или нарушения порядка доставки пакетов до точки сжатия.</p><h3 id="p4.1">4.1. Заголовок IP</h3><h4 id="p4.1.1">4.1.1. IP Traffic-Class / Type-Of-Service (TOS)</h4><p>Предполагается, что поля Traffic-Class (IPv6) и Type-Of-Service/DSCP (IPv4) могут изменять свои значения в течение срока существования потока пакетов. Этот анализ принимает во внимание несколько RFC, описывающих изменения исходной спецификации протокола в RFC 791 [1].</p><p>Байт TOS описан в исходной спецификации RFC 791 [1] как 3-битовое поле уровня предпочтения, за которым следует 3 бита TOS и 2 резервных бита (по определению равные 0). В RFC 1122 [21] размер поля TOS расширен до 5 битов, но значения двух добавленных битов не определены. RFC 1349 [23] определяет четвертый бит TOS как 'minimize monetary cost'. Следующее важное изменение содержится в RFC 2474 [14] (этот документ отменяет действие RFC 1349 [23]). RFC 2474 переопределяет октет TOS как 6-битовое поле DSCP (DiffServ Code Point), за которым следует 2 неиспользуемых бита. Позднее в RFC 2780 [30] эти два резервных бита октета TOS (или traffic class — класс трафика) определены для экспериментов с ECN.</p><p>Поэтому предполагается классифицировать октет TOS (или traffic class) как 6 битов DSCP и 2 дополнительных бита. Эти два бита могут предполагаться нулевыми или содержащими данные ECN. С учетом перспективы предпочтительней предполагать использование ECN, особенно в случае TCP.</p><p>Следует также обеспечить работу профиля со старыми вариантами стека, поскольку они будут применяться еще достаточно долго. Для простоты мы будем рассматривать поле как 6 битов TOS и 2 бита данных ECN во всех случаях.</p><p>Значение DSCP (как TOS в ROHC RTP) не предполагается изменяющимся часто (хотя оно может смениться посреди потока, например, в результате изменения маршрута).</p><h4 id="p4.1.2">4.1.2. Флаги ECN</h4><p>Сначала мы опишем флаги ECN в соответствии со спецификациями RFC 2481 [15] и RFC 3168 [18]. После этого будет описаное предлагаемое обновление, которое будет менять поведение флагов.</p><p>В RFC 2481 [15] определены 2 отдельных флага — ECT (ECN Capable Transport) и CE (Congestion Experienced). Флаг ECT, если он согласован стеком TCP, будет иметь значение 1 для всех пакетов с данными и 0 — для пакетов, содержащих только подтверждения. Это означает, что поведение флага ECT связано с поведением стека TCP. Непонятно, можно ли это использовать для компрессии.</p><p>Флаг CE используется только при установке ECT = 1. Отправитель устанавливает для флага значение 0, которое может быть заменено на 1 поддерживающим ECN маршрутизатором при возникновении в сети насыщения. Таким образом, предполагается, что флаг CE может быть в любой момент установлен в 1 в зависимости от состояния насыщения сети и местоположения системы компрессии на пути. Следовательно, система компрессии, расположенная близко к перегруженной сети часто будет видеть установленных флаг CE, а система сжатия, расположенная вблизи отправителя будет редко (или не будет совсем) видеть CE = 1.</p><p>Недавние экспериментальные предложения [19] используют иную трактовку этих битов, рассматривая их совместно как код, способный принимать 4 значения:</p><ul><li>00 — ECN не поддерживается</li><li>01 — поддерживается ECN, насыщение отсутствует (обозначается также ECT(0))</li><li>10 — поддерживается ECN, насыщение отсутствует (обозначается также ECT(1))</li><li>11 — присутствует насыщение.</li></ul><p>Использование двух кодов ECT позволяет отправителю детектировать ситуации, когда получатель не может надежно отвечать на информацию о перегрузке.</p><p>С точки зрения компрессии это изменение означает, что значения ECT(0) и ECT(1) равновероятны (для поддерживающего ECN потока), а значение 11 будет встречаться достаточно редко. Вероятность увидеть индикацию насыщения обсуждалась выре при описании флага CE.</p><p>В целях сжатия заголовков предлагается рассматривать значения ECN nonce в качестве базовых, хотя схема компрессии должна обеспечивать прозрачную компрессию для исходной схемы использования ECN.</p><h4 id="p4.1.3">4.1.3. Идентификация IP</h4><p>Поле Identification (IP ID) в заголовке IPv4 показывает какой фрагмент содержит дейтаграмма при сборке фрагментов пакета. Спецификация IPv4 не задает порядок присвоения значений идентификатора, указывая лишь, что каждому пакету следует давать уникальное для пары отправитель-получатель и используемого протокола значение IP ID. Уникальность должна обеспечиваться в течение интервала времени, которое дейтаграмма (или любой из ее фрагментов) могут находиться в сети. Это означает, что присвоение значений IP ID может выполняться различными путями, которые мы будем делить на три класса:</p><ul><li class="b">Sequential jump — нарастание</li><li class="lib">Это наиболее распространенная политика присвоения идентификаторов в современных вариантах стека IP. Один счетчик IP ID используется для всех потоков пакетов. Когда отправитель работает с множеством потоков одновременно, значение IP ID между последовательными пакетами одного потока может увеличиваться более, чем на 1. Значения IP ID являются легко предсказуемыми, для их передачи требуется меньшее количество битов, а увеличение идентификатора от пакета к пакету (определяется числом активных потоков исходящих пакетов и частотой передачи) обычно бывает ограничено.</li><li class="b">Random — случайные значения</li><li class="lib">Некоторые варианты стека IP используют в качестве IP ID псевдослучайные значения. В этом случае отсутствуют корреляции между значениями ID в последовательных пакетах. Следовательно, отсутствует возможность предсказать значение IP ID для следующей дейтаграммы. С точки зрения компрессии заголовков это означает, что поле IP ID нужно передавать без сжатия, что приводит к использованию двух лишних октетов в сжатом заголовке. Реализациям стека IP в терминалах сотовых сетей требуется эффективная компрессия, поэтому им не следует использовать данный вариант задания значений IP ID.</li><li class="b">Sequential — равномерное увеличение</li><li class="lib"><p>В этом варианте используется отдельный счетчик для каждого исходящего потока пакетов и значения IP ID будут увеличиваться на единицу для каждого следующего пакета (за исключением случаев достижения максимума и возврата к началу отсчета). Следовательно, изменение значения этого поля постоянно и заранее известно. Такой вариант присвоения идентификаторов наиболее подходит для сжатия заголовков. Однако его использование не столь широко, как следовало бы ожидать.</p><p>Во избежание нарушения требований спецификации RFC 791 [1], пакеты, использующие одну пару адресов «отправитель- получатель» и номер протокола IP, не могут иметь одинаковых значений IP ID. Следовательно, при выделении значений идентификатора по порядку нужно разделять значения идентификаторов для разных потоков одного протокола между одной парой конечных точек. Это можно сделать разными путями, каждый из которых использует случайные пропуски в порядке нумерации, что делает распределение идентификаторов не вполне последовательным. С точки зрения компрессии желательно реже использовать пропуски в значениях идентификаторов.</p></li></ul><p>Отметим, что эти идентификаторы используются только в IPv4 и, следовательно, не рассматриваются в IPv6. Для IPv4 поля ID могут обрабатываться тремя разными способами. Во-первых, имеется малоэффективное, но надежное решение, в котором поле идентификации передается без изменений во всех пакетах, что ведет к увеличению сжатых заголовков на 2 октета. Этот способ является наилучшим вариантом обработки полей ID в иех случаях, когда отправитель использует случайные значения ID. Во-вторых, может использоваться более гибкий механизм, который обеспечит снижение числа битов для полей ID при нарастающей (sequential jump) нумерации. Такие механизмы могут в некоторых случаях увеличивать число требуемых битов при использовании отправителем случайных значений идентификаторов. Следовательно, информация об используемом отправителем механизме выделения идентификаторов полезна при выборе между двумя упомянутыми выше решениями. Наконец, даже для IPv4 могут быть созданы схемы компрессии, не включающие в сжатый заголовок никакой дополнительной информации о поле ID. Для использования таких схем нужно знать какой из механизмов выделения значений поля ID применяется отправителем. Получение такой информации возможно не во всех случаях, что ведет к весьма редкому применению таких механизмов. Однако разработчикам стеков IPv4 для терминалов сотовых сетей следует использовать политику выделения идентификаторов, близкую к последовательной.</p><p>В контексте компрессии TCP поведение поля IP ID остается таким же. Однако в RFC 3095 [31] значения IP ID в общем случае получаются из порядковых номеров RTP. Для случая TCP нет подходящего кандидата на роль «ведущего порядкового номера».</p><p>Очевидно, что наблюдаемое поведение загруженного сервера может быть достаточно изменчивым. В некоторых случаях возможность совместного использования контекста компрессии IP для множества потоков (между одной парой конечных точек) может давать некоторые преимущества. Однако реальное воздействие может наблюдаться лишь в случаях использования большого числа потоков между конкретной машиной и сервером. Если рассматривается совместное использование контекста, предпочтительным будет совместное использование связанной с IP части контекста.</p><h4 id="p4.1.4">4.1.4. Флаг запрета фрагментации (DF)</h4><p>Механизм Path-MTU discovery (RFC 1191 для IPv4 [6] и RFC 1981 для IPv6 [11]) широко используется для протокола TCP, но весьма редко применяется сегодня для потоков пакетов UDP. Этот механизм использует флаг DF = 1 для определения необходимости фрагментирования на сквозном пути и нахождения минимального значения MTU вдоль этого пути. Можно предполагать, что конечные хосты, использующие этот механизм, будут передавать все пакеты с DF = 1, хотя хост может прекратить использование PMTU, установив DF = 0. С точки зрения компрессии мы считаем значение этого флага стабильным.</p><h4 id="p4.1.5">4.1.5. IP Hop-Limit / Time-To-Live (TTL)</h4><p>Поля Hop-Limit (IPv6) и Time-To-Live (IPv4) предполагаются постоянными в течение всего срока существования потока пакетов или чередующими значения из небольшого набора при изменении маршрутов.</p><h3 id="p4.2">4.2. Заголовок TCP</h3><p>Обсуждение сжимаемости полей TCP заимствовано из RFC 1144 [22]. Однако условия компрессии несколько отличаются, а используемые протоколы изменились.</p><h4 id="p4.2.1">4.2.1. Порядковый номер</h4><p>Понимание поведения порядковых номеров и номеров подтверждений имеет важное значение для схем сжатия TCP. На простейшем уровне поведение порядковых номеров можно объяснить достаточно легко. Однако имеется ряд осложняющих факторов, которые также следует рассмотреть.</p><p>Для последовательно передаваемых пакетов порядковые номера будут увеличиваться для каждого пакета на величину от 0 до верхнего предела, определяемого значением MSS (Maximum Segment Size) и, если этот механизм используется, Path-MTU discovery.</p><p>Существуют общепринятые значения MSS, но они могут изменяться в значительных пределах и непредсказуемыми для любого конкретного потока. С учетом этого факта и широкого диапазона размеров окна для представления порядковых номеров сложно (по сравнению с RTP, например) выбрать «одно решение на все случаи жизни».</p><p>Отметим, что увеличение порядковых номеров пакетов определяется размером данных в этом пакете (включая флаги SYN и FIN). Естественно, существуют точные соотношения, которые RFC 1144 [22] использует для сжатия порядковых номеров в наиболее эффективном случае. Этот метод не применим напрямую для устойчивых к ошибкам систем, но рассмотреть его полезно.</p><p>Однако в любой точке пути (например, там, где может быть развернута система компрессии) порядковые номера могут оказаться в любой точке окна TCP. Это зависит от множества параметров (размер буфера на стороне отправителя, анонсированный получателем размер буфера, алгоритм контроля насыщения TCP). Потеря пакетов или повтор передачи также могут вызывать флуктуации порядковых номеров в пределах этого окна.</p><p>Желательно иметь возможность предсказания порядковых с некоторой регулярностью. Однако сделать это сложно. Например, при передаче большого объема данных порядковые номера имеют тенденцию увеличения на величину MSS для каждого пакета (если предположить отсутствие потерь). Параметры вышележащих уровней также могут оказывать влияние — поведение порядковых номеров может повторяться с интервалом 8 кбайт — 5 сегментов по 1460 байтов, за которыми следует 1 сегмент размером 892 байта. Реализация TCP и управления буферами в стеке протоколов могут воздействовать на поведение порядковых номеров.</p><p>Система компрессии может отслеживать размер окна TCP, что позволяет ограничить размер этих переходов.</p><p>Для интерактивных потоков (например, telnet), порядковые номера будут увеличиваться на небольшие и нерегулярные значения. В этом случае обычно применим алгоритм Nagle [3], объединяющий по возможности мелкие пакеты для снижения объема служебного трафика (заголовков). Это может также вести к тому, что предсказать изменение порядковых номеров станет сложнее. Алгоритм Nagle предназначен для оптимизации и его не требуется использовать (приложения могут отключать этот алгоритм). Однако он включен по умолчанию во всех популярных реализациях TCP.</p><p>Отметим также, что флаги SYN и FIN (которые будут подтверждаться) также занимают 1 байт пространства порядковых номеров.</p><h4 id="p4.2.2">4.2.2. Номер подтверждения</h4><p>Большая часть информации, относящейся к порядковым номерам, применима и для номеров подтверждений. Однако имеются и некоторые важные отличия.</p><p>При передаче больших объемов данных обычно передается 1 подтверждение для каждой пары сегментов данных. Этот алгоритм описан в RFC 2581 [16]. Пакеты ACK не требуется передавать сразу же после получения сегмента данных, но подтверждения должны передаваться в течение 500 мсек и их следует генерировать по крайней мере для каждого второго полноразмерного (MSS) сегмента принятых данных. Может показаться, что увеличение номеров подтверждений приблизительно вдвое больше увеличения порядковых номеров. Однако это верно не во всех случаях и нерегулярность изменения порядковых номеров должна приниматься во внимание.</p><p>Отметим также распространенную ошибку реализаций 'stretch ACKs' [33] (подтверждения могут генерироваться реже, чем для каждого второго полноразмерного сегмента данных). Такая же картина может возникать при потерях на пути возврата подтверждений.</p><p>Поскольку номера подтверждений являются кумулятивными, отбрасывание путей на прямом пути будет приводить к тому, что номер подтверждения в течение некоторого времени не будет изменяться для обратного направления. Повторная передача отброшенных сегментов будет приводить к существенному увеличения номера подтверждения. Размер этого увеличения ограничен окном TCP как и для разового увеличения порядковых номеров. Для номеров подтверждений границу увеличения номера задает анонсируемый передающей стороной размер окна.</p><h4 id="p4.2.3">4.2.3. Резерв</h4><p>Значение резервного поля должно быть нулевым. Но это поле может использоваться в будущем и делать предположения о его значении не следует.</p><h4 id="p4.2.4">4.2.4. Флаги</h4><ul><li class="b">ECN-E (Explicit Congestion Notification — явное уведомление о перегрузке)</li><li class="lib">1 устанавливается как эхо бита CE в заголовке IP. Это значение будет устанавливаться в нескольких последовательных заголовках (пока не будет подтвержден с помощью CWR). При использовании ECN nonce в этом флаге будет передаваться бит суммы nonce (NS). Как обычно, прозрачность резервного бита важна для работы схемы компрессии в будущем. С точки зрения соотношения эффективность/сжатие бит NS не будет использоваться (всегда 0) или будет произвольно изменяться. Сумма nonce представляет собой 1-битовое значение суммы кодов ECT, как описано в [19].</li><li class="b">CWR (Congestion Window Reduced — окно насыщения уменьшено)</li><li class="lib">1 устанавливается для обозначения уменьшения размера окна насыщения в ответ на ECN. Это значение в общем случае устанавливается для отдельного пакета. Флаг устанавливается однократно в ответ на потерю пакета. Таким образом, вероятность установки этого флага пропорциональна степени насыщения сети, но очевидно меньше вероятности установки флага CE.</li><li class="b">ECE (Echo Congestion Experience — сигнал о возникновении перегрузки в сети)</li><li class="lib"><p>При получении в заголовке IP сигнала о перегрузке в сети, в ответ возвращается эхо-сигнал (бит ECE) в сегментах, передаваемых получателем до приема подтверждения о получении сигнала в виде установленного бита CWR. Очевидно, что в периоды насыщения и/или при большом значении RTT этот флаг часто будет иметь значение 1.</p><p>При организации соединения (пакеты SYN и SYN/ACK) бит ECN имеет специальное значение:</p><ul class="dot"><li>Флаги CWR и ECN-E устанавливаются в пакетах SYN для индикации желания использовать ECN.</li><li>Флаг CWR устанавливается в пакетах SYN-ACK для подтверждения использования ECN. (различие в битовых последовательностях для согласования сделано для того, чтобы можно было работать со старыми стеками, не понимающими расширение).</li></ul></li><li class="b">URG (Urgent Flag — флаг срочности)</li><li class="lib">1 указывает на срочность данных (маловероятно использование этого флага с какими-либо флагами, кроме ACK).</li><li class="b">ACK (Acknowledgement — подтверждение)</li><li class="lib">1 во всех случаях, кроме стартового пакета SYN.</li><li class="b">PSH (Push Function Field — выталкивание данных)</li><li class="lib">В общем случае произвольно меняется между 0 и 1. Однако одно из значений может встречаться чаще другого В основном определяется используемым стеком протоколов).</li><li class="b">RST (Reset Connection — сброс соединения)</li><li class="lib">1 устанавливается для сброса соединения (маловероятно использование этого флага с какими-либо флагами, кроме ACK).</li><li class="b">SYN (Synchronize Sequence Number — синхронизация порядковых номеров)</li><li class="lib">1 устанавливается для пакетов SYN/SYN-ACK на этапе организации соединения.</li><li class="b">FIN (End of Data: FINished — завершение передачи данных)</li><li class="lib">1 показывает отсутствие данных для передачи (маловероятно использование этого флага с какими-либо флагами, кроме ACK).</li></ul><h4 id="p4.2.5">4.2.5. Контрольная сумма</h4><p>Контрольная сумма служит для сквозного контроля отсутствия ошибок в данных TCP. Обсуждение вопросов работы с контрольными суммами содержится в RFC 1144 [22]. Схемам компрессии заголовков не следует полагаться на контрольную сумму TCP, хотя им следует применять свой подходящий механизм детектирования ошибок. Контрольные суммы TCP рассматриваются как произвольно изменяющиеся значения.</p><h4 id="p4.2.6">4.2.6. Окно (Window)</h4><p>Размер окна может изменяться от 0 до установленного получателем предела (для данного соединения).</p><p>На практике размер окна сохраняется постоянным или чередуется небольшой набор значений. В частности, при снижении размера окна ясно, что это связано с размером сегмента, но какие-то преимущества с точки зрения компрессии не очевидны. При увеличении размера окна следует помнить об эффекте 'Silly-Window Syndrome', который может заставить отправителя передавать данные в очень мелких сегментах.</p><p>При обсуждении поведения полей в последовательности сегментов TCP следует отметить, что получатель может генерировать сегменты 'window update', в которых изменяется только анонсируемый размер окна.</p><h4 id="p4.2.7">4.2.7. Указатель срочности (Urgent)</h4><p>С точки зрения компрессии поле Urgent Pointer представляет интерес по той причине, что оно служит показательным примером того, как «семантически идентичная» компрессия отличается от идентичной на битовом уровне. Это связано с тем, что поле указателя срочности имеет смысл только при установленном флаге URG.</p><p>Однако для обеспечения сквозного контроля целостности требуется прозрачная передача контрольной суммы TCP. Поскольку эта контрольная сумма учитывает поле Urgent Pointer, это требует обеспечивать побитовую идентичность для поля Urgent Pointer. Таким образом, поле Urgent Pointer требуется сжимать так, чтобы сохранялось его значение.</p><p>При установленном флаге URG поле Urgent Pointer указывает на окончание срочных данных, которое может находиться в любой точке окна. Срочные данные могут содержаться в нескольких данных и значение указателя срочности может изменяться. Отметим, что пользуются указателем срочности достаточно редко, поскольку он не обеспечивает эффективного способа управления данными на практике.</p><h3 id="p4.3">4.3. Опции</h3><p>Опции размещаются в конце заголовка TCP и учитываются при вычислении контрольной суммы. Опция может начинаться на любой границе байта. Заголовок TCP должен дополняться нулями для выравнивания по 32-битовой границе.</p><p>Необязательные поля заголовка идентифицируются полем типа опции. Опции типа 0 и 1 занимают один октет. Все остальные опции имеют 1-октетное поле типа, за которым следует октет размера (length) и поле данных, размером length-2 октета.</p><h4 id="p4.3.1">4.3.1. Обзор опций</h4><p>Агентство IANA поддерживает официальный список определенных опций TCP. На рисунке 12 показан список опций, определенных на момент публикации документа. Любая опция имеет идентификатор типа, выделенный IANA. Список опций доступен на сайте [20]. В тех случаях, когда это применимо, список опций содержит ссылки на RFC.</p><table><tr><td>Тип</td><td>Размер в октетах</td><td>Значение</td><td>RFC</td><td>Применение</td></tr><tr><td>0</td><td>-</td><td>End of Option List</td><td>RFC 793</td><td>*</td></tr><tr><td>1</td><td>-</td><td>No-Operation</td><td>RFC 793</td><td>*</td></tr><tr><td>2</td><td>4</td><td>Maximum Segment Size</td><td>RFC 793</td><td>*</td></tr><tr><td>3</td><td>3</td><td>WSopt — Window Scale</td><td>RFC 1323</td><td>*</td></tr><tr><td>4</td><td>2</td><td>SACK Permitted</td><td>RFC 2018</td><td>*</td></tr><tr><td>5</td><td>N</td><td>SACK</td><td>RFC 2018</td><td>*</td></tr><tr><td>6</td><td>6</td><td>Echo (отменено опцией 8)</td><td>RFC 1072</td><td></td></tr><tr><td>7</td><td>6</td><td>Echo Reply (отменено опцией 8)</td><td>RFC 1072</td><td></td></tr><tr><td>8</td><td>10</td><td>TSopt — Time Stamp Option</td><td>RFC 1323</td><td>*</td></tr><tr><td>9</td><td>2</td><td>Partial Order Connection Permitted</td><td>RFC 1693</td><td>*</td></tr><tr><td>10</td><td>3</td><td>Partial Order Service Profile</td><td>RFC 1693</td><td></td></tr><tr><td>11</td><td>6</td><td>CC</td><td>RFC 1644</td><td></td></tr><tr><td>12</td><td>6</td><td>CC.NEW RFC</td><td>1644</td><td></td></tr><tr><td>13</td><td>6</td><td>CC.ECHO RFC</td><td>1644</td><td></td></tr><tr><td>14</td><td>3</td><td>Alternate Checksum Request</td><td>RFC 1146</td><td></td></tr><tr><td>15</td><td>N</td><td>Alternate Checksum Data</td><td>RFC 1146</td><td></td></tr><tr><td>16</td><td></td><td>Skeeter</td><td></td><td></td></tr><tr><td>17</td><td></td><td>Bubba</td><td></td><td></td></tr><tr><td>18</td><td>3</td><td>Trailer Checksum Option</td><td></td><td></td></tr><tr><td>19</td><td>18</td><td>MD5 Signature Option</td><td>RFC 2385</td><td></td></tr><tr><td>20</td><td></td><td>SCPS Capabilities</td><td></td><td></td></tr><tr><td>21</td><td></td><td>Selective Negative Acks</td><td></td><td></td></tr><tr><td>22</td><td></td><td>Record Boundaries</td><td></td><td></td></tr><tr><td>23</td><td></td><td>Corruption experienced</td><td></td><td></td></tr><tr><td>24</td><td></td><td>SNAP</td><td></td><td></td></tr><tr><td>25</td><td></td><td>Unassigned (с 18.12.2000)</td><td></td><td></td></tr><tr><td>26</td><td></td><td>TCP Compression Filter</td><td></td><td></td></tr><tr class="c nobrd"><td colspan="5">Рисунок 12: Опции TCP общего назначения</td></tr></table><p>Знак * в колонке «Применение» отмечает опции, которые чаще встречаются в потоках TCP. Отметим также, что RFC 1072 [4] был заменен RFC 1323 [7], хотя исходное использование битов определено в 1072.</p><h4 id="p4.3.2">4.3.2. Поведение поля опций</h4><p>В общем случае все поля опций классифицируются как изменяющиеся. В этом параграфе рассматривается поведение каждой опции, определенное в RFC, указанном для данного типа опций.</p><ul><li class="b">0: End of Option List — конец списка опций</li><li class="lib">Этот тип указывает на завершение списка опций, которое может не совпадать с концом заголовка TCP, определяемым полем Data Offset. Эта опция указывается после завершения всех опций, а не какой-то отдельной опции, но ее необходимо использовать лишь в тех случаях, когда точки завершения заголовка TCP и списка опций не совпадают. Опция определена в RFC 793 [2]. С этой опцией не связано никаких данных, поэтому схеме компрессии достаточно просто закодировать присутствие опции. Однако, следует помнить о возможном присутствии после опции битов заполнения для выравнивания заголовка TCP по 4- октетной границе (биты заполнения имеют значение 0 в соответствии с документом [2]).</li><li class="b">1: No-Operation — нет операции</li><li class="lib">Эта опция может включаться между другими опциями заголовка (например, для выравнивания следующей опции по границе слова). Использование такого выравнивания на передающей стороне не гарантируется, поэтому получатель должен быть готов к обработке опций, которые начинаются не на границе слова (RFC 793 [2]). С этой опцией не связано никаких данных, поэтому схеме компрессии достаточно показать наличие опции. Это можно сделать путем обозначения наличия выравнивания и необходимости передачи информации о нем. В этом случае биты заполнения могут быть удалены.</li><li class="b">2: Maximum Segment Size — максимальный размер сегмента</li><li class="lib"><p>При наличии этой опции она определяет максимальный размер сегмента, который может быть передан данному конечному хосту. Этот поле следует устанавливать только в стартовом запросе на организацию соединения (т. е., в сегменте с флагом SYN). Если опция не используется, можно использовать сегменты любого размера в соответствии с RFC 793 [2].</p><p>Эта опция применяется очень часто. Размеры сегментов задаются с гранулярностью 16 битов. Теоретически может использоваться любой размер, однако на практике обычно применяется небольшой ряд значений. Например, значение 1460 байтов характерно для использования TCP/IPv4 в сетях Ethernet (хотя с ростом популярности туннелей все чаще используется значение 1400). По умолчанию для MSS используется значение 536. Распространенные значения поля могут кодироваться более эффективно.</p></li><li class="b">3: Window Scale Option (Wsopt) — опция масштабирования окна</li><li class="lib"><p>Эта опция может передаваться в сегменте SYN конечным хостом TCP для</p><ol><li>индикации передающему хосту TCP возможности масштабирования окон приема и передачи;</li><li>индикации коэффициента масштабирования окна приема.</li></ol><p>Коэффициент масштабирования окна задается в виде двоичного логарифма (возможно потому, что используется битовый сдвиг). Отметим, что окно в самом сегменте SYN никогда не масштабируется (RFC 1072 [4]). Данная опция может передаваться в начальном сегменте (т. е., в сегменте с установленным флагом SYN и сброшенным флагом ACK). Возможно использование опции и в последующих сегментах, но только при условии получения опции Window Scale в начальном сегменте. Опции Window Scale в сегментах без флага SYN следует игнорировать. Поле Window в самом сегменте SYN никогда не масштабируется (RFC 1323 [7]).</p><p>Масштабирование окна не влияет на кодирование других полей в течение срока существования соединения. Важно лишь кодирование самой опции масштабирования окна. Значения размера окна должны находиться в диапазоне от 0 до 14 (включительно). В общем случае следует ожидать не слишком больших значений, поскольку 14 соответствует размеру окна 1 Гбайт (слишком много).</p></li><li class="b">4: SACK-Permitted — возможность использования SACK</li><li class="lib">Эта опция может передаваться при организации соединения в пакетах SYN узлами TCP, которые готовы принимать (и, вероятно, обрабатывать) опцию SACK RFC 2018 [12]. Опция не включает каких-либо данных, которые нужно было бы сохранять при ее кодировании.</li><li class="b">5: SACK — частичное подтверждение</li><li class="lib"><p>Эта опция может использоваться для передачи в существующих соединениях расширенных подтверждений доставки. В частности получатель блоков данных с нарушением порядка может с помощью этой опции уведомить отправителя о приеме и буферизации таких блоков. Получатель ждет приема недостающих блоков в повторных пакетах для заполнения имеющихся в данных пропусков. В это же время получатель подтверждает данные, обычно указывая левый край окна в поле Acknowledgment Number заголовка TCP. Важно понимать, что опция SACK не меняет трактовку поля Acknowledgment Number, значение которого по прежнему указывает на левый край окна (т. е., на один байт больше порядкового номера последних данных, которые получены полностью RFC 2018 [12]).</p><p>Если использование SACK согласовано сторонами (путем обмена опциями SACK-Permitted), данная опция может применяться в тех случаях, когда получатель уведомляет о потерянных сегментах. Поскольку опция идентифицирует диапазоны блоков в окне приема, она может рассматриваться как базовое значение и набор значений смещения. Базовое значение (левый край первого блока) можно рассматривать как смещение от номера подтверждения TCP. В одной опции может указываться до 4 блоков SACK. Блоки SACK могут возникать во многих сегментах (если в сети часто нарушается порядок доставки) и будут, таким образом, расширять размер уже указанных блоков или добавлять новые блоки.</p><p>Дополнительные расширения типа DSACK RFC 2883 [17] не меняют существенно поведения блоков SACK в плане содержащейся в этих блоках информации.</p></li><li class="b">6: Echo — эхо</li><li class="lib"><p>Эта опция содержит информацию, которую принимающая сторона TCP может вернуть в последующей опции TCP Echo Reply (см. ниже). TCP может передать опцию TCP Echo в любом сегменте при условии, что в сегменте SYN при организации соединения была получена опция TCP Echo. При использовании опции TCP echo для измерения RTT эта опция включается в сегменты данных, а четыре информационных байта будут определять время передачи сегмента данных в удобном для отправителя формате (см. RFC 1072 [4]).</p><p>Опция Echo обычно не используется на практике, поскольку она заменена опцией Timestamp. Однако для обеспечения прозрачности схемам компрессии следует обеспечивать возможность поддержки этой опции. Однако не возникает никаких дополнительных преимуществ в результате какой-то специальной трактовки этой опции (отличной от «стандартного» для опций подхода).</p></li><li class="b">7: Echo Reply — эхо-отклик</li><li class="lib"><p>Модуль TCP, получивший опцию TCP Echo, содержащую 4 байта данных, будет возвращать эти байты ы опции TCP Echo Reply. Опция TCP Echo Reply должна возвращаться при передаче следующего сегмента (например, ACK). Если до отправки следующего сегмента будут получены новые опции Echo, модуль TCP должен выбрать только одну из них, игнорируя остальные (доkжен выбираться самый новый сегмент с самым старым порядковым номером — RFC 1072 [4]).</p><p>Опция Echo Reply обычно не используется на практике, поскольку она заменена опцией Timestamp. Однако для обеспечения прозрачности схемам компрессии следует обеспечивать возможность поддержки этой опции. Однако не возникает никаких дополнительных преимуществ в результате какой-то специальной трактовки этой опции (отличной от «стандартного» для опций подхода).</p></li><li class="b">8: Timestamps — временные метки</li><li class="lib"><p>Эта опция передает два 4-байтовых поля с временными метками. Поле Timestamp Value (TSval) содержит текущее значение временной метки передавшего опцию модуля TCP. Поле Timestamp Echo Reply (TSecr) имеет смысл только при наличии в заголовке TCP флага ACK и в этом случае содержит временную метку, переданную удаленным модулем TCP в поле TSval опции Timestamps. Когда поле TSecr не имеет смысла, оно должно содержать 0. В общем случае значение TSecr берется из последней принятой опции Timestamp, однако ниже рассмотрено несколько исключений из этого правила. TCP может включать опцию Timestamps (TSopt) в начальный сегмент (сегмент с флагом SYN, но без флага ACK), а также может передавать TSopt в других сегментах, если в начальном сегменте соединения было получено поле TSopt (см. RFC 1323 [7]).</p><p>Временные метки используются достаточно часто. Если эта опция используется на этапе организации соединения, следует ожидать ее появления и во всех последующих сегментах. Если в стартовых сегментах опции не было, она не может присутствовать и в других сегментах данного потока.</p><p>Поскольку поле содержит значение временной метки, логично предположить, что его не требуется передавать целиком. Однако картина изменения временных меток может быть различной.</p><p>Одной из важных причин использования временных меток является детектирование повторного использования порядковых номеров (защита от PAWS, см. RFC 1323 [7]). Для соединений, использующих компрессию заголовков TCP такая угроза обычно отсутствует, но важно обеспечить целостность опции. Этот вопрос рассматривается в документе RFC 3150 [32]. Однако предложенный алгоритм Эйфеля (Eifel) [35] рекомендует использовать временные метки на каналах сотовых сетей [34].</p><p>В части компрессии отметим, что диапазон разрешения для временных меток, предложенный в RFC 1323 [7] достаточно широк (от 1 мсек до 1 сек на «тик»). Вкупе с возможностью значительных вариаций RTT это осложняет выбор кодирвания, которое было бы оптимальным для всех случаев.</p></li><li class="b">9: Partial Order Connection (POC) permitted — возможность неполного упорядочивания</li><li class="lib"><p>Эта опция является простым индикатором, с помощью которого обе стороны соединения могут согласовать использование протокола POC (см. RFC 1693 [9]).</p><p>Соединения с неполным упорядочиванием редко используются (а может быть не используются совсем) в современной сети Internet, поэтому единственным требованием к схеме компрессии является обеспечение возможности кодирования этой опции.</p></li><li class="b">10: POC service profile — профиль POC</li><li class="lib"><p>Эта опция служит для обмена информацией, обеспечивающей работу протокола (обычная информация из заголовков TCP). Соединения с неполным упорядочиванием редко используются (а может быть не используются совсем) в современной сети Internet, поэтому единственным требованием к схеме компрессии является обеспечение возможности кодирования этой опции.</p></li><li class="b">11: Connection Count (CC) — счетчик соединений</li><li class="lib"><p>Эта опция является частью реализации TAO (TCP Accelerated Open), которая позволяет обойтись без трехэтапного согласования TCP Three-Way Handshake (3WHS). TAO использует 32-битовый номер инкарнации, называемый счетчиком соединений (connection count или CC), который передается в опции TCP каждого сегмента. Для каждого из направлений соединения TCP используется свое значение CC. Реализации присваивают монотонно возрастающие значения CC для последующих соединений, которые открываются активно или пассивно 9см. RFC 1644 [8]). Эта опция редко используется (а может быть не используется совсем) в современной сети Internet, поэтому единственным требованием к схеме компрессии является обеспечение возможности кодирования этой опции.</p></li><li class="b">12: CC.NEW</li><li class="lib"><p>Для корректной работы механизма TAO от клиентов требуется генерация монотонно возрастающих значений CC при успешной организации соединений. Получение опции CC.NEW заставляет сервер объявить некорректной кэшированную запись и выполнить процедуру 3WHS (см. RFC 1644 [8]). Эта опция редко используется (а может быть не используется совсем) в современной сети Internet, поэтому единственным требованием к схеме компрессии является обеспечение возможности кодирования этой опции.</p></li><li class="b">13: CC.ECHO</li><li class="lib">Когда сервер передает сегмент, он возвращает значение счетчика соединений из начальной опции CC.ECHO, которое используется клиентом для проверки корректности сегмента (см. RFC 1644 [8]). Эта опция редко используется (а может быть не используется совсем) в современной сети Internet, поэтому единственным требованием к схеме компрессии является обеспечение возможности кодирования этой опции.</li><li class="b">14: Alternate Checksum Request — запрос на изменение алгоритма расчета контрольной суммы</li><li class="lib"><p>Эта опция может быть передана в сегменте SYN для индикации того, что модуль TCP готов генерировать и принимать контрольные суммы, рассчитанные с использованием альтернативного алгоритма. В течение срока существования соединения такие суммы будут использоваться в заголовках TCP вместо обычных контрольных сумм TCP. Если нестандартная контрольная сумма имеет размер более 2 октетов, она может полностью помещаться в поле опции TCP Alternate Checksum Data Option с установкой нулевого значения в поле контрольной суммы заголовка TCP или указываться по частям в поле заголовка и опции. Для расчета контрольный сумм по иному алгоритму используется тот же набор данных, что и для обычных контрольных сумм TCP (см. RFC 1146 [5]).</p><p>Эта опция редко используется (а может быть не используется совсем) в современной сети Internet, поэтому единственным требованием к схеме компрессии является обеспечение возможности кодирования этой опции. Опция может использоваться только на этапе организации соединения (SYN-пакеты). Даже при наличии этой опции она не будет оказывать влияния на обработку контрольной суммы, поскольку для нее должна обеспечиваться прозрачность во всех случаях.</p></li><li class="b">15: Alternate Checksum Data — альтернативная контрольная сумма</li><li class="lib"><p>Это поле используется лишь в тех случаях, когда согласованная контрольная сумма имеет размер более 16 битов. Такие суммы не помещаются в стандартное поле заголовка TCP и должны по крайней мере частично указываться в данной опции. При расщеплении контрольной суммы между заголовком TCP и данной опцией или включении всей контрольной суммы в поле опции определяется независимо для каждой контрольной суммы. Размер этой опции будет зависеть от выбранного механизма генерации контрольных сумм для данного соединения (см. RFC 1146 [5]).</p><p>Если использование нестандартного алгоритма подсчета контрольных сумм согласовано при организации соединения, эта опция может появляться во всех последующих пакетах (если она требуется). Однако данная опция на практике почти не используется, поэтому единственным требованием к схеме компрессии является обеспечение возможности кодирования этой опции.</p></li><li class="b">16 — 18:</li><li class="lib">Эти опции, не включенные в RFC, не рассматриваются в данном документе.</li><li class="b">19: MD5 Digest — сигнатура MD5</li><li class="lib"><p>Каждый сегмент, передаваемый в соединение TCP будет защищаться от подмены путем включения в него 16-битовой сигнатуры MD5, получаемой с помощью алгоритма MD5 для собранного вместе (concatenate) блока данных [13].</p><p>При получении подписанного сегмента получатель должен проверить его путем расчета сигнатуры для тех же данных (с использованием своего ключа) и сравнения с полученной сигнатурой. При обнаружении различий сегмент должен отбрасываться без передачи серверу какого-либо отклика на него. Разумно также сохранять информацию о таких событиях в системном журнале.</p><p>В отличие от других расширений TCP (например, от опции Window Scale [7]), отсутствие данной опции в сегменте SYN-ACK не должно заставлять отправителя отключать использование подписей в своих сегментах. Такое согласование обычно делается для предотвращения некорректного поведения некоторых реализаций TCP при получении опции в отличных от SYN сегментах. Это не вызывает проблем для данной опции, поскольку сегменты SYN-ACK, передаваемые в процессе организации соединений, не будут подписаны и, следовательно, будут игнорироваться. В результате этого соединение не будет организовано и опция просто не сможет появиться в сегментах без флага SYN. Более важно то, что передача сигнатур должна вестись под полным контролем приложения, а не по милости удаленного хоста, который не понимает эту опцию. Сигнатуры MD5 следует, подобно любым криптографически защищенным данным, передавать без использования компрессии. Следовательно, схема компрессии должна просто обеспечивать прозрачную передачу этой опции.</p></li><li class="b">20 — 26;</li><li class="lib">Эти опции, не включенные в RFC, не рассматриваются в данном документе. Это означает, что детали их поведения не описываются и не ожидается, что схема компрессии оптимизирована для работы с такими опциями. Однако любые нераспознанные опции должны прозрачно передаваться схемой компрессии TCP для обеспечения эффективной работы с редкими и новыми опциями.</li></ul><p>Приведенный выше список включает опции, известные на момент создания этого документа. Предполагается, что могут быть определены другие опции. Важно обеспечить обработку будущих опций системой компрессии заголовков. Обработка неизвестных пока опций не может быть оптимизирована, но они, по крайней мере, должны прозрачно передаваться.</p><p>Современная модель использования опций TCP включает согласование опций в процессе обмена сегментами SYN и последующее использование согласованных сторонами опций. Это ведет к возможности некоторых допущений о присутствии тех или иных опций (только в пакетах с флагом SYN, в каждом пакете и т. п.). Когда такие допущения корректны, они помогают несколько оптимизировать сжатие заголовков. Однако такие допущения нежелательны, поскольку нет гарантии, что обработка и согласование опций не изменится в будущем. Отметим также, что система компрессии может не обрабатывать SYN-пакеты потока и, следовательно, не может знать о том, какие опции согласованы для использования.</p><h2 id="p5">5. Другие наблюдения</h2><h3 id="p5.1">5.1. Неявные подтверждения</h3><p>Для потоков TCP существует небольшое число намеков на неявные подтверждения. Даже если система компрессии видит только одно направление потока TCP, она может судить о получении пакета SYN просто по наличию передаваемых пакетов без флага SYN.</p><p>Для систем компрессии существует четкое требование независимости от топологии. Это означает, на практике невозможно гарантировать, что просмотр пакетов данных на уровне системы компрессии позволяет гарантированно судить о получении пакета SYN системой декомпрессии (поскольку пакет SYN может идти по иному пути).</p><p>Однако существуют некоторые косвенные признаки, которые могут использоваться в определенных обстоятельствах для повышение эффективности компрессии.</p><h3 id="p5.2">5.2. Совместно используемые данные</h3><p>Представляется разумным рассмотреть два случая — (i) когда прямой (данные) и обратный (ACK) путь проходят по общему каналу и (ii) когда прямой (данные) и обратный (ACK) путь проходят по разным каналам, каждый из которых используется только для определенного направления.</p><p>В первом случае компрессор и декомпрессор могут располагаться в одном месте. Тогда компрессор и декомпрессор на каждой стороне соединения могут обмениваться информацией. Такой обмен может повысить уровень эффективности.</p><p>Например, номера подтверждений обычно берутся из порядковых номеров противоположного направления. Поскольку подтверждение не может генерироваться для пакета, который еще не прошел через канал, это обеспечивает эффективный способ кодирования подтверждений.</p><h3 id="p5.3">5.3. Доля заголовков TCP</h3><p>При передаче больших объемов данных TCP доля заголовков TCP невелика по сравнению с общим размером пакетов (например, &lt; 3% для пакетов размером 1460 октетов) и сравнима с долей заголовков в типичном голосовом потоке RTP. Очевидно, что спектральная эффективность является важной целью. Однако «выжимание последних битов» при компрессии дает незначительное повышение эффективности при существенном росте сложности. При создании профилей компрессии TCP нужно искать компромисс между эффективностью и сложностью.</p><p>Однако в направлении подтверждений (т. е., для заголовков «чистых» подтверждений) долю заголовков можно считать бесконечной, поскольку объем передаваемых данных равен нулю. Поэтому оптимизация для пути подтверждений может считаться полезной.</p><p>Существует множество схем работы с подтверждениями TCP, позволяющих снизить расход полосы на передачу ACK. Многие из таких схем описаны в документах [33] и [32]. Большинство этих схем полностью совместимо с компрессией заголовков без каких-либо дополнительных усилий. Хотя и не предполагается оптимизация схем компрессии для экспериментальных опций, полезно учитывать эти опции при разработке схем компрессии (и наоборот, учитывать схемы компрессии при создании новых опций). Схема компрессии заголовков должна быть способна поддерживать любые опции, включая те, которые еще не определены.</p><h3 id="p5.4">5.4. Независимость полей и поведение пакетов</h3><p>Ясно, что прямое сравнение с сильно ориентированной на пакеты компрессией RTP достаточно сложно. Поля заголовков RTP имеют тенденцию регулярных изменений от пакета к пакету, а многие поля (например, IPv4 IP ID, порядковый номер RTP, временные метки RTP) изменяются в зависимости одно от другого. Однако поля TCP (такие, как порядковый номер) менее предсказуемы отчасти в результате влияния внешних факторов (размеры окна TCP, поведение приложение и т. п.). Значения полей также изменяются независимо. Все это в целом дает дополнительные стимулы для выполнения компрессии и осложняет выбор набора вариантов кодирования, который обеспечит эффективность в сочетании с устойчивостью к ошибкам.</p><h3 id="p5.5">5.5. Короткоживущие потоки</h3><p>Сложно предположить, как можно повысить производительность для отдельного, непредсказуемого и короткоживущего соединения. Однако существует множество типовых ситуаций, когда организуется множество соединений TCP между одной парой хостов. Одним из таких примеров может служить web-серфинг (это более относится к HTTP/1.0 [25], нежели к HTTP/1.1 [26]).</p><p>Когда соединение закрывается, оно может быть последним между данной парой хостов, но чаще в течение сравнительно короткого времени создается новое соединение. В этом случае связанная с заголовком IP часть контекста (т. е., поля, описанные в параграфе 2.1) будет сохраняться почти без изменений. Некоторые аспекты контекста TCP также сохранят сходство.</p><p>Поддержка репликации более детально рассматривалась в главе 3. В целом, поддержка совместного использования части контекста или генерация одного контекста из другого обеспечивает оптимизацию для последовательности соединений с небольшим сроком существования.</p><p>Отметим, что несмотря на то, что протокол TCP использует прямые соединения, компрессору сложно сказать, когда завершится поток TCP. Например, даже для «двухстороннего» соединения получение подтверждение (ACK) пакета FIN в компрессоре/декомпрессоре не означает, что не может быть повтора передачи FIN. Поэтому может оказаться более полезной инициализация нового контекста на основе существующего, нежели повторное использование имеющегося контекста.</p><p>Как было отмечено в параграфе 4.1.3, заголовок IP может совместно использоваться множеством транспортных потоков между одной парой конечных точек. Это может быть использовано при инициализации новых заголовков TCP из существующих заголовков. Начинают обычно с номеров портов.</p><h3 id="p5.6">5.6. Master Sequence Number</h3><p>Как было отмечено в параграфе 4.1.3, в TCP не существует очевидного кандидата на роль «ведущего порядкового номера». Более того, отмечено, что такой «ведущий» номер требуется только для того, чтобы позволить декомпрессору подтверждать пакеты в двухстороннем режиме. Понятно, также, что такой порядковый номер не будет требоваться для каждого пакета.</p><p>Хотя пространство порядковых номеров и представляется обширным, очевидно, что имеется необходимость в его расширении. Не существует очевидного способа обеспечить гарантию уникальности пакетов без такого расширения пространства номеров (порядковые номера и номера подтверждений могут по-прежнему использовать общее пространство).</p><h3 id="p5.7">5.7. Ограничение размера опций TCP</h3><p>Как можно видеть из приведенного выше обсуждения, большинство опций TCP, таких, как MSS, Wsopt или SACK-Permitted может появляться только в сегментах SYN. Каждой реализации следует (и предполагается, что это выполняется на практике) игнорировать неизвестные опции в сегментах SYN. Опции TCP будут передаваться в сегментах без флага SYN лишь в тех случаях, когда обмен опциями в SYN-сегментах показал, что обе стороны понимают данное расширение. Другие опции TCP, такие, как MD5 Digest или Timestamp, также обычно передаются в процессе организации соединений (т. е., в пакетах SYN).</p><p>Общий размер заголовка также является предметом обсуждения. Заголовок TCP показывает начало сегмента данных с помощью 4-битового поля, определяющего общий (с учетом опций) размер заголовка в 32-битовых словах. Это означает, что общий размер заголовка и опций не может превышать 60 байтов (т. е., на опции остается не более 40 байтов).</p><h2 id="p6">6. Вопросы безопасности</h2><p>Поскольку этот документ лишь описывает поведение полей TCP, он не создает новых проблем безопасности.</p><p>Документ предназначен для использования в целях компрессии заголовков TCP/IP. При работе с механизма аутентификации типа IPsec AH [24] важно обеспечить прозрачность сжатия. При использовании шифрования (например, IPsec ESP [27]) поля TCP могут стать невидимыми, что будет препятствовать их сжатию.</p><h2 id="p7">7. Благодарности</h2><p>Множество посвященных протоколам IP и TCP документов RFC (надеемся, что ниже перечислены все эти документы), вместе с посвященными схемам компрессии RFC 1144 [22], RFC 3544 [36] и RFC 3095 [31], а также подробный анализ RTP/UDP/IP в RFC 3095 послужили источниками идей и информации для этой работы. Дополнительная информация по основам компресии содержится также в документах [28] и [29].</p><p>Этот документ основан также на обсуждениях в почтовой конференции ROHC и различных коридорах (виртуальных и иных) множества ключевых вопросов. Особая благодарность Qian Zhang, Carsten Bormann и Gorry Fairhurst.</p><p>Qian Zhang и Hongbin Liao внесли свой вклад по анализу используемых совместно полей заголовков.</p><p>Все ошибки и погрешности представления и интерпретации остаются на совести авторов этого документа.</p><h2 id="p8">8. Литература</h2><h2 id="p8.1">8.1. Нормативные документы</h2><table itemprop="references"><tr><td>[1]</td><td>Postel, J., <a href="../791.rfc" title="RFC 791 - Internet Protocol">«Internet Protocol», STD 5, RFC 791</a>, Сентябрь 1981</td></tr><tr><td>[2]</td><td>Postel, J., <a href="../793.rfc" title="RFC 793 - Протокол управления передачей">«Протокол TCP», STD 7, RFC 793</a>, Сентябрь 1981.</td></tr><tr><td>[3]</td><td>Nagle, J., «Congestion control in IP/TCP internetworks», RFC 896, Январь 1984.</td></tr><tr><td>[4]</td><td>Jacobson, V. и R. Braden, «TCP extensions for long-delay paths», RFC 1072, October 1988.</td></tr><tr><td>[5]</td><td>Zweig, J. и C. Partridge, «TCP alternate checksum options», RFC 1146, Март 1990.</td></tr><tr><td>[6]</td><td>Mogul, J. и S. Deering, <a href="../1191.rfc" title="RFC 1191 - Исследование MTU на пути следования сообщения">«Исследование MTU на пути следования сообщения», RFC 1191</a>, Ноябрь 1990.</td></tr><tr><td>[7]</td><td>Jacobson, V., Braden, B., and D. Borman, «TCP Extensions for High Performance», RFC 1323, Май 1992.</td></tr><tr><td>[8]</td><td>Braden, B., «T/TCP — TCP Extensions for Transactions Functional Specification», RFC 1644, Июль 1994.</td></tr><tr><td>[9]</td><td>Connolly, T., Amer, P., and P. Conrad, «An Extension to TCP: Partial Order Service», RFC 1693, Ноябрь 1994.</td></tr><tr><td>[10]</td><td>Bellovin, S., «Defending Against Sequence Number Attacks», RFC 1948, Май 1996.</td></tr><tr><td>[11]</td><td>McCann, J., Deering, S., and J. Mogul, «Path MTU Discovery for IP version 6», RFC 1981, Август 1996.</td></tr><tr><td>[12]</td><td>Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, «TCP Selective Acknowledgment Options», RFC 2018, October 1996.</td></tr><tr><td>[13]</td><td>Heffernan, A., «Protection of BGP Sessions via the TCP MD5 Signature Option», RFC 2385, Август 1998.</td></tr><tr><td>[14]</td><td>Nichols, K., Blake, S., Baker, F., and D. Black, «Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers», RFC 2474, Декабрь 1998.</td></tr><tr><td>[15]</td><td>Ramakrishnan, K. и S. Floyd, «A Proposal to add Explicit Congestion Notification (ECN) to IP», RFC 2481, Январь 1999.</td></tr><tr><td>[16]</td><td>Allman, M., Paxson, V., и W. Stevens, <a href="../2581.rfc" title="RFC 2581 - Контроль насыщения в TCP">«Контроль насыщения в TCP», RFC 2581</a>, Апрель 1999.</td></tr><tr><td>[17]</td><td>Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, «An Extension to the Selective Acknowledgement (SACK) Option for TCP», RFC 2883, Июль 2000.</td></tr><tr><td>[18]</td><td>Ramakrishnan, K., Floyd, S., и D. Black, <a href="../3168.rfc" title="RFC 3168 - Добавление явных уведомлений о перегрузке (ECN) в IP">«Добавление явных уведомлений о перегрузке (ECN) в IP», RFC 3168</a>, Сентябрь 2001</td></tr><tr><td>[19]</td><td>Spring, N., Wetherall, D., и D. Ely, <a href="../3540.rfc" title="RFC 3540 - Устойчивый механизм сигнализации насыщения с помощью ECN-nonce">«Устойчивый механизм сигнализации насыщения с помощью ECN-nonce», RFC 3540</a>, Июнь 2003</td></tr></table><h3 id="p8.2">8.2. Дополнительная литература</h3><table itemprop="references"><tr><td>[20]</td><td>IANA, «IANA», IANA TCP options, Февраль 1998, http://www.iana.org/assignments/tcp-parameters.</td></tr><tr><td>[21]</td><td>Braden, R., <a href="../1122.rfc" title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни">«Требования к хостам Internet - Коммуникационные уровни», STD 3, RFC 1122</a>, Октябрь 1989</td></tr><tr><td>[22]</td><td>Jacobson, V., «Compressing TCP/IP headers for low-speed serial links», RFC 1144, Февраль 1990.</td></tr><tr><td>[23]</td><td>Almquist, P., «Type of Service in the Internet Protocol Suite», RFC 1349, Июль 1992.</td></tr><tr><td>[24]</td><td>Kent, S. и R. Atkinson, «IP Authentication Header», RFC 2402, Ноябрь 1998.</td></tr><tr><td>[25]</td><td>Berners-Lee, T., Fielding, R., and H. Nielsen, «Hypertext Transfer Protocol — HTTP/1.0», RFC 1945, Май 1996.</td></tr><tr><td>[26]</td><td>Kent, S. и R. Atkinson, «IP Encapsulating Security Payload (ESP)», RFC 2406, Ноябрь 1998.</td></tr><tr><td>[27]</td><td>Fielding, R., Gettys, J., Mogul, J., Nielsen, H., и T. Berners-Lee, <a href="../2068.rfc" title="RFC 2068 - Протокол Передачи Гипертекста - HTTP/1.1">«Протокол Передачи Гипертекста — HTTP/1.1», RFC 2068</a>, Январь 1997.</td></tr><tr><td>[28]</td><td>Degermark, M., Nordgren, B., and S. Pink, «IP Header Compression», RFC 2507, Февраль 1999.</td></tr><tr><td>[29]</td><td>Casner, S. и V. Jacobson, «Compressing IP/UDP/RTP Headers for Low-Speed Serial Links», RFC 2508, Февраль 1999.</td></tr><tr><td>[30]</td><td>Bradner, S. и V. Paxson, «IANA Allocation Guidelines For Values In the Internet Protocol and Related Headers», BCP 37, RFC 2780, Март 2000.</td></tr><tr><td>[31]</td><td>Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, «RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed», RFC 3095, Июль 2001.</td></tr><tr><td>[32]</td><td>Dawkins, S., Montenegro, G., Kojo, M., and V. Magret, «End-to-end Performance Implications of Slow Links», BCP 48, RFC 3150, Июль 2001.</td></tr><tr><td>[33]</td><td>Balakrishnan, Padmanabhan, V., Fairhurst, G., and M. Sooriyabandara, «TCP Performance Implications of Network Path Asymmetry», RFC 3449, Декабрь 2002.</td></tr><tr><td>[34]</td><td>Inamura, H., Montenegro, G., Ludwig, R., Gurtov, A., and F. Khafizov, «TCP over Second (2.5G) and Third (3G) Generation Wireless Networks», RFC 3481, Февраль 2003.</td></tr><tr><td>[35]</td><td>Ludwig, R. и M. Meyer, «The Eifel Detection Algorithm for TCP», RFC 3522, Апрель 2003.</td></tr><tr><td>[36]</td><td>Engan, M., Casner, S., Bormann, C., and T. Koren, «IP Header Compression over PPP», RFC 3544, Июль 2003.</td></tr><tr><td>[37]</td><td>Karn, P., Bormann, C., Fairhurst, G., Grossman, D., Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L. Wood, «Advice for Internet Subnetwork Designers», BCP 89, RFC 3819, Июль 2004.</td></tr></table><h2>Адреса авторов</h2><p>Mark A. West<br />Siemens/Roke Manor Research<br />Roke Manor Research Ltd.<br />Romsey, Hants SO51 0ZN UK<br />Phone: +44 (0)1794 833311<br />URI: http://www.roke.co.uk<br />EMail: <bdo dir="rtl">&#107;&#117;&#46;&#111;&#99;&#46;&#101;&#107;&#111;&#114;&#64;&#116;&#115;&#101;&#119;&#46;&#97;&#46;&#107;&#114;&#97;&#109;</bdo></p><p>Stephen McCann<br />Siemens/Roke Manor Research<br />Roke Manor Research Ltd.<br />Romsey, Hants SO51 0ZN UK<br />Phone: +44 (0)1794 833341<br />URI: http://www.roke.co.uk<br />EMail: <bdo dir="rtl">&#107;&#117;&#46;&#111;&#99;&#46;&#101;&#107;&#111;&#114;&#64;&#110;&#110;&#97;&#99;&#99;&#109;&#46;&#110;&#101;&#104;&#112;&#101;&#116;&#115;</bdo></p></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 4413 - Поведение полей TCP/IP",disqus_identifier="4413.rfc",disqus_url="http://rfc2.ru/4413.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>