<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../1122.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 1122 — Требования к хостам Internet - Коммуникационные уровни</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../1122.rfc">RFC 1122 — Требования к хостам Internet - Коммуникационные уровни</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 1122</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank"><span itemprop="alternativeHeadline">Requirements for Internet Hosts - Communication Layers</span></a></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Стандарт Интернета</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1989-10-01">Октябрь 1989</time></dd><dd><div class="icon i5"></div> Автор: <span itemprop="author">Robert Braden</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div id="text" itemprop="articleBody"><h3>Статус документа</h3><p>В данном RFC содержатся официальные спецификации для сообщества Internet. Документ содержит ссылки, исправления и дополнения к первичным стандартам протоколов, имеющим отношение к хостам. Документ можно распространять свободно.<br /><br /></p><h3>Аннотация</h3><p>Этот документ является одним из двух RFC, посвященных определению и обсуждению требований к программам хостов Internet. Данный документ посвящен коммуникационным протоколам, а второй документ <a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC 1123</a> — прикладным протоколам и протоколам поддержки.<br /><br /></p><h2>Оглавление</h2><ul class="map"><li><a href="print#p1" title="Введение">1. Введение</a></li><li class="lia"><a href="print#p1.1" title="Архитектура Internet">1.1 Архитектура Internet</a></li><li class="lia"><a href="print#p1.2" title="Общие вопросы">1.2 Общие вопросы</a></li><li class="lia"><a href="print#p1.3" title="Работа с документом">1.3 Работа с документом</a></li><li class="lia"><a href="print#p1.4" title="Благодарности">1.4 Благодарности</a></li><li><a href="print#p2" title="Канальный уровень">2. Канальный уровень</a></li><li class="lia"><a href="print#p2.1" title="Введение">2.1 Введение</a></li><li class="lia"><a href="print#p2.2" title="Общие вопросы">2.2 Общие вопросы</a></li><li class="lia"><a href="print#p2.3" title="Частные вопросы">2.3 Частные вопросы</a></li><li class="lia"><a href="print#p2.4" title="Интерфейс между канальным уровнем и IP">2.4 Интерфейс между канальным уровнем и IP</a></li><li class="lia"><a href="print#p2.5" title="Требования к канальному уровню">2.5 Требования к канальному уровню</a></li><li><a href="print#p3" title="Протоколы уровня INTERNET">3. Протоколы уровня INTERNET</a></li><li class="lia"><a href="print#p3.1" title="Введение">3.1 Введение</a></li><li class="lia"><a href="print#p3.2" title="Общие вопросы">3.2 Общие вопросы</a></li><li class="lia"><a href="print#p3.3" title="Частные вопросы">3.3 Частные вопросы</a></li><li class="lia"><a href="print#p3.4" title="Интерфейс между IP и транспортным уровнем">3.4 Интерфейс между IP и транспортным уровнем</a></li><li class="lia"><a href="print#p3.5" title="Требования к уровню INTERNET">3.5 Требования к уровню INTERNET</a></li><li><a href="print#p4" title="Транспортные протоколы">4. Транспортные протоколы</a></li><li class="lia"><a href="print#p4.1" title="Протокол пользовательских дейтаграмм UDP">4.1 Протокол пользовательских дейтаграмм UDP</a></li><li class="lia"><a href="print#p4.2" title="Протокол управления передачей - TCP">4.2 Протокол управления передачей — TCP</a></li><li><a href="print#p5" title="Литература">5. Литература</a></li></ul><h2 id="p1">1. Введение</h2><p>Этот документ является первым из пары RFC, определяющих и обсуждающих требования к реализации хост-систем на базе стека протоколов Internet. Документ посвящен коммуникационным протоколам — канальный уровень, уровень IP (сетевой) и транспортный уровень. Второй документ пары — «Требования к хостам Internet - Прикладные и служебные протоколы» [<a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC1123</a>] — посвящен протоколам прикладного уровня. С этой парой также тесно связан документ — «Требования к маршрутизаторам» [RFC1009].</p><p>Документ предназначен для производителей и разработчиков, а также для пользователей коммуникационных программ Internet. Документ написан на основе обобщения опыта работы исследователей Internet и компаний-производителей.</p><p>В этом RFC рассмотрены стандарты протоколов, которые должны использоваться на хостах, подключенных к сети Internet, а также связанные с ними RFC и другие документы, описывающие текущие варианты спецификаций для таких протоколов. В документе исправлен ряд ошибок, встречающихся в упоминаемых документах, рассмотрены дополнительные вопросы и даны рекомендации по реализации протоколов.</p><p>Для каждого протокола в данном документе также приведен явный набор требований, рекомендаций и опций. Читатель должен понимать, что список приведенных в документе требований неполон — полные требования для хостов Internet содержатся в документах, определяющих спецификации протоколов. В данном RFC приведены поправки, уточнения и дополнения к стандартам протоколов.</p><p>Качественная реализация протоколов, подготовленная в результате внимательного прочтения этого RFC, работы в контакте с техническим сообществом Internet и учета позитивной практики разработки коммуникационных программ, не должна сильно отличаться от содержащихся в документе требований. Многие из «требований» данного RFC уже реализованы в стандартах или рассматриваются для включения в стандарты, поэтому их обсуждение в данном документе может показаться избыточным. Однако такие вопросы были включены в документ, поскольку некоторые из имеющихся реализаций содержат ошибки, приводящие к недостаточной интероперабельности, снижению производительности и возникновению иных проблем.</p><p>В документе обсуждается и разъясняется множество требований и рекомендаций. Простой список требований может быть опасен по ряду причин:</p><ul class="dot"><li>некоторые требуемые функции более важны, а ряд функций не является обязательным;</li><li>существует множество причин, по которым продукция, разработанная для ограниченного контекста, может быть выбрана для использования в иных средах.</li></ul><p>Нужно следовать приведенным в документе спецификациям для обеспечения интероперабельности хостов при взаимодействии через разнородные и сложные системы Internet. Хотя многие из числа имеющихся реализаций не соответствуют тем или иным требованиям, спецификации являются идеалом, к которому нужно стремиться.</p><p>Приведенные в документе требования основаны на современном уровне архитектуры Internet. Документ будет обновляться по мере развития спецификаций и технологий в тех областях, с которыми он связан.</p><p>Вводная часть документа начинается с краткого обзора архитектуры Internet применительно к хостам, приведены также некоторые рекомендации по выбору программ для хостов. Кроме того, во введении даны некоторые рекомендации по работе с остальной частью документа и рассмотрена используемая терминология.</p><h3 id="p1.1">1.1 Архитектура Internet</h3><p>Рассмотрению основ архитектуры Internet и поддерживаемых протоколов посвящена книга DDN Protocol Handbook [INTRO:3], основы архитектуры рассмотрены также в работах [INTRO:9], [INTRO:10], [INTRO:11]. В работе [RFC980] рассматриваются вопросы получения документов со стандартами протоколов Internet, а документ [RFC1010] содержит список номеров (числовых идентификаторов), выделенных для протоколов Internet.</p><h4>1.1.1 Хосты Internet</h4><p>Хост-компьютер или попросту хост является конечным пользователем коммуникационного сервиса. На хостах в общем случае выполняются программы по запросам пользователей и/или поддерживаются коммуникационные службы Internet для обслуживания пользовательских запросов. Хосты Internet соответствуют концепции конечной системы (End-System) в стеке протоколов OSI [INTRO:13].</p><p>Коммуникационная система Internet содержит соединенные между собой сети передачи пакетов, в которых обмен информацией между хостами осуществляется на основе протоколов Internet. Сети подключаются к Internet или промежуточным системам OSI (Intermediate Systems, [INTRO:13]) с использованием компьютеров, обеспечивающих коммутацию пакетов — такие компьютеры называют шлюзами (gateway) или маршрутизаторами IP (IP router). В документе «Требования к маршрутизаторам» [RFC1009] содержатся официальные спецификации для шлюзов (маршрутизаторов) Internet. [RFC1009] вместе с настоящим документом и [<a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC1123</a>] определяют правила для текущей реализации архитектуры Internet.</p><p>Хосты Internet сильно различаются по своим размерам, производительности и выполняемым функциям. В сети Internet используются самые разные компьютеры, включая настольные ПК, рабочие станции, мэйнфреймы и суперкомпьютеры. По выполняемым функциям хосты делятся на системы общего назначения (например, терминальные серверы) и мультисервисные системы (поддержка широкого спектра сетевых служб — remote login, FTP, электронннная почта и т. п.).</p><p>Для обозначения хостов с множеством интерфейсов в одну или несколько сетей используется термин multihomed (многодомный). Более подробное описание таких хостов приведено в параграфе 1.1.3 Терминология.</p><h4>1.1.2 Архитектурные допущения</h4><p>Современная архитектура Internet основана на группе базовых допущений о коммуникационной системе. Допущения, связанные с хостами, перечислены ниже:</p><ul class="lat"><li><p class="b">Internet является «сетью сетей»</p><p class="lib">Каждый хост напрямую подключен к какой-либо сети (сетям) — соединение с Internet является лишь концептуальным. Два хоста одной сети могут обмениваться между собой данными с использованием тех же протоколов, которые служат для связи с хостами удаленных сетей.</p></li><li><p class="b">Шлюзы не хранят информацию о состоянии соединений</p><p class="lib">Для повышения устойчивости коммуникационных систем шлюзы разрабатываются таким образом, чтобы обеспечивалась пересылка дейтаграмм IP без организации явных соединений (stateless) и независимо от других дейтаграмм. В результате для обеспечения устойчивости могут использоваться избыточные (redundant) пути, которые активизируются при возникновении сбоев на основных путях.</p><p class="lib">Вся информация, требуемая для сквозного управления потоком данных (end-to-end flow control) через соединение, обеспечивается хостами с помощью программ транспортного или прикладного уровня. Таким образом, все данные для контроля соединения сосредоточены в конечных точках соединения и могут быть потеряны только при сбое на хостах.</p></li><li><p class="b">Маршрутизация осуществляется в шлюзах</p><p class="lib">Маршрутизация является сложным процессом и должна выполняться шлюзами, а не хостами. Важной причиной такого допущения является избавление от необходимости смены или повторной настройки программ в результате изменений, вносимых при сменах архитектуры маршрутизации Internet.</p></li><li><p class="b">Система должна быть совместима с различными вариантами сетей</p><p class="lib">Базовой предпосылкой архитектуры Internet является возможность изменения в широких пределах сетевых параметров (например, скорости каналов, задержки, числа теряемых пакетов, изменения порядка доставки пакетов, максимального размера пакетов и т. п.). Другим важным требованием является устойчивость к сбоям в отдельных сетях, шлюзах, хостах и сохранение возможности работы с доступной скоростью. Конечной целью взаимодействия открытых систем (open system interconnection) является обеспечение эффективной работы Internet и полной интероперабельности для всех типов хостов и сетей, соединенных через различные каналы Internet.</p><p class="lib">В некоторых случаях разработчики преследуют менее амбициозные цели. Например, среды ЛВС обычно менее требовательны к хостам по сравнению с Internet в целом; локальные сети имеют небольшие задержки, теряется только малая часть пакетов и порядок доставки пакетов обычно сохраняется. Некоторые компании в своих реализациях используют решения, приемлемые для ЛВС, но совершенно не подходящие для гетерогенных сред. Обычно такую продукцию преподносят в качестве дешевого решения для локальных сетей. Однако, изолированная ЛВС может перестать быть таковой и при организации взаимодействия с другими сетями и Internet использование таких упрощенных решений с неизбежностью породит проблемы. В конце концов ни пользователь, ни производитель могут оказаться не в состоянии решить проблемы, возникшие в результате применения не полностью соответствующих стандартам оборудования и программ.</p></li></ul><p>Приведенные в документе требования относятся к полнофункциональным хостам Internet, обеспечивающим полную интероперабельность при использовании самых разных путей передачи данных сети Internet.</p><h4>1.1.3 Стек протоколов Internet</h4><p>Для связи через Internet на хостах должен использоваться многоуровневый набор протоколов, соответствующий стеку протоколов Internet. Обычно на хостах реализован по крайней мере один протокол для каждого из уровней. Уровни протоколов, используемые в архитектуре Internet, описаны в работе [RFC1011]:</p><ul><li class="b">Прикладной уровень (Application Layer)</li><li class="lib"><p>Прикладной уровень располагается в верхней части стека протоколов Internet. В стеке Internet прикладной уровень не разделен на подуровни, хотя некоторые из протоколов прикладного уровня Internet содержат внутренние подуровни. Прикладной уровень стека Internet объединяет в себе функции двух уровней (Presentation — уровень представления и Application — прикладной) эталонной модели OSI.</p><p>Мы будем различать две категории протоколов прикладного уровня — пользовательские протоколы, которые предоставляют услуги непосредственно пользователю, и протоколы поддержки (служебные), обеспечивающие системные функции общего назначения. Требования к пользовательским и служебным протоколам рассмотрены в [<a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC1123</a>].</p><p>Наиболее распространенными пользовательскими протоколами Internet являются:</p><ul class="dot"><li>Telnet (удаленный вход в систему)</li><li>FTP (передача файлов)</li><li>SMTP (доставка электронной почты)</li></ul><p>Существует также множество стандартизованных [RFC1011] и частных пользовательских протоколов.</p><p>Служебные протоколы используются для преобразования имен, загрузки ОС и управления — к числу таких протоколов относятся SNMP, BOOTP, RARP, DNS (Domain Name System).</p></li><li class="b">Транспортный уровень (Transport Layer)</li><li class="lib"><p>Транспортный уровень обеспечивает сквозную связь (end-to-end) между приложениями через сеть. На транспортном уровне используются два основных протокола:</p><ul class="dot"><li>Transmission Control Protocol (TCP) — протокол управления передачей</li><li>User Datagram Protocol (UDP) — протокол пользовательских дейтаграмм</li></ul><p>TCP представляет собой основанный на соединениях (connection-oriented) транспортный сервис с гарантированной доставкой пакетов, обеспечивающий надежную доставку с сохранением порядка пакетов и управлением потоком данных. Протокол UDP не использует явных соединений (connectionless) и передает данные в виде дейтаграмм (datagram) без гарантии доставки.</p><p>Исследовательскими организациями были разработаны и другие протоколы транспортного уровня, которые могут получить статус стандартных протоколов.</p><p>Более подробное описание протоколов транспортного уровня приведено в главе 4.</p></li><li class="b">Уровень Internet (Internet Layer)</li><li class="lib"><p>Все транспортные протоколы используют протокол IP (Internet Protocol) для передачи данных от отправителя к получателю. IP представляет собой службу доставки дейтаграмм без организации соединений (connectionless), не обеспечивающую сквозной гарантии доставки. Таким образом, при доставке на хост получателя дейтаграммы IP могут оказаться поврежденными; кроме того, не гарантируется сохранение порядка их доставки, отдельные дейтаграммы могут быть потеряны, а некоторые — продублированы. Если требуются гарантии доставки, ответственность за такие гарантии должны брать на себя вышележащие уровни. Протокол IP отвечает за адресацию, обозначение типа сервиса, фрагментацию и сборку, а также безопасность.</p><p>Передача данных без организации соединений лежит в основе протокола IP и является одной из основных характеристик архитектуры Internet. Протокол IP послужил моделью при разработке сетевого протокола OSI Connectionless Network Protocol [INTRO:12].</p><p>Управляющий протокол ICMP является важной составной частью IP, хотя с точки зрения архитектуры он работает поверх IP (т. е., использует IP для передачи данных, подобно транспортным протоколам TCP и UDP). ICMP обеспечивает доставку сообщений об ошибках, насыщении сети и перенаправлении пакетов для первого маршрутизатора (first-hop).</p><p>IGMP представляет собой протокол уровня Internet, используемый для организации динамических групп хостов с целью группового обмена информацией (IP multicasting).</p><p>Протоколы уровня Internet (IP, ICMP и IGMP) более подробно рассмотрены в главе 3.</p></li><li class="b">Канальный уровень (Link Layer)</li><li class="lib"><p>Для связи с непосредственно подключенными к нему сетями хост должен поддерживать коммуникационный протокол, используемый для обмена данными с сетью. Мы будем называть такой протокол MAC-протоколом (media-access layer protocol) или протоколом канального уровня (link layer).</p><p>На канальном уровне может использоваться множество протоколов в зависимости от используемой сетевой технологии.</p><p>Протоколы канального уровня рассмотрены в главе 2.</p></li></ul><h4>1.1.4 Встроенная маршрутизация</h4><p>Программы некоторых хостов Internet включают встроенный маршрутизатор — такие хосты могут пересылать пакеты, как это делают шлюзы, обеспечивая в то же время функции прикладного уровня как обычные хосты. Такие системы двойного назначения должны соответствовать требованиям [RFC1009] в части функций шлюза и требованиям настоящего документа, применительно к функциям хоста. Во всех перекрывающихся случаях эти две спецификации должны быть согласованы.</p><p>В сообществе Internet существует множество мнений о поддержке встроенных функций маршрутизации. Ниже приведены основные аргументы за и против таких систем:</p><ul><li class="b">За:</li><li class="lia">Такие системы могут быть приемлемы с точки зрения удобства и экономичности в локальных сетях или изолированных системах для использования существующих хостов в качестве маршрутизаторов. Существуют также аргументы в пользу встроенной маршрутизации с точки зрения архитектуры — компьютеров с несколькими сетевыми интерфейсами больше, нежели с одним интерфейсом, и поддержка функций маршрутизации позволяет более эффективно использовать такие хосты.</li><li class="b">Против:</li><li class="lia"><p>Алгоритмы и протоколы маршрутизации постоянно изменяются с ростом Internet. Попытка реализации этих протоколов на хостах общего назначения будет требовать постоянного обновления программ на таких хостах. Наличие многочисленных реализаций кода маршрутизации дополнительно затрудняет внесение требуемых изменений. И, наконец, реализация уровня IP для шлюза сложнее, нежели для обычного хоста, что делает работу с такими хостами также более сложной.</p><p>Кроме того, стиль работы некоторых хостов просто неприемлем для их использования в качестве стабильных и надежных маршрутизаторов.</p></li></ul><p>Обе точки зрения имеют свои плюсы и минусы. Прежде, чем выбрать решение для себя, администратор должен принять во внимание реальную потребность в поддержке хостом функций маршрутизации. Более детальное рассмотрение этого вопроса приведено в параграфе 3.1.</p><h3 id="p1.2">1.2 Общие вопросы</h3><p>Существуют два важнейших аспекта, которые должны принимать во внимание разработчики программ для хостов Internet.</p><h4>1.2.1 Постоянное изменение Internet</h4><p>Непредсказуемо быстрый рост Internet порождает проблемы управления и масштабирования в гигантских системах передачи дейтаграмм. В результате решения таких проблем изменяются и спецификации, описываемые в данном документе. Изменения планируются и осуществляются под контролем и с участием производителей сетевой продукции и организаций, ответственных за работу сетей.</p><p>Обновление и постоянное совершенствование являются неотъемлемыми чертами современных сетевых протоколов и такая ситуация будет сохраняться еще достаточно долго. Разработчики коммуникационных программ для стека протоколов Internet (или иных протоколов) должны поддерживать и обновлять свои программы с учетом изменяющихся спецификаций для того, чтобы не оставить в беде несчастных пользователей. Internet представляет собой большую коммуникационную сеть и пользователи постоянно контактируют между собой через эту сеть. Опыт и знания разработчиков, реализованные в их программах, за короткое время становятся достоянием технического сообщества Internet.</p><h4>1.2.2 Принципы устойчивости</h4><p>Для протоколов всех уровней существует общее правило, которому приложения должны следовать во избежание проблем с устойчивостью и интероперабельностью [<a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC791</a>]:</p><pre>Предъявлять жесткие требования по отношению к себе,
быть более мягким по отношению к другим.</pre><p>Программы должны уметь обрабатывать все мыслимые ошибки; не имеет значения вероятность возникновения той или иной ошибки — раньше или позже пакет с любой возможной комбинацией ошибок и/или атрибутов будет получен и программа должна быть готова к обработке такого пакета. Если программа не может эффективно обрабатывать ошибки, она приведет прямой дорогой к хаосу. В общем случае лучше предположить, что сеть наводнена зловредными объектами, которые постоянно передают пакеты, предназначенные для нанесения максимального вреда. Такое предположение обеспечит высокий уровень защиты. Наиболее серьезные проблемы в Internet связаны с неисследованными механизмами, включающимися с малой вероятностью; намерения обычных злоумышленников никогда не могут принести такого вреда!</p><p>На всех уровнях программ хостов Internet должны быть реализованы средства адаптации. В качестве простого примера рассмотрим спецификацию протокола, использующего численные значения для какого-либо поля в заголовке (например, тип, номер порта или код ошибки) — при разработке следует предполагать, что используемая нумерация неполна. Если спецификация протокола предполагает четыре возможных кода ошибки, приложение должно уметь обрабатывать по крайней мере пять типов ошибок (4 заданных и все остальные). Появление не определенных в спецификации кодов должно протоколироваться (см. ниже), но не должно нарушать работу системы.</p><p>Почти так же важен и другой аспект — программы на других хостах могут содержать определения, которые могут толкнуть хост на неразумные, но допустимые с точки зрения протокола действия. Естественным решением будет «поиск неразумных хостов» — программы хоста должны быть готовы не просто переносить появление неразумных хостов, но и участвовать в процессе ограничения вредных воздействий, которые подобные хосты могут нанести сетевым объектам общего пользования.</p><h4>1.2.3 Протоколирование ошибок</h4><p>Сеть Internet включает огромное количество разнотипных хостов и шлюзов, в каждом из которых реализовано множество протоколов и уровней — некоторые из хостов и маршрутизаторов наверняка содержат ошибки в программах стека протоколов Internet. В результате сложности, разнотипности и использования распределенных функций диагностика Internet является весьма непростой задачей.</p><p>Упростить поиск проблем помогает использование хостами специальных средств протоколирования ошибок и странностей в поведении протоколов. При записи таких событий важно включать максимум диагностической информации. Часто бывает весьма полезно записывать заголовки пакетов, вызывающих ошибки. Однако следует знать меру — средства протоколирования ошибок не должны отнимать слишком много ресурсов хоста и снижать эффективность его работы.</p><p>При записи информации об ошибках существует вероятность получения журнальных файлов огромного размера — таких ситуаций можно избежать, используя «циклический» журнал или включая запись только для диагностики определенных сбоев. Полезно также фильтровать и считать повторяющиеся последовательные сообщения. Представляется привлекательной приведенная ниже стратегия:</p><ol><li>всегда считать аномальные события и делать содержимое счетчиков доступным с помощью средств управления сетью (см. [<a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC1123</a>]);</li><li>поддерживать возможность выбора протоколируемых событий (например, записывать все ошибки, связанные с хостом X).</li></ol><p>Отметим, что разные системы управления сетью могут придерживаться различных правил в части числа протоколируемых ошибок для каждого хоста. Некоторые системы исходят из принципа: «если это не имеет ко мне прямого отношения, я не хочу об этом знать», тогда как другие системы прилагают максимум усилий для обнаружения и устранения аномалий в поведении сетевых протоколов.</p><h4>1.2.4 Конфигурационные параметры</h4><p>Идеальной реализацией хоста будет та, на которой настройка стека протоколов Internet будет полностью автоматизирована (selfconfiguring). Это позволит реализовать весь стек в ПЗУ или встроить в микросхемы оборудования — такое решение упростит организацию бездисковых станций, снимет значительную часть нагрузки с сетевых администраторов и упростит разработку систем. Однако этот идеал недостижим и на практике к нему не удается даже серьезно приблизиться.</p><p>В этом документе вы будете часто встречать требования, параметры которых являются опциями настройки. Существует несколько причин появления таких требований. В некоторых случаях это обусловлено отсутствием согласия по вопросу выбора наилучшего значения и в будущем может потребоваться установка иного значения параметра. В других случаях значение параметра может зависеть от внешних факторов (например, скорость и топология соседних сетей) и алгоритмы автоматической настройки могут отсутствовать или не обеспечивать полной настройки параметров. Причиной использования таких параметров могут послужить и административные требования.</p><p>Наконец, часть конфигурационных опций может потребоваться для обеспечения взаимодействия с устаревшими или содержащими ошибки реализациями протоколов, распространяемыми без исходных кодов (к несчастью, такое встречается в Internet достаточно часто). Для обеспечения корректного сосуществования с такими «сбойными» системами администраторам зачастую приходится «расстраивать» (mis-configure) корректно работающие системы. Такие проблемы будут решаться сами собой по мере удаления сбойных систем, но разработчики не должны оставлять этот вопрос без внимания.</p><p>Когда мы говорим, что параметр требует настройки, это не означает требования читать значение параметра из конфигурационного файла при каждой загрузке. Мы рекомендуем разработчикам устанавливать для таких параметров используемые по умолчанию значения — тогда в конфигурационных файлах могут содержаться лишь те значения, которые не совпадают с принятыми по умолчанию. Таким образом, конфигурационные требования обеспечивают гарантию возможности изменения принятых по умолчанию значений параметров — это решение можно использовать даже при загрузке программного кода из ПЗУ.</p><p>В этом документе для ряда случаев указаны значения, которые следует использовать по умолчанию. Выбор принятых по умолчанию значений является достаточно важным вопросом для случаев использования вместе с существующими сбойными системами. По мере продвижения Internet к полной интероперабельности, принятые по умолчанию значения будут реализовать официальный протокол, а не «расстраивать» систему для обеспечения совместимости с плохо работающими реализациями. Хотя рынок заставляет некоторых производителей устанавливать по умолчанию значения для «расстройки», мы рекомендуем использовать по умолчанию значения, соответствующие стандартам.</p><p>В заключении отметим, что производители продукции должны предоставлять полную документацию по всем конфигурационным параметрам, указывая допустимые значения и описывая влияние параметров на работу системы.</p><h3 id="p1.3">1.3 Работа с документом</h3><h4>1.3.1 Структура документа</h4><p>Деление протоколов на уровни, которое в общем случае используется как организационный принцип при реализации сетевых программ, служит также принципом организации данного документа. При описании правил мы предполагаем, что реализация достаточно точно отражает деление протоколов по уровням. Таким образом, документ поделен на три основных части — канальный уровень, уровень internet и транспортный уровень. Документ [<a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC1123</a>] содержит описание программ прикладного уровня. Такая организация документов представляется простой и наглядной.</p><p>Однако, жесткое деление на уровни не является совершенной моделью как для стека протоколов, так и для реализации программ. Протоколы различных уровней взаимодействуют в комплексе, иногда даже трудно отделить один протокол от другого, а отдельные функции могут включать несколько уровней. При разработке программных реализаций существует масса вариантов, многие из которых «творчески» подходят к вопросам деления на уровни. Мы рекомендуем всем разработчикам внимательно прочесть документы [RFC817] и [INTRO:8].</p><p>В этом документе описывается концептуальный интерфейс взаимодействия между уровнями, использующий функциональную нотацию (procedure call — вызов процедур), подобную той, что используется в спецификации TCP [<a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC793</a>]. Реализация хоста должна поддерживать логические потоки информации, применяемые при таких вызовах, но не требовать дословной реализации самих вызовов. Например, во многих реализациях связь между транспортным уровнем и IP отражается предоставлением разделяемого доступа к общим структурам данных.</p><p>В общем случае все главы документа организованы в форме следующих параграфов:</p><ol><li>Введение</li><li>Общие вопросы — рассматриваются документы со спецификациями протокола, приводятся исправления ошибок, перечисляются требования, которые могли быть нечетко или неточно сформулированы, и приводятся дополнительные комментарии и разъяснения.</li><li>Частные вопросы — рассматривается устройство протокола и вопросы реализации, не включенные в предыдущий раздел.</li><li>Интерфейсы — обсуждаются услуги, предоставляемые вышележащему протоколу.</li><li>Заключение — резюмируются требования данной главы.</li></ol><p>Во многих темах документа встречаются параграфы, помеченные как "Обсуждение" или "Реализация". Этот материал предназначен для разъяснения требований, рассмотренных ранее в документе. Такие параграфы также включают некоторые предложения по вариантам будущих разработок. Материалы о реализации содержат предложения, которые могут быть интересны для разработчиков.</p><p>Заключение служит в качестве краткого руководства и справочника к главе, но оно слишком кратко для использования в качестве информационного источника. Такие заключения никогда не должны использоваться отдельно от текста полного RFC.</p><h4>1.3.2 Уровень требований</h4><p>В этом документе модальные глаголы, служащие для формулировки требований, выделены жирным шрифтом и используются в оговоренном ниже смысле:</p><p>Требуется, должен (MUST) — этот глагол (или причастие от него) используется для обозначения абсолютной необходимости. Следует, рекомендуется (SHOULD) — этот глагол (или причастие рекомендуемый) служит для обозначения тех случаев, когда могут существовать дополнительные факторы, позволяющие игнорировать данное требование; в таких случаях рекомендуется принимать взвешенное решение с учетом всех факторов. Можно (MAY) — этот глагол и прилагательное необязательный означает, что вопрос реализации требования отдается на откуп разработчику. Кто-то может реализовать требование с целью расширения возможностей, а другой разработчик может отказаться от реализации в целях упрощения.</p><p>Реализация считается несовместимой со стандартами, если в ней не выполнены обязательные требования (MUST). Реализация, в которой выполнены все требования MUST и SHOULD считается «безусловно совместимой» (unconditionally compliant); если же выполняются все требования MUST, но проигнорирована часть требований SHOULD, реализация считается «условно совместимой» (conditionally compliant).</p><h4>1.3.3 Терминология</h4><p>Ряд используемых в документе технических терминов определен в данном параграфе.</p><ul><li class="b">Сегмент — Segment</li><li class="lib">Сегментом будем называть модуль данных, используемый для сквозной передачи по протоколу TCP. Сегмент состоит из заголовка TCP, за которым следуют данные. Сегменты передаются с использованием инкапсуляции в дейтаграммы IP.</li><li class="b">Сообщение — Message</li><li class="lib">При описании протоколов нижних уровней термин сообщение обозначает модуль, передаваемый на транспортном уровне. В частности, сегмент TCP является сообщением. Сообщение содержит заголовок транспортного уровня, за которым следуют данные. Для сквозной передачи через сеть Internet сообщение должно инкапсулироваться в дейтаграммы.</li><li class="b">Дейтаграмма IP — IP Datagram</li><li class="lib">Дейтаграмма IP представляет собой модуль данных протокола IP. Дейтаграмма IP содержит заголовок IP, за которым следует информация транспортного уровня (т. е., сообщение). При описании уровня Internet (глава 3) термин дейтаграмма обычно относится к дейтаграммам IP.</li><li class="b">Пакет — Packet</li><li class="lib">Пакет представляет собой модуль данных, передаваемый через интерфейс между уровнем Internet и канальным уровнем. Пакет включает заголовок IP и данные. Пакет может быть полной дейтаграммой IP или фрагментом такой дейтаграммы.</li><li class="b">Кадр — Frame</li><li class="lib">Кадр представляет собой модуль данных для передачи на канальном уровне и содержит заголовок канального уровня, за которым следует пакет.</li><li class="b">Подключенная сеть — Connected Network</li><li class="lib">Сеть, к которой непосредственно подключен хост, часто называют локальной сетью (local network) или подсетью (subnetwork) применительно к данному хосту. Однако использование этих терминов может привести к путанице, поэтому мы будем пользоваться термином подключенная сеть (connected network).</li><li class="b">Multihomed</li><li class="lib">Хост называют многодомным (multihomed) если он имеет более одного адреса IP. Более подробное обсуждение таких хостов вы найдете в параграфе 3.3.4.</li><li class="b">Физический интерфейс — Physical network interface</li><li class="lib">Физический интерфейс используется для подключения хоста к сети. Интерфейс имеет адрес канального уровня (возможно, уникальный). В хосте может использоваться множество физических интерфейсов с общим адресом канального уровня, но для каждого хоста одной физической сети должен обеспечиваться уникальный адрес на канальном уровне.</li><li class="b">Логический интерфейс — Logical [network] interface</li><li class="lib">Определим логический [сетевой] интерфейс как логический путь в подключенную сеть. Для идентификации логического интерфейса служит уникальный адрес IP. Более подробное рассмотрение логических интерфейсов приведено в параграфе 3.3.4.</li><li class="b">Specific-destination address</li><li class="lib">Эффективный адрес получателя дейтаграммы, даже если она является широковещательной (broadcast) или групповой (multicast). Дополнительная информация по этому вопросу содержится в параграфе 3.2.1.3.</li><li class="b">Путь — Path</li><li class="lib">В каждый момент времени все дейтаграммы IP от определенного хоста-отправителя к определенному хосту-получателю обычно передаются через одинаковую последовательность маршрутизаторов. Мы будем использовать термин «путь» для обозначения таких последовательностей маршрутизаторов. Отметим, что путь является однонаправленным, т. е. данные между парой хостов могут передаваться в каждом направлении по своему пути. MTU Максимальный размер передаваемого модуля данных (т. е., размер наибольшего пакета, который может быть передан через сеть).</li></ul><p>Термины кадр, пакет, дейтаграмма и сегмент дополнительно проиллюстрированы на приведенных ниже рисунках.</p><p>A) Передача в подключенную сеть:</p><pre> _______________________________________________
| LL hdr | IP hdr |         (data)              |
|________|________|_____________________________|

 &lt;---------- Frame -----------------------------&gt;
          &lt;----------Packet --------------------&gt;</pre><p>B) Перед фрагментацией IP или после сборки:</p><pre> ______________________________________
| IP hdr | transport| Application Data |
|________|____hdr___|__________________|

 &lt;--------  Datagram ------------------&gt;
          &lt;-------- Message -----------&gt;</pre><p>то же самое для TCP:</p><pre> ______________________________________
| IP hdr |  TCP hdr | Application Data |
|________|__________|__________________|

 &lt;--------  Datagram ------------------&gt;
          &lt;-------- Segment -----------&gt;</pre><h3 id="p1.4">1.4 Благодарности</h3><p>Этот документ включает результаты работы и комментарии большой группы специалистов по протоколам Internet, включая представителей университетов и исследовательских лабораторий, компаний- производителей и государственных агентств. Подготовка документа велась в рабочей группе IETF Host Requirements.</p><p>Редактор выражает особую благодарность за неустанную работу людям, принявшим участие в долгих конференциях и написавшим 3 мегабайта почтовых сообщений за 18 месяцев подготовки документа — это: Philip Almquist, Dave Borman (Cray Research), Noel Chiappa, Dave Crocker (DEC), Steve Deering (Stanford), Mike Karels (Berkeley), Phil Karn (Bellcore), John Lekashman (NASA), Charles Lynn (BBN), Keith McCloghrie (TWG), Paul Mockapetris (ISI), Thomas Narten (Purdue), Craig Partridge (BBN), Drew Perkins (CMU) и James Van Bokkelen (FTP Software).</p><p>Кроме того, выражается благодарность всем, кто внес большой вклад в подготовку документа: Bill Barns (Mitre), Steve Bellovin (AT&amp;T), Mike Brescia (BBN), Ed Cain (DCA), Annette DeSchon (ISI), Martin Gross (DCA), Phill Gross (NRI), Charles Hedrick (Rutgers), Van Jacobson (LBL), John Klensin (MIT), Mark Lottor (SRI), Milo Medin (NASA), Bill Melohn (Sun Microsystems), Greg Minshall (Kinetics), Jeff Mogul (DEC), John Mullen (CMC), Jon Postel (ISI), John Romkey (Epilogue Technology), Mike StJohns (DCA). Перечисленные ниже люди внесли значительный вклад в подготовку отдельных тем: Eric Allman (Berkeley), Rob Austein (MIT), Art Berggreen (ACC), Keith Bostic (Berkeley), Vint Cerf (NRI), Wayne Hathaway (NASA), Matt Korn (IBM), Erik Naggum (Naggum Software, Norway), Robert Ullmann (Prime Computer), David Waitzman (BBN), Frank Wancho (USA), Arun Welch (Ohio State), Bill Westfield (Cisco) и Rayan Zachariassen (Toronto).</p><p>Благодарим также всех, кто так или иначе способствовал появлению этого документа.</p><h2 id="p2">2. Канальный уровень</h2><h3 id="p2.1">2.1 Введение</h3><p>Для всех систем Internet — хостов и маршрутизаторов — предъявляются одинаковые требования к протоколам канального уровня.</p><p>Эти требования подробно рассмотрены в главе 3 документа «Требования к маршрутизаторам» [RFC1009] и дополнены в настоящем документе.</p><h3 id="p2.2">2.2 Общие вопросы</h3><p>Не рассматриваются.</p><h3 id="p2.3">2.3 Частные вопросы</h3><h4>2.3.1 Согласование трейлерного протокола</h4><p>Для инкапсуляции на канальном уровне может использоваться трейлерный протокол (trailer protocol) [RFC893], но использование такого протокола должно быть согласовано обеими системами (хосты или маршрутизаторы), взаимодействующими на канальном уровне с применением трейлеров. Если системы не могут согласовать трейлерный протокол динамически (для каждого получателя), принятая по умолчанию конфигурация должна запрещать использование трейлеров.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Трейлерный протокол представляет собой метод инкапсуляции на канальном уровне, обеспечивающий перекомпоновку (rearrange) пакетов, передаваемых в физическую сеть. В некоторых случаях трейлеры повышают производительность протоколов верхних уровней за счет снижения объема копируемых данных. Протоколы верхних уровней не знают об использовании трейлеров, но приемник и передатчик пакетов должны понимать, какой протокол используется для инкапсуляции.</p><p>Некорректное использование трейлеров может привести к серьезной путанице. С использованием трейлеров инкапсулируются только пакеты с заданным набором атрибутов и обычно этому требованию удовлетворяет лишь малая часть передаваемых пакетов. Таким образом, если одна система будет использовать трейлеры, а другая не будет, часть пакетов будет «улетать в черную дыру», а остальные будут доставляться нормально.</p></li><li class="b">Реализация</li><li class="lib"><p>В сетях Ethernet пакеты, инкапсулируемые с трейлерами, используют различные типы Ethernet [RFC893] и согласование трейлера выполняется одновременно с использованием протокола ARP для определения адреса получателя. Обмен пакетами ARP для определения адреса осуществляется обычным способом, но хост, согласующий трейлер, будет передавать дополнительный отклик ARP (trailer ARP reply), указывающий тип трейлерного протокола инкапсуляции в формате обычного отклика ARP. Если хост, настроенный на использование трейлеров, получает отклик ARP с типом трейлера от удаленной машины, он может добавить ее в список систем, поддерживающих трейлеры (например, пометив соответствующую запись в кэше ARP).</p><p>Хосты, желающие использовать трейлерную инкапсуляцию передают отклик trailer ARP всякий раз при завершении нормального обмена ARP для IP-адреса. Таким образом, хост, получивший запрос ARP для своего IP-адреса, будет передавать отклик trailer ARP в дополнение к нормальному отклику IP ARP; хост, передавший запрос IP ARP, будет передавать отклик trailer ARP при получении отклика на запрос IP ARP. При таком способе как запрашивающий, так и отвечающий хост в процессе обмена пакетами IP ARP может запросить использование трейлерной инкапсуляции.</p><p>Такая схема с использованием дополнительных пакетов trailer ARP reply вместо запросов ARP на указание типа трейлерного протокола была разработана для того, чтобы избежать непрерывного обмена пакетами ARP с некорректно работающими хостами, которые в ответ на запрос типа трейлера передают стандартный отклик ARP для IP-адреса. Проблема решается за счет передачи отклика trailer ARP в ответ на отклик IP ARP только в тех случаях, когда отклик IP ARP отвечает на невыполненный запрос (это верно для тех случаев, когда аппаратный адрес хоста остается неизвестным к моменту получения отклика IP ARP). Отклик trailer ARP всегда можно посылать вместе с откликом IP ARP, соответствующим запросу IP ARP.</p></li></ul><h4>2.3.2 Протокол преобразования адресов — ARP</h4><h5>2.3.2.1 Проверка кэша ARP</h5><p>Реализация протокола преобразования адресов ARP (Address Resolution Protocol) [<a href="../826.rfc" title="RFC 826 - Протокол преобразования адресов Ethernet (ARP)">RFC826</a>] должна обеспечивать механизм удаления устаревших записей из таблицы. Если поддерживаемый механизм использует тайм-аут, должна обеспечиваться возможность настройки времени ожидания.</p><p>Реализация должна обеспечивать механизм предотвращения лавинной рассылки (ARP flooding) в виде повторяющихся с высокой частотой запросов ARP Request для одного адреса IP. Рекомендуемая частота запросов не должна превышать для каждого адреса 1 запрос/сек.</p><ul><li class="b">Обсуждение:</li><li class="lib">Спецификация ARP [<a href="../826.rfc" title="RFC 826 - Протокол преобразования адресов Ethernet (ARP)">RFC826</a>] предлагает, но не требует использовать механизм тайм-аутов для объявления некорректными (invalidate) элементов кэша при смене хостом своего адреса Ethernet. Широкое распространение proxy ARP (см. параграф 2.4 в работе [RFC1009]) существенно повышает вероятность того, что в кэше будут содержаться некорректные записи, следовательно требуется механизм удаления устаревших записей из кэша ARP. Даже в отсутствие proxy ARP использование тайм-аутов полезно для автоматической коррекции данных ARP, которые могли быть кэшированы.</li><li class="b">Реализация</li><li class="lib"><p>Для удаления устаревших записей из кэша используется 4 механизма (иногда в комбинации).</p><ol><li><p>Timeout — записи периодически удаляются из кэша, даже если они остаются актуальными. При использовании ARP тайм-аут должен быть порядка 1 минуты.</p></li><li><p>Unicast Poll — активный опрос удаленных хостов с помощью периодической отправки по их адресам пакетов ARP Request и удаление записей для тех адресов, от которых не пришло пакетов ARP Reply после N последовательных опросов. Тайм-аут должен по-прежнему составлять около 1 минуты, а типичное значение N = 2.</p></li><li><p>Link-Layer Advice — если драйвер канального уровня обнаруживает проблемы с доставкой, соответствующая запись удаляется из кэша ARP.</p></li><li><p>Higher-layer Advice — обеспечивается вызов на канальный уровень с уровня Internet для индикации проблем с доставкой. Эффект такого вызова заключается в том, что соответствующая запись удаляется из кэша. Такой вызов является аналогом вызова ADVISE_DELIVPROB() с транспортного уровня на уровень Internet (см. параграф 3.4) и подпрограмма ADVISE_DELIVPROB фактически может использоваться для вызова программы канального уровня, удаляющей запись из кэша ARP.</p></li></ol><p>Варианты (1) и (2) используют тайм-аут порядка 1 минуты или меньше. При отсутствии ARP такой короткий период ожидания может породить заметный избыточный трафик в больших сетях Ethernet. Следовательно, может потребоваться увеличение тайм-аута ARP.</p></li></ul><h5>2.3.2.2 Очередь пакетов ARP</h5><p>Канальный уровень должен сохранять (а не отбрасывать) по крайней мере один (последний) пакет из каждой группы пакетов для того или иного адреса IP и передавать сохраненный пакет, когда адрес будет преобразован (resolve).</p><ul><li class="b">Обсуждение:</li><li class="lib">Невыполнение приведенного выше требования приводит к потере первого пакета при каждом обмене. Хотя протоколы верхних уровней в общем случае способны заново отправлять пакеты при их потере, утрата пакетов будет снижать производительность системы. Например, потеря запроса на открытие сеанса TCP приведет к тому, что оценка времени кругового обхода (round-trip time) будет некорректной. Приложения на основе UDP (такие, как DNS) будут еще сильнее страдать от такого недостатка.</li></ul><h4>2.3.3 Инкапсуляция Ethernet и IEEE 802</h4><p>Инкапсуляция пакетов IP для сетей Ethernet описана в [<a href="../894.rfc" title="RFC 894 - Стандарт передачи дейтаграмм IP в сетях Ethernet">RFC894</a>], а [<a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC1042</a>] содержит описание инкапсуляции IP для сетей IEEE 802. <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC 1042</a> уточняет вопросы, рассмотренные в параграфе 3.4 документа [RFC1009].</p><p>Для каждого хоста Internet, подключенного к сети Ethernet (10 Мбит/с) с помощью кабеля</p><ul class="dot"><li>требуется поддержка приема и передачи пакетов с использованием инкапсуляции <a href="../894.rfc" title="RFC 894 - Стандарт передачи дейтаграмм IP в сетях Ethernet">RFC 894</a>;</li><li>рекомендуется поддерживать прием пакетов <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC 1042</a> вперемешку с пакетами <a href="../894.rfc" title="RFC 894 - Стандарт передачи дейтаграмм IP в сетях Ethernet">RFC 894</a>;</li><li>допустимо поддерживать передачу пакетов с использованием инкапсуляции <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC 1042</a>.</li></ul><p>Хосты Internet, реализующие передачу с использованием инкапсуляции обоих типов (<a href="../894.rfc" title="RFC 894 - Стандарт передачи дейтаграмм IP в сетях Ethernet">RFC 894</a> и <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC 1042</a>), должны поддерживать возможность настройки (конфигурационная опция) используемого типа инкапсуляции. По умолчанию требуется использовать инкапсуляцию <a href="../894.rfc" title="RFC 894 - Стандарт передачи дейтаграмм IP в сетях Ethernet">RFC 894</a>.</p><p>Отметим, что стандартная инкапсуляция IP в соответствии с <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC 1042</a> не использует значение идентификатора протокола (K1=6), которое зарезервировано IEEE для протокола IP, устанавливая вместо этого значение K1=170, указывающее на расширение (SNAP), которое может использоваться для поля EtherType. Для систем Internet недопустима передача пакетов IEEE 802 с использованием K1=6.</p><p>Трансляция адресов Internet в адреса канального уровня для сетей Ethernet и IEEE 802 должна обеспечиваться на основе протокола ARP.</p><p>Значение MTU для Ethernet составляет 1500, а для 802.3 — 1492 байта.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Спецификация IEEE 802.3 обеспечивает работу по кабелям Ethernet 10 Мбит/с, что может вести к смешению в одной физической среде кадров Ethernet и IEEE 802.3. Приемник может различать кадры Ethernet и 802.3 по значению поля длины (Length) для 802.3 — это 2-октетное поле совпадает с полем EtherType в кадрах Ethernet. Значение поля длины для кадров 802.3 не должно превышать 1500, а все корректные значения EtherType превышают 1500.</p><p>Другая проблема совместимости связана с широковещательными кадрами на канальном уровне. Широковещательные кадры того или иного типа не будут видны хостам, способным принимать лишь другой тип кадров. Основной задачей данного параграфа является обеспечение рекомендаций по интероперабельности сетей с инкапсуляцией <a href="../894.rfc" title="RFC 894 - Стандарт передачи дейтаграмм IP в сетях Ethernet">RFC 894</a> и <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC 1042</a> в одной физической среде. Основной упор делается на доминирующие сейчас сети <a href="../894.rfc" title="RFC 894 - Стандарт передачи дейтаграмм IP в сетях Ethernet">RFC 894</a>, с учетом перехода в будущем на инкапсуляцию <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC 1042</a>.</p><p class="note">Отметим, что системы, поддерживающие только <a href="../894.rfc" title="RFC 894 - Стандарт передачи дейтаграмм IP в сетях Ethernet">RFC 894</a>, не могут напрямую взаимодействовать с системами <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC 1042</a>. Если каждый тип инкапсуляции организовать в виде логической сети (на том же кабеле), то две логические сети можно будет связать через шлюз IP (маршрутизатор). Использование хостов, способных поддерживать оба формата, не всегда полезно (и не всегда возможно), поскольку трудно автоматически определить формат передачи кадров из-за проблем с широковещательными кадрами канального уровня.</p></li></ul><h3 id="p2.4">2.4 Интерфейс между канальным уровнем и IP</h3><p>Интерфейс приема пакетов между IP и канальным уровнем должен включать флаг, показывающий пакеты для широковещательной рассылки на канальном уровне.</p><ul><li class="b">Обсуждение:</li><li class="lib">Хотя уровень IP в общем случае не знает адресов канального уровня (поскольку в каждой физической среде используется свой формат адресации), широковещательный адрес для поддерживающих широковещательную рассылку сред является в некотором роде исключением из общего правила. Более подробное рассмотрение этого вопроса приведено в параграфе 3.2.2.</li></ul><p>Интерфейс передачи пакетов между IP и канальным уровнем должен включать 5-битовое поле TOS, описанное в параграфе 3.2.1.6.</p><p>Для канального уровня недопустима передача сообщений об ошибке Destination Unreachable на уровень IP при отсутствии записи с адресом получателя в кэше ARP.</p><h3 id="p2.5">2.5 Требования к канальному уровню</h3><table><tr class="b"><td>Функция</td><td>Параграф</td><td>Требование</td></tr><tr><td>Трейлерная инкапсуляция</td><td>2.3.1</td><td>Обязательно</td></tr><tr><td>Передавать трейлеры по умолчанию без согласования</td><td>2.3.1</td><td>Недопустимо</td></tr><tr class="nbb"><td>ARP</td><td>2.3.2</td><td></td></tr><tr class="nbt"><td class="lia">Удаление устаревших записей</td><td>2.3.2.1</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Предотвращение ARP-лавин</td><td>2.3.2.1</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Настройка тайм-аута для кэша</td><td>2.3.2.1</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Сохранение по крайней мере последнего пакета с unresolved адресом</td><td>2.3.2.2</td><td>Рекомендуется</td></tr><tr><td>Инкапсуляция Ethernet и IEEE 802</td><td>2.3.3</td><td></td></tr><tr class="nbb"><td class="lia">Способность хоста:</td><td>2.3.3</td><td></td></tr><tr class="nbt"><td class="lib">Использовать <a href="../894.rfc" title="RFC 894 - Стандарт передачи дейтаграмм IP в сетях Ethernet">RFC 894</a> для приема и передачи</td><td>2.3.3</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Использовать <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC 1042</a> для приема</td><td>2.3.3</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lib">Использовать <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC 1042</a> для передачи</td><td>2.3.3</td><td>Возможно</td></tr><tr class="nbt"><td class="lic">Для этого случая поддержка по умолчанию <a href="../894.rfc" title="RFC 894 - Стандарт передачи дейтаграмм IP в сетях Ethernet">RFC 894</a></td><td>2.3.3</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Использование инкапсуляции с K1=6</td><td>2.3.3</td><td>Недопустимо</td></tr><tr class="nbt"><td class="lia">Поддержка ARP для сетей Ethernet и IEEE 802</td><td>2.3.3</td><td>Обязательно</td></tr><tr><td>Канальный уровень сообщает о широковещательных кадрах уровню IP</td><td>2.4</td><td>Обязательно</td></tr><tr><td>Передача уровнем IP значений TOS на канальный уровень</td><td>2.4</td><td>Обязательно</td></tr><tr><td>Трактовка отсутствия адреса в кэше как Destination Unreachable</td><td>2.4</td><td>Недопустимо</td></tr></table><h2 id="p3">3. Протоколы уровня INTERNET</h2><h3 id="p3.1">3.1 Введение</h3><p>Принцип устойчивости — "быть либеральным при приеме и консервативным при передаче" особенно важен для уровня Internet, где некорректное поведение одного хоста может нарушить работу множества других хостов.</p><p>К числу протокольных стандартов уровня Internet относятся:</p><ul><li class="b">[<a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC791</a>]</li><li class="lib">определяет протокол IP и содержит введение в архитектуру Internet.</li><li class="b">[<a href="../792.rfc" title="RFC 792 - Протокол ICMP">RFC792</a>]</li><li class="lib">определяет протокол ICMP, обеспечивающий диагностику и сообщения об ошибках для протокола IP. Хотя сообщения ICMP инкапсулируются в дейтаграммы IP, обработка ICMP рассматривается (и обычно реализована) как часть уровня IP. См. параграф 3.2.2.</li><li class="b">[<a href="../950.rfc" title="RFC 950 - Стандартные процедуры организации подсетей IP">RFC950</a>]</li><li class="lib">определяет обязательную поддержку подсетей для архитектуры адресации.</li><li class="b">[<a href="../1112.rfc" title="RFC 1112 - Расширение IP Multicasting">RFC1112</a>]</li><li class="lib"><p>определяет протокол IGMP (Internet Group Management Protocol — протокол управления группами Internet) как часть рекомендуемого расширения для хостов и интерфейсов хост-шлюз, обеспечивающего в масштабах Internet поддержку групповой адресации на уровне IP. См. параграф 3.2.3.</p><p>Адресатами групповых (multicast) пакетов IP могут быть произвольные группы хостов Internet. Групповая адресация IP разработана как естественное расширение групповой адресации на канальном уровне и обеспечивает стандартное толкование для локального доступа к multicasting-объектам.</p></li></ul><p>Ссылки на другие источники информации приведены в главе 5.</p><p>Программы уровня Internet на каждом хосте должны поддерживать оба протокола — IP и ICMP. Требования в части поддержки IGMP рассмотрены в параграфе 3.3.7.</p><p>Уровень IP выполняет две основных функции: (1) выбирает следующий маршрутизатор или хост (next hop) для исходящих дейтаграмм IP и (2) обеспечивает сборку принимаемых дейтаграмм IP. Уровень IP также может (3) реализовать преднамеренную фрагментацию исходящих дейтаграмм. Наконец, уровень IP должен (4) поддерживать детектирование и обработку ошибок. Предполагается, что в будущем функциональность уровня IP может быть расширена путем разработки новых приложений Internet для контроля и управления.</p><p>Для нормальных дейтаграмм осуществляется прямая (straightforward) обработка. Для входящих дейтаграмм уровень IP выполняет следующие операции:</p><ol><li>проверка корректности формата дейтаграммы;</li><li>проверка того, что дейтаграмма адресована локальному хосту;</li><li>обработка опций;</li><li>при необходимости сборка дейтаграмм из фрагментов;</li><li>передача инкапсулированного в дейтаграмме сообщения соответствующему модулю транспортного уровня.</li></ol><p>Для исходящих дейтаграмм уровень IP выполняет следующие операции:</p><ol><li>установка всех полей, не заданных на транспортном уровне;</li><li>выбор подходящего интерфейса подключенной сети (маршрутизация);</li><li>фрагментация дейтаграммы, если это необходимо, или преднамеренная фрагментация при использовании таковой (см. параграф 3.3.3);</li><li>передача пакетов соответствующему драйверу канального уровня.</li></ol><p>Хост называют многодомным (multihomed), если он имеет несколько адресов IP. Поддержка множества адресов для хостов вносит в стек протоколов дополнительную сложность и возможность путаницы, В этой части архитектуры Internet требуется серьезная работа для решения всех проблем. С поддержкой множества адресов связаны, прежде всего, две аспекта проблемы:</p><ol><li>Local multihoming — рассматриваемый хост имеет множество адресов;</li><li>Remote multihoming — локальному хосту приходится работать с удаленным хостом, использующим множество адресов.</li></ol><p>В настоящее время обслуживание работы с удаленными многодомными хостами должно обеспечиваться на прикладном уровне, как описано в [<a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC1123</a>]. Работа с локальным хостом, поддерживающим множество адресов, рассмотрена ниже (параграф 3.3.4).</p><p>Любой хост, пересылающий дейтаграммы от других хостов, действует как маршрутизатор и должен удовлетворять спецификациям маршрутизаторов (шлюзов), рассматриваемым в [RFC1009]. Хост Internet, поддерживающий встроенный маршрутизатор, должен иметь конфигурационные опции, позволяющие отключить маршрутизацию и по умолчанию маршрутизация должна быть выключена. В таком режиме дейтаграмма, принятая через какой-либо интерфейс, не будет пересылаться другому хосту или шлюзу (если не используется маршрутизация, заданная отправителем — source-route), независимо от числа имеющихся в данном хосте интерфейсов. Не допускается автоматический переход хоста в режим маршрутизации при наличии на хосте нескольких интерфейсов, поскольку оператор хоста может не желать выполнять функции маршрутизации и быть некомпетентным в этом вопросе.</p><p>В таких случаях для принятой дейтаграммы зачастую используют операцию silently discard. Это означает, что дейтаграмма отбрасывается без дальнейшей обработки и даже не передается сообщение ICMP об ошибке (см. параграф 3.2.2). Однако, для обеспечения диагностики хост должен обеспечивать возможность протоколирования таких ошибок (см. параграф 1.2.3), включая запись содержимого отбрасываемых дейтаграмм. Кроме того, количество отбрасываемых дейтаграмм должно учитываться счетчиком статистики.</p><ul><li class="b">Обсуждение:</li><li class="lib">Тихое отбрасывание ошибочных дейтаграмм в общем случае используется для предотвращения широковещательных штормов (broadcast storms).</li></ul><h3 id="p3.2">3.2 Общие вопросы</h3><h4>3.2.1 Протокол Internet — IP</h4><h5>3.2.1.1 Номер версии: RFC 791, параграф 3.1</h5><p>Дейтаграммы с номером версии, отличающимся от 4, должны отбрасываться без уведомления.</p><h5>3.2.1.2 Контрольная сумма: RFC 791, параграф 3.1</h5><p>Хост должен проверять контрольную сумму заголовка IP для каждой полученной дейтаграммы и отбрасывать без уведомления дейтаграммы с некорректной контрольной суммой.</p><h5>3.2.1.3 Адресация: RFC 791, параграф 3.2</h5><p>Существует пять классов IP-адресов — от A до E. Адреса класса D используются для групповой адресации IP [<a href="../1112.rfc" title="RFC 1112 - Расширение IP Multicasting">RFC1112</a>], а класс E зарезервирован для экспериментов.</p><p>Групповые адреса (класс D) представляют собой 28-битовые логические адреса, используемые для групп хостов, и могут быть постоянными (permanent) или временными (transient). Постоянные групповые адреса распределяет агентство IANA (Internet Assigned Number Authority) [RFC1010], а временные динамически выделяются для временных групп хостов. Принадлежность к группе определяется динамически на основе протокола IGMP [<a href="../1112.rfc" title="RFC 1112 - Расширение IP Multicasting">RFC1112</a>].</p><p>Рассмотрим более подробно IP-адреса классов A, B и C, используя обозначения:</p><pre>{ &lt;Номер сети&gt;, &lt;Номер хоста&gt; }</pre><p>или</p><pre>{ &lt;Номер сети&gt;, &lt;Номер подсети&gt;, &lt;Номер хоста&gt; }</pre><p>и "-1" для обозначения полей, содержащих только единицы (1). Такая нотация не предполагает, что единицы в маске адреса должны быть непрерывными.</p><ul class="lat"><li><pre>{ 0, 0 }</pre><p>Данный хост в данной сети. Этот адрес недопустимо указывать в качестве адреса отправителя за исключением случаев передачи адреса отправителя в процессе инициализации, посредством которого хост узнает свой IP-адрес.</p><p>В параграфе 3.3.6 рассмотрены варианты нестандартного использования {0,0}.</p></li><li><pre>{ 0, &lt;Номер хоста&gt; }</pre><p>Указывает хост данной сети. Такие адреса недопустимо указывать в качестве адреса отправителя за исключением случаев использования как адреса отправителя в процедурах инициализации, с помощью которых хост получает полный IP-адрес.</p></li><li><pre>{ -1, -1 }</pre><p>Широковещательный пакет ограниченного действия (Limited broadcast). Такой адрес недопустимо указывать в качестве адреса отправителя.</p><p>Дейтаграмма с таким адресом в поле получателя будет приниматься каждым хостом данной физической сети, но не будет выходить за пределы сети через маршрутизаторы.</p></li><li><pre>{ &lt;Номер сети&gt;, -1 }</pre><p>Широковещательный адрес для данной сети. Такой адрес недопустимо указывать в качестве адреса отправителя.</p></li><li><pre>{ &lt;Номер сети&gt;, &lt;Номер подсети&gt;, -1 }</pre><p>Широковещательный пакет для указанного маршрутизатора (конкретной подсети). Такой адрес недопустимо указывать в качестве адреса отправителя.</p></li><li><pre>{ &lt;Номер сети&gt;, -1, -1 }</pre><p>Широковещательный пакет для всех подсетей данной сети. Такой адрес недопустимо указывать в качестве адреса отправителя.</p></li><li><pre>{ 127, &lt;любой&gt; }</pre><p>Внутренний loopback-адрес хоста. Пакеты с таким адресом отправителя недопустимо передавать за пределы хоста.</p></li></ul><p>Номера сетей распределяются административно, чтобы каждая сеть в масштабе планеты имела уникальный номер. В адресах IP недопустимо использование значений 0 и -1 в любом из полей &lt;Номер хоста&gt;, &lt;Номер сети&gt; или &lt;Номер подсети&gt;, за исключением специальных случаев, перечисленных выше. Это требование подразумевает, что каждое из полей должно иметь размер не менее 2 битов.</p><p>Более подробное рассмотрение широковещательных адресов дается в параграфе 3.3.6.</p><p>Хост должен поддерживать подсети IP [<a href="../950.rfc" title="RFC 950 - Стандартные процедуры организации подсетей IP">RFC950</a>]. В соответствии с этим требованием каждый хост должен иметь маску адреса в форме {-1, -1, 0} (см. параграфы 3.2.2.9 и 3.3.1.1).</p><p>Когда хост передает дейтаграмму, в качестве IP-адреса отправителя должен указываться один из IP-адресов этого хоста, но не широковещательный или групповой адрес.</p><p>Хост должен отбрасывать без уведомления входящие дейтаграммы, не адресованные этому хосту. Входящая дейтаграмма считается адресованной хосту, если в поле адреса получателя указан:</p><ol><li>IP-адрес этого хоста (один из имеющихся);</li><li>широковещательный адрес IP, корректный для данной сети;</li><li>адрес multicast-группы, в которую входит данный хост.</li></ol><p>В большинстве случаев дейтаграммы, адресованные всем (broadcast) или группе (multicast) хостов, обрабатываются так, будто они направлены по одному из IP-адресов данного хоста. Мы будем использовать термин «конкретный адрес получателя» (specificdestination address) в качестве эквивалента локального IP-адреса хоста. Конкретный адрес получателя должен указываться в заголовках пакетов IP, если такие пакеты не являются групповыми или широковещательными. Конкретный адрес получателя является IP-адресом физического интерфейса, через который дейтаграмма принимается хостом.</p><p>Хост должен без уведомления отбрасывать дейтаграммы, содержащие адрес отправителя, противоречащий приведенным в этом параграфе правилам. Проверка корректности может осуществляться на уровне IP или любым протоколом транспортного уровня.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Дейтаграммы с некорректными адресами могут появляться в результате широковещательной рассылки на канальном уровне дейтаграмм с конкретным (unicast) адресом или вследствие ошибок в настройках хостов и маршрутизаторов.</p><p>Архитектура хостов Internet должна поддерживать обработку IP-адресов как 32-битовых целых чисел без каких-либо особенностей и избегать применения алгоритмов, требующих знания формата IP-адресов. Если этому правилу не следовать, любые изменения формата или интерпретации адресов в будущем потребуют внесения изменений в программы хостов. Однако, проверка корректности широковещательных и групповых адресов требует отказа от таких правил.</p><p>Разработчики программ должны знать, что приложения, использующие широковещательную адресацию во все подсети (рассмотренный выше вариант f) могут оказаться неработоспособными в некоторых сетях. Широковещание для всех подсетей поддерживается не всеми маршрутизаторами и даже при наличии такой поддержки отдельные администраторы запрещают ее при настройке маршрутизаторов.</p></li></ul><h5>3.2.1.4 Фрагментация и сборка: RFC 791, параграф 3.2</h5><p>Модель Internet требует, чтобы каждый хост поддерживал сборку фрагментов (reassembly). Требования к фрагментации и сборке рассмотрены в параграфах 3.3.2 и 3.3.3.</p><h5>3.2.1.5 Идентификация: RFC 791, параграф 3.2</h5><p>При передаче идентичной копии ранее отправленной дейтаграммы хост может сохранять идентификационное поле для такой копии.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Некоторые специалисты по протоколам Internet утверждают, что при передаче копии ранее отправленной дейтаграммы эта копия должна содержать такое же значение поля идентификации, как оригинал. Это обеспечивает два преимущества: (1) если дейтаграмма фрагментирована и некоторые фрагменты теряются, принимающая сторона может восстановить полную дейтаграмму из фрагментов оригинала и копии; (2) загруженный (congested) маршрутизатор может использовать поле IP Identification (и поле Fragment Offset — смещение фрагмента) для удаления дубликатов дейтаграмм из очереди.</p><p>Однако наблюдения за реальным трафиком и потерей дейтаграмм в Internet показывают, что использование первого из перечисленных преимуществ маловероятно в силу существования других механизмов (например, перепаковка TCP перед повторной передачей), предотвращающих повторную передачу идентичных дейтаграмм [IP:9]. Следовательно, сохранение идентификационного поля при повторной передаче дейтаграмм может оказаться бесполезным. Кроме того, работающие без организации соединений протоколы (типа UDP) будут требовать взаимодействия с прикладными программами для сохранения значения идентификационного поля при повторной передаче.</p></li></ul><h5>3.2.1.6 Тип обслуживания: RFC 791, параграф 3.2</h5><p>Байт Type-of-Service (тип обслуживания) в заголовке IP поделен на 2 части — поле Precedence (3 старших бита) и поле TOS (5 младших битов). В этом документе термин TOS всегда относится к одноименному полю (младшие 5 битов).</p><p>Поле Precedence предназначено для специальных приложений Министерства Обороны (Department of Defense). Вопросы использования отличных от 0 значений этого поля выходит за пределы компетенции настоящего документа и стандартов IP. Производители продукции должны консультироваться с агентством DCA (Defense Communication Agency) для получения рекомендаций по использованию поля Precedence в своих реализациях протоколов других уровней. Однако, разработчики должны понимать, что использование поля precedence потребует передачи его значения между протоколами разных уровней, как это делается для поля TOS.</p><p>Уровень IP должен обеспечивать для транспортного уровня способ установки поля TOS в каждой передаваемой дейтаграмме (по умолчанию все биты имеют нулевые значения). Рекомендуется для уровня IP передавать значения TOS принятых из сети пакетов на транспортный уровень.</p><p>Отображения TOS на канальном уровне, определенные в RFC 795, не рекомендуется применять.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Хотя поле TOS мало использовалось в прошлом, планируется возрастание роли этого поля в ближайшем будущем. Предполагается, что TOS будет использоваться для управления двумя аспектами работы шлюзов — маршрутизацией и алгоритмами использования очередей. В параграфе 2 работы [<a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC1123</a>] рассматриваются требования к прикладным программам для работы с полем TOS.</p><p>Значение TOS должно также отображаться на селекторы сервиса канального уровня. Такое решение, например, применяется для организации эффективного совместного использования (sharing) последовательных каналов разными классами трафика TCP. Однако отображение, предложенное в RFC 795 для сетей, которые входили в состав Internet в 1981 году, сейчас явно устарело.</p></li></ul><h5>3.2.1.7 Время жизни: RFC 791, параграф 3.2</h5><p>Для хостов недопустима передача дейтаграмм с нулевым значением времени жизни (поле TTL).</p><p>Для хостов недопустимо отбрасывание дейтаграмм лишь потому, что они приняты со значением поля TTL &lt; 2.</p><p>Уровень IP должен обеспечивать для транспортного уровня способ установки поля TTL в каждой передаваемой дейтаграмме. При использовании фиксированного значения TTL требуется обеспечить возможность настройки этого значения. Рекомендуемые значения времени жизни указаны в документе "Assigned Numbers".</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Поле TTL обеспечивает две функции — ограничение времени жизни сегментов TCP ([<a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC793</a>], стр. 28) и предотвращение петель в маршрутизации Internet. Хотя TTL задает время в секундах, это поле используется также в качестве счетчика интервалов (hop-count), поскольку каждый маршрутизатор должен уменьшать значение поля TTL на 1. Смысл поля TTL состоит в том, что при уменьшении значения этого поля до 0 дейтаграмма отбрасывается маршрутизатором (но не конечным хостом). Хосты, выполняющие функции маршрутизации, должны следовать этому правилу для TTL, как маршрутизаторы.</p><p>Протокол вышележащего уровня может устанавливать значение TTL при реализации поиска в расширенной области ("expanding scope" search) для некоторых ресурсов Internet. Такой ход используется также некоторыми средствами диагностики и может оказаться полезным в целом ряде случаев (например, для обнаружения «ближайшего» сервера данного класса с использованием групповой адресации IP). Конкретный протокол транспортного уровня может задать свою границу TTL для максимального времени жизни дейтаграмм.</p><p>При использовании фиксированного значения времени жизни оно должно быть достаточно велико (по крайней мере, больше «диаметра» Internet — самого длинного из возможных путей). Разумно устанавливать для времени жизни двойной «диаметр» с учетом продолжающегося расширения Internet.</p></li></ul><h5>3.2.1.8 Опции: RFC 791, параграф 3.2</h5><p>Для транспортного уровня должен обеспечиваться способ задания опций IP, которые будут включаться во все передаваемые дейтаграммы IP (см. параграф 3.4).</p><p>Все опции IP (за исключением NOP и END-OF-LIST) из принимаемых дейтаграмм должны передаваться на транспортный уровень или системе обработки ICMP (если дейтаграмма является сообщением ICMP). Оба уровня (транспортный и уровень IP) должны интерпретировать понятные им опции IP, игнорируя остальные.</p><p>Ниже в этом документе рассматриваются вопросы поддержки специфических опций IP, требуемой протоколами ICMP, TCP и UDP.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Передача всех принятых опций IP на транспортный уровень является преднамеренным «нарушением жесткого деления на уровни», которое предназначено для упрощения ввода в будущем новых опций IP, относящихся к транспортному уровню. Каждый уровень должен выбрать все имеющие к нему отношение опции для внутренней обработки и игнорировать остальные опции. Для этого каждая опция IP (кроме NOP и END-OF-LIST) указывает свой размер.</p><p>В этом документе не определяется порядок обработки опций каждого заголовка IP. Хосты, использующие множество опций при передаче, должны понимать, что результаты могут зависеть от порядка обработки опций.</p></li><li class="b">Реализация</li><li class="lib"><p>Программы IP-уровня должны быть устойчивы к сообщениям с опциями, размер которых выходит за допустимые пределы. Известны примеры реализаций, которые входят в бесконечный цикл при получении пакетов с полем опций некорректного размера.</p><p>Ниже перечислены требования к отдельным опциям IP:</p><ul class="lat"><li><p>Security (безопасность)</p><p>Некоторые среды требуют наличия опции Security в каждой дейтаграмме — такие требования выходят за пределы настоящего документа и стандартов IP. Отметим, что опции безопасности, определенные в <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC 791</a> и RFC 1038, утратили силу. Для приложений DoD разработчикам следует обращаться к документу [RFC1108].</p></li><li><p>Stream Identifier (идентификатор потока)</p><p>Эта опция устарела — ее недопустимо передавать в пакетах, а на приемной стороне она должна игнорироваться.</p></li><li><p>Source Route (маршрутизация отправителем)</p><p>Хост должен поддерживать маршрутизацию отправителем в исходящих дейтаграммах и должен поддерживать себя, как конечного адресата при маршрутизации отправителем.</p><p>Если хост получает дейтаграмму, содержащую завершенный маршрут от отправителя (completed source route), это говорит о доставке дейтаграммы конечному адресату. Принятые опции (записанный маршрут) должны передаваться на транспортный уровень (или системе обработки сообщений ICMP). Записанные маршруты будут инвертироваться и использоваться для передачи отклика на дейтаграмму (см. Опции IP в главе 4). Когда маршрут возврата построен, требуется корректно сформировать его даже при использовании записи маршрута от хоста-отправителя (см. пункт (B) ниже).</p><p>Заголовки IP, содержащие более одной опции Source Route, передавать недопустимо, поскольку маршрутизация в таких случаях будет зависеть от реализации.</p><p>В параграфе 3.3.5 приведены правила для хостов, выступающих в качестве промежуточных (intermediate hop) для source route (т. е. пересылающих дейтаграммы с заданной отправителем маршрутизацией).</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>При фрагментировании дейтаграмм source-route каждый фрагмент будет содержать копию заданного отправителем маршрута. Поскольку обработка опций IP (включая source route) должна предшествовать сборке фрагментов, исходная дейтаграмма не может быть собрана до тех пор, пока она не будет доставлена конечному адресату.</p><p>Предположим, что такая дейтаграмма передается от хоста S на хост D через шлюзы G1, G2, ... Gn. В спецификации IP существуют неоднозначности, позволяющие задавать для опций source route дейтаграмм, передаваемых хостом S, вариант (A) или (B):</p><ul><li>A)<pre>{>>G2, G3, ... Gn, D} &lt;--- корректно</pre></li><li>B)<pre>{S, >>G2, G3, ... Gn, D} &lt;---- ошибка</pre></li></ul><p>(>> представляет указатель). При использовании варианта (A) дейтаграмма, принятая хостом D, будет содержать опции {G1, G2, ... Gn >>}, с IP-адресами хостов S и D как отправителя и получателя. Если использован вариант (B), принятая хостом D дейтаграмма будет по-прежнему содержать адреса S и D как отправителя и получателя, но опции будут иметь вид {S, G1, ...Gn >>}, т. е; хост-отправитель исходной дейтаграммы оказывается первым в маршруте возврата.</p></li></ul></li><li><p>Record Route (запись маршрута)</p><p>Реализация установки и обработки опции Record Route является необязательной.</p></li><li><p>Timestamp (временная метка)</p><p>Реализация установки и обработки опции Timestamp является необязательной. При реализации этой опции должны выполняться следующие правила:</p><ul class="dot"><li><p>Хост-отправитель должен записывать временную метку в поле Timestamp опций, для которых поле адреса еще не указано или содержит адрес интерфейса данного хоста.</p></li><li><p>Принимающий хост должен (если это возможно) добавить текущее время в опцию Timestamp перед передачей опции для обработки на транспортный уровень или ICMP.</p></li><li><p>Значение временной метки должно соответствовать требованиям, приведенным в параграфе 3.2.2.8 для сообщений ICMP Timestamp.</p></li></ul></li></ul></li></ul><h4>3.2.2 Протокол управляющих сообщений Internet — ICMP</h4><p>Сообщения ICMP делятся на два класса.</p><ul><li class="b">ICMP-сообщения об ошибках:</li><li class="lib"><ul><li>Destination Unreachable — адресат недоступен (см. параграф 3.2.2.1)</li><li>Redirect — перенаправление (см. параграф 3.2.2.2)</li><li>Source Quench — «заткнуть рот отправителю» (см. параграф 3.2.2.3)</li><li>Time Exceeded — время жизни истекло (см. параграф 3.2.2.4)</li><li>Parameter Problem — проблема с параметрами (см. параграф 3.2.2.5)</li></ul></li><li class="b">Запросы ICMP:</li><li class="lib"><ul><li>Echo — эхо (см. параграф 3.2.2.6)</li><li>Information — информация (см. параграф 3.2.2.7)</li><li>Timestamp — временная метка (см. параграф 3.2.2.8)</li><li>Address Mask — маска адреса (см. параграф 3.2.2.9)</li></ul></li></ul><p>При получении сообщений ICMP неизвестного типа такие сообщения должны отбрасываться без уведомления.</p><p>Каждое сообщение ICMP об ошибке включает заголовок Internet и по крайней мере первые 8 октетов дейтаграммы, с которой связана ошибка. Заголовок и данные должны в точности соответствовать исходной дейтаграмме, связанной с ошибкой; возможно включение более 8 октетов.</p><p>В тех случаях, когда уровень Internet должен передавать сообщения ICMP на транспортный уровень, из исходного сообщения должен извлекаться номер протокола IP, используемый для выбора соответствующего объекта транспортного уровня, обеспечивающего обработку ошибок.</p><p>Сообщения ICMP об ошибках должны передаваться с нормальными (т. е., 0) значениями битов TOS.</p><p>Не допускается передача сообщений ICMP об ошибках в результате приема следующих пакетов:</p><ul class="dot"><li>сообщение ICMP об ошибке</li><li>дейтаграммы с групповым или широковещательным адресом IP</li><li>дейтаграммы, переданные как широковещательные на канальном уровне</li><li>фрагмент, не являющийся первым</li><li>дейтаграммы, для которых адрес отправителя не определен как один хост (например, нулевой адрес, loopback-адрес, широковещательный или групповой адрес, адрес класса E).</li></ul><ul><li class="b">Обсуждение:</li><li class="lib"><p>Эти правила будут предотвращать возникновение «широковещательных штормов» (broadcast storm) при получении хостом ICMP-сообщения об ошибке в ответ на широковещательную дейтаграмму. Например, широковещательный сегмент UDP, адресованный в несуществующий порт, может инициировать лавину дейтаграмм ICMP Destination Unreachable от всех машин, которые не обслуживают указанный в дейтаграмме порт. В большой сети Ethernet такая лавина может привезти к остановке сети на несколько секунд в результате возникновения коллизий.</p><p>Каждая дейтаграмма, передаваемая в широковещательном режиме в подключенную сеть, должна содержать корректный широковещательный адрес IP для своих получателей (см. параграф 3.3.6). Однако, некоторые хосты не соблюдают это правило, поэтому каждый хост должен проверять широковещательные адреса канального уровня и широковещательные адреса IP.</p></li><li class="b">Реализация</li><li class="lib">Канальный уровень должен информировать уровень IP о получении широковещательных для канального уровня дейтаграмм (см. параграф 2.4).</li></ul><h5>3.2.2.1 Destination Unreachable: RFC 792</h5><p>Для сообщений этого типа определены дополнительные коды:</p><ul><li>6 — неизвестна сеть адресата</li><li>7 — неизвестен хост-адресат</li><li>8 — изолированный хост-отправитель</li><li>9 — связь с сетью адресата административно запрещена</li><li>10 — связь с хостом-адресатом административно запрещена</li><li>11 — сеть недоступна для заданного типа обслуживания</li><li>12 — хост недоступен заданного типа обслуживания</li></ul><p>Рекомендуется для хостов генерировать сообщения Destination Unreachable с кодами:</p><ul><li>2 (Protocol Unreachable — протокол недоступен) — указанный транспортный протокол не поддерживается</li><li>3 (Port Unreachable — порт недоступен) — указанный транспортный протокол (например, UDP) не может демультиплексировать дейтаграмму и нет механизма передачи отправителю уведомления.</li></ul><p>Принятые сообщения Destination Unreachable должны передаваться на транспортный уровень. Транспортный уровень должен использовать полученную информацию подобающим образом (см. примеры в параграфах 4.1.3.3, 4.2.3.9, 4.2.4). Транспортный протокол, обеспечивающий собственный механизм уведомления отправителя о недоступности портов (например, TCP при передаче сегментов RST), никогда не должен воспринимать сообщения ICMP Port Unreachable для таких же целей.</p><p>Сообщение Destination Unreachable, принятое с кодом 0 (Net — сеть), 1 (Host — хост) или 5 (Bad Source Route — некорректный маршрут от отправителя), может приходить от транзитного маршрутизатора и должно интерпретироваться как намек (не доказательство) на то, что адресат может быть недоступен [RFC816]. В частности, такие сообщения не могут служить доказательством неработоспособности маршрутизатора (см. параграф 3.3.1).</p><h5>3.2.2.2 Redirect: RFC 792</h5><p>Хостам не рекомендуется передавать сообщений ICMP Redirect, поскольку эти сообщения являются прерогативой маршрутизаторов. Хост, получивший сообщение Redirect, должен соответственно скорректировать свою маршрутную информацию. Каждый хост должен быть готов к приему сообщений Host Redirect и Network Redirect для их обработки в соответствии с рекомендациями параграфа 3.3.1.2.</p><p>Сообщения Redirect рекомендуется отбрасывать без уведомления, если указанный в них новый шлюз не находится в той же сети, через которую было доставлено сообщение Redirect [INTRO:2, Appendix A], или сообщения Redirect приходят от маршрутизатора, который не указан как first-hop (первый маршрутизатор) для данного получателя (см. параграф 3.3.1).</p><h5>3.2.2.3 Source Quench: RFC 792</h5><p>Хост может передавать сообщения Source Quench в тех случаях, когда он находится или приближается к состоянию необходимости отбрасывания входящих дейтаграмм в результате переполнения буферов сборки или нехватки других ресурсов. Более подробную информацию по этому вопросу вы сможете найти в параграфе 2.2.3 работы [RFC1009].</p><p>При получении сообщения Source Quench уровень IP должен сообщить о нем транспортному уровню (или системе обработки сообщений ICMP). В общем случае транспортный или прикладной уровень должен обеспечивать механизм реакции на сообщения Source Quench для всех протоколов, которые могут передавать последовательность дейтаграмм одному адресату и способны поддерживать достаточно информации о состоянии, чтобы сделать возможной реакцию на такие сообщения. Обработка сообщений Source Quench протоколами TCP и UDP описана в главе 4.</p><ul><li class="b">Обсуждение:</li><li class="lib">Сообщения Source Quench могут генерироваться хостами-получателями или некоторыми шлюзами по пути передачи дейтаграмм. Хост, получивший сообщение Source Quench, должен снизить уровень трафика для данного получателя на некоторое время и потом постепенно восстанавливать его. Механизм реакции на сообщения Source Quench может быть реализован на транспортном (для протоколов на основе соединений типа TCP) или прикладном (для протоколов, работающих поверх UDP) уровне. В работе [RFC1016] предложен механизм для уровня IP, позволяющий непосредственно реагировать на сообщения Source Quench за счет управления скоростью передачи дейтаграмм, однако это предложение пока является только экспериментальным и не может быть рекомендовано для использования.</li></ul><h5>3.2.2.4 Time Exceeded: RFC 792</h5><p>Принимаемые сообщения Time Exceeded должны передаваться на транспортный уровень.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Маршрутизаторы передают сообщение Time Exceeded с кодом 0 (In Transit — в процессе передачи) при получении дейтаграмм с нулевым значением TTL (время жизни). Такая ситуация может говорить о наличии петель в маршрутизации или слишком малом значении TTL при генерации дейтаграммы.</p><p>Хост может получать сообщения Time Exceeded с кодом 1 (Reassembly Timeout — тайм-аут при сборке) от хоста-адресата, который не смог в заданное время получить все фрагменты и собрать дейтаграмму. В будущем такие сообщения могут стать частью некоторых процедур MTU discovery, используемых для определения максимального размера дейтаграмм, которые можно передать без фрагментации.</p></li></ul><h5>3.2.2.5 Parameter Problem: RFC 792</h5><p>Для хостов рекомендуется генерировать сообщения Parameter Problem. Принимаемые сообщения Parameter Problem должны передаваться на транспортный уровень и, кроме того, информация о таких сообщениях может передаваться пользователю.</p><ul><li class="b">Обсуждение:</li><li class="lib">Сообщения ICMP Parameter Problem передаются хосту-отправителю при обнаружении любых проблем, для которых нет специализированных сообщений ICMP. Появление сообщений Parameter Problem обычно служит сигналом о наличии ошибок в работе протоколов на локальном или удаленном хосте.</li></ul><p>Ниже определяется новое значение кода для сообщений Parameter Problem:</p><ul><li>1 = отсутствует обязательный параметр.</li></ul><ul><li class="b">Обсуждение:</li><li class="lib">Этот код уже используется в военных приложениях при отсутствии опций безопасности.</li></ul><h5>3.2.2.6 Echo Request/Reply: RFC 792</h5><p>Каждый хост должен поддерживать функции сервера ICMP Echo, обеспечивающие прием запросов Echo Request и передачу в ответ на них сообщений Echo Reply. Рекомендуется также реализовать интерфейс прикладного уровня для передачи сообщений Echo Request и получения откликов Echo Reply с диагностическими целями.</p><p>Сообщения ICMP Echo Request, полученные с групповым или широковещательным адресом IP, можно отбрасывать без уведомления.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Здесь приводятся беспристрастные результаты дебатов между теми, кто считает, что отклики на широковещательные запросы ICMP Echo обеспечивают эффективные возможности для диагностики, и теми, кто утверждает, что с помощью таких откликов очень легко создать пакетные бури.</p><p>IP-адрес отправителя в откликах ICMP Echo Reply должен совпадать с указанным адресом получателя (см. определение в 3.2.1.3) из соответствующего сообщения ICMP Echo Request.</p><p>Данные, получаемые в запросе ICMP Echo Request, должны полностью включаться в результирующий отклик Echo Reply. Однако, если передача Echo Reply требует преднамеренной фрагментации, которая не реализована, дейтаграмма должна быть усечена до размера MTU (см. параграф 3.3.3).</p><p>Сообщения Echo Reply должны передаваться на пользовательский интерфейс ICMP, если соответствующий запрос Echo Request не направлен на уровень IP.</p><p>Если в запросе ICMP Echo Request присутствует опция Record Route и/или TimeStamp, эта опция(и) должна быть обновлена с включением в маршрут текущего хоста и вставлена в заголовок IP отклика Echo Reply без «усекновения». Таким образом, сохраняется записанный маршрут для замкнутого кольца.</p><p>Если в запросе ICMP Echo Request присутствует опция Source Route, маршрут возврата должен быть инвертирован и вставлен в поле Source Route сообщения Echo Reply.</p></li></ul><h5>3.2.2.7 Information Request/Reply: RFC 792</h5><p>Для хостов рекомендуется не реализовать эти сообщения.</p><ul><li class="b">Обсуждение:</li><li class="lib">Пара сообщений Information Request/Reply была предназначена для поддержки самонастраиваемых систем типа бездисковых станций, чтобы позволить им получать IP-адреса в процессе загрузки. Однако протоколы RARP и BOOTP обеспечивают более эффективные механизмы получения хостами IP-адресов.</li></ul><h5>3.2.2.8 Timestamp/Timestamp Reply: RFC 792</h5><p>Хост может поддерживать сообщения Timestamp и Timestamp Reply. Если такая поддержка реализована, должно выполняться следующее правило.</p><ul class="dot"><li>Функция сервера ICMP Timestamp возвращает сообщение Timestamp Reply в ответ на каждое принятое сообщение Timestamp. Если эта функция реализована, она должна обеспечивать минимальные вариации задержки (т. е. функция должна быть включена в ядро, чтобы избежать вариаций задержки, связанных с пользовательскими процессами).</li></ul><p>В перечисленных ниже случаях обработка Timestamp должна соответствовать правилам для ICMP Echo:</p><ul class="dot"><li><p>Сообщения Timestamp Request с групповыми и широковещательными адресами IP можно отбрасывать без уведомления.</p></li><li><p>IP-адрес отправителя в сообщении Timestamp Reply должен совпадать с адресом получателя, указанным в соответствующем запросе Timestamp.</p></li><li><p>При получении опции Source-route в запросе Timestamp, путь возврата должен инвертироваться при создании опции Source Route для отклика Timestamp Reply.</p></li><li><p>При наличии опции Record Route и/или Timestamp в запросе Timestamp Request, эти опции рекомендуется обновлять с включением текущего хоста и помещать обновленное значение в поле заголовка IP для сообщения Timestamp Reply.</p></li><li><p>Входящие сообщения Timestamp Reply должны передаваться пользовательскому интерфейсу ICMP. Предпочтительной формой временных меток ("стандартное значение") является число миллисекунд с полуночи по Стандартному времени (Universal Time). Однако временные метки с таким разрешением могут быть слишком сложны в реализации. Например, во многих системах используются часы, синхронизируемые от электросети (50 или 60 Гц) — следовательно, такие системы не могут обеспечить требуемого разрешения. Поэтому допускается отклонение от стандартного значения:</p><ul class="lat"><li>"Стандартное значение" должно обновляться не менее 15 раз в секунду (т. е. не менее 6 младших битов должны быть неопределенными).</li><li>Точность "стандартного значения" должна приближаться к точности таймера CPU.</li></ul></li></ul><h5>3.2.2.9 Address Mask Request/Reply: RFC 950</h5><p>Хост должен поддерживать первый и может реализовать все три из перечисленных ниже методов определения адресных масок, соответствующих IP-адресам этого хоста:</p><ol><li>статические конфигурационные параметры;</li><li>динамическое определение масок в процессе инициализации системы (см. [<a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC1123</a>]);</li><li>передача сообщений ICMP Address Mask Request и прием откликов ICMP Address Mask Reply.</li></ol><p>Для каждого хоста требуется обеспечить выбор используемого метода.</p><p>При использовании метода (3) можно применять Address Mask и должны выполняться следующие условия:</p><ul class="lat"><li><p>При инициализации хост должен передать с широковещательным адресом сообщение Address Mask Request в подключенную сеть. Если ответ Address Mask Reply не приходит незамедлительно, должно использоваться минимальное число повторов.</p></li><li><p>До получения отклика Address Mask Reply хосту рекомендуется предполагать, что маска соответствует классу адреса данного хоста (т. е. подключенная сеть не поделена на подсети).</p></li><li><p>Первое принятое сообщение Address Mask Reply должно использоваться для установки адресной маски, соответствующей частному локальному адресу IP. Это верно даже в тех случаях, когда первое сообщение Address Mask Reply не было запрошено (unsolicited) — в таких случаях оно будет широковещательным и может прийти после того, как хост перестал передавать повторные запросы Address Mask Request. После того, как маска была установлена с использованием Address Mask Reply, последующие сообщения Address Mask Reply должны игнорироваться.</p></li></ul><p>Если сообщения Address Mask запрещены, запросы ICMP Address Mask Request не будут передаваться и все принятые отклики ICMP Address Mask Reply для локального IP-адреса должны игнорироваться.</p><p>Для хостов рекомендуется выполнять некоторые разумные проверки устанавливаемых адресных масок (см. «Реализация» ниже). Недопустима передача системой откликов Address Mask Reply, если эта система не является уполномоченным агентом для адресных масок. Уполномоченный агент может быть хостом или шлюзом, но он должен быть явно настроен как агент для адресных масок. Получение адресных масок с помощью Address Mask Reply не дает получателю таких прав и не может использоваться как основание для передачи откликов Address Mask Reply.</p><p>При статически заданных адресных масках рекомендуется использовать дополнительный конфигурационный флаг, определяющий для хоста возможность выступать в качестве уполномоченного агента для масок (может ли этот хост отвечать на запросы Address Mask Request с использованием маски).</p><p>Настроенный как агент хост должен передать в широковещательном режиме сообщение Address Mask Reply для маски инициализируемого интерфейса.</p><p>Дополнительные сведения об использовании сообщений Address Mask Request/Reply приведены в параграфе System Initialization работы [<a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC1123</a>].</p><ul><li class="b">Обсуждение</li><li class="lib"><p>Хосты, передающие сообщения Address Mask Reply, часто могут порождать серьезные проблемы. Для предотвращения этого отклики Address Mask Reply должны передаваться только уполномоченными агентами, явно указанными администратором сети.</p><p>Когда уполномоченный агент получает сообщение Address Mask Request, он будет передавать отклик Address Mask Reply по IP-адресу отправителя запроса. Если сетевая часть этого адреса имеет нулевое значение (см. (a) и (b) в параграфе 3.2.1.3), отклик передается в широковещательном режиме.</p><p>Не получив отклика на сообщения Address Mask Request, хост будет предполагать отсутствие агентов или подсетей, но причиной отсутствия отклика может быть временная недоступность агента. Агент будет передавать в широковещательном режиме незапрошенные сообщения Address Mask Reply при своей инициализации для обновления масок на всех хостах, которые были инициализированы в период недоступности агента.</p></li><li class="b">Реализация</li><li class="lib">Предлагается выполнять следующую проверку адресной маски — в маске должны содержаться не только единицы (1) и старшие 8 битов должны быть установлены в 1 или вся маска должна быть нулевой.</li></ul><h4>3.2.3 Протокол IGMP (Internet Group Management Protocol)</h4><p>Протокол IGMP [<a href="../1112.rfc" title="RFC 1112 - Расширение IP Multicasting">RFC1112</a>] используется хостами и маршрутизаторами одной сети для организации и поддержки членства хостов в multicast-группах. Шлюзы используют этот протокол вместе с протоколом групповой маршрутизации для поддержки трафика IP multicast через Internet.</p><p>В настоящее время реализация IGMP является необязательной (см. параграф 3.3.7). Без использования IGMP хосты могут участвовать в multicast-группах подключенной сети.</p><h3 id="p3.3">3.3 Частные вопросы</h3><h4>3.3.1 Маршрутизация исходящих дейтаграмм</h4><p>Уровень IP выбирает следующий маршрутизатор (next hop) для каждой передаваемой дейтаграммы. Если получатель находится в подключенной сети, дейтаграмма передается на этот хост напрямую; в остальных случаях дейтаграмма направляется маршрутизатору подключенной сети.</p><h5>3.3.1.1 Выбор Local/Remote</h5><p>Для определения принадлежности хоста к подключенной сети должен использоваться следующий алгоритм [см. IP:3]:</p><ul class="lat"><li><p>Адресная маска (применительно к локальному IP-адресу для многодомного хоста) представляет собой 32-битовое значение, позволяющее выбрать поля номеров сети и подсети в адресах IP.</p></li><li><p>Если биты IP-адреса получателя, извлеченные с помощью маски, совпадают с битами IP-адреса отправителя, полученными с такой же маской, это говорит о принадлежности хоста к подключенной сети и дейтаграмма передается напрямую хосту-получателю.</p></li><li><p>Если условие (b) не выполняется, для доставки дейтаграммы должен использоваться шлюз, определяемый в соответствии с требованиями параграфа 3.3.1.2.</p></li></ul><p>Для некоторых специальных случаев используется иной алгоритм:</p><ul class="dot"><li><p>Для групповых и широковещательных адресов ограниченного действия дейтаграммы просто передаются на канальный уровень через соответствующий интерфейс.</p></li><li><p>Для широковещательных дейтаграмм, адресованных всей сети или подсети, могут использоваться стандартные алгоритмы маршрутизации.</p></li></ul><p>IP-уровень хоста должен корректно работать в минимальной сетевой среде (в частности, при отсутствии маршрутизаторов). Если IP-уровень хоста упорно ищет хотя бы один шлюз при инициализации, такой хост не сможет работать в изолированной сети.</p><h5>3.3.1.2 Выбор шлюза</h5><p>Для эффективной маршрутизации группы дейтаграмм одному получателю хост-отправитель должен сохранять кэш маршрутов. Хост использует описанный ниже алгоритм для маршрутизации дейтаграмм с использованием кэша (алгоритм предназначен прежде всего для переноса основного бремени маршрутизации на шлюзы) [RFC816].</p><ul class="dot"><li><p>Если кэш маршрутов не содержит информации для интересующего адреса, хост выбирает принятый по умолчанию шлюз и передает дейтаграмму этому маршрутизатору. Соответствующая запись вносится в кэш маршрутов.</p></li><li><p>Если шлюз не является лучшим путем к адресату, он должен будет переслать дейтаграмму наиболее подходящему маршрутизатору и вернуть хосту-отправителю сообщение ICMP Redirect.</p></li><li><p>Получив сообщение Redirect, хост обновляет шлюз в соответствующей записи кэша для того, чтобы последующие дейтаграммы доставлялись по более эффективному пути.</p></li></ul><p>Поскольку маска сети для адреса получателя в общем случае неизвестна, сообщения Network Redirect должны трактоваться аналогично сообщениям Host Redirect, т.е. запись в кэше для хоста-получателя (и только для него) будет обновляться (или создаваться, если ранее ее не было) с учетом нового шлюза.</p><ul><li class="b">Обсуждение:</li><li class="lib">Эта рекомендация предназначена для защиты от шлюзов, передающих сообщения Network Redirect в сеть с подсетями, в нарушение требований к маршрутизаторам [RFC1009].</li></ul><p>При отсутствии в кэше записи для адреса получателя (если адресат не находится в подключенной сети) уровень IP должен выбрать маршрутизатор из своего списка принятых по умолчанию шлюзов (default gateway). Уровень IP должен поддерживать множество используемых по умолчанию шлюзов.</p><p>В качестве дополнительной возможности уровень IP хоста может реализовать таблицу статических маршрутов (static route). Каждый статический маршрут может включать флаг, определяющий возможность переписывания этого маршрута с помощью ICMP Redirect.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Для начала работы хосту требуется знать по крайней мере один используемый по умолчанию шлюз. Эту информацию можно получить из конфигурационного файла или загрузочного сценария (например, BOOTP — [<a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC1123</a>]).</p><p>Предполагается, что хост может расширять список используемых по умолчанию шлюзов, добавляя в него маршрутизаторы по мере их обнаружения. Например, хост может записывать каждый шлюз, на который пересылает пакеты. Такое решение может оказаться очень эффективным для некоторых случаев, но в иных ситуациях (не все маршрутизаторы одинаковы) оно может порождать проблемы и, поэтому, не рекомендуется.</p><p>Статический маршрут представляет собой отображение хоста или сети на тот или иной следующий маршрутизатор (next-hop gateway); маршрут может также зависеть от типа обслуживания (ToS), рассматриваемого в следующем параграфе. Статические маршруты устанавливаются администратором сети взамен нормальных механизмов автоматической маршрутизации и для обслуживания исключительных ситуаций. Однако, следует помнить, что статические маршруты являются потенциальным источником ошибок при изменении конфигурации или повреждениях оборудования.</p></li></ul><h5>3.3.1.3 Кэш маршрутов</h5><p>Каждая запись в кэше маршрутов должна содержать следующие поля:</p><ol><li>локальный IP-адрес (для многодомных хостов)</li><li>IP-адрес получателя</li><li>тип(ы) обслуживания ToS</li><li>IP-адрес следующего маршрутизатора</li></ol><p>Поле (2) может содержать полный адрес получателя или только адрес сети, в которую тот входит. Поле TOS (3) должно присутствовать в записи.</p><p>Процедуры работы с кэшем маршрутов описаны в параграфе 3.3.4.2.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Включение поля Type-of-Service в кэш маршрутов и его рассмотрение в алгоритме маршрутизации будет обеспечивать механизм для применения в будущем маршрутизации по типу обслуживания в сети Internet (см. параграф 3.2.1.6).</p><p>Каждая запись в кэше определяет конечную точку пути через Internet. Хотя маршрут между двумя точками может динамически изменяться, характеристики пути передачи остаются почти неизменными в течение продолжительного времени для каждого транспортного соединения между парой хостов.</p><p>Следовательно, запись в кэше маршрутов является естественным местом для хранения информации о свойствах пути. Примером такого свойства может служить максимальный размер нефрагментируемой дейтаграммы (см. параграф 3.3.3) или средняя задержка на круговом пути, измеренная транспортным протоколом.</p><p>Эти данные в общем случае собираются и используются протоколами вышележащих уровней (например, TCP) или приложениями, использующими протокол UDP. В настоящее время ведутся эксперименты по кэшированию свойств путейописанным здесь способом.</p><p>Существуют разногласия по вопросу использования ключей для кэша — только адрес получателя или оба адреса (получателя и отправителя). Сторонники использования только адресов получателей приводят следующие аргументы:</p><ol><li><p>В соответствии с требованиями параграфа 3.3.1.2 сообщения Redirect будут порождать записи, ключами к которым являются адреса получателей; простейшая и наиболее общая схема всегда будет использовать адреса хостов.</p></li><li><p>Уровень IP не всегда может знать адресную маску для сети получателя в сложной среде с подсетями.</p></li><li><p>Использование только адресов хостов-получателей позволит применять полные 32-битовые адреса, обеспечивая восприимчивость к изменению архитектуры Internet.</p></li></ol><p>Сторонники использования в качестве ключей адресов отправителей и получателей также приводят свои аргументы:</p><ol><li><p>Экономия памяти.</p></li><li><p>Упрощение структуры данных, простота объединения с таблицами принятых по умолчанию и статических маршрутов (см. ниже).</p></li><li><p>Обеспечивается больше полезного места для хранения информации о свойствах пути, как было упомянуто выше.</p></li></ol></li><li class="b">Реализация</li><li class="lib"><p>Кэш должен быть достаточно велик и обеспечивать возможность включения записей для максимального числа хостов-получателей, которое может использоваться в каждый момент времени.</p><p>Маршрутная запись в кэше может также включать управляющую информацию, используемую для выбора заменяемой записи. Это может быть реализовано, например, в форме бита recently used (недавно использована) или временной метки для последнего обращения. В целях диагностики рекомендуется сохранять время последнего изменения записи.</p><p>При реализации может возникнуть желание снизить издержки на сканирование кэша маршрутов для каждой передаваемой дейтаграммы. Это можно реализовать с помощью хэш-таблицы для ускорения просмотра или путем предоставления ориентированными на соединения протоколами транспортного уровня «советов» или временных указателей на подходящую запись в кэше уровню IP с каждой последовательной дейтаграммой.</p><p>Хотя мы рассматривали здесь кэш маршрутов и список используемых по умолчанию шлюзов по-отдельности, на практике их часто объединяют в одну структуру данных — routing table (таблица маршрутизации).</p></li></ul><h5>3.3.1.4 Обнаружение «мертвых» шлюзов</h5><p>Уровень IP должен обеспечивать возможность обнаружения неработающих маршрутизаторов на следующем интервале (next-hop gateway), включенных в кэш маршрутов, и выбора других маршрутов взамен поврежденных (см. параграф 3.3.1.5).</p><p>Процесс обнаружения сбойных маршрутизаторов детально рассмотрен в [RFC816]. До сегодняшнего дня не разработано полного алгоритма, обеспечивающего эффективное обнаружение сбойных маршрутов, хотя предложен целый ряд методик.</p><ul class="dot"><li><p>Не рекомендуется использовать конкретный маршрутизатор при отсутствии признаков его работоспособности.</p></li><li><p>Активные средства проверки типа ping (т.е., использование сообщений ICMP Echo Request/Reply) слишком накладны и не обеспечивают требуемого масштабирования. В частности, следует отметить, что недопустимо проверять состояние первого маршрутизатора путем непрерывной передачи по его адресу запросов ICMP.</p></li><li><p>Даже при отсутствии других способов проверки состояния маршрутизатора ping следует использовать только в случаях отсутствия подтверждений работы маршрутизатора при передаче ему реального трафика, что позволяет усомниться в работоспособности маршрутизатора.</p></li><li><p>Чтобы избежать использования ping уровни выше и ниже IP должны обеспечивать возможность получения сведений о состоянии пути в кэше маршрутов за счет использования позитивной (маршрутизатор работает) или негативной информации о состоянии шлюза.</p></li></ul><ul><li class="b">Обсуждение:</li><li class="lib"><p>Если реализация не включает адекватного механизма обнаружения неработающих маршрутизаторов, сбой в маршрутизаторе будет приводить к пропаданию пакетов в «черной дыре». Такие ситуации вызывают массу нареканий со стороны пользователей и весьма сложны для обнаружения.</p><p>Механизм обнаружения «мертвых» маршрутизаторов не должен создавать неприемлемой нагрузки на хост, подключенную сеть или соседние маршрутизаторы. Продолжительность детектирования и приемлемый уровень нагрузки в некоторой степени зависят от характера использования хоста, но в общем случае требуется достаточно быстро находить повреждение в ближайшем маршрутизаторе (first-hop gateway), чтобы не нарушалась работа приложений транспортного уровня, не использующих прямых соединений (connections) за время детектирования сбоя и поиска альтернативного пути.</p><p>Передача информации от соседних уровней стека протоколов усложняет интерфейс между уровнями, но может существенно упростить обнаружение сбойных маршрутизаторов. Информация может приходить почти от всех элементов архитектуры IP/TCP, но наиболее важны сведения от транспортного и канального уровней. Ниже приведены примеры такой информации:</p><ul class="dot"><li><p>TCP или другой протокол на основе соединений должен обеспечивать возможность получения негативной информации (например, слишком большое число повторных передач).</p></li><li><p>TCP может давать позитивную информацию после получения (нового) подтверждения о доставке данных. Даже при асимметричном маршруте такое подтверждение свидетельствует об успешной передаче.</p></li><li><p>Сообщения ICMP Redirect от конкретных маршрутизаторов должны использоваться как позитивные сведения о работе шлюза.</p></li><li><p>Информация канального уровня, который способен эффективно детектировать сбои и сообщать о них (например, с помощью сообщений ARPANET Destination Dead), должна использоваться как негативные сведения.</p></li><li><p>Сбои в работе ARP или при проверке отображений (преобразований) ARP могут использоваться как негативная информация для соответствующих адресов IP.</p></li><li><p>Поступление пакетов от конкретного адреса канального уровня является подтверждением работы соответствующего устройства. Однако включение таких данных в сведения о работоспособности шлюзов требует отображения адресов канального уровня в адреса IP и последующей проверки принадлежности этих адресов указанным в кэше маршрутов шлюзам. Такое решение может оказаться недостаточно эффективным.</p></li></ul><p class="note">Отметим, что использование позитивных сведений от каждой полученной дейтаграммы может привести к чрезмерной загрузке системы.</p><p>Сведения могут передаваться с использованием требуемых аргументов во все интерфейсы с IP-уровнем, однако некоторые транспортные и прикладные протоколы не способны генерировать корректные анонсы. Такие интерфейсы, следовательно, должны поддерживать нейтральные сведения, поскольку передача анонса с неверным знаком (позитив — негатив) может привести к некорректной работе системы.</p><p>Существуют (и широко распространен) иной метод определения «мертвых» маршрутизаторов, но его использование не рекомендуется. Этот метод основан на получении хостом (в пассивном режиме wiretapping) дейтаграмм протокола IGP (Interior Gateway Protocol), которыми маршрутизаторы обмениваются между собой с использованием широковещательных адресов. Такое решение имеет существенный недостаток — хосты должны распознавать все протоколы внутренних шлюзов, которые маршрутизатор может использовать (см. [RFC1009]). Кроме того, такой вариант будет работать только в широковещательной сети.</p><p>В настоящее время ping (т. е., использование сообщений ICMP Echo) используется как механизм проверки работоспособности маршрутизаторов только при возникновении абсолютной необходимости. Отклики на ping гарантируют работоспособность проверяемого интерфейса и связанной с ним машины, но они не гарантируют возможности передачи дейтаграмм в другие интерфейсы маршрутизатора. При наличии сообщений Redirect или иных явных признаков того, что машина является шлюзом, отклики на ping будут говорить о том что маршрутизатор успешно выполняет свои функции. Однако отбрасывание хостом без уведомления пакетов, которые маршрутизатор должен пересылать или перенаправлять, может приводить к тому, что такое предположение перестанет быть верным. Чтобы избежать подобных проблем, разрабатывается новый тип сообщений "are you a gateway?" (это маршрутизатор?).</p></li></ul><ul><li class="b">Реализация</li><li class="lib"><p>Для обнаружения «мертвых» маршрутизаторов предлагается следующий алгоритм:</p><ul class="dot"><li><p>Связать таймер «повторной маршрутизации» (reroute timer) с каждым шлюзом, на который указывает запись в кэше маршрутов. При инициализации таймера устанавливается значение Tr, которое должно быть достаточно мало, чтобы можно было обнаружить неработающий маршрутизатор до того, как транспортное соединение будет разорвано по тайм-ауту.</p></li><li><p>Позитивные сведения будут сбрасывать таймер в Tr, а негативные — обнулять таймер.</p></li><li><p>Всякий раз, когда уровень IP используется для маршрутизации дейтаграммы, должно проверяться состояние таймера. Если таймер содержит нулевое значение, уровень IP будет использовать ping для данного шлюза.</p></li><li><p>Пакеты ping (ICMP Echo) можно при необходимости повторять до N раз. Если за N попыток не было получено ни одного отклика, делается вывод о неработоспособности маршрутизатора и в кэше должен указываться новый шлюз для всех записей, указывающих на сбойный маршрутизатор.</p></li></ul><p class="note">Отметим, что значение Tr обратно пропорционально числу возможных анонсов. Значение Tr должно быть достаточно мало, чтобы обеспечить следующие условия:</p><ul class="dot"><li><p>Пакеты ping должны составлять достаточно малую часть (например, &lt;10%) от всех пакетов, передаваемых маршрутизатору с данного хоста.</p></li><li><p>Пакеты ping должны передаваться достаточно редко (например, каждые 3 минуты).</p></li></ul><p>Поскольку описанный алгоритм имеет дело с маршрутизаторами, на которые указывают записи в кэше маршрутов, а не с самими записями, для реализации этого алгоритма желательно использовать двухуровневую структуру кэша (например, по типу кэша ARP).</p></li></ul><h5>3.3.1.5 Выбор нового шлюза</h5><p>Если прекративший работать шлюз не является в настоящий момент используемым по умолчанию, уровень IP может незамедлительно переключиться на работу с принятым по умолчанию маршрутизатором. При сбое в работе установленного по умолчанию шлюза уровень IP должен выбрать другой маршрутизатор для использования по умолчанию (предполагается, что может существовать несколько таких шлюзов) на прекратившем работу пути и организовать новые маршруты.</p><ul><li class="b">Обсуждение:</li><li class="lib">В случае прекращения работы маршрутизатора другие шлюзы подключенной сети узнают об этом с помощью некоторых протоколов обмена информацией между маршрутизаторами. Однако, это не происходит моментально, поскольку протоколы маршрутизации имеют время обмена порядка 30-60 секунд. Если хост переключится на другой маршрут до того, как выбранный маршрутизатор узнает о сбое, этот маршрутизатор может попытаться переслать дейтаграмму вышедшему из строя шлюзу и послать отправителю дейтаграммы сообщение Redirect, указывающее на «мертвый» маршрутизатор (!). В результате этого может начаться процесс автогенерации обновлений кэша маршрутов до того, как маршрутизатор узнает о прекращении работы другого шлюза. Для предотвращения таких ситуаций логика обнаружения «мертвых» маршрутизаторов должна обеспечивать некоторый гистерезис. Однако, на практике упомянутые случаи автогенерации обновлений случаются редко, поскольку обслуживание хоста не может быть восстановлено до тех пор, пока шлюз не организует маршрутную информацию.</li><li class="b">Реализация</li><li class="lib">Одним из вариантов реализации выбора нового маршрута по умолчанию является просто циклический перебор хостом своего списка используемых по умолчанию шлюзов. Другим вариантом является ранжирование маршрутизаторов по уровню приоритета и использование по умолчанию шлюза с максимальным приоритетом. Если в данный момент текущим является маршрутизатор не с высшим приоритетом, хост использует ping (достаточно редкие запросы), чтобы обнаружить восстановление работы маршрутизатора с высшим приоритетом. Частота запросов может быть очень низкой, порядка одного запроса в 3 минуты.</li></ul><h5>3.3.1.6 Инициализация</h5><p>Должна обеспечиваться возможность настройки следующих параметров:</p><ol><li>IP-адреса.</li><li>Маски адресов.</li><li>Список используемых по умолчанию шлюзов с уровнем приоритета для каждого.</li></ol><p>Должна обеспечиваться возможность ручной настройки перечисленных параметров и, кроме того, могут использоваться различные методы динамического определения параметров (см. параграф "Инициализация хоста" в [<a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC1123</a>]).</p><ul><li class="b">Обсуждение:</li><li class="lib">Некоторые реализации хостов прослушивают протоколы маршрутизации в широковещательной сети для обнаружения шлюзов. Стандартный метод определения используемых по умолчанию шлюзов находится в стадии разработки.</li></ul><h4>3.3.2 Сборка (Reassembly)</h4><p>Уровень IP должен обеспечивать сборку фрагментов (reassembly) дейтаграмм IP.</p><p>Будем обозначать максимальный размер дейтаграммы, которая может быть собрана, как EMTU_R (Effective MTU to receive — эффективное значение MTU для приема); иногда используется термин «размер буфера сборки» (reassembly buffer size). Значение EMTU_R должно быть не менее 576 (байтов) и рекомендуется обеспечивать возможность настройки этого значения или использования неограниченного буфера сборки. Кроме того, это значение рекомендуется делать не меньше, чем значение MTU для подключенных сетей.</p><ul><li class="b">Обсуждение:</li><li class="lib">Фиксированное значение предела EMTU_R не должно встраиваться в программный код, поскольку некоторые протоколы прикладного уровня требуют использования EMTU_R > 576.</li><li class="b">Реализация</li><li class="lib"><p>При реализации можно использовать непрерывный буфер сборки для каждой дейтаграммы или применять более сложные структуры данных, позволяющие собирать дейтаграммы неопределенно большого размера; в последнем случае говорят о неограниченном (indefinite) EMTU_R.</p><p>Логически сборка представляет собой просто копирование каждого фрагмента в буфер с использованием указанного смещения. Отметим, что фрагменты дейтаграмм могут перекрываться в результате повторной передачи после нового фрагментирования с сохранением идентификатора.</p><p>Некоторую хитрость при сборке представляет учет для определения момента, когда собраны все фрагменты дейтаграммы. Мы рекомендуем алгоритм Кларка (Clark) [RFC815], не требующий дополнительного пространства памяти для учета. Однако, следует отметить, что в отличие от сказанного в [RFC815], заголовок первого фрагмента должен быть сохранен для включения в возможное сообщение ICMP Time Exceeded (Reassembly Timeout — тайм-аут при сборке).</p></li></ul><p>Должен обеспечиваться механизм, посредством которого транспортный уровень будет определять значение MMS_R — максимальный размер сообщения, которое может быть принято и собрано в дейтаграмму IP (см. функцию GET_MAXSIZES в параграфе 3.4). Если используется неограниченное значение EMTU_R, величина MMS_R определяется как MMS_R = EMTU_R - 20 (минимальный размер заголовка IP).</p><p>Для сборки должно задаваться максимальное время (тайм-аут). Значение тайм-аута рекомендуется делать фиксированным, а не привязывать его к оставшемуся времени жизни (TTL). Рекомендуется устанавливать тайм-аут в диапазоне 60-120 секунд. По истечении заданного времени частично собранные дейтаграммы должны отбрасываться с передачей сообщений ICMP Time Exceeded хосту-отправителю (если получен начальный фрагмент).</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Спецификация IP говорит, что тайм-аут для сборки должен быть равен оставшемуся времени жизни дейтаграммы (TTL) из заголовка IP, но такое решение не работает должным образом, поскольку маршрутизаторы в общем случае трактуют TTL просто как счетчик интервалов, а не время доставки. Если тайм-аут для сборки слишком мал, дейтаграммы будут отбрасываться без нужды, что приведет к излишней загрузке коммуникационных каналов. Значение тайм-аута должно быть не меньше среднего времени доставки пакетов через Internet. Реальная оценка минимального значения тайм-аута для сборки фрагментов составляет 60 секунд.</p><p>Предлагается сохранять в кэше значения времени на передачу дейтаграмм туда и обратно, измеряемые протоколами транспортного уровня, и использовать эти значения для определения величины тайм-аута при сборке. Однако для применения таких методов на практике требуются дополнительные исследования.</p><p>При установке слишком большого значения тайм-аута на принимающем хосте может не хватить выделенного для буферов пространства и время жизни сегмента MSL (Maximum Segment Lifetime) [<a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC793</a>] станет слишком велико. Значение MSL управляет максимальной скоростью, с которой могут передаваться фрагменты дейтаграмм при использовании различных значений 16-битового поля идентификации (увеличение MSL снижает максимальную скорость). Спецификация TCP [<a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC793</a>] предполагает для MSL значение 2 минуты. Эта величина устанавливает верхний предел для тайм-аута при сборке.</p></li></ul><h4>3.3.3 Фрагментация</h4><p>Уровень IP может реализовать механизм преднамеренной фрагментации дейтаграмм.</p><p>Будем обозначать максимальный размер передаваемой дейтаграммы IP для конкретной комбинации отправитель — получатель (и возможно TOS), как EMTU_S (Effective MTU for sending — эффективное значение MTU для передачи).</p><p>Хост должен реализовать механизм, позволяющий транспортному уровню выяснять значение MMS_S (максимальный размер сообщения транспортного уровня, которое может быть передано) для данной комбинации {отправитель, получатель, TOS} (см. функцию GET_MAXSIZES в параграфе 3.4). Если локальной фрагментации не производится, должно выполняться условие:</p><pre>MMS_S = EMTU_S - &lt;размер заголовка IP&gt;</pre><p>и значение EMTU_S не должно быть больше MTU для сетевого интерфейса, соответствующего адресу отправителя дейтаграммы.</p><p>Отметим, что значение &lt;размер заголовка IP&gt; в этом выражении будет равно 20, если IP не резервирует пространство для вставки опций IP в дополнение к опциям, устанавливаемым на транспортном уровне.</p><p>Хост, не реализующий локальную фрагментацию, должен обеспечивать получение транспортным (для TCP) или прикладным (для UDP) уровнем значения MMS_S от уровня IP и передачу дейтаграмм, размер которых не превышает MMS_S.</p><p>В общем случае желательно избегать локальной фрагментации и выбирать значение EMTU_S достаточно небольшим для того, чтобы избежать фрагментации на любом из шлюзов по пути доставки. При отсутствии актуальной информации о минимальном значении MTU для пути уровень IP должен использовать значение EMTU_S &lt;= 576, если получатель не находится в подключенной сети (для этого случая используется принятое в сети значение MTU).</p><p>Значение MTU для каждого физического интерфейса должно быть настраиваемым.</p><p>Реализация уровня IP может использовать флаг конфигурации All-Subnets-MTU (MTU для всех подсетей), показывающий, что значение MTU в подключенной сети будет использоваться и для других подсетей этой сети (но не для других сетей). Таким образом, этот флаг заставляет использовать маску сети взамен маски подсети для выбора значения EMTU_S. Для многодомных хостов флаг All-Subnets-MTU требуется для каждого сетевого интерфейса.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Выбор корректного размера дейтаграмм для передачи данных является сложной задачей [IP:9].</p><ul class="lat"><li>В общем случае от хоста не требуется прием дейтаграмм IP размером более 576 байтов (включая заголовок) и хост не должен передавать дейтаграмм большего размера без предварительного явного согласования с хостом-получателем. Таким образом, MMS_S задает только верхнюю границу размера дейтаграмм, которые может передавать транспортный уровень. Даже при MMS_S > 556 транспортный уровень должен ограничивать свои сообщения размером 556 байтов при отсутствии информации от хоста-получателя о возможности принимать более крупные сообщения.</li><li><p>Некоторые транспортные протоколы (например, TCP) обеспечивают возможность явного уведомления отправителя о максимальном размере дейтаграмм, которые другая сторона может принимать и собирать [RFC879]. На уровне IP подобного механизма не существует.</p><p>Транспортный протокол, предполагающий EMTU_R > 576 (см. параграф 3.3.2), может передавать дейтаграммы большого размера другим хостам, поддерживающим такой же протокол.</p></li><li>В идеальном случае хост должен ограничивать свое значение EMTU_S для данного получателя до минимального значения MTU во всех сетях на пути к получателю во избежание фрагментации. Фрагментация IP, будучи формально корректной, может существенно снижать производительность протокола транспортного уровня, поскольку потеря одного фрагмента будет требовать повторной передачи всех фрагментов сообщения [IP:9].</li></ul><p>Поскольку практически все сети в среде Internet поддерживают MTU=>576, настоятельно рекомендуется использовать значение 576 для дейтаграмм, передаваемых за пределы локальной сети.</p><p>Для определения MTU на данном пути предлагается передавать фрагмент дейтаграммы с нулевым смещением и ожидать отклика ICMP Time Exceeded в результате тайм-аута при сборке (остальные фрагменты не передаются). Такое сообщение будет содержать заголовок самого большого из оставшихся фрагментов в своем теле. Ведутся эксперименты и с более прямыми механизмами, но они еще не адаптированы (см. например RFC 1063).</p></li></ul><h4>3.3.4 Локальные многодомные хосты</h4><h5>3.3.4.1 Введение</h5><p>Многодомный хост имеет множество адресов IP, которые можно рассматривать как логические интерфейсы. Эти интерфейсы могут быть связаны с одним или различными физическими интерфейсами, а последние могут быть соединены с одной или разными сетями.</p><p>Различается несколько вариантов многодомных хостов:</p><ul class="lat"><li><p>Множество логических сетей</p><p>Создатели архитектуры Internet предполагали, что каждая физическая сеть будет иметь уникальный номер IP-сети (или подсети). Однако администраторы локальных сетей иногда считают полезным отказ от такого допущения и организуют в одной физической ЛВС множество логических сетей.</p><p>Если хост, подключенный к такой физической сети, настроен на обслуживание трафика каждой из N различных логических сетей, этот хост будет иметь N логических интерфейсов. Эти интерфейсы могут использовать один или множество физических интерфейсов для подключения к одной физической сети.</p></li><li><p>Множество логических хостов</p><p>Когда хост имеет множество адресов IP с одинаковой сетевой частью (или одинаковым номером подсети), используется понятие логического хоста. Логические интерфейсы хоста могут использовать один или множество физических интерфейсов.</p></li><li><p>Простой вариант</p><p>В этом случае каждый логический интерфейс отображается на отдельный физический интерфейс, подключенный к своей физической сети. Термин «многодомный» изначально относился только к таким хостам, но сейчас толкование термина существенно расширилось.</p><p>Хост со встроенными функциями маршрутизации обычно представляет собой простой вариант многодомного хоста. Отметим, однако, что многодомный хост не обязан поддерживать функций маршрутизации (т. е. он может не реализовать пересылку пакетов из одной подключенной сети в другую).</p><p>Простой многодомный хост представляет наиболее серьезную проблему маршрутизации. Выбор интерфейса (т.е., сети firsthop) может существенно влиять на производительность и даже на доступность удаленных частей Internet.</p></li></ul><p>В заключение отметим также обратный случай (это не многодомный хост), когда один логический интерфейс объединяет несколько физических интерфейсов (например, в целях повышения надежности или пропускной способности за счет организации параллельных каналов передачи данных между двумя точками сети две системы могут быть соединены множеством каналов «точка-точка»). Такой вариант мы будем называть мультиплексированием на канальном уровне. При таком мультиплексировании протоколы, расположенные выше канального уровня, просто не знают о наличии множества физических интерфейсов — драйвер устройства на канальном уровне отвечает за мультиплексирование и маршрутизацию пакетов через разные физические интерфейсы.</p><p>В архитектуре протоколов Internet элемент протокола танспортного уровня не имеет собственного адреса, используя взамен один адрес IP. Это задача уровня IP — обеспечивать интерфейс для транспортного и прикладного уровней. В частности, прикладная программа может знать о множестве адресов IP многодомного хоста и выбирать один из них для своего использования.</p><h5>3.3.4.2 Требования для многодомных хостов</h5><p>Приведенные здесь правила применяются при выборе IP-адреса отправителя для передачи дейтаграмм многодомными хостами.</p><ol><li><p>Если дейтаграмма передается в ответ на принятую дейтаграмму, адрес отправителя должен совпадать с адресом получателя в принятой дейтаграмме. Более подробное описание требования для вышележащих уровней приведено в параграфах 4.1.3.5 и 4.2.3.7, а также в параграфе «Общие вопросы» работы [<a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC1123</a>]. В остальных случаях адрес отправителя можно выбирать.</p></li><li><p>Приложение должно быть способно явно указывать адрес отправителя при организации соединения или запросе.</p></li><li><p>При отсутствии такой спецификации сетевые программы должны выбирать адрес отправителя в соответствии с приведенными ниже правилами.</p></li></ol><p>С многодомными хостами связаны два ключевых вопроса:</p><ul class="ulat"><li><p>Хост может отбрасывать без уведомления входящие дейтаграммы, в которых адрес получателя не соответствует физическому интерфейсу, принявшему дейтаграмму.</p></li><li><p>Хост может ограничить себя передачей дейтаграмм IP (не source-route) только через физический интерфейс, соответствующий IP-адресу отправителя в дейтаграмме.</p></li></ul><ul><li class="b">Обсуждение:</li><li class="lib"><p>Разработчики программ для хостов Internet используют две различных по концепции модели многодомных хостов, кратко рассмотренные ниже. В этом документе не отдается преимущества какой-либо модели — обе имеют свои плюсы и минусы.</p><p>Различия между этими моделями, рассмотренные в (A) и (B), являются опциональными.</p><ul class="dot"><li><p>Модель Strong ES</p><p>Модель Strong ES придает важное значение различиям между хостами и маршрутизаторами (ES/IS) и применительно к ней следует изменить может на должен в пунктах (A) и (B), рассмотренных выше. В этой модели многодомный хост представляется как множество логических хостов в одном физическом компьютере.</p><p>Применительно к (A) сторонники модели Strong ES отмечают, что механизм автоматической маршрутизации Internet не обеспечивает маршрутизации дейтаграмм в физические интерфейсы, которые не соответствуют адресу получателя. В модели Strong ES расчет маршрута для исходящих дейтаграмм представляет собой отображение:</p><pre>маршрут(IP-адрес отправителя, IP-адрес получателя, TOS) -> шлюз</pre><p>Адрес отправителя включен как параметр для того, чтобы выбрать шлюз, напрямую доступный через соответствующий физический интерфейс. Отметим, что эта модель логически требует по крайней мере одного принятого по умолчанию шлюза и предпочитает иметь множество таких шлюзов для каждого IP-адреса отправителя.</p></li><li><p>Модель Weak ES</p><p>В этой модели различия между хостами и маршрутизаторами не считаются существенными и следует использовать недопустимо вместо может для приведенных выше пунктов (A) и (B). Эта модель может быть более естественной для хостов, прослушивающих протоколы маршрутизации, и просто необходима для хостов с поддержкой встроенной маршрутизации.</p><p>Модель Weak ES может приводить к сбоям в работе механизма Redirect. Если дейтаграмма передана физическому интерфейсу, который не соответствует адресу получателя, первый маршрутизатор не сможет понять, когда ему нужно отправить сообщение Redirect. С другой стороны, хост поддерживающий функции маршрутизации, может получать маршрутную информацию без использования сообщений Redirect.</p><p>В модели Weak ES расчет маршрута для исходящих дейтаграмм представляет собой отображение:</p><pre>маршрут(IP-адрес получателя, TOS) -> шлюз, интерфейс</pre></li></ul></li></ul><h5>3.3.4.3 Выбор адреса отправителя</h5><ul><li class="b">Обсуждение:</li><li class="lib"><p>При передаче начального запроса соединения (например, сегмент TCP SYN) или дейтаграммы запроса обслуживания (например, UDP-запрос) транспортный уровень многодомного хоста должен знать, какой адрес отправителя нужно использовать. Если приложение не задало этот адрес, транспортный уровень должен запросить у IP-уровня концептуальное отображение:</p><pre>GET_SRCADDR(удаленный IP-адрес, TOS) -> локальный IP-адрес</pre><p>Значение TOS задает тип обслуживания (см. 3.2.1.6) и результатом является нужный адрес отправителя. Для реализации такого отображения предлагаются следующие правила:</p><ul class="lat"><li><p>Если удаленный адрес Internet относится к одной из (под)сетей, с которыми хост непосредственно соединен, может быть выбран соответствующий адрес отправителя, если нужный интерфейс находится в рабочем состоянии.</p></li><li><p>Можно просмотреть кэш маршрутов для поиска активного маршрута в интересующую сеть через любой сетевой интерфейс. Если такой маршрут найден, можно выбрать локальный адрес IP, соответствующий интерфейсу.</p></li><li><p>Аналогичным образом можно использовать и таблицу статических маршрутов (см. 3.3.1.2).</p></li><li><p>Можно просмотреть список используемых по умолчанию шлюзов. Если такой шлюз связан с другими интерфейсами, можно выбрать шлюз с максимальным приоритетом.</p></li></ul><p>В будущем может быть определен для многодомных хостов способ передачи маршрутизаторам всех подключенных сетей запросов для определения сети, наиболее подходящей для данного получателя.</p></li><li class="b">Реализация</li><li class="lib"><p class="note">Отметим, что описанный процесс по сути совпадает с маршрутизацией дейтаграмм (см. 3.3.1) и, следовательно, хост может объединять реализацию этих функций.</p></li></ul><h4>3.3.5 Пересылка Source Route</h4><p>С учетом приведенных ниже ограничений хост может выступать в качестве промежуточного интервала (intermediate hop) в маршруте source route, пересылая маршрутизируемые отправителем дейтаграммы на следующий указанный хост.</p><p>Однако, при выполнении таких функций квази-маршрутизации хост должен соответствовать всем требованиям, предъявляемым к шлюзам при пересылке дейтаграмм source route [RFC1009]. Эти требования имеют более высокий приоритет, нежели рассмотренные выше требования к хостам.</p><ul class="ulat"><li><p>TTL (см. параграф 3.2.1.7)</p><p>Значение поля TTL должно декрементироваться и дейтаграмма может быть отброшена в соответствии с требованиями к шлюзам [RFC1009].</p></li><li><p>ICMP Destination Unreachable (см. параграф 3.2.2.1)</p><p>Хост должен быть способен генерировать сообщения Destination Unreachable со следующими кодами:</p><ul><li>4 — (Fragmentation Required but DF Set), если дейтаграмма source route не может быть фрагментирована в соответствии с требованиями сети получателя;</li><li>5 — (Source Route Failed), если дейтаграмму source route невозможно переслать (например, из-за проблем с маршрутизацией или в связи с тем, что следующий интервал при строгом задании маршрута — strict source route — не находится в подключенной сети).</li></ul></li><li><p>IP-адрес отправителя (см. параграф 3.2.1.3)</p><p>Маршрутизируемые отправителем дейтаграммы при их пересылке могут иметь (в нормальных условиях имеют) адрес отправителя, который не является одним из IP-адресов пересылающего хоста.</p></li><li><p>Опция Record Route (см. параграф 3.2.1.8d)</p><p>Хост, пересылающий дейтаграммы source route, которые содержат опцию Record Route, должен обновлять значение этого поля, вписываz туда информацию о себе.</p></li><li><p>Опция Timestamp (см. параграф 3.2.1.8e)</p><p>Хост, пересылающий дейтаграммы source route, которые содержат опцию Timestamp, должен добавлять в нее текущую временную метку в соответствии с правилами для этой опции.</p></li></ul><p>Для определения правил, регулирующих работу хостов при пересылке дейтаграмм source route, мы будем использовать термин «локальная обработка» (local source-routing), если следующий шлюз доступен через тот же физический интерфейс, который принял дейтаграмму; в остальных случаях будет использоваться термин «нелокальная обработка» (non-local ource-routing).</p><ul class="dot"><li><p>Хост может выполнять локальную обработку без каких-либо ограничений.</p></li><li><p>Хост, поддерживающий нелокальную обработку, должен иметь конфигурационную опцию, позволяющую запретить пересылку и по умолчанию пересылка должна быть отключена.</p></li><li><p>Хост должен соответствовать всем требованиям к шлюзам в части настройки политики фильтрации ([RFC1009]), ограничивающей нелокальную обработку.</p></li></ul><p>Если хост получает дейтаграмму с незавершенным маршрутом source route, но по тем или иным причинам не пересылает ее, он должен послать сообщение ICMP Destination Unreachable (код 5, Source Route Failed) отправителю дейтаграммы, если сама дейтаграмма не является сообщением ICMP об ошибке.</p><h4>3.3.6 Широковещание</h4><p>В параграфе 3.2.1.3 определены 4 стандартных формы широковещательных адресов IP:</p><ul><li class="b">Limited Broadcast — ограниченная область:</li><li class="lia"><pre>{-1, -1}</pre></li><li class="b">Directed Broadcast — широковещание для сети:</li><li class="lia"><pre>{&lt;Номер сети&gt;,-1}</pre></li><li class="b">Subnet Directed Broadcast — широковещание для подсети:</li><li class="lia"><pre>{&lt;Номер сети&gt;,&lt;Номер подсети&gt;,-1}</pre></li><li class="b">All-Subnets Directed Broadcast — широковещание для всех подсетей:</li><li class="lia"><pre>{&lt;Номер сети&gt;,-1,-1}</pre></li></ul><p>Хост должен распознавать все эти форматы в поле получателя принимаемых дейтаграмм.</p><p>Существует класс хостов, использующих нестандартный формат широковещательных адресов (0 взамен -1). Для всех хостов рекомендуется распознавать и принимать такие нестандартные форматы в полях адреса получателя для входящих дейтаграмм.</p><p>Хост может использовать конфигурационную опцию для выбора формата (0 или -1) на каждом физическом интерфейсе, но по умолчанию должна применяться стандартная форма (-1).</p><p>Когда хост отправляет дейтаграмму по широковещательному адресу канального уровня, IP-адрес получателя должен быть корректным широковещательным или групповым адресом IP.</p><p>Для хостов рекомендуется отбрасывать без уведомления дейтаграммы, полученные в широковещательных кадрах канального уровня (см. 2.4), если в них не указан широковещательный или групповой IP-адрес получателя.</p><p>Для рассылки широковещательных сообщений в подключенные сети рекомендуется использовать адреса формата Limited Broadcast.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Использование формата Limited Broadcast взамен Directed Broadcast может повысить устойчивость системы. Проблемы часто бывают вызваны машинами, которые не понимают до конца природы широковещательных адресов (см. 3.2.1.3) или используют собственные идеи о применении таких адресов. Типичным примером из прошлого являются машины, которые не понимают выделение подсетей, но подключены к сети, содержащей последние. Передача сообщений с адресом Subnet Broadcast для подключенной сети будет приводить к тому, что такие машины воспримут эти сообщения как адресованные другому хосту (не им).</p><p>Существует также вопрос о возможности передачи дейтаграмм с адресом формата Limited Broadcast через все интерфейсы многодомного хоста, однако этот вопрос выходит за пределы документа.</p></li></ul><h4>3.3.7 IP Multicasting</h4><p>Хост должен поддерживать локальное использование групповой адресации (local IP multicasting) для всех подключенных сетей, на которых возможно отображение IP-адресов класса D на адреса канального уровня (см. ниже). Локальная поддержка групповой адресации включает передачу multicast-дейтаграмм, присоединение к multicast-группам, прием multicast-дейтаграмм и выход из multicast-групп. Сюда включается поддержка всех расширений [<a href="../1112.rfc" title="RFC 1112 - Расширение IP Multicasting">RFC1112</a>], за исключением протокола IGMP, поддержка которого не является обязательной.</p><ul><li class="b">Обсуждение:</li><li class="lib">Протокол IGMP обеспечивает шлюзы, поддерживающие маршрутизацию групповых адресов, информацией, требуемой для поддержки групповой адресации IP через множество сетей. В настоящее время multicast-маршрутизация находится в стадии экспериментов и доступна не везде. Для хостов, не подключенных к сетям с multicast-шлюзами, или в тех случаях, когда не нужно принимать multicast-дейтаграммы из других сетей, протокол IGMP не используется, поэтому его реализация не является обязательной. Однако, другие расширения [<a href="../1112.rfc" title="RFC 1112 - Расширение IP Multicasting">RFC1112</a>] в настоящее время рекомендованы в целях обеспечения доступа на уровне IP с локальной групповой адресацией как альтернатива локальной широковещательной адресации. Предполагается, что реализация IGMP тоже станет обязательной в будущем, когда multicast-маршрутизация получит более широкое распространение.</li></ul><p>Если поддержка IGMP не реализована, для хостов рекомендуется сохранять принадлежность к группе all-hosts (все хосты) с адресом 224.0.0.1 при инициализации уровня IP и сохранять принадлежность к этой группе в течение всего периода активности уровня IP.</p><ul><li class="b">Обсуждение:</li><li class="lib">Включение в группу all-hosts будет обеспечивать локальную поддержку групповой адресации (например, протокол обнаружения шлюзов) даже без поддержки IGMP.</li></ul><p>Отображение IP-адресов класса D на локальные адреса в настоящее время стандартизовано для следующих типов сетей:</p><ul class="dot"><li><p>Ethernet/IEEE 802.3 в соответствии с [<a href="../1112.rfc" title="RFC 1112 - Расширение IP Multicasting">RFC1112</a>].</p></li><li><p>Всех сетей, поддерживающих широковещательную, но не групповую адресацию (IP-адреса класса D отображаются на локальный широковещательный адрес).</p></li><li><p>Всех типов каналов «точка-точка» (например, SLIP или HDLC) — в этом случае отображения адресов не требуется. Все групповые дейтаграммы IP передаются в исходном виде, включая локальное кадрирование.</p></li></ul><p>Отображение для сетей других типов будет стандартизовано в будущем.</p><p>Хостам рекомендуется обеспечивать для протоколов верхних уровней или приложений способ определения поддержки групповой адресации IP хостами подключенных сетей.</p><h4>3.3.8 Сообщения об ошибках</h4><p>На практике хосты должны возвращать сообщения ICMP об ошибках при обнаружении последних, за исключением тех случаев, когда возврат сообщений ICMP об ошибках специально запрещен.</p><ul><li class="b">Обсуждение:</li><li class="lib">Общим явлением в сетях на базе дейтаграмм является «болезнь черных дыр» — дейтаграммы передаются адресату, а от того не приходит никаких откликов. При отсутствии откликов обнаружение проблем становится весьма затруднительным.</li></ul><h3 id="p3.4">3.4 Интерфейс между IP и транспортным уровнем</h3><p>Интерфейс между IP и транспортным уровнем должен обеспечивать полный доступ ко всем механизмам уровня IP, включая опции, тип обслуживания TOS и время жизни (TTL). Транспортный уровень должен иметь механизм установки интерфейсных параметров или/и обеспечивать передачу таких параметров от приложений.</p><ul><li class="b">Обсуждение:</li><li class="lib">Для приложений очень важна возможность использования таких параметров, даже если соответствующие механизмы еще недостаточно эффективны в Internet (например, TOS). Реализация поддержки этих механизмов обеспечивает возможность работы с ними без серьезного изменения программных настроек хоста по мере реализации механизмов в Internet.</li></ul><p>Опишем концептуальный интерфейс между транспортным уровнем и IP, как набор процедурных вызовов. Приведенное здесь описание является расширением [<a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC791</a>] (параграф 3.3).</p><ul class="dot"><li><p>Передача дейтаграмм</p><pre>SEND(src, dst, prot, TOS, TTL, BufPTR, len, Id, DF, opt => result)</pre><p>параметры процедуры описаны в <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC 791</a>. Передача параметра Id необязательна (см. 3.2.1.5).</p></li><li><p>Прием дейтаграмм</p><pre>RECV(BufPTR, prot => result, src, dst, SpecDest, TOS, len, opt)</pre><p>Все параметры определены в <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC 791</a>, за исключением SpecDest = указанный адрес получателя дейтаграммы (см. 3.2.1.3).</p><p>Полученный в результате параметр dst содержит адрес получателя дейтаграммы. Поскольку этот адрес может быть широковещательным, должен передаваться параметр SpecDest, не определенный в <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC 791</a>. Параметр opt содержит все опции IP для дейтаграммы и также должен передаваться на транспортный уровень.</p></li><li><p>Выбор адреса отправителя</p><pre>GET_SRCADDR(remote, TOS) -> local remote = remote IP address</pre><ul><li>TOS = тип обслуживания (Type-of-Service)</li><li>local = локальный адрес IP</li></ul><p>См. параграф 3.3.4.3.</p></li><li><p>Определение максимального размера дейтаграмм</p><pre>GET_MAXSIZES(local, remote, TOS) -> MMS_R, MMS_S</pre><ul><li>MMS_R = максимальный размер принимаемого сообщения транспортного уровня.</li><li>MMS_S = максимальный размер передаваемого сообщения транспортного уровня.</li><li>(local, remote, TOS определены выше)</li></ul><p>См. параграфы 3.3.2 и 3.3.3.</p></li><li><p>Сообщение об успешной доставке</p><pre>ADVISE_DELIVPROB(sense, local, remote, TOS)</pre><p>Параметр sense представляет собой 1-битовый флаг, показывающий тип анонса (позитивный или негативный), описанного в параграфе 3.3.1.4. Остальные параметры были определены выше.</p></li><li><p>Передача сообщения ICMP</p><pre>SEND_ICMP(src, dst, TOS, TTL, BufPTR, len, Id, DF, opt) -> result</pre><p>(Параметры определены в <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC 791</a>).</p><p>Передача параметра Id не является обязательной (см. параграф 3.2.1.5). Транспортный уровень должен быть способен передавать некоторые сообщения ICMP Port Unreachable или любой из запросов. Эта функция может рассматриваться как частный случай вызова SEND() и отдельное рассмотрение ее диктуется лишь задачами упрощения.</p></li><li><p>Прием сообщения ICMP</p><pre>RECV_ICMP(BufPTR ) -> result, src, dst, len, opt</pre><p>(Параметры определены в <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC 791</a>).</p><p>Уровень IP должен передавать некоторые сообщения ICMP соответствующим программам транспортного уровня. Эта функция может рассматриваться как частный случай вызова RECV() и указана отдельно лишь для упрощения.</p></li></ul><p>Для сообщений ICMP об ошибках, передаваемых на верхние уровни, данные должны включать исходный заголовок IP и все октеты исходной дейтаграммы, включенные в сообщение ICMP. Эти данные будут использоваться транспортным уровнем для поиска информации о состоянии соединения.</p><p>На верхний уровень передаются, в частности, следующие сообщения:</p><ul class="dot"><li>Destination Unreachable</li><li>Source Quench</li><li>Echo Reply (пользовательскому интерфейсу ICMP, если Echo Request передан не с уровня IP)</li><li>Timestamp Reply (пользовательскому интерфейсу ICMP)</li><li>Time Exceeded</li></ul><ul><li class="b">Обсуждение:</li><li class="lib">В будущем интерфейс обмена данными между транспортным уровнем и IP может быть расширен (см. параграф 3.3.1.3) для передачи информации о пути.</li></ul><h3 id="p3.5">3.5 Требования к уровню INTERNET</h3><table><tr class="b c"><td>Функция</td><td>Параграф</td><td>Требование</td></tr><tr><td>Реализация IP и ICMP</td><td>3.1</td><td>Обязательно</td></tr><tr><td>Обработка remote multihoming на прикладном уровне</td><td>3.1</td><td>Обязательно</td></tr><tr><td>Поддержка local multihoming</td><td>3.1</td><td>Возможно</td></tr><tr><td>Выполнение требований к шлюзам при рассылке дейтаграмм</td><td>3.1</td><td>Обязательно</td></tr><tr class="nbb"><td>Настройка конфигурации для встроенного маршрутизатора</td><td>3.1</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Режим маршрутизатора по умолчанию выключен</td><td>3.1</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Автоматическая настройка по числу интерфейсов</td><td>3.1</td><td>Недопустимо</td></tr><tr><td>Возможность протоколирования отброшенных дейтаграмм</td><td>3.1</td><td>Рекомендуется</td></tr><tr class="nbb"><td>Корректировка счетчиков статистики при отбрасывании</td><td>3.1</td><td>Рекомендуется</td></tr><tr class="nbt"><td>Отбрасывание без уведомления пакетов других (не 4) версий</td><td>3.2.1.1</td><td>Обязательно</td></tr><tr><td>Проверка контрольной сумм и отбрасывание без уведомления при ошибках</td><td>3.2.1.2</td><td>Обязательно</td></tr><tr class="nbb"><td>Адресация:</td><td>3.2.1.3</td><td></td></tr><tr class="nbt"><td class="lia">Адресация подсетей (<a href="../950.rfc" title="RFC 950 - Стандартные процедуры организации подсетей IP">RFC 950</a>)</td><td>3.2.1.3</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Адресом отправителя должен быть собственный адрес хоста</td><td>3.2.1.3</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Отбрасывание без уведомления дейтаграмм с некорректным адресом получателя</td><td>3.2.1.3</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Отбрасывание без уведомления дейтаграмм с некорректным адресом отправителя</td><td>3.2.1.3</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Поддержка сборки фрагментов</td><td>3.2.1.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Сохранение идентификатора для копии дейтаграммы</td><td>3.2.1.4</td><td>Возможно</td></tr><tr class="nbb"><td>TOS:</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Возможность установки TOS на транспортном уровне</td><td>3.2.1.6</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Передача принятых значений TOS на транспортный уровень</td><td>3.2.1.6</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Использование на канальном уровне отображения RFC 795</td><td>3.2.1.6</td><td>Не рекомендуется</td></tr><tr class="nbb"><td>TTL:</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Передача пакетов с TTL=0</td><td>3.2.1.7</td><td>Не допускается</td></tr><tr class="nbt"><td class="lia">Отбрасывание принятых дейтаграмм с TTL &lt; 2</td><td>3.2.1.7</td><td>Не допускается</td></tr><tr class="nbt"><td class="lia">Возможность установки TTL на транспортном уровне</td><td>3.2.1.7</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Возможность установки фиксированного значения TTL</td><td>3.2.1.7</td><td>Обязательно</td></tr><tr class="nbb"><td>Опции IP:</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Возможность транспортного уровня передавать опции</td><td>3.2.1.8</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Передача всех принятых опций на вышележащий уровень</td><td>3.2.1.8</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Игнорирование неизвестных опций на уровне IP</td><td>3.2.1.8</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Опции безопасности</td><td>3.2.1.8a</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Передача идентификатора потока</td><td>3.2.1.8b</td><td>Не рекомендуется</td></tr><tr class="nbt"><td class="lia">Игнорирование опции идентификатора потока</td><td>3.2.1.8c</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Запись маршрутов</td><td>3.2.1.8d</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Временная метка</td><td>3.2.1.8e</td><td>Возможно</td></tr><tr class="nbb"><td>Опция Source Route:</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Инициирование и завершение опции Source Route</td><td>3.2.1.8c</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Дейтаграммы с заполненным SR передаются на транспортный уровень</td><td>3.2.1.8c</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Построение корректного (без избыточности) пути возврата</td><td>3.2.1.8c</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Передача множества опции SR в заголовке</td><td>3.2.1.8c</td><td>Недопустимо</td></tr><tr class="nbb"><td>ICMP:</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Отбрасывание без уведомления неизвестных типов ICMP</td><td>3.2.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Включение более 8 октетов исходной дейтаграммы</td><td>3.2.2</td><td>Возможно</td></tr><tr class="nbt"><td class="lib">Включение полученных октетов</td><td>3.2.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Передача сообщений ICMP Error транспортному ровню</td><td>3.2.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Передача сообщений ICMP с TOS=0</td><td>3.2.2</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Передача сообщений ICMP об ошибках для:</td><td></td><td></td></tr><tr class="nbt"><td class="lib"> — сообщений ICMP об ошибках</td><td>3.2.2</td><td>Недопустимо</td></tr><tr class="nbt"><td class="lib"> — широковещательных и групповых пакетов IP</td><td>3.2.2</td><td>Недопустимо</td></tr><tr class="nbt"><td class="lib"> — широковещательных пакетов канального уровня</td><td>3.2.2</td><td>Недопустимо</td></tr><tr class="nbt"><td class="lib"> — фрагментов, не являющихся первыми</td><td>3.2.2</td><td>Недопустимо</td></tr><tr class="nbt"><td class="lib"> — дейтаграмм с неуникальным адресом отправителя</td><td>3.2.2</td><td>Недопустимо</td></tr></table><table><tr class="nbt"><td class="lia">Возврат сообщений ICMP об ошибках (если не запрещено)</td><td>3.3.8</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Получатель недоступен (destination unreachable):</td><td></td><td></td></tr><tr class="nbt"><td class="lib">Генерация destination unreachable (код 2 и 3)</td><td>3.2.2.1</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lib">Передача destination unreachable на верхние уровни</td><td>3.2.2.1</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Действия верхних уровней для destination unreachable</td><td>3.2.2.1</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lib">Интерпретация dest. unreachable лишь как совета</td><td>3.2.2.1</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Redirect:</td><td></td><td></td></tr><tr class="nbt"><td class="lib">Хост посылает Redirect</td><td>3.2.2.2</td><td>Не рекомендуется</td></tr><tr class="nbt"><td class="lib">Обновление кэша маршрутов при получении Redirect</td><td>3.2.2.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Обслуживание Redirect для хоста и сети</td><td>3.2.2.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lic">Отбрасывание некорректных сообщений Redirect</td><td>3.2.2.2</td><td>Рекомендуется</td></tr><tr class="nbb"><td class="lia">Source Quench:</td><td></td><td></td></tr><tr class="nbt"><td class="lib">Передача Source Quench при нехватке буферов</td><td>3.2.2.3</td><td>Возможно</td></tr><tr class="nbt"><td class="lib">Передача Source Quench на верхний уовень</td><td>3.2.2.3</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Воздейтсвие верхнего уровня на Source Quench</td><td>3.2.2.3</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Передача Time Exceeded на верхний уровень</td><td>3.2.2.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Проблемы с параметрами:</td><td></td><td></td></tr><tr class="nbt"><td class="lib">Передача сообщений Parameter Problem</td><td>3.2.2.5</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lib">Передача Parameter Problem на верхний уровень</td><td>3.2.2.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Передача сообщений Parameter Problem пользователю</td><td>3.2.2.5</td><td>Возможно</td></tr><tr class="nbb"><td class="lia">ICMP Echo Request/Reply:</td><td></td><td></td></tr><tr class="nbt"><td class="lib">Эхо-сервер и эхо-клиент</td><td>3.2.2.6</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Эхо-клиент</td><td>3.2.2.6</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lib">Отбрасывание Echo Request для широковещательных адресов</td><td>3.2.2.6</td><td>Возможно</td></tr><tr class="nbt"><td class="lib">Отбрасывание Echo Request для групповых адресов</td><td>3.2.2.6</td><td>Возможно</td></tr><tr class="nbt"><td class="lib">Использование указанного адреса отправителя в Echo Reply</td><td>3.2.2.6</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Сохранение данных в Echo Reply</td><td>3.2.2.6</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Передача Echo Reply на верхний уровень</td><td>3.2.2.6</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Отражение опций Record Route, Time Stamp</td><td>3.2.2.6</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lib">Инверсия и отражение опции Source Route</td><td>3.2.2.6</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">ICMP Information Request/Reply</td><td>3.2.2.7</td><td>Не рекомендуется</td></tr><tr class="nbt"><td class="lia">ICMP Timestamp/Timestamp Reply:</td><td></td><td>Возможно</td></tr><tr class="nbt"><td class="lib">Минимизация вариаций задержки</td><td>3.2.2.8</td><td>Рекомендуется</td></tr><tr class="nbb"><td class="lib">Отбрасывание без уведомления широковещательных пакетов Timestamp</td><td>3.2.2.8</td><td>Возможно</td></tr><tr class="nbt"><td class="lib">Отбрасывание без уведомления групповых Timestamp</td><td>3.2.2.8</td><td>Возможно</td></tr><tr class="nbt"><td class="lib">Использование указанного адреса как отправителя TS Reply</td><td>3.2.2.8</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Отражение опций Record Route и Timestamp</td><td>3.2.2.8</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lib">Обращение и отражение опции Source Route</td><td>3.2.2.8</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Передача на верхний уровень</td><td>3.2.2.8</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Выполнение правил для «стандартных значений»</td><td>3.2.2.8</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">ICMP Address Mask Request/Reply:</td><td></td><td></td></tr><tr class="nbt"><td class="lib">Настройка источника получения Address Mask</td><td>3.2.2.9</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Поддержка статической конфигурации адресных масок</td><td>3.2.2.9</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Динамическое получение маски при загрузке</td><td>3.2.2.9</td><td>Возможно</td></tr><tr class="nbt"><td class="lib">Получение маски с помощью Addr. Mask Request/Reply</td><td>3.2.2.9</td><td>Возможно</td></tr><tr class="nbt"><td class="lic">Повторная передача запроса при отсутствии отклика</td><td>3.2.2.9</td><td>Обязательно</td></tr><tr class="nbt"><td class="lic">Использование маски по умолчанию при отсутствии отклика</td><td>3.2.2.9</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lid">Обновление маски после получения первого отклика</td><td>3.2.2.9</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Разумная проверка маски</td><td>3.2.2.9</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lib">Неуполномоченная передача откликов Address Mask Reply</td><td>3.2.2.9</td><td>Недопустимо</td></tr><tr class="nbt"><td class="lic">Явное указание уполномоченных агентов</td><td>3.2.2.9</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Статическая конфигурация => флаг Addr-Mask-Authoritative</td><td>3.2.2.9</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lic">Широковещательная передача Addr. Mask Reply при инициализации</td><td>3.2.2.9</td><td>Обязательно</td></tr><tr class="nbb"><td>Маршрутизация исходящих дейтаграмм:</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Использование маски при выборе локальный/удаленный</td><td>3.3.1.1</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Работа с подключенной сетью без шлюза</td><td>3.3.1.1</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Поддержка кэша для ближайших (next-hop) шлюзов</td><td>3.3.1.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Одинаковая трактовка Host/Net Redirect</td><td>3.3.1.2</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Использование шлюза по умолчанию при отсутствии записи в кэше</td><td>3.3.1.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Поддержка множества «шлюзов по умолчанию»</td><td>3.3.1.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Поддержка таблицы статических маршрутов</td><td>3.3.1.2</td><td>Возможно</td></tr><tr class="nbt"><td class="lib">Флаг: возможность переписывания маршрута путем Redirect</td><td>3.3.1.2</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Использование в качестве ключа адреса хоста, а не сети</td><td>3.3.1.3</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Включение TOS в кэш маршрутов</td><td>3.3.1.3</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Возможность обнаружения сбоев в следующем шлюзе</td><td>3.3.1.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Предположение о постоянной доступности маршрута</td><td>3.3.1.4</td><td>Не рекомендуется</td></tr><tr class="nbt"><td class="lia">Непрерывное использование ping для шлюзов</td><td>3.3.1.4</td><td>Недопустимо</td></tr><tr class="nbt"><td class="lia">ping используется только при передаче трафика</td><td>3.3.1.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">ping используется только при отсутствии позитивных анонсов</td><td>3.3.1.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Анонсы от верхних и нижних уровней</td><td>3.3.1.4</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Смена «умершего» шлюза по умолчанию</td><td>3.3.1.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Возможность ввода конфигурационных параметров вручную</td><td>3.3.1.6</td><td>Обязательно</td></tr></table><table><tr class="nbb"><td>Фрагментация и сборка</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Возможность сборки входящих дейтаграмм</td><td>3.3.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">По крайней мере дейтаграммы размером 576 байтов</td><td>3.3.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Настраиваемое или неограниченное значение EMTU_R</td><td>3.3.2</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Возможность транспортного уровня выяснять MMS_R</td><td>3.3.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Передача ICMP Time Exceed при тайм-ауте во время сборки</td><td>3.3.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Фиксированный тайм-аут для сборки</td><td>3.3.2</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Передача MSS_S на верхние уровни</td><td>3.3.3</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Локальная фрагментация исходящих пакетов</td><td>3.3.3</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">или отказ от передачи пакетов > MSS_S</td><td>3.3.3</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Передача не более 576 байтов за пределы сети</td><td>3.3.3</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Конфигурационный флаг All-Subnets-MTU</td><td>3.3.3</td><td>Возможно</td></tr><tr class="nbb"><td>Многодомные хосты:</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Ответ в таким же адресом, как указанный адрес получателя</td><td>3.3.4.2</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Возможность для приложений выбирать локальные адреса IP</td><td>3.3.4.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Отбрасывание дейтаграмм на «некорректном» интерфейсе</td><td>3.3.4.2</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Передача дейтаграмм только через «правильный» интерфейс</td><td>3.3.4.2</td><td>Возможно</td></tr><tr class="nbb"><td>Пересылка SOURCE-ROUTE:</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Пересылка дейтаграмм с опцией Source Route</td><td>3.3.5</td><td>Возможно</td></tr><tr class="nbt"><td class="lib">Выполнение соответствующих правил для шлюзов</td><td>3.3.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lic">Обновление TTL с помощью правил шлюза</td><td>3.3.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lic">Возможность генерации кодов ошибок ICMP 4, 5</td><td>3.3.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lic">IP-адрес отправителя не указывает на локальный хост</td><td>3.3.5</td><td>Возможно</td></tr><tr class="nbt"><td class="lic">Обновление опций Timestamp, Record Route</td><td>3.3.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Настраиваемый переключатель для нелокальных SRing</td><td>3.3.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lic">По умолчанию отключено</td><td>3.3.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Выполнение правил доступа к шлюзу для нелокальных SRing</td><td>3.3.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Если не пересылаем, использовать опцию Dest Unreach (5)</td><td>3.3.5</td><td>Рекомендуется</td></tr><tr class="nbb"><td>Широковещание:</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Широковещательный IP-адрес отправителя</td><td>3.2.1.3</td><td>Недопустимо</td></tr><tr class="nbt"><td class="lia">Нормальный прием широковещательных дейтаграмм форм. 0 и -1</td><td>3.3.6</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Опция передачи широковещ. дейтаграмм форм. 0 и -1</td><td>3.3.6</td><td>Возможно</td></tr><tr class="nbt"><td class="lic">По умолчанию формат -1</td><td>3.3.6</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Распознавание всех форматов широковещательных адресов</td><td>3.3.6</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Использов. групповых/широковещательных адресов IP в широковещ. канального уровня</td><td>3.3.6</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Отбрасывание дейтаграмм только с широковещательным адресом канального уровня</td><td>3.3.6</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Использование адресов Limited Broadcasct для подключенных сетей</td><td>3.3.6</td><td>Рекомендуется</td></tr><tr class="nbb"><td>Групповая адресация:</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Поддержка локальной групповой адресации IP (<a href="../1112.rfc" title="RFC 1112 - Расширение IP Multicasting">RFC 1112</a>)</td><td>3.3.7</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Поддержка IGMP (<a href="../1112.rfc" title="RFC 1112 - Расширение IP Multicasting">RFC 1112</a>)</td><td>3.3.7</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Присоединение группы all-hosts при старте</td><td>3.3.7</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Поддержка интерфейса с верхним уровнем</td><td>3.3.7</td><td>Рекомендуется</td></tr><tr class="nbb"><td>Интерфейс:</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Возможность использовать все механизмы IP на транспортном уровне</td><td>3.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Передача идентификатора интерфейса на транспортный уровень</td><td>3.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Передача всех опций IP на транспортный уровень</td><td>3.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Транспортный уровень может передав. некоторые сообщения ICMP</td><td>3.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Передача заданных сообщений ICMP на транспортный уровень</td><td>3.4</td><td>Обязательно</td></tr><tr class="nbl"><td class="lib">Включение заголовка IP + 8 или более октетов</td><td>3.4</td><td>Обязательно</td></tr></table><h2 id="p4">4. Транспортные протоколы</h2><h3 id="p4.1">4.1 Протокол пользовательских дейтаграмм UDP</h3><h4>4.1.1 Введение</h4><p>Протокол пользовательских дейтаграмм UDP [<a href="../768.rfc" title="RFC 768 - Протокол датаграмм клиента (UDP)">RFC768</a>] обеспечивает лишь минимальный транспортный сервис — негарантированную доставку дейтаграмм — и предоставляет приложениям прямой доступ к службе дейтаграмм уровня IP. UDP используется приложениями, которым не нужен высокий уровень сервиса TCP, или требуемые приложению коммуникационные службы не поддерживаются протоколом TCP (например, групповая или широковещательная адресация).</p><p>Протокол UDP не добавляет почти ничего к службам уровня IP — лишь поддержку контрольных сумм и мультиплексирование по номерам портов. Следовательно, прикладные программы, использующие UDP должны сами решать все задачи сквозного обмена данными, которые обычно обслуживаются протоколами, основанными на соединениях (т. е., обеспечивать повторную передачу при неудачах, управлять потоком данных, контролировать насыщение и т. п). Сложность взаимодействия между IP и TCP заменяется на сложное взаимодействие между UDP и приложениями, использующими протокол UDP.</p><h4>4.1.2 Общие вопросы</h4><p>В спецификации UDP ошибки отсутствуют.</p><h4>4.1.3 Частные вопросы</h4><h5>4.1.3.1 Порты</h5><p>Хорошо известные порты UDP подчиняются тем же правилам, что и хорошо известные порты для протокола TCP (см. параграф 4.2.2.1).</p><p>Если принятая дейтаграмма адресована порту UDP, для которого нет прослушивания (LISTEN), протоколу UDP рекомендуется передать сообщение отправителю ICMP Port Unreachable.</p><h5>4.1.3.2 Опции IP</h5><p>Протокол UDP должен передавать прикладным программам все опции IP, полученные от уровня IP. Приложениям должна предоставляться возможность установки опций IP для передаваемых дейтаграмм UDP и протокол UDP должен передавать эти опции уровню IP.</p><ul><li class="b">Обсуждение:</li><li class="lib">В настоящее время через UDP передаются только опции Source Route, Record Route и Time Stamp. Однако в будущем число таких опций может быть расширено (например, за счет опций безопасности IP) и реализации протокола UDP, поэтому, не должны делать каких-либо предположений о формате или содержимом передаваемых опций.</li></ul><p>Приложениям на основе UDP может потребоваться получение информации source route из дейтаграмм с запросами и установка обратного маршрута в передаваемых откликах.</p><h5>4.1.3.3 Сообщения ICMP</h5><p>Протокол UDP должен передавать на уровень приложений все сообщения ICMP об ошибках, полученные от уровня IP. Для реализации этого может использоваться вызов процедуры ERROR_REPORT (см. 4.2.4.1).</p><ul><li class="b">Обсуждение:</li><li class="lib">Отметим, что сообщения ICMP об ошибках в результате передачи дейтаграмм UDP принимаются асинхронно. Приложения на базе протокола UDP, желающие получать сообщения ICMP об ошибках, сами отвечают за поддержку состояния, которое обеспечит демультиплексирование принятых сообщений (например, программа может сохранять операцию приема незавершенной). Приложения также отвечают за предотвращение конфликтов в результате задержки сообщений ICMP об ошибках по причине занятости портов.</li></ul><h5>4.1.3.4 Контрольные суммы UDP</h5><p>Хост должен поддерживать механизмы генерации и проверки контрольных сумм UDP. Приложения могут управлять процессом генерации контрольных сумм UDP, но по умолчанию протокол должен самостоятельно работать с контрольными суммами. Если принятая дейтаграмма UDP содержит отличную от нуля и некорректную контрольную сумму, протокол UDP должен отбросить такую дейтаграмму без уведомления. Приложения могут управлять решением вопроса об отбрасывании дейтаграмм без контрольной суммы.</p><ul><li class="b">Обсуждение:</li><li class="lib">Некоторые приложения, применяемые преимущественно в локальных сетях, могут отключать использование контрольных сумм UDP в целях повышения производительности. В результате этого может возникать множество ошибок, природа которых не будет определена. Эффективность работы с отключенным механизмом контрольных сумм UDP весьма спорна.</li><li class="b">Реализация</li><li class="lib">В реализации контрольных сумм UDP часто допускают одну и ту же ошибку. В отличие от контрольных сумм TCP контрольные суммы UDP не являются обязательными — нулевое значение поля контрольной суммы в заголовке UDP говорит об отсутствии контрольной суммы. Если отправитель получает для контрольной суммы реальной дейтаграммы UDP нулевое значение, он должен установить в поле контрольной суммы значение 65535 (все биты имеют значение 1). От получателя не требуется в таких случаях каких-либо дополнительных действий, поскольку значения 0 и 65535 эквивалентны с точки зрения арифметики с дополнением до 1.</li></ul><h5>4.1.3.5 Многодомные хосты UDP</h5><p>При получении дейтаграммы UDP указанный адрес получателя должен передаваться на уровень приложений. Прикладные программы должны иметь возможность указывать IP-адрес отправителя при передаче дейтаграмм UDP или оставлять поле адреса пустым (в этих случаях сетевые программы должны указать подходящий адрес отправителя). Рекомендуется обеспечивать способ передачи выбранного адреса отправителя на прикладной уровень, чтобы программа могла позднее получать отклик на дейтаграмму только от соответствующего интерфейса.</p><ul><li class="b">Обсуждение:</li><li class="lib">Приложения на основе запросов/откликов, использующие протокол UDP, должны устанавливать для откликов в качестве адреса отправителя тот же адрес, который был задан для получателя запроса (см. параграф «Общие вопросы» в [<a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC1123</a>]).</li></ul><h5>4.1.3.6 Некорректная адресация</h5><p>Дейтаграммы UDP, принятые с некорректным IP-адресом отправителя (например, широковещательный или групповой адрес) должны отбрасываться на уровне UDP или IP (см. 3.2.1.3).</p><p>Когда хост передает дейтаграмму UDP, в качестве адреса отправителя должен использоваться IP-адрес (один из возможных) этого хоста.</p><h4>4.1.4 Интерфейс между уровнем UDP и прикладным уровнем</h4><p>Интерфейс между приложениями и UDP должен полностью обеспечивать службы, описанные в параграфе 3.4. Таким образом, приложениям на основе UDP требуются функции GET_SRCADDR(), GET_MAXSIZES(), ADVISE_DELIVPROB() и RECV_ICMP(), описанные в 3.4. Например, функция GET_MAXSIZES() может использоваться для определения эффективного значения максимального размера дейтаграмм UDP для конкретной тройки {интерфейс, удаленный хост, TOS}.</p><p>Программы прикладного уровня должны иметь возможность установки значений TTL и TOS, а также опций IP при передаче дейтаграмм UDP и установленные значения должны прозрачно передаваться на уровень IP. UDP может передавать полученные значения TOS на уровень приложений.</p><h4>4.1.5 Требования к протоколу UDP</h4><table><tr class="b c"><td>Функция</td><td>Параграф</td><td>Требование</td></tr><tr><td>UDP передает сообщения Port Unreachable</td><td>4.1.3.1</td><td>Рекомендуется</td></tr><tr class="nbb"><td>Опции IP в UDP</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Передача полученных опций на уровень приложений</td><td>4.1.3.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Приложения могут устанавливать опции при передаче</td><td>4.1.3.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">UDP передает опции на уровень IP</td><td>4.1.3.2</td><td>Обязательно</td></tr><tr><td>Передача сообщений ICMP на прикладной уровень</td><td>4.1.3.3</td><td>Обязательно</td></tr><tr class="nbb"><td>Контрольные суммы UDP:</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Генерация и проверка контрольных сумм</td><td>4.1.3.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Отбрасывание дейтаграмм с ошибкой в контрольной сумме</td><td>4.1.3.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Передача дейтаграмм без контрольной суммы</td><td>4.1.3.4</td><td>Возможно</td></tr><tr class="nbt"><td class="lib">По умолчанию контрольная сумма используется</td><td>4.1.3.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Приемник может требовать контрольную сумму</td><td>4.1.3.4</td><td>Возможно</td></tr><tr class="nbb"><td>Многодомные хосты UDP:</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Передача указанного адреса получателя приложениям</td><td>4.1.3.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Возможность задания локального адреса отправителя на прикладном уровне</td><td>4.1.3.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Возможность задания шаблона локального адреса отправителя на прикладном уровне</td><td>4.1.3.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Уведомление приклад. уровня об используемом локальном адресе</td><td>4.1.3.5</td><td>Возможно</td></tr><tr><td>Дейтаграммы с некорректным IP-адресом отправителя отбрасываются UDP/IP</td><td>4.1.3.6</td><td>Обязательно</td></tr><tr><td>При передаче дейтаграмм используется только корректный. адрес IP</td><td>4.1.3.6</td><td>Обязательно</td></tr><tr class="nbb"><td>Службы интерфейса UDP c приложениями:</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Полный интерфейс IP (см. 3.4) для приложений</td><td>4.1.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Возможность задания TTL, TOS и опций IP при передаче</td><td>4.1.4</td><td>Обязательно</td></tr><tr class="nbl"><td class="lib">Передача принятого TOS на уровень приложений</td><td>4.1.4</td><td>Возможно</td></tr></table><h3 id="p4.2">4.2 Протокол управления передачей — TCP</h3><h4>4.2.1 Введение</h4><p>Протокол управления передачей — TCP (Transmission Control Protocol) [<a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC793</a>] представляет собой транспортный протокол стека Internet для работы с виртуальными соединениями. TCP обеспечивает гарантированную доставку с сохранением порядка для полнодуплексных потоков данных (октеты или байты). Протокол TCP используется теми приложениями, которым нужен ориентированный на соединения транспортный сервис с гарантией доставки (например, электронная почта SMTP, передача файлов по протоколу FTP, служба виртуальных терминалов Telnet); требования к таким протоколам прикладного уровня описаны в работе [<a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC1123</a>].</p><h4>4.2.2 Общие вопросы</h4><h5>4.2.2.1 Хорошо известные (Well-Known) порты: RFC 793, параграф 2.7</h5><ul><li class="b">Обсуждение:</li><li class="lib"><p>TCP резервирует номера от 0 до 255 для хорошо известных портов, которые служат для использования стандартных служб через Internet. Остальные номера портов могут свободно распределяться между прикладными процессами. Текущий список хорошо известных портов можно найти в документе Assigned Numbers [RFC1010]. Предпосылкой задания новых номеров wellknown является подготовка RFC для новой службы, достаточно детально описывающего сервис для обеспечения возможности его реализации.</p><p>Некоторые системы выделяют еще одну область портов TCP — зарезервированные порты, которые обычно используются для системных задач. Например, зарезервированные порты могут занимать номера от 256 до некоторого значения, принятого в данной системе. Некоторые системы используют защиту хорошо известных и зарезервированных портов, позволяя лишь привилегированным пользователям открывать соединения TCP с использованием этих портов. Такая мера весьма разумна, если хост не делает предположений, что другие хосты используют порты с младшими номерами аналогичным образом.</p></li></ul><h5>4.2.2.2 Использование флага Push: RFC 793, параграф 2.8</h5><p>Когда приложение использует серию вызовов SEND без установки флага PUSH, TCP может объединять (агрегировать) данные внутренними средствами, не передавая их. Подобно этому при получении серии сегментов без бита PSH, TCP может помещать данные во внутреннюю очередь без передачи их принимающему приложению.</p><p>Бит PSH не является маркером записи и не связан с границами сегментов. Передатчику рекомендуется удалять (collapse) последовательные биты PSH при пакетировании данных для передачи сегментов максимального размера.</p><p>TCP может реализовать флаги PUSH при вызовах функции SEND. Если флаги PUSH не реализованы, требуется выполнение двух условий при передаче TCP: (1) буфер данных не должен быть бесконечным и (2) должен устанавливаться бит PSH в последнем буферизованном сегменте (т. е., при отсутствии в очереди данных для передачи).</p><p>В <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC 793</a> на страницах 48, 50 и 74 ошибочно указано, что принятый бит PSH должен передаваться прикладному уровню — передача прикладному уровню полученного флага PSH не является обязательной.</p><p>От прикладных программ требуется установка флага PUSH при вызове SEND, если требуется форсировать доставку во избежание простоя соединения. Однако протоколу TCP рекомендуется по возможности передавать сегменты максимального размера в целях повышения производительности (см. 4.2.3.4).</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Когда флаг PUSH не реализован для вызовов функции SEND (т. е., интерфейс между прикладным уровнем и TCP использует потоковую модель в чистом виде), ответственность за объединение небольших фрагментов данных в сегменты разумного размера частично ложится на уровень приложений.</p><p>В общем случае интерактивный прикладной протокол должен устанавливать флаг PUSH по крайней мере при последнем вызове SEND для каждой последовательности команд или откликов. Протоколы, передающие большие объемы данных (типа FTP), должны устанавливать флаг PUSH для последнего сегмента файла или при возникновении необходимости предотвратить «застой» буфера.</p><p>На приемной стороне бит PSH форсирует доставку буферизованных данных прикладной программе (даже при неполном использовании буфера). Отсутствие (снятие) бита PSH может использоваться для предотвращения ненужных обращений к прикладным процессам, что может существенно повысить производительность (особенно важно это для больших хостов с разделением времени). Передача бита PSH принимающей программе позволяет провести аналогичную оптимизацию на прикладном уровне.</p></li></ul><h5>4.2.2.3 Размер окна: RFC 793, параграф 3.1</h5><p>Размер окна должен трактоваться как беззнаковое целое — если большое окно будет представляться как окно с отрицательным размером, TCP просто не будет работать. Рекомендуется использовать 32-битовые поля для размера окна передачи и приема в записи с параметрами соединения.</p><ul><li class="b">Обсуждение:</li><li class="lib">Известно, что поле размера окна в заголовке TCP слишком мало для высоких скоростей и путей с большой задержкой. Для расширения окна TCP определены экспериментальные опции (см. например, [RFC1072]). С учетом такого расширения при реализации TCP следует рассчитывать на 32-битовые значения размера окна.</li></ul><h5>4.2.2.4 Указатель срочности: RFC 793, параграф 3.1</h5><p>Второе предложение этого параграфа содержит ошибку — urgent pointer указывает на порядковый номер последнего (а не следующего за ним) октета в последовательности срочных (urgent) данных. Описание на стр. 56 (последнее предложение) корректно.</p><p>Протокол TCP должен поддерживать последовательности срочных данных любой длины.</p><p>Протокол TCP должен информировать прикладной уровень в асинхронном режиме всякий раз, если указатель Urgent получен при отсутствии ожидающих обработки срочных данных или Urgent упреждает срочные данные в потоке. Для приложений должен обеспечиваться способ определения количества остающихся срочных данных, которые будут прочитаны из соединения, или, по крайней мере, возможность узнать о наличии таких данных.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Хотя механизм Urgent может использоваться для любых приложений, обычно он применяется для передачи «прерываний» типа команд Telnet (см. параграф Using Telnet Synch Sequence в [<a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">RFC1123</a>]).</p><p>Асинхронное уведомление за пределами основного канала (out-of-band) будет позволять приложениям перейти в режим urgent при чтении данных из соединения TCP. Это позволяет контролировать команды, передаваемые приложению, нормальный буфер которого заполнен необработанными данными.</p></li><li class="b">Реализация</li><li class="lib">Базовый механизм ERROR-REPORT(), описанный в параграфе 4.2.4.1 может использоваться для информирования приложений о приходе важных данных.</li></ul><h5>4.2.2.5 Опции TCP: RFC 793, параграф 3.1</h5><p>Протокол TCP должен обеспечивать возможность получения опций TCP в любом сегменте. Протокол TCP должен игнорировать без генерации ошибки любые опции TCP, которые в нем не реализованы, предполагая, что опции содержат поле длины (все определяемые в будущем опции TCP будут также содержать поле длины). Протокол TCP должен быть готов к обработке опций некорректного (например, нулевого) размера без возникновения серьезных проблем — одним из вариантов такой обработки является сброс (reset) соединения и протоколирование причины.</p><h5>4.2.2.6 Максимальный размер сегмента: RFC 793, параграф 3.1</h5><p>Протокол TCP должен поддерживать опции максимального размера сегмента — MSS для приема и передачи [RFC879]. Для TCP рекомендуется передавать опцию MSS в каждом сегменте SYN при получении MSS, отличного от принятого по умолчанию значения 536; можно передавать эту опцию во всех случаях.</p><p>Если опция MSS не получена при организации соединения, протокол TCP должен использовать принятое по умолчанию значение MSS = 536 (576-40) [RFC879].</p><p>Максимальный размер сегмента, реально передаваемого TCP — эффективное значение MSS для передачи должно быть меньше MSS для передачи (отражает доступный размер буфера сборки на удаленном хосте) и максимального размера, поддерживаемого уровнем IP:</p><pre>Eff.snd.MSS =

   min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize</pre><p>где:</p><ul class="dot"><li>SendMSS — значение MSS, полученное от удаленного хоста или принятое по умолчанию значение 536. если опция MSS не была получена.</li><li>MMS_S — максимальный размер сообщений транспортного уровня, которые может передавать TCP.</li><li>TCPhdrsize — размер заголовка TCP (обычно 20, но может быть больше за счет опций TCP).</li><li>IPoptionsize — размер всех опций IP, которые TCP будет передавать на уровень IP с этим сообщением.</li></ul><p>Значение MSS, которое будет передано в опции MSS, не должно быть больше</p><pre>MMS_R - 20</pre><p>где MMS_R — максимальный размер для сообщений транспортного уровня, которые могут быть приняты (и собраны); TCP получает значения MMS_R и MMS_S от уровня IP (см. описание функции GET_MAXSIZES в 3.4).</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Размер сегмента TCP оказывает существенное влияние на производительность. Увеличение сегментов повышает пропускную способность за счет снижения объема заголовков в общем потоке данных и уменьшения времени на обработку этих заголовков. Однако, если пакеты столь велики, что требуется фрагментация IP, эффективность существенно снижается при потере любого фрагмента [IP:9].</p><p>Некоторые реализации TCP передают опцию MSS только в тех случаях, когда хост-получатель относится к подключенной сети. Однако в общем случае уровень TCP может не иметь достаточно информации для определения такой принадлежности, поэтому разумно передать уровню IP решение вопроса определения приемлемого значения MTU для пути Internet.</p><p>Рекомендуется использовать опцию MSS во всех случаях, когда значение отличается от 536 (тогда уровень IP определяет MMS_R в соответствии с параграфами 3.3.3 и 3.4). Предлагаемые для уровня IP механизмы определения MTU в этом случае не будут оказывать влияния на TCP.</p></li></ul><h5>4.2.2.7 Контрольная сумма TCP: RFC 793, параграф 3.1</h5><p>В отличие от контрольных сумм UDP (см. 4.1.3.4) контрольные суммы TCP использовать обязательно. Отправитель должен генерировать контрольную сумму, а получатель должен ее проверять.</p><h5>4.2.2.8 Диаграмма состояния соединения TCP: RFC 793 параграф 3.2, стр. 23</h5><p>С диаграммами состояния связано несколько проблем:</p><ul class="dot"><li><p>Стрелка от SYN-SENT к SYN-RCVD должна помечаться snd SYN,ACK, в соответствии с текстом на стр. 68 и рисунком 8.</p></li><li><p>Возможна стрелка от состояния SYN-RCVD к состоянию LISTEN при условии получения RST после пассивного открытия (см. стр 70 в <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC 793</a>).</p></li><li><p>Возможно прямо перейти из FIN-WAIT-1 в состояние TIME-WAIT (см. стр. 75 в <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC 793</a>).</p></li></ul><h5>4.2.2.9 Выбор начального порядкового номера: RFC 793, параграф 3.3, стр. 27</h5><p>Протокол TCP должен использовать начальный порядковый номер, генерируемый в соответствии с текущим временем.</p><h5>4.2.2.10 Число последовательных попыток открытия: RFC 793, параграф 3.4, стр. 32</h5><p>На рисунке 8 допущена ошибка — пакет в строке 7 должен быть идентичен пакету в строке 5.</p><p>Протокол TCP должен поддерживать одновременные попытки организации соединения.</p><ul><li class="b">Обсуждение:</li><li class="lib">Разработчики иногда удивляются, увидев, что при попытке двух приложений одновременно соединиться друг с другом организуется только одно соединение. Это не ошибка, а преднамеренное действие, поэтому не пытайтесь «исправить» ситуацию.</li></ul><h5>4.2.2.11 Восстановление по старым дубликатам SYN: RFC 793, параграф 3.4, стр. 33</h5><p>Отметим, что реализации TCP должны сохранять информацию о соединениях, достигших состояния SYN_RCVD в результате пассивного или активного использования OPEN.</p><h5>4.2.2.12 Сегмент RST: RFC 793, параграф 3.4</h5><p>Для протокола TCP рекомендуется допускать прием сегментов RST, содержащих данные.</p><ul><li class="b">Обсуждение:</li><li class="lib">Предлагается включать в сегменты RST текст в формате ASCII, содержащий код и объяснение причины RST. Стандарта для представления таких данных еще не разработано.</li></ul><h5>4.2.2.13 Завершение соединений: RFC 793, параграф 3.5</h5><p>Соединения TCP могут завершаться двумя способами: (1) нормальная процедура завершения TCP с использованием FIN и (2) "прерывание" в результате передачи одного или нескольких сегментов RST, приводящих к немедленному закрытию соединения. Если соединение TCP закрыто удаленной стороной, локальное приложение должно получить информацию об использованном варианте завершения (1 или 2).</p><p>При нормальном завершении соединений TCP обеспечивается гарантированная доставка данных в обоих направлениях. Поскольку оба направления соединений TCP закрываются независимо, возможно существование «полузакрытых» соединений, когда передача данных в одном направлении завершена (и невозможна), а в другом данные продолжают передаваться.</p><p>Хост может реализовать «полудуплексные» последовательности закрытия TCP так, что приложение, вызвавшее функцию CLOSE, не сможет после этого читать данные из соединения. Если такой хост вызывает CLOSE в процессе приема данных через соединение TCP или новые данные получены уже после вызова CLOSE, протоколу TCP рекомендуется передать сегмент RST для информирования о потере данных.</p><p>При активном закрытии соединения оно должно сохраняться в состоянии TIME-WAIT (ожидание) в течение времени 2 x MSL. Однако возможно восприятие новых вызовов SYN от удаленного TCP для повторного открытия соединения непосредственно из состояния TIME-WAIT, если выполняются следующие условия:</p><ol><li>начальный порядковый номер для нового соединения больше максимального порядкового номера, использованного в предыдущем соединении;</li><li>происходит возврат в состояние TIME-WAIT, если SYN оказывается дубликатом старого вызова.</li></ol><ul><li class="b">Обсуждение:</li><li class="lib"><p>Полнодуплексное завершение соединений TCP для сохранения данных не включено в аналогичный транспортный протокол TP4 стека ISO.</p><p>Некоторые системы не поддерживают полузакрытых соединений, поскольку такие соединения не согласуются с моделью ввода-вывода используемой операционной системы. В таких системах приложение после вызова CLOSE уже не сможет читать данные из соединения — такая ситуация называется полудуплексным завершением сеанса TCP.</p><p>Изящный алгоритм завершения TCP требует, чтобы активное состояние сохранялось (по крайней мере) на одной из сторон в течение времени 2 x MSL (4 минуты). В течение этого периода пара (удаленный сокет, локальный сокет), определяющая  соединение, остается занятой и не может быть повторно использована. Для сокращения периода занятости данной пары портов некоторые реализации TCP позволяют воспринимать новые вызовы SYN в состоянии TIME-WAIT.</p></li></ul><h5>4.2.2.14 Передача данных: RFC 793, параграф 3.7, стр. 40</h5><p>С момента выхода <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC 793</a> алгоритмы TCP постоянно совершенствовались для повышения эффективности обмена данными. В последующих параграфах этого документа описаны обязательные и рекомендуемые алгоритмы TCP, позволяющие определить, когда следует передавать данные (4.2.3.4) и подтверждения (4.2.3.2) или обновлять окно (4.2.3.3).</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Одним из важных вопросов производительности является «синдром глупого окна» (Silly Window Syndrome или SWS), описанный в [RFC813] — стабильное небольшое увеличение окна, в результате которого происходит существенное снижение производительности TCP. Алгоритмы предотвращения SWS описаны ниже как для передающей (4.2.3.4), так и для приемной стороны (4.2.3.3).</p><p>Кратко говоря, причиной SWS является получение информации о расширении окна вправо всякий раз, когда есть буферное пространство, доступное для приема данных, и отправитель использует увеличение окна (невзирая на его незначительность) для передачи большего объема данных [RFC813]. Результатом этого может стать непрерывная передача крошечных сегментов даже при наличии больших буферов на приемной и передающей стороне. SWS может возникать только при передаче больших объемов данных; если соединение стабильно (передается постоянный поток данных), проблема исчезает. Причиной проблемы является типичная реализация прямого (straightforward) управления окном — ниже описаны алгоритмы для получателя и отправителя, позволяющие решить эту проблему.</p><p>Другим важным вопросом производительности TCP является то, что некоторые приложения (особенно системы удаленного входа в систему) на хостах с посимвольным вводом имеют тенденцию передавать потоки однооктетных сегментов данных. Во избежание застоя каждый вызов TCP SEND от таких приложений должен «выталкиваться» (push) приложением явно или в неявной форме с помощью TCP. В результате может возникнуть поток сегментов TCP, содержащих лишь по одному октету, что ведет к снижению эффективности использования Internet и вносит существенный вклад в насыщение. Алгоритм Nagle, описанный в параграфе 4.2.3.4, обеспечивает простое и эффективное решение этой проблемы. Алгоритм обеспечивает группировку символов для соединений Telnet (это может удивить пользователей, ожидающих эхо после каждого символа, но восприятие пользователей не является проблемой).</p><p>Отметим, что алгоритм Nagle и алгоритм предотвращения SWS дополняют друг друга в деле повышения производительности. Алгоритм Nagle предотвращает передачу крошечных сегментов, которая может приводить к незначительному постоянному расширению окна, а алгоритм предотвращения SWS блокирует появление мелких сегментов в результате незначительных сдвигов правого края окна в сторону расширения.</p><p>В осторожных реализациях может передаваться два или более подтверждений для каждого принятого сегмента. Предположим для примера, что получатель незамедлительно подтверждает прием каждого сегмента. Когда прикладная программа «потребит» данные и снова увеличит доступное пространство в буфере приема, получатель может передать второе подтверждение отправителю для обновления окна. Экстремальная ситуация возникает при 1-октетных сегментах в соединениях TCP, использующих протокол Telnet для удаленного входа в систему. Встречаются реализации, где на каждое нажатие клавиши пользователем генерируется три передаваемых в ответ сегмента: (1) подтверждение, (2) однобайтовое расширение окна и (3) эхо-символ.</p></li></ul><h5>4.2.2.15 Тайм-аут повторной передачи: RFC 793, параграф 3.7, стр. 41</h5><p>Сейчас известно, что предложенный в <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC 793</a> алгоритм расчета тайм-аута для повторной передачи не является адекватным (см параграф 4.2.3.1).</p><p>Недавняя работа Якобсона [TCP:7] по вопросам насыщения Internet и стабильности повторной передачи TCP предлагает новый алгоритм, объединяющий механизмы slow start (медленный старт) и congestion avoidance (предотвращение насыщения). Протокол TCP должен реализовать эти алгоритмы.</p><p>Если повторный пакет идентичен исходному (сохранены не только границы данных, но также окно и поля подтверждения в заголовке), можно использовать прежнее значение поля идентификации IP (см. 3.2.1.5).</p><ul><li class="b">Реализация</li><li class="lib"><p>Некоторые разработчики TCP выбирают «пакетированный» поток данных, т. е., указывают границы сегмента при передаче в очередь и держат эти границы в очереди на повторную передачу, пока не будет получено подтверждение. В других вариантах (они могут быть проще) пакетирование не происходит до завершения передачи (или повторной передачи), поэтому очередь на повторную передачу в таких реализациях не используется.</p><p>В варианте с очередью на повторную передачу производительность TCP может быть повышена за счет повторного пакетирования для сегментов, ожидающих подтверждения при первом тайм-ауте повторной передачи. Оставшиеся сегменты будут объединяться в один сегмент максимального размера с новым идентификатором IP. После этого TCP будет держать новый сегмент в очереди на передачу, пока не будет получено подтверждение. Однако, если первые два сегмента в очереди на повторную передачу превышают максимальный размер сегмента, TCP будет повторять передачу только для первого сегмента из очереди с сохранением идентификационного поля IP.</p></li></ul><h5>4.2.2.16 Управление окном: RFC 793, параграф 3.7, стр. 41</h5><p>Получателям TCP не рекомендуется отсекать часть окна (т. е., перемещать правый край окна влево). Однако отправитель TCP должен быть устойчивым к уменьшению окна, при котором значение "useable window" (см. 4.2.3.4) становится отрицательным.</p><p>Если такое происходит, отправителю не рекомендуется передавать новые данные, но следует повторить передачу неподтвержденных данных между SND.UNA и SND.UNA+SND.WND. Отправитель также может повторить передачу данных за пределами SND.UNA+SND.WND, но не рекомендуется прерывать соединение по тайм-ауту, если доставка данных за пределами правого края окна не подтверждена. Если окно сокращается до нуля, протокол TCP должен проверить его стандартным способом (см. ниже).</p><ul><li class="b">Обсуждение:</li><li class="lib">Во многих реализациях TCP возникают проблемы при сокращении окна справа после передачи данных в окно большего размера. Отметим, что TCP использует эвристические методы для выбора последнего обновления окна вопреки возможному изменению порядка дейтаграмм. В результате может быть проигнорировано обновление окна на меньшее, которое было предложено ранее, если не увеличивается ни порядковый номер, ни номер подтверждения.</li></ul><h5>4.2.2.17 Проверка нулевого окна: RFC 793, параграф 3.7, стр. 42</h5><p>Должна поддерживаться проверка нулевого (предлагаемого) окна.</p><p>TCP может сохранять свои предлагаемые приемные окна закрытыми в течение неопределенного времени. До тех пор, пока TCP на приемной стороне продолжает слать подтверждения в ответ на проверочные (probe) сегменты, протокол TCP на передающей стороне должен сохранять соединение открытым.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Очень важно помнить, что сегменты ACK (подтверждение), которые не содержат данных, передаются протоколом TCP без гарантий. Если проверка нулевого окна не поддерживается, соединение может быть разорвано при потере сегмента ACK, заново открывающего окно.</p><p>Задержка при открытии нулевого окна обычно происходит в тех случаях, когда принимающее приложение останавливает обмен данными с со своим TCP. Например, демон печати может остановить работу при отсутствии в принтере бумаги.</p></li></ul><p>Передающему хосту рекомендуется посылать первую пробу нулевого окна, когда такое окно существовало в течение периода, равного тайм-ауту для передачи (см. 4.2.2.15); интервалы передачи последующих проб рекомендуется экспоненциально увеличивать.</p><ul><li class="b">Обсуждение:</li><li class="lib">Эта процедура минимизирует задержку, если условие нулевого окна возникает в результате потери сегмента ACK, содержащего обновление открытия окна. Рекомендуется экспоненциальное увеличение интервала (возможно с заданием максимального значения). Эта процедура напоминает алгоритм повтора передачи и реализацию этих процессов можно объединить.</li></ul><h5>4.2.2.18 Пассивные вызовы OPEN: RFC 793, параграф 3.8</h5><p>Каждый пассивный вызов OPEN создает новую запись о соединении в состоянии LISTEN или возвращает ошибку — это не должно оказывать влияния на любые ранее созданные записи соединений.</p><p>Реализации TCP, поддерживающие множество пользователей одновременно, должны обеспечивать вызовы OPEN, функционально позволяющие приложениям прослушивать (LISTEN) порт, пока не будет блокировано соединение с таким же номером локального порта в состоянии SYN-SENT или SYN-RECEIVED.</p><ul><li class="b">Обсуждение:</li><li class="lib">Некоторые приложения (например, серверы SMTP) могут требовать обслуживания множества одновременных попыток организации соединения. Вероятность отказа при таких попытках может быть снижена за счет предоставления программе возможности прослушивания соединения одновременно с попыткой согласования параметров для ранее организованного соединения.</li><li class="b">Реализация</li><li class="lib">Приемлемые реализации одновременных попыток соединения могут разрешать множество открытых пассивных вызовов OPEN или «клонирование» соединений в состоянии LISTEN из одного пассивного вызова OPEN.</li></ul><h5>4.2.2.19 Время жизни: RFC 793, параграф 3.9, стр. 51</h5><p>В <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC 793</a> указано, что TCP будет запрашивать у IP-уровня передачу сегментов TCP со значением TTL = 60. Это требование устарело и значение TTL для передачи сегментов TCP должно быть настраиваемым (см. 3.2.1.7).</p><h5>4.2.2.20 Обработка событий: RFC 793, параграф 3.9</h5><p>Хоть это и не является обязательным, рекомендуется для TCP поддерживать очереди с нарушением порядка сегментов TCP (в <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC 793</a> на стр. 70 сказано возможно).</p><ul><li class="b">Обсуждение:</li><li class="lib">Некоторые реализации для небольших хостов не используют очереди сегментов по причине ограниченности буферного пространства. Такое решение может привести к существенному снижению производительности TCP, поскольку потеря единственного сегмента приведет к тому, что все последующие сегменты будут доставляться с нарушением порядка.</li></ul><p>В общем случае обработка принятых сегментов должна быть построена так, чтобы сегменты ACK по возможности объединялись. Например, если TCP обрабатывает группу сегментов из очереди, передача сегмента ACK должна происходить только после обработки всех таких сегментов.</p><p>Ниже приведены некоторые поправки к параграфу «Обработка событий» в <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC 793</a>.</p><ul class="lat"><li><p>Вызов CLOSE, состояние CLOSE-WAIT (стр. 61): следует читать LAST-ACK взамен CLOSING.</p></li><li><p>Состояние LISTEN, проверка SYN (стр. 65, 66): При наличии бита SYN передача сбрасывается, если для сегмента некорректны значения security/compartment или precedence. В документе допущена ошибка. Правильная команда сброса показана ниже:</p><pre>&lt;SEQ=0&gt;&lt;ACK=SEG.SEQ+SEG.LEN&gt;&lt;CTL=RST,ACK&gt;</pre><p>Состояние SYN-SENT, проверка SYN (стр. 68): При переходе соединения в состояние ESTABLISHED должны быть установлены следующие переменные:</p><pre>SND.WND &lt;- SEG.WND
SND.WL1 &lt;- SEG.SEQ
SND.WL2 &lt;- SEG.ACK</pre></li><li><p>check security and precedence (стр. 71): Первый заголовок ESTABLISHED STATE реально должен быть списком всех состояний, кроме SYN-RECEIVED — ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIMEWAIT.</p></li><li><p>Вместо check the SYN bit (стр. 71) следует читать "In SYN-RECEIVED state and if the connection was initiated with a passive OPEN, then return this connection to the LISTEN state and return. Otherwise check the SYN bit".</p></li><li><p>Check ACK field, SYN-RECEIVED state (стр. 72: При переходе соединения в состояние ESTABLISHED должны быть установлены переменные, указанные в п. (c).</p></li><li><p>Check ACK field, ESTABLISHED state (стр. 72): The ACK is a duplicate if SEG.ACK =&lt; SND.UNA (знак = пропущен).</p><p>Аналогичный пропуск в условии обновления окна — должно быть:</p><pre>SND.UNA =&lt;SEG.ACK =&lt; SND.NXT</pre></li><li><p>USER TIMEOUT (стр. 77):</p><p>Лучше будет уведомлять приложение о тайм-ауте, а не о разрешении TCP закрыть соединение (см. также параграф 4.2.3.5).</p></li></ul><h5>4.2.2.21 Подтверждение для сегментов из очереди: RFC 793, параграф 3.9</h5><p>TCP может передавать сегмент ACK, подтверждающий RCV.NXT, когда приходит корректный сегмент, который находится в окне, но не на его левой границе.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>В <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC 793</a> (стр. 74) нет ясности по вопросу передачи сегмента ACK при получении сегментов с нарушением порядка (т. е., SEG.SEQ не равно RCV.NXT).</p><p>Одной из причин передачи подтверждений для сегментов с нарушением порядка доставки может быть поддержка экспериментального алгоритма, названного fast retransmit (быстрая повторная передача). При использовании этого алгоритма отправитель передает избыточные подтверждения ACK для указания потери сегмента до истечения тайм-аута повторной  передачи. Подсчитывается число полученных подтверждений ACK с одинаковым значением SEG.ACK и одинаковой правой границей окна. При получении большего числа ACK, нежели заданное пороговое значение, предполагается потеря сегмента, начинающегося с SEG.ACK и выполняется повторная передача без ожидания тайм-аута. Пороговое значение выбирается таким образом, чтобы компенсировать максимальное разупорядочивание сегментов в Internet. Использование этого алгоритма пока слишком непродолжительно, чтобы сделать выводы о его полезности.</p></li></ul><h4>4.2.3 Частные вопросы</h4><h5>4.2.3.1 Расчет тайм-аута для повторной передачи</h5><p>Хост TCP должен поддерживать алгоритмы Karn и Jacobson для расчета тайм-аута повторной передачи RTO.</p><ul class="dot"><li><p>Алгоритм Jacobson для расчета взвешенного времени кругового обхода (RTT) включает простое измерение вариаций [TCP:7].</p></li><li><p>Алгоритм Karn для выбора способа измерения RTT гарантирует, что случайные значения времени кругового обхода не будут уничтожать результат расчета взвешенного времени обхода [TCP:6].</p></li></ul><p>Такая реализация должна также включать экспоненциальный рост последовательных значений RTO для одного сегмента. Для повторной передачи сегментов SYN рекомендуется использовать такой же алгоритм, как для сегментов данных.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Известны две проблемы, связанные с расчетом RTO, описанным в <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC 793</a>. Во-первых, при наличии повторов точное измерение RTT становится затруднительным. Во-вторых, алгоритм расчета взвешенного времени кругового обхода неадекватен [TCP:7], поскольку использует некорректное предположение о малости и постоянстве вариаций RTT. Для решения этих проблем используются алгоритмы Karn и Jacobson, соответственно.</p><p>Повышение производительности в результате использования этих алгоритмов может колебаться от незначительного до гигантского. Алгоритм Jacobson для включения вариаций измеренных значений RTT особенно важен для низкоскоростных каналов, где естественные вариации размера пакетов приводят к значительным вариациям RTT. Один из разработчиков отметил рост эффективности использования канала 9.6 кбит/с с 10% до 90% в результате реализации алгоритма Jacobson для TCP.</p></li></ul><p>Для инициализации оценочных параметров новых соединений рекомендуется использовать значения:</p><ul><li>RTT = 0 секунд.</li><li>RTO = 3 секунды (взвешенные вариации инициализируются значением, которое будет влиять на RTO).</li></ul><p>Известно, что рекомендованные значения верхней и нижней границ RTO неадекватны для больших сетей. Рекомендуется задавать нижнюю границу в долях секунды (для работы со скоростными ЛВС), а в качестве верхней границы использовать значение 2*MSL (240 секунд).</p><ul><li class="b">Обсуждение:</li><li class="lib">Опыт показывает, что приведенные выше параметры инициализации имеют разумные значения, а использование алгоритмов Karn и Jacobson делает поведение TCP разумным, независимо от выбора начальных параметров.</li></ul><h5>4.2.3.2 Когда передавать сегмент ACK</h5><p>Хост, получающий поток сегментов данных TCP, может повысить эффективность работы (хостов и Internet) за счет передачи меньшего числа подтверждений ACK для принятых сегментов. Такой метод называется задержкой подтверждений [RFC813].</p><p>Для TCP рекомендуется реализовать задержку ACK, но такая задержка не должна быть слишком большой. В частности задержка должна быть меньше 0.5 сек. и в потоке сегментов полного размера подтверждения должны передаваться по крайней мере для каждого второго сегмента.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Задержка ACK позволяет приложениям обновить окно и, возможно, передать незамедлительный отклик. В частности, для систем удаленного доступа с посимвольным вводом задержка ACK может снижать число сегментов, передаваемых сервером, втрое (ACK, обновление окна и эхо-символ передаются в одном сегменте).</p><p>В дополнение к этому на некоторых крупных, многопользовательских хостах, задержка ACK может существенно снизить затраты на обработку заголовков за счет уменьшения общего числа обрабатываемых пакетов [RFC813]. Однако, чрезмерная задержка ACK может нарушать определение времени обхода и работу алгоритмов «тактирования» пакетов [TCP:7].</p></li></ul><h5>4.2.3.3 Когда передавать Window Update</h5><p>Протокол TCP должен включать алгоритм предотвращения SWS на приемной стороне [RFC813].</p><ul><li class="b">Реализация</li><li class="lib"><p>Алгоритм предотвращения SWS на приемной стороне определяет когда может быть анонсировано расширение правого края окна (обновление окна — updating the window). Этот алгоритм используют совместно с задержкой подтверждений ACK (см. 4.2.3.2) для определения момента передачи получателю сегмента ACK, содержащего текущее окно. При описании мы будем использовать обозначения, принятые в <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC 793</a> (см. рис. 4 и 5 в этом документе).</p><p>Решением для приемной стороны является предотвращение анонсов смещения правого края окна RCV.NXT+RCV.WND с небольшим инкрементом даже при получении из сети мелких сегментов.</p><p>Предположим, что на приемной стороне имеется буфер RCV.BUFF. В любой момент времени RCV.USER октетов из этого буфера может быть связано с данными, которые уже получены и подтверждены, но еще не восприняты пользовательским процессом. Когда соединение находится в статичном состоянии, RCV.WND = RCV.BUFF и RCV.USER = 0.</p><p>Сохранение правого края окна неподвижным при получении и подтверждении данных требует чтобы приемник анонсировал пространство, которое меньше его реального буфера, т. е., приемник должен задавать значение RCV.WND, которое позволит сохранить постоянной сумму RCV.NXT+RCV.WND при возрастании RCV.NXT. Таким образом, общее пространство буфера RCV.BUFF в общем случае делится на три части:</p><pre>    |&lt;------- RCV.BUFF ----------------&gt;|
         1             2            3
----|---------|------------------|------|----
           RCV.NXT               ^
                              (Fixed)</pre><ol><li>RCV.USER — полученные, но не воспринятые приложением данные;</li><li>RCV.WND — пространство, анонсируемое отправителю;</li><li>Reduction — доступное, но еще не анонсированное пространство.</li></ol><p>Предлагаемый алгоритм предотвращения SWS для приемной стороны сохраняет фиксированное значение RCV.NXT+RCV.WND до тех пор, пока выполняется условие:</p><pre>RCV.BUFF - RCV.USER - RCV.WND  >=

       min( Fr * RCV.BUFF, Eff.snd.MSS )</pre><p>гле Fr — часть, рекомендуемое значение которой составляет 1/2, а Eff.snd.MSS — эффективное значение MSS для передачи в данном соединении (см. 4.2.2.6). При выполнении условий неравенства устанавливается RCV.WND = RCV.BUFF-RCV.USER.</p><p class="note">Отметим, что общим эффектом этого алгоритма является анонсирование RCV.WND с инкрементом Eff.snd.MSS (для разумных буферов на приемной стороне Eff.snd.MSS &lt; RCV.BUFF/2). Отметим также, что приемная сторона должна использовать свое значение Eff.snd.MSS, предполагая, что оно совпадает со значением для передающей стороны.</p></li></ul><h5>4.2.3.4 Когда передавать данные</h5><p>Протокол TCP должен поддерживать механизм предотвращения SWS на приемной стороне.</p><p>Для протокола TCP рекомендуется реализация алгоритма Nagle [RFC896], позволяющего объединять короткие сегменты. Однако, приложениям должен обеспечиваться способ запрета алгоритма Nagle для отдельных соединений. Во всех случаях для передачи данных действуют также ограничения, вносимые алгоритмом Slow Start (см. 4.2.2.15).</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Алгоритм Nagle в общем случае действует следующим образом:</p><p class="lia">При наличии неподтвержденных данных (т. е., SND.NXT > SND.UNA) в буферы TCP передаются все пользовательские данные (не принимая во внимание бит PSH), пока остающиеся данные не будут подтверждены или пока TCP не сможет передать сегмент полного размера (Eff.snd.MSS байтов; см. 4.2.2.6).</p><p>Некоторые приложения (например, отображение окон в реальном масштабе времени) требуют запрета алгоритма Nagle, чтобы небольшие сегменты данных передавались с максимальной скоростью.</p></li><li class="b">Реализация</li><li class="lib"><p>Алгоритм предотвращения SWS на передающей стороне реализуется сложней, нежели на приемной, поскольку отправитель не знает (явно) размер буферного пространства RCV.BUFF на приемной стороне. Проверенным вариантом является расчет отправителем значения максимального окна передачи для соединения Max(SND.WND) и использование полученного значения для оценки RCV.BUFF. К сожалению, возможна только оценка буфера, поскольку приемная сторона может время от времени менять значение RCV.BUFF. Чтобы избежать застоя соединений в результате этого, необходимо использовать значение тайм-аута для форсирования передачи данных, имеющего преимущество перед алгоритмом предотвращения SWS. На практике форсирование передачи по тайм-ауту должно происходить редко.</p><p>Доступное окно (useable window) имеет размер ([RFC813]):</p><pre>U = SND.UNA + SND.WND - SND.NXT</pre><p>т. е., предлагаемое окно меньше, чем размер переданных, но не подтвержденных данных. Если D указывает количество данных в очереди на передачу TCP, рекомендуется использовать следующий набор правил для передачи данных:</p><ol><li><p>при достижении максимального размера передаваемого сегмента, т. е.:</p><pre>min(D,U) >= Eff.snd.MSS;</pre></li><li><p>или установлен флаг push и все данные из очереди могут быть переданы, т. е.:</p><pre>[SND.NXT = SND.UNA and] PUSHED and D &lt;= U</pre><p>(условие в квадратных скобках вносится алгоритмом Nagle);</p></li><li><p>или по крайней мере Fs-ая часть максимального окна может быть передана, т. е.:</p><pre>[SND.NXT = SND.UNA and] min(D.U) >= Fs * Max(SND.WND);</pre></li><li><p>или установлен флаг PUSH и достигнут тайм-аут.</p><p>Fs представляет собой часть, рекомендуемое значение которой составляет 1/2. Значение тайм-аута должно составлять 0.1-1.0 сек. Может оказаться удобным объединение этого таймера с таймером проверки нулевого окна, описанным в параграфе 4.2.2.17.</p></li></ol><p>В заключение отметим, что использование алгоритма предотвращения SWS рекомендуется взамен алгоритма sender-side, описанного в работе [RFC813].</p></li></ul><h5>4.2.3.5 Сбои в соединениях TCP</h5><p>Многократные повторы передачи одного сегмента TCP свидетельствуют о наличии сбоев на удаленном хосте или пути через Internet. Эти сбои могут быть кратковременными или продолжительными. При возникновении таких ситуаций хост должен использовать перечисленные ниже процедуры [RFC816]:</p><ul class="lat"><li><p>Существуют два пороговых значения R1 и R2 для измерения числа повторов передачи одного сегмента. Для задания R1 и R2 могут использоваться единицы времени или число повторов передачи.</p></li><li><p>При достижении числа повторов R1 передается негативный анонс (см. 3.3.1.4) на уровень IP для включения диагностики работоспособности шлюзов.</p></li><li><p>При достижении порога R2 (превышает R1) соединение закрывается.</p></li><li><p>Приложениям должна обеспечиваться возможность установки порога R2 для отдельного соединения. Например, интерактивные соединения могут устанавливать для R2 «бесконечное» значение, предоставляя пользователю самостоятельно решать вопрос о разрыве соединения.</p></li><li><p>Протоколу TCP рекомендуется информировать приложения о проблемах с доставкой (если это не запрещено приложением; см. 4.2.4.1), при достижении порога R1, но до порога R2. Такая информация позволяет программам удаленного доступа (типа Telnet) информировать пользователя о проблемах.</p></li></ul><p>Рекомендуется устанавливать для R1 значение, соответствующее по крайней мере 3 повторам при текущем значении RTO. Для R2 рекомендуется задавать значение не менее 100 секунд.</p><p>При попытке создать соединение TCP может наблюдаться сбой с многократным повтором сегмента SYN, получением сегмента RST или сообщения ICMP Port Unreachable. Повторные передачи SYN должны обрабатываться обычным способом (как для данных), включая уведомление прикладного уровня.</p><p>Однако, значения R1 и R2 для сегментов SYN могут отличаться от значения для сегментов данных. В частности, значение R2 для SYN должно быть достаточно велико, чтобы обеспечивать повторные передачи по крайней мере в течение 3 минут. Приложение может закрыть соединение и раньше (например, задав число попыток).</p><ul><li class="b">Обсуждение:</li><li class="lib">Для некоторых путей Internet время организации соединения достаточно велико и число таких путей может существенно возрасти в будущем.</li></ul><h5>4.2.3.6 TCP Keep-Alive</h5><p>Разработчики могут включать в свои реализации TCP пакеты keep-alive, хотя такая практика не принята повсеместно. При включении keep-alive приложениям должна обеспечиваться возможность запрета таких пакетов для отдельных соединений TCP и по умолчанию такие пакеты должны быть запрещены.</p><p>Пакеты keep-alive должны передаваться только при отсутствии пакетов данных или подтверждений в течение заданного интервала. Значение этого интервала должно быть настраиваемым и по умолчанию должно составлять не менее 2 часов. Очень важно помнить, что для сегментов ACK, не содержащих данных, протокол TCP не обеспечивает гарантии доставки. Следовательно, при реализации механизма keep-alive сбои в ответ на специфические проверки не должны интерпретироваться как «умирание» соединения.</p><p>Рекомендуется передавать сегменты keep-alive без данных, однако можно настраивать протокол на передачу сегментов keepalive, содержащих один произвольный октет для совместимости с ошибочными реализациями TCP.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Механизм keep-alive периодически проверяет удаленную сторону при простое соединения, даже если отсутствуют неподтвержденные данные. Спецификация TCP не включает механизма keep-alive, поскольку он: (1) может обрывать нормальные соединения в результате транзитных сбоев Internet; (2) приводит к ненужному расходу полосы и (3) повышает расходы для соединений Internet с платным трафиком.</p><p>Некоторые реализации TCP все же включают механизм keep-alive. Для подтверждения работоспособности бездействующего соединения такие реализации передают пробные сегменты, предназначенные для получения отклика удаленной стороны. Такие сегменты в общем случае включают поле SEG.SEQ=SND.NXT-1 и могут также содержать один произвольный октет данных. Отметим, что для бездействующих соединений SND.NXT=RCV.NXT, поэтому значение SEG.SEQ будет выходить за пределы окна. Следовательно, пробный сегмент будет заставлять приемник вернуть сегмент подтверждения, говорящий о том, что соединение сохраняет работоспособность. Если удаленная сторона разорвала соединение, она будет возвращать RST вместо подтверждающего сегмента.</p><p>К несчастью, в некоторых не вполне корректных реализациях TCP возникают сбои при получении сегмента с SEG.SEQ = SND.NXT-1, если такой сегмент не содержит данных. Приложение может дополнительно проверить, способна ли удаленная сторона корректно отвечать на пакеты keep-alive без вставленного в них произвольного (garbage) октета данных.</p><p>Механизм TCP keep-alive следует использовать только в серверных приложениях, которые могут неограниченно долго сохранять соединения, потребляя без нужды сетевые ресурсы, даже если клиент по тем или иным причинам разорвал или потерял соединение.</p></li></ul><h5>4.2.3.7 Многодомные хосты TCP</h5><p>Если приложение на многодомном хосте не указывает локальный IP-адрес при активной организации соединения TCP, протокол TCP должен запрашивать уровень IP для получения локального IP-адреса до (первой) передачи SYN. Более подробные сведения приведены в параграфе 3.4 — функция GET_SRCADDR().</p><p>Во всех остальных случаях через это соединение был уже передан или принят сегмент и протокол TCP должен использовать тот же локальный адрес, который применялся для предыдущего сегмента.</p><h5>4.2.3.8 Опции IP</h5><p>При передаче опций на уровень TCP со стороны IP, протокол TCP должен игнорировать непонятные опции. TCP может поддерживать опции Time Stamp и Record Route.</p><p>Приложениям должна обеспечиваться возможность задания source route при активной организации соединения TCP и этот маршрут должен иметь преимущество перед source route из принятой дейтаграммы.</p><p>При пассивной организации соединения TCP и достижении пакетом конечной точки, указанной опцией IP Source Route (содержащей путь возврата), протокол TCP должен сохранить маршрут возврата и использовать его для всех сегментов, передаваемых через это соединение. Если в последующих сегментах приходит иной маршрут source route, новый маршрут рекомендуется использовать взамен прежнего.</p><h5>4.2.3.9 Сообщения ICMP</h5><p>Протокол TCP должен передавать сообщения ICMP об ошибках, полученные с уровня IP, соединениям, с которыми связаны ошибки. Демультиплексирование осуществляется на основе заголовков IP, содержащих сообщения ICMP.</p><ul class="dot"><li><p>Source Quench</p><p>Протокол TCP должен реагировать на сообщения Source Quench замедлением передачи через соединение. Для реализации этого рекомендуется использовать процедуру как при тайм-ауте повторной передачи.</p></li><li><p>Destination Unreachable — коды 0, 1, 5</p><p>Поскольку такие сообщения говорят о кратковременных ошибках, протокол TCP не должен прерывать соединение; рекомендуется передать эту информацию приложению.</p></li></ul><ul><li class="b">Обсуждение:</li><li class="lib"><p>Протокол TCP может сообщать о некритичных ошибках непосредственно прикладному уровню с помощью процедуры ERROR_REPORT; допускается также информировать приложения только при возникновении тайм-аута для соединения TCP.</p><ul class="dot"><li><p>Destination Unreachable — коды 2-4</p><p>Эти сообщения говорят о серьезных ошибках, поэтому рекомендуется разрывать соединения TCP.</p></li><li><p>Time Exceeded — коды 0, 1</p><p>Эти ошибки трактуются аналогично Destination Unreachable с кодами 0, 1, 5 (см. выше).</p></li><li><p>Parameter Problem</p><p>Эти ошибки трактуются аналогично Destination Unreachable с кодами 0, 1, 5 (см. выше).</p></li></ul></li></ul><h5>4.2.3.10 Проверка корректности удаленного адреса</h5><p>Реализация TCP должна отбрасывать (как ошибочные) локальные вызовы OPEN с некорректным IP-адресом удаленной стороны (например, широковещательный или групповой адрес).</p><p>Входящие запросы SYN с некорректным адресом отправителя должны игнорироваться уровнем TCP или IP (см. 3.2.1.3). Реализация TCP должна без уведомления отбрасывать все входящие сегменты SYN с широковещательными или групповыми адресами.</p><h5>4.2.3.11 Картины трафика TCP</h5><ul><li class="b">Реализация</li><li class="lib"><p>Спецификация протокола TCP [<a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC793</a>] предоставляет разработчикам свободу выбора алгоритма для контроля за потоком сообщений через соединение — пакетирование, управление окном, передача подтверждений и т. д. Выбрать алгоритм непросто, поскольку протокол TCP должен адаптироваться к различным картинам трафика. Опыт показывает, что разработчикам TCP требуется проверять реализацию для двух экстремальных вариантов трафика:</p><ul class="dot"><li><p>Односимвольные сегменты</p><p>Даже при использовании передающей стороной алгоритма Nagle соединения TCP для удаленного входа в систему через ЛВС с малой задержкой будут порождать поток односимвольных сегментов. Если на удаленном терминале включен режим эхо-символов, принимающая сторона будет в общем случае генерировать отклик на каждый принятый символ.</p></li><li><p>Передача больших объемов данных</p><p>При использовании TCP для передачи большого объема данных поток почти полностью будет состоять из сегментов размером MSS (эффективное значение). Хотя TCP использует пространство порядковых номеров с байтовой (октетной) гранулярностью, при передаче больших объемов данных должны учитываться только сегменты.</p></li></ul><p>Опыт показывает что эффективные и корректные реализации TCP хорошо работают в обоих экстремальных случаях. Наиболее важным средством для проверки новых реализаций TCP являются программы трассировки пакетов. Многолетний опыт показывает важность трассировки для различных картин трафика при использовании с другими реализациями TCP для поиска ошибок.</p></li></ul><h5>4.2.3.12 Эффективность</h5><ul><li class="b">Реализация</li><li class="lib"><p>На основании накопленного опыта выработаны рекомендации для разработчиков TCP:</p><ul class="lat"><li><p>Не копируйте данные</p><p>При передаче больших объемов данных наибольшую нагрузку на процессор создает копирование данных из одного места в другое для определения контрольной суммы. Важно минимизировать число копий данных TCP. Поскольку передача данных через шину памяти может существенно ограничивать скорость, полезно объединять копирование данных с вычислением контрольных сумм.</p></li><li><p>Внимательно относитесь к вычислению контрольных сумм</p><p>Хорошие программы вычисления контрольных сумм TCP обычно в 2-5 раз быстрее, по сравнению с простой реализацией определений CRC. Для эффективного определения контрольных сумм требуется программирование высокого класса (см. [<a href="../1071.rfc" title="RFC 1071 - Расчет контрольных сумм в Internet">RFC1071</a>]).</p></li><li><p>Код общего назначения</p><p>Обработка протокола TCP может быть сложной, но для большинства сегментов используется лишь несколько простых решений. Посегментная обработка существенно ускоряется за счет эффективного кодирования основной линии с минимизацией числа принимаемых решений для наиболее вероятных ситуаций.</p></li></ul></li></ul><h4>4.2.4 Интерфейс между TCP и прикладным уровнем</h4><h5>4.2.4.1 Асинхронные отчеты</h5><p>Должен обеспечиваться механизм информирования приложений о некритичных ошибках TCP. В общем случае это реализуется с помощью прикладной процедуры ERROR_REPORT, которая может асинхронно [RFC817] вызываться с транспортного уровня: ERROR_REPORT(local connection name, reason, subreason) Кодирование причин ошибок не рассматривается здесь, однако сообщения, асинхронно передаваемые приложениям, должны включать:</p><ul class="dot"><li>полученные сообщения ICMP об ошибках (см. 4.2.3.9)</li><li>информацию о многократных повторах передачи (см. 4.2.3.5)</li><li>анонсы указателей срочности (см. 4.2.2.4).</li></ul><p>Для программ, которые не хотят получать информации об ошибках ERROR_REPORT, рекомендуется эффективно отключить вызов процедуры.</p><ul><li class="b">Обсуждение:</li><li class="lib">Сообщения в общем случае включают сведения о некритичных ошибках, которые можно игнорировать без вреда для большинства приложений. Предполагается, что по умолчанию передача отчетов об ошибках запрещена, но это не обязательно.</li></ul><h5>4.2.4.2 Тип обслуживания</h5><p>Прикладному уровню должна быть обеспечена возможность задавать тип обслуживания TOS для сегментов, передаваемых через соединение. Рекомендуется также обеспечивать приложениям возможность изменения TOS в процессе использования соединения. Протоколу TCP рекомендуется передавать текущее значение TOS без изменений на уровень IP при передаче сегмента в соединение.</p><p>Значение TOS задается независимо для каждого направления в соединении, поэтому принимающее приложение будет задавать TOS для сегментов ACK.</p><p>TCP может передавать приложениям последнее использованное значение TOS из принятых сегментов.</p><ul><li class="b">Обсуждение:</li><li class="lib"><p>Некоторые приложения (например, SMTP) меняют тип обмена данными во время соединения и, следовательно, могут пожелать изменить значение TOS.</p><p class="note">Отметим также, что вызов OPEN в соответствии с <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC 793</a> включает параметр options, в котором могут быть заданы опции IP (source route, record route, timestamp).</p></li></ul><h5>4.2.4.3 Вызов Flush</h5><p>Некоторые реализации TCP включают вызовы FLUSH, которые очищают очередь передачи TCP от всех данных, помещенных в нее с помощью вызовов SEND из прикладных программ, но сохраняет данные, остающиеся в правой части текущего окна передачи. Таким образом, эта функция удаляет из очереди как можно больше данных без потери синхронизации порядковых номеров. Это полезно для реализации функций типа abort output в Telnet.</p><h5>4.2.4.4 Многодомные хосты</h5><p>Пользовательский интерфейс, описанный в параграфах 2.7 и 3.8 <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC 793</a>, требует расширения для многодомных хостов. Функция OPEN должна поддерживать необязательный параметр с локальным адресом:</p><pre>OPEN( ... [local IP address,] ... )</pre><ul><li class="b">Обсуждение:</li><li class="lib">Некоторые приложения на базе TCP (например, FTP) требуют указывать локальный IP-адрес, который используется для организации соединения.</li><li class="b">Реализация</li><li class="lib"><p>Пассивный вызов OPEN с заданным локальным адресом IP будет ждать входящего запроса на соединение с этим адресом. Если параметр не указан, пассивный вызов OPEN будет ждать запроса на входящее соединение по любому локальному адресу IP и потом связывать локальный IP-адрес с этим соединением.</p><p>Для активных вызовов OPEN указанный локальный IP-адрес будет использоваться для организации соединения. Если параметр не задан, сетевая программа будет выбирать подходящий локальный адрес IP (см. 3.3.4.2) для организации соединения.</p></li></ul><h4>4.2.5 Требования к протоколу TCP</h4><table><tr class="b c"><td>Функция</td><td>Параграф</td><td>Требование</td></tr><tr class="nbb"><td>Флаг Push</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Объединение или очередь при отсутствии флага Push</td><td>4.2.2.2</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Передающая сторона удаляет последовательные флаги Push</td><td>4.2.2.2</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">При вызове функции SEND можно установить Push</td><td>4.2.2.2</td><td>Возможно</td></tr><tr class="nbt"><td class="lib">При отсутствии Push бесконечный буфер передачи</td><td>4.2.2.2</td><td>Недопустимо</td></tr><tr class="nbt"><td class="lib">При отсутствии Push установка PSH для последнего сегмента</td><td>4.2.2.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Уведомление принимающей программы о PSH</td><td>4.2.2.2</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Передача по возможности сегментов максимального размера</td><td>4.2.2.2</td><td>Рекомендуется</td></tr><tr class="nbb"><td>Окно</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Размер трактуется как беззнаковое целое</td><td>4.2.2.3</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Поддержка 32-битового поля размера</td><td>4.2.2.3</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Сокращение окна справа</td><td>4.2.2.16</td><td>Не рекомендуется</td></tr><tr class="nbt"><td class="lia">Устойчивость к сокращению окна</td><td>4.2.2.16</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Неопределенное закрытие окна приемником</td><td>4.2.2.17</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Отправитель проверяет нулевое окно</td><td>4.2.2.17</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Первая проверка после RTO</td><td>4.2.2.17</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lib">Экспоненциальное увеличение интервала проверки</td><td>4.2.2.17</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Возможность неопределенного обнуления окна</td><td>4.2.2.17</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Тайм-аут для нормального соединения с нулевым окном</td><td>4.2.2.17</td><td>Недопустимо</td></tr><tr class="nbb"><td>Срочные данные</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Указатель на последний октет</td><td>4.2.2.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Последовательности срочных данных произвольной длины</td><td>4.2.2.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Асинхронное уведомление приложений о срочных данных</td><td>4.2.2.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Приложение может узнавать о наличии срочных данных</td><td>4.2.2.4</td><td>Обязательно</td></tr><tr class="nbb"><td>Опции TCP</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Получение опций в любом сегменте</td><td>4.2.2.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Игнорировать неподдерживаемые опции</td><td>4.2.2.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Устойчивость к опциям некорректного размера</td><td>4.2.2.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Реализация приема и передачи опции MSS</td><td>4.2.2.6</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Передача опции MSS, если максимальный размер не равен 536</td><td>4.2.2.6</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Передача опции MSS во всех случаях</td><td>4.2.2.6</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Значение MSS для передачи по умолчанию равно 536</td><td>4.2.2.6</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Расчет эффективного размера сегмента передачи</td><td>4.2.2.6</td><td>Обязательно</td></tr><tr class="nbb"><td>Контрольные суммы TCP</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Отправитель рассчитывает контрольную сумму</td><td>4.2.2.7</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Получатель проверяет контрольную сумму</td><td>4.2.2.7</td><td>Обязательно</td></tr><tr><td>Установка начального номера по текущему времени</td><td>4.2.2.9</td><td>Обязательно</td></tr></table><table><tr class="nbb"><td>Организация соединений</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Поддержка одновременных попыток</td><td>4.2.2.10</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">SYN-RCVD помнит последнее состояние</td><td>4.2.2.11</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Пассивные вызовы CALL могут мешать друг другу</td><td>4.2.2.18</td><td>Недопустимо</td></tr><tr class="nbt"><td class="lia">Функция одновременного прослушивания для одного порта</td><td>4.2.2.18</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Запрос адреса отправителя на уровне IP при необходимости</td><td>4.2.3.7</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">В противном случае использовать локальные адреса соединения</td><td>4.2.3.7</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">OPEN для групповых и широковещательных IP-адресов</td><td>4.2.2.14</td><td>Недопустимо</td></tr><tr class="nbt"><td class="lia">Отбрасывание сегментов для групповых/широковещательных адресов</td><td>4.2.2.14</td><td>Обязательно</td></tr><tr class="nbb"><td>Завершение соединений</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Сегмент RST может содержать данные</td><td>4.2.2.12</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Информирование приложений о разрыве соединения</td><td>4.2.2.13</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Полудуплексное закрытие соединений</td><td>4.2.2.13</td><td>Возможно</td></tr><tr class="nbt"><td class="lib">Передача RST для индикации потери данных</td><td>4.2.2.13</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Сохранять состояние TIME-WAIT в течение 2 x MSL</td><td>4.2.2.13</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Восприятие новых SYN во время TIME-WAIT</td><td>4.2.2.13</td><td>Возможно</td></tr><tr><td>Повторная передача</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Алгоритм Jacobson Slow Start</td><td>4.2.2.15</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Алгоритм Jacobson Congestion-Avoidance</td><td>4.2.2.15</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Повторная передача с сохранением идентификации IP</td><td>4.2.2.15</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Алгоритм Karn</td><td>4.2.3.1</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Алгоритм Якобсона для оценки RTO</td><td>4.2.3.1</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Экспоненциальное увеличение тайм-аута</td><td>4.2.3.1</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Расчет SYN RTO как для данных</td><td>4.2.3.1</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Рекомендуемые начальные значения и границы</td><td>4.2.3.1</td><td>Рекомендуется</td></tr><tr class="nbb"><td>Генерация подтверждений (ACK)</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Очередь для сегментов с нарушением порядка</td><td>4.2.2.20</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Обработка всей очереди до передачи подтверждения</td><td>4.2.2.20</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Передача ACK для сегментов с нарушением порядка</td><td>4.2.2.21</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Задержанные подтверждения</td><td>4.2.3.2</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lib">Задержка &lt; 0.5 сек</td><td>4.2.3.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Подтверждается каждый 2-ой сегмент полного размера</td><td>4.2.3.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Алгоритм предотвращения SWS на приемной стороне</td><td>4.2.3.3</td><td>Обязательно</td></tr><tr class="nbb"><td>Передача данных</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Настраиваемое значение TTL</td><td>4.2.2.19</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Алгоритм предотвращения SWS на передающей стороне</td><td>4.2.3.4</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Алгоритм Nagle</td><td>4.2.3.4</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lib">Приложение может отключить алгоритм Nagle</td><td>4.2.3.4</td><td>Обязательно</td></tr></table><table><tr class="nbb"><td>Сбои в соединениях</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Негативный анонс для IP при достижении R1</td><td>4.2.3.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Закрытие соединения при достижении R2</td><td>4.2.3.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Приложения могут устанавливать R2</td><td>4.2.3.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Информировать прикладной уровень после R1, но до R2</td><td>4.2.3.5</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Рекомендуемые значения для R1 и R2</td><td>4.2.3.5</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Поддержка такого же механизма для SYN</td><td>4.2.3.5</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Значение R2 для SYN не менее 3 минут</td><td>4.2.3.5</td><td>Обязательно</td></tr><tr class="nbb"><td>Передача пакетов Keep-Alive</td><td>4.2.3.6</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Приложение может передавать запросы</td><td>4.2.3.6</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">По умолчанию механизм отключен</td><td>4.2.3.6</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Возможность передачи только во время бездействия</td><td>4.2.3.6</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Возможность настройки интервала</td><td>4.2.3.6</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">По умолчанию интервал не менее 2 часов</td><td>4.2.3.6</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Устойчивость к потере подтверждений</td><td>4.2.3.6</td><td>Обязательно</td></tr><tr class="nbb"><td>Опции IP</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Игнорировать опции, не понятные TCP</td><td>4.2.3.8</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Поддержка временных меток</td><td>4.2.3.8</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Поддержка записи маршрута</td><td>4.2.3.8</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Source Route:</td><td></td><td></td></tr><tr class="nbt"><td class="lib">Возможность задать из приложения</td><td>4.2.3.8</td><td>Обязательно</td></tr><tr class="nbt"><td class="lic">Переписывание Source Route в дейтаграммах</td><td>4.2.3.8</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Встраивание маршрута возврата по исходному</td><td>4.2.3.8</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Изменение Source Route новыми сегментами</td><td>4.2.3.8</td><td>Рекомендуется</td></tr><tr class="nbb"><td>Прием сообщений ICMP от уровня IP</td><td>4.2.3.9</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Destination Unreach (0,1,5) => информировать приложение</td><td>4.2.3.9</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Destination Unreach (0,1,5) => разорвать соединение</td><td>4.2.3.9</td><td>Недопустимо</td></tr><tr class="nbt"><td class="lia">Destination Unreach (2-4) => разорвать соединение</td><td>4.2.3.9</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Source Quench => slow start</td><td>4.2.3.9</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Time Exceeded => информировать приложение без разрыва соединения</td><td>4.2.3.9</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Param Problem => информировать приложение без разрыва соединения</td><td>4.2.3.9</td><td>Рекомендуется</td></tr><tr class="nbb"><td>Проверка адресов</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Отказ для вызовов CALL с неверным адресом IP</td><td>4.2.3.10</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Отказ для SYN от некорректных адресов IP</td><td>4.2.3.10</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Отбрасывание без уведомления SYN с широковещательными/групповыми адресами</td><td>4.2.3.10</td><td>Обязательно</td></tr><tr class="nbb"><td>Интерфейс между TCP и приложениями</td><td></td><td></td></tr><tr class="nbt"><td class="lia">Механизм информирования об ошибках</td><td>4.2.4.1</td><td>Обязательно</td></tr><tr class="nbt"><td class="lia">Приложение может отключать информирование об ошибках</td><td>4.2.4.1</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Приложение может задавать TOS для передачи</td><td>4.2.4.2</td><td>Обязательно</td></tr><tr class="nbt"><td class="lib">Передача без изменений на уровень IP</td><td>4.2.4.2</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Приложение может менять TOS для действующего соединения</td><td>4.2.4.2</td><td>Рекомендуется</td></tr><tr class="nbt"><td class="lia">Передача приложению полученного TOS</td><td>4.2.4.2</td><td>Возможно</td></tr><tr class="nbt"><td class="lia">Вызов FLUSH</td><td>4.2.4.3</td><td>Возможно</td></tr><tr class="nbl"><td class="lia">Адрес IP как необязательный параметр OPEN</td><td>4.2.4.4</td><td>Обязательно</td></tr></table><h2 id="p5">5. Литература</h2><table itemprop="references"><tr><td>[RFC1123]</td><td>Robert Braden, <a href="../1123.rfc" title="RFC 1123 - Требования к хостам Internet - Прикладные и служебные протоколы">«Требования к хостам Internet - Прикладные и служебные протоколы», RFC 1123</a>, Октябрь 1989.</td></tr><tr><td>[RFC1009]</td><td>«Requirements for Internet Gateways», R. Braden and J. Postel, RFC 1009, Июнь 1987.</td></tr><tr><td>[INTRO:3]</td><td>«DDN Protocol Handbook», NIC-50004, NIC-50005, NIC-50006, (three volumes), SRI International, Декабрь 1985.</td></tr><tr><td>[RFC1011]</td><td>«Official Internet Protocols», J. Reynolds and J. Postel, RFC 1011, Май 1987.</td></tr><tr><td>[RFC980]</td><td>«Protocol Document Order Information», O. Jacobsen and J. Postel, RFC 980, Март 1986.</td></tr><tr><td>[RFC1010]</td><td>«Assigned Numbers», J. Reynolds and J. Postel, RFC 1010, Май 1987.</td></tr><tr><td>[RFC817]</td><td>«Modularity and Efficiency in Protocol Implementations», D. Clark, RFC 817, Июль 1982.</td></tr><tr><td>[INTRO:8]</td><td>«The Structuring of Systems Using Upcalls», D. Clark, 10th ACM SOSP, Orcas Island, Washington, Декабрь 1985.</td></tr><tr><td>[INTRO:9]</td><td>«A Protocol for Packet Network Intercommunication», V. Cerf and R. Kahn, IEEE Transactions on Communication, Май 1974.</td></tr><tr><td>[INTRO:10]</td><td>«The ARPA Internet Protocol», J. Postel, C. Sunshine, and D. Cohen, Computer Networks, Vol. 5, No. 4, Июль 1981.</td></tr><tr><td>[INTRO:11]</td><td>«The DARPA Internet Protocol Suite», B. Leiner, J. Postel, R. Cole and D. Mills, Proceedings INFOCOM 85, IEEE, Washington DC, Март 1985.</td></tr><tr><td>[INTRO:12]</td><td>«Final Text of DIS8473, Protocol for Providing the Connectionless Mode Network Service», ANSI, Март 1986.</td></tr><tr><td>[INTRO:13]</td><td>«End System to Intermediate System Routing Exchange Protocol», ANSI X3S3.3, Апрель 1986.</td></tr><tr><td>[RFC893]</td><td>«Trailer Encapsulations», S. Leffler and M. Karels, RFC 893, Апрель 1984.</td></tr><tr><td>[RFC826]</td><td>David C. Plummer, <a href="../826.rfc" title="RFC 826 - Протокол преобразования адресов Ethernet (ARP)">«Протокол преобразования адресов Ethernet (ARP)», RFC 826</a>, Ноябрь 1982.</td></tr><tr><td>[RFC894]</td><td>Charles Hornig, <a href="../894.rfc" title="RFC 894 - Стандарт передачи дейтаграмм IP в сетях Ethernet">«Стандарт передачи дейтаграмм IP в сетях Ethernet», RFC 894</a>, Апрель 1984.</td></tr><tr><td>[RFC1042]</td><td> J. Postel и J. Reynolds, <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">«Стандарт передачи дейтаграмм IP в сетях IEEE 802», RFC 1042</a>, Февраль 1988.</td></tr><tr><td>[RFC791]</td><td>J. Postel, <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">«Протокол IP (Internet Protocol)», RFC 791</a>, Сентябрь 1981.</td></tr><tr><td>[RFC792]</td><td>J. Postel, <a href="../792.rfc" title="RFC 792 - Протокол ICMP">«Протокол ICMP», RFC 792</a>, Сентябрь 1981.</td></tr><tr><td>[RFC950]</td><td> J. Mogul и J. Postel, <a href="../950.rfc" title="RFC 950 - Стандартные процедуры организации подсетей IP">«Стандартные процедуры организации подсетей IP», RFC 950</a>, Август 1985.</td></tr><tr><td>[RFC1112]</td><td>Steve Deering, <a href="../1112.rfc" title="RFC 1112 - Расширение IP Multicasting">«Расширение IP Multicasting», RFC 1112</a>, Август 1989.</td></tr><tr><td>[IP:5]</td><td>«Military Standard Internet Protocol», MIL-STD-1777, Department of Defense, Август 1983.</td></tr><tr><td>[RFC963]</td><td>«Some Problems with the Specification of the Military Standard Internet Protocol», D. Sidhu, RFC 963, Ноябрь 1985.</td></tr><tr><td>[RFC879]</td><td>«The TCP Maximum Segment Size and Related Topics», J. Postel, RFC 879, Ноябрь 1983.</td></tr><tr><td>[RFC1108]</td><td>«Internet Protocol Security Options», B. Schofield, RFC 1108, October 1989.</td></tr><tr><td>[IP:9]</td><td>«Fragmentation Considered Harmful», C. Kent and J. Mogul, ACM SIGCOMM-87, Август 1987. Published as ACM Comp Comm Review, Vol.17, no.5.</td></tr><tr><td>[RFC815]</td><td>«IP Datagram Reassembly Algorithms», D. Clark, RFC 815, Июль 1982.</td></tr><tr><td>[RFC816]</td><td>«Fault Isolation and Recovery», D. Clark, RFC 816, Июль 1982.</td></tr><tr><td>[RFC922]</td><td>Jeffrey Mogul, <a href="../922.rfc" title="RFC 922 - Широковещательная рассылка дейтаграмм IP при наличии подсетей">«Широковещательная рассылка дейтаграмм IP при наличии подсетей», RFC 922</a>, Октябрь 1984.</td></tr><tr><td>[RFC814]</td><td>«Name, Addresses, Ports, and Routes», D. Clark, RFC 814, Июль 1982.</td></tr><tr><td>[RFC1016]</td><td>«Something a Host Could Do with Source Quench: The Source Quench Introduced Delay (SQUID)», W. Prue and J. Postel, RFC 1016, Июль 1987.</td></tr><tr><td>[RFC768]</td><td>J. Postel, <a href="../768.rfc" title="RFC 768 - Протокол датаграмм клиента (UDP)">«Протокол UDP», RFC 768</a>, Август 1980.</td></tr><tr><td>[RFC793]</td><td>J. Postel, <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">«Протокол управления передачей (TCP)», RFC 793</a>, Сентябрь 1981.</td></tr><tr><td>[TCP:2]</td><td>«Transmission Control Protocol», MIL-STD-1778, US Department of Defense, Август 1984.</td></tr><tr><td>[RFC964]</td><td>«Some Problems with the Specification of the Military Standard Transmission Control Protocol», D. Sidhu and T. Blumer, RFC 964, Ноябрь 1985.</td></tr><tr><td>[RFC879]</td><td>«The TCP Maximum Segment Size and Related Topics», J. Postel, RFC 879, Ноябрь 1983.</td></tr><tr><td>[RFC813]</td><td>«Window and Acknowledgment Strategy in TCP», D. Clark, RFC 813, Июль 1982.</td></tr><tr><td>[TCP:6]</td><td>«Round Trip Time Estimation», P. Karn & C. Partridge, ACM SIGCOMM-87, Август 1987.</td></tr><tr><td>[TCP:7]</td><td>«Congestion Avoidance and Control», V. Jacobson, ACM SIGCOMM-88, Август 1988.</td></tr><tr><td>[RFC817]</td><td>«Modularity and Efficiency in Protocol Implementation», D. Clark, RFC 817, Июль 1982.</td></tr><tr><td>[RFC896]</td><td>«Congestion Control in IP/TCP», J. Nagle, RFC 896, Январь 1984.</td></tr><tr><td>[RFC1071]</td><td>R. Braden, D. Borman, и C. Partridge, <a href="../1071.rfc" title="RFC 1071 - Расчет контрольных сумм в Internet">«Расчет контрольных сумм в Internet», RFC 1071</a>, Сентябрь 1988.</td></tr><tr><td>[RFC1072]</td><td>«TCP Extensions for Long-Delay Paths», V. Jacobson & R. Braden, RFC 1072, October 1988.</td></tr></table><h2>Вопросы безопасности</h2><p>С программами различных коммуникационных уровней хостов связано множество вопросов безопасности, но их обсуждение выходит за рамки данного RFC.</p><p>Архитектура Internet в общем случае обеспечивает весьма слабую защиту против подстановки (spoofing) IP-адресов отправителя, поэтому любой механизм обеспечения безопасности на основе IP-адресов отправителей должен применяться с осторожностью. Однако, в ограниченной среде некоторая проверка адресов отправителей становится вполне возможной. Например, можно создать безопасную ЛВС, входной маршрутизатор которой будет отбрасывать любые дейтаграммы, в которых в качестве отправителя указан внутренний адрес локальной сети. В этом случае хост ЛВС может различать внешние и внутренние хосты по адресу отправителя. Проблема усложняется при задании маршрута отправителем (source routing) и существуют предложения запретить хостам рассылку дейтаграмм source-route из соображений безопасности (см. 3.3.5).</p><p>Вопросы безопасности рассматриваются в параграфах, связанных с опцией IP Security (см. 3.2.1.8), сообщениями ICMP Parameter Problem (см. 3.2.2.5), опциями IP в дейтаграммах UDP (см. 4.1.3.2) и резервированием портов TCP (см. 4.2.2.1).</p><h2>Адрес автора</h2><p>Robert Braden<br />USC/Information Sciences Institute<br />4676 Admiralty Way<br />Marina del Rey, CA 90292-6695<br />Телефон: (213) 822 1511<br />EMail: <bdo dir="rtl">&#117;&#100;&#101;&#46;&#105;&#115;&#105;&#64;&#110;&#101;&#100;&#97;&#114;&#98;</bdo></p></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни",disqus_identifier="1122.rfc",disqus_url="http://rfc2.ru/1122.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>