<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../5905.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 5905 — Протокол сетевого времени NTPv4</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../5905.rfc">RFC 5905 — Протокол сетевого времени NTPv4</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 5905</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank"><span itemprop="alternativeHeadline">Network Time Protocol Version 4: Protocol and Algorithms Specification</span></a></dd><dd><div class="icon i7"></div> Предыдущие версии: RFC 958, RFC 1059, RFC 1119, RFC 1305, RFC 1361, RFC 1769, RFC 2030, RFC 4330</dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Предложенный стандарт</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="2010-06-01">Июнь 2010</time></dd><dd><div class="icon i5"></div> Авторы: <span itemprop="author">D. Mills</span>, <span itemprop="author">U. Delaware</span>, <span itemprop="author">J. Martin</span>, <span itemprop="author">J. Burbank</span>, <span itemprop="author">W. Kasch</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Мельников Дмитрий Анатольевич</span></dd></dl><div id="text" itemprop="articleBody"><h2>Оглавление</h2><ul class="map"><li><a href="print#p1">1. Введение</a></li><li><a href="print#p2">2. Режимы функционирования</a></li><li><a href="print#p3">3. Разновидности функционирования протокола</a></li><li class="lia"><a href="print#p3.1">3.1. Поиск функционирующего сервера</a></li><li><a href="print#p4">4. Определения</a></li><li><a href="print#p5">5. Модель реализации</a></li><li><a href="print#p6">6. Типы данных (логическая харктеристика)</a></li><li><a href="print#p7">7. Структуры данных</a></li><li class="lia"><a href="print#p7.1">7.1. Условные обозначения структур данных</a></li><li class="lia"><a href="print#p7.2">7.2. Общие параметры</a></li><li class="lia"><a href="print#p7.3">7.3. Переменные в заголовке NTP-сообщения</a></li><li class="lia"><a href="print#p7.4">7.4. NTP-сообщение «Kiss-o'-Death»</a></li><li class="lia"><a href="print#p7.5">7.5. Формат дополнительного поля расширения</a></li><li><a href="print#p8">8. Процедурная характеристика протокола</a></li><li><a href="print#p9">9. Функциональные процедуры удлённого сервера</a></li><li class="lia"><a href="print#p9.1">9.1. Переменные, обрабатываемые удалённым сервером</a></li><li class="lia"><a href="print#p9.2">9.2. Процедуры, проводимые удалённым сервером</a></li><li><a href="print#p10">10. Процедура (алгоритм) фильтрации времени</a></li><li><a href="print#p11">11. Системный процесс (процедуры)</a></li><li class="lia"><a href="print#p11.1">11.1. Переменные системного процесса (процедур)</a></li><li class="lia"><a href="print#p11.2">11.2. Процедуры системного процесса</a></li><li class="lib"><a href="print#p11.2.1">11.2.1. Процедура (алгоритм) селекции</a></li><li class="lib"><a href="print#p11.2.2">11.2.2. Процедура (алгоритм) кластеризации</a></li><li class="lib"><a href="print#p11.2.3">11.2.3. Процедура (алгоритм) суммирования</a></li><li class="lia"><a href="print#p11.3">11.3. Процедура (алгоритм) корректировки (настройки) времени (часов)</a></li><li><a href="print#p12">12. Процедура корректировки (настройки) времени (часов)</a></li><li><a href="print#p13">13. Процедура опроса</a></li><li class="lia"><a href="print#p13.1">13.1. Переменные процедуры опроса</a></li><li class="lia"><a href="print#p13.2">13.2. Процессы (операции) процедуры опроса</a></li><li><a href="print#p14">14. Простой протокол сетевого времени (SNTP)</a></li><li><a href="print#p15">15. Проблемы обеспечения безопасности</a></li><li><a href="print#p16">16. Вопросы, решаемые IANA</a></li><li><a href="print#p17">17. Благодарности</a></li><li><a href="print#p18">18. Ссылки</a></li><li class="lia"><a href="print#p18.1">18.1. Нормативные документы</a></li><li class="lia"><a href="print#p18.2">18.2. Дополнительная литература</a></li></ul><h2 id="p1">1. Введение</h2><p>Данный стандарт вводит четвёртую версию протокола сетевого времени (Network Time Protocol Version 4 — NTPv4), который широко используется для синхронизации системных часов среди множества распределённых серверов времени и клиентов. Он определяет базовую архитектуру, логическую и процедурную характеристики (протокол, как конечный автомат), структуры данных и алгоритмы. NTPv4-протокол вводит новые функциональные свойства в третью версию NTP-протокола (RFC-1305) и расширяется сам за счёт поглощения функциональных свойств SNTPv4-протокола (RFC-4330). Данный стандарт заменяет предшествующие стандарты RFC-1305 и RFC-4330. Так как в некоторых полях NTPv4-сообщений были сделаны всего лишь незначительные изменения, последние не должны повлиять на качество взаимодействия NTPv4-протокол с предшествующими версиями NTP- и SNTP-протоколов.</p><div class="pic"><img src="../img/rfc-5905-ntp-protocol.png" alt="Иерархия, структура и топология системы сетевого времени на основе NTP-протокола" /><p>Рис.1. Иерархия, структура и топология системы сетевого времени на основе NTP-протокола</p></div><p>Модель NTP-подсети синхронизации представляет собой множество первичных эталонных источников, синхронизируемых по радио- и проводным каналам от национальных стандартов, например, через магистральные шлюзы, соединено с общедоступными ресурсами и функционирует, как первичные серверы времени (рис.1).</p><p>Главной целью NTP-протокола является доставка данных для временной синхронизации от одних серверов времени к другим серверам времени через Internet-сеть и частные корпоративные сети, а также сверка времени между серверами. Точно настроенные алгоритмы (процедуры) снижают вероятность ошибок в следствие сбоев программно-аппаратных комплексов или нештатных ситуаций при передаче протокольных данных. Программные модули серверов и клиентов настраиваются так, чтобы поток значений параметров был направлен в сторону клиентов от первичных серверов времени, расположенных в корневых узлах подсети, через вторичные серверы времени. NTPv4-протокол устраняет недостатки предыдущей версии протокола, корректирует имеющиеся в последней ошибки и добавляет новые свойства. Соответственно, определение расширенной NTP-метки времени позволяет использовать удвоенные числа с плавающей запятой во всех без исключения прикладных реализациях протокола. А это в свою очередь, повышает точность времени, которая составляет менее одной наносекунды, а точность частоты — менее одной наносекунды в секунду. Новый стандарт имеет несколько дополнительных преимуществ, среди которых новый алгоритм обслуживания часов, который более чувствителен флуктуациям частоты в аппаратных системных часах. Типовые первичные серверы времени построены на современных вычислительных средствах, обеспечивающих точность в пределах нескольких десятков микросекунд. Типовые вторичные серверы времени и клиенты в составе высокоскоростных ЛВС обеспечивают точность в пределах нескольких сотен микросекунд при интервалах опроса до 1024 секунд (это была максимальная точность для NTPv3-протокола). А при интервалах опроса до 36 часов NTPv4-серверы и клиенты обеспечивают точность в пределах нескольких десятков миллисекунд.</p><h2 id="p2">2. Режимы функционирования</h2><p>Программный NTP-модуль функционирует как первичный сервер, вторичный сервер или клиентский модуль. Первичный сервер синхронизируется от эталонных часов, которые напрямую синхронизируются от глобальных UTC-систем времени (например, GPS, Galileo и т.п.). Клиентский NTP-модуль синхронизируется от одного или более вышележащих серверов, но не синхронизируется от зависимых клиентов. Вторичные серверы связаны с одним или несколькими вышележащими серверами и одним или несколькими нижележащими серверами или клиентами. Все серверы и клиенты, которые полностью соответствуют NTPv4-протоколу, должны применять весь набор алгоритмов, представленный в этом стандарте. С целью поддержания стабильности в больших NTP-подсетях синхронизации, целесообразно, чтобы вторичные серверы полностью соответствовали NTPv4-протоколу. Допускается использование альтернативных алгоритмов, однако, их выходные параметры должны быть идентичны тем, которые имеют алгоритмы, представленные в данном стандарте.</p><h2 id="p3">3. Разновидности функционирования протокола</h2><p>Существует три разновидности функционирования NTPv4-протокола (рис.2):</p><ul class="list"><li class="b"><p>Симметричное функционирование</p></li><li class="lib"><p>В этом варианте удалённый сервер времени функционирует одновременно, и собственно как сервер, и как клиент, используя для этого, либо симметричное активное виртуальное соединение, либо симметричное пассивное виртуальное соединение. При постоянном симметричном активном соединении (режим №1) передаются соответствующие NTP-сообщения на удалённый сервер, также функционирующий в режиме постоянного симметричного соединения. Как альтернатива, после получения NTP-сообщения от сервера, функционирующего в режиме постоянного симметричного соединения, по другому не согласованному виртуальному соединению может быть сформировано временное пассивное виртуальное соединение. По такому соединению передаются соответствующие NTP-сообщения (режим №2), а само виртуальное соединение поддерживается до окончания тайм-аута или возникновения ошибки или сбоя. Удалённые серверы времени как бы «принуждают» друг друга к обоюдной синхронизации. В данном стандарте удалённые серверы функционируют как клиенты, а сами клиенты используют их как источники синхронизации.</p></li><li class="b"><p>Функционирование в режимах «клиент/сервер»</p></li><li class="lib"><p>В данном режиме постоянный клиент передает пользовательские NTP-сообщения (режим №3) на сервер времени, который отвечает на них путём передачи своих NTP-сообщений (режим №4). Серверы времени синхронизируют одного или нескольких клиентов, но сами от них не синхронизируются. Сервер может быть также «ретранслятором» эталонного времени, если он получает сигналы времени непосредственно от источника эталонного времени/частоты. В данном варианте клиенты синхронизируются от серверов времени.</p></li><li class="b"><p>Широковещательное функционирование</p></li><li class="lib"><p>В данном режиме широковещательный сервер времени, используя постоянное виртуальное соединение периодически передает свои широковещательные NTP-сообщения (режим №5), которые могут принимать несколько клиентов. После приёма широковещательного NTP-сообщения сервера времени по несогласованному виртуальному соединению клиент формируется временное широковещательное виртуальное соединение (режим №6), которое функционирует до окончания тайм-аута или возникновения ошибки или сбоя. Такой режим необходим для начального «импульса», когда клиент, функционирующий в режиме «клиент», обменивается несколькими NTP-сообщениями с сервером времени для того, чтобы точно измерить задержку распространения сигнала, или чтобы активизировать протокол безопасности «Autokey»<sup><abbr title="Mills, D.L., «The Autokey security architecture, protocol and algorithms. Electrical and Computer Engineering Technical Report 06-1-1», NDSS, Январь 2006.">[?]</abbr></sup>, после выполнения которого клиент возвращается в широковещательный режим клиента. Широковещательный сервер синхронизирует клиентов и другие серверы времени.</p></li></ul><table><tr><th>Режимы функционирования</th><th>Кодирование режима</th><th>Режим обработки пакетов</th></tr><tr><td>Симметричный активный</td><td>1</td><td>1 или 2</td></tr><tr><td>Симметричный пассивный</td><td>2</td><td>1</td></tr><tr><td>Режим клиента</td><td>3</td><td>4</td></tr><tr><td>Режим сервера</td><td>4</td><td>3</td></tr><tr><td>Широковещательный режим сервера</td><td>5</td><td>5</td></tr><tr><td>Широковещательный режим клиента</td><td>6</td><td>-</td></tr><tr><th colspan="3">Рис.2. Режимы функционирования NTPv4-протокола</th></tr></table><p>Необходимо отметить, что постоянные виртуальные соединения после их установления в дальнейшем никогда не прерываются. Временные виртуальные соединения формируются после получения NTP-сообщения и с последующем прерываются, либо по истечении тайм-аута, либо при возникновении ошибки или сбоя.</p><p>В телефонной индустрии точность каждого сервера определяется номером «слоем» (числом), при этом самый верхний уровень (первичные серверы) обозначается единицей, а каждый последующий (вниз) уровень (вторичные серверы) в иерархии обозначается числом, которое на единицу больше, по сравнению с предшествующим уровнем. Так как номер «слоя» увеличивается, начиная с единицы, достигнутая при однократном запросе точность времени будет ухудшаться в зависимости от соответствующего маршрута обмена данными и стабильности системных часов. Усреднённые ошибки измерений, вызванные различными расстояниями синхронизации, возрастают пропорционально номеру «слоя» и измеренной задержке петлевого маршрута (roundtrip delay).</p><p>На практике, топология подсети синхронизации должна быть такой, чтобы исключить петлевые маршруты и минимизировать расстояния синхронизации. Используемый в NTP-протоколе алгоритм селекции основан одном из вариантов алгоритма распределенной маршрутизации Беллмана-Форда (BellmanFord), предназначенного для расчета связывающих деревьев с минимальными весовыми коэффициентами, которые своими «корнями» замыкаются на первичные серверы. Результатом такого подхода является то, что подсеть перенастраивается автоматически в иерархическую структуру (с ведущими и ведомыми серверами) с целью обеспечения максимально возможных точности и надежности времени, даже когда один или несколько первичных или вторичных серверов или сетевых маршрутов между ними не функционируют по причине сбоя.</p><h3 id="p3.1">3.1. Поиск функционирующего сервера</h3><p>Существуют два специальных типа виртуальных соединений: многоадресное (manycast) клиента и многоадресное сервера, — которые реализуют процедуру поиска функционирующего сервера. Также существуют два типа многоадресных виртуальных соединения клиента: постоянное и временное. Постоянное многоадресное соединение клиента предназначено для передачи клиентских NTP-сообщений (режим №3) по специализированному широковещательному или групповому IPv4/v6-адресу. Специализированные многоадресные серверы в пределах временного интервала, указанного в поле «time-to-live» (TTL) заголовка IP-пакета, контролируют трафик на предмет обнаружения IP-пакетов с определенным широковещательным или групповым IP-адресом. Если сервер приемлем для синхронизации, то тогда он передаёт своё ответное NTP-сообщение (режим №4), используя для этого IP-пакет, в котором указывает уникальный адрес клиента. После получения этого NTP-сообщения клиент формирует временное виртуальное соединение (режим №3). Временное виртуальное соединение клиента поддерживается до окончания тайм-аута или возникновения ошибки или сбоя.</p><p>Клиент, функционирующий в многоадресном режиме, продолжает передавать NTP-сообщения с целью установления минимального числа виртуальных соединений. Клиент начинает поиск со значения TTL, равного единице, и в последующем увеличивает это значение на единицу до тех пор, пока не будет установлено минимальное число виртуальных соединений или пока TTL достигнет своего максимального значения.</p><p>Если TTL достигает своего максимального значения, но при этом сформировано не достаточное количество виртуальных соединений, то тогда клиент прекращает передачу на период тайм-аута и разрывает все установленные соединения, а затем повторяет поиск. Если сформировано минимально число виртуальных соединений, то тогда клиент начинает передачу по одному NTP-сообщению через интервал тайм-аута с целью поддержания этих соединений. Поле допускает следующие предельные значения — минимально равно единице, а максимальное — 255. Эти предельные значения могут быть изменены, если это необходимо для конкретных прикладных систем.</p><p>Временные виртуальные соединения конкурируют между собой. Как только сформированы новые соединения, клиентский NTP-модуль запускает алгоритмы оптимизации (фильтрации, селекции, кластеризации и суммирования) с целью выбора наилучших претендентов для синхронизации, а оставшиеся соединения прерываются по окончании тайм-аута. Таким образом, группа серверов времени включает только наилучших кандидатов, которые отправили наиболее приемлемые ответные NTP-сообщения для обслуживания системного времени.</p><h2 id="p4">4. Определения</h2><p>Шкала (масштаб) времени (timescale) представляет собой систему отсчёта эталонного источника, в которой время выражается с помощью монотонно возрастающего значения бинарного счётчика с бесконечным числом битов. Он считает секунды и доли секунды, когда используется десятичная дробь. Шкала Всеобщего скоординированного времени (Coordinated Universal Time — UTC) определена Рекомендацией Международного союза электросвязи ITU-R TF.460<sup><abbr title="International Telecommunications Union, «ITU-R TF.460 Standard-frequency and time-signal emissions», Февраль 2002.">[?]</abbr></sup>. Под протекторатом Метрической конвенции 1865 года (Metre Convention of 1865), в 1975 году Международное бюро мер и весов (International Bureau of Weights and Measures — IBWM<sup><abbr title="Международное бюро мер и весов (французское название — Bureau International des Poids et Mesures) — постоянно действующая международная организация со штаб-квартирой, расположенной в г.Севр (предместье Парижа, Франция). Учреждено в 1875 г., вместе с подписанием Метрической конвенции. Основная задача Бюро заключается в обеспечении существования единой системы измерений во всех странах-участницах этой конвенции. В МБМВ хранятся международные эталоны основных единиц и выполняются международные метрологические работы, связанные с разработкой и хранением международных эталонов и сличением национальных эталонов с международными и между собой. В МБМВ также проводятся исследования в области метрологии, направленные на увеличение точности измерений. Бюро финансируется странами-участницами Метрической конвенции.">[?]</abbr></sup>) строго рекомендовало использовать UTC-время в качестве основы гражданского времени.</p><p>Шкала UTC-времени представляет собой усреднённое значение солнечного времени, распространяемое лабораториями национальных стандартов времени/частоты. Системное время представляет собой показание системных часов, обслуживаемых аппаратно-программным комплексом и операционной системой (ОС). Назначение NTP-алгоритмов состоит в минимизации различий по времени и по частоте между UTC-временем и системным временем. Когда эти различия снижаются до номинальных допустимых значений, то тогда говорят, что системное время синхронно относительно UTC-времени.</p><p>Дата события представляет собой значение UTC-времени, когда это событие имело место. Даты являются кратковременными величинами, обозначаемыми символом <code>Т</code> (в верхнем регистре). Текущее время является иной шкалой времени, которая совпадает с функцией синхронизации программного NTP-модуля.</p><p>Метка времени <code>T(t)</code> представляет собой, либо UTC-дату, либо сдвиг текущего времени <code>t</code> относительно UTC-времени. Сущность метки времени должна вытекать из содержания NTP-сообщения. Пусть <code>T(t)</code> — сдвиг времени, <code>R(t)</code> — сдвиг частоты, <code>D(t)</code> — скорость ухода частоты (первая производная <code>R(t)</code> относительно <code>t</code>). Тогда, если <code>T(t<sub>0</sub>)</code> — сдвиг UTC-времени, определённый в момент времени <code>t = t<sub>0</sub></code>, сдвиг UTC-времени в момент времени <code>t</code>:</p><pre>T(t) = T(t<sub>0</sub>) + R(t<sub>0</sub>)(t-t<sub>0</sub>) + ½ × D(t<sub>0</sub>)(t-t<sub>0</sub>)<sup>2</sup> + ε</pre><p>где <code>ε</code> — стохастическая ошибка. Несмотря на то, что параметр <code>D(t)</code> очень важен при описании прецизионных генераторов частоты, им, в принципе, можно пренебречь при описании компьютерных генераторов частоты. В данном стандарте все значения времени представляются в секундах, а значения частоты — в секундах за одну секунду (сек/сек). Иногда для описания сдвигов частоты используются промили — число миллионный долей (parts-per-million — PPM), одна промиля равна 10<sup>-6</sup> сек/сек.</p><p>В прикладных компьютерных системах синхронизации очень важно оценить эффективность функции (процедуры) обеспечения синхронизации. Модель эффективности NTP-протокола включает четыре статистических параметра, которые обновляются при каждом обращении клиента к серверу времени для проведения измерительных процедур. <em>Сдвиг</em> <code>θ</code> представляет собой максимально правдоподобный сдвиг времени серверных часов относительно системного времени. <em>Задержка</em> <code>δ</code> представляет собой задержку по времени при передачи пакета по замкнутому (петлевому) маршруту между клиентом и сервером времени. <em>Дисперсия</em> <code>ε</code> представляет собой максимальную естественную ошибку, возникающую при измерениях времени/частоты. Дисперсия увеличивается до значения, которое равно максимальному допустимому отклонению частоты (<code>φ</code>) корректируемых системных часов, обычно 15 РРМ. <em>Джиттер</em> <code>ψ</code> определяется как среднеквадратическое значение сдвига (отклонение времени/частоты), и представляет собой номинальную ошибку при оценивании сдвига.</p><p>Несмотря на то, что все эти четыре параметра представляют собой раздельно измеренные значения системного времени относительно каждого сервера времени, NTP-протокол включает ряд процедур для суммирования этих параметров нескольких серверов с целью более точной коррекции и калибровки системного времени. <em>Системный сдвиг</em> <code>Θ</code> представляет собой максимально правдоподобную оценку сдвига всей совокупности серверов времени. Системный джиттер <code>Ψ</code> представляет собой номинальную ошибку при оценивании системного сдвига. Параметры <code>δ</code> и <code>ε</code> накапливаются на каждом уровне (номер <code>слоя</code>), начиная от эталонных часов, что приводит к образованию корневой задержки <code>Δ</code> и корневой дисперсии <code>Ε</code>, также являющимися статистическими параметрами. Расстояние синхронизации <code>Λ</code> равно: <code>Ε + Λ/2</code>, — и представляет собой максимальную ошибку, которая является следствием всех возможных причин её возникновения. Эти параметры присущи всем прикладным системам, которые зависят от оценивания эффективности функции (процедуры) обеспечения синхронизации.</p><h2 id="p5">5. Модель реализации</h2><p>На рис.3 представлена структура типовой многоканальной модели прикладного программного модуля NTPv4-протокола. Эта модель включает два процесса, присущие каждому серверу времени:</p><ol class="lia"><li><p>Процесс удалённого сервера времени, обеспечивающий приём NTP-сообщений от другого сервера времени или источника эталонного времени.</p></li><li><p>Процесс опроса удалённых серверов времени, обеспечивающий передачу NTP-сообщений другому удалённому серверу времени или источнику эталонного времени.</p></li></ol><p>Эти процессы организуют передачу, приём и обработку NTP-сообщений, представляющих собой единую структуру данных, включающих статистические параметры и другие переменные и константы, и для этого формируют виртуальные соединения. Клиентский программный NTP-модуль передаёт NTP-сообщения одному или нескольким серверам времени, а затем обрабатывает переданные ими ответные NTP-сообщения. Серверный программный NTP-модуль меняет местами IP-адреса и номера UDP-портов отправителя/получателя, заполняет определённые поля в NTP-сообщении и сразу после этого отправляет его источнику запроса, если используется режим функционирования «клиент/сервер», в противном случае, если используется симметричный режим функционирования, NTP-сообщение передается через некоторое время. После каждого приёма NTP-сообщения вычисляется сдвиг <code>θ</code> между временем удалённого сервера и системными часами, используя для этого соответствующие значения статистических параметров <code>δ</code>, <code>ε</code> и <code>ψ</code>.</p><pre>..........................................................................................
. Удалённые .      Процедуры      .             Системный              .     Процесс     .
.  серверы  .  опроса удалённых   .              процесс               .    настройки    .
.           .      серверов       .                                    .     времени     .
.+---------+. +------------------+. +---------------+                  .                 .
.| Сервер  |-&gt;| Опрос удаленного |. |               |                  .                 .
.| времени |  | сервера времени  |-&gt;|               |                  .                 .
.|    1    |&lt;-|        1         |. |               |                  .                 .
.+---------+. +------------------+. |               |                  .                 .
.           .          ^          . |               |                  .                 .
.           .          |          . |               |                  .                 .
.+---------+. +------------------+. |               |  +--------------+.                 .
.| Сервер  |-&gt;| Опрос удаленного |. |   Алгоритмы   |-&gt;|              |.   +--------+    .
.| времени |  | сервера времени  |-&gt;|   селекции    |  |   Алгоритм   |---&gt;| Фильтр |    .
.|    2    |&lt;-|        2         |. |       и       |  | суммирования |.   |  ФАПЧ  |    .
.+---------+. +------------------+. | кластеризации |-&gt;|              |.   +--------+    .
.           .          ^          . |               |  +--------------+.        |        .
.           .          |          . |               |                  .        |        .
.+---------+. +------------------+. |               |                  .        |        .
.| Сервер  |-&gt;| Опрос удаленного |. |               |                  .        |        .
.| времени |  | сервера времени  |-&gt;|               |                  .        |        .
.|    3    |&lt;-|        3         |. |               |                  .        |        .
.+---------+. +------------------+. +---------------+                  .        |        .
........................^.......................................................|.........
                        |                                              .        V        .
                        |                                              . +------------+  .
                        |                                              . | Генератор  |  .
                        +------------------------------------------------| переменной |  .
                                                                       . |  частоты   |  .
                                                                       . +------------+  .
                                                                       .     Процесс     .
                                                                       .  корректировки  .
                                                                       .      часов      .
                                                                       ...................

Рис.3. Модель прикладного программного модуля NTPv4-протокола</pre><p>Системный процесс<sup><abbr title="В данном случае системный процесс назван так потому, что он является системным с точки зрения NTP-протокола, а с точки зрения операционной системы сервера или персонального компьютера клиента он является прикладным NTP-процессом.">[?]</abbr></sup> включает процедуры селекции, кластеризации и суммирования на основе соответствующих алгоритмов оптимизации, и осуществляет поиск среди возможных серверов времени наиболее «лучших» кандидатов, с точки зрения их точности и надежности, для последующей синхронизации системных часов. Алгоритм селекции основан на византийских принципах обнаружения неисправностей или отказов и решает задачу по нейтрализации самых некорректных кандидатов, именуемых «ложными часами», и предотвращения их включения в перечень (группу) «надёжных часов». Надёжные часы представляют собой такие часы, которые обеспечивают соответствующую точность синхронизации относительно известного доверенного стандартного источника времени/частоты (синхронизируются от него), в то время как ложные часы представляют собой часы, которые показывают ложное или неточное время. Алгоритм кластеризации основан на статистических принципах и обеспечивает поиск группы часов, включающей наиболее точные надежные часы. Алгоритм суммирования (объединения) решает задачу вычисления финального значения сдвига времени путём статистического усреднения значений наиболее точных надёжных часов, прошедших алгоритм кластеризации.</p><p>Процедура корректировки часов представляет собой системный процесс, который управляет временем и частотой системных часов, а в модели реализации он представляет собой генератор переменной частоты (ГПЧ). Метки времени, формируемые ГПЧ, «замыкают» контур ФАПЧ, который управляет временем системных часов. Процесс, обеспечивающий подстройку часов, представляет собой процедуру корректировки времени, которая проводится раз в секунду с целью вставки вычисленного сдвига времени и поддержания постоянной частоты. Среднеквадратическое отклонение (сдвиг) времени представляет собой номинальную ошибку при оценивании сдвига или <em>джиттер системных часов</em>. Среднеквадратическое отклонение (сдвиг) частоты представляет собой стабильность частоты генератора или <em>отклонение частоты</em>.</p><p>Клиентский программный NTP-модуль передаёт NTP-сообщения каждому серверу времени с интервалом опроса, равным 2<sup>τ</sup> секунд. В NTPv4-стандарте <code>τ</code> имеет диапазон значений от 4 (16 секунд) до 17 (36 часов). Значение <code>τ</code> определяется с помощью алгоритма настройки часов целью его совпадения с временной константой контура ФАПЧ <code>Т<sup>с</sup> = 2<sup>τ</sup></code>. В режиме «клиент/сервер» сервер времени отвечает незамедлительно. Однако, в симметричном режиме каждый из двух удаленных серверов времени регулируют значение <code>τ</code> в зависимости от текущего системного сдвига и системного джиттера, и поэтому они могут не согласиться с применением одного и того же значения. Очень важно, чтобы динамическое поведение алгоритма настройки времени было под «чутким» контролем с целью поддержания стабильности в крупных NTP-подсетях. Это требует, чтобы удалённые серверы должны согласовывать единое значение <code>τ</code>, равное минимальному показателю степени среди двух серверов времени. NTPv4-протокол включает специальные средства для соответствующего согласования этого значения.</p><p>Модель реализации NTPv4-протокола включает специализированные средства для установки и корректировки системных часов. Полагается, ОС реализует две функции:</p><ol class="lia"><li><p>Прямая установка времени (например, ОС-Unix системный процесс <code>settimeofday</code>).</p></li><li><p>Корректировка времени в пределах небольшого диапазона (с помощью минимальных приращений), путём ускорения или замедления течения времени, с помощью вычисленного корректирующего значения (например, ОС-Unix системный процесс <code>adjtime</code>).</p></li></ol><p>Системный процесс <code>adjtime</code> используется при корректировке времени, если корректирующее значение не превосходит предельное значение, а системный процесс <code>settimeofday</code> — если превосходит предельное значение.</p><h2 id="p6">6. Типы данных (логическая харктеристика)</h2><p>Все значения NTP-времени представляются в бинарном формате (twos-complement format), в котором биты нумеруются, начиная с нуля, слева на право (причём крайний левый бит — бит высшего порядка или старший). В настоящее время существуют три формата NTP-времени:</p><ol class="lia"><li><p class="b">32-битовый укороченный формат (рис.4,1)</p><div class="lib"><p>Этот формат используется в полях заголовка NTP-сообщения, содержащих значения задержки и дисперсии, когда использование значений с высокой точностью или в более широком диапазоне не приемлемо. Он включает 16-битовое поле целых секунд и 16-битовое поле долей секунды.</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Секунды              |         Доли секунды          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Рис.4,1. 32-битовый укороченный формат NTP-времени</pre></div></li><li><p class="b">64-битовый формат метки времени (рис.4,2)</p><div class="lib"><p>Этот формат используется в заголовках NTP-сообщений или в других полях с ограниченной длиной. Он включает 32-битовое поле целых секунд (136 лет) и 32-битовое поле долей секунды (точность 232 пикосекунды).</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Секунды                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Доли секунды                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Рис.4,2. 64-битовый формат метки времени</pre></div></li><li><p class="b">128-битовый формат даты (рис.4,3)</p><div class="lib"><p>Этот формат используется только тогда, когда существует возможность хранения с достаточным объёмом памяти. Он включает 64-битовое поле целых секунд (584 млрд. лет) и 64-битовое поле долей секунды (0,05 аттосекунды или 0,5е<sup>-18</sup>). С целью согласования отображений между форматами поле целых секунд разделено на два субполя: 32-битовое поле номера эпохи и 32-битовое поле сдвига эпохи. Эпохи не могут напрямую формироваться NTP-протоколом, и в этом просто нет необходимости. Если это будет необходимо, то тогда номер эпохи может быть получен из внешних источников, например, из файловой системы или специализированного аппаратного устройства.</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Номер эпохи                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Сдвиг относительно точки отсчёта эпохи             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                         Доли секунды                          |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Рис.4,3. 128-битовый формат даты</pre></div></li></ol><p>В форматах даты и метки времени точкой отсчёта первичной эпохи, или основной датой нулевой эры (№0), является 00<sup><u>00</u></sup> часов 1 января 1900 года по UTC-шкале времени, когда все биты нулевые. Необходимо заметить, что строго говоря, UTC-времени не существовало до 1 января 1972 года, но существует договорённость о том, что оно существовало все вечность, и даже в случае, когда вся информация о применении вставочных секунд могла быть потеряна. Все даты определяются относительно первичной эпохи. Если значение даты больше чем нулевой, то она представляется временем после точки отсчёта первичной эпохи, если же — меньше, то она представляется временем до точки отсчёта первичной эпохи.</p><p class="note">Замечание. Поле «Сдвиг эпохи» в формате даты и поле «Секунды» в формате метки времени интерпретируются одинаково.</p><p>Метки времени представляют собой беззнаковые значения времени, а выполнение операций над ними приводит к результату, который относится к той же самой или смежной эпохе. Нулевая эра включает даты, начиная с точки отсчёта первичной эпохи до определённого момента времени в 2036 году, когда поле метки времени полностью заполниться единицами и в следующий момент времени обнулиться, и после этого начнётся первая эра (№1). В обоих форматах нулевое значение представляет собой особый случай, при котором неизвестно время или отсутствует возможность синхронизировать время. На рис.5 представлено несколько исторических NTP-дат и их значения в соответствие с Модифицированным Юлианским днём (Modified Julian Date — MJD), NTP-эпохой и NTP-меткой времени.</p><table><tr><th>Дата</th><th>MJD</th><th>NTP-эпоха (эра)</th><th>NTP-метка времени (сдвиг эпохи)</th><th>Сдвиг</th></tr><tr><td>1 января -4712 года</td><td>-2,400,001</td><td>-49</td><td>1,795,583,104</td><td>1-ый день Юлианского календаря</td></tr><tr><td>1 января -1 года</td><td>-679,306</td><td>-14</td><td>139,775,744</td><td>2 век до нашей эры</td></tr><tr><td>1 января 0 года</td><td>-678,491</td><td>-14</td><td>171,311,744</td><td>1 век до нашей эры</td></tr><tr><td>1 января 1 года</td><td>-678,575</td><td>-14</td><td>202,939,144</td><td>1 век нашей эры</td></tr><tr><td>4 октября 1582 года</td><td>-100,851</td><td>-3</td><td>2,873,647,488</td><td>Последний день Юлианского календаря</td></tr><tr><td>15 октября 1582 года</td><td>-100,840</td><td>-3</td><td>2,874,597,888</td><td>1-ый день Григорианского календаря</td></tr><tr><td>31 декабря 1899 года</td><td>15019</td><td>-1</td><td>4,294,880,896</td><td>Последний день NTP-эпохи -1 (эра № -1)</td></tr><tr><td>1 января 1900 года</td><td>15020</td><td>0</td><td>0</td><td>Первый день NTP-эпохи 0 (эра № 0)</td></tr><tr><td>1 января 1970 года</td><td>40,587</td><td>0</td><td>2,208,988,800</td><td>Первый день UNIX-эпохи</td></tr><tr><td>1 января 1972 года</td><td>41,317</td><td>0</td><td>2,272,060,800</td><td>Первый день UTC-эпохи</td></tr><tr><td>31 декабря 1999 года</td><td>51,543</td><td>0</td><td>3,155,587,200</td><td>Последний день 20-го века</td></tr><tr><td>8 февраля 2036 года</td><td>64,731</td><td>1</td><td>63,104</td><td>Первый день NTP-эпохи 1 (эра № 1)</td></tr><tr><th colspan="5">Рис.5. Наиболее интересные исторические NTP-даты</th></tr></table><p>Пусть <code>p</code> будет число старших битов, отведенных для дробной части секунды. Тогда точность часов определяется выражением 2<sup>-p</sup> в секундах. С целью минимизации отклонения и содействия в формировании максимально непредсказуемых для нарушителя значений меток времени младшие биты должны быть установлены в форме реальной случайной последовательности битов. Точность часов представляет собой текущее время для считывания системного времени, в секундах.</p><p class="note">Замечание. Точность, определённая таким образом в этом стандарте, может быть больше или меньше, чем разрешение. Параметр <code>ρ</code>, используемый в данном стандарте для обозначения точности, всегда больше двух.</p><p>При обработке значений дат и меток времени допускается только одна арифметическая операция — вычитание по модулю два, в результате которого получается 127- или 63- битовое знаковое значение. Чрезвычайно необходимо, чтобы разности первого порядка между двумя датами сохраняли полную 128-битовую точность, а разности первого порядка между двумя метками времени сохраняли полную 64-битовую точность. Однако, разности обычно представляют собой весьма малые значения, как правило, сравнимые с коротким промежутком времени в несколько секунд, и поэтому они могут быть преобразованы в удвоенный формат с плавающей запятой (точкой) для последующей обработки, причём без снижения точности.</p><p>Очень важно, чтобы двоичные арифметические действия не отличались между собой при обработке знаковых и беззнаковых величин (несмотря на то, что их можно сравнивать по знаку в записи), в противном случае необходимо ввести указания по условному обозначению. Таким образом, даже на наличие различий между знаковыми датами и беззнаковыми метками времени, они обрабатываются одинаково. Существует опасность, связанная с вычислением 64-битовых меток времени перекрывающих границы эпох, например, в 2036 году, которая может привести к обнулению всех битов метки времени. Фактически, если клиент синхронизировался от сервера времени за 68 лет до начала действия протокола, то тогда всё равно будут иметь место корректные значения, даже не взирая на то, что клиент и сервер функционируют в граничащих эпохах.</p><p>Некоторые значения времени представлены в экспоненциальном формате, это относится к точности значений времени, временным константам и интервалам опроса. Для этого используется 8-битовый знаковый целочисленный формат, в котором секунды выражаются как двоичный логарифм (log<sub>2</sub>). Для обработки значений в этом формате допускается только две арифметических операции: увеличение или уменьшение. Например, если интервал опроса составляет 1024 секунды, то в экспоненциальной форме этот интервал будет равен 10.</p><p>Для преобразования системного времени в любой NTP-формат даты и метки времени необходимо, чтобы знать число секунд <code>s</code> от точки отсчёта первичной эпохи до значения системного времени. Для заданного <code>s</code> определяем:</p><pre>era = s / 2<sup>32</sup> и timestamp = s - era × 2<sup>32</sup></pre><p>которые имеют место и при положительных и отрицательных значениях даты. Для заданных значений эпохи (<code>era</code>) и метки времени (<code>timestamp</code>) определяем:</p><pre> s = era × 2<sup>32</sup> + timestamp</pre><p>Преобразование NTP-времени и системное время и наоборот может быть с незначительными ошибками, но это не является проблемой данного стандарта.</p><p class="note">Замечание. Число дней в нулевой эре (№0) на один больше, чем число дней в большинстве других эпох, и это не произойдет до тех пор, пока не наступит 2400 год эры №3.</p><h2 id="p7">7. Структуры данных</h2><p>Переменные состояния разделены по классам в соответствии с их функциональным предназначением:</p><ol class="lia"><li><p><em>Пакетные переменные</em> представляют собой величины, размещаемые в заголовках NTP-сообщений, которые, в свою очередь, содержаться в передаваемых и принимаемых IP-пакетах.</p></li><li><p><em>Переменные удаленного сервера и процедуры опроса</em> представляют собой величины, которыми обменивается каждый сервер по отдельному виртуальному соединению.</p></li><li><p><em>Системные переменные</em> представляют собой величины, которые описывают состояние сервера времени, то есть как оно понимается зависимыми от него клиентами.</p></li><li><p><em>Переменные настройки часов</em> представляют собой величины, которые используются во внутренних процессах обработки параметров при реализации алгоритма настройки часов.</p></li><li><p><em>Дополнительные классы параметров и переменных</em>.</p></li></ol><table><tr><th>Обозначение</th><th>Описание</th></tr><tr><td>r.</td><td>Переменная в заголовке принятого NTP-сообщения</td></tr><tr><td>x.</td><td>Переменная в заголовке переданного NTP-сообщения</td></tr><tr><td>p.</td><td>Переменная удалённого сервера/опроса</td></tr><tr><td>s.</td><td>Системная переменная</td></tr><tr><td>c.</td><td>Переменная настройки часов</td></tr><tr><th colspan="2">Рис.6. Условные обозначения префиксов</th></tr></table><h3 id="p7.1">7.1. Условные обозначения структур данных</h3><p>С целью установления различия между переменными с одним и тем же именем, но используемых в различных процедурах, вводятся их условные обозначения, представленные на рис.6. Переменная в принятом NTP-сообщении <code>v</code> является составным элементом пакетной структуры <code>r</code> и имеет полное наименование <code>r.v</code>. аналогично обозначает переменная в переданном NTP-сообщении — <code>x.v</code>, переменная удалённого сервера — <code>p.v</code>, системная переменная — <code>s.v</code>, и переменная настройки часов — <code>с.v</code>. Для каждого виртуального соединения устанавливаются переменные удалённого сервера. Системные переменные и переменные часов устанавливаются только один раз.</p><h3 id="p7.2">7.2. Общие параметры</h3><p>В данном стандарте помимо классов переменных представлены несколько общих параметров, часть которых представлена на рис.7.</p><table><tr><th>Наименование</th><th>Значение параметра</th><th>Описание</th></tr><tr><td>PORT</td><td>123</td><td>Номер транспортного порта NTP-протокола</td></tr><tr><td>VERSION</td><td>4</td><td>Номер версии NTP-протокола</td></tr><tr><td>TOLERANCE</td><td>15e<sup>-6</sup></td><td>Допустимое отклонение частоты <code>φ</code> (сек/сек)</td></tr><tr><td>MINPOLL</td><td>4</td><td>Минимальное экспоненциальное значение интервала опроса (16 сек)</td></tr><tr><td>MAXPOLL</td><td>17</td><td>Максимальная экспоненциальное значение интервала опроса (36 часов)</td></tr><tr><td>MAXDISP</td><td>16</td><td>Максимальная дисперсия (16 сек)</td></tr><tr><td>MINDISP</td><td>0,005</td><td>Минимальная дисперсия/приращение (сек)</td></tr><tr><td>MAXDIST</td><td>1</td><td>Пороговое расстояние (1 сек)</td></tr><tr><td>MAXSTRAT</td><td>16</td><td>Максимальный номер «слоя»</td></tr><tr><th colspan="3">Рис.7. Общие параметры</th></tr></table><p>В любой прикладной системе таких общих параметров гораздо больше, а их число зависит от самой прикладной системы. Некоторые из общих параметров записываются в постоянное запоминающее устройство (ПЗУ), например, номер порта транспортного уровня, утверждённый IANA. Другие общие параметры, например допустимое отклонение частоты (<code>φ</code>), касаются предположения о наиболее худшем функционировании системных часов после их синхронизации и последующем допустимом дрейфе в условиях потери связи с источниками синхронизации (синхроисточники). В частности, это относится к максимальным и минимальным значениям параметров, определяющих границы переменных состояния.</p><p>Некоторые прикладные системы могут настраивать и управлять своими переменными с помощью специализированных команд настройки. Например, прикладной эталонный источник вычисляет значение точности <code>PRECISION</code> как логарифм двух (log<sub>2</sub>) от минимального значения времени за несколько итераций при считывании системного времени.</p><h3 id="p7.3">7.3. Переменные в заголовке NTP-сообщения</h3><p>Наиболее важными переменными состояния, с объективной точки зрения, являются переменные в заголовке NTP-сообщения (рис.8). Заголовок NTP-сообщения включает целое число 32-битовых (4-октета) слов, расположенных в порядке их последовательной передачи по сети. NTP-сообщение включает три следующих компонента:</p><ol class="lia"><li>собственно заголовок;</li><li>одно или несколько дополнительных полей расширения;</li><li>дополнительный код аутентификации сообщения (Message Authentication Code — MAC).</li></ol><table><tr><th>Наименование</th><th>Обозначение</th><th>Описание</th></tr><tr><td>leap</td><td>leap</td><td>Индикатор перехода через 00<sup><u>00</u></sup> часов</td></tr><tr><td>version</td><td>version</td><td>Номер версии NTP-протокола</td></tr><tr><td>mode</td><td>mode</td><td>Режим функционирования</td></tr><tr><td>stratum</td><td>stratum</td><td>Номер «слоя»</td></tr><tr><td>poll</td><td>poll</td><td>Экспоненциальное значение интервала опроса</td></tr><tr><td>precision</td><td>ρ</td><td>Экспоненциальное значение точности</td></tr><tr><td>rootdelay</td><td>Δ<sub>r</sub></td><td>Коневая задержка</td></tr><tr><td>rootdisp</td><td>Ε<sub>r</sub></td><td>Коневая дисперсия</td></tr><tr><td>refid</td><td>refid</td><td>Идентификатор эталонного источника</td></tr><tr><td>reftime</td><td>reftime</td><td>Значение (метка) времени эталонного источника</td></tr><tr><td>org</td><td>T<sub>1</sub></td><td>Метка времени клиента при отправке NTP-сообщения серверу</td></tr><tr><td>rec</td><td>T<sub>2</sub></td><td>Метка времени сервера при получении NTP-сообщения клиента</td></tr><tr><td>xmt</td><td>T<sub>3</sub></td><td>Метка времени сервера при отправке NTP-ответа клиенту</td></tr><tr><td>dst</td><td>T<sub>4</sub></td><td>Метка времени клиента при получении NTP-ответа сервера</td></tr><tr><td>keyid</td><td>keyid</td><td>Идентификатор криптоключа</td></tr><tr><td>MAC</td><td>MAC</td><td>Проверочная аутентификационная сумма сообщения</td></tr><tr><th colspan="3">Рис.8. Переменные в заголовке NTP-сообщения</th></tr></table><pre>|0                          7|8       15|16         23|24       31|
+-----------+--------+-------+----------+-------------+-----------+
| Индикатор | Номер  |       |  Номер   |  Интервал   |           |
| перехода  | версии | Режим | "слоя"   |   опроса    | Точность  |
|    (2)    |  (3)   |  (3)  |   (8)    |    (8)      |    (8)    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Корневая задержка (32)                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Корневая дисперсия (32)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|              Идентификатор источника времени (32)               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                                 |
+         Метка времени источника эталонного времени (64)         +
|                                                                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                                 |
+        Метка времени отправки NTP-сообщения серверу (64)        +
|                                                                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                                 |
+ Метка времени сервера при получении NTP-сообщения клиента (64)  +
|                                                                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                                 |
+   Метка времени сервера при отправке NTP-ответа клиенту (64)    +
|                                                                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                                 |
.                                                                 .
.            Первое поле расширения (переменная длина)            .
.                                                                 .
|                                                                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                                 |
.                                                                 .
.            Второе поле расширения (переменная длина)            .
.                                                                 .
|                                                                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Идентификатор криптоключа (32)                  | \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \
|                                                                 |   > MАС-поле
|            Криптографическая проверочная сумма (128)            |  /
|                                                                 | /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Рис.9. Формат заголовка NTP-сообщения</pre><p>Собственно заголовок идентичен заголовкам NTP-сообщение всех предшествующих версий. Дополнительные поля расширения используются ассиметричными криптоалгоритмами Autokey-протокола. МАС-поле используется совместно Autokey-протоколом и симметричным криптоалгоритмом.</p><p>NTP-сообщение размещается в поле полезной нагрузки UDP-блока (RFC-768). Некоторые поля включают несколько 32-битовых слов, а другие размещаются в составе одного 32-битового слова. Заголовок NTP-сообщения представлен на рис.9, он включает двенадцать 32-битовых слов и завершается дополнительными полями расширения и кодом аутентификации сообщения, содержащее поле идентификатора криптоключа и поле проверочной аутентификационной суммы сообщения. Поля расширения используются для обеспечения дополнительных функциональных возможностей (свойств), например, использование Autokey-протокола. Формат поля расширения выбран так, чтобы при анализе содержания сообщения не нужно было бы иметь какую-либо информацию о функциях этого поля.</p><p>Основной заголовок NTP-сообщения начинается с первого бита сообщения до конца поля «Метка времени сервера при отправке NTP-ответа клиенту» (Transmit Timestamp).</p><p>Назначение и кодирование полей NTP-сообщения следующие:</p><ol class="lia"><li><p class="b">«Leap Indicator» (LI):</p><div class="lib"><p>Индикатор перехода — 2-битовый код, указывающий на использование секунд перехода через 00<sup><u>00</u></sup> часов, которые будут вставлены или удалены на последней минуте текущего дня, и имеющий следующую кодировку:</p><table><tr><th>Код</th><th>Значение</th></tr><tr><td>00</td><td>Предупреждение отсутствует</td></tr><tr><td>01</td><td>Последняя минута содержит 61 секунду</td></tr><tr><td>10</td><td>Последняя минута содержит 59 секунд</td></tr><tr><td>11</td><td>Состояние «тревоги» (часы не синхронизированы)</td></tr></table></div><li><p class="b">«Version Number» (VN):</p><p class="lib">Номер версии NTP-протокола — 3-битовый целочисленный код. Текущая версия <code>4</code>.</p></li><li><p class="b">«Mode»:</p><div class="lib"><p>Режим функционирования — 3-битовый целочисленный код. Имеет следующую кодировку:</p><table><tr><th>Код</th><th>Значение</th></tr><tr><td>0</td><td>Зарезервировано</td></tr><tr><td>1</td><td>Симметричный активный режим</td></tr><tr><td>2</td><td>Симметричный пассивный режим</td></tr><tr><td>3</td><td>Клиент</td></tr><tr><td>4</td><td>Сервер</td></tr><tr><td>5</td><td>Широковещательный режим</td></tr><tr><td>6</td><td>Зарезервировано для управляющих NTP-сообщений</td></tr><tr><td>7</td><td>Зарезервировано для частного использования</td></tr></table></div></li><li><p class="b">«Stratum»:</p><div class="lib"><p>Номер «слоя» — 8-битовый целочисленный код, определяющий уровень иерархии, на котором расположен сервер времени. Имеет следующую кодировку:</p><table><tr><th>Код</th><th>Значение</th></tr><tr><td>0</td><td>Не определено или недопустим</td></tr><tr><td>1</td><td>Первичный сервер (например, через GPS-приёмник)</td></tr><tr><td>2-15</td><td>Вторичный сервер (через NTP-протокол)</td></tr><tr><td>16</td><td>Не синхронизировано</td></tr><tr><td>17-255</td><td>Зарезервировано</td></tr></table><p>Обычно, нулевое значение номер «слоя» в принятых NTP-сообщениях отображается в значение <code>MAXSTRAT (16)</code> переменной удалённого сервера <code>p.stratum</code>, а передаваемых NTP-сообщениях отображается в переменную <code>p.stratum</code> со значением <code>MAXSTRAT (16)</code> или большим, чем ноль. Это правило позволяет эталонным часам, которые, как правило, расположены на нулевом уровне иерархии, достаточно просто использовать те же алгоритмы, которые используются при работе с внешними источниками;</p></div></li><li><p class="b">«Poll»:</p><p class="lib">Интервал опроса — 8-битовый целочисленный знаковый код, определяющий максимальный интервал между успешно переданными NTP-сообщениями (в секундах, как log<sub>2</sub>). Максимальное и минимальное значения интервала, которые предлагаются использовать «по умолчанию», — 6 и 10, соответственно;</p></li><li><p class="b">«Precision»:</p><p class="lib">Точность — 8-битовый целочисленный знаковый код, определяющий точность локальных часов (в секундах, как log<sub>2</sub>). Например, значение <code>-18</code> соответствует точности приблизительно одной микросекунде. Точность может быть определена при первом запуске службы времени, как минимальное время полученное за несколько итераций при считывании системного времени;</p></li><li><p class="b">«Root Delay»:</p><p class="lib">Корневая задержка определяет общую задержку петлевого маршрута до эталонного источника, 32-битовый укороченный формат NTP-времени (рис.4,1);</p></li><li><p class="b">«Root Dispersion»:</p><p class="lib">Корневая дисперсия определяет максимальную ошибку времени относительно эталонного источника, 32-битовый укороченный формат NTP-времени (рис.4,1);</p></li></ol><ol class="lia" start="9"><li><p class="b">«Reference ID» (refid):</p><div class="lib"><p>Идентификатор источника времени — 32-битовый код, определяющий эталонные часы или соответствующий сервер времени. Конкретная интерпретация идентификатора зависит от значения в поле «Номер "слоя"». Если в NTP-сообщении указан нулевой номер «слоя» (не определён или не допустим), то тогда идентификатор кодируется как 4-символьная ASCII-последовательность (RFC-1345), именуемая как «the kiss code» (код «помощи»<sup><abbr title="Это специальный сленг. Существует фраза «kiss of life», которая переводится как способ искусственного дыхания (вдувание воздуха изо рта в рот). Поэтому фразу «the kiss code» можно перевести как «вспомогательная команда», предназначенная для проведения технологических процедур мониторинга и устранения неисправностей.">[?]</abbr></sup>) и используемая для отладки и мониторинга. Если в NTP-сообщении указан номер «слоя» один (эталонные часы), то тогда идентификатор — 4-октетная ASCII-последовательность, дополняемая нулями слева, и указывающая на конкретные эталонные часы. IANA утвердила официальный перечень идентификаторов источников эталонного времени. Однако, любая символьная последовательность, начинающаяся с символа <code>Х</code>, зарезервирована для проведения разного рода исследований и дальнейшего совершенствования системы. Далее приводятся наиболее часто используемые ASCII-идентификаторы:</p><table><tr><th>ID</th><th>Источник сигнала времени</th></tr><tr><td>GOES</td><td>Геостационарный спутник системы экологического мониторинга и наблюдения</td></tr><tr><td>GPS</td><td>Глобальная система местоопределения</td></tr><tr><td>GAL</td><td>Система местоопределения «Галилео»</td></tr><tr><td>PPS</td><td>Общий радиосигнал с длительностью импульса, равной 1 секунде</td></tr><tr><td>IRIG</td><td>Группа стандартизации в телеметрии, США</td></tr><tr><td>WWVB</td><td>Низкочастотный радиопередатчик, 60 кГц, Форт Коллинз, Колорадо, США</td></tr><tr><td>DCF</td><td>Низкочастотный радиопередатчик, 77.5 кГц, DCF77, Майнфлинген, ФРГ</td></tr><tr><td>HBG</td><td>Низкочастотный радиопередатчик, 75 кГц, Прангинс, Швейцария</td></tr><tr><td>MSF</td><td>Низкочастотный радиопередатчик, 60 кГц, Антхорн, Великобритания</td></tr><tr><td>JJY</td><td>Низкочастотный радиопередатчик, 40 кГц, Фукушима, 60 кГц, Сага, Япония</td></tr><tr><td>LORC</td><td>Среднечастотный радиопередатчик, 100 кГц, радионавигация, LORAN-C</td></tr><tr><td>TDF</td><td>Среднечастотный радиопередатчик, 162 кГц, Аллоуис, Франция</td></tr><tr><td>CHU</td><td>Высокочастотный радиопередатчик, Оттава, Онтарио, Канада</td></tr><tr><td>WWV</td><td>Высокочастотный радиопередатчик, Форт Коллинз, шт.Колорадо, США</td></tr><tr><td>WWVH</td><td>Высокочастотный радиопередатчик, Кауаи, Гавайи, США</td></tr><tr><td>NIST</td><td>Телефонный модем Национального института стандартов и технологий США</td></tr><tr><td>ACTS</td><td>Телефонный модем Автоматизированной службы компьютерного времени США</td></tr><tr><td>USNO</td><td>Телефонный модем Национальной обсерватории США</td></tr><tr><td>PTB</td><td>Телефонный модем Национального метрологического института ФРГ</td></tr></table><p>Если номер «слоя» равен двум или больше (вторичные серверы времени и клиенты), то тогда идентификатор обозначает сервер времени и может использоваться для выявления петлевых маршрутов синхронизации. Если используется IPv4-адресация, то тогда идентификатор представляет собой IPv4-адрес. Если используется IPv6-адресация, то тогда идентификатор представляет собой первые четыре октета результата хеширования (MD5-алгоритм, RFC-1321), IPv6-адреса.</p><p class="note">Замечание. Когда NTPv4-сервер времени использует IPv6-адресацию, а клиентский программный NTP-модуль — IPv4-адресацию, то тогда поле «Reference ID» может содержать случайную величину, что исключает возможность выявления петлевых маршрутов синхронизации.</p></div></li><li><p class="b">«Reference Timestamp»:</p><p class="lib">время, когда системные часы были установлены или скорректированы в последний раз, в 64-битовом NTP-формате метки времени (рис.4,2);</p></li><li><p class="b">«Originate Timestamp» (org):</p><p class="lib">время в программном NTP-модуле клиента, которое определяет время отправки им NTP-запроса на удаленный сервер времени, в 64-битовом NTP-формате метки времени (рис.4,2);</p></li><li><p class="b">«Receive Timestamp» (rec):</p><p class="lib">время в программном NTP-модуле сервера, которое определяет время получения им NTP-запроса от клиента, в 64-битовом NTP-формате метки времени (рис.4,2);</p></li><li><p class="b">«Transmit Timestamp» (xmt):</p><p class="lib">время в программном NTP-модуле сервера, которое определяет время отправки им NTP-ответа клиенту, в 64-битовом NTP-формате метки времени (рис.4,2);</p></li><li><p class="b">«Destination Timestamp» (dst):</p><div class="lib"><p>время в программном NTP-модуле клиента, которое определяет время получения им NTP-ответа от удаленного сервера времени, в 64-битовом NTP-формате метки времени (рис.4,2).</p><p class="note">Замечание. Поле «Destination Timestamp» не включается в заголовок NTP-сообщения, так как оно определяется только после приёма NTP-сообщения и становится доступным в соответствующем буфере, в котором временно храниться поступившее NTP-сообщение.</p><p>Если программный NTP-модуль имеет доступ к физическому уровню Internet-архитектуры, то тогда метки времени соответствуют началу символов после начала кадра канального уровня. В противном случае, прикладные службы должны попытаться «привязать» метку времени к самой ранней доступной точке кадра канального уровня;</p></div></li><li><p class="b">«Extension Field»:</p><p class="lib">Дополнительное поле расширения, формат которого представлен в разделе 7.5;</p></li><li><p class="b">«Key Identifier» (keyid):</p><p class="lib">идентификатор ключа — 32-битовое беззнаковое целочисленный код, используемый клиентом и сервером для указания секретного 128-битового MD5-ключа;</p></li><li><p class="b">«Message Digest» (digest):</p><p class="lib">криптографическая проверочная сумма — 128-битовая последовательность, вычисленная с помощью MD5-алгоритма хеширования и секретного криптоключа по всей последовательности NTP-заголовка, включая дополнительные поля расширения, но не включая поля «Key Identifier» и «Message Digest».</p></li></ol><h3 id="p7.4">7.4. NTP-сообщение «Kiss-o'-Death»</h3><p>Если имеет место нулевой номер «слоя», который считается не определённым или не допустимым, поле «Reference Identifier» может использоваться для доставки сообщений, которые выполняют роль данных о состоянии системы и управления доступом. Такие сообщения называются «Kiss-o'-Death»<sup><abbr title="Это специальный сленг. Эта фраза переводится как «последний удар» или «последняя попытка».">[?]</abbr></sup> (KoD), а доставляемые ими ASCII-данные называются «kiss codes» (коды «помощи»). KoD-сообщения получили своё название потому, что ранее они использовались для информирования клиентов о прекращении передачи сообщений, которые нарушают управление доступом к серверу. Коды «помощи» могут быть весьма полезными, с точки зрения информирования «интеллектуального» программного клиентского NTPv4- или SNTPv4-модуля. Такие коды представляют собой 4-символьные ASCII-последовательности, дополняемые слева нулями. Эти последовательности предназначены для вывода на дисплей и записи в файлы. Перечень принятых в настоящее время кодов «помощи» представлен на рис.10.</p><p>Получатели KoD-сообщений обязаны их проверить и выполнить следующие действия:</p><ul class="lat lia"><li><p>При получении кодовых комбинаций <code>DENY</code> и <code>RSTR</code> клиент обязан разорвать виртуальные соединения с данным сервером времени и прекратить передачу сообщений этому серверу.</p></li><li><p>При получении кодовой комбинации <code>RATE</code> клиент обязан незамедлительно снизить свой интервал опроса этого сервера и продолжать его уменьшать каждый раз при получении этой кодовой комбинации.</p></li><li><p>При получении кодовой комбинации начинающейся с ASCII-символа <code>Х</code>, предназначенной для проведения экспериментальных исследований и последующих усовершенствований, она должна быть проигнорирована, если она не распознаётся.</p></li><li><p>Все другие кодовые комбинации и KoD-сообщения, не определённые данным протоколом, уничтожаются после их поверки.</p></li></ul><table><tr><th>Код</th><th>Описание</th></tr><tr><td>ACST</td><td>Виртуальное соединение установлено одноадресным сервером</td></tr><tr><td>AUTH</td><td>Аутентификация сервером завершилась отказом</td></tr><tr><td>AUTO</td><td>Autokey-последовательность некорректна</td></tr><tr><td>BCST</td><td>Виртуальное соединение установлено широковещательным сервером</td></tr><tr><td>CRYP</td><td>Криптографическая аутентификация или идентификация завершились отказом</td></tr><tr><td>DENY</td><td>Удалённый сервер отказал в доступе</td></tr><tr><td>DROP</td><td>Потеря удаленного сервера времени в симметричном режиме</td></tr><tr><td>RSTR</td><td>Отказ в доступе в следствие локальной стратегии безопасности</td></tr><tr><td>INIT</td><td>Виртуальное соединение с первого раза не установлено</td></tr><tr><td>MCST</td><td>Виртуальное синхросоединение установлено динамически обнаруженным сервером</td></tr><tr><td>NKEY</td><td>Ключ не найден (либо он никогда ранее не загружался, либо он является ненадёжным)</td></tr><tr><td>RATE</td><td>Скорость превышена. Сервер временно запретил доступ, так как клиент превысил порог скорости</td></tr><tr><td>RMOT</td><td>Изменение виртуального соединения со стороны удалённого IP-узла, использующего NTP-протокол напрямую</td></tr><tr><td>STEP</td><td>Произошла итерация по изменению системного времени, виртуальное синхросоединение не установлено</td></tr><tr><th colspan="2">Рис.10. Описание кодов «помощи»</th></tr></table><p>Метки времени «Receive Timestamp» и «Transmit Timestamp», установленные сервером, не обрабатываются, когда они присутствуют в KoD-сообщении, не должны рассматриваться как надёжные значения времени поэтому должны уничтожаться.</p><h3 id="p7.5">7.5. Формат дополнительного поля расширения</h3><p>В NTPv4-заголовок может быть добавлено одно или несколько поле расширения (между основным заголовком и МАС-полем, которое всегда должно присутствовать при наличии полей расширения). Правила кодирования и семантика этого поля не являются предметом рассмотрения данного стандарта. Формат дополнительного поля расширения представлен на рис.11.</p><p>Все поля расширения дополняются нулям до границы 32-битововго слова. Поле «Тип поля расширения» («Field Type») предназначено для указания функции, которую выполняет это поле (в данном стандарте его кодирование не рассматривается). Минимальный размер поля расширения составляет 16 октетов, тогда как максимальный размер — не стандартизован.</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Тип поля расширения      |     Длина поля расширения     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.                               |                               .
.                           Значение                            .
.                                                               .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|              Дополнение нулями (если необходимо)              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Рис.11. Формат дополнительного поля расширения</pre><p>Поле «Размер поля расширения» («Length») представляет собой 16-битовое беззнаковое целое число, которое предназначено для указания размера всего поля расширения включая поле «Дополнение нулями».</p><h2 id="p8">8. Процедурная характеристика протокола</h2><p>Основой процедурной характеристики NTPv4-протокола является процесс (алгоритм), который обеспечивает обмен значениями времени между серверами, удаленными серверами и клиентами. Он обеспечивает защиту от потери или дублирования NTPv4-сообщений. Целостность данных обеспечивается с помощью проверочных сумм IP- и UDP-протоколов. Протокол не обеспечивает управление потоком и процедуру повторной передачи, более того, в этом нет необходимости. Протокол использует метки времени, при этом они, либо извлекаются из заголовка NTPv4-собщения, либо они проставляются системными часами при отправке или сразу после получения NTPv4-собщения. Метки времени это данные о точном времени, и поэтому их целесообразно повторно проставлять в случае повторной передачи на канальном уровне, а также корректировать при вычислении криптографической контрольной суммы при передаче NTPv4-собщения.</p><p>NTPv4-собщения используются в двух различных режимах передачи:</p><ol class="lia"><li><p>Один-одному (one-to-one), то есть однонаправленный.</p></li><li><p>Один-многим (one-to-many), то есть широковещательный.</p><p>При использовании IPv4-адресации — это широковещательный или групповой адрес (Для этого IANA зарегистрировала групповой IPv4-адрес — 224.0.1.1). А при использовании IPv6-адресации — это групповой адрес (Для этого IANA зарегистрировала окончание группового IPv6-адреса — :101).</p></li></ol><p>В процедурной характеристике NTPv4-протокола используются четыре метки времени <code>t<sub>1</sub>…t<sub>4</sub></code> и три переменные состояния <code>org</code>, <code>rec</code> и <code>xmt</code> (рис.12).</p><pre>          t<sub>2</sub>            t<sub>3</sub>           t<sub>6</sub>            t<sub>7</sub>
     +---------+   +---------+   +---------+   +---------+
     |    0    |   |    t<sub>1</sub>   |   |   t<sub>3</sub>    |   |    t<sub>5</sub>   |
     +---------+   +---------+   +---------+   +---------+
     |    0    |   |    t<sub>2</sub>   |   |   t<sub>4</sub>    |   |    t<sub>6</sub>   |  Метки времени
     +---------+   +---------+   +---------+   +---------+  в NTP-сообщении
     |   t<sub>1</sub>    |   |t<sub>3</sub>=clock |   |   t<sub>5</sub>    |   |t<sub>7</sub>=clock |
     +---------+   +---------+   +---------+   +---------+
     |t<sub>2</sub>=clock |                 |t<sub>6</sub>=clock |
     +---------+                 +---------+
                                                            Сервер B
     +---------+   +---------+   +---------+   +---------+
org  |   T<sub>1</sub>    |   |    T<sub>1</sub>   |   | t<sub>5</sub>&lt;&gt;T<sub>1</sub>? |   |    T5   |
     +---------+   +---------+   +---------+   +---------+  Переменные
rec  |   T<sub>2</sub>    |   |    T<sub>2</sub>   |   |   T<sub>6</sub>    |   |    T<sub>6</sub>   |  состояния
     +---------+   +---------+   +---------+   +---------+
xmt  |    0    |   |    T<sub>3</sub>   |   |  t<sub>3</sub>=T<sub>3</sub>? |   |    T<sub>7</sub>   |
     +---------+   +---------+   +---------+   +---------+

               t<sub>2</sub>      t<sub>3</sub>                 t<sub>6</sub>          t<sub>7</sub>
     ---------------------------------------------------------
Сервер В      /\         \                 /\            \
              /           \                /              \
             /             \              /                \
            /               \/           /                 \/
     ---------------------------------------------------------
Сервер А  t<sub>1</sub>                t<sub>4</sub>         t<sub>5</sub>                  t<sub>8</sub>

         t<sub>1</sub>            t<sub>4</sub>            t<sub>5</sub>             t<sub>8</sub>
     +---------+   +---------+   +---------+   +---------+
     |    0    |   |    t<sub>1</sub>   |   |   t<sub>3</sub>    |   |    t<sub>5</sub>   |
     +---------+   +---------+   +---------+   +---------+
     |    0    |   |    t<sub>2</sub>   |   |   t<sub>4</sub>    |   |    t<sub>6</sub>   |  Метки времени
     +---------+   +---------+   +---------+   +---------+  в NTP-сообщении
     |t<sub>1</sub>=clock |   |    t<sub>3</sub>   |   |t<sub>5</sub>=clock |   |    t<sub>7</sub>   |
     +---------+   +---------+   +---------+   +---------+
                   |t<sub>4</sub>=clock |                 |t<sub>8</sub>=clock |
                   +---------+                 +---------+
                                                            Сервер A
     +---------+   +---------+   +---------+   +---------+
org  |    0    |   |  t<sub>3</sub>&lt;&gt;0? |   |   T<sub>3</sub>    |   | t<sub>7</sub>&lt;&gt;T<sub>3</sub>? |
     +---------+   +---------+   +---------+   +---------+  Переменные
rec  |    0    |   |    T<sub>4</sub>   |   |   T<sub>4</sub>    |   |    T<sub>8</sub>   |  состояния
     +---------+   +---------+   +---------+   +---------+
xmt  |   T<sub>1</sub>    |   |  t<sub>1</sub>=T<sub>1</sub>? |   |   T<sub>5</sub>    |   |  t5=T<sub>5</sub>? |
     +---------+   +---------+   +---------+   +---------+

Рис.12. Структурно-временная модель процедурной характеристики NTPv4-протокола</pre><p>На рис.12 сервер <em>А</em> передаёт первое NTPv4-сообщение, включающее только время своей отправки <code>t<sub>1</sub></code>, которое затем копируется в значение <code>T<sub>1</sub></code>. Север <em>В</em> принимает NTPv4-собщение в момент времени <code>t<sub>2</sub></code> и копирует <code>t<sub>1</sub></code> в <code>T<sub>1</sub></code>, а метку времени получения NTPv4-сообщения <code>t<sub>2</sub></code> — в <code>T<sub>2</sub></code>. В это время или несколько позже в момент времени <code>t<sub>3</sub></code> сервер <em>В</em> передаёт серверу <em>А</em> NTPv4-сообщение, содержащее <code>t<sub>1</sub></code>, <code>t<sub>2</sub></code> и дополнительно метку времени отправки <code>t<sub>3</sub></code>. Все эти три метки времени копируются в соответствующие переменные состояния. Сервер <em>А</em> в момент времени <code>t<sub>4</sub></code> принимает NTPv4-собщение, содержащее три метки времени <code>t<sub>1</sub></code>, <code>t<sub>2</sub></code> и <code>t<sub>3</sub></code>, а также дополнительную метку прибытия NTPv4-собщения от сервера <em>В</em> <code>t<sub>4</sub></code>. Эти четыре метки используются для расчёта сдвига и задержки часов сервера <em>В</em> относительно сервера <em>А</em>.</p><p>Прежде чем будут обновлены значения переменных состояния <code>xmt</code> и <code>org</code>, проводятся две важных контрольных проверки с целью защиты против дубликатов, поддельных или повторно переданных NTPv4-собщений. Из рассмотренного ранее примера, NTPv4-собщение будет являться дубликатом или повторно переданным, если метка времени отправки <code>t<sub>3</sub></code> в NTPv4-собщении совпадёт с переменной состояния <code>org</code>, равной <code>T<sub>3</sub></code>. NTPv4-собщение будет являться поддельным, если метка времени отправки <code>t<sub>1</sub></code> в NTPv4-собщении не совпадёт с переменной состояния <code>xmt</code>, равной <code>T<sub>1</sub></code>. Если эти две контрольных проверки прошли успешно, то тогда переменные состояния обновляются, а само NTPv4-собщение уничтожается. Для защиты от повторной передачи последнего переданного NTPv4-собщения, переменная состояния <code>xmt</code> устанавливается в ноль сразу после успешной проверки NTPv4-сообщения на предмет его фиктивности.</p><p>Четыре наиболее важные метки времени, T<sub>1</sub> … T<sub>4</sub>, используются для вычисления сдвига времени сервера <em>В</em> относительно сервера <em>А</em>:</p><pre>θ = T(B) - T(A) = ½×[(T<sub>2</sub> - T<sub>1</sub>) + (T<sub>3</sub> - T<sub>4</sub>)]</pre><p>а задержка петлевого маршрута:</p><pre>δ = T(ABA) = (T<sub>4</sub> - T<sub>1</sub>) - (T<sub>3</sub> - T<sub>2</sub>)</pre><p>Необходимо отметить, что значения в круглых скобках вычисляются на основе 64-битовых беззнаковых метках времени и преобразуются в знаковые величины, состоящие из 63 соответствующих битов и знака плюс (один бит). Эти величины могут представлять собой даты, начиная с последних 68 лет и кончая последующими 68 годами. Однако, сдвиг и задержка вычисляются как суммы и разности таких значений, в которых только 62 бита отводятся для числа, а два бита отводятся под знак числа, и поэтому могут представлять собой явные значения, начиная с последних 34 лет и кончая последующими 34 годами. Другими словами, время клиента должно быть синхронизировано от сервера времени не ранее, чем за 34 лет до начала действия протокола. Это фундаментальное ограничение, связанное с 64-битовыми целочисленными арифметическими действиями.</p><p>В прикладных программных NTPv4-модулях, в которых возможна арифметическая операция с удвоенными числами с плавающей точкой, разности первого порядка могут быть преобразованы в удвоенные значения с плавающей точкой, а суммы и разности второго порядка вычисляются с использованием этой операции. Так как значения второго порядка, как правило, очень малы относительно отклонений значений, указываемых в метках времени, и в этом смысле потери точности практически нет, и поэтому однозначный временной интервал от 34 до 68 лет может быть восстановлен.</p><p>В некоторых случаях, когда начальный сдвиг частоты в клиентском NTP-модуле относительно большой, а реальное время распространения сигнала мало, то тогда при вычислении задержки результат может быть отрицательным. Например, если разность частоты равна 100 промилей, а интервал <code>T<sub>4</sub> — T<sub>1</sub></code> — 64 секунды, то тогда мнимая задержка составит -6,4 миллисекунд. Так как отрицательные значения являются «обманчивыми» при последовательном вычислении, значение <code>δ</code> должно быть ограничено значением не меньшим, чем <code>s.ρ</code>, где <code>s.ρ</code> представляет собой точность системы (в секундах).</p><p>Представленные выше рассуждения касаются наиболее общего случая, когда два удалённых сервера времени, функционирующих в симметричном режиме, независимо друг от друга измеряют сдвиги и задержки между собой. Если сервер находится в ином режиме, процедурная характеристика протокола может быть упрощена. Сервер времени копирует метки времени T<sub>3</sub> и T<sub>4</sub> из NTPv4-сообщения клиента в значения T<sub>1</sub> и T<sub>2</sub> NTPv4-сообщения сервера и добавляет метку времени T<sub>3</sub> отправки ответного NTPv4-сообщения перед самой передачей последнего клиенту.</p><p>Процедурная характеристика NTPv4-протокола, по определению, способна защитить систему от повторной передачи ответного NTPv4-сообщения сервера. Однако, она не способна предотвратить повторную передачу ответного NTPv4-сообщения клиента, при реализации которой сервер отправит ответное NTPv4-сообщение с новыми значениями T<sub>2</sub> и T<sub>3</sub>, и после этого будут рассчитаны некорректные значения сдвига и задержки. Эта уязвимость может быть устранена путём обнуления значения переменной состояния <code>xmt</code> после вычисления значений сдвига и задержки.</p><h2 id="p9">9. Функциональные процедуры удлённого сервера</h2><p>Процедуры удалённого сервера времени инициируются после получения NTPv4-сообщения от клиента или другого удалённого сервера. Эти процедуры, являясь часть процедурной характеристики NTPv4-протокола, позволяют определить сдвиг времени и задержку петлевого маршрута, а также дополнительные статистические параметры, используемые системным процессом и процессом опроса удалённых серверов времени. Переменные удалённого сервера обрабатываются после установления виртуального соединения на основе данных обновления, содержащихся в поступающих NTPv4-сообщениях. Каждый удалённый сервер времени инициирует процедуры установления виртуального соединения, опроса других серверов времени и определения временных параметров и переменных.</p><h3 id="p9.1">9.1. Переменные, обрабатываемые удалённым сервером</h3><p>На рис.13 … 16 представлены переменные, обрабатываемые удалённым сервером времени (их наименования, обозначения и краткие описания). Имена и обозначения являются взаимозаменяемыми.</p><table><tr><th>Наименование</th><th>Обозначение</th><th>Описание</th></tr><tr><td>srcaddr</td><td>srcaddr</td><td>IP-адрес источника</td></tr><tr><td>srcport</td><td>srcport</td><td>Номер транспортного порта источника</td></tr><tr><td>dstaddr</td><td>dstaddr</td><td>IP-адрес получателя</td></tr><tr><td>dstport</td><td>destport</td><td>Номер транспортного порта получателя</td></tr><tr><td>keyid</td><td>keyid</td><td>Идентификатор криптоключа</td></tr><tr><th colspan="3">Рис.13. Переменные настройки виртуального соединения</th></tr></table><table><tr><th>Наименование</th><th>Обозначение</th><th>Описание</th></tr><tr><td>leap</td><td>leap</td><td>Индикатор перехода через 00 00 часов</td></tr><tr><td>version</td><td>version</td><td>Номер версии NTP-протокола</td></tr><tr><td>mode</td><td>mode</td><td>Режим функционирования</td></tr><tr><td>stratum</td><td>stratum</td><td>Номер «слоя»</td></tr><tr><td>ppoll</td><td>ppoll</td><td>Экспоненциальное значение интервала опроса</td></tr><tr><td>rootdelay</td><td>Δ<sub>r</sub></td><td>Коневая задержка</td></tr><tr><td>rootdisp</td><td>Ε<sub>r</sub></td><td>Коневая дисперсия</td></tr><tr><td>refid</td><td>refid</td><td>Идентификатор эталонного источника</td></tr><tr><td>reftime</td><td>reftime</td><td>Метка времени эталонного источника</td></tr><tr><th colspan="3">Рис.14. Переменные в заголовке NTP-сообщения, передаваемого удалённым сервером</th></tr></table><table><tr><th>Наименование</th><th>Обозначение</th><th>Описание</th></tr><tr><td>org</td><td>T<sub>1</sub></td><td>Метка времени источника NTP-сообщения</td></tr><tr><td>rec</td><td>T<sub>2</sub></td><td>Метка времени при получении NTP-сообщения</td></tr><tr><td>xmt</td><td>T<sub>3</sub></td><td>Метка времени при отправке NTP-ответа</td></tr><tr><td>t</td><td>t</td><td>Время счётчика секунд</td></tr><tr><th colspan="3">Рис.15. Переменные меток времени</th></tr></table><table><tr><th>Наименование</th><th>Обозначение</th><th>Описание</th></tr><tr><td>offset</td><td>θ</td><td>Сдвиг времени</td></tr><tr><td>delay</td><td>δ</td><td>Задержка петлевого маршрута</td></tr><tr><td>disp</td><td>ε</td><td>Дисперсия</td></tr><tr><td>jitter</td><td>ψ</td><td>Джиттер</td></tr><tr><td>filter</td><td>filter</td><td>Фильтр времени</td></tr><tr><td>t<sub>p</sub></td><td>t<sub>p</sub></td><td>Время фильтрации</td></tr><tr><th colspan="3">Рис.16. Статистические параметры и переменные</th></tr></table><p>Переменные настройки обычно запрашиваются при установлении виртуального соединения, либо из файла настройки, либо из первого поступившего NTPv4-сообщения, когда виртуальное соединение неизвестно. К ним относятся:</p><ul class="list"><li><code>srcaddr</code></li><li class="lib"><p>IP-адрес удалённого сервера времени или эталонного источника времени. Он становится IP-адресом получателя в IP-пакете, содержащем ответное NTPv4-сообщение, в данном виртуальном соединении.</p></li><li><code>srcport</code></li><li class="lib"><p>Номер UDP-порта удалённого сервера времени или эталонного источника времени. Он становится номером порта получателя в IP-пакете, содержащем ответное NTPv4-сообщение, в данном виртуальном соединении. Когда функциональное взаимодействие осуществляется в симметричных режимах (1, 2), то тогда данное поле должно содержать утверждённый IANA номер NTP-порта — 123. В других режимах оно может содержать любые другие номера в зависимости от правил обеспечения безопасности.</p><li><code>dstaddr</code></li><li class="lib"><p>IP-адрес клиента. Он становится IP-адресом отправителя (источника) в IP-пакете, содержащем ответное NTPv4-сообщение, в данном виртуальном соединении.</p></li><li><code>dstport</code></li><li class="lib"><p>Номер UDP-порта клиент, обычно, это утверждённый IANA номер NTP-порта — 123. Он становится номером порта отправителя (источника) в IP-пакете, содержащем ответное NTPv4-сообщение, в данном виртуальном соединении.</p></li><li><code>keyid</code></li><li class="lib"><p>Идентификатор симметричного криптоключа, для определения 128-битового MD5-ключа, который используется для формирования и проверки значений в МАС-поле. Клиент и удалённый сервер могут использовать различные значения идентификатора, но они должны принадлежать одному и тому же криптоключу.</p></li></ul><p>Переменные, представленные на рис.14, обновляются на основании данных, содержащихся в заголовках поступивших NTPv4-сообщений. Они интерпретируются точно также, как и переменные, содержащихся в заголовках NTPv4-сообщений и с аналогичными именами. Для последующей целесообразно преобразовать переменные <code>r.rootdelay</code> и <code>r.rootdisp</code> в заголовке NTPv4-сообщения в укороченном формате (рис.4,1) в удвоенный формат с плавающей точкой, аналогично переменным удалённого сервера времени.</p><p>Переменные, представленные на рис.15, включают метки времени, которыми обмениваются объекты и субъекты синхронизации на основе процедурной характеристики NTPv4-протокола. Переменная <code>t</code> представляет собой значение счётчика секунд <code>c.t</code>, который участвует в формировании меток времени. Переменная <code>c.t</code> уточняется процессом корректировки времени. Фактически, счётчик считает секунды с момента запуска службы.</p><p>Переменные, представленные на рис.16, включают статистические параметры, которые вычисляются с помощью прикладной процедуры фильтрации времени <code>clock_filter()</code>. Переменная <code>t<sub>p</sub></code> представляет собой значение счётчика секунд, который участвует в формировании этих параметров.</p><h3 id="p9.2">9.2. Процедуры, проводимые удалённым сервером</h3><p>К таким процедурам относятся процедура приема NTPv4-сообщения и процедура управления доступом на основе списка управления доступом (access control list — ACL). Последняя не требует каких-либо специальных методов по управлению доступом, хотя существует рекомендация, чтобы прикладные программные NTPv4-модули включали такой способ, который подобен многим другим широко используемым способам.</p><p>Проверки формата включают контроль корректности длины и дополнения до 32-битовой границы, доступность номера версии протокола (1…4), а также, при наличии, корректность дополнительных полей расширения.</p><p>Не существует какого-либо специального требования к процедуре аутентификации. Однако, если процедура аутентификации имеет место, то тогда среди всех реализованных способов должен быть и способ, основанный на MD5-алгоритме хеширования с использование симметричного криптоключа (RFC-1231).</p><p>Для поиска и сравнения IP-адресов и номеров портов транспортного уровня отправителей NTPv4-сообщений существует таблица виртуальных соединений, при этом используется специальный прикладной процесс <code>find_assoc()</code>. На рис.17 представлена диспетчерская таблица, в которой колонки соответствуют номерам форматов пакетов (NTPv4-сообщений), а строки — режимам функционирования виртуальных соединений. Данная таблица позволяет определить необходимую процедуру обработки. Кодировка процедур следующая:</p><table><tr><th rowspan="2" colspan="2" class="c">Режим соединения</th><th colspan="5" class="c">Форматы пакетов</th></tr><tr class="odd"><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr><tr class="x"><td colspan="7"></td></tr><tr><td>Отсутствие соединения</td><td>0</td><td>NEWPS</td><td>DSCRD</td><td>FXMIT</td><td>MANY</td><td>NEWBC</td></tr><tr><td>Симметричный активный</td><td>1</td><td>PROC</td><td>PROC</td><td>DSCRD</td><td>DSCRD</td><td>DSCRD</td></tr><tr><td>Симметричный пассивный</td><td>2</td><td>PROC</td><td>ERR</td><td>DSCRD</td><td>DSCRD</td><td>DSCRD</td></tr><tr><td>Режим клиента</td><td>3</td><td>DSCRD</td><td>DSCRD</td><td>DSCRD</td><td>PROC</td><td>DSCRD</td></tr><tr><td>Режим сервера</td><td>4</td><td>DSCRD</td><td>DSCRD</td><td>DSCRD</td><td>DSCRD</td><td>DSCRD</td></tr><tr><td>Широковещательный</td><td>5</td><td>DSCRD</td><td>DSCRD</td><td>DSCRD</td><td>DSCRD</td><td>DSCRD</td></tr><tr><td>Широковещательный (клиента)</td><td>6</td><td>DSCRD</td><td>DSCRD</td><td>DSCRD</td><td>DSCRD</td><td>PROC</td></tr><tr><th colspan="7">Рис.17. Диспетчерская таблица удалённого сервера времени</th></tr></table><ul class="list"><li><code>DSCRD</code> (уничтожение)</li><li class="lib"><p>Этот код указывает на несущественную ошибку функционирования NTPv4-протокола, возникшую в следствие программной ошибки, либо это было опоздавшее NTPv4-сообщение, либо оно было повторно передано. Прикладной процесс сервера уничтожает сообщение и завершается.</p></li><li><code>ERR</code> (ошибка)</li><li class="lib"><p>Этот код указывает на фатальную ошибку функционирования NTPv4-протокола, возникшую в следствие программной ошибки, либо это было опоздавшее NTPv4-сообщение, либо оно было повторно передано. Прикладной процесс сервера уничтожает сообщение, разрывает виртуальное соединение, функционировавшее в симметричном пассивном режиме, и завершается.</p></li><li><code>FXMIT</code></li><li class="lib"><p>Этот код указывает на то, что NTPv4-сообщение клиента (режим №3) не соответствует режиму функционирования, то есть виртуальное синхросоединение отсутствует. Если IP-адрес получателя не является широковещательным, то тогда сервер переходит в режим сервера формирует ответное NTPv4-сообщение и отправляет его клиенту без сохранения данного режима. Заголовок NTPv4-сообщения сервера формируется специальным прикладным процессом <code>fast_xmit()</code> из системных переменных и переменных из принятого NTPv4-сообщения (рис.18). Если системные переменные <code>s.rootdelay</code> и <code>s.rootdisp</code> храняться в удвоенном формате с плавающей точкой, то тогда они должны быть первыми преобразованы в укороченный 32-битовый NTP-формат.</p><table class="w640"><tr><th class="ar">Переменные в NTP-сообщении</th><th class="nl" style="width:1%">&lArr;</th><th class="nl" style="width:50%">Переменная</th></tr><tr><td class="ar">r.leap</td><td class="nl">&lArr;</td><td class="nl">p.leap</td></tr><tr><td class="ar">r.mode</td><td class="nl">&lArr;</td><td class="nl">p.mode</td></tr><tr><td class="ar">r.stratum</td><td class="nl">&lArr;</td><td class="nl">p.stratum</td></tr><tr><td class="ar">r.poll</td><td class="nl">&lArr;</td><td class="nl">p.ppoll</td></tr><tr><td class="ar">r.rootdelay</td><td class="nl">&lArr;</td><td class="nl">p.rootdelay</td></tr><tr><td class="ar">r.rootdisp</td><td class="nl">&lArr;</td><td class="nl">p.rootdisp</td></tr><tr><td class="ar">r.refid</td><td class="nl">&lArr;</td><td class="nl">p.refid</td></tr><tr><td class="ar">r.reftime</td><td class="nl">&lArr;</td><td class="nl">p.reftime</td></tr><tr><td class="ar">r.keyid</td><td class="nl">&lArr;</td><td class="nl">p.keyid</td></tr><tr><th colspan="3">Рис.18. Переменные их принятого NTPv4-сообщения</th></tr></table><p class="note">Замечание. Если процедура аутентификации завершилась отказом в доступе, то тогда сервер передает специальное ответное NTPv4-сообщение, именуемое «crypto-NAK». Это сообщение включает данные обычного NTPv4-заголовка (рис.8), но МАС-поле состоит из четырёх нулевых октетов. Клиент, получив это сообщение от сервера, может использовать или уничтожить содержащиеся в нём данные. После этих действий процесс завершается.</p><p>Если IP-адрес получателя является групповым IP-адресом, то тогда отправитель функционирует в групповом клиентском режиме. Если NTPv4-сообщение корректно и номер «слоя» сервера меньше, чем номер «слоя» клиента, то тогда сервер передает обычное NTPv4-сообщение сервера (режим №4), но при этом использует однонаправленный IP-адрес получателя. Если процедура аутентификации завершилась отказом в доступе, то тогда ответное NTPv4-сообщение «crypto-NAK» не передаётся. После этих действий процесс завершается.</p></li><li><code>MANY</code></li><li class="lib"><p>Этот код указывает на то, что NTPv4-сообщение сервера (режим №4) не соответствует режиму функционирования, то есть виртуальное синхросоединение отсутствует. Обычно, это может произойти тогда, когда сервер передаёт ответное NTPv4-сообщение в составе IP-пакета с групповым IP-адресом на ранее полученный IP-пакет с групповым IP-адресом, содержащий NTPv4-сообщение клиента. Если NTPv4-сообщение корректно, то тогда устанавливается обычное виртуальное соединение в клиентском режиме (режим №3), а процесс обработки продолжает функционировать, как если бы виртуальное соединение было установлено на основе данных из файла настройки.</p></li></ul><ul class="list"><li><code>NEWBC</code></li><li class="lib"><p>Этот код указывает на то, что NTPv4-сообщение (режим №5), содержащееся в IP-пакете с широковещательным IP-адресом, не соответствует режиму функционирования, то есть виртуальное синхросоединение отсутствует. Клиент устанавливает, либо клиентское (режим №3), либо клиентское широковещательное (режим №6) виртуальное соединение с помощью прикладных процессов <code>mobilize()</code> и <code>clear()</code>. Затем прикладной процесс <code>packet()</code> подтверждает корректность NTPv4-сообщения и обновляет значения переменных прикладного NTPv4-модуля удалённого сервера времени.</p><p>Если прикладной программный NTPv4-модуль сервера времени не реализует дополнительные функции по обеспечению безопасности или калибровки времени, то тогда виртуальное соединение переходит в широковещательные клиентский режим (режим №6), а процесс обработки завершается. Если же прикладные программные NTPv4-модули серверов времени способны использовать аутентификацию на основе криптографии с открытыми ключами, то тогда они могут применить протокол аутентификации «Autokey» или ему подобный протокол обеспечения безопасности. Для определения задержки, связанной с распространением синхросигнала, целесообразно, чтобы прикладные программные NTPv4-модули серверов времени переустанавливали свои виртуальные соединения «клиент/сервер» в режим№3 и использовали укороченную процедуру информационного обмена. Затем для последующего информационного взаимодействия виртуальное синхросоединение переходит в режим №6, а прикладной процесс удалённого сервера функционирует только в режиме контроля соединения (listen-only mode).</p></li><li><code>NEWPS</code></li><li class="lib"><p>Этот код указывает на то, что принято NTPv4-сообщение (режим №1), указывающее на симметричное активное виртуальное соединение, но виртуальное синхросоединение отсутствует. Клиент формирует виртуальное соединение в симметричном пассивном режиме (режим №2) с помощью прикладных процессов <code>mobilize()</code> и <code>clear()</code>. Процесс обработки продолжается.</p></li><li><code>PROC</code></li><li class="lib"><p>Этот код указывает на то, что принятое NTPv4-сообщение прошло проверку и оно принадлежит существующему виртуальному синхросоединению. Метки времени в этом NTPv4-сообщении тщательно проверены на предмет корректности, дублирования или подмены (фальсификации) NTPv4-сообщений. Дополнительные проверочные процедуры представлены на рис.19.</p><p class="note">Замечание. Все NTPv4-сообщения, включая сообщения «crypto-NAK», считаются корректными, если они успешно прошли все, указанные на рис.19, проверочные процедуры.</p><table><tr><th>Тип сообщения</th><th>Описание</th></tr><tr><td>1. Дубликат</td><td>В лучшем случае, это старое продублированное сообщение, в худшем — атака хакера «повторная передача». Такое событие может произойти в симметричных режимах, если интервалы опроса сбалансированы.</td></tr><tr><td class="nobr">2. Фальсифицированное</td><td rowspan="2">Одно или несколько полей меток времени некорректны. Такое событие обычно происходит в симметричных режимах, когда один удалённый сервер времени передаёт первое сообщение другому, а перед этим другой сервер принял его первое ответное сообщение.</td></tr><tr><td class="odd">3. Некорректное</td></tr><tr><td class="oddw">4. Отказ в доступе</td><td class="oddw">Источник сообщения числится в «чёрном» списке системы управления доступом</td></tr><tr><td class="odd">5. Провал аутентификации</td><td class="odd">Криптографическая проверочная сумма не совпадает со значением в МАС-поле.</td></tr><tr><td class="oddw">6. Нет синхронизации</td><td class="oddw">Сервер не засинхронизировался от доступного источника.</td></tr><tr><td class="nobr odd">7. Некорректные данные заголовка</td><td class="odd">Одно или несколько полей заголовка сообщения некорректны.</td></tr><tr><th colspan="2" class="oddw">Рис.19. Описание дополнительных проверочных процедур</th></tr></table><p>Обработка NTPv4-сообщения продолжается с помощью прикладного процесса <code>packet()</code>, которые копирует значения переменных из сообщения в значения переменных прикладного программного NTPv4-модуля удалённого сервера (рис.18). Прикладной процесс <code>receive()</code> использует 1…5 дополнительные проверочные процедуры, представленные на рис.19, а <code>packet()</code> — 6…7 процедуры. Если в процессе проверки NTPv4-сообщения выявляются ошибки, то тогда оно уничтожатся, а процесс обработки завершается.</p></li></ul><p>Процедурная характеристика NTPv4-протокола обеспечивает вычисление сдвига времени <code>θ</code> и задержку петлевого маршрута <code>δ</code> с помощью самых «свежих» меток времени (рис.12). Несмотря на то, что, в принципе, существует возможность выполнить все вычисления (кроме разностей значений меток времени первого порядка) с использованием арифметических операций над числами с фиксированной точкой, всё равно гораздо проще преобразовать разности первого порядка в удвоенные значения с плавающей точкой и выполнить остальные вычисления с использованием арифметических операций над такими числами. Все последующие рассуждения будут основаны на этом предположении.</p><p>В процедуре опроса участвует 8-битовый регистр сдвига <code>p.reach</code>, который определяет достижимость удалённого сервера времени, а также являются ли полученные от него данные самыми «свежими». Это регистр сдвигается влево на один бит, когда передано NTPv4-сообщение, а крайний правый бит обнуляется. После получения корректных NTPv4-сообщений прикладной процесс <code>packet()</code> устанавливает крайний правый бит в <code>1</code>. Если в этом регистре содержится любое количество ненулевых битов, то тогда считается, что удалённый сервер времени достижим, в противном случае — нет. Так как интервал опроса в прикладном NTPv4-модуле сервера времени может измениться после получения последнего NTPv4-сообщения, инициализируется прикладной процесс <code>poll_update()</code>, который выполняет задачу определения нового интервала опроса IP-узла.</p><p>Статистическая дисперсия <code>ε(t)</code> представляет собой максимальную ошибку, являющуюся следствием допустимого отклонения частоты и интервала времени с момента передачи последнего NTPv4-сообщения. В начальный момент дисперсия вычисляется следующим образом:</p><pre>ε(t<sub>0</sub>) = r.ρ + s.ρ + Φ×(T<sub>4</sub> - T<sub>1</sub>)</pre><p>то есть измерение было сделано в момент времени <code>t<sub>0</sub></code>, что соответствовало значению счётчика секунд. Переменная <code>r.ρ</code> — точность, указанная в NTPv4-сообщении, а <code>s.ρ</code> — точность системных часов, при этом обе переменные измеряются в секундах. Они необходимы для учёта погрешностей при считывании значений системного времени, и в прикладном NTPv4-модуле сервера, и в прикладном NTPv4-модуле клиента.</p><p>Затем дисперсия возрастает с постоянной скоростью <code>Φ</code>, другими словами, в момент времени <code>t</code>:</p><pre>ε(t) = ε(t<sub>0</sub>) + Φ×(t - t<sub>0</sub>)</pre><p>По умолчанию <code>Φ = 15 РРМ</code>, что составляет примерно 1,3 секунды за сутки. В дальнейшем аргумент <code>t</code> не будет использоваться, а дисперсия будет обозначаться одним символом <code>ε</code>. Остальные статистические параметры вычисляются с помощью процедуры фильтрации времени.</p><h2 id="p10">10. Процедура (алгоритм) фильтрации времени</h2><p>Процедура (алгоритм) фильтрации времени является частью процедур, применяемых в прикладном программном NTPv4-модуле удалённого сервера. Эту процедуру реализует прикладной процесс <code>clock_filter()</code>, который фильтрует поток протокольных данных с целью выбора эталонных источников времени, обеспечивающих наиболее точное время. Данная процедура обеспечивает вычисление значений переменных (рис.16), среди которых сдвиг <code>θ</code>, задержка <code>δ</code>, дисперсия <code>ε</code>, джиттер <code>ψ</code> и время прибытия NTPv4-сообщения <code>t</code>. Эти данные используются алгоритмами обработки входного трафика с целью определения наилучшего и окончательного сдвига, который, в свою очередь, используется для корректировки системных часов. Они также используются для определения функционального состояния сервера времени и его пригодности выступать в роли источника синхронизации.</p><p>Процедура фильтрации времени сохраняет наборы самых последних значений взаимосвязанных переменных (<code>θ</code>, <code>δ</code>, <code>ε</code>, <code>t</code>) в схеме фильтра, который функционирует как 8-разрядный регистр сдвига. Наборы значений переменных сохраняются в том порядке, в котором прибыли NTPv4-сообщения. В данном случае, переменная <code>t</code> — значение счётчика секунд в момент приёма NTPv4-сообщения, и поэтому она отличается от переменой <code>t<sub>р</sub></code> прикладного NTPv4-модуля удалённого сервера.</p><p>Используемая схема фильтрации призвана обеспечить достаточное количество источников синхронизации для последующего анализа, а также удаление устаревших данных. В начале, наборы переменных для всех состояний устанавливаются в форме временного (фиктивного) набора (0, MAXDISP, MAXDISP, 0). После поступления корректных NTPv4-сообщений наборы значений переменных записываются в память фильтра, что влечёт за собой удаление наборов устаревших значений, и поэтому в фильтре остаются только разрешённые наборы переменных. Если в регистре достижимости три бита низшего порядка являются нулевыми, указывая на то, что три интервала опроса, в течении которых поступили некорректные NTPv4-сообщения, истекли, то тогда процедура опроса обращается к процедуре фильтрации времени, реализуемая фильтром, в памяти которого записан фиктивный набор переменных, как если бы последний был получен из сети. Если такая ситуация остаётся на протяжении восьми интервалов опрос, то тогда регистр переустанавливается в исходное состояние.</p><p>На следующем этапе, состояния регистра сдвига копируются во временный перечень, в котором записи сортируются по мере возрастания значения <code>δ</code>. Пусть <code>i</code> будет индексом состояния, начиная с наименьшего значения <code>δ</code>. Если время фильтрации первого набора переменных <code>t<sub>0</sub></code> не является более поздним, чем время фильтрации самого последнего корректного синхроисточника <code>t<sub>p</sub></code>, то тогда прикладной процесс завершается, сохраняя без изменений текущие значения переменных прикладного NTPv4-модуля сервера. В противном случае, пусть <code>ε<sub>i</sub></code> будет дисперсией i-ой записи, тогда</p><pre>     i=n-1
     ---        ε<sub>i</sub>
ε =   \    ----------
      /       (i+1)
     ---    2
     i=0</pre><p>является дисперсией удалённого сервера <code>p.disp</code>.</p><p class="note">Замечание. При перезагрузке значения <code>ε</code>, либо на входе фильтра времени, либо она его выходе, это значение должно быть предварительно удалено из набора переменных.</p><p>При более внимательном анализе становится очевидным, что:</p><ul class="lat lia"><li><p>Если все состояния содержат фиктивный набор переменных со значением дисперсии <code>MAXDISP</code>, то тогда вычисленное значение дисперсии не на много меньше чем 16 секунд.</p></li><li><p>Каждый раз, когда корректный набор переменных сдвигается в регистре, дисперсия снижается почти на половину, в зависимости от дисперсии в корректных наборах переменных.</p></li><li><p>После обработки четвёртого корректного NTPv4-сообщения значение дисперсии обычно составляет не многим менее одной секунды, которое является предполагаемым значением параметра <code>MAXDISP</code>, используемого процедурой селекции для определения приемлемости значений переменных прикладного NTPv4-модуля сервера.</p></li></ul><p>Пусть сдвиг первого состояния регистра, записанного в перечень, будет <code>θ<sub>0</sub></code>, тогда при других состояниях регистра, следующих в произвольном порядке, джиттер представляет собой среднеквадратичное отклонение:</p><pre>               +-----        -----+<sup>1/2</sup>
               |  n-1             |
               |  ---             |
       1       |  \               |
ψ =  -------- * |  /    (θ<sub>0</sub>-θ<sub>j</sub>)<sup>2</sup>   |
     (n-1)     |  ---             |
               |  j=1             |
               +-----        -----+</pre><p>где <code>n</code> — число корректных наборов переменных в памяти фильтра (n > 1). С целью гарантированного обеспечения совместимости и предотвращения каких-либо ограничений в других вычислениях, значение <code>ψ</code> ограничивается снизу значением системной точности <code>s.ρ</code>, выраженной в секундах. Несмотря на то, что пока нет согласованного единого критерия классификации серверов времени, с точки зрения их качества, джиттер является очень важным показателем качества обеспечения синхронизации и состояния перегрузки сети. Важное значение для алгоритмов оптимизации имеет расстояние синхронизации удалённого сервера времени, которое вычисляется с помощью задержки и дисперсии:</p><pre>λ = (δ / 2) + ε</pre><p class="note">Замечание. Значение <code>ε</code> и тем более значение <code>λ</code> увеличиваются со скоростью <code>Φ</code>.</p><p>Переменная <code>λ</code> не является системным параметром, так как её значение пересчитывается при каждом её использовании. Она является составной частью расстояния синхронизации до корневого сервера времени и используется алгоритмами оптимизации в качестве метрики при определении качества синхросигналов, передаваемых каждым доступным сервером времени.</p><p>Очень важно отметить, что в отличие от NTPv3-протокола, виртуальные NTPv4-соединения не оповещают о переходе в режим тайм-аута с помощью установки значения <code>16</code> в поле «Номер слоя» («Stratum», рис.9) и значения <code>3</code> в поле «Индикатор перехода» («Leap Indicator», рис.9). Переменные виртуального соединения сохраняют свои значения, которые были указаны в последнем поступившем NTPv4-сообщении. В NTPv4-протоколе переменная <code>λ</code> увеличивается со временем, и в конечном счёте расстояние синхронизации превышает предельное значение расстояния <code>MAXDIST</code>, а в этом случае, виртуальное соединение считается непригодным для синхронизации.</p><h2 id="p11">11. Системный процесс (процедуры)</h2><p>После того, как алгоритм фильтрации времени вычислит значения переменных (<code>θ</code>, <code>δ</code>, <code>ε</code>, <code>ψ</code>, <code>t</code>), все процедуры прикладных NTPv4-модулей сервера опрашиваются алгоритмами оптимизации, включающими алгоритмы селекции, кластеризации, суммирования и корректировки часов в рамках системного процесса. Процедура (алгоритм) селекции опрашивает серверы времени с помощью виртуальных соединений и «отбрасывает» некорректные часы, которые продемонстрировали некорректное время, оставляя в итоге корректные часы.</p><p>В течении нескольких циклов процедура (алгоритм) кластеризации удаляет виртуальное соединение, которое являются самым длинным относительно опрашивающего сервера времени или клиента, пока не останется определённое число кандидатов на роль источника синхронизации.</p><p>Процедура (алгоритм) суммирования вычисляет наилучшие и заключительные значения статистических параметров/переменных на основе усреднения весовых коэффициентов. Финальное значение сдвига времени далее поступает на вход процедуры (алгоритм) корректировки времени, которая устанавливает правильное значение времени в системных часах.</p><p>Процедура (алгоритм) кластеризации выбирает одного из кандидатов в качестве системного сервера времени. Значения взаимосвязанных статистических параметров/переменных (<code>θ</code>, <code>δ</code>, <code>ε</code>, <code>ψ</code>, <code>t</code>) используются для формирования системных переменных, которыми пользуются зависящие от них серверы времени и клиенты, и становятся доступными для всех других прикладных и системных процессов, которые функционируют в данном компьютере.</p><h3 id="p11.1">11.1. Переменные системного процесса (процедур)</h3><p>На рис.20 представлены наименование, обозначение и краткое описание каждой системной переменной. Если не указано обратного, то тогда все переменные записываются с префиксом <code>s</code>.</p><p>За исключением переменных <code>t</code>, <code>p</code>, <code>Ψ</code>, <code>Θ</code> и констант <code>NMIN</code> и <code>CMIN</code>, все переменные имеют одинаковый формат и интерпретируются как переменные прикладного NTPv4-модуля сервера времени с одним и тем же именем. Параметры <code>NMIN</code> и <code>CMIN</code> используются в процедурах (алгоритмах) селекции и кластеризации.</p><table><tr><th>Наименование</th><th>Обозначение</th><th>Описание</th></tr><tr><td>t</td><td>t</td><td>Время обновления данных</td></tr><tr><td>p</td><td>p</td><td>Идентификатор системного сервера времени</td></tr><tr><td>leap</td><td>leap</td><td>Индикатор перехода через 00<sup><u>00</u></sup> часов</td></tr><tr><td>stratum</td><td>stratum</td><td>Номер «слоя»</td></tr><tr><td>precision</td><td>ρ</td><td>Значение точности</td></tr><tr><td>offset</td><td>Θ</td><td>Суммарный сдвиг времени</td></tr><tr><td>jitter</td><td>Ψ</td><td>Суммарный джиттер</td></tr><tr><td>rootdelay</td><td>Δ</td><td>Коневая задержка</td></tr><tr><td>rootdisp</td><td>Ε</td><td>Коневая дисперсия</td></tr><tr><td>v</td><td>v</td><td>Перечень претендентов на роль источника синхронизации</td></tr><tr><td>refid</td><td>refid</td><td>Идентификатор эталонного источника</td></tr><tr><td>reftime</td><td>reftime</td><td>Значение (метка) времени эталонного источника</td></tr><tr><td>NMIN</td><td>3</td><td>Минимальное число претендентов на роль источника синхронизации</td></tr><tr><td>CMIN</td><td>1</td><td>Минимальное число кандидатов на роль системного источника синхронизации</td></tr><tr><th colspan="3">Рис.20. Параметры и переменные системного процесса (процедур)</th></tr></table><p>Переменная <code>t</code> представляет собой значение счётчика секунд с момента последнего обновления данных, определяемого прикладным процессом <code>clock_update()</code>. Переменная <code>p</code> является идентификатором системного сервера времени, определённого прикладным процессом <code>cluster()</code>. Переменная <code>ρ</code> (точность) имеет точно такой же формат, как и переменная в заголовке NTPv4-сообщения с таким же именем. Под точностью понимается наибольшее значение разрешающей способности (максимальная частота дискретизации), а также время считывания текущего значения часов (в log<sub>2</sub>). Например, точность часов на основе промышленной частоты 60 Гц составляет 16 миллисекунд, даже тогда, когда аппаратная реализация системных часов обеспечивает точность одну наносекунду.</p><p>Значения сдвига и джиттера определяются прикладным процессом <code>combine()</code>. Эти значения считаются наилучшими, а финальные значения сдвига и джиттера используются для корректировки системного времени. Первоначально значения всех переменных обнуляются, после этого в поле «Индикатор перехода» («Leap Indicator», рис.9) записывается значение <code>3</code> (отсутствие синхронизации), а в поле «Номер слоя» («Stratum», рис.9) — значение <code>MAXSTRAT</code> (<code>16</code>). В заголовке передаваемого NTPv4-сообщения значение <code>MAXSTRAT</code> отображается в последовательность нулевых битов.</p><h3 id="p11.2">11.2. Процедуры системного процесса</h3><p>На рис.21 представлена структурная блок-схема прикладного процесса <code>clock_select()</code>, который реализует ряд процедур системного NTPv4-процесса. Процедура (алгоритм) селекции определяет большую группу предполагаемых корректных кандидатов (корректных источников синхронизации) на основе принципов обоюдного согласия. Процедура (алгоритм) кластеризации удаляет «менее достойных кандидатов» с целью формирования подгруппы наиболее точных претендентов на роль синхроисточников. Процедура (алгоритм) суммирования определяет наилучшее и заключительное значение сдвига, которое будет использоваться в процедуре (алгоритме) корректировки времени. Если процедура (алгоритм) селекции не смогла определить достаточно большую группу предполагаемых источников синхронизации, или не смогла определить, по крайней мере, число претендентов, равное значению константы <code>CMIN</code>, то тогда системный процесс завершается без настройки системных часов. Если же указанные выше процедуры прошли успешно, то тогда процедура (алгоритм) кластеризации выбирает наилучшего, с точки зрения статистических результатов, кандидата в качестве системного сервера времени, а значения его переменных используются как системные переменные.</p><h4 id="p11.2.1">11.2.1. Процедура (алгоритм) селекции</h4><p>Процедура (алгоритм) селекции предназначена для поиска интервала перекрытия, содержащего максимальное число корректных часов, на основе принципов византийского соглашения, определённых Марцулло<sup><abbr title="Marzullo and S. Owicki, «Maintaining the time in a distributed system.», ACM Operating Systems Review 19, Июль 1985.">[?]</abbr></sup>, но сама процедура была изменена с целью повышения точности.</p><p>Во-первых, выявляются те серверы времени, которые не пригодны в соответствии с правилами процедурной характеристики NTPv4-протокола, и за тем к ним блокируется доступ, с помощью прикладного процесса <code>accept()</code>. Далее, для оставшихся претендентов формируется набор переменных <code>(p, type, edge)</code>. В данном наборе <code>p</code> — идентификатор виртуального соединения, <code>type</code> идентифицирует конечные точки интервала корректности (upper (верхняя) <code>+1</code>, middle (средняя) <code>0</code> и lower (нижняя) <code>-1</code>), который центрирован относительно значения переменной <code>θ</code>, для конкретного кандидата. С учётом этого имеем три набора: нижняя точка <code>(p, -1, θ - λ)</code>, средняя точка <code>(p, 0, θ)</code> и верхняя точка <code>(p, +1, θ + λ)</code>, где <code>λ</code> — корневое расстояние синхронизации, вычисляемое при каждом его применении с помощью прикладного процесса <code>rootdist()</code>. При реализации процедуры (алгоритма) селекции выделяют следующие итерации:</p><pre>                          +-----------------+
                          | clock_select()  |
                          +-----------------+
...................................|.............
.                                  V            .
.       Да +---------+ +----------------------+ .
.       +--|Приемлем?| |      Отобранные      | .
.       |  +---------+ |      кандидаты       | .
.       V       Нет |  |                      | .
.  +---------+      |  |                      | .
.  | Добавить|      |  |                      | .
.  |кандидата|      |  |                      | .
.  +----------      |  |                      | .
.       |           V  |                      | .
.       +---------->-->|                      | .
.                      |                      | .
.  Алгоритм селекции   +----------------------+ .
...................................|.............
                                   V
                   Нет +------------------------+
         +-------------|      Претендент?       |
         |             +------------------------+
         |                         | Да
         |                         V
         |             +------------------------+
         |             | Алгоритм кластеризации |
         |             +------------------------+
         |                         |
         |                         V
         V          Да +------------------------+
         |&lt;------------|       n &lt; CMIN?        |
         |             +------------------------+
         V                         |
  +-----------------+              V Нет
  |   s.p = NULL    |  +------------------------+
  +-----------------+  |      s.p = v<sub>0</sub>.p       |
         |             +------------------------+
         V                         |
+-------------------+              V
|     В начало      |  +------------------------+
|(без синхронизации)|  |        В начало        |
+-------------------+  | (наличие синхронизации)|
                       +------------------------+

Рис.21. Прикладной процесс "clock_select()"</pre><ol class="lia"><li><p>Для каждого из m виртуальных соединений, в списке претендентов формируются три набора переменных.</p></li><li><p>Классификация наборов переменных в списке на основе компонента <code>edge</code> в следующем порядке: нижняя точка, средняя точка и верхняя точка этих интервалов, начиная с самого нижнего значения и заканчивая самым верхним значением. Присваиваем нулевое значение числу некорректных источников синхронизации (<code>f = 0</code>).</p></li><li><p>Присваиваем нулевое значение числу средних точек (<code>d = 0</code>). Присваиваем <code>с</code> нулевое значение (<code>с = 0</code>). Проверяем все крайние точки, начиная с самой нижней и заканчивая самой верхней. Прибавляем к <code>с</code> единицу при проверке каждой нижней точки, и вычитаем единицу после каждой верхней точки, добавляем единицу к <code>d</code> после каждой средней точки. Если <code>с ≥ m - f </code>, процедура завершается, а текущему значению числа нижних точек присваивается единица.</p></li><li><p>Присваиваем <code>с</code> нулевое значение (<code>с = 0</code>). Проверяем все крайние точки, начиная с самой верхней и заканчивая самой нижней. Прибавляем к <code>с</code> единицу при проверке каждой верхней точки, и вычитаем единицу после каждой нижней точки, добавляем единицу к <code>d</code> после каждой средней точки. Если <code>с ≥ m - f </code>, процедура завершается, а текущему числу верхних точек присваивается значение <code>u</code>.</p></li><li><p>Проверяем равенство <code>d = f</code> и неравенство <code>l &lt; u</code>. Если они выполняются, то тогда процедур завершилась успешно, а интервал перекрытия составляет [l, u]. Если же нет, то тогда увеличиваем на единицу значение <code>f</code>. После этого проверяем неравенство <code>f &lt; m/2</code>. Если оно выполняется, то тогда процедура возвращается на третью итерацию. Если же оно не выполняется, то тогда процедура переходит на шестую итерацию.</p></li><li><p>Процедура завершилась «неудачей». Максимальное число корректных часов не определено. Нет приемлемых кандидатов для корректировки системного времени.</p></li></ol><p>Необходимо отметить, что эта процедура начинается в предположении, что некорректные часы отсутствуют (<code>f = 0</code>) и она «пытается» найти непустой интервал перекрытия, содержащий средние точки всех корректных серверов времени, то есть надёжных источников синхронизации. Если нельзя найти непустой интервал, то тогда число предполагаемых некорректных источников синхронизации увеличивается на единицу, а попытка отыскания непустого интервала повторяется. Если же непустой интервал найден, а число некорректных источников синхронизации меньше, чем корректных, то тогда считается, что найдена группа основных источников синхронизации и средняя точка каждого такого источника (<code>θ</code>) представляет собой кандидата, который в дальнейшем обрабатывается процедурой (алгоритмом) кластеризации.</p><p>Если же группа основных источников синхронизации не найдена, или если число корректных источников синхронизации меньше, чем значение параметра <code>CMIN</code>, то тогда для процесса настройки и корректировки системных часов не хватает приемлемых кандидатов. Параметр <code>CMIN</code> определяет минимальное количество серверов времени, удовлетворяющих требованиям корректности. Более внимательные сетевые администраторы могли бы установить такое значение параметра <code>CMIN</code>, которое бы гарантировало несколько дополнительных серверов времени, вполне приемлемых для их обработки соответствующими алгоритмами оптимизации. Однако, исторически сложилось так, что значение параметра <code>CMIN</code>, по-умолчанию, равно единице.</p><h4 id="p11.2.2">11.2.2. Процедура (алгоритм) кластеризации</h4><p>Кандидаты из группы основных источников синхронизации помещаются в списке оставшихся претендентов <code>v</code> в форме наборов параметров (<code>p, θ<sub>p</sub>, ψ<sub>p</sub>, λ<sub>p</sub></code>), в котором <code>p</code> — идентификатор виртуального соединения, <code>θ<sub>p</sub>, ψ<sub>p</sub>, stratum<sub>p</sub></code> — текущие значения сдвига, джиттера и номера «слоя» р-го виртуального соединения, соответственно, а <code>λ<sub>p</sub></code> — весовой коэффициент равный выражению <code>stratum<sub>p</sub> × MAXDIST + λ</code>, где <code>λ</code> — корневое расстояние синхронизации для р-го виртуального соединения. Перечень основных источников синхронизации обрабатывается процедурой (алгоритмом) кластеризации, в этой обработке принимает участие вторая часть прикладного процесса <code>clock_select()</code>:</p><ol class="lia"><li><p>Пусть набор <code>p, θ<sub>p</sub>, ψ<sub>p</sub>, λ<sub>p</sub></code> определяет кандидат из списка основных источников синхронизации.</p><li><p>Классифицируем кандидатов с учётом возрастания <code>λ<sub>p</sub></code>. Пусть <code>n</code> — число кандидатов, а параметр <code>NMIN</code> определяет минимально необходимое число кандидатов в списке основных источников синхронизации.</p></li><li><p>Для каждого кандидата определяется селективный джиттер <code>ψ<sub>s</sub></code>:</p><pre>     +-----             -----+<sup>1/2</sup>
     |        n-1            |
     |        ---            |
     |   1    \              |
ψ<sub>s</sub> = | ---- * /  (θ<sub>s</sub> - θ<sub>j</sub>)<sup>2</sup>  |
     |  n-1   ---            |
     |        j=1            |
     +-----             -----+</pre></li><li><p>Выбираем кандидата с максимальным значением <code>ψ<sub>s</sub></code> и обозначаем <code>ψ<sub>max</sub></code>.</p></li><li><p>Выбираем кандидата с минимальным значением <code>ψ<sub>p</sub></code> и обозначаем <code>ψ<sub>min</sub></code>.</p></li><li><p>Проверяем неравенства <code>ψ<sub>max</sub> &lt; ψ<sub>min</sub></code> или <code>n ≤ NMIN</code>. Если они выполняются, то тогда процедура считается выполненной, а оставшиеся кандидаты в списке основных источников синхронизации ранжируются в порядке предпочтения. Первая запись в списке определяет системный удалённый сервер времени, а его переменные в дальнейшем используются для обновления системных переменных. Если неравенства не выполняются, то тогда претендент со значением <code>ψ<sub>max</sub></code> удаляется из списка, значение <code>n</code> уменьшается на единицу, а процедура переходит на третью итерацию (<code>λ</code>).</p></li></ol><p>Данная процедура (алгоритм) функционирует циклически, и при каждом цикле удаляет из списка основных источников синхронизации одного из кандидатов, имеющего максимальный селективный джиттер <code>ψ<sub>s</sub></code>. Однако, если значение <code>ψ<sub>s</sub></code> меньше минимального значения джиттера удалённого сервера времени <code>ψ<sub>p</sub></code>, то тогда добиться улучшения качества синхронизации путём удаления «бракуемых» серверов времени не возможно. В противном случае (<code>ψ<sub>s</sub> > ψ<sub>p</sub></code>), определяется минимальный состав основных источников синхронизации, что позволяет корректно завершить процедуру. После её завершения регистрируется финальное значение <code>ψ<sub>max</sub></code>, так как оно в последующем используется в качестве системного селективного джиттера <code>Ψ<sub>s</sub></code>.</p><h4 id="p11.2.3">11.2.3. Процедура (алгоритм) суммирования</h4><p>Оставшиеся претенденты на роль основных источников синхронизации обрабатываются прикладным процессом <code>clock_combine()</code> с целью определения наилучших и заключительных значений параметров, которые будут в последующем использоваться процедурой (алгоритмом) корректировки (настройки) времени (часов). Прикладной процесс <code>clock_combine()</code> обрабатывает статистические значения сдвига и джиттера с целью определения суммарного системного значения сдвига <code>Θ</code> и системного значения джиттера <code>Ψ<sub>p</sub></code> удалённого сервера, при этом статистическому параметру каждого сервера времени присваивается весовой коэффициент на основе вычисления значения обратной величины корневого расстояния синхронизации и нормирования результата.</p><p>Суммарное значение <code>Θ</code> используется прикладным процессом <code>clock_update()</code>. Первый претендент из списка основных источников синхронизации именуется как системный удалённый сервер времени с идентификатором <code>p</code>. Джиттер системного удалённого сервера времени <code>Ψ<sub>p</sub></code> является компонентом системного джиттера <code>Ψ</code>. Значение <code>Ψ<sub>p</sub></code> всё время используется совместно со значением селективного джиттера <code>Ψ<sub>s</sub></code> для определения системного джиттера:</p><pre>Ψ = [(Ψ<sub>s</sub>)<sup>2</sup> + (Ψ<sub>p</sub>)<sup>2</sup>]<sup>½</sup></pre><p>Каждый раз обновление данных синхронизации осуществляется с помощью прикладного процесса <code>clock_update()</code>, к которому происходит обращение после получения соответствующего NTPv4-сообщения от системного сервера времени. В соответствие с существующим правилом, данные обновления времени (синхронизации) уничтожаются, если время их поступления <code>p.t</code> было не строго более поздним, чем системное время <code>s.t</code> последнего обновления данных синхронизации. Передаваемые маркеры <code>IGNOR</code>, <code>PANIC</code>, <code>ADJ</code> и <code>STEP</code> определяют ответную реакцию прикладного процесса <code>local_clock()</code> и означают следующее:</p><ol><li><p><code>IGNOR</code></p><p class="lib">Данные обновления времени (синхронизации) были проигнорированы, так как принадлежали «отбракованному» источнику синхронизации.</p></li><li><p><code>PANIC</code></p><p class="lib">Значение сдвига на много превысило критическое пороговое значение <code>PANICT</code> (1000 сек). В связи с этим целесообразно завершить программу обработки и передать диагностическое сообщение системному администратору сети с последующей регистрацией данного события.</p></li><li><p><code>STEP</code></p><p class="lib">Значение сдвига не превысило критическое пороговое значение <code>PANICT</code>, но оно значительно больше, чем «пошаговое» пороговое значение <code>STEP</code> (125 мсек). В этом случае, часы «пошагово» сдвигаются к корректному значению сдвига, но так как это означает, что данные всех удалённых серверов времени стали неприемлемыми, все виртуальные синхросоединения должны быть переустановлены, а процедура NTPv4-синхронизации стартует с начала, как и в начальный период функционирования.</p></li><li><p><code>ADJ</code></p><div class="lib"><p>Значение сдвига не превысило «пошаговое» пороговое значение <code>STEP</code> и поэтому данные обновления времени (синхронизации) являются корректными. В этом случае, значения системных переменных обновляются на основе значений переменных удалённых серверов времени (рис.22).</p><table class="w640"><tr><th class="ar">Системные переменные</th><th class="nl" style="width:1%">&lArr;</th><th class="nl">Переменные системного сервера времени</th></tr><tr><td class="ar">s.leap</td><td class="nl">&lArr;</td><td class="nl">p.leap</td></tr><tr><td class="ar">s.stratum</td><td class="nl">&lArr;</td><td class="nl">p.stratum + 1</td></tr><tr><td class="ar">s.offset</td><td class="nl">&lArr;</td><td class="nl">Θ</td></tr><tr><td class="ar">s.jitter</td><td class="nl">&lArr;</td><td class="nl">Ψ</td></tr><tr><td class="ar">s.rootdelay</td><td class="nl">&lArr;</td><td class="nl">p .δ<sub>r</sub> + δ</td></tr><tr><td class="ar">s.rootdisp</td><td class="nl">&lArr;</td><td class="nl">p.ε<sub>r</sub> + p.ε + p.ψ + Φ×(s.t - p.t) + |Θ|</td></tr><tr><td class="ar">s.refid</td><td class="nl">&lArr;</td><td class="nl">p.refid</td></tr><tr><td class="ar">s.reftime</td><td class="nl">&lArr;</td><td class="nl">p.reftime</td></tr><tr><td class="ar">s.t</td><td class="nl">&lArr;</td><td class="nl">p.t</td></tr><tr><th colspan="3">Рис.22. Обновление системных переменных</th></tr></table></div></li></ol><p>На рис.22 не показана одна очень важная деталь. Рост дисперсии (<code>p.ε + p.ψ + Φ×(s.t - p.t) + |Θ|</code>) ограничивается снизу значением параметра <code>MINDISP</code>. В подсетях синхронизации, в которых используются высокопроизводительные ЛВС и быстродействующие процессоры, и в которых очень малы значения задержки и сдвига, ускоряется монотонный и чётко выраженный рост значения параметра <code>s.rootdisp</code> (<code>Ε</code>), что предотвращает образование петлевых синхромаршрутов между удалёнными серверами времени, функционирующими на одном и том же слое иерархии синхросети.</p><p>Системные переменные могут зависеть от конкретных прикладных программных NTPv4-модулей, и выступать в роли номинальных эксплуатационных характеристик и параметров. Системный сдвиг <code>Θ</code> представляет собой сдвиг времени относительно доступных источников синхронизации. Системный джиттер <code>Ψ</code> представляет собой оценку значения ошибки при определении значения системного сдвига, которая иногда именуется как ожидаемая ошибка. Корневая задержка <code>Δ</code> представляет собой общую задержку петлевого маршрута относительно первичного сервера времени. Корневая дисперсия <code>Ε</code> является суммарной дисперсией, накопленной во всей сети относительно первичного сервера времени. И в заключении, корневое расстояние синхронизации определяется следующим выражением:</p><pre>Λ = Ε + Δ / 2</pre><p>и представляет собой максимальное значение ошибки в следствие всех возможных нештатных или иных событий в сети.</p><h3 id="p11.3">11.3. Процедура (алгоритм) корректировки (настройки) времени (часов)</h3><p>В NTPv4-протоколе процедура (алгоритм) корректировки (настройки) времени (часов) несколько упрощена, а именно это касается одновременного использования двух принципиально различных систем управления с обратной связью (СУОС). В СУОС с фазовой автоподстройкой частоты (ФАПЧ) периодически с интервалом μ секунд происходит обновление значения фазы, которое напрямую используется для минимизации ошибки времени, а косвенно — ошибки частоты. В СУОС с частотной автоподстройкой частоты (ЧАПЧ) периодически с интервалом μ секунд происходит обновление значения частоты, которое напрямую используется для минимизации ошибки частоты, а косвенно — ошибки времени. Системы с ФАПЧ обычно более эффективны, когда преобладает сетевой джиттер, в то время как системы с ЧАПЧ более эффективны, когда преобладает отклонение частоты генератора.</p><pre>           θ<sub>r</sub>  + +---------\        +----------------+
   NTP --------->| Фазовый  \  V<sub>d</sub>   |                | V<sub>s</sub>
           θ<sub>c</sub>  - | детектор  ------>| Фильтр времени |----+
       +-------->|          /       |                |    |
       |         +---------/        +----------------+    |
       |                                                  |
 -----------                                              |
/ Генератор \                                             |
|  частоты  |                                             |
\           /                                             |
 -----------  .......................................     |
       ^      . Фильтр с управляющей обратной связью.     |
       |      . +---------+   x  +-------------+    .     |
       | V<sub>с</sub>   . | Коррек- |&lt;-----|             |    .     |
       +------.-| тировка |   y  | Предсказание|&lt;---------+
              . | времени |&lt;-----| фазы/частоты|    .
              . |         |      |             |    .
              . +---------+      +-------------+    .
              .......................................

Рис.23. Корректировка времени с помощью СУОС</pre><p>Процедура корректировки времени основана на СУОС (рис.23). Переменная <code>θ<sub>r</sub></code> представляет собой сдвиг, определённый с помощью процедуры (алгоритма) суммирования (фаза эталонного синхроисточника), переменная <code>θ<sub>с</sub></code> — сдвиг, формируемый генератором частоты (управляющая фаза). При каждом обновлении данных вырабатывается сигнал <code>V<sub>d</sub></code>, который представляет собой разность мгновенных значений фаз <code>θ<sub>r</sub> - θ<sub>с</sub></code>. Фильтр времени для каждого анализируемого сервера времени функционирует как линия задержки с отводами, в которой алгоритм фильтра времени выбирает нужный отвод для съёма выходного сигнала. Процедуры (алгоритмы) селекции, кластеризации и суммирования анализируют данные, поступившие от нескольких фильтров, для выработки сигнала <code>V<sub>s</sub></code>. Фильтр с управляющей обратной связью и импульсной характеристикой <code>F(t)</code> вырабатывает сигнал <code>V<sub>c</sub></code>, который управляет генератором частоты, формирующим выходной сигнал с частотой <code>ω<sub>c</sub></code> и окончательным значением фазы <code>θ<sub>с</sub></code>, и, таким образом, замыкается цепь обратной связи. Сигнал <code>V<sub>c</sub></code> генерируется процедурой корректировки времени.</p><p>Обычно, псевдолинейная СУОС, рассмотренная выше, выполняет функцию настройки системных часов. Однако, возможны случаи, когда использование нелинейного алгоритма приводит к значительному улучшению характеристик синхронизации. Одним из таких случаев является ситуация при которой, процедура корректировки времени начинается без какой-либо исходной информации о частоте встроенных часов. При использовании псевдолинейной СУОС необходимо несколько часов, чтобы достигнуть высокой точности измерения, и при этом в течении большей части этого периода времени невозможно увеличить интервал опроса. А при использовании нелинейной СУОС этот период времени уменьшается до 15 минут. Другим случаем является ситуация, при которой возникают случайные «всплески» (большие значения) джиттера в следствие сетевых перегрузок. Процедурная характеристика обеспечивает защиту от ошибок, вызванных такими «всплесками» джиттера, продолжающимися в течении менее, чем 15 минут.</p><p>На рис.24 представлены переменные (в нижнее регистре) и параметры (в верхнем регистре), используемые в процедуре корректировки времени.</p><p>Если не оговорено обратного, то тогда все переменные обозначаются префиксом <code>с</code>. Переменные <code>t</code>, <code>tc</code>, <code>state</code>, <code>hyster</code> и <code>count</code> являются целочисленными величинами, а остальные переменные имеют удвоенные значения с плавающей точкой.</p><p>Процедура настройки часов реализуется с помощью прикладного процесса <code>local_clock()</code>, обращение к которому происходит при функционировании прикладного процесса <code>clock_update()</code>. Прикладной процесс <code>local_clock()</code> состоит из двух этапов:</p><ol class="lia"><li>на первом этапе определяется состояние часов;</li><li>на первом этапе определяется временная константа и, таким образом, интервал опроса.</li></ol><table><tr><th>Наименование</th><th>Значение</th><th>Описание</th><tr><td>t</td><td>таймер</td><td>Счётчик секунд</td></tr><tr><td>offset</td><td>Θ</td><td>Суммарный сдвиг времени</td></tr><tr><td>resid</td><td>Θ<sub>r</sub></td><td>Остаточный сдвиг времени</td></tr><tr><td>freq</td><td>φ</td><td>Частота генератора часов</td></tr><tr><td>jitter</td><td>ψ</td><td>Джиттер сдвига времени</td></tr><tr><td>wander</td><td>ω</td><td>Отклонение частоты генератора часов</td></tr><tr><td>tc</td><td>τ</td><td>Временная константа (log<sub>2</sub>)</td></tr><tr><td>state</td><td>state</td><td>Состояние</td></tr><tr><td>adj</td><td>adj</td><td>Корректировка частоты</td></tr><tr><td>hyster</td><td>hyster</td><td>Счётчик запаздывания фазы</td></tr><tr><td>STEPT</td><td>125</td><td>Пошаговое значение сдвига (0,125 сек)</td></tr><tr><td>WATCH</td><td>900</td><td>Предельное значение сдвига (сек)</td></tr><tr><td>PANICT</td><td>1000</td><td>Критическое пороговое значение сдвига (сек)</td></tr><tr><td>LIMIT</td><td>30</td><td>Предел запаздывания фазы</td></tr><tr><td>PGATE</td><td>4</td><td>Интервал запаздывании фазы</td></tr><tr><td>TC</td><td>16</td><td>Шкала временной константы</td></tr><tr><td>AVG</td><td>8</td><td>Постоянная усреднения</td></tr><tr><th colspan="3">Рис.24. Параметры и переменные, используемые в процедуре корректировки времени</th></tr></table><p>Прикладной процесс <code>local_clock()</code> немедленно прекращается, если сдвиг превышает критическое пороговое значение сдвига <code>PANICT</code> (1000 сек). Функция перехода из одного состояния в другое реализуется с помощью прикладного процесса <code>rstclock()</code> (рис.25). В представленной на рис.25 таблице имеются четыре колонки, в которых указываются наименование состояния, переход и процедуры, если сдвиг <code>θ</code> меньше, чем значение <code>STEP</code>, переход и процедуры, если сдвиг <code>θ</code> больше, чем значение <code>STEP</code>, и соответствующие комментарии и пояснения.</p><p>В данной таблице переход в другое состояние обозначен стрелкой ("&rArr;"), после чего приводятся последующие процедуры. Процедуры, такие как корректировка времени и корректировка частоты реализуются с помощью СУОС ФАПЧ/ЧАПЧ в течении прикладного процесса <code>local_clock()</code>. Процедура ускоренной (пошаговой) корректировки времени реализуется напрямую, то есть с помощью непосредственного управляющего воздействия на часы, но такая корректировка осуществляется только тогда, когда сдвиг не превышает значение <code>WATCH</code> (900 сек) и больше, чем пошаговое значение сдвига <code>STEP</code> (0,125 сек). Такая процедура защищает нормальное функционирование часов в условиях экстремальной перегрузки сети.</p><p>Статистические переменные джиттер (<code>ψ</code>) и отклонение (<code>ω</code>) и вычисляются с помощью экспоненциального усреднения и весового коэффициента <code>AVG</code>. Экспоненциальная временнáя константа (<code>τ</code>) определяется путём сравнения значения <code>ψ</code> с величиной текущего сдвига <code>θ</code>. Если сдвиг в <code>PGATE</code> (4) раз больше, чем джиттер часов, то тогда значение счётчика запаздывания фазы <code>hyster</code> уменьшается на два, в противном случае — увеличивается на единицу. Если значение счётчика <code>hyster</code> достигло верхнего предела <code>LIMIT</code> (30), то тогда значение <code>τ</code> увеличивается на единицу. Если же значение счётчика <code>hyster</code> достигло нижнего предела <code>-LIMIT</code> (-30), то тогда значение <code>τ</code> уменьшается на единицу. Обычно значение <code>τ</code> колеблется около значения параметра <code>MAXPOLL</code>, но быстро уменьшается, если температурный всплеск вызвал большие колебания значения частоты.</p><table><tr><th>Состояние</th><th>θ &gt; STEP</th><th>θ &lt; STEP</th><th>Примечания</th></tr><tr><td>NSET</td><td>&rArr; FREQ<br>корректировка времени</td><td>&rArr; FREQ<br>пошаговая (ускоренная)<br>корректировка времени</td><td>Отсутствует файл со значением частоты</td></tr><tr><td>FSET</td><td>&rArr; SYNC<br>корректировка времени</td><td>&rArr; SYNC<br>пошаговая (ускоренная)<br>корректировка времени</td><td>Наличие файла созначением частоты</td></tr><tr><td>SPIK</td><td>&rArr; SYNC<br>корректировка частоты<br>корректировка времени</td><td>if &lt; 900 сек &rArr; SPIK<br>else &rArr; SYNC<br>пошаговая (ускоренная)<br>корректировка частоты<br>пошаговая (ускоренная)<br>корректировка времени</td><td>«Выбраковка» претендента</td></tr><tr><td>FREQ</td><td>if &lt; 900 сек &rArr; FREQ<br>else &rArr; SYNC<br>пошаговая (ускоренная)<br>корректировка частоты<br>корректировка времени</td><td>if &lt; 900 сек &rArr; FREQ<br>else &rArr; SYNC<br>пошаговая (ускоренная)<br>корректировка частоты<br>корректировка времени</td><td>Начальная частота</td></tr><tr><td>SYNC</td><td>&rArr; SYNC<br>корректировка частоты<br>корректировка времени</td><td>if &lt; 900 сек &rArr; SPIK<br>else &rArr; SYNC<br>пошаговая (ускоренная)<br>корректировка частоты<br>пошаговая (ускоренная)<br>корректировка времени</td><td>Нормальная процедура</td></tr><tr><th colspan="4">Рис.25. Таблица переходов из одного состояния в другое</th></tr></table><h3 id="p12">12. Процедура корректировки (настройки) времени (часов)</h3><p>Текущая корректировка времени (настройка часов) реализуется прикладным процессом <code>clock_adjust()</code>. Такая корректировка происходит один раз в секунду и предусматривает прибавление к значению текущей частоты корректирующего значения, а также фиксированной доли (в процентах) остаточного значения сдвига <code>θ<sub>r</sub></code>. Величина <code>θ<sub>r</sub></code>, по своей сути, является экспоненциальным показателем затухания значения <code>θ</code>, обеспечиваемого фильтром с СУОС при каждом обновлении данных синхронизации. Параметр <code>ТС</code> масштабирует временнỳю константу для удобного сравнения её с интервалом опроса.</p><p class="note">Замечание. Дисперсия <code>Ε</code> возрастает каждую секунду на значение <code>Φ</code>.</p><p>Процедура корректировки времени включает субпроцедуру прерывания таймера для управления счётчиком секунд <code>c.t</code>. Последний имеет нулевое значение при запуске NTPv4-службы времени, и затем увеличивается на единицу каждую секунду. Во время каждого прерывания происходит обращение к прикладному процессу <code>clock_adjust()</code> с целью проведения настройки часов с одновременной корректировкой времени и частоты. Затем проверяются все виртуальные соединения с целью определения является ли значение счётчика секунд равным или превышает значение переменной состояния <code>p.next</code>. Если так, то тогда происходит обращение в прикладному процессу опроса удалённых серверов времени с целью передачи NTPv4-сообщения и вычисления следующего значения <code>p.next</code>.</p><h2 id="p13">13. Процедура опроса</h2><p>Каждое виртуальное соединение обеспечивает процедуру опроса, которая проводится регулярно через определённый интервал времени с целью формирования и передачи NTPv4-сообщений для различных режимов функционирования виртуальных соединений (симметричном, клиентском и широковещательном сервера). Процедура опроса осуществляется непрерывно, независимо от того являются ли удалённые серверы времени достижимыми или нет. Непрерывность процедуры необходимо для управления фильтром времени и регистром достижимости.</p><h3 id="p13.1">13.1. Переменные процедуры опроса</h3><p>На рис.26 представлены переменные (в нижнее регистре) и параметры (в верхнем регистре), используемые в процедуре опроса. Если не оговорено обратного, то тогда все переменные обозначаются префиксом <code>p</code>.</p><table><tr><th>Наименование</th><th>Значение</th><th>Описание</th><tr><td>hpoll</td><td>hpoll</td><td>Экспоненциальное значение времени опроса сервера</td></tr><tr><td>last</td><td>last</td><td>Время последнего опроса</td></tr><tr><td>next</td><td>next</td><td>Время следующего опроса</td></tr><tr><td>reach</td><td>reach</td><td>Регистр достижимости</td></tr><tr><td>unreach</td><td>unreach</td><td>Счетчик недостижимых серверов времени</td></tr><tr><td>UNREACH</td><td>24</td><td>Предельное значение недостижимых серверов</td></tr><tr><td>BCOUNT</td><td>8</td><td>Количество последовательно передаваемых сообщений</td></tr><tr><td>BURST</td><td>flag</td><td>Согласие на восстановление соединения</td></tr><tr><td>IBURST</td><td>flag</td><td>Запрос на восстановление соединения</td></tr><tr><th colspan="3">Рис.26. Параметры и переменные, используемые в процедуре опроса</th></tr></table><p>Значения переменных опроса передаются с помощью NTPv4-сообщений вместе со значениями переменных обрабатываемых удалённым сервером в период сеанса связи (сессии). Переменные, используемые в процедуре опроса, имеют следующую кодировку:</p><ol class="lia"><li><p><code>hpoll</code></p><p class="lib">Знаковое целое число, представляющее собой экспоненциальное значение, то есть log<sub>2</sub> в секундах.</p></li><li><p><code>last</code></p><p class="lib">Целое число, представляющее собой значение счётчика секунд с момента передачи самого последнего NTPv4-сообщения.</p></li><li><p><code>next</code></p><p class="lib">Целое число, представляющее собой значение счётчика секунд до момента передачи следующего NTPv4-сообщения.</p></li><li><p><code>reach</code></p><p class="lib">8-битовое целое число, определяемое регистром сдвига, который используется совместно процедурой опроса и процедурой удалённого сервера.</p></li><li><p><code>unreach</code></p><p class="lib">Целое число, представляющее собой количество секунд, прошедших с момента, когда удалённый сервер времени стал недостижимым.</p></li></ol><h3 id="p13.2">13.2. Процессы (операции) процедуры опроса</h3><p>Как было указано ранее, каждую секунду в период процедуры корректировки времени происходит обращение к прикладному процессу <code>clock_adjust()</code>. Этот процесс обращается к другому прикладному процессу <code>poll()</code> при каждом очередном информационном взаимодействии по конкретному виртуальному соединению. Если время отправки очередного запрашивающего NTPv4-сообщения превысило значение счётчика секунд, то тогда прикладной процесс передаёт такое сообщение незамедлительно. В период функционирования виртуальных соединений в симметричном режиме (режимы 1, 2), в клиентском режиме (режим 3) и в широковещательном режиме сервера (режим 5) регулярно передаются полнофункциональные NTPv4-сообщения, содержащие все требуемые переменные и параметры. В широковещательном режиме клиента (режим 6) полнофункциональные NTPv4-сообщения не передаются, а передаются специализированные NTPv4-сообщения, содержащие только переменные достижимости удалённых серверов времени. Прикладной процесс <code>poll()</code>, в свою очередь, обращается к процессу <code>peer_xmit()</code> с целью передачи NTPv4-сообщения. Если флаг <code>BURST</code> установлен (имеет значение <code>1</code>), то тогда никаких последующих операций не проводится, за исключением обращения к прикладному процессу <code>poll_update()</code> с целью установки значения интервала следующего опроса. Если же флаг <code>BURST</code> не установлен (равен <code>0</code>), то тогда значение переменной достижимости сдвигается влево на один бит, а крайний правый бит обнуляется. Если удалённый сервер времени не был обнаружен в течении последних трёх интервалов опроса, то тогда происходит обращение к прикладному процессу <code>clock_filter()</code> с целью увеличения значения дисперсии.</p><p>Если флаг <code>BURST</code> установлен, а сервер достижим и может выступать в роли корректного источника синхронизации, то тогда клиентский NTPv4-модуль передает последовательность из восьми (<code>BCOUNT</code> = 8) NTPv4-сообщений в течение каждого интервала опроса. Интервал между поочерёдной передачей NTPv4-сообщений составляет две секунды. Если флаг <code>IBURST</code> установлен, а это означает, что это переданное сервером NTPv4-сообщение является первым, причём этот удаленный сервер считался недостижимым, то тогда клиентский NTPv4-модуль передает NTPv4-сообщение с установленным флагом <code>BURST</code>. Такая операция обмена флагами весьма полезна для ускоренного уменьшения расстояния синхронизации ниже предельного значения и быстрой синхронизации часов.</p><p>Если в поле <code>p.flags</code> («Флаги опроса») флаг <code>P_MANY</code> установлен, то такое соединение функционирует многоадресного клиентского соединения. Многоадресные клиентские соединения обеспечивают передачу NTPv4-сообщений в режиме клиента, которые размещаются в IP-пакетах с групповыми адресами, в течении временных интервалов со значением <code>MINPOLL</code> (минимальное экспоненциальное значение интервала опроса). Виртуальное соединение инициализируется со значения <code>TTL</code>, равного единице. Если к моменту времени следующего опроса число удалённых серверов, с которыми установлены виртуальные соединения, окажется меньше значения <code>MINCLOCK</code>, то тогда значение <code>TTL</code> увеличивается на единицу. Если значение <code>TTL</code> достигает своего предельного максимального значения <code>TTLMAX</code> и при этом не найдя минимально необходимое число <code>MINCLOCK</code> удалённых серверов времени, то тогда интервал опроса будет увеличиваться до тех пор, пока он не достигнет предельного значения <code>BEACON</code>, а при достижении этого значения процедура опроса стартует с начала.</p><p>Прикладной процесс <code>poll()</code> обладает специфическим свойством, а именно он возвращает значение интервала опроса в первоначальное, если удалённый сервер времени становится недостижимым. Если значение регистра достижимости <code>reach</code> не нулевое, то тогда сервер считается достижимым, а счётчик недостижимых серверов <code>unreach</code> устанавливается в нулевое значение. В противном случае, значение счётчика <code>unreach</code> увеличивается на единицу, причём это увеличение происходит при каждом опросе до максимального значения <code>UNREACH</code>. С этого момента при каждом опросе значение <code>hpoll</code> увеличивается на единицу, что означает удвоение интервала опроса до максимального значения <code>MAXPOLL</code>, которое определяется прикладным процессом <code>poll_update()</code>. Когда удалённый сервер времени вновь становится достижимым, то тогда значение счётчика <code>unreach</code> устанавливается в нулевое значение, значение <code>hpoll</code> переустанавливается в значение системной переменной <code>tc</code>, а процесс синхронизации начинает функционировать нормально.</p><p>Прикладной процесс <code>xmit_packet()</code> обеспечивает передачу NTPv4-сообщения. Некоторые значения переменных в заголовке нового NTPv4-сообщения копируются из результатов функционирования процедур удалённого сервера, которые содержались в предшествующем сообщении, а другие — из системных переменных. На рис.27 представлены значения переменных, которые отображаются в каждом поле заголовка NTPv4-сообщения.</p><table class="w640"><tr><th class="ar">Переменные заголовка</th><th class="nl" style="width:1%">&lArr;</th><th class="nl" style="width:50%">Переменные</th></tr><tr><td class="ar">x.leap</td><td class="nl">&lArr;</td><td class="nl">s.leap</td></tr><tr><td class="ar">x.version</td><td class="nl">&lArr;</td><td class="nl">s.version</td></tr><tr><td class="ar">x.mode</td><td class="nl">&lArr;</td><td class="nl">s.mode</td></tr><tr><td class="ar">x.stratum</td><td class="nl">&lArr;</td><td class="nl">s.stratum</td></tr><tr><td class="ar">x.poll</td><td class="nl">&lArr;</td><td class="nl">s.poll</td></tr><tr><td class="ar">x.precision</td><td class="nl">&lArr;</td><td class="nl">s.precision</td></tr><tr><td class="ar">x.rootdelay</td><td class="nl">&lArr;</td><td class="nl">s.rootdelay</td></tr><tr><td class="ar">x.rootdisp</td><td class="nl">&lArr;</td><td class="nl">s.rootdisp</td></tr><tr><td class="ar">x.refid</td><td class="nl">&lArr;</td><td class="nl">s.refid</td></tr><tr><td class="ar">x.reftime</td><td class="nl">&lArr;</td><td class="nl">s.reftime</td></tr><tr><td class="ar">x.org</td><td class="nl">&lArr;</td><td class="nl">p.xmt</td></tr><tr><td class="ar">x.rec</td><td class="nl">&lArr;</td><td class="nl">p.dst</td></tr><tr><td class="ar">x.xmt</td><td class="nl">&lArr;</td><td class="nl">clock</td></tr><tr><td class="ar">x.keyid</td><td class="nl">&lArr;</td><td class="nl">p.keyid</td></tr><tr><td class="ar">x.digest</td><td class="nl">&lArr;</td><td class="nl">md5 digest</td></tr><tr><th colspan="3">Рис.27. Содержание заголовка передаваемого NTPv4-сообщения "xmit_packet"</th></tr></table><p>В тех прикладных программных реализациях, в которых для обозначения корневой задержки и корневой дисперсии используется удвоенный тип данных с плавающей точкой, необходимо производить конвертирование этих переменных в укороченный NTP-формат. Все другие поля, либо копируются без изменений с системных переменных и переменных, обрабатываемых в удалённом сервере, либо в них проставляются метки времени с использованием системных часов. Обращение к прикладному процессу <code>poll_update()</code> происходит после получения корректного NTPv4-сообщения и сразу же после того, как было передано NTPv4-сообщение об опросе. Если флаг <code>IBURST</code> установлен, то тогда интервал опроса является фиксированным и равным 2 секундам. В противном случае, экспоненциальному значению интервала опроса сервера <code>hpoll</code> присваивается наименьшее значение среди: <code>ppoll</code>, изъятого из последнего принятого NTPv4-сообщения, или <code>hpoll</code>, сформированного прикладным процессом <code>poll()</code>, но это значение не должно быть меньше значения <code>MINPOLL</code> и больше значения <code>MAXPOLL</code>. Таким образом, процедура корректировки времени может быть полностью основана на выборках, но не может быть полностью зависима от них. Этот принцип позволяет сохранить динамическое поведение подсети синхронизации и защитить её от протокольных ошибок.</p><p>Экспоненциальное значение интервала опроса преобразуется в обычное значение интервала, которое после прибавления самого последнего значения переменной определяет следующую переменную, то есть время следующего интервала опроса. И в заключении, самое последнее значение переменной записывается в текущем счётчике секунд.</p><h2 id="p14">14. Простой протокол сетевого времени (SNTP)</h2><p>Первичные серверы и клиенты, взаимодействующие с NTPv4-подсетью синхронизации, функционируют в соответствие с простым протоколом сетевого времени (Simple Network Time Protocol — SNTPv4, RFC-4330), который не предусматривает использование рассмотренных выше алгоритмов (процедур) оптимизации (рис.28). SNTPv4-протокол предназначен для первичных серверов времени, оснащенных только одними эталонными часами, а также для клиентов, обслуживаемых одним сервером времени (поток пользователь-сервер, upstream), и независимых клиентов. Полнофункциональный программный NTPv4-модуль предназначен для вторичных серверов времени, взаимодействующих с несколькими клиентскими серверами (потоки пользователь-сервер, upstream), а также с несколькими прикладными серверами (потоки сервер-пользователь, downstream) или клиентами. В других случаях, отличающихся от указанных, программные NTPv4-модули и SNTPv4-модули, а также клиентские NTP/SNTPv4-модули полностью функционально совместимы и могут встречаться в любых NTP-подсетях синхронизации.</p><div class="pic"><img src="../img/rfc-5905-sntp-protocol.png" alt="Иерархия, структура и топология системы сетевого времени на основе SNTP-протокола" /><p>Рис.28. Иерархия, структура и топология системы сетевого времени на основе SNTP-протокола</p></div><p>Первичный SNTPv4-сервер, реализующий процедурную характеристику, представленную в разделе 8, не взаимодействует с другими серверами (то есть в режиме пользователь-сервер, upstream), за исключением одиночных эталонных часов (сервер, включающий только эталонный источник времени). В принципе, он не отличается от первичного NTPv4-сервера, который реализует алгоритмы оптимизации и, более того, способен «уравновешивать» значения нескольких эталонных источников времени.</p><p>После получения SNTPv4-запроса клиента, первичный SNTPv4-сервер (программный SNTPv4-модуль сервера) формирует и передаёт ответное SNTPv4-сообщение, содержащее значения переменных, которые представлены на рис.29.</p><p class="note">Замечание. Поле «Дисперсия» в заголовке SNTPv4-сообщения должно обновляться таким же образом, как это представлено в разделе 5.</p><table class="w640"><tr><th class="ar">Переменные заголовка</th><th class="nl" style="width:1%">&lArr;</th><th class="nl" style="width:50%">Переменные</th></tr><tr><td class="ar">x.leap</td><td class="nl">&lArr;</td><td class="nl">s.leap</td></tr><tr><td class="ar">x.version</td><td class="nl">&lArr;</td><td class="nl">r.version</td></tr><tr><td class="ar">x.mode</td><td class="nl">&lArr;</td><td class="nl">4</td></tr><tr><td class="ar">x.stratum</td><td class="nl">&lArr;</td><td class="nl">s.stratum</td></tr><tr><td class="ar">x.poll</td><td class="nl">&lArr;</td><td class="nl">r.poll</td></tr><tr><td class="ar">x.precision</td><td class="nl">&lArr;</td><td class="nl">s.precision</td></tr><tr><td class="ar">x.rootdelay</td><td class="nl">&lArr;</td><td class="nl">s.rootdelay</td></tr><tr><td class="ar">x.rootdisp</td><td class="nl">&lArr;</td><td class="nl">s.rootdisp</td></tr><tr><td class="ar">x.refid</td><td class="nl">&lArr;</td><td class="nl">s.refid</td></tr><tr><td class="ar">x.reftime</td><td class="nl">&lArr;</td><td class="nl">s.reftime</td></tr><tr><td class="ar">x.org</td><td class="nl">&lArr;</td><td class="nl">r.xmt</td></tr><tr><td class="ar">x.rec</td><td class="nl">&lArr;</td><td class="nl">r.dst</td></tr><tr><td class="ar">x.xmt</td><td class="nl">&lArr;</td><td class="nl">clock</td></tr><tr><td class="ar">x.keyid</td><td class="nl">&lArr;</td><td class="nl">r.keyid</td></tr><tr><td class="ar">x.digest</td><td class="nl">&lArr;</td><td class="nl">md5 digest</td></tr><tr><th colspan="3">Рис.29. Содержание заголовка передаваемого NTPv4-сообщения "fast_xmit"</th></tr></table><p>Программный SNTPv4-модуль клиента, реализующий процедурную характеристику, представленную в разделе 8, размещается в одиночном сервере времени, обслуживающем несколько клиентов, и в персональных компьютерах независимых клиентов. Он может взаимодействовать с любой NTP-подсетью синхронизации в соответствии с процедурной и логической характеристиками NTP-протокола, но по упрощенной процедуре с использованием только поля «Метка времени сервера при отправке NTP-ответа клиенту» в ответном SNTPv4-сообщении сервера и игнорированием всех других полей. Однако, дополнительное усложнение программного SNTPv4-модуля и, таким образом, доведение его до полнофункционального NTPv4-модуля (процедурная и логическая характеристики) является минимальным, и поэтому целесообразно применять полнофункциональный программный NTPv4-модуль.</p><h2 id="p15">15. Проблемы обеспечения безопасности</h2><p>NTPv4-протокол предусматривает использование дополнительной функции аутентификации (специальное поле «Authentication»), которая основана на применении MD5-алгоритма вычисления хэш-функции. Однако, в 2004 году последний был скомпрометирован и его стойкость была существенно понижена, что делает этот алгоритм крайне не эффективным<sup><abbr title="Bellovin, S. и E. Rescorla, Proceedings of the 13 th annual ISOC Network and Distributed System Security Symposium, «Deploying a new Hash Algorithm», Февраль 2006.">[?]</abbr></sup>.</p><p>В случае реализации NTPv4-протокола, как представлено в данном стандарте, широковещательные NTPv4-клиенты являются уязвимыми к нарушениям, вызываемых некорректным поведением расположенными в Internet-сети широковещательными SNTP/NTP-серверами, среди которых могут быть и серверы нарушителей. В таких случаях целесообразно использовать дополнительные средства обеспечения безопасности, среди которых основными являются управление доступом и аутентификация на основе криптоалгоритмов.</p><p>В разделе 8 рассматриваются способы защиты от атак типа «Повторная передача NTPv4-сообщений».</p><h2 id="p16">16. Вопросы, решаемые IANA</h2><p>Для NTP-протокола был утвержден транспортный порт (UDP/TCP) под номером <code>123</code>. IANA назначила для NTP-протокола два IP-адреса: <code>224.0.1.1</code> для IPv4-адресации и <code>:101</code> окончание для IPv6-адресации.</p><h2 id="p17">17. Благодарности</h2><p>The editors would like to thank Karen O'Donoghue, Brian Haberman, Greg Dowd, Mark Elliot, Harlan Stenn, Yaakov Stein, Stewart Bryant, and Danny Mayer for technical reviews and specific text contributions to this document.</p><h2 id="p18">18. Ссылки</h2><h3 id="p18.1">18.1. Нормативные документы</h3><table itemprop="references"><tr><td>[RFC-768]</td><td>Postel, J., <a href="../768.rfc" title="RFC 768 — Протокол датаграмм клиента (UDP)">«Протокол датаграмм клиента (UDP)», RFC 768</a>, STD 6, Август 1980.</td></tr><tr><td>[RFC-791]</td><td>Postel, J., <a href="../791.rfc" title="RFC 791 — Протокол IP (Internet Protocol)">«Протокол IP (Internet Protocol)», RFC 791</a>, STD 5, Сентябрь 1981.</td></tr><tr><td>[RFC-793]</td><td>Postel, J., <a href="../793.rfc" title="RFC 793 — Протокол управления передачей (TCP)">«Протокол управления передачей (TCP)», RFC 793</a>, STD 7, Сентябрь 1981.</td></tr><tr><td>[RFC-1321]</td><td>Rivest, R., <a href="../1321.rfc" title="RFC 1321 — Алгоритм цифровых подписей MD5">«Алгоритм цифровых подписей MD5», RFC 1321</a>, Апрель 1992.</td></tr><tr><td>[RFC-2119]</td><td>Bradner, S., <a href="../2119.rfc" title="RFC 2119 — Ключевые слова для обозначения уровня требований в RFC">«Ключевые слова для обозначения уровня требований в RFC», RFC 2119</a>, BCP 14, Март 1997.</td></tr></table><h3 id="p18.2">18.2. Дополнительная литература</h3><table itemprop="references"><tr><td>[CGPM]</td><td>Bureau International des Poids et Mesures, «Comptes Rendus de la 15e CGPM», 1976.</td></tr><tr><td class="nobr">[ITU-R_TF.460]</td><td>International Telecommunications Union, «ITU-R TF.460 Standard-frequency and time-signal emissions», Февраль 2002.</td></tr><tr><td>[RFC-1305]</td><td>Mills, D., «Network Time Protocol (Version 3) Specification, Implementation and Analysis», RFC 1305, Март 1992.</td></tr><tr><td>[RFC-1345]</td><td>Simonsen, K., «Character Mnemonics and Character Sets», RFC 1345, Июнь 1992.</td></tr><tr><td>[RFC-4330]</td><td>Mills, D., «Simple Network Time Protocol (SNTP) Version 4 for IPv4, IPv6 and OSI», RFC 4330, Январь 2006.</td></tr><tr><td>[RFC-5226]</td><td>Narten, T. и H. Alvestrand, «Guidelines for Writing an IANA Considerations Section in RFCs», BCP 26, RFC 5226, Май 2008.</td></tr><tr><td>[RFC-5906]</td><td>Haberman, B., Ed. и D. Mills, «Network Time Protocol Version 4: Autokey Specification», RFC 5906, Июнь 2010.</td></tr><tr><td>[ref6]</td><td>Marzullo and S. Owicki, «Maintaining the time in a distributed system», ACM Operating Systems Review 19, Июль 1985.</td></tr><tr><td>[ref7]</td><td>Mills, D.L., «Computer Network Time Synchronization — the Network Time Protocol», CRC Press, 304 pp, 2006.</td></tr><tr><td>[ref9]</td><td>Mills, D.L., Electrical and Computer Engineering Technical Report 06-6-1, NDSS, Июнь 2006, «Network Time Protocol Version 4 Reference and Implementation Guide», 2006.</td></tr></table></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 5905 - Протокол сетевого времени NTPv4",disqus_identifier="5905.rfc",disqus_url="http://rfc2.ru/5905.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>