<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../791.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 791 — Протокол IP (Internet Protocol)</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../791.rfc">RFC 791 — Протокол IP (Internet Protocol)</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 791</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank"><span itemprop="alternativeHeadline">Internet Protocol</span></a></dd><dd><div class="icon i7"></div> Предыдущие версии: RFC 760</dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Стандарт Интернета</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1981-09-01">Сентябрь 1981</time></dd><dd><div class="icon i5"></div> Автор: <span itemprop="author">J. Postel</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div id="text" itemprop="articleBody"><h3>Предисловие</h3><p style="font-style:italic">Этот документ содержит спецификацию стандарта DoD (Министерство обороны США) для протокола IP (IP). Документ основан на 6 предварительных вариантах спецификации протокола ARPA Internet и содержит фрагменты этих спецификаций. В разработке используемых в документе концепций и терминологии принимало участие множество людей. В данной редакции пересмотрены вопросы адресации, обработки ошибок, кодирования опций, приоритетов, изоляции (compartments) и ограничений протокола Internet.</p><p style="float:right;margin-top:-15px">Jon Postel, редактор</p><div style="font-style:italic;margin-top:35px;"><p>За время, прошедшее с момента завершения данного документа протокол IP стал одним из самых распространенных протоколов сетевого уровня ISO/OSI и сегодня этот протокол используется практически на каждом компьютере. Однако за прошедшие годы сильно изменилось толкование некоторых используемых в документе терминов и в переводе используются термины в их современном толковании, дабы не порождать путаницы.</p><p>Термин gateway в исходном документе использовался для обозначения устройств, которые сегодня называют маршрутизаторами (router), а термин шлюз (буквальный перевод gateway) обозначает обычно устройства (программы), обеспечивающие преобразование протоколов на более высоких уровнях модели ISO/OSI (например, почтовые шлюзы).</p><p>Термин Internet фактически перестал быть нарицательным именем и служит, прежде всего, для обозначения всего множества связанных между собой IP-сетей в масштабе планеты. Поэтому столь распространенное в оригинальном документе словосочетание protocol internet в переводе указывается как протокол IP.</p><p>Часто встречающийся в исходном документе термин local network interface переводится как 'интерфейс канального уровня», в соответствии с современной терминологией.</p></div><div style="float:right;margin-top:-15px">Николай Малых, переводчик</div><h2>Оглавление</h2><ul class="map"><li><a href="print#p1" title="Введение">1. Введение</a></li><li class="lia"><a href="print#p1.1" title="Мотивация">1.1. Мотивация</a></li><li class="lia"><a href="print#p1.2" title="Сфера действия протокола">1.2. Сфера действия протокола</a></li><li class="lia"><a href="print#p1.3" title="Интерфейсы">1.3. Интерфейсы</a></li><li class="lia"><a href="print#p1.4" title="Работа протокола">1.4. Работа протокола</a></li><li><a href="print#p2" title="Обзор">2. Обзор</a></li><li class="lia"><a href="print#p2.1" title="Связь с другими протоколами">2.1. Связь с другими протоколами</a></li><li class="lia"><a href="print#p2.2" title="Модель работы протокола">2.2. Модель работы протокола</a></li><li class="lia"><a href="print#p2.3" title="Функциональное описание">2.3. Функциональное описание</a></li><li class="lia"><a href="print#p2.4" title="Шлюзы">2.4. Шлюзы</a></li><li><a href="print#p3" title="Спецификация">3. Спецификация</a></li><li class="lia"><a href="print#p3.1" title="Формат заголовка IP">3.1. Формат заголовка IP</a></li><li class="lia"><a href="print#p3.2" title="Обсуждение">3.2. Обсуждение</a></li><li class="lia"><a href="print#p3.3" title="Интерфейсы">3.3. Интерфейсы</a></li><li><a href="print#p.appendix.a" title="Примеры и сценарии">Приложение A: Примеры и сценарии</a></li><li><a href="print#p.appendix.b" title="Порядок передачи данных">Приложение B: Порядок передачи данных</a></li><li><a href="print#p.glossary" title="Глоссарий">Глоссарий</a></li><li><a href="print#p.references" title="Литература">Литература</a></li></ul><h2 id="p1">1. Введение</h2><h3 id="p1.1">1.1. Мотивация</h3><p>Протокол IP предназначен для использования в соединенных между собой компьютерных сетях обмена данными на основе коммутации пакетов. Такие системы получили название catenet [1]. Протокол обеспечивает передачу блоков данных, называемых дейтаграммами между отправителем и получателем, хосты которых идентифицируются адресами фиксированной длины. Протокол также обеспечивает фрагментацию и сборку для дейтаграмм большого размера, если сеть не позволяет передать дейтаграмму целиком.</p><h3 id="p1.2">1.2. Сфера действия протокола</h3><p>Протокол IP ограничивается доставкой битовых пакетов (дейтаграмм) от отправителя к получателю через систему соединенных между собой сетей. Протокол не поддерживает механизмов повышения надежности сквозной доставки, управления потоком данных, сохранения порядка и других функций, общепринятых для протоколов прямого взаимодействия между хостами. Протокол IP использует услуги поддерживающих этот протокол сетей для предоставления услуг различного типа и с разным качеством.</p><h3 id="p1.3">1.3. Интерфейсы</h3><p>Этот протокол вызывается протоколами взаимодействия «хост-хост» и сам вызывает функции локальных сетевых протоколов  для передачи дейтаграмм следующему маршрутизатору или хосту-получателю.</p><p>Например, модуль TCP будет вызывать модуль IP для размещения сегмента TCP (заголовок TCP и пользовательские данные) как объекта данных дейтаграммы IP. Модуль TCP будет указывать адреса и другие параметры заголовка IP в качестве аргументов при вызове функции IP. Модуль IP будет создавать дейтаграмму IP и обращаться к локальному сетевому интерфейсу для передачи дейтаграммы.</p><p>Для случая ARPANET, например, модуль IP будет вызывать модуль локальной сети, который добавит заголовок типа 1822 [2] к дейтаграмме, создавая сообщение ARPANET для передачи IMP. Адрес ARPANET определяется из адреса IP интерфейсом с локальной сетью и будет принимать значение адреса какого-либо из хостов ARPANET, который может быть шлюзом в другую сеть.</p><h3 id="p1.4">1.4. Работа протокола</h3><p>Протокол IP выполняет две основных функции — адресацию и фрагментацию/сборку дейтаграмм.</p><p>Модули IP используют адреса из заголовков IP для передачи дейтаграмм в направлении получателя. Процесс выбора пути к адресату называется маршрутизацией.</p><p>Модули IP используют поля заголовков IP для фрагментации и сборки дейтаграмм IP при необходимости передачи через сети с малым размером пакетов.</p><p>Модули IP используются на каждом хосте, участвующем в сети и на каждом маршрутизаторе, соединяющем сети. Эти модули используют общие правила интерпретации полей адреса и фрагментации/сборки дейтаграмм IP. Кроме того, эти модули (особенно в маршрутизаторах) выполняют процедуры принятия решения о пересылке дейтаграмм и выполняют еще ряд функций.</p><p>Протокол IP трактует каждую дейтаграмму как независимый элемент, не связанный с другими дейтаграммами IP. Протокол не использует соединения или логических устройств (виртуальных или иных).</p><p>Для обеспечения сервиса протокол IP использует 4 ключевых механизма — ToS (тип обслуживания), TTL (время жизни), Options (опции) и Header Checksum (контрольная сумма заголовка).</p><p>Тип обслуживания (ToS) используется для индикации желаемого качества сервиса. ToS представляет собой абстрактный или обобщенный набор параметров, характеризующих выбранный сервис, который обеспечивается в сетях, образующих Internet. Индикация ToS используется маршрутизаторами для выбора реальных параметров передачи применительно к конкретной сети, следующего интервала или следующего маршрутизатора при доставке дейтаграмм IP.</p><p>Время жизни TTL определяет максимальный срок существования дейтаграмм IP. Это значение устанавливается отправителем и уменьшается в каждой точке на пути доставки, где дейтаграмма подвергается обработке. Если значение TTL становится нулевым до того, как дейтаграмма будет доставлена адресату, такая дейтаграмма просто уничтожается. Можно рассматривать TTL как время саморазрушения дейтаграмм.</p><p>Опции обеспечивают функции контроля требуемые или полезные в некоторых ситуациях, но не используемые для большинства рутинных задач. Опции включают временные метки, параметры безопасности и специальные средства маршрутизации.</p><p>Контрольная сумма заголовка обеспечивает возможность проверки корректности передачи дейтаграмм IP. Если при передаче дейтаграмма была повреждена вычисленная заново при обработке контрольная сумма заголовка не совпадет с содержащимся в дейтаграмме значением контрольной суммы и такая дейтаграмма отбрасывается как ошибочная.</p><p>Протокол IP не обеспечивает механизма гарантированной доставки. В протоколе не используется подтверждений (сквозных или поэтапных) доставки или средств контроля ошибок (за исключением контрольных сумм заголовка). Протокол также не поддерживает средств повтора передачи и управления потоком данных.</p><p>При обнаружении ошибок информация о них может передаваться с помощью протокола ICMP (Internet Control Message Protocol) [<a href="../792.rfc" title="RFC 792 - Протокол ICMP">RFC792</a>], реализуемого в модуле IP.</p><h2 id="p2">2. Обзор</h2><h3 id="p2.1">2.1. Связь с другими протоколами</h3><p>На приведенном рисунке (Рисунок 1) показаны связи IP с другими протоколами:</p><pre>+------+ +-----+ +-----+     +-----+
|Telnet| | FTP | | TFTP| ... | ... |
+------+ +-----+ +-----+     +-----+
      |   |         |           |
     +-----+     +-----+     +-----+
     | TCP |     | UDP | ... | ... |
     +-----+     +-----+     +-----+
        |           |           |
     +--------------------------+----+
     |           IP & ICMP           |
     +--------------------------+----+
                    |
       +---------------------------+
       |  Протокол локальной сети  |
       +---------------------------+

Рисунок 1. Связь с другими протоколами</pre><p>Протокол IP взаимодействует с протоколом вышележащего уровня (протоколы взаимодействия между хостами — host-to-host) и с нижележащим протоколом локальной сети (в этом контексте локальной сетью может считаться небольшая сеть в одном здании или распределенная сеть типа ARPANET).</p><h3 id="p2.2">2.2. Модель работы протокола</h3><p>Модель передачи дейтаграмм от одной прикладной программы к другой можно проиллюстрировать описанным ниже сценарием.</p><p>Будем предполагать что передача включает лишь один промежуточный шлюз.</p><p>Передающая программа готовит свои данные и вызывает локальный модуль IP для передачи этих данных как дейтаграммы, указывая адрес получателя и другие параметры в качестве аргументов.</p><p>Модуль IP готовит заголовок дейтаграммы и присоединяет к нему данные. После этого модуль IP определяет локальный сетевой адрес для указанного получателя (в данном случае это адрес шлюза).</p><p>Модуль передает дейтаграмму и локальный адрес локальному сетевому интерфейсу.</p><p>Интерфейс канального уровня создает заголовок и присоединяет к нему дейтаграмму IP, после чего пакет передается в локальную сеть.</p><p>Дейтаграмма приходит на хост-шлюз в пакете канального уровня. Интерфейс канального уровня удаляет заголовок канального уровня и передает дейтаграмму модулю IP. Модуль IP определяет на основе IP-адреса, что дейтаграмму следует переслать хосту другой сети. Тогда модуль IP определяет адрес канального уровня для пересылки дейтаграммы получателю и вызывает интерфейс канального уровня той сети, куда будет передаваться дейтаграмма.</p><p>Интерфейс канального уровня создает заголовок и, присоединив к нему дейтаграмму, передает пакет хосту-адресату. На хосте получателя дейтаграмма выделяется из пакета интерфейсом канального уровня и передается модулю IP. Модуль IP определяет по заголовку, что дейтаграмма адресована приложению на данном хосте и передает прикладной программе данные из дейтаграммы вместе с адресом отправителя и другими параметрами в ответ на системный вызов.</p><pre>Прикладная программа                          Прикладная программа
        \                                            /
      модуль IP             модуль IP             модуль IP
          \                 /       \              /
          LNI-1          LNI-1      LNI-2        LNI-2
             \           /            \          /
            Локальная сеть 1         Локальная сеть 2


Рисунок 2. Путь передачи данных</pre><h3 id="p2.3">2.3. Функциональное описание</h3><p>Задачей протокола IP является перемещение дейтаграмм через множество соединенных между собою сетей. Эта задача решается путем передачи дейтаграмм от одного модуля IP к другому, пока дейтаграмма не будет доставлена адресату. Модули IP размещаются на хостах и шлюзах (маршрутизаторах) Internet. Дейтаграммы маршрутизируются от одного модуля IP к другому через промежуточные сети на основе интерпретации адресов IP. Таким образом, одним из важнейших механизмов IP является адресация.</p><p>При маршрутизации сообщений от одного модуля IP к другому может потребоваться передача дейтаграмм через сети, для которых максимальный размер пакета меньше размера дейтаграммы. Для решения этой проблемы протокол IP обеспечивает механизмы фрагментации и сборки дейтаграмм.</p><h4>Адресация</h4><p>Следует различать имена, адреса и маршруты [4]. Имя указывает объект, который мы видим. Адрес показывает местонахождение, а маршрут говорит, как до него добраться. Протокол IP имеет дело преимущественно с адресами. Отображение адресов на имена и обратно (преобразование) является задачей протоколов более высоких уровней (т. е., транспортного и сеансового). Модуль IP преобразует адреса IP в адреса локальной сети. Отображение адресов локальной сети в маршруты является задачей процедур нижележащего уровня (т. е.. локальной сети или шлюзов).</p><p>Адреса имеют IP фиксированную длину — 4 октета (32 бита). Адрес начинается с номера сети, за которым следует локальный адрес (его называют полем rest — остаток). Существует три класса адресов IP — класс A, в котором старший бит имеет значение 0, остальные 7 битов старшего октета задают номер сети, а 24 младших бита — номер хоста; класс B, в котором два старших бита имеют значения 10, следующие 14 битов определяют номер сети, а последние 16 битов — номер хоста; класс C, в котором три старших бита имеют значения 110, следующие 21 образуют номер сети, а последние 8 битов определяют номер хоста.</p><p>Следует с осторожностью относиться к преобразованию адресов IP в адреса локальной сети, поскольку один физический хост может функционировать как несколько различных хостов, использующих разные адреса IP. И наоборот, некоторые хосты могут использовать множество физических интерфейсов (многодомные хосты — multi-homing).</p><p>Таким образом, следует обеспечить возможность присутствия на хосте множества физических интерфейсов в сеть, каждый из которых может иметь несколько логических адресов IP.</p><p>Примеры отображения адресов приводятся в работе Address Mappings [RFC796].</p><h4>Фрагментация</h4><p>Фрагментация дейтаграмм IP требуется в тех случаях, когда дейтаграмма происходит из сети, которая поддерживает больший размер пакетов, нежели промежуточные сети на пути к адресату.</p><p>Дейтаграмма IP может быть помечена как don't fragment (не фрагментировать). Такие дейтаграммы не будут фрагментироваться ни при каких обстоятельствах. Если нефрагментируемая дейтаграмма IP не может быть доставлена адресату без фрагментации, она просто отбрасывается.</p><p>Допускается использование невидимой для модуля IP фрагментации, передачи и сборки дейтаграмм в локальной сети [6].</p><p>Процедуры фрагментации и сборки дейтаграмм должны обеспечивать возможность разбиения дейтаграмм на почти произвольное число частей, которые впоследствии могут быть собраны воедино. Получатель фрагментов использует поле идентификации для того, чтобы фрагменты разных дейтаграмм не перемешивались. Поле смещения дейтаграммы говорит получателю о положении фрагмента в исходной дейтаграмме. Поля смещения и размера фрагмента определяют часть исходной дейтаграммы, содержащуюся в отдельном фрагменте. Флаг наличия последующих фрагментов (если он сброшен) говорит о том, что фрагмент является последним в дейтаграмме.</p><p>Поле идентификации позволяет различать фрагменты разных дейтаграмм. Отправляющий дейтаграмму модуль протокола устанавливает значение поля идентификации в каждой дейтаграмме так, чтобы оно было уникальным для данной пары отправитель-получатель и протокола в течение времени присутствия дейтаграммы в сети Internet. Этот модуль также устанавливает нулевые значения смещения фрагмента и флага наличия других фрагментов (more-fragments flag).</p><p>Для фрагментирования длинной дейтаграммы IP модуль IP (например, на маршрутизаторе) создает две новых дейтаграммы IP и копирует содержимое полей заголовка из длинной дейтаграммы в заголовки обеих новых дейтаграмм. Данные исходной дейтаграммы делятся на две части по 64 битовой (8 октетов) границе. Вторая часть дейтаграммы может иметь размер, не кратный 8 октетам (64 битам), но первая часть должна содержать целое число 8-октетных блоков. Назовем число 8-октетных блоков в первой части дейтаграммы NFB (Number of Fragment Blocks — число блоков фрагментации). Первая часть дейтаграммы помещается в первую из новых дейтаграмм IP и поле длины устанавливается в соответствии длиной первой дейтаграммы. Для первой дейтаграммы устанавливается флаг наличия дополнительных фрагментов. Вторая часть данных помещается во вторую из созданных заново дейтаграмм и поле размера устанавливается в соответствии с длиной новой дейтаграммы. Значение поля смещения увеличивается на величину NFB. Значение флага наличия дополнительных фрагментов сохраняется в соответствии с флагом исходной нефрагментированной дейтаграммы.</p><p>Эту процедуру легко обобщить на случай разбиения дейтаграммы на n фрагментов, где n > 2. Для сборки фрагментов дейтаграммы IP, модуль IP (например, на хосте адресата) объединяет дейтаграммы IP с совпадающими значениями полей идентификации, адресов отправителя и получателя, а также протокола. Объединение осуществляется путем размещения данных из каждой дейтаграммы в позицию буфера, указанную полем смещения фрагмента в заголовке IP. Первый фрагмент будет иметь нулевое смещение, а для последнего фрагмента флаг more-fragments будет иметь нулевое значение.</p><h3 id="p2.4">2.4. Шлюзы</h3><p>Шлюзы обеспечивают пересылку дейтаграмм IP между сетями, обеспечивая также поддержку протокола GGP (Gateway to Gateway Protocol — протокол обмена данными между шлюзами) [7] для обмена данными маршрутизации и другой управляющей информацией.</p><p>В шлюзах реализация протоколов вышележащих уровней не обязательна и функции GGP могут быть реализованы в модуле IP.</p><pre>   +------------------------------+
   |        IP + ICMP + GGP       |
   +------------------------------+
          |                 |
+----------------+  +----------------+
| Локальная сеть |  | Локальная сеть |
+----------------+  +----------------+

Рисунок 3. Протоколы шлюзов</pre><h2 id="p3">3. Спецификация</h2><h3 id="p3.1">3.1. Формат заголовка IP</h3><p>Заголовок дейтаграмм internet имеет следующий формат:</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version|  IHL  |Type of Service|          Total Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification        |Flags|      Fragment Offset    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live |    Protocol   |         Header Checksum       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Source Address                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Destination Address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Рисунок 4. Формат заголовка дейтаграммы IP</pre><ul><li class="b">Version — 4 бита</li><li class="lib">Это поле указывает номер версии протокола и определяет формат заголовка. Данная спецификация описывает версию 4.</li><li class="b">IHL — 4 бита</li><li class="lib">Это поле содержит размер заголовка IP в 32-битовых словах и указывает на начало данных. Отметим, что минимальное значение этого поля для корректного заголовка составляет 5.</li><li class="b">ToS — 8 битов</li><li class="lib"><p>Поле ToS обеспечивает индикацию абстрактных параметров желаемого качества обслуживания. Это значение используется при выборе реальных параметров обслуживания в процессе передачи дейтаграммы через отдельную сеть. Некоторые сети предлагают приоритетный сервис, который тем или иным способом трактует трафик с большим уровнем предпочтения как более важный, нежели трафик другого типа (обычно при высокой загрузке просто воспринимается только трафик с уровнем предпочтения выше некоторого порога). Основной выбор осуществляется между тремя вариантами — малая задержка, высокая надежность, высокая пропускная способность.</p><table class="nobrd"><tr><td>биты 0-2:</td><td colspan="2">предпочтения.</td></tr><tr><td>бит 3:</td><td>0 = обычная задержка,</td><td>1 = малая задержка.</td></tr><tr><td>бит 4:</td><td>0 = обычная пропускная способность,</td><td>1 = высокая пропускная способность.</td></tr><tr><td>бит 5:</td><td>0 = обычная надежность,</td><td>1 = высокая надежность.</td></tr><tr><td>биты 6-7:</td><td colspan="2">зарезервированы для использования в будущем.</td></tr></table><pre>   0     1     2     3     4     5     6     7
+-----+-----+-----+-----+-----+-----+-----+-----+
|                 |     |     |     |     |     |
|   PRECEDENCE    |  D  |  T  |  R  |  0  |  0  |
|                 |     |     |     |     |     |
+-----+-----+-----+-----+-----+-----+-----+-----+</pre><p>Precedence (предпочтения):</p><ul><li>111 — управление сетью</li><li>110 — межсетевое управление</li><li>101 — CRITIC/ECP</li><li>100 — сверхсрочно</li><li>011 — срочно</li><li>010 — незамедлительно</li><li>001 — приоритетный</li><li>000 — обычный</li></ul><p>Использование флагов Delay, Throughput, Reliability может увеличивать стоимость (в том или ином смысле) обслуживания. Во многих сетях предпочтение по одному из этих параметров может быть связано с потерями по другому. За исключением специальных случаев следует использовать не более двух флагов из 3 возможных.</p><p>Значение ToS используется для задания способа обработки дейтаграмм в процессе их передачи через internet. Например, отображение значений ToS на реальные параметры обслуживания в сетях AUTODIN II, ARPANET, SATNET, PRNET описано в работе Service Mappings [RFC795].</p><p>Уровень предпочтения Network Control (управление сетью) означает, что дейтаграмма предназначена для использования внутри сети. Реальная трактовка этого обозначения определяется местными условиями сети. Значение Internetwork Control (межсетевое управление) показывает дейтаграммы, предназначенные только для управления шлюзами. Если та или иная сеть использует значение уровня предпочтения, она берет на себя ответственность за доступ к этим полям и их использование.</p></li><li class="b">Total Length — 16 битов</li><li class="lib"><p>Это поле указывает общий размер (в октетах) дейтаграммы с учетом заголовка и данных. Размер этого поля позволяет создавать дейтаграммы длиной до 65 535 октетов. Столь большие дейтаграммы неприемлемы для большинства хостов и сетей. Все хосты должны быть готовы к восприятию дейтаграмм размером до 576 октетов (целиком или в виде фрагментов). Хостам рекомендуется передавать дейтаграммы, размер которых превышает 576 октетов только в тех случаях, когда есть уверенность, что адресат может принимать такие дейтаграммы.</p><p>Значение 576 выбрано для того, чтобы дейтаграммы могли кроме заголовка содержать блок данных разумных размеров. Например, такой размер позволяет передавать блок данных размером 512 октетов с 64-октетным заголовком. Максимальный размер заголовка IP составляет 60 октетов, а размер типичного заголовка IP — 20 октетов, что оставляет достаточно места для заголовков вышележащих уровней.</p></li></ul><ul><li class="b">Identification — 16 битов</li><li class="lib">Значение поля идентификации присваивается отправителем для обеспечения корректной сборки фрагментов дейтаграммы.</li><li class="b">Flags — 3 бита</li><li class="lib"><p>Набор флагов управления.</p><table class="nobrd"><tr><td>Бит 0:</td><td colspan="2">(зарезервирован (должен иметь значение 0)</td></tr><tr><td>Бит 1:</td><td>(DF) 0 = фрагментация возможна,</td><td>1 = фрагментация недопустима.</td></tr><tr><td>Бит 2:</td><td>(MF) 0 = последний фрагмент,</td><td>1 = фрагмент не является последним.</td></tr></table><pre>  0   1   2
+---+---+---+
|   | D | M |
| 0 | F | F |
+---+---+---+</pre></li><li class="b">Fragment Offset — 13 битов</li><li class="lib">Это поле показывает положение данного фрагмента в исходной дейтаграмме. Смещение измеряется в единицах, кратных 8 октетам (64 бита). Смещение первого фрагмента равно нулю.</li><li class="b">TTL — 8 битов</li><li class="lib">Это поле определяет максимальный срок существования дейтаграммы в системе internet. Дейтаграммы с нулевым значением времени жизни должны уничтожаться. Значение этого поля изменяется при обработке заголовков IP. Время измеряется в секундах, но, поскольку каждый обрабатывающий дейтаграмму модуль должен уменьшать значение TTL, по крайней мере, на 1 (даже если обработка длилась меньше секунды), значение TTL следует рассматривать как верхний предел срока жизни дейтаграммы в систем. Это поле введено для того, чтобы можно было избавиться от недоставленных дейтаграмм.</li><li class="b">Protocol — 8 битов</li><li class="lib">Это поле указывает протокол следующего уровня, содержащийся в поле данных дейтаграммы IP. Идентификаторы протоколов указаны в Assigned Numbers [RFC790].</li><li class="b">Header Checksum — 16 битов</li><li class="lib"><p>Контрольная сумма полей заголовка. Поскольку некоторые поля заголовка (например, TTL) изменяются в процессе доставки, значение контрольной суммы проверяется и вычисляется заново в каждой точке обработки заголовков IP.</p><p>Контрольная сумма заголовка представляет собой 16-битовое поразрядное дополнение (one's complement) суммы поразрядных дополнений всех 16-битовых слов заголовка. При вычислении контрольной суммы значение самого поля принимается нулевым.</p><p>Контрольную сумму легко посчитать и можно показать ее адекватность, но алгоритм вычисления контрольной суммы может быть заменен специальной процедурой CRC с учетом опыта использования.</p></li><li class="b">Source Address — 32 бита</li><li class="lib">Адрес отправителя (см. параграф 3.2. Обсуждение).</li><li class="b">Destination Address — 32 бита</li><li class="lib">Адрес получателя (см. параграф 3.2. Обсуждение).</li><li class="b">Options — переменная длина</li><li class="lib"><p>Поле опций является необязательным. Поддержка опций должна реализоваться во всех модулях IP (на хостах и шлюзах). Использование опций определяется для отдельной дейтаграммы, а не для реализации модуля. В некоторых средах использование опций безопасности является обязательным.</p><p>Поле опций имеет переменную длину. Существует два варианта форматирования опций:</p><ul class="dot"><li>однооктетные опции;</li><li>октет типа опции, октет размера опции и октеты собственно опций (поле размера опции учитывает поля типа, размера и данных опции).</li></ul><p>Октет типа опции содержит три поля:</p><ul class="dot"><li>флаг копирования (1 бит);</li><li>класс опции (2 бита);</li><li>номер опции (5 битов).</li></ul><p>Флаг копирования показывает, что данная опция копируется во все фрагменты дейтаграммы:</p><ul class="dot"><li>0 — опция не копируется;</li><li>1 — опция копируется во фрагменты.</li></ul><p>Поле класса опций может принимать 4 значения:</p><ul class="dot"><li>0 — управление;</li><li>1 — зарезервирован;</li><li>2 — отладка и измерения;</li><li>3 — зарезервирован.</li></ul><p>Определены следующие номера опций IP:</p><table><tr><td>Класс</td><td>Номер</td><td>Длина</td><td>Описание</td></tr><tr><td>0</td><td>0</td><td>-</td><td>Конец списка опций (End of Option list). Эта опция занимает только 1 октет и не использует поле длины.</td></tr><tr><td>0</td><td>1</td><td>-</td><td>Нет операции. Эта опция занимает только 1 октет и не использует поле длины.</td></tr><tr><td>0</td><td>2</td><td>11</td><td>Безопасность (Security). Используется для передачи опций Security (безопасность), Compartmentation (изоляция), User Group (TCC), Handling Restriction Codes (коды управления ограничениями), совместимых с требованиями DOD.</td></tr><tr><td>0</td><td>3</td><td>перем.</td><td>Loose Source Routing (нестрогое задание маршрута отправителем). Используется для маршрутизации дейтаграмм IP с учетом данных, указанных отправителем.</td></tr><tr><td>0</td><td>9</td><td>перем.</td><td>Strict Source Routing (строгое задание маршрута отправителем). Используется для маршрутизации дейтаграмм IP на основе данных, указанных отправителем.</td></tr><tr><td>0</td><td>7</td><td>перем.</td><td>Record Route (запись маршрута). Используется для трассировки пути дейтаграмм IP.</td></tr><tr><td>0</td><td>8</td><td>4</td><td>Stream ID (идентификатор потока). Используется для обозначения потоков дейтаграмм.</td></tr><tr><td>2</td><td>4</td><td>перем.</td><td>Internet Timestamp (временная метка).</td></tr></table></li></ul><ul><li class="b">Определения отдельных опций</li><li class="lib"><ul><li>End of Option List:</li><li class="lib"><pre>+--------+
|00000000|
+--------+
  Type=0</pre><p>Эта опция указывает на завершение списка опций. Граница этой опции может не совпадать с окончанием заголовка IP, указанным полем длины заголовка. Данная опция служит для того, чтобы показать завершение списка использованных для дейтаграммы опций (а не отдельной опции). Использование опции требуется только в тех случаях, когда окончание списка опций не совпадает с завершением заголовка IP.</p><p>Эту опцию можно копировать, добавлять и удалять при фрагментации или по иным причинам.</p></li><li>No Operation:</li><li class="lib"><pre>+--------+
|00000001|
+--------+
  Type=1</pre><p>Такая опция может использоваться между другими опциями (например, для выравнивания начала следующей опции по 32-битовой границе).</p><p>Эту опцию можно копировать, добавлять и удалять при фрагментации или по иным причинам.</p></li><li><p>Security:</p></li><li class="lib"><p>Эта опция обеспечивает хостам способ передачи информации о безопасности, изоляции (compartmentation), ограничениях обслуживания и TCC (закрытые группы пользователей). Опция использует следующий формат:</p><pre>+--------+--------+---//---+---//---+---//---+---//---+
|10000010|00001011|SSS  SSS|CCC  CCC|HHH  HHH|  TCC   |
+--------+--------+---//---+---//---+---//---+---//---+
 Type=130 Length=11</pre><ul><li><p>Security (поле S) — 16 битов</p></li><li class="lib"><p>Опция позволяет задать 16 уровней безопасности (8 уровней зарезервированы для использования в будущем).</p><pre>00000000 00000000 - Unclassified
11110001 00110101 - Confidential
01111000 10011010 - EFTO
10111100 01001101 - MMMM
01011110 00100110 - PROG
10101111 00010011 - Restricted
11010111 10001000 - Secret
01101011 11000101 - Top Secret
00110101 11100010 - (Reserved for future use)
10011010 11110001 - (Reserved for future use)
01001101 01111000 - (Reserved for future use)
00100100 10111101 - (Reserved for future use)
00010011 01011110 - (Reserved for future use)
10001001 10101111 - (Reserved for future use)
11000100 11010110 - (Reserved for future use)
11100010 01101011 - (Reserved for future use)</pre></li><li><p>Compartments (поле C) — 16 битов</p></li><li class="lib"><p>Значение этого поля, содержащее только нули, означает, что передаваемые данные не требуют изоляции (compartment). Другие значения могут использоваться с разрешения Defense Intelligence Agency.</p></li><li><p>Handling Restrictions (поле H) — 16 битов</p></li><li class="lib"><p>Эти значения служат для управления разметкой и являются алфавитно-цифровыми направленными графами (определены в документе Defense Intelligence Agency Manual DIAM 65-19, "Standard Security Markings").</p></li><li><p>Transmission Control Code (поле TCC) — 24 бита</p></li><li class="lib"><p>Служит для разделения трафика и определения контролируемых «групп по интересам». Значения являются графами типа trigraph и доступны в HQ DCA Code 530.</p><p>Эта опция должна копироваться при фрагментации и появляется в дейтаграмме не более одного раза.</p></li></ul></li><li>Loose Source and Record Route:</li><li class="lib"><pre>+--------+--------+--------+---------//--------+
|10000011| length | pointer|     route data    |
+--------+--------+--------+---------//--------+
 Type=131</pre><p>Опция LSRR (нежестко заданный отправителем маршрут и запись пути) обеспечивает отправителям дейтаграмм IP способ предоставления маршрутной информации, используемой маршрутизаторами при пересылке дейтаграмм адресату, и записи маршрутной информации.</p><p>Опция начинается с кода типа (131), второй октет содержит значение размера опции с учетом полей типа и размера опции, а также октета указателя и собственно опции (маршрутных данных). Третий октет опции показывает октет маршрутных данных, начиная с которого будет обрабатываться следующий адрес отправителя. Отсчет смещения ведется от начала опции и значение указателя не может быть меньше 4.</p><p>Маршрутные данные состоят из цепочки адресов IP. Каждый адрес занимает 32 бита (4 октета). Если значение указателя превышает длину, это говорит о пустом маршруте source route (завершении записи пути) и маршрутизации на основе поля адреса получателя.</p><p>Если достигнут адрес из поля адреса получателя и указатель не превышает длину опции, следующий адрес из маршрута source route заменяет значение поля адреса получателя и адрес в записываемом маршруте заменяет используемый адрес отправителя, а значение указателя увеличивается на 4.</p><p>Адресом записываемого маршрута является собственный адрес модуля IP, известный в той среде, куда пересылается дейтаграмма.</p><p>Такая процедура замены source route записанным маршрутом (хотя в них и используется обратный по отношению друг к другу порядок) означает, что опция (и весь заголовок IP) сохраняет постоянный размер при передаче дейтаграммы через internet.</p><p>Эта опция не задает маршрут жестко, поскольку шлюзам и хостам IP разрешается использовать любой маршрут через любые промежуточные шлюзы для доставки дейтаграммы по адресу следующей точки маршрута.</p><p>Опция должна копироваться при фрагментации и появляется в дейтаграмме не более одного раза.</p></li><li>Strict Source and Record Route</li><li class="lib"><pre>+--------+--------+--------+---------//--------+
|10001001| length | pointer|     route data    |
+--------+--------+--------+---------//--------+
 Type=137</pre><p>Опция SSRR (жестко заданный отправителем маршрут и запись пути) обеспечивает отправителю дейтаграммы IP способ задания маршрутной информации, которая будет использоваться промежуточными маршрутизаторами для доставки дейтаграммы адресату и записи пути.</p><p>Опция начинается с идентификатора типа (137), за которым следует октет размера опции с учетом полей типа, длины, смещения и маршрутных данных. Третий октет опции содержит указатель (смещение от начала данной опции) на октет, с которого начинается следующий обрабатываемый адрес отправителя. Минимальное значение указателя составляет 4 (см. выше).</p><p>Маршрутные данные представляют собой цепочку адресов IP, каждый из которых занимает 32 бита (4 октета). Если указатель превышает размер опции, это говорит о пустом маршруте source route (завершении записи пути) и маршрутизации на основе адреса получателя.</p><p>Если достигнут адрес из поля адреса получателя и указатель не превышает длину опции, следующий адрес из маршрута source route заменяет значение поля адреса получателя и адрес в записываемом маршруте заменяет используемый адрес отправителя, а значение указателя увеличивается на 4.</p><p>Адресом записываемого маршрута является собственный адрес модуля IP, известный в той среде, куда пересылается дейтаграмма.</p><p>Такая процедура замены source route записанным маршрутом (хотя в них и используется обратный по отношению друг к другу порядок) означает, что опция (и весь заголовок IP) сохраняет постоянный размер при передаче дейтаграммы через internet.</p><p>Эта опция жестко задает маршрут, поскольку шлюзы и хосты IP должны передавать дейтаграмму непосредственно по следующему адресу, указанному в заданном отправителем маршруте, по всему пути доставки дейтаграммы адресату. Опция должна копироваться при фрагментации и появляется в дейтаграмме не более одного раза.</p></li><li>Record Route</li></ul></li></ul><ul><li><ul><li class="lib"><pre>+--------+--------+--------+---------//--------+
|00000111| length | pointer|     route data    |
+--------+--------+--------+---------//--------+
  Type=7</pre><p>Опция записи маршрута обеспечивает способ записи пути передачи дейтаграммы IP.</p><p>Опция начинается с поля типа (7), за которым следует поле длины, учитывающее полный размер опции (тип, размер, смещение, маршрутные данные). Третий октет содержит указатель на октет, с которого начинается следующая область записи маршрута. Смещение отсчитывается от начала опции, поэтому значение указателя не может быть меньше 4.</p><p>Записываемый маршрут представляет собой последовательность адресов IP, каждый из которых имеет длину 32 бита (4 октета). Если значение указателя превышает размер опции, это говорит о завершении записи маршрута. Отправляющий дейтаграмму хост должен обеспечить достаточное пространство (размер опции) для записи адресов на пути к получателю. В исходной дейтаграмме поля адресов должны иметь нулевые значения.</p><p>Когда модуль IP маршрутизирует дейтаграмму, он проверяет в ней наличие маршрутной записи. При наличии такой записи модуль помещает в нее свой адрес, известный в той среде, куда пересылается дейтаграмма, начиная со смещения, которое задано указателем, и увеличивая значение указателя на 4.</p><p>Если поле маршрутных данных уже заполнено (значение указателя превышает размер опции), дейтаграмма пересылается без дальнейшей записи маршрута. Если оставшегося пространства для записи маршрутных данных недостаточно для включения адреса, дейтаграмма рассматривается как ошибочная и отбрасывается. В таких случаях отправителю дейтаграммы может быть передано сообщение ICMP об ошибке в параметрах [<a href="../792.rfc" title="RFC 792 - Протокол ICMP">RFC792</a>].</p><p>Эта опция не копируется во фрагменты и не должна включаться в дейтаграмму более одного раза.</p></li><li>Stream Identifier</li><li class="lib"><pre>+--------+--------+--------+--------+
|10001000|00000010|    Stream ID    |
+--------+--------+--------+--------+
 Type=136 Length=4</pre><p>Эта опция позволяет передавать 16-битовые идентификаторы потоков SATNET через сети, которые не поддерживают концепцию потоков.</p><p>Опция должна копироваться при фрагментации и появляется в дейтаграмме не более одного раза.</p></li><li>Internet Timestamp</li><li class="lib"><pre>+--------+--------+--------+--------+
|01000100| length | pointer|oflw|flg|
+--------+--------+--------+--------+
|         internet address          |
+--------+--------+--------+--------+
|             timestamp             |
+--------+--------+--------+--------+
|                 .                 |
                  .
                  .
Type = 68</pre><p>Поле длины опции содержит значение, указывающее число октетов в поле типа опции, ее длины, указателя, полей Overflow, флагов и временных меток (всего до 40 октетов).</p><p>Поле указателя (Pointer) показывает смещение (в октетах) от начала опции до начала следующей временной метки. Таким образом, минимальное значение указателя равно 5. Область временных меток считается заполненной, когда значение указателя превышает размер опции.</p><p>Поле Overflow (oflw, переполнение — 4 бита) показывает число модулей IP, которые не смогли включить свои временные метки в результате нехватки места в опции.</p><p>Поле флагов (flg, 4 бита) может принимать следующие значения:</p><ul><li>0 — только временные метки, сохраняемые в последовательности 32-битовых слов;</li><li>1 — перед каждой меткой помещается IP-адрес регистрирующего метку модуля;</li><li>3 — поля адресов IP указываются заранее (prespecified) и модуль IP помещает временную метку только в том случае, когда адрес этого модуля указан следующим в списке адресов опции.</li></ul><p>Поля Timestamp (временная метка) выравниваются по правому краю и содержат число миллисекунд после полуночи по универсальному времени (UT).Если невозможно указать время в миллисекундах или нет привязки к универсальному времени, в поле метки может помещаться любое значение времени, а старший бит метки должен быть установлен (1), для индикации некорректности данной метки.</p><p>Отправляющий дейтаграмму хост должен предусмотреть достаточно места для записи временных меток по пути доставки дейтаграммы. Размер опции не может увеличиваться по мере добавления меток. Исходная дейтаграмма содержит нулевые значения всех предусмотренных в опции полей временных меток (кроме заранее указанных адресов IP).</p><p>Если область записи временных меток уже заполнена (значение указателя превышает размер опции), дейтаграмма пересылается без дальнейшей записи временных меток, но значение поля Overflow должно увеличиваться при каждой пересылке дейтаграммы.</p><p>Если в поле записи временных меток еще остается свободное место, но полная метка не помещается, такая дейтаграмма трактуется как ошибочная и отбрасывается. Отправителю такой дейтаграммы может быть передано сообщение ICMP о некорректности параметров дейтаграммы [<a href="../792.rfc" title="RFC 792 - Протокол ICMP">RFC792</a>].</p><p>Опция не копируется во фрагменты и передается только в первом фрагменте. Опция появляется в дейтаграмме только один раз</p></li></ul></li><li class="b">Padding — переменная длина</li><li class="lib">Поле заполнения служит для выравнивания размера заголовка IP по 32-битовой границе. Для заполнения используется значение 0.</li></ul><h3 id="p3.2">3.2. Обсуждение</h3><p>Реализация протокола должна быть гибкой и разумной. Каждая реализация должна предполагать интероперабельность с продукцией других разработчиков. Хотя целью данной спецификации является четкое и строгое описание протокола, существует вероятность различных интерпретаций стандарта. При передаче дейтаграмм следует строго следовать спецификации, сохраняя в то же время готовность к восприятию любых дейтаграмм, которые можно интерпретировать (например, не содержащих технических ошибок).</p><p>Базовый сервис internet ориентирован на обработку дейтаграмм и обеспечивает фрагментацию дейтаграмм на шлюзах и сборку фрагментов модулем IP хоста-получателя. Фрагментация и сборка дейтаграмм внутри отдельной сети или на основе частного соглашения также допустимы, поскольку процесс фрагментации и сборки совершенно прозрачен для IP и протоколов вышележащих уровней. Такая прозрачная фрагментация/сборка называется внутрисетевой (network-dependent или intranet) и не рассматривается в данной спецификации.</p><p>Адреса IP позволяют различить отправителя и получателя на уровне хоста. Дополнительные сведения содержатся в поле протокола. Предполагается, что каждый протокол обеспечивает мультиплексирование (если оно требуется) на хосте.</p><h4>Адресация</h4><p>Для обеспечения гибкого распределения адресов и поддержки большого числа сетей небольших и средних размеров используется специальная интерпретация полей адреса IP. Такая интерпретация позволяет выделить небольшое число адресов для крупных сетей, большее число адресов для сетей среднего размера и многочисленные адреса для небольших сетей. В дополнение к этому выделяется блок адресов для использования расширенного режима адресации.</p><p>Формат адресов:</p><table><tr><td>Старшие биты</td><td>Формат</td><td>Класс</td></tr><tr><td>0</td><td>7 битов задают номер сети, остальные 24 — номер хоста</td><td>A</td></tr><tr><td>10</td><td>14 битов задают номер сети, остальные 16 — номер хоста</td><td>B</td></tr><tr><td>110</td><td>21 бит задает номер сети, остальные 8 — номер хоста</td><td>C</td></tr><tr><td>111</td><td>Используется для расширенной адресации</td><td></td></tr></table><p class="note">Нулевое значение поля номера сети означает, что пакет адресован для данной сети. Такая адресация используется только для некоторых сообщений ICMP. Расширенный режим адресации не определен. Обе эти возможности зарезервированы для использования в будущем.</p><p>Реальные значения, выделенные для разных групп сетевых адресов указаны в работе Assigned Numbers [RFC790].</p><p>Локальные адреса распределяются на уровне локальной сети и должны позволять одному физическому хосту действовать как множество различных хостов internet. Т. е., должно поддерживаться отображение между адресами IP и физическим интерфейсом хоста, позволяющее связать несколько IP-адресов с одним физическим интерфейсом хоста. Должна также поддерживаться и обратная возможность — связывания нескольких физических интерфейсов с одним адресом IP.</p><p>Преобразование адресов IP в адреса сетей ARPANET, SATNET, PRNET и т. п. описано в работе Address Mappings [RFC796].</p><h4>Фрагментация и сборка</h4><p>Поле идентификации (ID) используется вместе с адресами отправителя/получателя и полем протокола для идентификации фрагментов дейтаграммы при сборке.</p><p>Флаг наличия других фрагментов (More Fragments или MF) устанавливается для всех фрагментов дейтаграммы, кроме последнего.</p><p>Поле Fragment Offset показывает положение фрагмента относительно начала исходной (нефрагментированной) дейтаграммы. Смещение учитывается в блоках размером 8 октетов. Стратегия фрагментации разработана таким образом, чтобы в нефрагментированной дейтаграмме вся поля, связанные с фрагментацией, имели нулевые значения (MF = 0, fragment offset = 0). Если дейтаграмма IP фрагментируется, ее поле данных должно делиться на части по 8-октетным границам.</p><p>Таким образом, используемый формат поддерживает до 213 = 8192 фрагментов по 8 октетов (т. е., до 65 536 октетов). Отметим, что это значение соответствует возможным значениям поля размера дейтаграммы в ее заголовке (естественно, заголовок показывает общую длину дейтаграммы, а не ее фрагментов).</p><p>При фрагментации дейтаграммы некоторые опции копируются из оригинальной дейтаграммы в каждый фрагмент, а часть опций сохраняется только в первом фрагменте.</p><p>Каждый модуль IP должен поддерживать пересылку без фрагментации дейтаграмм размером 68 октетов. Это значение выбрано потому, что заголовок дейтаграммы может достигать 60 октетов и поле данных должно содержать, по крайней мере, 8 октетов.</p><p>Каждый получатель должен поддерживать прием дейтаграмм размером, по крайней мере, 576 октетов целиком или с использованием фрагментации и сборки.</p><p>При фрагментации могут изменяться следующие поля:</p><ol><li>опции</li><li>флаг MF</li><li>смещение фрагмента</li><li>размер заголовка дейтаграммы</li><li>общий размер</li><li>контрольная сумма заголовка.</li></ol><p>Если установлен флаг запрета фрагментации (DF), дейтаграммы, которые невозможно передать целиком, отбрасываются. Этот вариант используется в тех случаях, когда принимающий хост не может собирать фрагменты дейтаграммы по причине нехватки ресурсов. Примером запрета фрагментации может служить ситуация с линией к небольшому хосту. Такой хост может иметь программу самозагрузки (boot strap), которая воспринимает дейтаграмму, хранящуюся в памяти и потом выполняет содержащийся в ней код.</p><p>Процедуры фрагментации и сборки проще описать на примерах. Описанные ниже процедуры содержат примеры реализации. Знак =&lt; в приведенных ниже псевдопрограммах означает «меньше или равно», # — «не равно», = — «равно», &lt;- — «установить значение». Выражение "x - y" включает x и исключает y (например "4 - 7" будет включать числа 4, 5 и 6, но не будет включать 7).</p><h4>Пример процедуры фрагментации</h4><p>Размер максимальной дейтаграммы, которая может быть передана через следующую сеть, называется MTU.</p><p>Если общий размер дейтаграммы не превышает MTU, эта дейтаграмма обрабатывается дальше. В противном случае дейтаграмма делится на два фрагмента — первый фрагмент имеет максимальный размер, а во втором содержится оставшаяся часть дейтаграммы. Первый фрагмент передается на следующий этап обработки, а для второго заново выполняется процедура проверки размера и при необходимости выполняется дополнительная фрагментация (это продолжается до тех пор, пока размер всех фрагментов перестанет превышать максимальное значение).</p><p>Обозначения:</p><ul><li>FO — смещение фрагмента</li><li>IHL — длина заголовка Internet</li><li>DF — флаг запрета фрагментирования</li><li>MF — флаг наличия других фрагментов</li><li>TL — общий размер</li><li>OFO — смещение старого фрагмента</li><li>OIHL — размер заголовка старого фрагмента</li><li>OMF — старый флаг наличия других фрагментов</li><li>OTL — старое значение общей длины</li><li>NFB — число фрагментов</li><li>MTU — максимальный передаваемый блок</li></ul><p>Процедура:</p><pre>IF TL =&lt; MTU THEN Submit this datagram to the next step
     in datagram processing ELSE IF DF = 1 THEN discard the
datagram ELSE
To produce the first fragment:
(1)  Copy the original internet header;
(2)  OIHL &lt;- IHL; OTL &lt;- TL; OFO &lt;- FO; OMF &lt;- MF;
(3)  NFB &lt;- (MTU-IHL*4)/8;
(4)  Attach the first NFB*8 data octets;
(5)  Correct the header:
     MF &lt;- 1;  TL &lt;- (IHL*4)+(NFB*8);
     Recompute Checksum;
(6)  Submit this fragment to the next step in
     datagram processing;
To produce the second fragment:
(7)  Selectively copy the internet header (some options
     are not copied, see option definitions);
(8)  Append the remaining data;
(9)  Correct the header:
     IHL &lt;- (((OIHL*4)-(length of options not copied))+3)/4;
     TL &lt;- OTL - NFB*8 - (OIHL-IHL)*4);
     FO &lt;- OFO + NFB;  MF &lt;- OMF;  Recompute Checksum;
(10) Submit this fragment to the fragmentation test; DONE.</pre><p>После выполнения п. 10 процедура завершается (если размер фрагмента не превышает допустимое значение) или повторяется. Эта процедура создает фрагменты одинакового (максимального) размера (за исключением последнего). Могут использоваться и другие процедуры, которые создают фрагменты с размером меньше максимального. Например, процедура фрагментации может использовать повторяющиеся операции деления данных дейтаграммы пополам, пока оно не достигнет приемлемого для передачи размера.</p><h4>Пример процедуры сборки</h4><p>Для каждой дейтаграммы идентификатор буфера определяется путем объединения (конкатенации) полей адресов отправителя и получателя, протокола и идентификации. Если дейтаграмма не является фрагментом (поля смещения фрагмента и флага дополнительных фрагментов имеют нулевые значения), все ресурсы сборки, связанные с этим идентификатором буфера, освобождаются и дейтаграмма передается на следующий этап обработки.</p><p>Если больше нет фрагментом с таким же идентификатором буфера, происходит выделение ресурсов для сборки. Эти ресурсы включают буфер данных, буфер заголовков, таблицу фрагментов (блоков), поле общего размера и таймер. Данные из фрагментов помещаются в буфер данных в соответствии с размером и смещением фрагментов; флаги в таблице фрагментов устанавливается при получении соответствующего фрагмента.</p><p>Заголовок первого фрагмента (fragment offset=0) помещается в буфер заголовков. Если фрагмент является последним (MF=0), определяется общий размер дейтаграммы. Если фрагмент завершает прием дейтаграммы (проверяется по таблице блоков), дейтаграмма передается на следующий этап обработки; в противном случае для таймера устанавливается наибольшее из двух значений — текущие показания таймера и значение поля TTL из данного фрагмента; управление передается процедуре сборки фрагментов.</p><p>Если заданное таймером время истекло, освобождаются все ресурсы, выделенные для данного идентификатора буфера. Начальная установка таймера задает нижнюю границу времени ожидания при сборке. При получении фрагментов время ожидания может быть увеличено в соответствии с TTL, а уменьшение времени ожидания не предусмотрено. Максимальное The maximum this timer значение таймера совпадает с максимальным значением TTL (около 4,25 мин.). Рекомендуется устанавливать начальное значение таймера равным 15 сек. Эта рекомендация может быть изменена с учетом реального опыт использования протокола. Отметим, что выбор этого значения связан с доступным размером буфера и скоростью среды передачи, т. е., при скорости 10 кбит/с и времени ожидания 15 сек. может потребоваться буфер размером 150 кбит.</p><p>Обозначения:</p><ul><li>FO — смещение фрагмента</li><li>IHL — длина заголовка Internet</li><li>DF — флаг запрета фрагментирования</li><li>MF — флаг наличия других фрагментов</li><li>TTL — время жизни</li><li>NFB — число фрагментов</li><li>TL — общий размер</li><li>TDL — общий размер данных</li><li>BUFID — идентификатор буфера</li><li>RCVBT — таблица полученных фрагментов</li><li>TLB — нижняя граница таймера.</li></ul><p>Процедура:</p><pre>(1)  BUFID &lt;- source|destination|protocol|identification;
(2)  IF FO = 0 AND MF = 0
(3)     THEN IF buffer with BUFID is allocated
(4)             THEN flush all reassembly for this BUFID;
(5)          Submit datagram to next step; DONE.
(6)     ELSE IF no buffer with BUFID is allocated
(7)             THEN allocate reassembly resources
                     with BUFID;
                     TIMER &lt;- TLB; TDL &lt;- 0;
(8)          put data from fragment into data buffer with
             BUFID from octet FO*8 to
                                 octet (TL-(IHL*4))+FO*8;
(9)          set RCVBT bits from FO
                                to FO+((TL-(IHL*4)+7)/8);
(10)         IF MF = 0 THEN TDL &lt;- TL-(IHL*4)+(FO*8)
(11)         IF FO = 0 THEN put header in header buffer
(12)         IF TDL # 0
(13)          AND all RCVBT bits from 0
                                     to (TDL+7)/8 are set
(14)            THEN TL &lt;- TDL+(IHL*4)
(15)                 Submit datagram to next step;
(16)                 free all reassembly resources
                     for this BUFID; DONE.
(17)         TIMER &lt;- MAX(TIMER,TTL);
(18)         give up until next fragment or timer expires;
(19) timer expires: flush all reassembly with this BUFID; DONE.</pre><p>В случаях, когда два фрагмента идентичны или перекрываются, эта процедура будет использовать более позднюю копию.</p><h4>Идентификация</h4><p>Выбор идентификатора для дейтаграммы базируется на обеспечении уникальности обозначения фрагментов отдельно взятой дейтаграммы. Модуль протокола, собирающий дейтаграмму из фрагментов, считает фрагменты относящимися к одной дейтаграмме, если у них совпадают адреса отправителя/получателя, тип протокола и поле идентификации. Таким образом, отправитель должен выбирать значение идентификатора так, чтобы оно было уникальным для комбинации адресов отправителя/получателя и типа протокола в течение срока жизни дейтаграммы (или любого ее фрагмента).</p><p>Представляется целесообразным для передающего хоста сохранение таблицы использованных идентификаторов — по одной записи для каждого получателя, с которым хост взаимодействовал в течение последнего промежутка времени, равного максимальному сроку существования пакета в internet.</p><p>Однако поле идентификации позволяет выбрать любое из 65536 значений идентификатора, поэтому некоторые хосты могут использовать уникальные идентификаторы, не связанные с получателем.</p><p>Для некоторых ситуаций разумно выбирать значения идентификаторов с помощью протокола вышележащего уровня. Например, модули протокола TCP могут повторно передавать идентичные сегменты TCP и вероятность корректной доставки будет повышаться, если при повторе использовать такой же идентификатор, как при первой передаче, поскольку фрагменты любой из дейтаграмм (первоначальной или повторных) могут использоваться для корректного восстановления сегмента TCP.</p><h4>ToS</h4><p>Значение TOS обеспечивает выбор уровня обслуживания с помощью абстрактных параметров precedence (предпочтение, приоритет), delay (задержка), throughput (пропускная способность), reliability (надежность). Эти абстрактные параметры преобразуются в реальные параметры обработки дейтаграмм в сетях на пути доставки.</p><ul><li class="b">Precedence</li><li class="lib">степень важности дейтаграммы.</li><li class="b">Delay</li><li class="lib">для таких дейтаграмм большое значение имеет время доставки.</li><li class="b">Throughput</li><li class="lib">для дейтаграмм имеет важное значение скорость передачи данных.</li><li class="b">Reliability</li><li class="lib">для дейтаграмм важное значение имеет надежность (гарантия) доставки.</li></ul><p>Например, ARPANET использует бит приоритета и разделяет «стандартные (тип 0) и неконтролируемые (тип 3) сообщения (выбор между одно- и многопакетными сообщениями также может рассматриваться как параметр обслуживания). Неконтролируемые сообщения доставляются с меньшими гарантиями, но имеют более низкую задержку. Предположим, что дейтаграмма IP доставляется через сеть ARPANET с параметрами ToS:</p><table class="nobrd"><tr><td>Precedence:</td><td>5</td></tr><tr><td>Delay:</td><td>0</td></tr><tr><td>Throughput:</td><td>1</td></tr><tr><td>Reliability:</td><td>1</td></tr></table><p>В этом случае отображение параметров сервиса на поддерживаемые в сети ARPANET параметры обслуживания приведет к установке бита приоритета ARPANET, поскольку значение precedence находится в старшей половине возможного диапазона и выбора стандартных сообщений, поскольку заданы параметры throughput и reliability, а бит delay не установлен. Более детальную информацию по этому вопросу можно найти в работе "Service Mappings" [RFC795].</p><h4>TTL</h4><p>Значение TTL устанавливается отправителем и задает максимальное время существования дейтаграммы в internet. Если время, заданное полем TTL, истекло, дейтаграмма уничтожается.</p><p>Значение этого поля должно уменьшаться в каждой точке обработки заголовка дейтаграммы для того, чтобы учесть затраты времени на такую обработку. Даже в тех случаях, когда нет информации о затратах времени на обработку, значение поля должно уменьшаться на 1. Время жизни измеряется в секундах и максимальное значение TTL (255) соответствует 255 секундам или 4,25 мин. Поскольку каждый модуль, обрабатывающий дейтаграмму, должен уменьшать значение TTL, по крайней мере, на 1, значение TTL должно трактоваться как верхний предел срока существования дейтаграммы. Назначение поля TTL состоит в том, чтобы недоставленные дейтаграммы уничтожались и ограничить срок существования дейтаграмм в системе.</p><p>Некоторые протоколы вышележащих уровней, обеспечивающие гарантированную доставку, базируются на предположении, что старые копии дейтаграмм не могут приходить по истечении некоторого времени. Поле TTL дает таким протоколам гарантию истинности этого предположения.</p><h4>Опции</h4><p>Опции являются необязательными для дейтаграмм, но все реализации должны поддерживать опции. Т. е., использование опций определяется отправителем, но каждый модуль IP должен быть способен разобрать любые опции. Поле опций может содержать несколько значений опций.</p><p>Опции не обязательно заканчиваются на 32-битовой границе. Заголовок IP в целях выравнивания по 32-битовой границе дополняется октетами нулей. Первый из таких октетов будет интерпретироваться как завершение поля опций, а остальная часть — как обычное заполнение.</p><p>Каждый модуль IP должен уметь обрабатывать любые опции. Опции безопасности (Security) требуются для классифицированного, и изолированного трафика, а также трафика с ограничением доступа.</p><h4>Контрольная сумма</h4><p>Контрольная сумма заголовка заново вычисляется каждый раз при изменении заголовка (например, при уменьшении TTL, добавлении или изменении опций, фрагментации дейтаграммы). Контрольная сумма на уровне IP предназначена для защиты полей заголовка от ошибок при передаче.</p><p>Для некоторых приложений допустимо небольшое число ошибок, но недопустима задержка передачи. Если протокол IP будет заниматься исправлением ошибок, такие приложения не смогут работать.</p><h4>Ошибки</h4><p>Сообщения об ошибках протокола IP могут передаваться с использованием протокола ICMP [<a href="../792.rfc" title="RFC 792 - Протокол ICMP">RFC792</a>].</p><h3 id="p3.3">3.3. Интерфейсы</h3><p>Функциональное описание пользовательского интерфейса IP является, в лучшем случае, умозрительным, поскольку каждая операционная система использует свои функции. Следовательно, мы должны предупредить читателя, что различные реализации IP могут иметь совершенно разные пользовательские интерфейсы. Однако любой модуль IP должен обеспечивать, по крайней мере, минимальный набор сервиса для обеспечения возможности совместного использования разных реализаций IP. В этом параграфе рассматриваются функциональные интерфейсы, требуемые от каждой реализации IP.</p><p>Протокол IP взаимодействует с одной стороны с локальной сетью, а с другой — с протоколом вышележащего уровня или прикладной программой. Далее протокол вышележащего уровня и прикладные программы (или даже программы шлюзов) будем называть для краткости «пользователь», поскольку они используют услуги модуля IP. Поскольку IP имеет дело с дейтаграммами между передачей отдельных дейтаграмм нет почти никакой связи и пользователь при каждом обращении к модулю IP передает ему все требуемые параметры для выполнения запрашиваемой операции.</p><h4>Пример интерфейса с вышележащим уровнем</h4><p>Ниже приведены два примера вызовов, удовлетворяющих требованиям к пользовательским вызовам IP ("=>" означает возврат):</p><pre>SEND (src, dst, prot, TOS, TTL, BufPTR, len, Id, DF, opt => result)

  where:

    src = source address
    dst = destination address
    prot = protocol
    TOS = type of service
    TTL = time to live
    BufPTR = buffer pointer
    len = length of buffer
    Id  = Identifier
    DF = Don't Fragment
    opt = option data
    result = response
      OK = datagram sent ok
      Error = error in arguments or local network error

  Note that the precedence is included in the TOS and the
  security/compartment is passed as an option.

RECV (BufPTR, prot, => result, src, dst, TOS, len, opt)

  where:

    BufPTR = buffer pointer
    prot = protocol
    result = response
      OK = datagram received ok
      Error = error in arguments
    len = length of buffer
    src = source address
    dst = destination address
    TOS = type of service
    opt = option data</pre><p>Для передачи дейтаграммы пользователь применяет вызов SEND, передавая все требуемые аргументы. Модуль IP, принявший вызов, проверяет аргументы, готовит и передает сообщение. Если параметры указаны корректно и дейтаграмма воспринята локальной сетью, модуль возвращает сообщение об успешной передаче. Если какой-то из параметров указан некорректно или дейтаграмма не принята локальной сетью, модуль возвращает сообщение об ошибке. В таких случаях модуль должен также возвращать соответствующий отклик, указывающий причину ошибки. Уровень детализации таких откликов зависит от реализации.</p><p>Получение модулем IP дейтаграммы из локальной сети может быть связано с ожидающим пользовательским вызовом RECV. Если такой вызов имеется, информация из дейтаграммы передается пользователю. Если же вызова нет, пользователю передается уведомление о прибывшей дейтаграмме. Если пользователь с указанным адресом не существует, отправителю возвращается сообщение ICMP об ошибке и дейтаграмма уничтожается.</p><p>Для уведомления пользователя могут применяться псевдопрерывания или аналогичный механизм, приемлемый в используемой реализацией среде.</p><p>Пользовательский вызов RECV может быть исполнен незамедлительно при наличии ожидающей дейтаграммы или помещен в состояние ожидания прихода дейтаграммы.</p><p>Адрес отправителя включается в вызов SEND, если передающий хост имеет несколько адресов (для логических или физических устройств). Модуль IP должен убедиться, что полученный адрес корректен и связан с данным хостом.</p><p>Реализация также может разрешать или требовать вызов модуля IP для индикации заинтересованности в получении или
предоставления исключительного использования для класса дейтаграмм (например, все дейтаграммы с определенным значением
поля протокола).</p><p>В этом параграфе было дано функциональное описание интерфейса пользователь — IP. Использованные обозначения похожи на нотацию большинства языков высокого уровня, однако такое использование не требует использования «функций-ловушек» (например, SVC, UUO, EMT) или иных форм взаимодействия между процессами.</p><h2 id="p.appendix.a">Приложение A: Примеры и сценарии</h2><h3>Пример 1</h3><p>Ниже приведен пример минимальной дейтаграммы IP, содержащей данные.</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver= 4 |IHL= 5 |Type of Service|        Total Length = 21      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Identification = 111     |Flg=0|   Fragment Offset = 0   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Time = 123  |  Protocol = 1 |        header checksum        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         source address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      destination address                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     data      |
+-+-+-+-+-+-+-+-+

Рисунок 5. Пример дейтаграммы IP</pre><p>Показанная дейтаграмма соответствует протоколу IP версии 4; заголовок содержит пять 32-битовых слов, а полный размер дейтаграммы составляет 21 октет. Показанная выше дейтаграмма является полной (не фрагментом).</p><h3>Пример 2</h3><p>В этом примере показана дейтаграмма среднего размера (452 октета данных), которая разбивается на два фрагмента, поскольку сеть не поддерживает передачу дейтаграмм, размер которых превышает 280 октетов.</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver= 4 |IHL= 5 |Type of Service|       Total Length = 472      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Identification = 111      |Flg=0|     Fragment Offset = 0 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Time = 123  | Protocol = 6  |        header checksum        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         source address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      destination address                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
\                                                               \
\                                                               \
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             data              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Рисунок 6. Пример дейтаграммы IP</pre><p>Ниже показан первый фрагмент, после выделения из дейтаграммы первых 256 октетов данных.</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver= 4 |IHL= 5 |Type of Service|       Total Length = 276      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Identification = 111      |Flg=1|     Fragment Offset = 0 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Time = 119  | Protocol = 6  |        Header Checksum        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         source address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      destination address                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
\                                                               \
\                                                               \
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Рисунок 7. Пример фрагмента дейтаграммы IP</pre><p>Второй фрагмент будет иметь форму.</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver= 4 |IHL= 5 |Type of Service|       Total Length = 216      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Identification = 111      |Flg=0|  Fragment Offset  =  32 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Time = 119  | Protocol = 6  |        Header Checksum        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         source address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      destination address                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
\                                                               \
\                                                               \
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            data               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Рисунок 8. Пример фрагмента дейтаграммы IP</pre><h3>Пример 3</h3><p>Ниже показан пример дейтаграммы, содержащей опции:</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver= 4 |IHL= 8 |Type of Service|       Total Length = 576      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Identification = 111    |Flg=0|     Fragment Offset = 0 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Time = 123  |  Protocol = 6 |       Header Checksum         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        source address                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      destination address                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Opt. Code = x | Opt.  Len.= 3 | option value  | Opt. Code = x |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Opt. Len. = 4 |           option value        | Opt. Code = 1 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Opt. Code = y | Opt. Len. = 3 |  option value | Opt. Code = 0 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
\                                                               \
\                                                               \
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Рисунок 9. Пример дейтаграммы IP</pre><h2 id="p.appendix.b">Приложение B: Порядок передачи данных</h2><p>Порядок передачи заголовков и данных, описываемых в этой спецификации, задается на уровне октетов. Дейтаграмма представляет собой группу октетов, которые передаются в том же порядке, в котором мы читаем. Например, в показанной ниже дейтаграмме октеты передаются в порядке возрастания номеров на рисунке.</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       1       |       2       |       3       |       4       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       5       |       6       |       7       |       8       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       9       |      10       |      11       |      12       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Рисунок 10. Порядок передачи байтов.</pre><p>Когда октет представляет числовое значение, показанный бит является старшим или наиболее значимым. На приведенных в спецификации рисунках это бит 0. Например, показанная ниже последовательность битов задает десятичное число 170.</p><pre> 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|1 0 1 0 1 0 1 0|
+-+-+-+-+-+-+-+-+

Рисунок 11. Значимость битов</pre><p>Подобно этому для многооктетных полей, представляющих числа, указанный бит является старшим. При передаче многооктетных значений старший октет передается первым.</p><h2 id="p.glossary">Глоссарий</h2><ul><li class="b">1822</li><li class="lib">BBN Report 1822, "The Specification of the Interconnection of a Host and an IMP" — спецификация интерфейса между хостом и сетью ARPANET.</li><li class="b">ARPANET leader</li><li class="lib">Управляющая информация сообщения ARPANET на интерфейсе хост-IMP.</li><li class="b">ARPANET message — сообщение ARPANET</li><li class="lib">Элемент передачи между хостом и IMP в сети ARPANET. Максимальный размер сообщения около 1012 октетов (8096 битов).</li><li class="b">ARPANET packet — пакет ARPANET</li><li class="lib">Единица передачи данных, используемая в сети ARPANET при обмене данными между IMP. Максимальный размер пакета составляет 126 октетов (1008 битов).</li><li class="b">Destination — получатель</li><li class="lib">Адрес получателя — поле заголовка IP.</li><li class="b">DF</li><li class="lib">Флаг запрета фрагментирования (Don't Fragment).</li><li class="b">Flags — флаги</li><li class="lib">Поле заголовка IP, содержащее различные флаги управления.</li><li class="b">Fragment Offset — смещение фрагмента</li><li class="lib">Поле заголовка IP, указывающее смещение фрагмента в исходной дейтаграмме.</li><li class="b">GGP</li><li class="lib">Gateway to Gateway Protocol — протокол, используемый шлюзами для управления маршрутизацией и других целей.</li><li class="b">Header — заголовок</li><li class="lib">Служебная информация в начале сообщения, сегмента, дейтаграммы, пакета или блока данных.</li><li class="b">ICMP</li><li class="lib">Internet Control Message Protocol — протокол, реализованный в модуле IP и используемый шлюзами и хостами для передачи информации об ошибках и проверки маршрутов.</li><li class="b">Identification — идентификация</li><li class="lib">Поле заголовка IP, содержащее идентификатор, присваиваемый отправителем для правильной сборки фрагментов.</li><li class="b">IHL</li><li class="lib">Internet Header Length — поле заголовка IP, указывающее размер заголовка в 32-битовых словах.</li><li class="b">IMP</li><li class="lib">Interface Message Processor — коммутатор пакетов в сети ARPANET.</li><li class="b">Internet Address — адрес IP</li><li class="lib">4-октетный (32 бита) адрес отправителя или получателя, состоящий из полей Network (номер сети) и Local Address (номер хоста).</li><li class="b">Internet datagram — дейтаграмма IP</li><li class="lib">Единица информации, используемая при обмене данными между парой модулей IP (включает заголовок IP).</li><li class="b">internet fragment — фрагмент IP</li><li class="lib">Часть дейтаграммы IP с заголовком IP.</li><li class="b">Local Address — локальный адрес (номер хоста)</li><li class="lib">The address of a host within a network. The actual mapping of an internet local address on to the host addresses in a network is quite general, allowing for many to one mappings.</li><li class="b">MF</li><li class="lib">Флаг наличия других фрагментов (More-Fragments), передаваемый в поле флагов заголовка IP.</li><li class="b">Module — модуль</li><li class="lib">Реализация (обычно программная) протокола или другой процедуры.</li><li class="b">more-fragments flag</li><li class="lib">Флаг наличия других фрагментов (More-Fragments), передаваемый в поле флагов заголовка IP.</li><li class="b">NFB</li><li class="lib">Number of Fragment Blocks — число блоков (по 8 октетов) данных во фрагменте дейтаграммы.</li><li class="b">octet</li><li class="lib">Восьмибитовый байт.</li><li class="b">Options — опции</li><li class="lib">Поле Options в заголовке IP может содержать тот или иной набор опций. Размер опции может быть переменным.</li><li class="b">Padding — заполнение</li><li class="lib">Поле Padding используется для выравнивания заголовка IP по 32-битовой границе. Для заполнения используется 0.</li><li class="b">Protocol — протокол</li><li class="lib">Поле Protocol заголовка IP содержит идентификатор протокола вышележащего уровня.</li><li class="b">Rest — остаток</li><li class="lib">Локальная часть адреса IP (номер хоста).</li><li class="b">Source — отправитель</li><li class="lib">Адрес отправителя в заголовке IP.</li><li class="b">TCP</li><li class="lib">Transmission Control Protocol — протокол обмена данными между хостами, обеспечивающий гарантированную доставку в среде internet.</li><li class="b">TCP Segment — сегмент TCP</li><li class="lib">Единица данных при обмене информацией между модулями TCP (включает заголовок TCP).</li><li class="b">TFTP</li><li class="lib">Trivial File Transfer Protocol — простой протокол обмена файлами на основе протокола UDP.</li><li class="b">Time to Live</li><li class="lib">Поле заголовка, определяющее верхнюю границу срока существования дейтаграммы IP.</li><li class="b">TOS</li><li class="lib">ToS — тип обслуживания.</li><li class="b">Total Length — общая длина</li><li class="lib">Поле заголовка Total Length показывает полный размер дейтаграммы в октетах с учетом заголовка и данных.</li><li class="b">TTL</li><li class="lib">Время жизни (Time to Live).</li><li class="b">Type of Service — тип обслуживания</li><li class="lib">Поле заголовка, определяющее тип (или качество) обслуживания дейтаграммы IP.</li><li class="b">UDP</li><li class="lib">Протокол пользовательских дейтаграмм (User Datagram Protocol) — протокол пользовательского (транспортного в современной терминологии. прим. перев.) уровня для приложений на базе транзакций.</li><li class="b">User</li><li class="lib">Пользователь IP — протокол вышележащего уровня, прикладная программа, программа шлюза.</li><li class="b">Version</li><li class="lib">Поле версии определяет формат заголовка internet.</li></ul><h2 id="p.references">Литература</h2><table itemprop="references"><tr><td>[1]</td><td>Cerf, V., «The Catenet Model for Internetworking», Information Processing Techniques Office, Defense Advanced Research Projects Agency, IEN 48, Июль 1978.</td></tr><tr><td>[2]</td><td>Bolt Beranek and Newman, «Specification for the Interconnection of a Host and an IMP», BBN Technical Report 1822, Revised May 1978.</td></tr><tr><td>[RFC792]</td><td>J. Postel, <a href="../792.rfc" title="RFC 792 - Протокол ICMP">«Протокол ICMP», RFC 792</a>, Сентябрь 1981.</td></tr><tr><td>[4]</td><td>Shoch, J., «Inter-Network Naming, Addressing, and Routing», COMPCON, IEEE Computer Society, Fall 1978.</td></tr><tr><td>[RFC796]</td><td>Postel, J., «Address Mappings», RFC 796, USC/Information Sciences Institute, Сентябрь 1981.</td></tr><tr><td>[6]</td><td>Shoch, J., «Packet Fragmentation in Inter-Network Protocols», Computer Networks, v. 3, n. 1, Февраль 1979.</td></tr><tr><td>[7]</td><td>Strazisar, V., «How to Build a Gateway», IEN 109, Bolt Beranek and Newman, Август 1979.</td></tr><tr><td>[RFC795]</td><td>Postel, J., «Service Mappings», RFC 795, USC/Information Sciences Institute, Сентябрь 1981.</td></tr><tr><td>[RFC790]</td><td>Postel, J., «Assigned Numbers», RFC 790, USC/Information Sciences Institute, Сентябрь 1981.</td></tr></table></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 791 - Протокол IP (Internet Protocol)",disqus_identifier="791.rfc",disqus_url="http://rfc2.ru/791.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>