<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../3920.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 3920 — Протокол XMPP: Ядро</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../3920.rfc">RFC 3920 — Протокол XMPP: Ядро</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 3920</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank"><span itemprop="alternativeHeadline">Extensible Messaging and Presence Protocol (XMPP): Core</span></a></dd><dd><div class="icon i7"></div> Другие версии: <strong class="obsoleted_by">RFC 6120</strong></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Предложенный стандарт</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="2004-10-01">Октябрь 2004</time></dd><dd><div class="icon i5"></div> Автор: <span itemprop="author">Peter Saint-Andre</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Семенов Юрий Алексеевич</span></dd></dl><div id="text" itemprop="articleBody"><h3>Статус документа</h3><p>Это документ содержит проект стандарта протокола Internet для Internet-сообщества и служит приглашением к дискуссии в целях развития и совершенствования протокола. Текущее состояние стандартизации и статус протокола можно узнать из текущей версии документа "Internet Official Protocol Standards" (STD 1). Допускается свободное распространение документа.</p><h3>Тезисы</h3><p>Этот документ определяет основные особенности протокола XMPP (eXtensible Messaging and Presence Protocol — расширяемый протокол обмена сообщениями и данными о присутствии), протокола, использующего XML (eXtensible Markup Language — расширяемый язык разметки) для обмена структурированной информацией в режиме близком к реальному времени между двумя любыми сетевыми оконечными точками.</p><h2>Оглавление</h2><ul class="map"><li><a href="print#p1" title="Введение">1. Введение</a></li><li><a href="print#p2" title="Обобщенная архитектура">2. Обобщенная архитектура</a></li><li><a href="print#p3" title="Схема адресации">3. Схема адресации</a></li><li><a href="print#p4" title="XML потоки">4. XML потоки</a></li><li><a href="print#p5" title="Использование TLS">5. Использование TLS</a></li><li><a href="print#p6" title="Использование SASL">6. Использование SASL</a></li><li><a href="print#p7" title="Подключение ресурсов">7. Подключение ресурсов</a></li><li><a href="print#p8" title="Метод сервера Dialback">8. Метод сервера Dialback</a></li><li><a href="print#p9" title="XML-строфы">9. XML-строфы</a></li><li><a href="print#p10" title="Правила сервера для обработки XML-строф">10. Правила сервера для обработки XML-строф</a></li><li><a href="print#p11" title="Использование XML в XMPP">11. Использование XML в XMPP</a></li><li><a href="print#p12" title="Основные требования совместимости">12. Основные требования совместимости</a></li><li><a href="print#p13" title="Соображения интернационализации">13. Соображения интернационализации</a></li><li><a href="print#p14" title="Вопросы безопасности">14. Вопросы безопасности</a></li><li><a href="print#p15" title="Соображения IANA">15. Соображения IANA</a></li><li><a href="print#p16" title="Литература">16. Литература</a></li><li><a href="print#p.appendix.a" title="Nodeprep">Приложение A. Nodeprep</a></li><li><a href="print#p.appendix.b" title="Resourceprep">Приложение B. Resourceprep</a></li><li><a href="print#p.appendix.c" title="XML-схемы">Приложение C. XML-схемы</a></li><li><a href="print#p.appendix.d" title="Differences Between Core Jabber Protocols and XMPP">Приложение D. Differences Between Core Jabber Protocols and XMPP</a></li></ul><h2 id="p1">1. Введение</h2><p>Расширяемый протокол обмена сообщениями и данными о присутствии XMPP (Extensible Messaging and Presence Protocol) является открытым протоколом, использующими XML (Extensible Markup Language [XML]) для сервисов обмена сообщениями в режиме близком к реальному времени, данными о присутствии, запросами/откликами. Базовый синтаксис и семантика были разработаны первоначально в 1999 году сообществом разработчиков системы Jabber с общедоступным кодом. В 2002 рабочая группа XMPP занялась адаптацией протокола Jabber, который должен стать основой технологии обмена сообщениями в реальном масштабе времени (IM) и данными о присутствии сообщества IETF. Результатом работы группы XMPP стал данный документ, который определяет базовые черты XMPP 1.0; расширения, необходимые для реализации обмена сообщениями и данными о присутствии в реальном масштабе времени, определены в RFC-2779 [IMP-REQS] и специфицированы в протоколе XMPP: передача сообщений и данных о присутствии в реальном масштабе времени [XMPP-IM].</p><h2 id="p2">2. Обобщенная архитектура</h2><p>Хотя XMPP не привязан к какой-то определенной сетевой архитектуре, реализация сессии осуществляется по схеме клиент-сервер, где клиент реализует подключение к серверу с помощью [TCP] TCP-транспорта, и сами серверы взаимодействуют друг с другом также, используя протокол ТСР.</p><p>На рисунке ниже представлена схема высокоуровневой архитектуры подобной сессии ("-" коммуникации, использующие XMPP протокол, "=" — коммуникации, использующие какой-либо другой протокол).</p><pre>C1----S1---S2---C3
      |
C2----+--G1===FN1===FC1</pre><p>Символы на рисунке имеют следующие значения:</p><ul class="dot"><li>C1, C2, C3 = XMPP клиенты</li><li>S1, S2 = XMPP серверы</li><li>G1 = шлюз, который осуществляет согласования XMPP и протоколов, используемых в сети без поддержки XMPP.</li><li>FN1 = внешняя сеть без поддержки XMPP</li><li>FC1 = клиент сети без поддержки XMPP</li></ul><h3>2.2. Сервер</h3><p>Сервер действует как интеллектуальный уровень абстракции для XMPP коммуникаций. Его основные обязанности:</p><ul class="dot"><li><p>установление и поддержание соединения или сессии с другими объектами, в виде XML-потоков (раздел 4) к или от авторизованных клиентов, серверов и прочих объектов.</p></li><li><p>маршрутизацию корректно адресованных строф (stanzas) (раздел 9) между такими объектами в рамках XML-потоков.</p></li></ul><p>Большинство XMPP-совместимых серверов осуществляют также запоминание данных, которые используются клиентами (например, список контактов для пользователей системы обмена сообщениями и данными о присутствии с помощью XMPP); в этом случае, XML-данные обрабатываются непосредственно сервером для клиента, а не переадресуются другому объекту.</p><h3>2.3. Клиент</h3><p>Большинство клиентов подключается непосредственно к серверу посредством TCP и используют XMPP для получения полной функциональности, доступной на сервере. Для каждого авторизованного клиента к серверу могут одновременно подключаться несколько ресурсов (например, устройств или позиций). Каждый ресурс характеризуется идентификатором XMPP-адреса (например, &lt;node@domain/home&gt; или &lt;node@domain/work&gt;), как это определено схемой адресации (раздел 3). Рекомендованным номером порта для соединения клиента с сервером является 5222, как это фиксировано IANA (смотри "Номера портов" (раздел 15)).</p><h3>2.4. Шлюз</h3><p>Шлюз является специальной функцией сервера, задача которой заключается в трансляции протокола XMPP для внешних систем обмена сообщениями, которые не поддерживают XMPP, а также преобразовании данных, поступающих из удаленных сетей, не поддерживающих XMPP. Примерами могут служить шлюзы для электронной почты (смотри [SMTP]), IRC (Internet Relay Chat, смотри [IRC]), SIMPLE (смотри [SIMPLE]), SMS (Short Message Service), а также сервисы типа AIM, ICQ, MSN Messenger или Yahoo! Instant Messenger.</p><h3>2.5. Сеть</h3><p>Так как каждый сервер идентифицируется сетевым адресом и так как коммуникации сервер-сервер являются простым расширение протокола клиент-сервер, на практике система представляет собой сеть серверов, которые взаимодействуют друг с другом. Таким образом, например, &lt;juliet@example.com&gt; может обмениваться сообщениями и данными о присутствии, а также другой информацией с &lt;romeo@example.net&gt;. Эта схема подобна протоколам обмена сообщениями (таким как [SMTP]), которые используют стандарты сетевой адресации. Коммуникации между любыми двумя серверами являются опционными. Если они разрешены, такие коммуникации должны осуществляться посредством XML-потоков, которые сопряжены с TCP-соединениями. Рекомендуемым номером порта для соединения серверов является 5269 (смотри главу "Номера портов" (раздел 15)).</p><h2 id="p3">3. Схема адресации</h2><h3>3.1. Overview</h3><p>Объектом считается нечто, что может рассматриваться, как конечная точка сети (т.е., ID для сети) и что может осуществлять обмен с использованием XMPP. Все такие объекты являются уникально адресуемыми в формате, совместимом с RFC 2396 [URI]. По историческим причинам адрес XMPP-объекта называется идентификатором Jabber или JID. JID содержит набор элементов, образующих доменный идентификатор, идентификатор узла или ресурса.</p><p>Синтаксис JID описан ниже в формализме Бакуса-Наура, определенном в [ABNF].</p><pre>jid             = [ node "@" ] domain [ "/" resource ]
domain          = fqdn / address-literal
fqdn            = (sub-domain 1*("." sub-domain))
sub-domain      = (internationalized domain label)
address-literal = IPv4address / IPv6address</pre><p>Все JID базируются на следующей структуре. Наиболее общим использованием этой структуры является идентификация пользователя системы обмена сообщениями, сервера, к которому пользователь подключается и используемых ресурсов в форме &lt;user@host/resource&gt;. однако, возможны типы узлов, отличные от клиентов; например, специальная комната для разговоров, предлагаемая многопользовательским сервисом, может адресоваться как &lt;room@service&gt; (где "room" является именем chat room, а "service" имя машины, предлагающей этот вид сервиса. Определенный участник такой беседы может адресоваться как &lt;room@service/nick&gt; (где "nick" — имя/прозвище участника такой сессии). Возможно много других типов JID (например, &lt;domain/resource&gt; может быть скриптом или сервисом на стороне сервера).</p><p>Каждая из возможных частей JID (идентификаторы узла, домена и ресурса) не должны содержать более 1023 байт, что устанавливает максимальный размер, включая символы '@' и '/', равный 3071 байту.</p><h3>3.2. Идентификатор домена</h3><p>Идентификатор домена является первичным идентификатором и представляет собой единственный обязательный элемент JID (простой идентификатор домена является корректным значением JID). Он обычно представляет сетевой шлюз или "первичный" сервер, к которому подключаются другие объекты для осуществления XML-маршрутизации и управления данными. Однако объект, адресуемый идентификатором домена, не обязательно является сервером и может быть сервисом, который адресуется как субдомен сервера, который обеспечивает функциональность, неподдерживаемую сервером (например, пользовательский каталог или шлюз к удаленной системе обмена сообщениями).</p><p>Идентификатором домена для каждого сервера или сервиса, который будет обмениваться данными через сеть, может быть IP-адрес, но он должен обязательно соответствовать имени домена [DNS]. Идентификатор домена должен иметь международное доменное имя, как это определено в [IDNA]. Прежде чем сравнивать два идентификатора доменов сервер должен (также как и клиент) использовать профайл Nameprep для меток (как это задано в [IDNA]).</p><h3>3.3. Идентификатор узла</h3><p>Идентификатор узла является опционным вторичным идентификатором, размещаемым перед доменным идентификатором, и отделяемым от него символом '@'. Он обычно представляет собой объект, запрашивающий и использующий доступ к сети, предоставляемый сервером или шлюзом (т.е., клиент). Хотя он может представлять собой и другой объект. Объект, представляемый идентификатором узла адресуется в рамках контекста конкретного домена; для задач обмена сообщениями и данными о присутствии приложений XMPP, этот адрес называется "чистым JID" и имеет вид &lt;node@domain&gt;.</p><p>Идентификатор узла должен быть сформатирован так, чтобы можно было использовать профайл Nodeprep [STRINGPREP]. Прежде чем сравнивать два идентификатора узлов, сервер должен сначала использовать профайл Nodeprep для каждого идентификатора.</p><h3>3.4. Идентификатор ресурса</h3><p>Идентификатор ресурса является опционным третичным идентификатором, размещаемым после идентификатора домена и отделенным от последнего символом '/'. Идентификатор ресурса может варьироваться от &lt;node@domain&gt; до &lt;domain&gt;. Он обычно представляет определенную сессию, соединение, например, устройство или положение), или объект (например, участник многопользовательского обмена сообщениями), принадлежащее сущности, ассоциированной с идентификатором узла. Идентификатор ресурса не прозрачен для сервера и других клиентов, и обычно определяется реализацией клиента, когда он выдает информацию, нужную для завершения подключения ресурса (Resource Binding, раздел 7). Объект может содержать несколько подключенных ресурсов. Каждый подключенный ресурс имеет свой идентификатор.</p><p>Идентификатор ресурса должен быть сформирован так, чтобы было можно применить профайл Resourceprep [STRINGPREP]. Прежде чем сравнивать два идентификатора ресурсов, сервер должен сначала использовать профайл Resourceprep для каждого идентификатора.</p><h3>3.5. Определение адреса</h3><p>После согласования SASL (раздел 6) и, если нужно, подключения ресурсов (раздел 7), принимающий объект должен определить начальное значение JID.</p><p>Для обменов сервер-сервер, начальное значение JID должно определять авторизационную идентичность, как это определено спецификацией уровня безопасности и простой аутентификации SASL (Simple Authentication and Security Layer) [SASL] (раздел 6).</p><p>Для коммуникаций клиент-клиент "чистый JID" (&lt;node@domain&gt;) должен определять авторизационную идентичность, как это определено спецификацией [SASL], (раздел 6). Секция идентификатора ресурса "чистого JID" (&lt;node@domain/resource&gt;) должна быть ресурсным идентификатором, согласованным клиентом и сервером при подключении ресурса (раздел 7).</p><p>Принимающий объект должен гарантировать, что результирующий JID (включая идентификатор узла, домена, ресурса и разделительные символы) соответствует правилам и форматам, определенным ранее в данном разделе; чтобы удовлетворить этим ограничениям, принимающий объект может быть вынужден заменить JID, присланный инициатором обмена.</p><h2 id="p4">4. XML потоки</h2><h3>4.1. Overview</h3><p>Два фундаментальных принципа делают возможным быстрый асинхронный обмен при сравнительно небольшом поле данных: XML-потоки и XML-строфы (stanzas). Эти термины определяются следующим образом:</p><ul><li class="b">Определение XML-потока:</li><li class="lib">XML-поток является контейнером для обмена XML-элементами между объектами через сеть. Начало XML-потока однозначно определяется открывающим XML-тэгом &lt;stream&gt; (с декларацией соответствующих атрибутов названий позиций), в то время как конец XML-потока однозначно определяется закрывающим XML-тэгом &lt;/stream&gt;. Во время существования потока, объект его инициировавший, может посылать произвольное число XML-элементов, либо элементов, используемых для согласования параметров потока (например, для согласования использования TLS (раздел 5), либо использования SASL (раздел 6)), либо XML-строф (как это определяется, &lt;message/&gt;, &lt;presence/&gt; или &lt;iq/&gt;). "Исходный поток" согласуется инициатором сессии (обычно клиентом или сервером) с принимающим объектом (обычно сервером). Исходный поток обеспечивает однонаправленную коммуникацию между инициатором и получателем; для того чтобы разрешить информационный обмен от принимающей стороны к инициатору, приемник должен согласовать поток в обратном направлении ("поток-отклик").</li><li class="b">Определение XML строфы:</li><li class="lib">XML-строфа является дискретным семантическим блоком структурированной информации, который посылается одним объектом другому объекту через XML-поток. XML-строфа является дочерним элементом по отношению элементу &lt;stream/&gt;. Начало любой XML-строфа однозначно определяется стартовым тэгом XML-потока (depth=1) (например, &lt;presence&gt;), а конец любой XML-строфы однозначно задается закрывающим тэгом (например, &lt;/presence&gt;). XML-строфа может содержать дочерние элементы (сопроводительные атрибуты и XML-символы). Единственными видами XML-строф, определенными здесь, являются: &lt;message/&gt;&gt;, &lt;presence/&gt; и &lt;iq/&gt; (раздел 9). XML-элементы, посланные для целей согласования транспортной безопасности TLS (Transport Layer Security) (раздел 5) и согласования SASL (раздел 6) не рассматриваются как XML-строфы.</li></ul><p>Рассмотрим пример клиентской сесии взаимодействия с сервером. Для того чтобы соединиться с сервером, клиент должен инициировать XML-поток путем посылки серверу открывающего тэга &lt;stream&gt;, опционно перед ним может следовать текстовая декларация, специфицирующая XML-версию и символьное кодирование (смотри "Включение текстовых деклараций" (раздел 11); а также Кодирование символов (раздел 11)). В соответствии с локальной политикой и предоставляемыми сервисами сервер должен откликнуться и сформировать XML-поток к клиенту. Как только клиент завершает согласование SASL (раздел 6), он может посылать любое число XML-строф любому получателю в сети. Когда клиент захочет прервать сессию, он просто посылает серверу закрывающий тэг &lt;/stream&gt; (поток может быть прерван также и сервером), после этого как клиент так и сервер разрывают ТСР-соединение.</p><p>По существу, XML-поток функционирует как конверт для всех XML-строф, посланных во время сессии. Мы можем представит это в упрощенной форме как:</p><pre>|--------------------|
| &lt;stream&gt;           |
|--------------------|
| &lt;presence&gt;         |
|   &lt;show/&gt;          |
| &lt;/presence&gt;        |
|--------------------|
| &lt;message to='foo'&gt; |
|   &lt;body/&gt;          |
| &lt;/message&gt;         |
|--------------------|
| &lt;iq to='bar'&gt;      |
|   &lt;query/&gt;         |
| &lt;/iq&gt;              |
|--------------------|
| ...                |
|--------------------|
| &lt;/stream&gt;          |
|--------------------|</pre><h3>4.2. Связь с TCP</h3><p>Хотя нет необходимости связывать XML-поток с ТСР-соединением [TCP] (например, два объекта могут установить соединение друг с другом посредством другого механизма, данная спецификация предполагает работу только с TCP-протоколом. В контексте коммуникаций клиент-сервер, сервер должен позволить клиенту разделять одно TCP-соединение для XML-строф, посланных клиентом серверу и от сервера клиенту. В контексте коммуникаций сервер-сервер, сервер должен использовать одно TCP-соединение для XML-строф, посланных сервером своему партнеру, и другое TCP-соединение (инициированное партнером) для передачи строф от партнера серверу.</p><h3>4.3. Безопасность потока</h3><p>Когда согласуется формирование XML-потоков в XMPP 1.0, следует использовать TLS, как это определено в разделе 5, а SASL должен использоваться при условиях, описанных в разделе 6. Безопасности исходного потока (т.е., потока от инициатора получателю) и поток-отклик (т.е., поток от получателя к инициатору) должны обеспечиваться независимо. Объект не должен пытаться посылать XML-строфы (раздел 9) через поток, прежде чем он будет аутентифицирован, но если он это сделает, тогда другой объект не должен воспринимать такие строфы и должен возвращать уведомление об ошибке &lt;not-authorized/&gt; и затем прерывать XML-поток и TCP-соединение; заметим, что здесь вовлечены только XML-строфы (т.е., элементы '&lt;message/&gt;, &lt;presence/&gt; и &lt;iq/&gt;), а не XML элементы, используемые для согласования параметров потока (например, элементы, используемые для согласования работы с TLS (раздел 5) или с SASL (раздел 6)).</p><h3>4.4. Атрибуты потока</h3><p>Существуют следующие атрибуты элемента потока:</p><ul><li class="b">to</li><li class="lia">Следует использовать только в заголовке XML-потока между инициатором и получателем. Значение этого атрибута должно соответствовать имени машины получателя. Не следует использовать атрибут 'to' в заголовках XML-потоков, где получатель посылает отклик инициатору; однако, если атрибут 'to' использован в таком контексте, он должен быть молча проигнорирован инициатором.</li><li class="b">from</li><li class="lia">Следует использовать только в заголовках XML-потоков от получателя к инициатору, и его значение должно быть равно имени машины, обслуживаемой получателем. Не должно быть атрибутов 'from' в заголовках XML-потоков между инициатором и получателем; однако, если атрибут 'from' все же вставлен, он должен молча игнорироваться получателем.</li><li class="b">id</li><li class="lia">Следует использовать только в заголовках XML-потоков от получателя к инициатору. Этот атрибут является уникальным идентификатором, сформированным получателем, для использования в качестве ключа сессии для потоков инициатора, и должен быть уникальным для принимающих приложений (в норме для сервера). Заметим, что ID-потока может быть критичным в отношении безопасности и, следовательно, непредсказуемым (рекомендации смотри в [RANDOM]). Не следует использовать атрибут 'id' в заголовках XML-потоков, посылаемых инициатором получателю; однако, если атрибут 'id' все же включен, он должен молча игнорироваться получателем.</li><li class="b">xml:lang</li><li class="lia">Следует включать инициатором в заголовок, чтобы специфицировать язык по умолчанию для любых посылаемых им символьных данных. Если атрибут включен, получатель должен запомнить его в качестве значения по умолчанию как для исходного потока, так и для потока-отклика; если атрибут не был включен, получатель должен использовать для обоих потоков значение из конфигурации, которое он должен пересылать в заголовке потока-отклика. Для всех строф, переданных в исходном потоке, если инициатор не использовал атрибут 'xml:lang', получатель должен использовать значение по умолчанию; если инициатор включил атрибут 'xml:lang', получатель не должен модифицировать или удалять его (смотри также xml:lang (раздел 9)). Значение атрибута 'xml:lang' должно быть NMTOKEN (как это определено в разделе 2.3 of [XML]) и должно следовать формату, определенному в RFC 3066 [LANGTAGS].</li><li class="b">version</li><li class="lia">Присутствие атрибута версии с значением, равным по крайней мере "1.0" сигнализирует о поддержке потоковых протоколов, описанных в данной спецификации.</li></ul><p>Мы можем резюмировать следующее:</p><table><tr><td></td><td>инициатор-получатель</td><td>получатель-инициатор</td></tr><tr><td>to</td><td>Имя машины получателя</td><td>молча игнорируется</td></tr><tr><td>from</td><td>молча игнорируется</td><td>Имя машины получателя</td></tr><tr><td>id</td><td>молча игнорируется</td><td>ключ сессии</td></tr><tr><td>xml:lang</td><td>язык по умолчанию</td><td>язык по умолчанию</td></tr><tr><td>version</td><td>Сигнал поддержки XMPP 1.0</td><td>Сигнал поддержки XMPP 1.0</td></tr></table><h4>4.4.1. Поддержка версии</h4><p>Версия XMPP, специфицированная здесь, равна "1.0"; в частности, подразумевает протоколы, ориентированные на потоки, (использование TLS — раздел 5, использование SASL — раздел 6 и ошибки в потоках — раздел 4), а также семантику трех определенных типов XML-строф (&lt;message/&gt;, &lt;presence/&gt; и &lt;iq/&gt;). Схема нумерации версий XMPP имеет формат "&lt;major&gt;.&lt;minor&gt;". Старший и младший коды версии должны рассматриваться как отдельные целые числа и каждое число может инкрементироваться. Таким образом, "XMPP 2.4" будет более ранней версией чем "XMPP 2.13", которая в свою очередь младше, чем версия "XMPP 12.3". Лидирующие нули (например, "XMPP 6.01") должны игнорироваться получателями и не должны пересылаться.</p><p>Старший код номера версии следует инкрементировать только, если форматы потока или строф, или необходимые действия изменились настолько сильно, что объект старой версии не сможет их интерпретировать корректно. Младший код номера версии индицирует новые возможности, и он должен игнорироваться объектом более ранней версии. Например, младший код номера версии может указывать на возможность обработки вновь определенных типов атрибута сообщения, данных о присутствии, или IQ-строф. Объект с большим значением младшего кода версии будет знать, что его партнер не способен правильно воспринять новый тип атрибута, и не будет его посылать.</p><p>Следующие правила следует использовать при генерации и обработке атрибута 'version' в заголовках потоков:</p><ol><li><p>Инициатор должен установить значение атрибута 'version' в заголовке исходного потока равным наивысшей поддерживаемой версии (например, если наивысшая поддерживаемая им версия равна описанной в данном документе, он должен установить ее равной "1.0").</p></li><li><p>Приемник должен установить значение атрибута 'version' в заголовке потока-отклика равным либо значению версии, присланной инициатором, либо наивысшему поддерживаемому значению приемника, в зависимости от того какое значение ниже. Приемник должен осуществлять числовое сравнение старшего и младшего кодов версии, а не использовать значение строки "&lt;major&gt;.&lt;minor&gt;".</p></li><li><p>Если номер версии, включенный в заголовок потока-отклика является по крайней мере в старшей части меньше, чем код версии, включенный в заголовок исходного потока, сущности новой версии не смогут работать. Инициатор должен сформировать уведомление об ошибки &lt;unsupported-version/&gt; и прервать XML-поток и разорвать TCP-соединение.</p></li><li><p>Если какой-либо объект получает заголовок без атрибута 'version', объект должен считать поддерживаемую версию объекта равной "0.0" и не должен включать атрибут 'version' в заголовок потока, который он посылает в виде отклика.</p></li></ol><h3>4.5. Декларации пространства имен</h3><p>Потоковый элемент должен содержать декларации потокового пространства имен и пространства имен по умолчанию ("декларация пространства имен" определено XML спецификации пространства имен [XML-NAMES]).</p><h3>4.6. Характеристики потока</h3><p>Если инициатор включает атрибут 'version' в заголовок исходного потока со значением по крайней мере "1.0", приемник должен послать дочерний элемент &lt;features/&gt; (перед ним размещается префикс пространства имен потока) инициатору, для того чтобы анонсировать любые характеристики поточного уровня, которые могут быть согласованы (или возможности, которые нужно анонсировать). Сейчас, это используется только для анонсирования использования TLS (раздел 5), использования SASL (раздел 6) и подключаемых ресурсов (раздел 7), а также для установления сессий, как это определено в [XMPP-IM]; однако, функциональность потоковых характеристик может использоваться для анонсирования других согласуемых параметров в будущем. Если объект не понимает или не поддерживает некоторые возможности, он должен их молча игнорировать.</p><h3>4.7. Ошибки потока</h3><p>Корневой потоковый элемент может содержать дочерний элемент &lt;error/&gt;, перед которым следует префикс пространства имен потока. Дочерний элемент ошибки должен быть послан соответствующим объектом (обычно сервером, а не клиентом), если он понимает, что на поточном уровне произошла ошибка.</p><h4>4.7.1. Правила</h4><p>Следующие правила используются в отношении ошибок уровня потока:</p><ul class="dot"><li><p>Предполагается, что все ошибки потокового уровня являются неисправимыми; следовательно, если ошибка случается на уровне потока, объект, который детектирует ошибку должен послать сигнал потоковой ошибки другому объекту, послать закрывающий тэг &lt;/stream&gt;, и завершить TCP-соединение.</p></li><li><p>Ошибка происходит, когда поток сформирован, получатель должен послать открывающий тэг &lt;stream&gt;, включить элемент &lt;error/&gt; в качестве дочернего, послать закрывающий тэг &lt;/stream&gt; и разорвать TCP-соединение. В этом случае, если инициатор предлагает неизвестную машину в атрибуте 'to' (или вообще не предлагает атрибута 'to'), сервер должен выдать перед терминацией заслуживающее доверия имя машины в атрибуте 'from' заголовка потока.</p></li></ul><h4>4.7.2. Синтаксис</h4><p>Синтаксис потоковых ошибок имеет следующий формат:</p><pre>&lt;stream:error&gt;
  &lt;defined-condition xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
  &lt;text xmlns='urn:ietf:params:xml:ns:xmpp-streams'
        xml:lang='langcode'&gt;
    OPTIONAL descriptive text
  &lt;/text&gt;
  [OPTIONAL application-specific condition element]
&lt;/stream:error&gt;</pre><p>Элемент &lt;error/&gt;:</p><ul class="dot"><li><p>должен содержать дочерний элемент, соответствующий одной из выявленных ошибок строф; этот элемент должен быть задан пространством имен 'urn:ietf:params:xml:ns:xmpp-streams'</p></li><li><p>содержать дочерний элемент &lt;text/&gt;, содержащий XML символьные данные, которые характеризуют ошибку более детально; этот элемент должен быть связан с пространством имен 'urn:ietf:params:xml:ns:xmpp-streams' и должен иметь атрибут 'xml:lang', характеризующий язык, используемый символьными данными.</p></li><li><p>содержать дочерний элемент для ошибки, специфичной для определенного состояния приложения; этот элемент должен быть привязан к прикладному пространству имен, а его структура определяется этим пространством имен.</p></li></ul><p>Элемент &lt;text/&gt; является опционным. В случае включения он должен использоваться только для описательных и диагностических данных, которые являются дополнительным пояснением условий. Он не должен интерпретироваться приложением программно. Он не должен использоваться в качестве сообщения об ошибке пользователю, но может служить дополнением к сообщению об ошибке.</p><h4>4.7.3. Определенные условия</h4><p>Определены следующие условия для ошибок уровня потока:</p><ul><li class="b">&lt;bad-format/&gt;</li><li class="lib">объект послал XML, который не может быть обработан; эта ошибка может использоваться вместо каких-то более специфических связанных с XML ошибок, таких как &lt;bad-namespace-prefix/&gt;, &lt;invalid-xml/&gt;, &lt;restricted-xml/&gt;, &lt;unsupported-encoding/&gt; и &lt;xml-not-well-formed/&gt;, хотя предпочтительнее более специфические сообщения об ошибках.</li><li class="b">&lt;bad-namespace-prefix/&gt;</li><li class="lib">объект послал префикс пространства имен, которое не поддерживается, или не послал префикс пространства имен на элемент, который требует такого префикса (смотри XML имена пространства имен и префиксы (раздел 11)).</li><li class="b">&lt;conflict/&gt;</li><li class="lib">сервер закрывает активный поток для этого объекта, так как инициирован новый поток, который конфликтует с существующим.</li><li class="b">&lt;connection-timeout/&gt;</li><li class="lib">объект не генерировал трафик через поток в течение некоторого времени (сконфигурирован исключительно для локальной работы).</li><li class="b">&lt;host-gone/&gt;</li><li class="lib">значение атрибута 'to', проверенное инициатором в заголовке потока соответствует машине, которая более не обслуживается сервером.</li><li class="b">&lt;host-unknown/&gt;</li><li class="lib">значение атрибута 'to', выданное инициатором в заголовке потока, не соответствует машине, обслуживаемой сервером.</li><li class="b">&lt;improper-addressing/&gt;</li><li class="lib">строфа, пересланная между серверами, не содержит атрибута 'to' или 'from' (или атрибут не имеет значения).</li><li class="b">&lt;internal-server-error/&gt;</li><li class="lib">сервер имеет ошибку в конфигурации или имеет место другая внутренняя ошибка, мешающая обработке потока.</li><li class="b">&lt;invalid-from/&gt;</li><li class="lib">JID имя машины, представленное в адресе 'from', не соответствует авторизованному JID или соответствующему согласованному домену (с помощью SASL или dialback).</li><li class="b">&lt;invalid-id/&gt;</li><li class="lib">ID потока или dialback ID некорректны или не соответствуют присланному ранее ID.</li><li class="b">&lt;invalid-namespace/&gt;</li><li class="lib">имя пространства имен потоков не соответствует &quot;http://etherx.jabber.org/streams&quot; или имя пространства имен dialback не совпадает с &quot;jabber:server:dialback&quot; (смотри &quot;XML имена пространства имен и префиксы&quot; (раздел 11)).</li><li class="b">&lt;invalid-xml/&gt;</li><li class="lib">объект послал некорректный XML через поток серверу, который выполняет валидацию (смотри &quot;Валидация&quot; (раздел 11)).</li><li class="b">&lt;not-authorized/&gt;</li><li class="lib">объект попытался послать данные, прежде чем поток оказался аутентифицирован, или он не авторизован для выполнения согласования формирования потока; приемник не должен обрабатывать предлагаемую строфу до посылки сообщения об ошибке.</li><li class="b">&lt;policy-violation/&gt;</li><li class="lib">объект нарушил некоторые правила внутренней политики; сервер может специфицировать политику в элементе &lt;text/&gt;.</li><li class="b">&lt;remote-connection-failed/&gt;</li><li class="lib">сервер не может корректно подключится к удаленному объекту, который необходим для авторизации или аутентификации.</li><li class="b">&lt;resource-constraint/&gt;</li><li class="lib">сервер не имеет достаточных ресурсов, чтобы обслужить поток.</li><li class="b">&lt;restricted-xml/&gt;</li><li class="lib">объект попытался послать нечто с ограниченным применением, например, комментарий, инструкцию обработки, DTD, ссылку на объект или недопустимый символ (смотри &quot;Ограничения&quot; (раздел 11)).</li><li class="b">&lt;see-other-host/&gt;</li><li class="lib">сервер не будет осуществлять сервис для инициатора, но переадресует трафик другой машине; сервер должен специфицировать имя альтернативной машины или IP-адрес (который должен являться корректным доменным идентификатором) в виде элемента XML символьных данных &lt;see-other-host/&gt;.</li><li class="b">&lt;system-shutdown/&gt;</li><li class="lib">сервер выключается и все активные потоки закрываются.</li><li class="b">&lt;undefined-condition/&gt;</li><li class="lib">обстоятельства ошибки не совпадает ни с одним из перечисленных выше; это условие ошибки следует использовать только совместно с условиями специфическими для приложения.</li><li class="b">&lt;unsupported-encoding/&gt;</li><li class="lib">инициатор использовал кодирование потока, которое не поддерживается сервером (смотри &quot;Кодировка символов&quot; (раздел 11)).</li><li class="b">&lt;unsupported-stanza-type/&gt;</li><li class="lib">инициатор послал дочерний поток первого уровня, который не поддерживается сервером.</li><li class="b">&lt;unsupported-version/&gt;</li><li class="lib">значение атрибута 'version', выданное инициатором в заголовке потока, специфицирует версию XMPP, которая не поддерживается сервером; сервер может специфицировать версии, поддерживаемого элемента с помощью &lt;text/&gt;.</li><li class="b">&lt;xml-not-well-formed/&gt;</li><li class="lib">инициатор послал XML, который некорректно сформирован (смотри [XML]).</li></ul><h4>4.7.4. Специфические для приложения условия</h4><p>Как было отмечено, приложение может выдать свою информацию об ошибке потока путем включения дочернего элемента ошибки. Специфический для приложения элемент должен быть дополнением к стандартному элементу. Таким образом элемент &lt;error/&gt; будет содержать 2-3 дочерних элементов:</p><pre>&lt;stream:error&gt;
     &lt;xml-not-well-formed
         xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;text xml:lang='en' xmlns='urn:ietf:params:xml:ns:xmpp-streams'&gt;
       Some special application diagnostic information!
     &lt;/text&gt;
     &lt;escape-your-data xmlns='application-ns'/&gt;
   &lt;/stream:error&gt;
   &lt;/stream:stream&gt;</pre><h3>4.8. Упрощенные примеры потоков</h3><p>Ниже представлены два упрощенных примера сессий, базирующихся на потоках клиент-сервер (где в "C"-строках данные пересылаются от клиента к серверу, а в "S"-строках — от сервера к клиенту); эти примеры включены для целей иллюстрации концепции, изложенной далее.</p><p>Базовая "сессия":</p><pre>C: &lt;?xml version='1.0'?&gt;
   &lt;stream:stream
       to='example.com'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'
       version='1.0'&gt;
S: &lt;?xml version='1.0'?&gt;
   &lt;stream:stream
       from='example.com'
       id='someid'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'
       version='1.0'&gt;</pre><p>... шифрование, аутентификация и подключение ресурсов ...</p><pre>C:   &lt;message from='juliet@example.com'
              to='romeo@example.net'
              xml:lang='en'&gt;
C:     &lt;body&gt;Art thou not Romeo, and a Montague?&lt;/body&gt;
C:   &lt;/message&gt;
S:   &lt;message from='romeo@example.net'
              to='juliet@example.com'
              xml:lang='en'&gt;
S:     &lt;body&gt;Neither, fair saint, if either thee dislike.&lt;/body&gt;
S:   &lt;/message&gt;
C: &lt;/stream:stream&gt;
S: &lt;/stream:stream&gt;</pre><p>Сессия реализована плохо:</p><pre>C: &lt;?xml version='1.0'?&gt;
   &lt;stream:stream
       to='example.com'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'
       version='1.0'&gt;
S: &lt;?xml version='1.0'?&gt;
   &lt;stream:stream
       from='example.com'
       id='someid'
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'
       version='1.0'&gt;</pre><p>... шифрование, аутентификация и подключение ресурсов ...</p><pre>C: &lt;message xml:lang='en'&gt;
     &lt;body&gt;Bad XML, no closing body tag!
   &lt;/message&gt;
S: &lt;stream:error&gt;
    &lt;xml-not-well-formed
        xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
   &lt;/stream:error&gt;
S: &lt;/stream:stream&gt;</pre><h2 id="p5">5. Использование TLS</h2><h3>5.1. Overview</h3><p>XMPP включает в себя метод обеспечения безопасности потока от фальсификации и подслушивания. Метод криптозащиты канала использует протокол безопасности транспортного уровня [TLS], с расширениями "STARTTLS", которые смоделированы для протоколов IMAP [IMAP], POP3 [POP3] и ACAP [ACAP], как это описано в RFC 2595 [USINGTLS]. Имя пространства имен для расширения STARTTLS = 'urn:ietf:params:xml:ns:xmpp-tls'.</p><p>Администратор данного домена может потребовать использования TLS для коммуникаций клиент-сервер и сервер-сервер. Клиенты должны использовать TLS, чтобы обеспечить безопасность потоков, прежде чем пытаться завершить согласование SASL (раздел 6), а серверы должны использовать TLS между двумя доменами для целей обеспечения безопасности коммуникаций сервер-сервер.</p><p>Используются следующие правила:</p><ol><li><p>Инициатор, который следует данной спецификации должен включить в заголовок потока атрибут 'version', содержащий значение "1.0".</p></li><li><p>Если согласование TLS происходит между двумя серверами, коммуникации не должны происходить до тех пор, пока DNS не распознает имена машин, введенные серверами (смотри "Коммуникации сервер-сервер" (раздел 14)).</p></li><li><p>Когда приемник, который следует данной спецификации, получает заголовок исходного потока, который содержит атрибут 'version', равный по крайней мере "1.0", он должен включить элемент &lt;starttls/&gt; (привязанный к пространству имен 'urn:ietf:params:xml:ns:xmpp-tls') вместе со списком других характеристик потока.</p></li><li><p>Если приемник намерен использовать TLS, согласование параметров TLS должно быть завершено до согласования использования SASL; такой порядок диалога необходим, чтобы защитить аутентификационную информацию, посланную во время согласования применения SASL.</p></li><li><p>Во время согласования использования TLS, объект не должен посылать каких-либо символов пробелов в элементе корневого потока в качестве сепараторов между элементами (любой пробел, имеющийся в примерах TLS ниже, включен исключительно из соображений читаемости); этот запрет помогает гарантировать корректность байт на уровне безопасности.</p></li><li><p>Приемник должен осуществлять согласование применения TLS сразу после посылки завершающего символа ">" элемента &lt;proceed/&gt;. Инициатор должен осуществлять согласование применения TLS сразу после получения завершающего символа ">" элемента &lt;proceed/&gt; от приемника.</p></li><li><p>Инициатор должен проверить сертификат, представленный приемником; (смотри "Проверка сертификата" (раздел 14)).</p></li><li><p>Сертификаты должны проверяться по поводу имени машины, выданного инициатором, (например, пользователем), а не имя машины, полученное с помощью DNS; например, если пользователь специфицирует имя машины "example.com", а DNS SRV прислал "im.example.com", сертификат должен проверять версию "example.com". Если JID для любого XMPP-объекта (например, клиента или сервера) присутствует в сертификате, он должен быть представлен, в виде UTF8String в пределах имени некоторого объекта (otherName) внутри subjectAltName. Делается это с привлечением объектного идентификатора [ASN.1] "id-on-xmppAddr", специфицированного в разделе 5.</p></li><li><p>Если согласование применения TLS прошло успешно, приемник должен ликвидировать любые данные, полученные ранее от инициатора небезопасным способом.</p></li><li><p>Если согласование применения TLS прошло успешно, инициатор должен аннулировать любые данные, полученные ранее от приемника небезопасным способом.</p></li><li><p>Если согласование применения TLS прошло успешно, приемник не должен предлагать инициатору расширения STARTTLS, а также другие возможности, которые предложены, когда поток рестартовал.</p></li><li><p>Если согласование применения TLS прошло успешно, инициатор должен приступить к согласованию SASL.</p></li><li><p>Если согласование применения TLS завершилось неудачей, приемник должен прервать XML-поток и разорвать TCP-соединение.</p></li><li><p>По поводу механизмов, которые должны быть непременно поддержаны, смотри в "Обязательные для использования технологии" (раздел 14).</p></li></ol><h4>5.1.1. Идентификатор объекта ASN.1 для XMPP-адреса</h4><p>Идентификатор объекта [ASN.1] "id-on-xmppAddr", описанный выше, определяется следующим образом:</p><pre>id-pkix OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
        dod(6) internet(1) security(5) mechanisms(5) pkix(7) }

id-on  OBJECT IDENTIFIER ::= { id-pkix 8 }  -- other name forms

id-on-xmppAddr  OBJECT IDENTIFIER ::= { id-on 5 }

XmppAddr ::= UTF8String</pre><p>Этот объектный идентификатор может быть представлен в точечном формате вида "1.3.6.1.5.5.7.8.5".</p><h3>5.2. Диалог</h3><p>Когда инициатор обеспечивает безопасность потока с помощью TLS, реализуются следующие шаги:</p><ol><li><p>Инициатор открывает TCP-соединение и инициирует поток путем посылки XML-заголовка получателю. В заголовок потока вставляется атрибут 'version', со значением как минимум "1.0".</p></li><li><p>Получатель откликается установлением TCP-соединения и посылкой XML-заголовка потока инициатору, включая при этом в заголовок атрибут 'version', содержащий значение как минимум "1.0".</p></li><li><p>Получатель предлагает инициатору расширение STARTTLS, включив его вместе с другими возможностями потока (если для взаимодействия с получателем требуется TLS, он должен сигнализировать об этом с помощью включения элемента &lt;required/&gt; в качестве дочернего элемента &lt;starttls/&gt;).</p></li><li><p>Инициатор выдает команду STARTTLS (т.е., элемент &lt;starttls/&gt;, соотнесенный с пространством имен 'urn:ietf:params:xml:ns:xmpp-tls'), чтобы уведомит получателя, что он хочет начать согласование применения TLS.</p></li><li><p>Получатель должен откликнуться либо элементом &lt;proceed/&gt;, либо элементом &lt;failure/&gt;, соотнесенным с пространством имен 'urn:ietf:params:xml:ns:xmpp-tls'. Если произойдет сбой, получатель должен прервать XML-поток и разорвать TCP-соединение. Если все в порядке, участники должны попытаться завершить согласование применения TLS через имеющееся TCP-соединение и до завершения этого процесса не должны посылать какие-либо XML-данные.</p></li><li><p>Инициатор и получатель пытаются согласно с [TLS] завершить согласование TLS.</p></li><li><p>Если реализация TLS оказалась неудачной, получатель должен разорвать TCP-соединение. В случае же успеха, инициатор должен сформировать новый поток, послав открывающий XML-заголовок получателю (необязательно посылать сначала закрывающий тэг &lt;/stream&gt;, так как получатель и инициатор должна рассматривать исходный поток закрытым после успешного завершения согласования применения TLS).</p></li><li><p>После получения нового заголовка потока от инициатора, получатель должен откликнуться посылкой инициатору нового заголовка XML-потока вмести со всеми доступными возможностями (возможность STARTTLS не включается).</p></li></ol><h3>5.3. Пример клиент-сервер</h3><p>Следующий пример показывает поток данных с обеспечением безопасности потока посредством STARTTLS (заметим: альтернативные шаги, показанные ниже, выполнены для иллюстрации протокола в случае сбоя (неудачи), они не являются исчерпывающими и не обязательно будут реализованы при пересылке данных в данном примере).</p><p>Шаг 1: Клиент формирует поток к серверу:</p><pre>&lt;stream:stream
   xmlns='jabber:client'
   xmlns:stream='http://etherx.jabber.org/streams'
   to='example.com'
   version='1.0'&gt;</pre><p>Шаг 2: Сервер откликается посылкой тэга потока клиенту:</p><pre>&lt;stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    id='c2s_123'
    from='example.com'
    version='1.0'&gt;</pre><p>Шаг 3: Сервер посылает клиенту расширение STARTTLS и данные о механизме аутентификации и других особенностях потока:</p><pre>&lt;stream:features&gt;
  &lt;starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'&gt;
    &lt;required/&gt;
  &lt;/starttls&gt;
  &lt;mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
    &lt;mechanism&gt;DIGEST-MD5&lt;/mechanism&gt;
    &lt;mechanism&gt;PLAIN&lt;/mechanism&gt;
  &lt;/mechanisms&gt;
&lt;/stream:features&gt;</pre><p>Шаг 4: Клиент посылает серверу команду STARTTLS:</p><pre>&lt;starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/&gt;</pre><p>Шаг 5: Сервер информирует клиента о том, что он может продолжить работу:</p><pre>&lt;proceed xmlns='urn:ietf:params:xml:ns:xmpp-tls'/&gt;</pre><p>Шаг 5 (alt): Сервер информирует клиента, что согласование TLS не состоялось и следует прервать поток и разорвать TCP-соединение:</p><pre>&lt;failure xmlns='urn:ietf:params:xml:ns:xmpp-tls'/&gt;
&lt;/stream:stream&gt;</pre><p>Шаг 6: Клиент и сервер пытаются завершить согласование применения TLS через существующее TCP-соединение.</p><p>Шаг 7: Если согласование TLS успешно, клиент формирует новый поток к серверу:</p><pre>&lt;stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    to='example.com'
    version='1.0'&gt;</pre><p>Шаг 7 (alt): Если согласование TLS не получилось, сервер закрывает TCP-соединение.</p><p>Шаг 8: Сервер реагирует посылкой клиенту заголовка потока и любых характеристик потока:</p><pre>&lt;stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    from='example.com'
    id='c2s_234'
    version='1.0'&gt;
&lt;stream:features&gt;
  &lt;mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
    &lt;mechanism&gt;DIGEST-MD5&lt;/mechanism&gt;
    &lt;mechanism&gt;PLAIN&lt;/mechanism&gt;
    &lt;mechanism&gt;EXTERNAL&lt;/mechanism&gt;
  &lt;/mechanisms&gt;
&lt;/stream:features&gt;</pre><p>Шаг 9: Клиент продолжает согласование SASL (раздел 6).</p><h3>5.4. Пример сервер-сервер</h3><p>Следующий пример показывает поток данных для двух серверов, обеспечивающих безопасность с помощью STARTTLS (заметим: альтернативные шаги, показанные ниже, приведены для иллюстрации работы протокола в случаях сбоев; они не являются обязательными).</p><p>Шаг 1: Сервер1 инициирует поток в серверу2:</p><pre>&lt;stream:stream
    xmlns='jabber:server'
    xmlns:stream='http://etherx.jabber.org/streams'
    to='example.com'
    version='1.0'&gt;</pre><p>Шаг 2: Сервер2 откликается посылкой тэга потока Серверу1:</p><pre>&lt;stream:stream
    xmlns='jabber:server'
    xmlns:stream='http://etherx.jabber.org/streams'
    from='example.com'
    id='s2s_123'
    version='1.0'&gt;</pre><p>Шаг 3: Сервер2 посылает расширение STARTTLS Серверу1 вместе с данными о механизме аутентификации и любыми другими возможностями потока:</p><pre>&lt;stream:features&gt;
  &lt;starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'&gt;
    &lt;required/&gt;
  &lt;/starttls&gt;
  &lt;mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
    &lt;mechanism&gt;DIGEST-MD5&lt;/mechanism&gt;
    &lt;mechanism&gt;KERBEROS_V4&lt;/mechanism&gt;
  &lt;/mechanisms&gt;
&lt;/stream:features&gt;</pre><p>Шаг 4: Сервер1 посылает команду STARTTLS Серверу2:</p><pre>&lt;starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/&gt;</pre><p>Шаг 5: Сервер2 информирует Сервер1 о том, что он может продолжать работу:</p><pre>&lt;proceed xmlns='urn:ietf:params:xml:ns:xmpp-tls'/&gt;</pre><p>Шаг 5 (alt): Сервер2 информирует Сервер1 о том, что согласование применения TLS не прошло и поток закрывается:</p><pre>&lt;failure xmlns='urn:ietf:params:xml:ns:xmpp-tls'/&gt;
&lt;/stream:stream&gt;</pre><p>Шаг 6: Сервер1 и Сервер2 пытаются завершить согласование применения TLS через TCP.</p><p>Шаг 7: Если согласование TLS прошло успешно, Сервер1 формирует новый поток к Серверу2:</p><pre>&lt;stream:stream
    xmlns='jabber:server'
    xmlns:stream='http://etherx.jabber.org/streams'
    to='example.com'
    version='1.0'&gt;</pre><p>Шаг 7 (alt): Если согласование TLS не прошло, Сервер2 закрывает TCP-соединение.</p><p>Шаг 8: Сервер2 откликается посылкой заголовка потока Серверу1 вместе с данными о доступных возможностях потока:</p><pre>&lt;stream:stream
    xmlns='jabber:server'
    xmlns:stream='http://etherx.jabber.org/streams'
    from='example.com'
    id='s2s_234'
    version='1.0'&gt;
&lt;stream:features&gt;
  &lt;mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
    &lt;mechanism&gt;DIGEST-MD5&lt;/mechanism&gt;
    &lt;mechanism&gt;KERBEROS_V4&lt;/mechanism&gt;
    &lt;mechanism&gt;EXTERNAL&lt;/mechanism&gt;
  &lt;/mechanisms&gt;
&lt;/stream:features&gt;</pre><p>Шаг 9: Сервер1 продолжает согласование применения SASL (раздел 6).</p><h2 id="p6">6. Использование SASL</h2><h3>6.1. Overview</h3><p>MPP содержит в себе метод аутентификации потока с помощью XMPP-профайла протокола SASL (Simple Authentication and Security Layer) [SASL]. SASL предоставляет обобщенный метод добавления поддержки аутентификации для протоколов с установлением соединения, и XMPP использует универсальный профайл XML пространства имен для SASL, который соответствует требованиям [SASL].</p><p>Используются следующие правила:</p><ol><li><p>Если согласование применения SASL происходит между двумя серверами, коммуникации не должны продолжаться до тех пор, пока с помощью DNS не выяснены имена присвоенные серверам (смотри "Коммуникации сервер-сервер" (раздел 14)).</p></li><li><p>Если инициатор может согласовать применение SASL, он должен включить в заголовок исходного потока атрибут 'version' со значением по крайней мере равным "1.0".</p></li><li><p>Если получатель может согласовать применение SASL, он должен анонсировать один или более аутентификационных механизмов в элементе &lt;mechanisms/&gt;, сопряженным с пространством имен 'urn:ietf:params:xml:ns:xmpp-sasl', в отклике на открывающий тэг потока, полученный от инициатора (если открывающий тэг потока включает в себя атрибут 'version' со значением по крайней мере равным "1.0").</p></li><li><p>Во время согласования применения SASL, объект не должен в качестве сепараторов элементов посылать символы пробелов (см. процедуру формирования содержимого в [XMPP-IM] и [XML]) в элементе корневого потока (любой символ пробела, представленный в примерах SASL, введен исключительно с целью обеспечения читабельности текста); этот запрет помогает гарантировать корректность представления материала на уровне безопасности.</p></li><li><p>Любые XML символьные данные, содержащиеся в XML-элементах, и используемые при согласовании SASL должны иметь кодировку base64, где кодировка привязана к определениям из раздела 3 RFC 3548 [BASE64].</p></li><li><p>Если предоставление "simple username" поддерживается выбранным механизмом SASL (например, это поддерживается механизмами DIGEST-MD5 и CRAM-MD5, но не поддерживается механизмами EXTERNAL и GSSAPI), во время аутентификации, инициатор должен обеспечить в качестве простого имени пользователя свой домен (IP-адрес или полное доменное имя, как оно записано в доменном идентификаторе) в случае коммуникаций сервер-сервер, или свое имя аккоунта (имя пользователя или узла, содержащегося в XMPP-идентификаторе узла) в случае коммуникаций клиент-сервер.</p></li><li><p>Если инициатор хочет действовать в интересах другого объекта и выбранный механизм SASL поддерживает передачу авторизационной идентичности, инициатор должен предоставить авторизационную идентичность в процессе согласования применения SASL. Если инициатор не хочет действовать в интересах другого объекта, он не должен предоставлять идентичность авторизации. Как специфицировано в [SASL], инициатор не должен предоставлять идентичность авторизации, за исключением случая, когда идентичность авторизации отличается от идентичности по умолчанию, полученной согласно [SASL]. Если такие данные предоставляются, значение идентичности авторизации должно иметь формат &lt;domain&gt; (т.е., только идентификатор домена) для серверов и формат &lt;node@domain&gt; (т.е., идентификатор узла и идентификатор домена) для клиентов.</p></li><li><p>В случае успешного согласования SASL, которое включает в себя согласование уровня безопасности, получатель должен ликвидировать любую информацию, полученную от инициатора, которая не получена непосредственно в процессе согласования SASL.</p></li><li><p>В случае успешного согласования SASL, которое включает в себя согласование уровня безопасности, инициатор должен ликвидировать любую информацию, полученную от получателя, которая не получена непосредственно в процессе согласования SASL.</p></li><li><p>В отношении механизмов, которые нужно поддерживать смотри "Обязательные для использования технологии" (раздел 14).</p></li></ol><h3>6.2. Narrative</h3><p>Когда инициатор аутентифицирует получателя, используя SASL, процедура включает в себя следующие шаги:</p><ol><li><p>Инициатор запрашивает аутентификацию SASL путем включения атрибута 'version' в открывающий заголовок XML потока, направленного получателю, со значением равным "1.0".</p></li><li><p>После посылки заголовка XML-потока в виде отклика, получатель анонсирует список доступных механизмов аутентификации SASL; каждый из этих элементов &lt;mechanism/&gt; включаются в качестве дочерних в контейнерный элемент &lt;mechanisms/&gt;, соотнесенный с пространством имен 'urn:ietf:params:xml:ns:xmpp-sasl', который в свою очередь является дочерним элементом &lt;features/&gt; в пространстве имен потока. Если TLS (раздел 5) нужно установить, прежде чем использовать какой-то конкретный механизм аутентификации, получатель не должен помещать этот механизм в список механизмов аутентификации SASL, до согласования TLS. Если инициатор предоставляет корректный сертификат при предварительном согласовании TLS, получатель при согласовании SASL должен предложить инициатору механизм SASL EXTERNAL (смотри [SASL]), хотя механизм EXTERNAL может быть предложен также и при других обстоятельствах.</p></li><li><p>Инициатор выбирает механизм путем посылки элемента &lt;auth/&gt;, соотнесенного с пространством имен 'urn:ietf:params:xml:ns:xmpp-sasl', получателю. Элемент содержит также значение атрибута 'mechanism'. Этот элемент может содержать символьные XML-данные (в терминологии SASL, "исходный отклик"), если механизм поддерживает или требует этого. Если инициатор должен послать исходный отклик нулевой длины, он должен передать отклик в виде одиночного символа равенства ("="), который указывает, что этот отклик не содержит данных.</p></li><li><p>Если необходимо, получатель направляет вызов инициатору путем посылки инициатору элемента &lt;challenge/&gt;, соотнесенного с пространством имен 'urn:ietf:params:xml:ns:xmpp-sasl'. Этот элемент может содержать символьные данные (которые должны быть обработаны в соответствии с определением механизма SASL, который выбрал инициатор).</p></li><li><p>Инициатор реагирует на вызов посылкой получателю элемента &lt;response/&gt;, соотнесенного с пространством имен 'urn:ietf:params:xml:ns:xmpp-sasl'. Этот элемент может содержать символьную XML-информацию (которая должна быть обработана в соответствии с определением механизма SASL, который выбрал инициатор).</p></li><li><p>Если необходимо, получатель посылает несколько вызовов, а инициатор отправляет несколько откликов.</p></li></ol><p>Эти последовательности вызов/отклик продолжаются до тех пор пока не случится одно из трех событий:</p><ol><li><p>Инициатор обрывает диалог посылкой получателю элемента &lt;abort/&gt;, соотносящегося с пространством имен 'urn:ietf:params:xml:ns:xmpp-sasl'. После получения элемента &lt;abort/&gt; получатель должен разрешить конфигурируемое но разумное число повторных попыток (по крайней мере 2), после которых он должен прервать TCP-соединение. Это позволяет инициатору (например, конечному пользователю — клиенту) перепроверить неверно выданные параметры авторизации (например, опечатку в пароле) без необходимости выполнения повторного соединения.</p></li><li><p>Получатель сообщает о неудаче диалога посылкой инициатору элемента &lt;failure/&gt;, соотносящегося пространству имен 'urn:ietf:params:xml:ns:xmpp-sasl', конкретная причина неудачи должна быть сообщена в соответствующем дочернем элементе элемента &lt;failure/&gt;, как это определено главе "Ошибки SASL" (раздел 6.4). В случае неудачи получатель должен разрешить конфигурируемое, но разумное число повторных попыток (по крайней мере 2), после которых он должен прервать TCP-соединение. Это позволяет инициатору (например, конечному пользователю — клиенту) перепроверить неверно выданные параметры авторизации (например, опечатку в пароле) без необходимости выполнения повторного соединения.</p></li><li><p>Получатель сообщает об успехе диалога посылкой инициатору элемента &lt;success/&gt;, соотносимого с пространством имен 'urn:ietf:params:xml:ns:xmpp-sasl'. Этот элемент может содержать символьную XML-информацию (в терминологии SASL "дополнительные данные при успехе"), если это требуется выбранным механизмом SASL. После получения элемента &lt;success/&gt; инициатор должен сформировать новый поток, путем посылки открывающего заголовка XML-потока получателю (посылать закрывающий тэг &lt;/stream&gt; не нужно, так как приемник и инициатор должны рассматривать исходный поток закрытым после отправки или получения элемента &lt;success/&gt;). После получения заголовка нового потока от инициатора получатель должен реагировать посылкой инициатору нового заголовка потока и информировать партнера об имеющихся возможностях посредством элемента &lt;features/&gt;.</p></li></ol><h3>6.3. Определение SASL</h3><p>Требования профайла [SASL] определяют необходимость предоставления следующей протокольной информации:</p><ul><li class="b">имя сервиса:</li><li class="lib">"xmpp"</li><li class="b">стартовая последовательность:</li><li class="lib">после того как инициатор выдает открывающий заголовок потока и получатель соответственно откликается, получатель выдает список приемлемых методов аутентификации. Инициатор выбирает один из методов и посылает получателю значение атрибута 'mechanism', содержащегося в элементе &lt;auth/&gt;.</li><li class="b">последовательность обмена:</li><li class="lib">вызовы и отклики реализуются посредством обмена элементами &lt;challenge/&gt;, направляемыми от получателя инициатору, и элементами &lt;response/&gt;, отправляемыми инициатором получателю. Получатель сообщает о неудаче с помощью посылки элемента &lt;failure/&gt;, а об успехе — посредством посылки элемента &lt;success/&gt;. Инициатор абортирует обмен путем посылки элемента &lt;abort/&gt;. После успешного согласования параметров потока, обе стороны считают исходный поток закрытым и посылают друг другу заголовки нового потока.</li><li class="b">согласование на уровне безпасности:</li><li class="lib">уровень безопасности начинает функционировать сразу после посылки завершающего символа ">" элемента &lt;success/&gt; получателю, и сразу после получения инициатором завершающего символа ">" элемента &lt;success/&gt;.</li><li class="b">использование авторизационной идентичности:</li><li class="lib">авторизационная идентичность может использоваться xmpp, чтобы указать &lt;node@domain&gt; клиента (если это не значение по умолчанию) или посылки &lt;domain&gt; сервера.</li></ul><h3>6.4. Ошибки SASL</h3><p>Определены следующие условия ошибок, сопряженных с SASL:</p><ul><li class="b">&lt;aborted/&gt;</li><li class="lib">Получатель подтверждает получение элемента &lt;abort/&gt;, посланного инициатором; посылается в ответ на элемент &lt;abort/&gt;.</li><li class="b">&lt;incorrect-encoding/&gt;</li><li class="lib">Данные предоставленные инициатором не могут быть обработаны из-за того, что кодировка [BASE64] оказалась некорректной (например, потому что кодировка не соответствует определению в разделе 3 из [BASE64]); в ответ посылается элемент &lt;response/&gt; или элемент &lt;auth/&gt; вместе с данными исходного отклика.</li><li class="b">&lt;invalid-authzid/&gt;</li><li class="lib">authzid, предоставленный инициатором, либо по причине неправильного формата, либо из-за того, что инициатор не имеет разрешения авторизовать данный идентификатор, присланный в элементах отклика &lt;response/&gt; или &lt;auth/&gt;.</li><li class="b">&lt;invalid-mechanism/&gt;</li><li class="lib">Инициатор не предоставил в элементе &lt;auth/&gt; отклика механизма или запросил механизм, который не поддерживается получателем.</li><li class="b">&lt;mechanism-too-weak/&gt;</li><li class="lib">Механизм, запрошенный инициатором, слабее предусмотренного политикой сервера для данного инициатора; присылается в элементе &lt;response/&gt; или &lt;auth/&gt; отклика.</li><li class="b">&lt;not-authorized/&gt;</li><li class="lib">Аутентикация не прошла из-за того, что инициатор не предоставил корректные параметры (это может быть, например, неизвестное имя пользователя); посылается в элементах &lt;response/&gt; или &lt;auth/&gt; отклика.</li><li class="b">&lt;temporary-auth-failure/&gt;</li><li class="lib">Аутентикация не прошла из-за временной ошибки на стороне получателя; посылается в в элементах &lt;auth/&gt; или &lt;response/&gt; отклика.</li></ul><h3>6.5. Пример клиент-сервер</h3><p>Следующий пример показывает схему обмена данными при аутентификации клиента сервером с привлечением SASL, это делается в норме после согласования применения TLS (заметим: альтернативные шаги, показанные ниже, приведены для иллюстрации работы протокола в случае ошибок).</p><p>Шаг 1: Клиент формирует поток до сервер:</p><pre>&lt;stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    to='example.com'
    version='1.0'&gt;</pre><p>Шаг 2: Сервер реагирует посылкой клиенту тэга потока:</p><pre>&lt;stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    id='c2s_234'
    from='example.com'
    version='1.0'&gt;</pre><p>Шаг 3: Сервер информирует клиента об имеющихся механизмах аутентификации:</p><pre>&lt;stream:features&gt;
  &lt;mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
    &lt;mechanism&gt;DIGEST-MD5&lt;/mechanism&gt;
    &lt;mechanism&gt;PLAIN&lt;/mechanism&gt;
  &lt;/mechanisms&gt;
&lt;/stream:features&gt;</pre><p>Шаг 4: Клиент выбирает механизм аутентификации:</p><pre>&lt;auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
      mechanism='DIGEST-MD5'/&gt;</pre><p>Шаг 5: Сервер посылает закодированный вызов [BASE64] клиенту:</p><pre>&lt;challenge xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
cmVhbG09InNvbWVyZWFsbSIsbm9uY2U9Ik9BNk1HOXRFUUdtMmhoIixxb3A9ImF1dGgi
LGNoYXJzZXQ9dXRmLTgsYWxnb3JpdGhtPW1kNS1zZXNzCg==
&lt;/challenge&gt;</pre><p>Декодированный вызов имеет вид:</p><pre>realm="somerealm",nonce="OA6MG9tEQGm2hh",\
qop="auth",charset=utf-8,algorithm=md5-sess</pre><p>Шаг 5 (alt): Сервер возвращает клиенту сообщение об ошибке:</p><pre>&lt;failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
  &lt;incorrect-encoding/&gt;
&lt;/failure&gt;
&lt;/stream:stream&gt;</pre><p>Шаг 6: Клиент посылает закодированный отклик [BASE64] на вызов:</p><pre>&lt;response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
dXNlcm5hbWU9InNvbWVub2RlIixyZWFsbT0ic29tZXJlYWxtIixub25jZT0i
T0E2TUc5dEVRR20yaGgiLGNub25jZT0iT0E2TUhYaDZWcVRyUmsiLG5jPTAw
MDAwMDAxLHFvcD1hdXRoLGRpZ2VzdC11cmk9InhtcHAvZXhhbXBsZS5jb20i
LHJlc3BvbnNlPWQzODhkYWQ5MGQ0YmJkNzYwYTE1MjMyMWYyMTQzYWY3LGNo
YXJzZXQ9dXRmLTgK
&lt;/response&gt;</pre><p>Декодированный отклик имеет вид:</p><pre>username=&quot;somenode&quot;,realm=&quot;somerealm&quot;,\
nonce=&quot;OA6MG9tEQGm2hh&quot;,cnonce=&quot;OA6MHXh6VqTrRk&quot;,\
nc=00000001,qop=auth,digest-uri=&quot;xmpp/example.com&quot;,\
response=d388dad90d4bbd760a152321f2143af7,charset=utf-8</pre><p>Шаг 7: Сервер посылает еще один закодированный [BASE64] вызов клиенту:</p><pre>&lt;challenge xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
cnNwYXV0aD1lYTQwZjYwMzM1YzQyN2I1NTI3Yjg0ZGJhYmNkZmZmZAo=
&lt;/challenge&gt;</pre><p>Декодированный вызов имеет вид:</p><pre>rspauth=ea40f60335c427b5527b84dbabcdfffd</pre><p>Шаг 7 (alt): Сервер посылалает клиенту сообщение об ошибке:</p><pre>&lt;failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
  &lt;temporary-auth-failure/&gt;
&lt;/failure&gt;
&lt;/stream:stream&gt;</pre><p>Шаг 8: Клиент откликается на вызов:</p><pre>&lt;response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/&gt;</pre><p>Шаг 9: Сервер информирует клиента об успешной аутентификации:</p><pre>&lt;success xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/&gt;</pre><p>Шаг 9 (alt): Сервер информирует клиента об ошибке аутентификации:</p><pre>&lt;failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
  &lt;temporary-auth-failure/&gt;
&lt;/failure&gt;
&lt;/stream:stream&gt;</pre><p>Шаг 10: Клиент формирует новый поток к серверу:</p><pre>&lt;stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    to='example.com'
    version='1.0'&gt;</pre><p>Шаг 11: Сервер откликается посылкой заголовка потока клиенту, сообщая о любых дополнительных имеющихся возможностях (если таких возможностей нет, посылается пустой элемент):</p><pre>&lt;stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    id='c2s_345'
    from='example.com'
    version='1.0'&gt;
&lt;stream:features&gt;
  &lt;bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/&gt;
  &lt;session xmlns='urn:ietf:params:xml:ns:xmpp-session'/&gt;
&lt;/stream:features&gt;</pre><h3>6.6. Пример сервер-сервер</h3><p>Следующий пример демонстрирует информационный обмен при аутентификации одного сервера другим при использовании SASL, это в норме может производиться только после завершения согласования применения TLS (заметим: альтернативные шаги, показанные ниже, приведены исключительно с иллюстративной целью).</p><p>Шаг 1: Сервер1 инициирует поток к Серверу2:</p><pre>&lt;stream:stream
    xmlns='jabber:server'
    xmlns:stream='http://etherx.jabber.org/streams'
    to='example.com'
    version='1.0'&gt;</pre><p>Шаг 2: Сервер2 откликается посылкой Серверу1 тэга потока:</p><pre>&lt;stream:stream
    xmlns='jabber:server'
    xmlns:stream='http://etherx.jabber.org/streams'
    from='example.com'
    id='s2s_234'
    version='1.0'&gt;</pre><p>Шаг 3: Сервер2 информирует Сервер1 о доступных механизмах аутентификации:</p><pre>&lt;stream:features&gt;
  &lt;mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
    &lt;mechanism&gt;DIGEST-MD5&lt;/mechanism&gt;
    &lt;mechanism&gt;KERBEROS_V4&lt;/mechanism&gt;
  &lt;/mechanisms&gt;
&lt;/stream:features&gt;</pre><p>Шаг 4: Сервер1 выбирает механизм аутентификации:</p><pre>&lt;auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
      mechanism='DIGEST-MD5'/&gt;</pre><p>Шаг 5: Сервер2 посылает закодированный [BASE64] вызов Серверу1:</p><pre>&lt;challenge xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
cmVhbG09InNvbWVyZWFsbSIsbm9uY2U9Ik9BNk1HOXRFUUdtMmhoIixxb3A9
ImF1dGgiLGNoYXJzZXQ9dXRmLTgsYWxnb3JpdGhtPW1kNS1zZXNz
&lt;/challenge&gt;</pre><p>Декодированный вызов имеет вид:</p><pre>realm=&quot;somerealm&quot;,nonce=&quot;OA6MG9tEQGm2hh&quot;,\
qop=&quot;auth&quot;,charset=utf-8,algorithm=md5-sess</pre><p>Шаг 5 (alt): Сервер2 возвращает Серверу1 сообщение об ошибке:</p><pre>&lt;failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
  &lt;incorrect-encoding/&gt;
&lt;/failure&gt;
&lt;/stream:stream&gt;</pre><p>Шаг 6: Сервер1 посылает закодированный отклик [BASE64] на вызов:</p><pre>&lt;response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
dXNlcm5hbWU9ImV4YW1wbGUub3JnIixyZWFsbT0ic29tZXJlYWxtIixub25j
ZT0iT0E2TUc5dEVRR20yaGgiLGNub25jZT0iT0E2TUhYaDZWcVRyUmsiLG5j
PTAwMDAwMDAxLHFvcD1hdXRoLGRpZ2VzdC11cmk9InhtcHAvZXhhbXBsZS5v
cmciLHJlc3BvbnNlPWQzODhkYWQ5MGQ0YmJkNzYwYTE1MjMyMWYyMTQzYWY3
LGNoYXJzZXQ9dXRmLTgK
&lt;/response&gt;</pre><p>Дешифрованный отклик имеет вид:</p><pre>username=&quot;example.org&quot;,realm=&quot;somerealm&quot;,\
nonce=&quot;OA6MG9tEQGm2hh&quot;,cnonce=&quot;OA6MHXh6VqTrRk&quot;,\
nc=00000001,qop=auth,digest-uri=&quot;xmpp/example.org&quot;,\
response=d388dad90d4bbd760a152321f2143af7,charset=utf-8</pre><p>Шаг 7: Сервер2 посылает еще один закодированный [BASE64] вызов Серверу1:</p><pre>&lt;challenge xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
cnNwYXV0aD1lYTQwZjYwMzM1YzQyN2I1NTI3Yjg0ZGJhYmNkZmZmZAo=
&lt;/challenge&gt;</pre><p>Декодированный вызов имеет вид:</p><pre>rspauth=ea40f60335c427b5527b84dbabcdfffd</pre><p>Шаг 7 (alt): Сервер2 возвращает Серверу1 сообщение об ошибке:</p><pre>&lt;failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
  &lt;invalid-authzid/&gt;
&lt;/failure&gt;
&lt;/stream:stream&gt;</pre><p>Шаг 8: Сервер1 откликается на вызов:</p><pre>&lt;response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/&gt;</pre><p>Шаг 8 (alt): Сервер1 абортирует согласование:</p><pre>&lt;abort xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/&gt;</pre><p>Шаг 9: Сервер2 информирует Сервер1 об успешной аутентификации:</p><pre>&lt;success xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/&gt;</pre><p>Шаг 9 (alt): Сервер2 информирует Сервер1 о неудаче аутентификации:</p><pre>&lt;failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
  &lt;aborted/&gt;
&lt;/failure&gt;
&lt;/stream:stream&gt;</pre><p>Шаг 10: Сервер1 инициирует новый поток к Серверу2:</p><pre>&lt;stream:stream
    xmlns='jabber:server'
    xmlns:stream='http://etherx.jabber.org/streams'
    to='example.com'
    version='1.0'&gt;</pre><p>Шаг 11: Сервер2 откликается посылкой Серверу1 заголовка потока, а также данными о любых дополнительных возможностях (при отсутствии последних посылается пустой элемент):</p><pre>&lt;stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    from='example.com'
    id='s2s_345'
    version='1.0'&gt;
&lt;stream:features/&gt;</pre><h2 id="p7">7. Подключение ресурсов</h2><p>После согласования применения SASL (раздел 6) с получателем, инициатор может хотеть или не нуждаться в подключении к потоку специфических ресурсов. В основном это относится только к клиентам: для того чтобы адаптироваться к формату адресации (раздел 3) и правил доставки строф (раздел 10), специфицированных в данном документе. Должен существовать идентификатор ресурса, ассоциированный с &lt;node@domain&gt; клиента (который либо генерируется сервером, либо предлагается приложением клиента). Это гарантирует, то, что адрес используемый для данного потока, является "полным JID" формата &lt;node@domain/resource&gt;.</p><p>После получения информации об успехе согласования SASL, клиент должен послать серверу новый заголовок, на который сервер должен откликнуться заголовком потока и прислать список доступных возможностей потока. Точнее, если сервер требует, чтобы клиент после успешного согласования SASL подключил ресурс к потоку, он должен включить пустой элемент &lt;bind/&gt;, сопряженный с пространством имен 'urn:ietf:params:xml:ns:xmpp-bind', в список возможностей, которые он предлагает клиенту после отправки заголовка для потока-отклика, посланного после успешного согласования SASL (но не до):</p><p>Сервер анонсирует возможность подключения ресурса клиенту:</p><pre>&lt;stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    id='c2s_345'
    from='example.com'
    version='1.0'&gt;
&lt;stream:features&gt;
  &lt;bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/&gt;
&lt;/stream:features&gt;</pre><p>После того как клиент оказывается проинформирован о необходимости подключения ресурса, он должен выполнить подключение ресурса к потоку, посредством посылки серверу IQ-строфы типа "set" (смотри "IQ семантика" (раздел 9)), содержащей данные, соотнесенные с пространством имен 'urn:ietf:params:xml:ns:xmpp-bind'.</p><p>Если клиент хочет позволить серверу сформировать идентификатор ресурса, он посылает IQ-строфу типа "set", которая содержит пустой элемент &lt;bind/&gt;:</p><p>Клиент просит сервер подключить ресурс:</p><pre>&lt;iq type='set' id='bind_1'&gt;
  &lt;bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/&gt;
&lt;/iq&gt;</pre><p>Сервер, который поддерживает подключение ресурсов, должен быть способен генерировать идентификатор ресурса для клиента. Идентификатор ресурса, генерируемый сервером, должен быть уникальным для данного &lt;node@domain&gt;.</p><p>Если клиент хочет специфицировать идентификатор ресурса, он посылает IQ-строфу типа &quot;set&quot;, которая содержит желаемый идентификатор ресурса в виде текстового элемента &lt;resource/&gt;, который является дочерним элементом &lt;bind/&gt;:</p><p>Клиент подключает ресурс:</p><pre>&lt;iq type='set' id='bind_2'&gt;
  &lt;bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'&gt;
    &lt;resource&gt;someresource&lt;/resource&gt;
  &lt;/bind&gt;
&lt;/iq&gt;</pre><p>Раз сервер сформировал идентификатор ресурса для клиента или воспринял идентификатор, предложенный клиентом, он должен послать клиенту IQ-строфу типа &quot;result&quot;, которая должна содержать дочерний элемент &lt;jid/&gt;, который специфицирует полный JID для подключенного ресурса, как это определено сервером:</p><p>Сервер информирует клиента об успешном подключении ресурса:</p><pre>&lt;iq type='result' id='bind_2'&gt;
  &lt;bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'&gt;
    &lt;jid&gt;somenode@example.com/someresource&lt;/jid&gt;
  &lt;/bind&gt;
&lt;/iq&gt;</pre><p>Сервер должен воспринять идентификатор ресурса, присланный клиентом, Но может заменить его на идентификатор, сгенерированный сервером; в этом случае, сервер не должен присылать клиенту строфу ошибки (например, &lt;forbidden/&gt;), а вместо этого прислать клиенту свой сгенерированный идентификатор ресурса в IQ результата, как было показано выше.</p><p>Когда клиент выдает идентификатор ресурса, возможна присылка следующей строфы условий ошибки (смотри "Строфы ошибок" (раздел 9)):</p><ul class="dot"><li>Представленный идентификатор ресурса не может обрабатываться сервером в соответствии с Resourceprep (Приложение B).</li><li>Клиенту не позволяется привязывать ресурсы к потоку (например, потому, что узел или пользователь достиг предельного числа подключаемых ресурсов).</li><li>Предложенный идентификатор ресурса уже используется, а сервер не разрешает подключения нескольких ресурсов с одинаковыми идентификаторами.</li></ul><p>Протокол обработки условия ошибки представлен ниже.</p><p>Идентификатор ресурса не может быть обработан при условии:</p><pre>&lt;iq type='error' id='bind_2'&gt;
  &lt;bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'&gt;
    &lt;resource&gt;someresource&lt;/resource&gt;
  &lt;/bind&gt;
  &lt;error type='modify'&gt;
    &lt;bad-request xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;
  &lt;/error&gt;
&lt;/iq&gt;</pre><p>Клиент не разрешает подключение ресурса:</p><pre>&lt;iq type='error' id='bind_2'&gt;
  &lt;bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'&gt;
    &lt;resource&gt;someresource&lt;/resource&gt;
  &lt;/bind&gt;
  &lt;error type='cancel'&gt;
    &lt;not-allowed xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;
  &lt;/error&gt;
&lt;/iq&gt;</pre><p>Идентификатор ресурса уже используется:</p><pre>&lt;iq type='error' id='bind_2'&gt;
  &lt;bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'&gt;
    &lt;resource&gt;someresource&lt;/resource&gt;
  &lt;/bind&gt;
  &lt;error type='cancel'&gt;
    &lt;conflict xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;
  &lt;/error&gt;
&lt;/iq&gt;</pre><p>Если, до завершения этапа подключения ресурса клиент попытается послать XML-строфу, отличную от IQ-строфы с дочерним &lt;bind/&gt;, привязанным к пространству имен 'urn:ietf:params:xml:ns:xmpp-bind', сервер не должен обрабатывать строфу и ему следует вернуть клиенту строфу ошибки &lt;not-authorized/&gt;.</p><h2 id="p8">8. Метод сервера Dialback ("обратный дозвон")</h2><h3>8.1. Overview</h3><p>Протоколы Jabber, которые адаптированы для XMPP, были приспособлены к использованию метода сервера "dialback" для защиты от фальсификации домена, таким образом делая сложным фальсификацию XML-строф. Обратный дозвон сервера (dialback) не является механизмом безопасности и связан исключительно со слабыми средствами верификации идентичности сервера (смотри "Коммуникации Сервер-сервер" (раздел 14), где рассмотрены характеристики безопасности этого метода). Домены, требующие надежной безопасности, должны использовать TLS и SASL. Если для аутентификации сервер-сервер используется SASL, обратный дозвон применять не следует (просто бессмысленно).</p><p>Метод обратного дозвона сервера возможен благодаря наличию DNS (Domain Name System), так как сервер может выяснить наличие другого сервера в пределах данного домена. Так как обратный дозвон зависит от DNS, междоменные коммуникации не должны запускаться, пока объекты не будут локализованы с помощью DNS сервера (смотри раздел 14)).</p><p>Обратный дозвон сервера является однонаправленным, по этой причине обеспечивает слабую верификацию идентичности для потока лишь в одном направлении. Так как обратный дозвон сервера не является механизмом аутентификации, двухсторонняя аутентификация здесь невозможна. Следовательно, чтобы реализовать двунаправленный обмен между доменами, обратный дозвон должен быть выполнен для обоих направлений.</p><p>Метод генерации и верификации ключей, используемый в dialback сервером должен учитывать используемые имена машин, идентификатор потока, формируемый сервером-приемником и секретный ключ, известный всем авторизованным в сети серверам. Идентификатор потока является критическим параметром безопасности в процедуре dialback и, следовательно, должен быть непредсказуемым и неповторимым (смотри [RANDOM]).</p><p>Любая ошибка, которая происходит во время согласования dialback должна рассматриваться как ошибка потока, которая приводит к прерыванию потока и разрыву TCP-соединения. Возможные условия ошибки специфицированы ниже в описании протокола.</p><p>Здесь используется следующая терминология:</p><ul><li class="b">Originating Server — исходный сервер</li><li class="lib">сервер, который пытается установить соединение между двумя доменами.</li><li class="b">Receiving Server — принимающий сервер</li><li class="lib">сервер, который пытается проверить, что исходный сервер представляет тот самый домен, который он анонсирует.</li><li class="b">Authoritative Server — управляющий сервер</li><li class="lib">сервер, который отвечает, руководствуясь именем, введенным исходным сервером; для базовой конфигурации это исходный сервер, но может быть и другая машина в сети исходного сервера.</li></ul><h3>8.2. Порядок событий</h3><p>Ниже представлено краткое описание последовательности событий при dialback:</p><ol><li>Исходный сервер устанавливает соединение с принимающим сервером.</li><li>Исходный сервер посылает через соединение значение 'key' принимающему серверу.</li><li>Принимающий сервер устанавливает соединение с управляющим сервером.</li><li>Принимающий сервер посылает этот ключ управляющему серверу.</li><li>Управляющий сервер подтверждает или не подтверждает корректность ключа.</li><li>Принимающий сервер информирует исходный сервер, аутентифицирован он или нет.</li></ol><p>Мы можем представить схему диалога следующим образом:</p><pre>Originating               Receiving
  Server                    Server
-----------               ---------
    |                         |
    |   establish connection  |
    | ----------------------&gt; |
    |                         |
    |   send stream header    |
    | ----------------------&gt; |
    |                         |
    |   send stream header    |
    | &lt;---------------------- |
    |                         |                   Authoritative
    |   send dialback key     |                       Server
    | ----------------------&gt; |                   -------------
    |                         |                         |
                              |   establish connection  |
                              | ----------------------&gt; |
                              |                         |
                              |   send stream header    |
                              | ----------------------&gt; |
                              |                         |
                              |   send stream header    |
                              | &lt;---------------------- |
                              |                         |
                              |   send verify request   |
                              | ----------------------&gt; |
                              |                         |
                              |   send verify response  |
                              | &lt;---------------------- |
                              |
    |  report dialback result |
    | &lt;---------------------- |
    |                         |</pre><h3>8.3. Протокол</h3><p>Протокольное взаимодействие между серверами выглядит следующим образом:</p><ol><li><p>Исходный сервер устанавливает ТСР-соединение с принимающим сервером.</p></li><li><p>Исходный сервер посылает заголовок потока принимающему серверу:</p><pre>&lt;stream:stream
    xmlns:stream='http://etherx.jabber.org/streams'
    xmlns='jabber:server'
    xmlns:db='jabber:server:dialback'&gt;</pre><p class="note">Заметим: атрибуты 'to' и 'from' являются опционными для элемента корневого потока. Включение декларации пространства имен xmlns:db с приведенным именем указывает принимающему серверу, что исходный сервер поддерживает dialback. Если имя пространства имен некорректно, тогда принимающий сервер должен сформировать ошибку потока &lt;invalid-namespace/&gt; и завершить XML-поток, а также разорвать TCP-соединение.</p></li><li><p>Принимающий сервер должен отослать назад заголовок потока исходному серверу, включая уникальный ID этого взаимодействия:</p><pre>&lt;stream:stream
    xmlns:stream='http://etherx.jabber.org/streams'
    xmlns='jabber:server'
    xmlns:db='jabber:server:dialback'
    id='457F9224A0...'&gt;</pre><p class="note">Заметим: Если имя пространства имен некорректно, тогда исходный сервер должен сформировать ошибку потока &lt;invalid-namespace/&gt;, прервать поток и разорвать TCP-соединение. Принимающий сервер должен ответить, но может молча завершить XML-поток, в зависимости от принятой политики безопасности; однако, если принимающий сервер хочет продолжить, он должен послать исходному серверу заголовок потока.</p></li><li><p>Исходный сервер посылает ключ dialback принимающему серверу:</p><pre>&lt;db:result
    to='Receiving Server'
    from='Originating Server'&gt;
  98AF014EDC0...
&lt;/db:result&gt;</pre><p class="note">Замечание: Этот ключ не просматривается принимающим сервером, так как он не хранит информацию об исходном сервере по завершении сессии. Ключ, генерируемый исходным сервером, должен базироваться частично на значении ID, предоставленном принимающим сервером на предыдущем шаге, а также частично на секретном ключе, совместно используемом исходным и управляющим серверами. Если значение адреса 'to' не соответствует имени машины, распознанному принимающим сервером, тогда последний должен генерировать сообщение ошибки потока &lt;host-unknown/&gt; и прерывать XML-поток. Если значение адреса 'from' соответствует домену, с которым принимающий сервер уже установил соединение, тогда он должен поддерживать существующее соединение до тех пор, пока не будет установлено новое соединение. Кроме того, принимающий сервер может сформировать сообщение об ошибке потока &lt;not-authorized/&gt; для нового соединения и затем прервать XML-поток и его TCP-соединение, связанные с новым запросом.</p></li><li><p>Принимающий сервер устанавливает TCP-соединение с доменным именем, представленным исходным сервером, как результ установления соединения с управляющим сервером.</p></li><li><p>Принимающий сервер посылает заголовок потока управляющему серверу:</p><pre>&lt;stream:stream
    xmlns:stream='http://etherx.jabber.org/streams'
    xmlns='jabber:server'
    xmlns:db='jabber:server:dialback'&gt;</pre><p class="note">Замечание: атрибуты 'to' и 'from' являются опционными для элемента корневого потока. Если имя пространства имен некорректно, тогда управляющий сервер должен генерировать сообщение ошибки потока &lt;invalid-namespace/&gt; и прерывать XML-поток и TCP-соединение.</p></li><li><p>Управляющий сервер посылает заголовок потока принимающему серверу:</p><pre>&lt;stream:stream
    xmlns:stream='http://etherx.jabber.org/streams'
    xmlns='jabber:server'
    xmlns:db='jabber:server:dialback'
    id='1251A342B...'&gt;</pre><p class="note">Замечание: Если имя пространства имен некорректно, тогда принимающий сервер должен сформировать сообщение ошибки потока &lt;invalid-namespace/&gt; и прервать XML-поток и соответствующее TCP-соединение между ним и сервером управления. Если ошибка потока случится между принимающим и управляющим серверами, тогда принимающий сервер должен сформировать сообщение об ошибке потока &lt;remote-connection-failed/&gt; и прервать поток и ТСР-соединение с исходным сервером.</p></li><li><p>Принимающий сервер посылает управляющему серверу запрос верификации ключа:</p><pre>&lt;db:verify
    from='Receiving Server'
    to='Originating Server'
    id='457F9224A0...'&gt;
  98AF014EDC0...
&lt;/db:verify&gt;</pre><p class="note">Замечание: Здесь уже получены имена машин, оригинальный идентификатор из заголовка потока принимающего сервера исходному серверу на шаге 3, и ключ, который исходный сервер послал принимающему серверу на шаге 4. На основе этой информации, а также на секретном, совместно используемом ключе сети управляющего сервера ключ верифицируется. Для генерации ключа может использоваться любой метод верификации. Если значение адреса 'to' не соответствует имени машины, выявленному управляющим сервером, тогда управляющий сервер должен сформировать сообщение об ошибке потока &lt;host-unknown/&gt; и разорвать XML-поток и ТСР-соединение. Если значение адреса 'from' не соответствует имени машины, представленному принимающим сервером при открытии TCP-соединения, тогда управляющий сервер должен сформировать ошибку потока &lt;invalid-from/&gt;.</p></li><li><p>Управляющий сервер проверяет, является ли ключ корректным:</p><pre>&lt;db:verify
    from='Originating Server'
    to='Receiving Server'
    type='valid'
    id='457F9224A0...'/&gt;</pre><p>или</p><pre>&lt;db:verify
    from='Originating Server'
    to='Receiving Server'
    type='invalid'
    id='457F9224A0...'/&gt;</pre><p class="note">Замечание: Если ID не соответствует тому, который предложен принимающим сервером на шаге 3, тогда принимающий сервер должен сгенерировать ошибку потока &lt;invalid-id/&gt; и прервать XML-поток и соответствующее TCP-соединение. Если значение адреса 'to' не соответствует имени машины, распознанному принимающим сервером, тогда принимающий сервер должен выработать ошибку потока &lt;host-unknown/&gt; и разорвать TCP-соединение. Если значение адреса 'from' не соответствует имени машины, представленному исходным сервером при открытии TCP-соединения, тогда принимающий сервер должен выработать ошибку потока &lt;invalid-from/&gt; и разорвать TCP-соединение. После возвращения флага верификации принимающему серверу, управляющий сервер должен прервать поток между ними.</p></li><li><p>Принимающий сервер информирует исходный сервер о результате:</p><pre>&lt;db:result
    from='Receiving Server'
    to='Originating Server'
    type='valid'/&gt;</pre><p class="note">Замечание: В этой точке, соединение либо верифицировано type='valid', либо объявлено некорректным. Если соединение некорректно, принимающий сервер должен прервать XML-поток и разорвать TCP-соединение. Если соединение верифицировано, исходный сервер начинает посылать данные, которые читаются принимающим сервером; перед этим все XML-строфы, посланные принимающему серверу должны быть молча отброшены.</p></li></ol><p>Результатом всего предшествующего является то, что принимающий сервер проверил идентичность исходного сервера, таким образом управляющий сервер может посылать, а принимающий сервер принимать XML-строфы через &quot;исходный поток&quot; (т.е., поток от исходного к принимающему серверу). Для того чтобы верифицировать идентичности объектов, используя &quot;поток-отклик&quot; (т.е., поток от принимающего сервера к исходному серверу), должен быть осуществлен также dialback (&quot;обратный дозвон&quot;) в обратном направлении.</p><p>После успешного выполнения процедуры dialback, принимающий сервер должен воспринять последующие пакеты &lt;db:result/&gt; (например, запросы валидации, посланные субдомену или другой машине, обслуживаемой принимающим сервером) от исходного сервера через имеющееся верифицированное соединение.</p><p>Даже если согласование dialback успешно, сервер должен проверить, что все XML-строфы полученные от другого сервера содержат атрибуты 'from' и 'to'; если строфа не следует этому ограничению, сервер, который получает строфу должен сформировать сообщение об ошибке потока &lt;improper-addressing/&gt; и разорвать TCP-соединение. Кроме того, сервер должен проверить, что атрибут 'from' строфы, полученной от другого сервера, содержит верифицированное имя домена для потока; если строфа не отвечает этим ограничениям, сервер, который получает строфу, должен сформировать ошибку потока &lt;invalid-from/&gt; и разорвать соединение.</p><h2 id="p9">9. XML-строфы</h2><p>После согласования применения TLS (раздел 5), SASL (раздел 6) и подключения ресурсов (раздел 7), если требуется, можно начать пересылку через поток XML-строф. Определены три типа XML-строф для пространств имен 'jabber:client' и 'jabber:server': &lt;message/&gt;, &lt;presence/&gt; и &lt;iq/&gt;. Кроме того, существует пять общих атрибутов для трех видов строф. Ниже описаны эти общие атрибуты, так же как базовая семантика трех видов строф, более детальную информацию о синтаксисе XML-строф и их применении можно найти в [XMPP-IM].</p><h3>9.1. Общие атрибуты</h3><p>Следующие пять атрибутов являются общими для сообщений, данных о присутствии и IQ-строф:</p><h4>9.1.1. Атрибут 'to'</h4><p>Атрибут 'to' специфицирует JID получателя строфы.</p><p>В пространстве имен 'jabber:client', строфа должна иметь атрибут 'to', хотя строфа, посланная от клиента серверу, для обработки сервером (например, данные о присутствии, посланные серверу для широковещательной рассылки другим объектам) не должна содержать атрибут 'to'.</p><p>В пространстве имен 'jabber:server' строфа должна иметь атрибут 'to'; если сервер получает строфу, которая не отвечает этим ограничениям, он должен сформировать ошибку потока &lt;improper-addressing/&gt; и разорвать соединение.</p><p>Если значение атрибута 'to' некорректно, объект, выяснивший этот факт, должен вернуть соответствующую ошибку отправителю, установив атрибут 'from' строфы-ошибки равной содержимому атрибуту 'to' исходной строфы.</p><h4>9.1.2. Атрибут 'from'</h4><p>Атрибут 'from' специфицирует JID отправителя.</p><p>Когда сервер получает XML-строфа в контексте аутентифицированного потока, сопряженного с пространством имен 'jabber:client', он должен сделать следующее:</p><ol><li>проверить, что значение атрибута 'from', предложенное клиентом, соответствует подключенному ресурсу для ассоциированного объекта</li><li>добавить адрес 'from' к строфе, чье значение равно чистому JID (&lt;node@domain&gt;) или полный JID (&lt;node@domain/resource&gt;), определенный сервером для подключенного ресурса, который сформировал строфу (смотри "Определение адресов" (раздел 3))</li></ol><p>Если клиент пытается послать XML-строфу, для которой значение атрибута 'from' не соответствует одному из подключенных ресурсов для данного объекта, сервер должен прислать клиенту ошибку потока &lt;invalid-from/&gt;. Если клиент пытается послать XML-строфу через поток, который еще не аутентифицирован, сервер должен вернуть клиенту ошибку потока &lt;not-authorized/&gt;. Если имеют место оба эти условия, со соединение прерывается. Это помогает исключить атаку отказа в обслуживании, запущенную недобросовестным клиентом.</p><p>Когда сервер генерирует строфу от своего имени для доставки подключенному клиенту (например, в контексте сервиса памяти, предоставляемого сервером клиенту), строфа либо не должна включать в себя атрибут 'from' либо включать атрибут 'from', чье значение является чистым JID аккоунта (&lt;node@domain&gt;) или полным JID клиента (&lt;node@domain/resource&gt;). Сервер не должен посылать клиенту строфу без атрибута 'from', если строфа не была сформирована самим сервером. Когда клиент получает строфу, которая не содержит атрибута 'from', он должен полагать, что строфа пришла от сервера, с которым клиент соединен.</p><p>В пространстве имен 'jabber:server', строфа должна иметь атрибут 'from'; если сервер получает строфу, которая не отвечает этому ограничению, он должен генерировать ошибку потока &lt;improper-addressing/&gt;. Кроме того, секция доменного идентификатора JID, содержащаяся в атрибуте 'from', должна соответствовать имени машины отправляющего сервера (или любой проверенный домен, такой как субдомен сервера-отправителя). Если сервер получает строфу, которая не отвечает этому ограничению, он должен сформировать сообщение об ошибке &lt;invalid-from/&gt;.</p><h4>9.1.3. Атрибут 'id'</h4><p>Опционный атрибут 'id' может использоваться объектом-отправителем для внутреннего отслеживания строф, которые он отправляет и получает (в частности для отслеживания взаимодействий типа запрос-отклик, типичных для семантики IQ-строф). Для атрибута 'id' глобальная уникальность является опционной в рамках домена или потока.</p><h4>9.1.3. Атрибут 'type'</h4><p>Атрибут 'type' специфицирует данные о целях или контексте сообщения, данные о присутствии или IQ-строфы. Конкретные допустимые значения атрибута 'type' сильно зависят от того, является ли строфа сообщением, данными о присутствии или IQ. Значения для строф сообщений и данных о присутствии являющиеся специфичными для технологии сообщений реального времени, они описаны в [XMPP-IM], тогда как значения для IQ-строф специфицируют роль IQ-строф в структурированном диалоге запрос-отклик (раздел 9). Единственным общим для всех трех типов строф является ошибка; смотри "Ошибки строф" (раздел 9).</p><h4>9.1.5. Атрибут 'xml:lang'</h4><p>Строфа должна иметь атрибут 'xml:lang' (как это описано в разделе 2.12 [XML]), если строфа содержит символьные данные, которые предназначены для обычного пользователя-человека (как описано в RFC 2277 [CHARSET], "Интернационализация для людей"). Значение атрибут 'xml:lang' специфицирует язык по умолчанию любых символьных данных, которое может быть переписано атрибутом 'xml:lang' дочернего элемента. Если строфа не имеет атрибута 'xml:lang', реализация должна предполагать, что действует значение языка по умолчанию, специфицированное для потока, как это определено выше в раздел 4. Значение атрибута 'xml:lang' должно быть NMTOKEN и должно соответствовать формату, определенному в RFC 3066 [LANGTAGS].</p><h3>9.2. Базовая семантика</h3><h4>9.2.1. Семантика сообщений</h4><p>Тип строф &lt;message/&gt; можно рассматривать как "push"-механизм, поскольку один объект "проталкивает" информацию другому объекту, подобно коммуникациям, которые осуществляются в системах типа электронной почты. Все строфы сообщений имеют атрибут 'to', который специфицирует получателя сообщения. После получения такой строфы сервер должен переадресовать или доставить ее адресату (смотри "Серверные правила для обработки XML-строф" (раздел 10)).</p><h4>9.2.2. Семантика присутствия</h4><p>Элемент &lt;presence/&gt; может рассматриваться как механизм широковещательного уведомления, посредством чего многие объекты получают информацию об объекте, на которую они подписались (в данном случае информация о доступности сети). Вообще, уведомляющий объект должен послать строфу присутствия без атрибута 'to', серверу, который должен широковещательно переслать ее всем объектам-подписчикам. Однако уведомляющий объект может также послать строфу присутствия с атрибутом 'to', в этом случае сервер должен обеспечить доставку строфы конкретному адресату. Общие правила переадресации и доставки строф смотри в главе "Серверные правила обработки XML-строф" (раздел 10) и в [XMPP-IM].</p><h4>9.2.3. Семантика IQ</h4><p>Info/Query, или IQ, представляет собой механизм запросов-откликов, сходный в некотором роде с [HTTP]. Семантика IQ делает возможными для объекта отправку запросов и получение откликов другого объекта. Информационное содержание запроса и отклика определяется декларацией пространства имен дочернего объекта IQ-элемента, а диалог отслеживается запрашивающим объектом с помощью атрибута 'id'. Таким образом, за стандартным обменом структурированными данными, такими как get/result или set/result следует IQ-диалог (хотя в отклике на запрос при определенных условиях может быть прислано сообщение об ошибке):</p><pre>Requesting                 Responding
  Entity                     Entity
----------                 ----------
    |                           |
    | &lt;iq type='get' id='1'&gt;    |
    | ------------------------&gt; |
    |                           |
    | &lt;iq type='result' id='1'&gt; |
    | &lt;------------------------ |
    |                           |
    | &lt;iq type='set' id='2'&gt;    |
    | ------------------------&gt; |
    |                           |
    | &lt;iq type='error' id='2'&gt;  |
    | &lt;------------------------ |
    |                           |</pre><p>Для того чтобы усилить данную семантику, применены следующие правила:</p><ol><li><p>Для IQ-строф необходим атрибут 'id'.</p></li><li><p>Для IQ-строф необходим атрибут 'type'. Значение должно быть из числа перечисленных ниже.</p><ul><li class="b">get</li><li class="lia">строфа является запросом информации или требований.</li><li class="b">set</li><li class="lia">строфа предоставляет необходимые данные, устанавливает новые значения или замещает существующие величины.</li><li class="b">result</li><li class="lia">строфа является откликом на успешный запрос get или set.</li><li class="b">error</li><li class="lia">произошла ошибка, связанная с обработкой или доставкой выданной перед этим строфы (get или set). (смотри "Строфы ошибок" (раздел 9)).</li></ul></li><li><p>Объект, который получает IQ-запрос типа "get" или "set" должен ответит IQ-откликом типа "result" или "error" (отклик должен сохранить атрибут 'id' запроса).</p></li><li><p>Объект, который получает строфу типа "result" или "error" не должен откликаться на строфу посылкой следующего IQ-отклика типа "result" или "error"; однако, как показано выше, запрашивающий объект может послать еще один запрос (например, IQ типа "set" для того чтобы предоставить нужную информацию, выявленную в результате обмена get/result).</p></li><li><p>IQ-строфа типа "get" или "set" должна содержать один и только один дочерний элемент, который специфицирует семантику конкретного запроса или отклика.</p></li><li><p>IQ-строфа типа "result" должна содержать нуль или один дочерний элемент.</p></li><li><p>IQ-строфа типа "error" должна содержать дочерний элемент, содержащийся в соответствующем "get" или "set" и должна включать в себя дочерний элемент &lt;error/&gt;. Подробности смотри в главе "ошибки строф" (раздел 9).</p></li></ol><h3>9.3. Ошибки строф</h3><p>Ошибки, сопряженные со строфами обрабатываются аналогично ошибкам потока (раздел 4). Однако, в отличии от ошибок потока, ошибки строф являются исправимыми; следовательно ошибки строф содержат намеки на действия, которые следует предпринять исходному отправителю, для того чтобы исправить ошибку.</p><h4>9.3.1. Правила</h4><p>В отношении ошибок, связанных со строфами, используются следующие правила:</p><ul class="dot"><li><p>Принимающий или обрабатывающий объект, который детектирует состояние ошибки в отношении строфы, должен прислать отправителю строфу того же сорта (сообщение, присутствие или IQ), чей атрибут 'type' установлен равным "error" (такая строфа называется "строфой ошибки").</p></li><li><p>Объект, который генерирует строфу ошибки должен включить исходный посланный XML, так чтобы отправитель мог проверить, если необходимо, корректность XML, прежде чем предпринимать попытку повторной передачи.</p></li><li><p>Строфа-ошибка должна содержать дочерний элемент &lt;error/&gt;.</p></li><li><p>Дочерний элемент &lt;error/&gt; не должен включаться, если атрибут 'type' имеет значение, отличное от "error" (или если атрибута 'type' нет вообще).</p></li><li><p>Объект, который получает ошибку строфы, не должен реагировать на строфу с еще одной ошибкой; это предотвращает зацикливание.</p></li></ul><h4>9.3.2. Синтаксис</h4><pre>&lt;stanza-kind to='sender' type='error'&gt;
  [RECOMMENDED to include sender XML here]
  &lt;error type='error-type'&gt;
    &lt;defined-condition xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;
    &lt;text xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'
          xml:lang='langcode'&gt;
      OPTIONAL descriptive text
    &lt;/text&gt;
    [OPTIONAL application-specific condition element]
  &lt;/error&gt;
&lt;/stanza-kind&gt;</pre><p>Вид строфы может принимать значение message (сообщение), presence (присутствие) или iq.</p><p>Значение элемента &lt;error/&gt; атрибута 'type' должно принимать одно из следующих значений:</p><ul><li class="b">cancel</li><li class="lib">не предпринимать повторных попыток (ошибка неисправима)</li><li class="b">continue</li><li class="lib">продолжать (это всего лишь предупреждение)</li><li class="b">modify</li><li class="lib">повторить попытку после изменения посылаемых данных</li><li class="b">auth</li><li class="lib">повторить попытку после изменения параметров авторизации</li><li class="b">wait</li><li class="lib">повторить поытку после выдержки (ошибка является временной)</li></ul><p>Элемент &lt;error/&gt;:</p><ul class="dot"><li><p>должен содержать дочерний элемент, соответствующий одному из условий, специфицированных ниже; этот элемент должен соотноститься с пространством имен 'urn:ietf:params:xml:ns:xmpp-stanzas'.</p></li><li><p>Может содержать дочерний элемент &lt;text/&gt;, который несет в себе символьные XML-данные, которые описывают ошибку более детально. Этот элемент должен соотноситься с пространством имен 'urn:ietf:params:xml:ns:xmpp-stanzas' и должен иметь атрибут 'xml:lang'.</p></li><li><p>Может содержать дочерний элемент для ошибок, специфических для приложения; этот элемент должен соотноситься с пространством имен приложения, а его структура определяется этим пространством имен.</p></li></ul><p>Элемент &lt;text/&gt; является опционным. Когда включается, он должен использоваться только для передачи описательной и диагностической информации, которая является дополнительной и служит для пояснения специфических условий приложения. Он не должен интерпретироваться приложением программно. Он не должен использоваться в качестве сообщения об ошибке пользователю.</p><p>Наконец, для обеспечения обратной совместимости, схема (специфицированная в [XMPP-IM]) позволяет опционное включение атрибута 'code' элемента &lt;error/&gt;.</p><h4>9.3.3. Определенные условия</h4><p>Определены следующие условия использования ошибок строф.</p><ul><li class="b">&lt;bad-request/&gt;</li><li class="lib">отправитель послал XML с некорректным форматом или который не может быть обработан (например, IQ-строфа, которая включает в себя нераспознаваемое значение атрибут 'type'); сопряженным типом ошибки должен быть &quot;modify&quot;.</li><li class="b">&lt;conflict/&gt;</li><li class="lib">доступ не может быть предоставлен, так как существует ресурс или сессия с тем же именем или адресом; сопряженным типом ошибки должен быть &quot;cancel&quot;.</li><li class="b">&lt;feature-not-implemented/&gt;</li><li class="lib">запрошенная возможность не реализуется получателем или сервером и, следовательно, не может быть осуществлена; сопряженным типом ошибки должен быть &quot;cancel&quot;.</li><li class="b">&lt;forbidden/&gt;</li><li class="lib">запрошенный объект не имеет требующегося разрешения для выполнения данного действия; cопряженным типом ошибки должен быть &quot;auth&quot;.</li><li class="b">&lt;gone/&gt;</li><li class="lib">получатель или сервер не может более контактировать с этим адресом (строфа ошибки может содержать новый адрес в виде символьных XML-данных элемента &lt;gone/&gt;); cопряженным типом ошибки должен быть &quot;modify&quot;.</li><li class="b">&lt;internal-server-error/&gt;</li><li class="lib">сервер не может обработать строфу, из-за неверной конфигурации или неопределенной внутренней ошибки сервера; cопряженным типом ошибки должен быть &quot;wait&quot;.</li><li class="b">&lt;item-not-found/&gt;</li><li class="lib">адресованный JID или запрошенный элемент не может быть найден; cопряженным типом ошибки должен быть &quot;cancel&quot;.</li><li class="b">&lt;jid-malformed/&gt;</li><li class="lib">посылающий объект предоставил или переслал XMPP-адрес (например, значение атрибута 'to' ) или нечто в этом же роде (например, идентификатор ресурса), который не стыкуется с синтаксисом, определенным в главе &quot;Схема адресации&quot; (раздел 3); cопряженным типом ошибки должен быть &quot;modify&quot;.</li><li class="b">&lt;not-acceptable/&gt;</li><li class="lib">получатель или сервер понимает запрос, но отказывается обрабатывать его, так как он не отвечает критериям, определенным получателем или сервером (например, локальная политика в отношении приемлемых слов в сообщениях); cопряженным типом ошибки должен быть &quot;modify&quot;.</li><li class="b">&lt;not-allowed/&gt;</li><li class="lib">получатель или сервер не позволяют любому объекту выполнять операцию; cопряженным типом ошибки должен быть &quot;cancel&quot;.</li><li class="b">&lt;not-authorized/&gt;</li><li class="lib">отправитель должен предоставить правильные параметры авторизации, прежде чем ему будет позволено выполнить соответствующеие действия, или он выдал неверные параметры авторизации; cопряженным типом ошибки должен быть &quot;auth&quot;.</li><li class="b">&lt;payment-required/&gt;</li><li class="lib">запрашивающий объект не авторизован для доступа к запрашиваему сервису, так как требуется оплата; cопряженным типом ошибки должен быть &quot;auth&quot;.</li><li class="b">&lt;recipient-unavailable/&gt;</li><li class="lib">адресат временно недоступен; cопряженным типом ошибки должен быть &quot;wait&quot; (заметим: приложение не должно возвращать эту ошибку, если, делая это, выдаст информацию о сетевой доступности адресата объекту, неавторизованному для получения такой информации).</li><li class="b">&lt;redirect/&gt;</li><li class="lib">получатель или сервер переадресуют запрос для этой информации другому объекту, обычно временно (ошибочная строфа должна содержать альтернативный адрес, который должен быть корректным JID, в текстовом элементе &lt;redirect/&gt; ); cопряженным типом ошибки должен быть &quot;modify&quot;.</li><li class="b">&lt;registration-required/&gt;</li><li class="lib">запрашиваемый объект не авторизован для доступа к запрошенному сервису, так как требуется регистрация; cопряженным типом ошибки должен быть &quot;auth&quot;.</li><li class="b">&lt;remote-server-not-found/&gt;</li><li class="lib">удаленный сервер или сервис, специфицированный в качестве части или всего JID получателя, не существует; cопряженным типом ошибки должен быть &quot;cancel&quot;.</li><li class="b">&lt;remote-server-timeout/&gt;</li><li class="lib">удаленный сервер или сервис, специфицированный в качестве части или всго JID получателя, не досягаемы в пределах разумного времени; cопряженным типом ошибки должен быть &quot;wait&quot;.</li><li class="b">&lt;resource-constraint/&gt;</li><li class="lib">получатель или сервер имеют мало системных ресурсов для обслуживания запроса; cопряженным типом ошибки должен быть &quot;wait&quot;.</li><li class="b">&lt;service-unavailable/&gt;</li><li class="lib">получатель или сервер в настоящее время не предоставляют запрашиваемого сервиса; cопряженным типом ошибки должен быть &quot;cancel&quot;.</li><li class="b">&lt;subscription-required/&gt;</li><li class="lib">запрашиваемый объект не авторизован для доступа к запрашиваемого сервиса, так как требуется подписка; cопряженным типом ошибки должен быть &quot;auth&quot;.</li><li class="b">&lt;undefined-condition/&gt;</li><li class="lib">условие ошибки не совпадает ни с одним, описанным в этом перчне; любой тип ошибки может быть ассоциирован с этим условием, и это условие может использоваться только совместно с условием, специфичным для приложения.</li><li class="b">&lt;unexpected-request/&gt;</li><li class="lib">получатель или сервер понимают запрос, но не ожидали его в данный момент; cопряженным типом ошибки должен быть &quot;wait&quot;.</li></ul><h4>9.3.4. Условия специфические для приложения</h4><p>Как было замечено, приложение может выдавать специфическую информацию строф ошибок путем включения дочернего элемента ошибки, соответственно привязанного к пространству имен. Специфический элемент приложения должен дополнять или прояснять определенный элемент ошибки. Таким образом, элемент &lt;error/&gt; будет содержать два или три дочерних элемента:</p><pre>&lt;iq type='error' id='some-id'&gt;
  &lt;error type='modify'&gt;
    &lt;bad-request xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;
    &lt;too-many-parameters xmlns='application-ns'/&gt;
  &lt;/error&gt;
&lt;/iq&gt;

&lt;message type='error' id='another-id'&gt;
  &lt;error type='modify'&gt;
    &lt;undefined-condition
          xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;
    &lt;text xml:lang='en'
          xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'&gt;
      Some special application diagnostic information...
    &lt;/text&gt;
    &lt;special-application-condition xmlns='application-ns'/&gt;
  &lt;/error&gt;
&lt;/message&gt;</pre><h2 id="p10">10. Правила сервера для обработки XML-строф</h2><p>Адаптивные реализации сервера должны гарантировать надлежащую обработку XML-строф между любыми двумя объектами.</p><p>За пределами требований нормальной обработки реализация каждого сервера будет содержать свои собственные "деревья доставки" для обслуживания приходящих к ним строф. Такое дерево определяет, нуждается ли строфа в переадресации в другой домен, будет ли обработана локально или доставлена ресурсу, сопряженному с соседним узлом. Здесь используются следующие правила:</p><h3>10.1. Нет адреса 'to'</h3><p>Если строфа не имеет атрибута 'to', сервер должен обработать ее для объекта, ее пославшего. Так как все строфы, полученные от других серверов, должны иметь атрибут 'to', это правило приложимо только к строфам, полученных от зарегистрированных объектов (таких как клиент), т.е. подключенных к серверу. Если сервер получает строфу присутствия без атрибута 'to', сервер должен послать ее широковещательно объектам, которые подписаны на посылку данных присутствия, если это возможно (семантика широковещательных данных для обмена сообщениями и данными присутствия определена в [XMPP-IM]). Если сервер получает IQ-строфу типа "get" или "set" без атрибута 'to' и он понимает пространство имен, которое соотнесено с содержимым строфы, он должен либо обработать строфу от имени отправителя (где под словом "обработать" подразумевается семантика соответствующего пространства имен) или прислать отпраителю сообщение об ошибке</p><h3>10.2. Чужой домен</h3><p>Если имя машины секции идентификатора домена JID содержит атрибут 'to', который не согласуется со сконфигурированными именами самого сервера или субдомена, сервер должен переадресовать строфу внешнему домену. Возможны два случая:</p><p>Между двумя доменами уже имеется поток сервер-сервер: существуют маршруты строф сервера к управляющему серверу для внешнего домена через существующий поток.</p><p>Между двумя доменами не существует потока сервер-сервер:</p><ol><li>выясняет имя машины для внешнего домена (как это определено для коммуникаций сервер-сервер (раздел 14)),</li><li>согласует поток сервер-сервер между двумя доменами (как это определено для применения TLS (раздел 5) и использует SASL (раздел 6)), и</li><li>переадресует строфу управляющему серверу для внешнего домена через вновь созданный поток.</li></ol><p>Если маршрутизация до сервера получателя не удалась, сервер должен прислать сообщение об ошибке отправителю; если сервер получателя достижим, но доставка строфы сервером получателя невозможна, сервер получателя должен прислать сообщение ошибки отправителю.</p><h3>10.3. Субдомен</h3><p>Если имя машины секции идентификатора домена JID, содержащегося в атрибуте 'to', соответствует субдомену одного из сконфигурированных имен самого сервера, сервер должен либо обработать строфу сам, либо переадресовать ее специализированному сервису, который ответственен за субдомен (если субдомен сконфигурирован), или послать уведомление об ошибке отправителю (если субдомен не сконфигурирован).</p><h3>10.4. Полный домен или специфические ресурсы</h3><p>Если имя машины секции идентификатора домена JID, содержащегося в атрибуте 'to', соответствует сконфигурированному имени самого сервера, а JID, содержащий атрибут 'to', имеет формат &lt;domain&gt; или &lt;domain/resource&gt;, сервер (или определенный ресурс) должен либо обрабатывать строфу или возвращать отправителю ошибку.</p><h3>10.5. Узел в том же домене</h3><p>Если имя машины секции идентификатора домена JID, содержащееся в атрибуте 'to', соответствует субдомену одного из сконфигурированных имен самого сервера, а JID, содержащий атрибут 'to', имеет формат &lt;node@domain&gt; или &lt;node@domain/resource&gt;, сервер должен доставить строфу адресату строфы, согласно JID, содержащемуся в атрибуте 'to'. Используются следующие правила:</p><ol><li><p>Если JID содержит идентификатор ресурса (т.е., имеет форму &lt;node@domain/resource&gt;) и существует подключенный ресурс, который соответствует полному JID, сервер получателя должен вставить строфу в поток или сессию, которая соответствует идентификатору ресурса.</p></li><li><p>Если JID содержит идентификатор ресурса и не существует подключенного ресурса, который соответствует полному JID, сервер получателя должен прислать отправителю ошибку строфы &lt;service-unavailable/&gt;.</p></li><li><p>Если JID имеет формат &lt;node@domain&gt; и в узле существует, по крайней мере, один подключенный ресурс, сервер получателя должен доставить строфу одному из подключенных ресурсов, согласно правилам приложения (набор правил доставки сообщения и данных о положении определен в [XMPP-IM]).</p></li></ol><h2 id="p11">11. Использование XML в XMPP</h2><h3>11.1. Ограничения</h3><p>XMPP является упрощенным и специализированным протоколом для потоковых элементов XML, для того чтобы обмениваться структурированной информацией в режиме близком к реальному времени. Так как XMPP не требует парсинга произвольных XML-документов, не существует никаких требований, которые должен поддерживать XMPP [XML]. В частности, используются следующие ограничения.</p><p>Что касается XML-генерации, XMPP-реализации не должны вводить в XML-поток следующие вещи:</p><ul class="dot"><li>комментарии (как это определено в разделе 2 [XML])</li><li>инструкции обработки (раздел 2)</li><li>внутренние или внешние DTD-субнаборы (раздел 2)</li><li>внутренние или внешние ссылки на объекты (раздел 4) за исключением заранее определенных сущностей (раздел 4)</li><li>символьные данные или значения атрибута, содержащие символы без эскэйпов, которые могут указывать на предопределенные объекты (раздел 4); следует избегать использования таких символов</li></ul><p>С учетом XML-обработки, если XMPP-реализация получает такие запрещенные данные, она должна их игнорировать.</p><h3>11.2. Имена XML-пространства имен и префиксов</h3><p>Пространство имен XML [XML-NAMES] используется в рамках XMPP-подобных XML, чтобы сформировать четкие границы принадлежности данных. Основной функцией пространства имен является разделение различных словарей XML-элементов, которые структурно перемешаны. Гарантия того, что XMPP-подобные XML знакомы с пространством имен, делает возможным структурное перемешивание любых допустимых XML с любыми элементами данных в рамках XMPP. Правила для пространства имен XML и префиксов определены в следующих подразделах.</p><h4>11.2.1. Пространство имен потоков</h4><p>Декларацией пространства имен потока для всех заголовков XML-потока является обязательной. Имя пространства имен потока должно быть 'http://etherx.jabber.org/streams'. Элемент имен элемента &lt;stream/&gt; и его дочерних элементов &lt;features/&gt; и &lt;error/&gt; должны быть заданы во всех случаях префиксом пространства имен потоков. Реализация должна генерировать для этих элементов только префикс 'stream:'.</p><h4>11.2.2. Пространство имен по умолчанию</h4><p>Декларациея пространства имен по умолчанию является обязательной, она используется во всех XML-потоках, для того чтобы определить для корневого потока допустимые дочерние элементы первого уровня. Эта декларация пространства имен должна быть идентичной для исходного потока и для потока-отклика, так чтобы оба потока были совместимыми. Декларация пространства имен по умолчанию применяется для потока и всех строф, посланных в рамках потока.</p><p>Реализация сервера должна поддерживать следующие два пространства имен по умолчанию:</p><ul><li class="b">jabber:client</li><li class="lib">это пространство имен по умолчанию декларируется, когда поток используется для коммуникаций между клиентом и сервером.</li><li class="b">jabber:server</li><li class="lib">это пространство имен по умолчанию декларируется, когда поток используется для коммуникаций между двумя серверами.</li></ul><p>Реализация клиента должна поддерживать пространство имен по умолчанию 'jabber:client'.</p><p>Реализация не должна генерировать префиксы пространства имен для элементов в пространстве имен по умолчанию, если это пространство имен 'jabber:client' или 'jabber:server'. Реализация не должна генерировать префиксов пространства имен для элементов, квалифицируемых по содержанию (в противоположность потоку) пространства имен, отличного от 'jabber:client' и 'jabber:server'.</p><p class="note">Замечание: Пространства имен 'jabber:client' и 'jabber:server' являются почти идентичными, но используются в различных контекстах (коммуникации клиент-сервер для 'jabber:client' и коммуникации сервер-сервер для 'jabber:server'). Единственное отличие между ними заключается в том, что атрибуты 'to' и 'from' являются опционными для строф, посланных в рамках 'jabber:client', в то время как они обязательны для строф, посланных в рамках 'jabber:server'. Если реализация принимает поток, который соотносится с пространствами имен 'jabber:client' или 'jabber:server', она должна поддерживать общие атрибуты (раздел 9) и базовую семантику (раздел 9) всех трех главных видов строф (сообщение, присутствие и IQ).</p><h4>11.2.3. Пространство имен Dialback</h4><p>Декларация пространства имен dialback является обязательной для всех элементов, используемых в серверном dialback (раздел 8). Имя пространства имен dialback должно быть 'jabber:server:dialback'. Все элементы, соотнесенные с этим пространством имен, должны иметь префикс. Реализация должна генерировать для таких элементов только префикс 'db:' и может воспринимать только префикс 'db:'.</p><h3>11.3. Валидация</h3><p>За исключением, как отмечено в отношении адресов 'to' и 'from' для строф из пространства имен 'jabber:server', сервер не несет ответственности за валидацию XML-элементов, переадресуемых клиенту или другому серверу. Конкретная реализация может решить предоставлять только проверенные информационные элементы, но это является опционным (хотя реализация не должна воспринимать XML, которые плохо сформатированы). Клиенты не должны полагаться на возможность посылки данных, неследующих заданным формам, и должны игнорировать любые нестандартные элементы или атрибуты во входном XML-потоке. Валидация XML-потоков и строф является опционной.</p><h3>11.4. Включение текстовых деклараций</h3><p>Реализации должны посылать текстовые декларации до посылки заголовка потока. Приложения должны следовать правилам из [XML], в зависимости от обстоятельств, при которых включается текстовая декларация.</p><h3>11.5. Кодирование символов</h3><p>Реализации должны поддерживать UTF-8 (RFC 3629 [UTF-8]) преобразования универсального символьного набора (ISO/IEC 10646-1 [UCS2]), как этого требует RFC 2277 [CHARSET]. Реализации не должны пытаться использовать любые другие виды кодирования.</p><h2 id="p12">12. Основные требования совместимости</h2><p>Этот раздел суммирует специфические аспекты протокола XMPP, которые должны поддерживаться серверами и клиентами, для того чтобы быть совместимыми. Для целей совместимости мы проводим различие между базовыми протоколами (которые должны поддерживаться любым сервером или клиентом, вне зависимости от специфичности приложений) и протокола отправки сообщений в реальном масштабе времени (IM) (которые должны поддерживаться IM и приложениями присутствия, работающими поверх базовых протоколов). Требования совместимости, которые приложимы ко всем серверам и клиентам, специфицированы ниже. Требования совместимости для IM серверов и клиентов описаны в разделе [XMPP-IM].</p><h3>12.1. Серверы</h3><p>В дополнение ко всем определенным требованиям с учетом безопасности сервер должен поддерживать следующие базовые протоколы:</p><ul class="dot"><li>Применение профайлов [NAMEPREP], Nodeprep (Приложение A) и Resourceprep (Приложение B) [STRINGPREP] к адресам (включая гарантию того, что идентификаторы доменов являются международными доменными именами, как это определено в [IDNA])</li><li>XML-потоки (раздел 4), включая использование TLS (раздел 5), использование SASL (раздел 6) и подключение ресурсов (раздел 7)</li><li>Базовая семантика трех основных видов строф (т.е., &lt;message/&gt;, &lt;presence/&gt; и &lt;iq/&gt;), как это определено в разделе 9</li><li>Генерация синтаксиса ошибок и семантик, относящаяся к потокам, TLS, SASL и XML-строфам</li></ul><p>Кроме того сервер может поддерживать серверный dialback (раздел 8).</p><h3>12.2. Клиенты</h3><p>Клиент должен поддерживать следующие базовые протоколы, чтобы считаться адекватным:</p><ul class="dot"><li>XML-потоки (раздел 4), включая использование TLS (раздел 5), использование SASL (раздел 6) и подключение ресурсов (раздел 7)</li><li>Базовая семаника трех определенных видов строф (т.е., &lt;message/&gt;, &lt;presence/&gt; и &lt;iq/&gt;), как это специфицировано в семантике строф (раздел 9)</li><li>Обработка (и, где возможно, генерация) синтаксиса ошибок и семантики, сопряженной с потоками, TLS, SASL и XML-строфами.</li></ul><p>Кроме того, клиент должен поддерживать следующие базовые протоколы:</p><ul class="dot"><li>Генерация адресов, в которых профайлы [NAMEPREP], Nodeprep (Приложение A), и Resourceprep (Приложение B) [STRINGPREP] могут успешно работать</li></ul><h2 id="p13">13. Соображения интернационализации</h2><p>XML-потоки должны кодироваться в UTF-8, как это специфицировано в главе "Кодирование символов" (раздел 11). Согласно описанию атрибутов потока (раздел 4), XML-поток должен содержать атрибут 'xml:lang', значение которого рассматривается как язык по умолчанию для любых символьных XML-данных, пересылаемых через поток, который предназначен для восприятия человеком. Как это специфицировано в xml:lang (раздел 9), XML-строфа должна включать в себя атрибут 'xml:lang', если строфа содержит символьные XML-данные, которые предназначены пользователю-человеку. Сервер должен использовать значение атрибута 'xml:lang' по умолчанию для строф, которые он переадресовывает или доставляет одному из подключенных объектов, и не должен модифицировать или удалять атрибуты 'xml:lang' из строф, которые он получает от других объектов.</p><h2 id="p14">14. Соображения безопасности</h2><h3>14.1. Высокая безопасность</h3><p>Для целей XMPP-коммуникаций (клиент-сервер и сервер-сервер), термин "Высокая безопасность" относится к использованию технологий безопасности, которые обеспечивают как взаимную аутентификацию, так и проверку целостности; в частности, когда для гарантии безопасности используется аутентификация, основанная на применении сертификатов, цепочка проверки должна использовать свои маршруты. В отношении процедуры проверки сертификатов смотри раздел 14 ниже.</p><p>Реализации должны поддерживать высокую безопасность. Предоставление услуг должно предполагать применение высокой безопасности.</p><h3>14.2. Валидация сертификатов</h3><p>Когда XMPP-партнер осуществляет связь с другим объектом безопасным образом, он должен проверить сертификат партнера.</p><p>Существует три возможных варианта:</p><ul><li>Случай #1: Партнер имеет сертификат оконечного объекта, который оказывается сертифицирован цепочкой сертификатов (как описано в разделе 6.1 [X509]).</li><li>Случай #2: Сертификат партнера подтвержден центром сертификации, неизвестным проверяющему партнеру.</li><li>Случай #3: Сертификат партнера подписан им самим.</li></ul><p>В случае #1, осуществляющий валидацию партнер должен выполнить одну из двух вещей:</p><ol><li><p>Верифицировать сертификат партнера согласно правилам [X509]. Сертификат должен быть затем проверен на предмет ожидаемой идентичности партнера согласно правил из [HTTP-TLS], за исключением того, что для идентификации партнера должно использоваться расширение subjectAltName типа "xmpp" (если имеется). Если одна из этих проверок не прошла, клиенты, ориентированные на пользователя, должны либо уведомить пользователя (клиенты в любом случае могут дать возможность пользователю сохранить соединение) или разорвать соединение с "неисправимой ошибкой сертификата". Автоматические клиенты должны разорвать соединение и сделать запись в соответствующий журнальный файл. Автоматические клиенты могут предоставить конфигурационные установки, которые блокируют эту проверку, но должны предоставить возможность ее восстановления.</p></li><li><p>Партнер должен предъявить сертификат пользователю для одобрения, включая всю сертификационную цепочку. Партнер должен кэшировать сертификат (или некоторую неподделываемую презентацию сертификата типа хэша). При будущих соединениях партнер должен верифицировать факт идентичности предъявляемого сертификата и уведомлять пользователя, если он изменился.</p></li></ol><p>В случае #2 и #3, реализации должны действовать как в (2) выше.</p><h3>14.3. Коммуникации клиент-сервер</h3><p>Совместимые клиентские реализации должны поддерживать для подключения сервера как TLS, так и SASL.</p><p>Протокол TLS для криптографического преобразования XML-потоков (определенного в рамках использования TLS (раздел 5)) предоставляет надежный механизм гарантирования конфиденциальности и целостности данных, пересылаемых между двумя объектами.</p><p>Протокол SASL для аутентификации XML-потоков (определено в главе "Использование SASL" (раздел 6)) предоставляет надежный механизм валидации того, что клиент, подключенный к серверу, является тем, за кого он себя выдает.</p><p>Коммуникации клиент-сервер не должны осуществляться, до тех пор пока имя машины, представленное сервером не будет выявлено. Такие процедуры сначала должны пытаться выяснить имя машины, используя сервис [SRV] "xmpp-client" и протокол "tcp", получая в результате рекорды типа "_xmpp-client._tcp.example.com." (использование строки "xmpp-client" для идентификатора сервиса согласуется с регламентациями IANA). Если SRV lookup терпит неудачу, методом решения проблемы будет выявление IPv4/IPv6-адресов, используя "xmpp-client" порт 5222, стандартизованный IANA.</p><p>IP-адрес и метод доступа к клиенту не должны делаться сервером публично доступными. Это помогает защитить сервер клиента от прямой атаки.</p><h3>14.4. Коммуникации сервер-сервер</h3><p>Совместимые реализации сервера должны для междоменных коммуникаций поддерживать как TLS, так и SASL. По историческим причинам, совместимые реализации сервера должны поддерживать Dialback (раздел 8).</p><p>Так как предоставление услуг является вопросом политики, коммуникации с другими доменами являются опционным для любого выбранного домена, и коммуникации сервер-сервер могут быть запрещены администратором. Если конкретному домену разрешены междоменные коммуникации, он должен обеспечивать высокий уровень безопасности.</p><p>Администраторы могут потребовать для коммуникаций сервер-сервер использования SASL, для того чтобы гарантировать как аутентификацию, так и конфиденциальность. По этой причине совместимые реализации должны поддерживать SASL.</p><p>Междоменные соединения не должны функционировать до тех пор, пока имена машин, предоставленные сервером, не были идентифицированы. Такая процедура для получения ресурсных записей "_xmpp-server._tcp.example.com." должна сначала воспользоваться сервисом "xmpp-server" [SRV] и протоколом "tcp" (использование строки "xmpp-server" для идентификатора сервиса согласуется с требованиями IANA.</p><p class="note">Заметим, что идентификатор "xmpp-server" заменил ранее использовавшийся "jabber". Если процедура SRV lookup терпит неудачу, следует выяснить традиционный IPv4/IPv6 адрес, используя "xmpp-server" порт 5269, зарегистрированный IANA.</p><p>Серверный dialback помогает защититься от фальсификации домена, делая более трудным фальсификацию XML-строф. Это не механизм аутентификации, обеспечения безопасности или шифрования строф между серверами, как это делается с помощью SASL и TLS. Процедура предлагает лишь слабую верификацию идентичности сервера. Кроме того, эта процедура уязвима для атак фальсификации DNS, если только не используется DNSSec [DNSSEC], и даже если информация DNS корректна, dialback не может защитить от атак, в которых атакер может украсть IP-адрес удаленного домена. Домены, требующие надежной безопасности должны использовать TLS и SASL. Если для аутентификации сервер-сервер используется SASL, dialback не следует использовать в силу полной бесполезности.</p><h3>14.5. Порядок слоев</h3><p>Порядок протокольных слоев в стеке должен быть следующим:</p><ol><li>TCP</li><li>TLS</li><li>SASL</li><li>XMPP</li></ol><p>Разумность такого порядка заключается в том, что он является основой [TCP] упорядочения для всего стека протоколов, работающих поверх TCP.</p><h3>14.6. Необходимость SASL для подключения канала к TLS</h3><p>Система SASL не предоставляет механизма подключения аутентификации SASL к уровню безопасности обеспечивающему конфиденциальность и целостность, которые согласованы на более низком уровне. Этот недостаток канальной привязки мешает SASL верифицировать, являются ли конечные точки виртуального канала, сформированного нижним уровнем безопасности, конечными точками, которые аутентифицировала SASL. Если конечные точки не идентичны, нижнему уровню безопасности нельзя доверять защиту данных, передаваемых между объектами SASL. В такой ситуации нужно согласовывать уровень безопасности SASL, который эффективно игнорирует более низкий уровень безопасности.</p><h3>14.7. Обязательные для использования технологии</h3><p>По минимуму все реализации должны поддерживать следующие механизмы:</p><ul><li><p>для аутентификации: механизм SASL [DIGEST-MD5]</p></li><li><p>для конфиденциальности: TLS (используя шифр TLS_RSA_WITH_3DES_EDE_CBC_SHA)</p></li><li><p>для обих: TLS плюс SASL EXTERNAL(используя TLS_RSA_WITH_3DES_EDE_CBC_SHA шифр, поддерживающий сертификаты стороны клиента)</p></li></ul><h3>14.8. Firewalls</h3><p>Коммуникации, использующие XMPP, в норме происходят поверх соединения через порт 5222 [TCP] (клиент-сервер) или порт 5269 (сервер-сервер), как это зарегистрировано IANA (смотри "Соображения IANA" (раздел 15)). Использование этих стандартных портов позволяет администраторам легко разрешить или запретить XMPP, делается это с помощью существующих стандартных firewall.</p><h3>14.9. Использование кодирования base64 в SASL</h3><p>Как клиент так и сервер должны верифицировать любые данные [BASE64], полученные в ходе согласования SASL. Реализация должна отвергать (или игнорировать) любые символы, которые неявно разрешены в кодировке base64. Это помогает защититься от создания скрытого канала, который может использоваться для "утечки" информации. Реализация не должна разрывать соединение при некорректном вводе, она должна отвергать любую последовательность символов base64, содержащую символ ('='), если такой символ включен не в качестве последнего символа данных (например, "=AAA" или "BBBB=CCC"). Это помогает защититься от атак переполнения буфера и некоторых других атак. Кодировка base64 визуально скрывает легко узнаваемую текстовую информацию, такую как пароли, но не обеспечивает конфиденциальности. Кодировка base64 должна следовать определениям из раздела 3 RFC 3548 [BASE64].</p><h3>14.10. Профайлы Stringprep</h3><p>XMPP использует профайл [NAMEPREP] из [STRINGPREP] для обработки идентификаторов доменов. Соображения безопасности, относящиеся к Nameprep, рассмотрены в соответствующем разделе [NAMEPREP].</p><p>Кроме того, XMPP определяет два профайла [STRINGPREP]: Nodeprep (Приложение A) для идентификаторов узлов и Resourceprep (Приложение B) для идентификаторов ресурсов.</p><p>В символьных наборах Unicode и ISO/IEC 10646 имеется много символов, которые выглядят сходным образом. Во многих случаях, пользователи протоколов безопасности могут осуществить визуальное распознавание имен объектов. Так как невозможно установить соответствие для символов идентичного вида без учета контекста (например, знания того, какой шрифт использован) stringprep не делает ничего для установления соответствия между идентично выглядящими символами и не запрещает использования таких символов.</p><p>Идентификатор узла может использоваться в качестве части адреса объекта в XMPP. Безопасность таких сервисов может быть скомпрометирована с помощью различной интерпретации интернациализированных идентификаторов узлов. Например, пользователь, вводящий один интернационализированный идентификатор может получить доступ к информации аккоунта другого пользователя.</p><p>Идентификатор ресурса может использоваться как часть адреса объекта в XMPP. Одним общим применением является имя пользователя при IM (активная сессия); другим может быть прозвище пользователя при многопользовательской сессии. Безопасность таких сервисов может быть скомпрометирована с помощью разной интерпретации интернациализированных идентификаторов узлов. например, пользователь может попытаться инициировать несколько сессий под одним и тем же именем, или пользователь может послать сообщение кому-то отличному от зарегистрированного получателя многопользовательской сессии.</p><h2 id="p15">15. Соображения IANA</h2><h3>15.1. Имя XML-пространства имен для данных TLS</h3><p>Субпространство имен URN для данных, связанных с TLS, в XMPP определено следующим образом. Это пространство имен сопряжено с форматом, определенным в IETF XML Registry [XML-REG].</p><pre>URI: urn:ietf:params:xml:ns:xmpp-tls
Specification: RFC 3920
Description: This is the XML namespace name for TLS-related data in
   the Extensible Messaging and Presence Protocol (XMPP) as defined
   by RFC 3920.
Registrant Contact: IETF, XMPP Working Group, &lt;xmppwg@jabber.org&gt;</pre><h3>15.2. Имя XML-пространства имен для данных SASL</h3><p>Субпространство имен URN для данных, связанных с SASL, в XMPP определено следующим образом. Это пространство имен сопряжено с форматом, определенным в [XML-REG].</p><pre>URI: urn:ietf:params:xml:ns:xmpp-sasl
Specification: RFC 3920
Description: This is the XML namespace name for SASL-related data in
   the Extensible Messaging and Presence Protocol (XMPP) as defined
   by RFC 3920.
Registrant Contact: IETF, XMPP Working Group, &lt;xmppwg@jabber.org&gt;</pre><h3>15.3. Имя XML-пространства имен для ошибок потока</h3><p>Субпространство имен URN для данных, связанных ошибками потоков в XMPP определено следующим образом. Это пространство имен сопряжено с форматом, определенным в [XML-REG].</p><pre>URI: urn:ietf:params:xml:ns:xmpp-streams
Specification: RFC 3920
Description: This is the XML namespace name for stream-related error
   data in the Extensible Messaging and Presence Protocol (XMPP) as
   defined by RFC 3920.
Registrant Contact: IETF, XMPP Working Group, &lt;xmppwg@jabber.org&gt;</pre><h3>15.4. Имя XML-пространства имен для подключения ресурсов</h3><p>Субпространство имен URN для подключения ресурсов в XMPP (Extensible Messaging and Presence Protocol) определяется следующим образом. Это имя пространства имен соответствует формату, определенному в [XML-REG].</p><pre>URI: urn:ietf:params:xml:ns:xmpp-bind
Specification: RFC 3920
Description: This is the XML namespace name for resource binding in
   the Extensible Messaging and Presence Protocol (XMPP) as defined
   by RFC 3920.
Registrant Contact: IETF, XMPP Working Group, &lt;xmppwg@jabber.org&gt;</pre><h3>15.5. Имя XML-пространства имен для ошибок строф</h3><p>Субпространство имен URN для данных, связанных с ошибками строф в XMPP определено следующим образом. Это имя пространства имен соответствует формату, определенному в [XML-REG].</p><pre>URI: urn:ietf:params:xml:ns:xmpp-stanzas
Specification: RFC 3920
Description: This is the XML namespace name for stanza-related error
   data in the Extensible Messaging and Presence Protocol (XMPP) as
   defined by RFC 3920.
Registrant Contact: IETF, XMPP Working Group, &lt;xmppwg@jabber.org&gt;</pre><h3>15.6. Nodeprep-профайл Stringprep</h3><p>Профайл Nodeprep для stringprep определен в рамках Nodeprep (Приложение A). IANA зарегистрировала Nodeprep в регистре профайлов stringprep.</p><ul><li><p>Имя этого профайла:</p></li><li class="lib"><p>Nodeprep</p></li><li><p>RFC, в котором описан профайл:</p></li><li class="lib"><p>RFC 3920</p></li></ul><h3>15.7. Профайл Resourceprep из Stringprep</h3><p>Профайл Resourceprep из stringprep определен в рамках Resourceprep (Приложение B). IANA зарегистрировала Resourceprep в регистре профайлов stringprep.</p><ul><li><p>Имя этого профайла:</p></li><li class="lib"><p>Resourceprep</p></li><li><p>RFC, в котором описан профайл:</p></li><li class="lib"><p>RFC 3920</p></li></ul><h3>15.8. Имя сервиса GSSAPI</h3><p>IANA зарегистрировала "xmpp" в качестве имени сервиса GSSAPI [GSS-API], как это задано в рамках определения SASL (раздел 6).</p><h3>15.9. Номера портов</h3><p>IANA зарегистрировала ключевые слова xmpp-client и xmpp-server для обозначения номеров портов для ТСР-обмена 5222 и 5269, соответственно. Эти номера портов следует использовать для обменов клиент-сервер и сервер-клиент.</p><h2 id="p16">16. Литература</h2><h3>16.1. Нормативные документы</h3><table itemprop="references"><tr><td>[ABNF]</td><td>Crocker, D. и P. Overell, «Augmented BNF for Syntax Specifications: ABNF», RFC 2234, Ноябрь 1997.</td></tr><tr><td>[BASE64]</td><td>Josefsson, S., «The Base16, Base32, and Base64 Data Encodings», RFC 3548, Июль 2003.</td></tr><tr><td>[CHARSET]</td><td>Alvestrand, H., «IETF Policy on Character Sets and Languages», BCP 18, RFC 2277, Январь 1998.</td></tr><tr><td>[DIGEST-MD5]</td><td>Leach, P. и C. Newman, «Using Digest Authentication as a SASL Mechanism», RFC 2831, Май 2000.</td></tr><tr><td>[DNS]</td><td>Mockapetris, P., «Domain names — implementation and specification», STD 13, RFC 1035, Ноябрь 1987.</td></tr><tr><td>[GSS-API]</td><td>Linn, J., «Generic Security Service Application Program Interface Version 2, Update 1», RFC 2743, Январь 2000.</td></tr><tr><td>[HTTP-TLS]</td><td>Rescorla, E., «HTTP Over TLS», RFC 2818, Май 2000.</td></tr><tr><td>[IDNA]</td><td>Faltstrom, P., Hoffman, P., and A. Costello, «Internationalizing Domain Names in Applications (IDNA)», RFC 3490, Март 2003.</td></tr><tr><td>[IPv6]</td><td>Hinden, R. и S. Deering, «Internet Protocol Version 6 (IPv6) Addressing Architecture», RFC 3513, Апрель 2003.</td></tr><tr><td>[LANGTAGS]</td><td>Alvestrand, H., «Tags for the Identification of Languages», BCP 47, RFC 3066, Январь 2001.</td></tr><tr><td>[NAMEPREP]</td><td>Hoffman, P. и M. Blanchet, «Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)», RFC 3491, Март 2003.</td></tr><tr><td>[RANDOM]</td><td>Eastlake 3rd, D., Crocker, S., and J. Schiller, «Randomness Recommendations for Security», RFC 1750, Декабрь 1994.</td></tr><tr><td>[SASL]</td><td>Myers, J., «Simple Authentication and Security Layer (SASL)», RFC 2222, October 1997.</td></tr><tr><td>[SRV]</td><td>Gulbrandsen, A., Vixie, P., and L. Esibov, «A DNS RR for specifying the location of services (DNS SRV)», RFC 2782, Февраль 2000.</td></tr><tr><td>[STRINGPREP]</td><td>Hoffman, P. и M. Blanchet, «Preparation of Internationalized Strings ("stringprep")», RFC 3454, Декабрь 2002.</td></tr><tr><td>[TCP]</td><td>Postel, J., <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">«Протокол управления передачей (TCP)», STD 7, RFC 793</a>, Сентябрь 1981.</td></tr><tr><td>[TERMS]</td><td>Bradner, S., «Key words for use in RFCs to Indicate Requirement Levels», BCP 14, RFC 2119, Март 1997.</td></tr><tr><td>[TLS]</td><td>Dierks, T. и C. Allen, <a href="../2246.rfc" title="RFC 2246 - Протокол TLS 1.0">«Протокол TLS 1.0», RFC 2246</a>, Январь 1999</td></tr><tr><td>[UCS2]</td><td>International Organization for Standardization, «Information Technology — Universal Multiple-octet coded Character Set (UCS) — Amendment 2: UCS Transformation Format 8 (UTF-8)», ISO Standard 10646-1 Addendum 2, October 1996.</td></tr><tr><td>[UTF-8]</td><td>Yergeau, F., «UTF-8, a transformation format of ISO 10646», STD 63, RFC 3629, Ноябрь 2003.</td></tr><tr><td>[X509]</td><td>Housley, R., Polk, W., Ford, W., and D. Solo, «Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile», RFC 3280, Апрель 2002.</td></tr><tr><td>[XML]</td><td>Bray, T., Paoli, J., Sperberg-McQueen, C., and E. Maler, «Extensible Markup Language (XML) 1.0 (2nd ed)», W3C REC-xml, Октябрь 2000.</td></tr><tr><td>[XML-NAMES]</td><td>Bray, T., Hollander, D., and A. Layman, «Namespaces in XML», W3C REC-xml-names, Январь 1999.</td></tr></table><h3>16.2. Дополнительная литература</h3><table itemprop="references"><tr><td>[ACAP]</td><td>Newman, C. и J. Myers, «ACAP — Application Configuration Access Protocol», RFC 2244, Ноябрь 1997.</td></tr><tr><td>[ASN.1]</td><td>CCITT, «Recommendation X.208: Specification of Abstract Syntax Notation One (ASN.1)», 1988.</td></tr><tr><td>[DNSSEC]</td><td>Eastlake 3rd, D., «Domain Name System Security Extensions», RFC 2535, Март 1999.</td></tr><tr><td>[HTTP]</td><td>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, «Hypertext Transfer Protocol — HTTP/1.1», RFC 2616, Июнь 1999.</td></tr><tr><td>[IMAP]</td><td>Crispin, M., «INTERNET MESSAGE ACCESS PROTOCOL — VERSION 4rev1», RFC 3501, Март 2003.</td></tr><tr><td>[IMP-REQS]</td><td>Day, M., Aggarwal, S., Mohr, G., and J. Vincent, «Instant Messaging / Presence Protocol Requirements», RFC 2779, Февраль 2000.</td></tr><tr><td>[IRC]</td><td>Oikarinen, J. и D. Reed, <a href="../1459.rfc" title="RFC 1459 - Протокол ретранслируемого интернет-чата (IRC)">«Протокол IRC», RFC 1459</a>, Май 1993.</td></tr><tr><td>[JEP-0029]</td><td>Kaes, C., «Definition of Jabber Identifiers (JIDs)», JSF JEP 0029, Октябрь 2003.</td></tr><tr><td>[JEP-0078]</td><td>Saint-Andre, P., «Non-SASL Authentication», JSF JEP 0078, Июль 2004.</td></tr><tr><td>[JEP-0086]</td><td>Norris, R. и P. Saint-Andre, «Error Condition Mappings», JSF JEP 0086, Февраль 2004.</td></tr><tr><td>[JSF]</td><td>Jabber Software Foundation, «Jabber Software Foundation».</td></tr><tr><td>[POP3]</td><td>Myers, J. и M. Rose, <a href="../1939.rfc" title="RFC 1939 - Протокол POP3">«Протокол POP3», STD 53, RFC 1939</a>, Май 1996.</td></tr><tr><td>[SIMPLE]</td><td>SIMPLE Working Group, «SIMPLE WG».</td></tr><tr><td>[SMTP]</td><td>Klensin, J., «Simple Mail Transfer Protocol», RFC 2821, Апрель 2001.</td></tr><tr><td>[URI]</td><td>Berners-Lee, T., Fielding, R., and L. Masinter, «Uniform Resource Identifiers (URI): Generic Syntax», RFC 2396, Август 1998.</td></tr><tr><td>[USINGTLS]</td><td>Newman, C., «Using TLS with IMAP, POP3 and ACAP», RFC 2595, Июнь 1999.</td></tr><tr><td>[XML-REG]</td><td>Mealling, M., «The IETF XML Registry», BCP 81, RFC 3688, Январь 2004.</td></tr><tr><td>[XMPP-IM]</td><td>Saint-Andre, P., Ed., «Extensible Messaging and Presence Protocol (XMPP): Instant Messaging and Presence», RFC 3921, Октябрь 2004.</td></tr></table><h2 id="p.appendix.a">Приложение A. Nodeprep</h2><h3>A.1. Введение</h3><p>Это приложение определяет профайл "Nodeprep" из [NAMEPREP]. Как таковой, он специфицирует правила обработки, которые позволят пользователям вводить интернационализированные идентификаторы узлов в XMPP и иметь при этом содержимое строк корректным. Идентификатор узла XMPP является опционной частью XMPP-адреса, которая предшествует идентификатору домена и сепаратору '@'. Он часто но не всегда ассоциируется именем пользователя при IM. Эти правила обработки ориентированы только на XMPP идентификаторы узлов, а не для произвольных текстов или любых аспектов XMPP-адреса.</p><p>Этот профайл определяет следующее, как это определено в [NAMEPREP]:</p><ul class="dot"><li>Профайл предназначен для: интернациализированных идентификаторов узлов в рамках XMPP</li><li>Символьный репертуар, который является входными и выходными данными для stringprep: Unicode 3.2 специфицирован в разделе 2 этого приложения</li><li>Используемые соответствия (mapping): специфицированы в разделе 3</li><li>Используемая нормализация Unicode: специфицирована в разделе 4</li><li>Символы, которые запрещены для выхода: специфицированы в разделе 5</li><li>Реверсивная обработка символов: специфицирована в разделе 6</li></ul><h3>A.2. Репертуар символов</h3><p>Этот профайл использует Unicode 3.2 со списком неприсвоенных кодовых значений таблицы A.1, определенной в Приложение A [NAMEPREP].</p><h3>A.3. Соответствие</h3><p>Этот профайл специфицирует соответствие при использовании таблиц из [STRINGPREP]:</p><ul><li>Table B.1</li><li>Table B.2</li></ul><h3>A.4. Нормализация</h3><p>Этот профайл специфицирует использование Unicode формы нормализации KC, как это описано в [NAMEPREP].</p><h3>A.5. Запрещенный вывод</h3><p>Этот профайл специфицирует запрет использования следующих таблиц из [NAMEPREP].</p><ul><li>Table C.1.1</li><li>Table C.1.2</li><li>Table C.2.1</li><li>Table C.2.2</li><li>Table C.3</li><li>Table C.4</li><li>Table C.5</li><li>Table C.6</li><li>Table C.7</li><li>Table C.8</li><li>Table C.9</li></ul><p>Кроме того, запрещены также следующие Unicode-символы:</p><ul><li>#x22 (&quot;)</li><li>#x26 (&amp;)</li><li>#x27 (')</li><li>#x2F (/)</li><li>#x3A (:)</li><li>#x3C (&lt;)</li><li>#x3E (&gt;)</li><li>#x40 (@)</li></ul><h3>A.6. Реверсивные символы</h3><p>Этот профайл специфицирует проверку реверсивных строк, как это описано в разделе 6 [NAMEPREP].</p><h2 id="p.appendix.b">Приложение B. Resourceprep</h2><h3>B.1. Введение</h3><p>Это приложение определяет профайл "Resourceprep" [NAMEPREP]. В этом качестве оно специфицирует правила обработки, которые позволят пользователю вводить интернационализированные идентификаторы ресурсов в XMPP и иметь высокий шанс получить содержимое строк корректным. (Идентификатор ресурса XMPP является опционной частью XMPP-адреса, которая следует за доменным идентификатором и сепаратором '/'. Он часто но не всегда является ассоциированным с именем сессии IM. Эти правила обработки предназначены для идентификаторов ресурсов XMPP и не ориентированы на работу с произвольными текстами или любыми другими аспектами XMPP-адреса.</p><p>Этот профайл определяет следующее (как это требуется [STRINGPREP]):</p><ul class="dot"><li>Профайл предназначен для: интернацианализированных идентификаторов ресурсов в XMPP</li><li>Символьный репертуар, который является входом и выходом stringprep: Unicode 3.2, специфицирован в разделе 2 этого приложения</li><li>Используемое соответствие символов специфицировано в разделе 3</li><li>Используемая нормализация Unicode специфицирована в разделе 4</li><li>Символы, которые запрещено использовать специфицированы в разделе 5</li><li>Реверсивная обработка символов специфицирована в разделе 6</li></ul><h3>B.2. Символьный репертуар</h3><p>Этот профайл использует Unicode 3.2 со списком неприсвоенных кодов из таблицы A.1, см. Приложение A [STRINGPREP].</p><h3>B.3. Соответствие</h3><p>Этот профайл специфицирует соответствие (mapping), использующее таблицу B.1 из [NAMEPREP]:</p><h3>B.4. Нормализация</h3><p>Этот профайл специфицирует использование формы KC нормализации Unicode, как это описано в [NAMEPREP].</p><h3>B.5. Запрещенный вывод</h3><p>Этот профайл специфицирует запрещенные для использования таблицы из [NAMEPREP].</p><ul><li>Table C.1.2</li><li>Table C.2.1</li><li>Table C.2.2</li><li>Table C.3</li><li>Table C.4</li><li>Table C.5</li><li>Table C.6</li><li>Table C.7</li><li>Table C.8</li><li>Table C.9</li></ul><h3>B.6. Реверсивные символы</h3><p>Этот профайл специфицирует проверку реверсивных строк, как это описано в разделе 6 [STRINGPREP].</p><h2 id="p.appendix.c">Приложение C. XML-схемы</h2><p>Следующие схемы XML являются описательными, а не нормативными. Для схем, определяющих пространства имен 'jabber:client' 'jabber:server', смотри [XMPP-IM].</p><h3>C.1. Пространство имен потоков</h3><pre>&lt;?xml version='1.0' encoding='UTF-8'?&gt;

&lt;xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='http://etherx.jabber.org/streams'
    xmlns='http://etherx.jabber.org/streams'
    elementFormDefault='unqualified'&gt;

  &lt;xs:element name='stream'&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence xmlns:client='jabber:client'
                   xmlns:server='jabber:server'
                   xmlns:db='jabber:server:dialback'&gt;
        &lt;xs:element ref='features' minOccurs='0' maxOccurs='1'/&gt;
        &lt;xs:any namespace='urn:ietf:params:xml:ns:xmpp-tls'
                minOccurs='0'
                maxOccurs='unbounded'/&gt;
        &lt;xs:any namespace='urn:ietf:params:xml:ns:xmpp-sasl'
                minOccurs='0'
                maxOccurs='unbounded'/&gt;
        &lt;xs:choice minOccurs='0' maxOccurs='1'&gt;
          &lt;xs:choice minOccurs='0' maxOccurs='unbounded'&gt;
            &lt;xs:element ref='client:message'/&gt;
            &lt;xs:element ref='client:presence'/&gt;
            &lt;xs:element ref='client:iq'/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:choice minOccurs='0' maxOccurs='unbounded'&gt;
            &lt;xs:element ref='server:message'/&gt;
            &lt;xs:element ref='server:presence'/&gt;
            &lt;xs:element ref='server:iq'/&gt;
            &lt;xs:element ref='db:result'/&gt;
            &lt;xs:element ref='db:verify'/&gt;
          &lt;/xs:choice&gt;
        &lt;/xs:choice&gt;
        &lt;xs:element ref='error' minOccurs='0' maxOccurs='1'/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name='from' type='xs:string' use='optional'/&gt;
      &lt;xs:attribute name='id' type='xs:NMTOKEN' use='optional'/&gt;
      &lt;xs:attribute name='to' type='xs:string' use='optional'/&gt;
      &lt;xs:attribute name='version' type='xs:decimal' use='optional'/&gt;
      &lt;xs:attribute ref='xml:lang' use='optional'/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name='features'&gt;
    &lt;xs:complexType&gt;
      &lt;xs:all xmlns:tls='urn:ietf:params:xml:ns:xmpp-tls'
              xmlns:sasl='urn:ietf:params:xml:ns:xmpp-sasl'
              xmlns:bind='urn:ietf:params:xml:ns:xmpp-bind'
              xmlns:sess='urn:ietf:params:xml:ns:xmpp-session'&gt;
        &lt;xs:element ref='tls:starttls' minOccurs='0'/&gt;
        &lt;xs:element ref='sasl:mechanisms' minOccurs='0'/&gt;
        &lt;xs:element ref='bind:bind' minOccurs='0'/&gt;
        &lt;xs:element ref='sess:session' minOccurs='0'/&gt;
      &lt;/xs:all&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name='error'&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence  xmlns:err='urn:ietf:params:xml:ns:xmpp-streams'&gt;
        &lt;xs:group   ref='err:streamErrorGroup'/&gt;
        &lt;xs:element ref='err:text'
                    minOccurs='0'
                    maxOccurs='1'/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;

  &lt;/xs:element&gt;

&lt;/xs:schema&gt;</pre><h3>C.2. Пространство имен потоковых ошибок</h3><pre>&lt;?xml version='1.0' encoding='UTF-8'?&gt;

&lt;xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-streams'
    xmlns='urn:ietf:params:xml:ns:xmpp-streams'
    elementFormDefault='qualified'&gt;

  &lt;xs:element name='bad-format' type='empty'/&gt;
  &lt;xs:element name='bad-namespace-prefix' type='empty'/&gt;
  &lt;xs:element name='conflict' type='empty'/&gt;
  &lt;xs:element name='connection-timeout' type='empty'/&gt;
  &lt;xs:element name='host-gone' type='empty'/&gt;
  &lt;xs:element name='host-unknown' type='empty'/&gt;
  &lt;xs:element name='improper-addressing' type='empty'/&gt;
  &lt;xs:element name='internal-server-error' type='empty'/&gt;
  &lt;xs:element name='invalid-from' type='empty'/&gt;
  &lt;xs:element name='invalid-id' type='empty'/&gt;
  &lt;xs:element name='invalid-namespace' type='empty'/&gt;
  &lt;xs:element name='invalid-xml' type='empty'/&gt;
  &lt;xs:element name='not-authorized' type='empty'/&gt;
  &lt;xs:element name='policy-violation' type='empty'/&gt;
  &lt;xs:element name='remote-connection-failed' type='empty'/&gt;
  &lt;xs:element name='resource-constraint' type='empty'/&gt;
  &lt;xs:element name='restricted-xml' type='empty'/&gt;
  &lt;xs:element name='see-other-host' type='xs:string'/&gt;
  &lt;xs:element name='system-shutdown' type='empty'/&gt;
  &lt;xs:element name='undefined-condition' type='empty'/&gt;
  &lt;xs:element name='unsupported-encoding' type='empty'/&gt;
  &lt;xs:element name='unsupported-stanza-type' type='empty'/&gt;
  &lt;xs:element name='unsupported-version' type='empty'/&gt;
  &lt;xs:element name='xml-not-well-formed' type='empty'/&gt;

  &lt;xs:group name='streamErrorGroup'&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref='bad-format'/&gt;
      &lt;xs:element ref='bad-namespace-prefix'/&gt;
      &lt;xs:element ref='conflict'/&gt;
      &lt;xs:element ref='connection-timeout'/&gt;
      &lt;xs:element ref='host-gone'/&gt;
      &lt;xs:element ref='host-unknown'/&gt;
      &lt;xs:element ref='improper-addressing'/&gt;
      &lt;xs:element ref='internal-server-error'/&gt;
      &lt;xs:element ref='invalid-from'/&gt;
      &lt;xs:element ref='invalid-id'/&gt;
      &lt;xs:element ref='invalid-namespace'/&gt;
      &lt;xs:element ref='invalid-xml'/&gt;
      &lt;xs:element ref='not-authorized'/&gt;
      &lt;xs:element ref='policy-violation'/&gt;
      &lt;xs:element ref='remote-connection-failed'/&gt;
      &lt;xs:element ref='resource-constraint'/&gt;
      &lt;xs:element ref='restricted-xml'/&gt;
      &lt;xs:element ref='see-other-host'/&gt;
      &lt;xs:element ref='system-shutdown'/&gt;
      &lt;xs:element ref='undefined-condition'/&gt;
      &lt;xs:element ref='unsupported-encoding'/&gt;
      &lt;xs:element ref='unsupported-stanza-type'/&gt;
      &lt;xs:element ref='unsupported-version'/&gt;
      &lt;xs:element ref='xml-not-well-formed'/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

  &lt;xs:element name='text'&gt;
    &lt;xs:complexType&gt;
      &lt;xs:simpleContent&gt;
        &lt;xs:extension base='xs:string'&gt;
          &lt;xs:attribute ref='xml:lang' use='optional'/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:simpleType name='empty'&gt;
    &lt;xs:restriction base='xs:string'&gt;
      &lt;xs:enumeration value=''/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;</pre><h3>C.3. Пространство имен TLS</h3><pre>&lt;?xml version='1.0' encoding='UTF-8'?&gt;

&lt;xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-tls'
    xmlns='urn:ietf:params:xml:ns:xmpp-tls'
    elementFormDefault='qualified'&gt;
  &lt;xs:element name='starttls'&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element
            name='required'
            minOccurs='0'
            maxOccurs='1'
            type='empty'/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name='proceed' type='empty'/&gt;
  &lt;xs:element name='failure' type='empty'/&gt;

  &lt;xs:simpleType name='empty'&gt;
    &lt;xs:restriction base='xs:string'&gt;
      &lt;xs:enumeration value=''/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;</pre><h3>C.4. Пространство имен SASL</h3><pre>&lt;?xml version='1.0' encoding='UTF-8'?&gt;

&lt;xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-sasl'
    xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
    elementFormDefault='qualified'&gt;

  &lt;xs:element name='mechanisms'&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name='mechanism'
                    maxOccurs='unbounded'
                    type='xs:string'/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name='auth'&gt;
    &lt;xs:complexType&gt;
      &lt;xs:simpleContent&gt;
        &lt;xs:extension base='empty'&gt;
          &lt;xs:attribute name='mechanism'
                        type='xs:string'
                        use='optional'/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name='challenge' type='xs:string'/&gt;
  &lt;xs:element name='response' type='xs:string'/&gt;
  &lt;xs:element name='abort' type='empty'/&gt;
  &lt;xs:element name='success' type='empty'/&gt;

  &lt;xs:element name='failure'&gt;
    &lt;xs:complexType&gt;
      &lt;xs:choice minOccurs='0'&gt;
        &lt;xs:element name='aborted' type='empty'/&gt;
        &lt;xs:element name='incorrect-encoding' type='empty'/&gt;
        &lt;xs:element name='invalid-authzid' type='empty'/&gt;
        &lt;xs:element name='invalid-mechanism' type='empty'/&gt;
        &lt;xs:element name='mechanism-too-weak' type='empty'/&gt;
        &lt;xs:element name='not-authorized' type='empty'/&gt;
        &lt;xs:element name='temporary-auth-failure' type='empty'/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:simpleType name='empty'&gt;
    &lt;xs:restriction base='xs:string'&gt;
      &lt;xs:enumeration value=''/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;</pre><h3>C.5. Пространство имен подключения ресурсов</h3><pre>&lt;?xml version='1.0' encoding='UTF-8'?&gt;

&lt;xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-bind'
    xmlns='urn:ietf:params:xml:ns:xmpp-bind'
    elementFormDefault='qualified'&gt;

  &lt;xs:element name='bind'&gt;
    &lt;xs:complexType&gt;
      &lt;xs:choice minOccurs='0' maxOccurs='1'&gt;
        &lt;xs:element name='resource' type='xs:string'/&gt;
        &lt;xs:element name='jid' type='xs:string'/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

&lt;/xs:schema&gt;</pre><h3>C.6. Пространство имен Dialback</h3><pre>&lt;?xml version='1.0' encoding='UTF-8'?&gt;

&lt;xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='jabber:server:dialback'
    xmlns='jabber:server:dialback'
    elementFormDefault='qualified'&gt;

  &lt;xs:element name='result'&gt;
    &lt;xs:complexType&gt;
      &lt;xs:simpleContent&gt;
        &lt;xs:extension base='xs:token'&gt;
          &lt;xs:attribute name='from' type='xs:string' use='required'/&gt;
          &lt;xs:attribute name='to' type='xs:string' use='required'/&gt;
          &lt;xs:attribute name='type' use='optional'&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base='xs:NCName'&gt;
                &lt;xs:enumeration value='invalid'/&gt;
                &lt;xs:enumeration value='valid'/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name='verify'&gt;
    &lt;xs:complexType&gt;
      &lt;xs:simpleContent&gt;
        &lt;xs:extension base='xs:token'&gt;
          &lt;xs:attribute name='from' type='xs:string' use='required'/&gt;
          &lt;xs:attribute name='id' type='xs:NMTOKEN' use='required'/&gt;
          &lt;xs:attribute name='to' type='xs:string' use='required'/&gt;
          &lt;xs:attribute name='type' use='optional'&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base='xs:NCName'&gt;
                &lt;xs:enumeration value='invalid'/&gt;
                &lt;xs:enumeration value='valid'/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

&lt;/xs:schema&gt;</pre><h3>C.7. Пространство имен ошибок строф</h3><pre>&lt;?xml version='1.0' encoding='UTF-8'?&gt;

&lt;xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-stanzas'
    xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'
    elementFormDefault='qualified'&gt;

  &lt;xs:element name='bad-request' type='empty'/&gt;
  &lt;xs:element name='conflict' type='empty'/&gt;
  &lt;xs:element name='feature-not-implemented' type='empty'/&gt;
  &lt;xs:element name='forbidden' type='empty'/&gt;
  &lt;xs:element name='gone' type='xs:string'/&gt;
  &lt;xs:element name='internal-server-error' type='empty'/&gt;
  &lt;xs:element name='item-not-found' type='empty'/&gt;
  &lt;xs:element name='jid-malformed' type='empty'/&gt;
  &lt;xs:element name='not-acceptable' type='empty'/&gt;
  &lt;xs:element name='not-allowed' type='empty'/&gt;
  &lt;xs:element name='payment-required' type='empty'/&gt;
  &lt;xs:element name='recipient-unavailable' type='empty'/&gt;
  &lt;xs:element name='redirect' type='xs:string'/&gt;
  &lt;xs:element name='registration-required' type='empty'/&gt;
  &lt;xs:element name='remote-server-not-found' type='empty'/&gt;
  &lt;xs:element name='remote-server-timeout' type='empty'/&gt;
  &lt;xs:element name='resource-constraint' type='empty'/&gt;
  &lt;xs:element name='service-unavailable' type='empty'/&gt;
  &lt;xs:element name='subscription-required' type='empty'/&gt;
  &lt;xs:element name='undefined-condition' type='empty'/&gt;
  &lt;xs:element name='unexpected-request' type='empty'/&gt;

  &lt;xs:group name='stanzaErrorGroup'&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref='bad-request'/&gt;
      &lt;xs:element ref='conflict'/&gt;
      &lt;xs:element ref='feature-not-implemented'/&gt;
      &lt;xs:element ref='forbidden'/&gt;
      &lt;xs:element ref='gone'/&gt;
      &lt;xs:element ref='internal-server-error'/&gt;
      &lt;xs:element ref='item-not-found'/&gt;
      &lt;xs:element ref='jid-malformed'/&gt;
      &lt;xs:element ref='not-acceptable'/&gt;
      &lt;xs:element ref='not-allowed'/&gt;
      &lt;xs:element ref='payment-required'/&gt;
      &lt;xs:element ref='recipient-unavailable'/&gt;
      &lt;xs:element ref='redirect'/&gt;
      &lt;xs:element ref='registration-required'/&gt;
      &lt;xs:element ref='remote-server-not-found'/&gt;
      &lt;xs:element ref='remote-server-timeout'/&gt;
      &lt;xs:element ref='resource-constraint'/&gt;
      &lt;xs:element ref='service-unavailable'/&gt;
      &lt;xs:element ref='subscription-required'/&gt;
      &lt;xs:element ref='undefined-condition'/&gt;
      &lt;xs:element ref='unexpected-request'/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

  &lt;xs:element name='text'&gt;
    &lt;xs:complexType&gt;
      &lt;xs:simpleContent&gt;
        &lt;xs:extension base='xs:string'&gt;
          &lt;xs:attribute ref='xml:lang' use='optional'/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:simpleType name='empty'&gt;
    &lt;xs:restriction base='xs:string'&gt;
      &lt;xs:enumeration value=''/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;</pre><h2 id="p.appendix.d">Appendix D. Differences Between Core Jabber Protocols and XMPP</h2><p>This section is non-normative.</p><p>XMPP has been adapted from the protocols originally developed in the Jabber open-source community, which can be thought of as "XMPP 0.9". Because there exists a large installed base of Jabber implementations and deployments, it may be helpful to specify the key differences between the relevant Jabber protocols and XMPP in order to expedite and encourage upgrades of those implementations and deployments to XMPP.  This section summarizes the core differences, while the corresponding section of [XMPP-IM] summarizes the differences that relate specifically to instant messaging and presence applications.</p><h3>D.1. Channel Encryption</h3><p>It was common practice in the Jabber community to use SSL for channel encryption on ports other than 5222 and 5269 (the convention is to use ports 5223 and 5270).  XMPP uses TLS over the IANA-registered ports for channel encryption, as defined under Use of TLS (Section 5) herein.</p><h3>D.2. Authentication</h3><p>The client-server authentication protocol developed in the Jabber community used a basic IQ interaction qualified by the 'jabber:iq:auth' namespace (documentation of this protocol is contained in [JEP-0078], published by the Jabber Software Foundation [JSF]).  XMPP uses SASL for authentication, as defined under Use of SASL (Section 6) herein.</p><p>The Jabber community did not develop an authentication protocol for server-to-server communications, only the Server Dialback (Section 8) protocol to prevent server spoofing.  XMPP supersedes Server Dialback with a true server-to-server authentication protocol, as defined under Use of SASL (Section 6) herein.</p><h3>D.3. Resource Binding</h3><p>Resource binding in the Jabber community was handled via the 'jabber:iq:auth' namespace (which was also used for client authentication with a server).  XMPP defines a dedicated namespace for resource binding as well as the ability for a server to generate a resource identifier on behalf of a client, as defined under Resource Binding (Section 7).</p><h3>D.4. JID Processing</h3><p>JID processing was somewhat loosely defined by the Jabber community (documentation of forbidden characters and case handling is contained in [JEP-0029], published by the Jabber Software Foundation [JSF]). XMPP specifies the use of [NAMEPREP] for domain identifiers and supplements Nameprep with two additional [STRINGPREP] profiles for JID processing: Nodeprep (Appendix A) for node identifiers and Resourceprep (Appendix B) for resource identifiers.</p><h3>D.5. Error Handling</h3><p>Stream-related errors were handled in the Jabber community via XML character data text in a &lt;stream:error/&gt; element.  In XMPP, stream-related errors are handled via an extensible mechanism defined under Stream Errors (Section 4.7) herein.</p><p>Stanza-related errors were handled in the Jabber community via HTTP-style error codes.  In XMPP, stanza-related errors are handled via an extensible mechanism defined under Stanza Errors (Section 9.3) herein.  (Documentation of a mapping between Jabber and XMPP error handling mechanisms is contained in [JEP-0086], published by the Jabber Software Foundation [JSF].)</p><h3>D.6. Internationalization</h3><p>Although use of UTF-8 has always been standard practice within the Jabber community, the community did not define mechanisms for specifying the language of human-readable text provided in XML character data.  XMPP specifies the use of the 'xml:lang' attribute in such contexts, as defined under Stream Attributes (Section 4.4) and xml:lang (Section 9.1.5) herein.</p><h3>D.7. Stream Version Attribute</h3><p>The Jabber community did not include a 'version' attribute in stream headers.  XMPP specifies inclusion of that attribute as a way to signal support for the stream features (authentication, encryption, etc.) defined under Version Support (Section 4.4.1) herein.</p><h2>Авторы</h2><p>Most of the core aspects of the Extensible Messaging and Presence Protocol were developed originally within the Jabber open-source community in 1999.  This community was founded by Jeremie Miller, who released source code for the initial version of the jabber server in January 1999.  Major early contributors to the base protocol also included Ryan Eatmon, Peter Millard, Thomas Muldowney, and Dave Smith.  Work by the XMPP Working Group has concentrated especially on security and internationalization; in these areas, protocols for the use of TLS and SASL were originally contributed by Rob Norris, and stringprep profiles were originally contributed by Joe Hildebrand. The error code syntax was suggested by Lisa Dusseault.</p><h2>Благодарности</h2><p>Thanks are due to a number of individuals in addition to the contributors listed.  Although it is difficult to provide a complete list, the following individuals were particularly helpful in defining the protocols or in commenting on the specifications in this memo: Thomas Charron, Richard Dobson, Sam Hartman, Schuyler Heath, Jonathan Hogg, Cullen Jennings, Craig Kaes, Jacek Konieczny, Alexey Melnikov, Keith Minkler, Julian Missig, Pete Resnick, Marshall Rose, Alexey Shchepin, Jean-Louis Seguineau, Iain Shigeoka, Greg Troxel, and David Waite.  Thanks also to members of the XMPP Working Group and the IETF community for comments and feedback provided throughout the life of this memo.</p><h2>Адрес автора</h2><p>Peter Saint-Andre (editor)<br />Jabber Software Foundation<br />EMail: <bdo dir="rtl">&#103;&#114;&#111;&#46;&#114;&#101;&#98;&#98;&#97;&#106;&#64;&#114;&#101;&#116;&#101;&#112;&#116;&#115;</bdo></p></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 3920 - Протокол XMPP: Ядро",disqus_identifier="3920.rfc",disqus_url="http://rfc2.ru/3920.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>