<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../1413.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 1413 — Протокол идентификации</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../1413.rfc">RFC 1413 — Протокол идентификации</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 1413</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank" rel="nofollow"><span itemprop="alternativeHeadline">Identification Protocol</span></a></dd><dd><div class="icon i7"></div> Предыдущие версии: RFC 912, RFC 931</dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Предложенный стандарт</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1993-02-01">Февраль 1993</time></dd><dd><div class="icon i5"></div> Автор: <span itemprop="author">M. St. Johns</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div id="text" itemprop="articleBody"><h3>Статус документа</h3><p>Этот документ содержит спецификацию стандарта, предложенного сообществу Internet, и является запросом к обсуждению в целях дальнейшего развития протокола. Состояние стандартизации документа можно выяснить в "IAB Official Protocol Standards". Документ может распространяться свободно.</p><h3>1. Введение</h3><p>Протокол идентификации (Identification Protocol, ident, Ident Protocol) обеспечивает способ идентификации пользователя для конкретного соединения TCP. Используя на входе номера пары соединенных между собой портов TCP, протокол возвращает строку символов, идентифицирующую владельца данного соединения на стороне сервера. Первоначально протокол идентификации называли Authentication Server Protocol (протокол аутентификации сервера). Новое имя лучше отражает суть протокола. Данный документ является результатом работы группы TCP Client Identity Protocol в составе IETF.</p><h3>2. Обзор</h3><p>Протокол представляет собой сервис на основе соединений TCP. Сервер слушает соединения TCP для порта 113 (десятичный номер). После организации соединения сервер читает строку данных, содержащую сведения о цели соединения. При существовании идентификатора пользователя для соединения сервер передает этот идентификатор в качестве отклика. После этого сервер может закрыть соединение или продолжить диалог "запрос-отклик". Серверу следует закрывать соединение по истечении заданного конфигурационными параметрами тайм-аута (60-180) при отсутствии каких-либо запросов. Клиент может закрыть соединение в любой момент, однако для компенсации возможных задержек в сети клиенту следует выждать по крайней мере 30 секунд после запроса прежде, закрыть соединение.</p><h3>3. Ограничения</h3><p>Передача запросов допустима только для полностью организованных соединений. Запрос содержит номера пары портов (локальный - удаленный), используемых для идентификации соединения и получаемых с указанием локального и удаленного адресов. Это означает, что пользователь с адресом A может запрашивать у сервера B только информацию о соединении между A и B.</p><h3>4. Формат запросов и откликов</h3><p>Сервер воспринимает простые текстовые запросы в формате:</p><pre>&lt;port-on-server&gt;, &lt;port-on-client&gt;</pre><p>где &lt;port-on-server&gt; указывает порт TCP (десятичное значение) для адресата (хоста, где работает сервер ident), а &lt;port-on-client&gt; указывает порт TCP (десятичное значение) на клиентской системе. Важно отметить, что если клиент на хосте A хочет сделать запрос серверу на хосте B о соединении, заданном локально (на хосте A) парой портов 23, 6191 (входящее соединение TELNET), клиент должен сделать запрос для пары 6191, 23 (идентификация соединения с точки зрения хоста B).</p><p>Например:</p><pre>6191, 23</pre><p>Отклик имеет формат:</p><pre>&lt;port-on-server&gt;, &lt;port-on-client&gt; : &lt;resp-type&gt; : &lt;add-info&gt;</pre><p>где &lt;port-on-server&gt; и &lt;port-on-client&gt; совпадают с номерами портов в запросе, &lt;resp-type&gt; идентифицирует тип отклика, а &lt;add-info&gt; содержит зависящие от контекста данные.</p><p>Возвращаемая информация связана с соединением TCP, заданным параметрами &lt;server-address&gt;, &lt;client-address&gt;, &lt;port-on-server&gt;, &lt;port-on-client&gt; (&lt;server-address&gt; и &lt;client-address&gt; - IP-адреса обеих сторон соединения, а &lt;port-on-server&gt; и &lt;port-on-client&gt; - параметры запроса)</p><p>Например:</p><pre>6193, 23 : USERID : UNIX : stjohns
6195, 23 : ERROR : NO-USER</pre><h3>5. Типы откликов</h3><p>Отклики могут быть двух типов:</p><h3>USERID</h3><p>В этом случае строка &lt;add-info&gt; содержит название операционной системы (возможно, с указанием поддерживаемого набора символов), за которым следует разделитель ":" и строка идентификации.</p><p>Если отклик содержит набор символов, последний отделяется от имени операционной системы запятой (,). Для обозначения набора символов используются стандартные идентификаторы. Если набор символов не указан, предполагается US-ASCII (см. ниже).</p><p>Идентификаторы операционной системы должны указываться в соответствии с документов RFC 1340, "Assigned Numbers" или его "наследниками".</p><p>В дополнение к идентификаторам ОС, указанным в "Assigned Numbers" можно использовать специальный идентификатор "OTHER" (прочие ОС).</p><p>Если в качестве операционной системы не возвращается значение "OTHER", предполагается, что сервер возвращает "нормальную" идентификацию пользователя, который владеет данным соединением (строка символов, позволяющая однозначно определить пользователя — например, имя пользователя в системе или пользовательская часть почтового адреса). Если указана операционная система (т.е., строка отклика не содержит "OTHER"), предполагается, что имя пользователя также имеет смысл (например, для использования в качестве аргумента команды finger или как части почтового адреса).</p><p>Значение "OTHER" говорит о том, что дальнейшие данные являются неформатированной строкой печатных символов используемого в системе набора. Отклик "OTHER" следует возвращать, если идентификатор пользователя не соответствует описанным выше требованиям. Например, такой отклик следует передавать, если вместо имени пользователя возвращается реальное имя или телефонный номер из пользовательской записи UNIX.</p><p>Предполагается, что идентификатор пользователя содержит только печатные символы используемого в системе набора. Идентификатор представляет собой строку октетов, не включающую символов (восьмеричное представление) 000 (NUL), 012 (LF) и 015 (CR). Важно подчеркнуть, что символы пробела (040), следующие за двоеточием, являются частью строки идентификатора и не должны игнорироваться. Обычно строка отклика завершается последовательностью CR/LF. Подчеркнем, что строка может содержать печатные символы, но не обязана содержать только их.</p><h3>ERROR</h3><p>Если по каким-то причинам владелец соединения не может быть определен, строка &lt;add-info&gt; сообщает о причине. Возможны следующие значения &lt;add-info&gt;:</p><ul><li class="b">INVALID-PORT</li><li class="lib">Один из портов указан некорректно. Такой отклик возвращается, если номер какого-нибудь (или обоих) из портов выходит за допустимые пределы (порты TCP могут нумероваться от 1 до 65535) или не является целым числом.</li><li class="b">NO-USER</li><li class="lib">Указанное парой портов соединение в настоящее время не используется или принадлежит неизвестному объекту.</li><li class="b">HIDDEN-USER</li><li class="lib">Сервер может определить пользователя, но не сообщает о нем по требованию этого пользователя.</li><li class="b">UNKNOWN-ERROR</li><li class="lib">Причину ошибки не удается определить (любая причина, не указанная выше). Такой отклик может возвращаться и в тех случаях, когда сервер может определить причину ошибки, но не желает ее сообщать. Если на сервере реализована такая возможность, она должна быть настраиваемой и по умолчанию сервер должен возвращать корректное сообщение об ошибке.</li></ul><p>В дальнейшем могут быть добавлены другие коды отклики. При использовании нестандартных откликов они должны начинаться с символа "X".</p><p>В дополнение к возврату откликов сервер может разрывать соединения, не возвращая никакого отклика. Преждевременное завершение соединения (клиент не получил символа EOL) должно трактоваться клиентом как отклик "ERROR : UNKNOWN-ERROR".</p><h3>Формальный синтаксис</h3><pre>&lt;request&gt; ::= &lt;port-pair&gt; &lt;EOL&gt;

&lt;port-pair&gt; ::= &lt;integer&gt; &quot;,&quot; &lt;integer&gt;

&lt;reply&gt; ::= &lt;reply-text&gt; &lt;EOL&gt;

&lt;EOL&gt; ::= &quot;015 012&quot;  ; CR-LF End of Line Indicator

&lt;reply-text&gt; ::= &lt;error-reply&gt; | &lt;ident-reply&gt;

&lt;error-reply&gt; ::= &lt;port-pair&gt; &quot;:&quot; &quot;ERROR&quot; &quot;:&quot; &lt;error-type&gt;

&lt;ident-reply&gt; ::= &lt;port-pair&gt; &quot;:&quot; &quot;USERID&quot; &quot;:&quot; &lt;opsys-field&gt;
                  &quot;:&quot; &lt;user-id&gt;

&lt;error-type&gt; ::= &quot;INVALID-PORT&quot; | &quot;NO-USER&quot; | &quot;UNKNOWN-ERROR&quot;
                 | &quot;HIDDEN-USER&quot; |  &lt;error-token&gt;

&lt;opsys-field&gt; ::= &lt;opsys&gt; [ &quot;,&quot; &lt;charset&gt;]

&lt;opsys&gt; ::= &quot;OTHER&quot; | &quot;UNIX&quot; | &lt;token&gt; ...etc.
            ;  (See &quot;Assigned Numbers&quot;)

&lt;charset&gt; ::= &quot;US-ASCII&quot; | ...etc.
              ;  (See &quot;Assigned Numbers&quot;)

&lt;user-id&gt; ::= &lt;octet-string&gt;

&lt;token&gt; ::= 1*64&lt;token-characters&gt; ; 1-64 characters

&lt;error-token&gt; ::= &quot;X&quot;1*63&lt;token-characters&gt;
                  ; 2-64 chars beginning w/X

&lt;integer&gt; ::= 1*5&lt;digit&gt; ; 1-5 digits.

&lt;digit&gt; ::= &quot;0&quot; | &quot;1&quot; ... &quot;8&quot; | &quot;9&quot; ; 0-9

&lt;token-characters&gt; ::=
               &lt;Any of these ASCII characters: a-z, A-Z,
                - (dash), .!@#$%^&amp;*()_=+.,&lt;&gt;/?&quot;'~`{}[]; &gt;
                            ; upper and lowercase a-z plus
                            ; printables minus the colon &quot;:&quot;
                            ; character.

&lt;octet-string&gt; ::= 1*512&lt;octet-characters&gt;

&lt;octet-characters&gt; ::=
               &lt;any octet from  00 to 377 (octal) except for
                ASCII NUL (000), CR (015) and LF (012)&gt;</pre><p>Примечания:</p><ol><li>Для обеспечения интероперабельности различных реализаций в части трактовки символов пробела следует придерживаться общего принципа: "будь консервативным при передаче и либеральным на приеме". Клиентам и серверам не следует генерировать избыточных пробелов, но они должны воспринимать строки с лишними пробелами от других. Избыточные пробелы могут встречаться везде, кроме собственно маркеров (token). В частности, дополнительные пробелы могут встречаться в начале и в конце строк запросов и откликов. Однако дополнительные пробелы недопустимы в отклике с идентификатором пользователя после двоеточия вслед за именем операционной системы, поскольку в этом случае они будут трактоваться как часть имени пользователя (именем пользователя считается вся последовательность символов от двоеточия до символов завершения строки CR/LF). Символы CR/LF не должны рассматриваться как часть идентификатора пользователя.</li><li>Вопреки сказанному выше, серверам следует ограничивать число пробелов между элементами (маркерами) до минимально возможного (полезного). Клиент может разорвать соединение, получив более 1000 символов без сигнала завершения строки &lt;EOL&gt;.</li><li>Размер идентификатора пользователя следует ограничивать 512 символами, а размер маркера - 64 символами, поскольку: a) новые маркеры (т. е., OPSYS или ERROR-TYPE) будут иметь размер не более 64 символов и b) серверу не следует передавать более 512 октетов идентификатора пользователя, а клиент должен принимать первые 512 октетов идентификатора пользователя. Вследствие этих ограничения сервер должен возвращать наиболее важную часть идентификатора пользователя в первых 512 октетах.</li><li>Следует использовать только те наборы символов и идентификаторы этих наборов, которые указаны в RFC 1340, "Assigned Numbers" и более новых вариантах этого документа. Идентификаторы набора символов применимы только к полям идентификации пользователя, а все остальные поля должны использовать набор символов US-ASCII.</li><li>Хотя поле &lt;user-id&gt; было определено выше как &lt;octet-string&gt; (строка октетов), оно должно соответствовать по формату и набору символов значению поля &lt;opsys-field&gt;; описанного выше.</li><li>Идентификатор набора символов обеспечивает для клиента контекст, позволяющий печатать или сохранять строку идентификации пользователя. Если клиент не может распознать или использовать указанный набор символов, ему следует трактовать строку идентификации как строку октетов (OCTET), со храняя вместе с ней идентификатор использованного набора символов. Строку октетов в таких случаях следует печатать, сохранять и обрабатывать с 16- ричном представлении (0-9a-f) в дополнение к используемому клиентской реализацией представлению (это обеспечивает возможность стандартного представления в различных реализациях).</li></ol><h3>6. Вопросы безопасности</h3><p>Уровень достоверности информации, возвращаемой данным протоколом, зависит от настроек запрашиваемого хоста и политики поддерживающей хост организации. Например, ПК, используемый в открытой лаборатории, может возвращать о себе любые сведения, которые пожелает указать пользователь. Более того, хост может возвращать специально искаженную (ложную) информацию.</p><p>Протокол Identification Protocol не предназначен для авторизации (проверки полномочий) или управления доступом. В лучшем случае этот протокол обеспечивает некоторые дополнительные сведения о соединениях TCP, в худшем - возвращает ошибочную, некорректную или умышленно искаженную информацию.</p><p>Использование возвращаемых протоколом сведений для каких-либо целей, кроме аудита, настоятельно не рекомендуется. В частности, использовать Identification Protocol для принятия решений о предоставлении доступа в качестве основного (т. е., при отсутствии других проверок) или дополнительного средства может существенно снизить уровень безопасности хоста.</p><p>Сервер идентификации может собирать сведения о пользователях, объектах и процессах, которые зачастую могут содержать приватные данные. Сервер идентификации обеспечивает услуги по типу служб CallerID, поддерживаемых некоторыми телефонными компаниями, и требования к сообщаемым сервером сведениям формируются так же, как к данным CallerID. Если вы не желаете поддерживать службу finger из соображений ограничения доступа к сведениям о пользователях, вам нецелесообразно использовать и протокол идентификации.</p><h3>7. Благодарности</h3><p>Благодарим Дэна Бернштейна (Dan Bernstein), который оживил интерес к данному протоколу и указал на досадные ошибки в RFC 931.</p><h3>Литература</h3><table itemprop="references"><tr><td>[1]</td><td>St. Johns, M., «Authentication Server», RFC 931, TPSC, Январь 1985.</td></tr><tr><td>[2]</td><td>Reynolds, J., and J. Postel, «Assigned Numbers», STD 2, RFC 1340, USC/Information Sciences Institute, Июль 1992.</td></tr></table><h3>Адрес автора</h3><p>Michael C. St. Johns<br />DARPA/CSTO<br />3701 N. Fairfax Dr<br />Arlington, VA 22203<br />Phone: (703) 696-2271<br />EMail: <bdo dir="rtl">&#108;&#105;&#109;&#46;&#97;&#112;&#114;&#97;&#100;&#64;&#115;&#110;&#104;&#111;&#106;&#116;&#115;</bdo></p></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 1413 - Протокол идентификации",disqus_identifier="1413.rfc",disqus_url="http://rfc2.ru/1413.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>