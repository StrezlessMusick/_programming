<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link rel="prev" href="2" /><link rel="next" href="4" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><title>Перевод RFC 2581 — Контроль насыщения в TCP, стр. 3</title><meta name="author" content="M. Allman, V. Paxson, W. Stevens" /><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../2581.rfc">RFC 2581 — Контроль насыщения в TCP</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 2581</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank" rel="nofollow"><span itemprop="alternativeHeadline">TCP Congestion Control</span></a></dd><dd><div class="icon i7"></div> Другие версии: RFC 2001, <strong class="obsoleted_by">RFC 5681</strong></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Предложенный стандарт</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1999-04-01">Апрель 1999</time></dd><dd><div class="icon i5"></div> Авторы: <span itemprop="author">M. Allman</span>, <span itemprop="author">V. Paxson</span>, <span itemprop="author">W. Stevens</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div class="pages"><p class="r"> <h2 class="pt"><span class="z">RFC 2581,</span> Страница 3 из 9</h2></p><ul><li><noindex><a href="print" rel="nofollow">Одной Страницей</a></noindex></li><li><a accesskey="1" title="Первая страница" href="../2581.rfc" class="arr">&lArr;</a></li><li><a accesskey="2" title="На страницу назад" href="2"><b>&larr;</b></a></li><li><a href="../2581.rfc">1</a></li><li><a href="2">2</a></li><li class="this"><span>3</span></li><li><a href="4">4</a></li><li><a href="5">5</a></li><li><a href="6">6</a></li><li><a href="7">7</a></li><li><a href="8">8</a></li><li><a href="9">9</a></li><li><a accesskey="3" title="На страницу вперед" href="4">&rarr;</a></li><li><a accesskey="4" title="Последняя страница" href="9">&rArr;</a></li></ul></div><div id="text" itemprop="articleBody"><h3>3.1 Алгоритмы Slow Start и Congestion Avoidance</h3><p>Алгоритмы замедленного старта (slow start) и предотвращения перегрузки (congestion avoidance) должны использоваться отправителем TCP для контроля за передачей в сеть остающихся неотправленными данных. Для реализации этих алгоритмов в состояние соединения TCP добавлены две переменных. Размер окна насыщения (cwnd) - задаваемый на стороне отправителя предел для количества данных, которые отправитель может передать в сеть до получения подтверждения (ACK), а анонсируемое получателем окно (rwnd) определяет установленный на приемной стороне предел размера остающихся данных. Передачей управляет меньшее из двух значений cwnd и rwnd.</p><p>Еще одна переменная состояния ssthresh используется для определения момента, когда следует использовать алгоритм замедленного старта или предотвращения перегрузки в соответствии с приведенными ниже описаниями.</p><p>Начало передачи в сеть с неизвестными условиями требует от TCP достаточно медленной проверки сети с целью определения доступной "емкости" для того, чтобы избежать насыщения сети избыточным потоком данных. Алгоритм slow start используется для решения этой задачи на начальном этапе передачи или после восстановления в результате потери пакетов, обнаруженной с помощью таймера повторной передачи.</p><p>IW - начальное значение cwnd - должно быть не более 2*SMSS байтов и недопустимо делать это значение более 2 сегментов.</p><p class="note">Отметим, что нестандартные экспериментальные реализации TCP могут разрешать использование начального окна IW большего размера, как определено в уравнении (1) [RFC2414]:</p><pre>IW = min (4*SMSS, max (2*SMSS, 4380 bytes)) (1)</pre><p>В таких случаях отправитель TCP может использовать начальное окно размером в 3 или 4 сегмента, если суммарный размер этих сегментов не превышает 4380 байтов. Данный документ не разрешает использование таких расширений. Однако далее в этом документе обсуждается использование выражения (1) как направления для экспериментов в части изменений параметров (но не как часть данной спецификации алгоритмов контроля насыщения).</p><p>Начальное значение ssthresh может быть сколь угодно высоким (например, некоторые реализации используют в качестве порога размер анонсируемого окна), но значение порога может быть уменьшено при возникновении насыщения. Алгоритм замедленного старта используется в тех случаях, когда cwnd &lt; ssthresh, а при cwnd &gt; ssthresh применяется алгоритм предотвращения перегрузки. Если cwnd = ssthresh отправитель может использовать любой из этих алгоритмов.</p><p>При замедленном старте TCP увеличивает размер окна cwnd не более, чем на SMSS байтов для каждого пакета ACK, подтверждающего доставку новой порции данных. Замедленный старт завершается, когда размер окна насыщения cwnd превышает порог ssthresh (или становится равным этому порогу).</p><p>В процессе предотвращения перегрузки размер окна cwnd увеличивается на 1 полноразмерный сегмент за каждый период кругового обхода RTT. Предотвращение насыщения продолжается до тех пор, пока насыщение наблюдается. Для обновления значений cwnd в процессе предотвращения перегрузки обычно используется выражение:</p><pre>cwnd += SMSS*SMSS/cwnd (2)</pre><p>Такое увеличение окна выполняется при каждом входящем пакете ACK, не являющемся дубликатом. Выражение (2) обеспечивает допустимое приближение для описанного выше увеличения окна cwnd на 1 полноразмерный сегмент для каждого периода RTT. Отметим, что для соединения, в котором получатель подтверждает прием каждого сегмента данных, выражение (2) задает несколько более агрессивный подход, нежели добавление размера 1 сегмента на каждый период RTT, а для получателей, подтверждающих каждый второй пакет, выражение (2) задает менее агрессивный подход по сравнению с добавлением 1 сегмента.</p><div class="note"><p>Примечание для разработчиков: Поскольку в реализациях TCP обычно используется целочисленная арифметика, выражение (2) может не приводить к увеличению размера окна cwnd, когда окно насыщения очень велико (больше, чем SMSS*SMSS). Если выражение (2) дает нулевой результат, его следует "округлять" до 1 байта.</p><p>В старых реализациях используется дополнительная положительная константа в правой части выражения (2). Такой подход некорректен и может вести к снижению производительности [RFC2525].</p></div><p>Другим подходящим способом увеличения окна cwnd в процессе предотвращения перегрузки является подсчет числа байтов новых данных, которые были подтверждены пакетами ACK (недостатком этого метода является необходимость поддержки дополнительной переменной состояния). Когда число подтвержденных байтов достигнет значения cwnd, размер окна cwnd может быть увеличен на величину до SMSS байтов. Отметим, что в процессе предотвращения перегрузки размер окна cwnd недопустимо увеличивать более, чем на размер одного полноразмерного сегмента в течение периода RTT или на величину, вычисляемую с помощью выражения 2.</p><p class="note">Примечание для разработчиков: Некоторые реализации поддерживают размер окна cwnd в байтах, а другие - в полноразмерных сегментах. В последнем случае использование выражения (2) становится затруднительным и может оказаться предпочтительным механизм, рассмотренный в предыдущем абзаце.</p><p>Когда отправитель TCP обнаруживает потерю сегмента с помощью таймера повтора передачи, для переменной ssthresh должно устанавливаться значение, не превышающее значение выражения 3:</p><pre>ssthresh = max (FlightSize / 2, 2*SMSS) (3)</pre><p>Как было отмечено выше, FlightSize показывает количество данных, которые еще находятся в сети (переданы, но не подтверждены).</p><p class="note">Примечание для разработчиков: Легко ошибиться и использовать cwnd вместо FlightSize, что может в некоторых реализациях приводить к увеличению порога до значений, превышающих rwnd.</p><p>Более того, при возникновении тайм-аута необходимо устанавлив ать для размера окна насыщения cwnd значение, не превышающее размер окна потерь LW, которое равно 1 полноразмерному сегменту (независимо от значения IW). Следовательно, после повтора передачи отброшенного сегмента отправитель TCP использует замедленный старт для увеличения окна от 1 полноразмерного сегмента до нового значения ssthresh, после чего снова включается механизм предотвращения перегрузки.</p></div></div><noindex><div class="pages"><p class="r"> <b>Страница 3 из 9</b></p><ul><li><noindex><a href="print" rel="nofollow">Одной Страницей</a></noindex></li><li><a title="Первая страница" href="../2581.rfc" class="arr">&lArr;</a></li><li><a title="На страницу назад" href="2"><b>&larr;</b></a></li><li><a href="../2581.rfc">1</a></li><li><a href="2">2</a></li><li class="this"><span>3</span></li><li><a href="4">4</a></li><li><a href="5">5</a></li><li><a href="6">6</a></li><li><a href="7">7</a></li><li><a href="8">8</a></li><li><a href="9">9</a></li><li><a title="На страницу вперед" href="4">&rarr;</a></li><li><a title="Последняя страница" href="9">&rArr;</a></li></ul></div></noindex><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 2581 - Контроль насыщения в TCP",disqus_identifier="2581.rfc",disqus_url="http://rfc2.ru/2581.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>