<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link rel="prev" href="3" /><link rel="next" href="5" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><title>Перевод RFC 2581 — Контроль насыщения в TCP, стр. 4</title><meta name="author" content="M. Allman, V. Paxson, W. Stevens" /><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../2581.rfc">RFC 2581 — Контроль насыщения в TCP</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 2581</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank" rel="nofollow"><span itemprop="alternativeHeadline">TCP Congestion Control</span></a></dd><dd><div class="icon i7"></div> Другие версии: RFC 2001, <strong class="obsoleted_by">RFC 5681</strong></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Предложенный стандарт</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1999-04-01">Апрель 1999</time></dd><dd><div class="icon i5"></div> Авторы: <span itemprop="author">M. Allman</span>, <span itemprop="author">V. Paxson</span>, <span itemprop="author">W. Stevens</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div class="pages"><p class="r"> <h2 class="pt"><span class="z">RFC 2581,</span> Страница 4 из 9</h2></p><ul><li><noindex><a href="print" rel="nofollow">Одной Страницей</a></noindex></li><li><a accesskey="1" title="Первая страница" href="../2581.rfc" class="arr">&lArr;</a></li><li><a accesskey="2" title="На страницу назад" href="3"><b>&larr;</b></a></li><li><a href="../2581.rfc">1</a></li><li><a href="2">2</a></li><li><a href="3">3</a></li><li class="this"><span>4</span></li><li><a href="5">5</a></li><li><a href="6">6</a></li><li><a href="7">7</a></li><li><a href="8">8</a></li><li><a href="9">9</a></li><li><a accesskey="3" title="На страницу вперед" href="5">&rarr;</a></li><li><a accesskey="4" title="Последняя страница" href="9">&rArr;</a></li></ul></div><div id="text" itemprop="articleBody"><h3>3.2 Fast Retransmit/Fast Recovery</h3><p>Получателю TCP следует незамедлительно передавать дубликат ACK при получении сегмента с нарушением порядка доставки. Это делается для того, чтобы с помощью пакета ACK информировать отправителя о том, что сегмент был получен с нарушением порядка и указать порядковый номер ожидаемого сегмента. С точки зрения отправителя дубликат ACK может быть вызван различными проблемами в сети. Во-первых, причиной может служить отбрасывание сегментов. В этом случае все сегменты после отброшенного будут порождать дубликаты ACK. Во-вторых, дубликаты ACK могут быть обусловлены нарушением порядка доставки сегментов (например, при доставке по разным путям [Pax97]). Наконец, причиной дубликатов ACK может быть репликация пакетов ACK или сегментов данных в сети. В дополнение к сказанному получателю TCP следует незамедлительно передавать подтверждение ACK при получении сегмента, который полностью или частично заполняет пропуски в порядковых номерах. Это позволит предоставить своевременную информ ацию отправителю, выполняющему восстановление после потери с использованием тайм-аута повторной передачи (retransmission timeout), быстрого повтора (fast retransmit) или экспериментального алгоритма восстановления (loss recovery) типа NewReno [RFC2582].</p><p>Отправителю TCP следует использовать алгоритм быстрого повтора для детектирования потери и исправления ошибки с использованием входящих дубликатов ACK. Алгоритм быстрого повтора использует прибытие 3 дубликатов ACK (4 идентичных подтверждения ACK без доставки между ними каких-то других пакетов) как индикацию потери сегмента. После получения 3 дубликатов ACK протокол TCP выполняет повторную передачу сегмента, который представляется потерянным, без ожидания завершения отсчета по таймеру повтора передачи.</p><p>После того, как алгоритм быстрого повтора передаст те данные, которые представляются включенными в отсутствующий сегмент, алгоритм "быстрого восстановления ("fast recovery") регулирует передачу новых данных, пока не будет получено подтверждение ACK, не являющееся дубликатом. Алгоритм замедленного старта не используется по той причине, что получение дубликатов ACK не только указывает на потерю сегмента, но и говорит о высокой вероятности того, что сегменты покинули сеть (хотя массированное дублирование сегментов в сети может сделать такое допущение некорректным). Иными словами, поскольку получатель может генерировать дубликат ACK только при получении сегмента, этот сегмент покинул сеть и находится в приемном буфере, более не потребляя ресурсов сети. Более того, поскольку "синхронизация" ACK сохраняется [Jac88], отправитель TCP может продолжать передачу новых сегментов (хотя и со сниженным значением cwnd).</p><p>Алгоритмы быстрого повтора и быстрого восстановления обычно реализуются вместе, как описано ниже.</p><ol><li>При получении третьего дубликата ACK устанавливается значение ssthresh, которое не превышает значения выражения 3.</li><li>Повторяется передача потерянного сегмента и устанавливается cwnd = ssthresh + 3*SMSS. Это искусственно "увеличивает" размер окна насыщения на число сегментов (три), которые покинули сеть и буферизованы получателем.</li><li>Для каждого принятого дополнительного дубликата ACK значение cwnd увеличивается на SMS S. Это искусственно увеличивает окно насыщения для того, чтобы отразить выход из сети дополнительных сегментов.</li><li>Передается новый сегмент, если это разрешено значениями cwnd и окна, анонсируемого получателем.</li><li>При получении следующего пакета ACK, подтверждающего новые данные, устанавливается cwnd = ssthresh (значение порога, заданное в п. 1). Это приводит к "уменьшению" размера окна насыщения.</li></ol><blockquote><p>Этому пакету ACK следует быть подтверждением, вызванным повтором с п. 1 в течение одного периода RTT после повтора (хотя подтверждение может прийти быстрей при наличии существенного нарушения порядка доставки сегментов данных на приемной стороне). Кроме того, этому пакету ACK следует подтверждать все промежуточные сегменты, переданные между потерянным сегментом и получением третьего дубликата ACK, если ни один из этих сегментов не был потерян.</p></blockquote><p class="note">Примечание: Известно, что этот алгоритм в общем случае не обеспечивает достаточно эффективного восстановления при множественных потерях в одном "звене" пакетов [FF96]. Один из вариантов решения этой проблемы описан в документе [RFC2582].</p></div></div><noindex><div class="pages"><p class="r"> <b>Страница 4 из 9</b></p><ul><li><noindex><a href="print" rel="nofollow">Одной Страницей</a></noindex></li><li><a title="Первая страница" href="../2581.rfc" class="arr">&lArr;</a></li><li><a title="На страницу назад" href="3"><b>&larr;</b></a></li><li><a href="../2581.rfc">1</a></li><li><a href="2">2</a></li><li><a href="3">3</a></li><li class="this"><span>4</span></li><li><a href="5">5</a></li><li><a href="6">6</a></li><li><a href="7">7</a></li><li><a href="8">8</a></li><li><a href="9">9</a></li><li><a title="На страницу вперед" href="5">&rarr;</a></li><li><a title="Последняя страница" href="9">&rArr;</a></li></ul></div></noindex><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 2581 - Контроль насыщения в TCP",disqus_identifier="2581.rfc",disqus_url="http://rfc2.ru/2581.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>