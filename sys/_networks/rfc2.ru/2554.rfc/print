<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../2554.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 2554 — Расширение сервиса SMTP для аутентификации</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../2554.rfc">RFC 2554 — Расширение сервиса SMTP для аутентификации</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 2554</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank" rel="nofollow"><span itemprop="alternativeHeadline">SMTP Service Extension for Authentication</span></a></dd><dd><div class="icon i7"></div> Другие версии: <strong class="obsoleted_by">RFC 4954</strong></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Предложенный стандарт</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1999-03-01">Март 1999</time></dd><dd><div class="icon i5"></div> Автор: <span itemprop="author">John Gardiner Myers</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div id="text" itemprop="articleBody"><h3>Статус документа</h3><p>В этом документе содержится спецификация протокола, предложенного сообществу Internet. Документ служит приглашением к дискуссии в целях развития и совершенствования протокола. Текущее состояние стандартизации протокола вы можете узнать из документа "Internet Official Protocol Standards" (STD 1). Документ может распространяться без ограничений.</p><h2>1. Введение</h2><p>Этот документ определяет расширение сервиса SMTP [ESMTP], посредством которого клиент SMTP может указать серверу механизм аутентификации, провести обмен данными протокола аутентификации и дополнительно согласовать уровень защиты для последующих транзакций протокола. Это расширение является вариантом SASL (Simple Authentication and Security Layer) [SASL].</p><h2>2. Используемые в документе соглашения</h2><p>В примерах строки "C:" и "S:" показывают строки, передаваемые клиентом и сервером, соответственно.</p><p>Ключевые слова необходимо (MUST), недопустимо (MUST NOT), следует (SHOULD), не следует (SHOULD NOT), возможно (MAY) в данном документе должны интерпретироваться в соответствии с документом "Ключевые слова для обозначения уровня требований в RFC" [KEYWORDS].</p><h2>3. Расширение для аутентификации</h2><ol><li>Имя расширения сервиса SMTP — Authentication</li><li>Ключевое слово EHLO, связанное с этим расширением, — AUTH</li><li>Ключевое слово AUTH EHLO содержит в качестве параметра список разделенных пробелами имен поддерживаемых механизмов SASL.</li><li>Определяется новая команда (verb) SMTP — AUTH.</li><li>Дополнительный параметр, использующий ключевое слово AUTH, добавляется к команде MAIL FROM и максимальный размер этой команды расширяется до 500 символов.</li><li>Данное расширение подходит для протокола подачи сообщений [SUBMIT].</li></ol><h2>4. Команда AUTH</h2><pre>AUTH mechanism [initial-response]</pre><h4>Аргументы</h4><p>Строка, идентифицирующая механизм аутентификации SASL. В строку может также включаться необязательный отклик, представленный в формате base64.</p><h4>Ограничения</h4><p>После успешного выполнения команды AUTH в той же сессии не могут вводиться дополнительные команды AUTH. После успешного выполнения команды AUTH сервер должен отвергать любые последующие команды AUTH с возвратом кода 503. Команды AUTH не допускаются в процессе выполнения почтовых транзакций.</p><h4>Обсуждение</h4><p>Команда AUTH показывает серверу механизм аутентификации. Если сервер поддерживает запрошенный механизм, он выполняет обмен данными протокола аутентификации и идентифицирует пользователя. В дополнение к этому может согласовываться уровень защиты для последующих транзакций протокола. Если запрошенный механизм аутентификации не поддерживается, сервер отвергает команду AUTH с возвратом кода 504.</p><p>Обмен данными протокола аутентификации состоит из последовательности запросов (challenge) сервера и откликов (answer) клиента, определяемых используемым механизмом аутентификации. Запрос сервера (server challenge), называемый также индикацией готовности (ready response) представляет собой код 334 с текстом, содержащим строку в коде BASE64. Ответ клиента состоит из строки в коде BASE64. Если клиент отказывается от аутентификационного обмена, он возвращает строку,
содержащую только символ *. Если сервер получает такой отклик, он должен отвергнуть команду AUTH и возвратить код 501.</p><p>Необязательный аргумент initial-response в команде AUTH служит для «замыкания круга» (round trip) при использовании механизмов аутентификации, которые не передают данных в начальном запросе (initial challenge). При использовании аргумента initial-response с таким механизмом клиенту не передается пустой изначальный запрос и вместо этого сервер передает данные, указанные параметром initial-response, как будто он шлет их в ответ на пустой запрос. В отличие от пустого (zero-length) ответа клиента на код 334 пустой изначальный отклик передается в виде одного символа — знака равенства (=).</p><p>Если клиент использует в команде AUTH параметр initial-response для механизма, который передает данные в изначальном запросе, сервер отвергает команду AUTH с возвратом кода 535.</p><p>Если сервер не может декодировать аргумент BASE64, он отвергает команду AUTH с возвратом кода 501. Если сервер отвергает аутентификационные данные, ему следует отвергнуть и команду AUTH с возвратом кода 535, если нет подходящего более специфичного кода из числа перечисленных в главе 6. Для успешного завершения клиентом процесса обмена аутентификационными данными, сервер SMTP возвращает код 235.</p><p>Имя сервиса, задаваемое данным вариантом SASL, — smtp.</p><p>Если в процессе аутентификационного обмена SASL согласуется уровень защиты, он вступает в силу сразу же после последовательности CRLF, завершающей аутентификационный обмен для клиента и CRLF в отклике о позитивном результате для сервера. После вступления в силу уровня защиты протокол SMTP сбрасывается в начальное состояние (состояние SMTP после возврата сервером кода готовности 220). Сервер должен отбрасывать любые полученные от клиента данные (такие, как аргументы команды EHLO), которые не были получены непосредственно из согласования SASL. Клиент должен отбрасывать любую полученную от сервера информацию (такую, как список расширений сервиса SMTP), которая не была получена непосредственно из согласования SASL (исключением является возможность клиента сравнивать список анонсируемых механизмов SASL до и после аутентификации для детектирования активных атак по срыву согласования). Клиенту следует передавать EHLO в качестве первой команды после успешного завершения SASL-согласования, которое приводит к включению уровня защиты.</p><p>От сервера не требуется поддержки любого конкретного механизма аутентификации или механизмов аутентификации, требуемых для поддержки любых уровней защиты. При отказе, полученном в ответ на команду AUTH, клиент может попытаться использовать другой механизм аутентификации с помощью новой команды AUTH.</p><p>При отказе от выполнения команды AUTH сервер должен вести себя так, как будто клиент не вводил команду AUTH совсем.</p><p>Строка BASE64 в общем случае может иметь произвольную длину. Клиенты и серверы должны поддерживать строки запросов и откликов такого размера, который использует поддерживаемый ими механизм аутентификации, независимо от всех прочих ограничений на размер, которые могут вносить другие компоненты реализации протокола для сервера или клиента.</p><p>Примеры:</p><pre>S: 220 smtp.example.com ESMTP server ready
C: EHLO jgm.example.com
S: 250-smtp.example.com
S: 250 AUTH CRAM-MD5 DIGEST-MD5
C: AUTH FOOBAR
S: 504 Unrecognized authentication type.
C: AUTH CRAM-MD5
S: 334
PENCeUxFREJoU0NnbmhNWitOMjNGNndAZWx3b29kLmlubm9zb2Z0LmNvbT4=
C: ZnJlZCA5ZTk1YWVlMDljNDBhZjJiODRhMGMyYjNiYmFlNzg2ZQ==
S: 235 Authentication successful.</pre><h2>5. Параметр AUTH в команде the MAIL FROM</h2><pre>AUTH=addr-spec</pre><h4>Аргументы</h4><p>Параметр addr-spec указывает «личность» (identity) подающего сообщение в систему доставки или содержит два символа &lt;&gt;, показывающие, что «личность» неизвестна или недостаточно аутентифицирована. С учетом ограничений, накладываемых на параметры ESMTP значение addr-spec кодируется в xtext. Синтаксис xtext описан в главе 5 документа [ESMTP-DSN].</p><h4>Обсуждение</h4><p>Необязательный параметр AUTH в команде MAIL FROM позволяет кооперировать агенты, находящиеся в защищенной среде для аутентификации отдельных сообщений.</p><p>Если сервер доверяет аутентифицированной «личности» клиента, заявляющего, что сообщение уже было изначально подано addr-spec, серверу следует передать это значение addr-spec в параметре AUTH при трансляции сообщения любому серверу, который поддерживает расширение AUTH.</p><p>Команда MAIL FROM с параметром AUTH=&lt;&gt; показывает, что изначально подавший сообщение неизвестен. Для сервера недопустимо трактовать такое сообщение как изначально поданное клиентом.</p><p>Если параметр AUTH не включен в команду MAIL FROM, клиент аутентифицирован и сервер полагает, что сообщение было изначально подано клиентом, сервер может указать «личность» клиента как addr-spec в параметре AUTH при трансляции сообщения любому серверу, который поддерживает расширение AUTH.</p><p>Если сервер не совсем доверяет аутентифицированной «личности» клиента или клиент попросту не аутентифицирован, сервер должен вести себя как при получении параметра AUTH=&lt;&gt;. Сервер может в таких случаях записать значение AUTH в системный журнал.</p><p>Если параметр AUTH=&lt;&gt; задан явно или в результате выполнения требований предыдущего параграфа, сервер должен указать параметр AUTH=&lt;&gt; при трансляции сообщения любому серверу, который поддерживает расширение AUTH.</p><p>Сервер может трактовать расширение списка рассылки как новую подачу, указывая в параметре AUTH адрес списка рассылки или администратора этого списка при трансляции сообщения получателям.</p><p>Реализация может трактовать всех клиентов как недостаточно доверенных в этом случае реализация не делает ничего кроме разбора и отбрасывания синтаксически корректных параметров AUTH команды MAIL FROM и указания AUTH=&lt;&gt; всем серверам, использующим расширение AUTH.</p><p>Примеры:</p><pre>C: MAIL FROM:&lt;e=mc2@example.com&gt; AUTH=e+3Dmc2@example.com
S: 250 OK</pre><h2>6. Коды ошибок</h2><p>Перечисленные ниже коды ошибок могут использоваться для индикации соответствующих условий.</p><ul><li class="b">432 A password transition is needed</li><li class="lib">Такой отклик на команду AUTH показывает, что пользователю нужно перейти к выбранному механизму аутентификации. Обычно это делается путем однократного использования механизма аутентификации PLAIN.</li><li class="b">534 Authentication mechanism is too weak</li><li class="lib">Этот отклик на команду AUTH показывает, что выбранный механизм аутентификации слабее, чем сервер может позволить для этого пользователя.</li><li class="b">538 Encryption required for requested authentication mechanism</li><li class="lib">Этот отклик на команду AUTH показывает, что выбранный механизм аутентификации может использоваться только для шифрованных соединений SMTP.</li><li class="b">454 Temporary authentication failure</li><li class="lib">Этот отклик на команду AUTH показывает, что аутентификация завершилась неудачей в результате временных проблем на сервере.</li><li class="b">530 Authentication required</li><li class="lib">Этот отклик может возвращаться любой командой, за исключением AUTH, EHLO, HELO, NOOP, RSET и QUIT. Он показывает, что политика сервера требует аутентификации для выполнения запрошенной операции.</li></ul><h2>7. Формальный синтаксис</h2><p>Спецификация формального синтаксиса использует расширенную нотацию Бэкуса-Наура (BNF), описанную в документе [ABNF].</p><p>За исключением явно указанных случаев регистр символов для букв не принимается во внимание. Использование строчных и прописных букв обусловлено исключительно наглядностью. Реализации должны принимать эти строки независимо от регистра символов.</p><pre>UPALPHA         = %x41-5A            ;; верхний регистр: A-Z

LOALPHA         = %x61-7A            ;; нижний регистр: a-z

ALPHA           = UPALPHA / LOALPHA  ;; регистр не имеет значения

DIGIT           = %x30-39            ;; цифры 0-9

HEXDIGIT        = %x41-46 / DIGIT    ;; шестнадцатеричные цифры (верхний регистр)

hexchar         = "+" HEXDIGIT HEXDIGIT

xchar           = %x21-2A / %x2C-3C / %x3E-7E
                  ;; символы US-ASCII за исключением "+", "=", пробела и CTL

xtext           = *(xchar / hexchar)

AUTH_CHAR       = ALPHA / DIGIT / "-" / "_"

auth_type       = 1*20AUTH_CHAR

auth_command    = "AUTH" SPACE auth_type [SPACE (base64 / "=")]
                  *(CRLF [base64]) CRLF

auth_param      = "AUTH=" xtext
                  ;; декодированная форма xtext ДОЛЖНА
                  ;; совпадать с addr-spec или "&lt;&gt;"

base64          = base64_terminal / ( 1*(4base64_CHAR) [base64_terminal] )

base64_char     = UPALPHA / LOALPHA / DIGIT / "+" / "/"
                  ;; регистр принимается во внимание

base64_terminal = (2base64_char "==") / (3base64_char "=")

continue_req    = "334" SPACE [base64] CRLF

CR              = %x0C           ;; ASCII CR (возврат каретки)

CRLF            = CR LF

CTL             = %x00-1F / %x7F ;; все коды управления ASCII, а также символ DEL

LF              = %x0A           ;; ASCII LF (перевод строки)

SPACE            = %x20          ;; ASCII SP (пробел)</pre><h2>8. Литература</h2><table itemprop="references"><tr><td>[ABNF]</td><td>Crocker, D. и P. Overell, «Augmented BNF for Syntax Specifications: ABNF», RFC 2234, Ноябрь 1997.</td></tr><tr><td>[CRAM-MD5]</td><td>Klensin, J., Catoe, R. и P. Krumviede, «IMAP/POP AUTHorize Extension for Simple Challenge/Response», RFC 2195, Сентябрь 1997.</td></tr><tr><td>[ESMTP]</td><td>Klensin, J., Freed, N., Rose, M., Stefferud, E. и D. Crocker, «SMTP Service Extensions», RFC 1869, Ноябрь 1995.</td></tr><tr><td>[ESMTP-DSN]</td><td>Moore, K, «SMTP Service Extension for Delivery Status Notifications», RFC 1891, Январь 1996.</td></tr><tr><td>[KEYWORDS]</td><td>Bradner, S., «Key words for use in RFCs to Indicate Requirement Levels», BCP 14, RFC 2119, Март 1997.</td></tr><tr><td>[SASL]</td><td>Myers, J., «Simple Authentication and Security Layer (SASL)», RFC 2222, October 1997.</td></tr><tr><td>[SUBMIT]</td><td>Gellens, R. и J. Klensin, «Message Submission», RFC 2476, Декабрь 1998.</td></tr><tr><td>[RFC821]</td><td>Postel, J., «Simple Mail Transfer Protocol», STD 10, RFC 821, Август 1982.</td></tr><tr><td>[RFC822]</td><td>Crocker, D., «Standard for the Format of ARPA Internet Text Messages», STD 11, RFC 822, Август 1982.</td></tr></table><h2>9. Вопросы безопасности</h2><p>В этом документе затрагиваются вопросы безопасности.</p><p>Если клиент использует это расширение для создания шифрованного туннеля через открытую сеть до корпоративного сервера требуется обеспечить такую настройку клиента, чтобы почта никогда не передавалась на этот сервер без соответствующей аутентификации и шифрования. В противном случае атакующий сможет красть клиентскую почту путем захвата соединений SMTP и ложной индикации отсутствия на сервере поддержки данного расширения или генерации ложных отказов от выполнения команд AUTH.</p><p>До начала согласования SASL все протокольные транзакции выполняются в открытом виде и могут быть изменены в результате активной атаки. По этой причине клиенты и серверы должны отбрасывать любые сведения, полученные до начала согласования SASL после того, как будет завершено SASL-согласование, приводящее к использованию защищенного уровня.</p><p>Этот механизм не защищает порт TCP, поэтому при активной атаке возможно перенаправить попытки соединения с портом транслятора в порт подачи сообщений [SUBMIT]. Параметр AUTH=&lt;&gt; предотвращает для таких атак возможность заставить транслируемое сообщение без аутентификации конверта «подбирать» аутентификацию клиента транслятора.</p><p>Клиент подачи сообщений может требовать от пользователя аутентификации всякий раз, когда анонсируется подходящий механизм SASL. Следовательно, для сервера подачи сообщений [SUBMIT] может оказаться нежелательным анонсирование механизма SASL в тех случаях, когда использование этого механизма не дает клиенту преимуществ по сравнению с анонимной подачей сообщений.</p><p>Это расширение не предназначено для замены сквозных систем поддержки цифровых подписей или шифрования типа S/MIME или PGP. Данное расширение предназначено для решения иных задач и ниже перечислены основные отличия от сквозных (end-toend) систем:</p><ol><li>данное расширение в общем случае полезно только на защищенных территориях;</li><li>это расширение защищает «конверт» сообщения в целом, а не только тело сообщения;</li><li>расширение аутентифицирует подачу сообщений, а не подтверждает авторство содержимого письма;</li><li>расширение может дать отправителю некоторые гарантии того, что сообщение будет доставлено на следующий этап (next hop) в тех случаях, когда отправитель имеет взаимную аутентификацию со следующим этапом и согласовал подходящий уровень безопасности.</li></ol><p>Дополнительное рассмотрение вопросов безопасности приводится в спецификации SASL [SASL].</p><h2>10. Адрес автора</h2><p>John Gardiner Myers<br />Netscape Communications<br />501 East Middlefield Road<br />Mail Stop MV-029<br />Mountain View, CA 94043<br />EMail: <bdo dir="rtl">&#109;&#111;&#99;&#46;&#101;&#112;&#97;&#99;&#115;&#116;&#101;&#110;&#64;&#115;&#114;&#101;&#121;&#109;&#103;&#106;</bdo></p></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 2554 - Расширение сервиса SMTP для аутентификации",disqus_identifier="2554.rfc",disqus_url="http://rfc2.ru/2554.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>