<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link rel="prev" href="45" /><link rel="next" href="47" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><title>Перевод RFC 2060 — Протокол IMAP v.4, rev. 1, стр. 46</title><meta name="author" content="M. Crispin" /><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../2060.rfc">RFC 2060 — Протокол IMAP v.4, rev. 1</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 2060</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank" rel="nofollow"><span itemprop="alternativeHeadline">Internet Message Access Protocol v.4 rev.1</span></a></dd><dd><div class="icon i7"></div> Другие версии: RFC 1730, <strong class="obsoleted_by">RFC 3501</strong></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Предложенный стандарт</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1996-12-01">Декабрь 1996</time></dd><dd><div class="icon i5"></div> Автор: <span itemprop="author">M. Crispin</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div class="pages"><p class="r"> <h2 class="pt"><span class="z">RFC 2060,</span> Страница 46 из 51</h2></p><ul><li><noindex><a href="print" rel="nofollow">Одной Страницей</a></noindex></li><li><a accesskey="1" title="Первая страница" href="../2060.rfc" class="arr">&lArr;</a></li><li><a accesskey="2" title="На страницу назад" href="45"><b>&larr;</b></a></li><li><a class="x" href="../2060.rfc">1</a></li><li><a class="x" href="2">2</a></li><li><a class="x" href="3">3</a></li><li><a class="x" href="4">4</a></li><li><a class="x" href="5">5</a></li><li><a class="x" href="6">6</a></li><li><a class="x" href="7">7</a></li><li><a class="x" href="8">8</a></li><li><a class="x" href="9">9</a></li><li><a class="x" href="10">10</a></li><li><a class="x" href="11">11</a></li><li><a class="x" href="12">12</a></li><li><a class="x" href="13">13</a></li><li><a class="x" href="14">14</a></li><li><a class="x" href="15">15</a></li><li><a class="x" href="16">16</a></li><li><a class="x" href="17">17</a></li><li><a class="x" href="18">18</a></li><li><a class="x" href="19">19</a></li><li><a class="x" href="20">20</a></li><li><a class="x" href="21">21</a></li><li><a class="x" href="22">22</a></li><li><a class="x" href="23">23</a></li><li><a class="x" href="24">24</a></li><li><a class="x" href="25">25</a></li><li><a class="x" href="26">26</a></li><li><a class="x" href="27">27</a></li><li><a class="x" href="28">28</a></li><li><a class="x" href="29">29</a></li><li><a class="x" href="30">30</a></li><li><a class="x" href="31">31</a></li><li><a class="x" href="32">32</a></li><li><a class="x" href="33">33</a></li><li><a class="x" href="34">34</a></li><li><a class="x" href="35">35</a></li><li><a class="x" href="36">36</a></li><li><a class="x" href="37">37</a></li><li><a class="x" href="38">38</a></li><li><a class="x" href="39">39</a></li><li><a class="x" href="40">40</a></li><li><a class="x" href="41">41</a></li><li><a href="42">42</a></li><li><a href="43">43</a></li><li><a href="44">44</a></li><li><a href="45">45</a></li><li class="this"><span>46</span></li><li><a href="47">47</a></li><li><a href="48">48</a></li><li><a href="49">49</a></li><li><a href="50">50</a></li><li><a class="x" href="51">51</a></li><li><a accesskey="3" title="На страницу вперед" href="47">&rarr;</a></li><li><a accesskey="4" title="Последняя страница" href="51">&rArr;</a></li></ul></div><div id="text" itemprop="articleBody"><h4 id="p7.4.2">7.4.2. Отклик FETCH</h4><table class="nobrd"><tr><td>Содержимое:</td><td>данные сообщения</td></tr></table><p>Отклик FETCH возвращает клиенту данные о сообщении. Данные представляются в виде пар имя — значение, заключенных в скобки. Этот отклик возвращается по команде в результате команд FETCH и STORE или по инициативе сервера (например, в результате обновления флагов).</p><p>Настоящая спецификация определяет следующие типы данных:</p><table class="nobrd"><tr><td>BODY</td><td>форма BODYSTRUCTURE без расширения данных</td></tr><tr><td>BODY[&lt;section&gt;]&lt;&lt;origin_octet&gt;&gt;</td><td>Строковое выражение содержимого тела указанной части сообщения. Клиенту следует интерпретировать строку в соответствии с типом транспортного кодирования содержимого, типом и подтипом тела. Если указан начальный октет, эта строка является подстрокой всего содержимого тела, начиная с<p>начального октета. Это значит, что BODY[]&lt;0&gt; можно усечь, а BODY[] усекать недопустимо. Допустимо использование 8-битовых текстовых данных, если идентификатор [CHARSET] является частью заключенного в скобки списка параметров тела для этой секции. Отметим, что заголовки (спецификаторы частей HEADER и MIME или части заголовка MESSAGE/RFC822) ДОЛЖНЫ быть 7-битовыми (8-битовые символы недопустимы в заголовках). Отметим также, что в данные заголовка всегда включается пустая строка в конце.</p><p>Нетекстовые (бинарные) данные ДОЛЖНЫ передаваться с использованием преобразования в текст (например, BASE64) до передачи клиенту. Для восстановления исходных двоичных данных клиент должен декодировать строку транспортного кодирования.</p></td></tr><tr><td>BODYSTRUCTURE</td><td>Заключенный в скобки список, который описывает структуру тела сообщения [MIMEIMB]. Этот список создается сервером в результате разбора полей заголовка [MIME-IMB] и включения при необходимости принятых по умолчанию значений. Например, простое текстовое сообщение из 48 строк и 2279 октетов имеет структуру тела: ("TEXT" "PLAIN" ("CHARSET" "US-ASCII") NIL NIL "7BIT" 2279 48). При наличии множества частей они указываются вложенными списками в скобках. Вместо типа тела первого элемента заключенного в скобки списка помещается вложенное тело. Вторым элементов списка в скобках является подтип multipart (mixed, digest, parallel, alternative и т. п.). Например, сообщение из 2 частей, содержащее текст и данные в формате BASE64 может иметь структуру тела: (("TEXT" "PLAIN" ("CHARSET" "US-ASCII") NIL NIL "7BIT" 1152 23)("TEXT" "PLAIN" ("CHARSET" "US-ASCII" "NAME" "cc.diff") "&lt;960723163407.20117h@cac.washington.edu&gt;" "Compiler diff" "BASE64" 4554 73) "MIXED")) После подтипа multipart следует расширение данных. Это расширение никогда не возвращается в выборках BODY но может содержаться в выборках BODYSTRUCTURE. При наличии расширенных данных они должны размещаться в приведенном ниже порядке.<ul><li>body parameter parenthesized list</li><li class="lib">Заключенный в скобки список пар «атрибут-значение» (например, ("foo" "bar" "baz" "rag"), где "bar" является значением атрибута "foo", а "rag" — значением "baz") в соответствии с [MIME-IMB].</li><li>body disposition</li><li class="lib">Заключенный в скобки список, который содержит строку типа размещения, за которой следует заключенный в скобки список пар «атрибут размещения — значение». Типы размещения и имена атрибутов будут определены в будущей версии предложенного стандарта [DISPOSITION].</li><li>body language</li><li class="lib">Строка или заключенный в скобки список, указывающие язык тела в соответствии с [LANGUAGETAGS].</li></ul><p>Все последующие данные еще не определены в данной версии протокола. Такие расширения данных могут содержать 0 или более значений NIL, строк, чисел и потенциально вложенных заключенных в скобки списков таких данных. Реализации клиентов, использующие выборки BODYSTRUCTURE ДОЛЖНЫ быть готовы к восприятию расширенных данных такого типа. Для серверов недопустима передача таких расширений, пока они не будут определены при пересмотре данного протокола.</p><p>Базовые поля для тел, не содержащих множества частей (non-multipart body) имеют следующий порядок:</p><ul><li>body type</li><li class="lib">Строка, указывающая название типа среды в соответствии с [MIME-IMB].</li><li>body subtype</li><li class="lib">Строка, указывающая имя подтипа в соответствии с [MIME-IMB].</li><li>body parameter parenthesized list</li><li class="lib">Заключенный в скобки список пар «атрибут-значение» (например, ("foo" "bar" "baz" "rag"), где "bar" является значением атрибута "foo", а "rag" — значением "baz") в соответствии с [MIME-IMB].</li><li>body id</li><li class="lib">Строка, указывающая идентификатор содержимого в соответствии с [MIME-IMB].</li><li>body description</li><li class="lib">Строка, описывающая содержимое в соответствии с [MIME-IMB].</li><li>body encoding</li><li class="lib">Строка, указывающая транспортное кодирование в соответствии с [MIME-IMB].</li><li>body size</li><li class="lib">Число, показывающее размер тела в октетах. Отметим, что это число показывает размер для транспортного кодирования, а не размер после декодирования.</li></ul><p>Тело типа MESSAGE или подтипа RFC822 содержит сразу же после основных полей структуру конверта, структуру тела и размер текстовых строк инкапсулированного сообщения.</p><p>Тело типа TEXT содержит сразу же после основных полей размер и собственно тело в форме текстовых строк. Отметим, что поле размера задается для транспортного кодирования, а не для содержимого после декодирования.</p><p>После основных полей и перечисленных выше полей, связанных с конкретными типами сообщений, следуют поля расширения. Эти поля никогда не возвращаются в выборке BODY, но могут возвращаться выборкой BODYSTRUCTURE. При использовании расширенных данных они ДОЛЖНЫ размещаться в приведенном ниже порядке (для тел, не содержащих множества частей):</p><ul><li>body MD5</li><li class="lib">Строка, дающая значение MD5 в соответствии с определением [MD5].</li><li>body disposition</li><li class="lib">Список в скобках таким же содержимым и функциями, как расположение тела для multipart body part.</li><li>body language</li><li class="lib">Строка или заключенный в скобки список, указывающие язык тела сообщения в соответствии с [LANGUAGE-TAGS].</li></ul><p>Все последующие расширения данных еще не определены в этой версии протокола и описываются как данные multipart-расширений.</p></td></tr><tr><td>ENVELOPE</td><td>Заключенный в скобки список, описывающий структуру конверта в сообщении. Этот список создается сервером путем разбора заголовка [RFC-822] на составные части и включения при необходимости принятых по умолчанию значений. Поля в структуре конверта располагаются в следующем порядке: date, subject, from, sender, reply-to, to, cc, bcc, in-reply-to, and message-id. Поля date, subject, in-reply-to и message-id представляют собой текстовые строки, поля from, sender, reply-to, to, cc, bcc — заключенные в скобки списки адресных структур.<p>Адресная структура представляет собой заключенный в скобки список, который описывает адрес электронной почты. Поля структуры располагаются в следующем порядке: personal name, [SMTP] at-domainlist (source route), mailbox name, host name.</p><p>Групповой синтаксис [RFC-822] указывается специальной формой адресной структуры, в которой имя хоста имеет значение NIL. Если имя почтового ящика также имеет значение NIL, это говорит о маркере окончания группы (точка с запятой в синтаксисе RFC 822). Если имя почтового ящика отличается от NIL, это говорит о маркере начала группы и поле имени почтового ящика содержит имя группы.</p><p>Любые неприменимые поля конверта или адресной структуры содержат значение NIL. Отметим, что сервер должен по умолчанию брать значения полей reply-to и sender из поля from; предполагается, что клиент не обязан их знать.</p></td></tr><tr><td>FLAGS</td><td>Заключенный в скобки список флагов, установленных для сообщения.</td></tr><tr><td>INTERNALDATE</td><td>Строка, представляющая внутреннюю дату сообщения.</td></tr><tr><td>RFC822</td><td>Эквивалент BODY[].</td></tr><tr><td>RFC822.HEADER</td><td>Эквивалент BODY.PEEK[HEADER].</td></tr><tr><td>RFC822.SIZE</td><td>Число, выражающее размер [RFC-822] для сообщения.</td></tr><tr><td>RFC822.TEXT</td><td>Эквивалент BODY[TEXT].</td></tr><tr><td>UID</td><td>Число, выражающее уникальный идентификатор сообщения.</td></tr></table><pre>Пример:  S: * 23 FETCH (FLAGS (\Seen) RFC822.SIZE 44827)</pre></div></div><noindex><div class="pages"><p class="r"> <b>Страница 46 из 51</b></p><ul><li><noindex><a href="print" rel="nofollow">Одной Страницей</a></noindex></li><li><a title="Первая страница" href="../2060.rfc" class="arr">&lArr;</a></li><li><a title="На страницу назад" href="45"><b>&larr;</b></a></li><li><a class="x" href="../2060.rfc">1</a></li><li><a class="x" href="2">2</a></li><li><a class="x" href="3">3</a></li><li><a class="x" href="4">4</a></li><li><a class="x" href="5">5</a></li><li><a class="x" href="6">6</a></li><li><a class="x" href="7">7</a></li><li><a class="x" href="8">8</a></li><li><a class="x" href="9">9</a></li><li><a class="x" href="10">10</a></li><li><a class="x" href="11">11</a></li><li><a class="x" href="12">12</a></li><li><a class="x" href="13">13</a></li><li><a class="x" href="14">14</a></li><li><a class="x" href="15">15</a></li><li><a class="x" href="16">16</a></li><li><a class="x" href="17">17</a></li><li><a class="x" href="18">18</a></li><li><a class="x" href="19">19</a></li><li><a class="x" href="20">20</a></li><li><a class="x" href="21">21</a></li><li><a class="x" href="22">22</a></li><li><a class="x" href="23">23</a></li><li><a class="x" href="24">24</a></li><li><a class="x" href="25">25</a></li><li><a class="x" href="26">26</a></li><li><a class="x" href="27">27</a></li><li><a class="x" href="28">28</a></li><li><a class="x" href="29">29</a></li><li><a class="x" href="30">30</a></li><li><a class="x" href="31">31</a></li><li><a class="x" href="32">32</a></li><li><a class="x" href="33">33</a></li><li><a class="x" href="34">34</a></li><li><a class="x" href="35">35</a></li><li><a class="x" href="36">36</a></li><li><a class="x" href="37">37</a></li><li><a class="x" href="38">38</a></li><li><a class="x" href="39">39</a></li><li><a class="x" href="40">40</a></li><li><a class="x" href="41">41</a></li><li><a href="42">42</a></li><li><a href="43">43</a></li><li><a href="44">44</a></li><li><a href="45">45</a></li><li class="this"><span>46</span></li><li><a href="47">47</a></li><li><a href="48">48</a></li><li><a href="49">49</a></li><li><a href="50">50</a></li><li><a class="x" href="51">51</a></li><li><a title="На страницу вперед" href="47">&rarr;</a></li><li><a title="Последняя страница" href="51">&rArr;</a></li></ul></div></noindex><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 2060 - Протокол IMAP v.4, rev. 1",disqus_identifier="2060.rfc",disqus_url="http://rfc2.ru/2060.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>