<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../4251.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 4251 — Архитектура протокола SSH</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../4251.rfc">RFC 4251 — Архитектура протокола SSH</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 4251</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank"><span itemprop="alternativeHeadline">SSH Protocol Architecture</span></a></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Предложенный стандарт</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="2006-01-01">Январь 2006</time></dd><dd><div class="icon i5"></div> Авторы: <span itemprop="author">Tatu Ylonen</span>, <span itemprop="author">Chris Lonvick</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div id="text" itemprop="articleBody"><h3>Статус документа</h3><p>В этом документе содержится спецификация протокола, предложенного сообществу Internet. Документ служит приглашением к дискуссии в целях развития и совершенствования протокола. Текущее состояние стандартизации протокола вы можете узнать из документа "Internet Official Protocol Standards" (STD 1). Документ может распространяться без ограничений.</p><h3>Тезисы</h3><p>Протокол SSH (Secure Shell) используется для организации безопасного входа в удаленную систему (login) и организации иных безопасных служб через сети, не обеспечивающие безопасности. В данном документе описана архитектура протокола SSH, а также нотация и терминология, используемые в документах, посвященных протоколу SSH. Описывается также алгоритм именования SSH, поддерживающий локализованные расширения.</p><p>Протокол SSH состоит из трех основных компонент. Протокол транспортного уровня (Transport Layer Protocol) обеспечивает аутентификацию серверов, конфиденциальность и целостность и высоким уровнем защищенности. Протокол аутентификации пользователей (User Authentication Protocol) используется на серверах для проверки полномочий клиентов. Протокол соединений (Connection Protocol) обеспечивает мультиплексирование шифрованного туннеля в несколько логических каналов. Детальные описания каждого из этих протоколов содержатся в отдельных документах.</p><h2>Оглавление</h2><ul class="map"><li><a href="print#p1" title="Введение">1. Введение</a></li><li><a href="print#p2" title="Разработчики">2. Разработчики</a></li><li><a href="print#p3" title="Используемые в документе соглашения">3. Используемые в документе соглашения</a></li><li><a href="print#p4" title="Архитектура">4. Архитектура</a></li><li class="lia"><a href="print#p4.1" title="Ключи хостов">4.1. Ключи хостов</a></li><li class="lia"><a href="print#p4.2" title="Возможности расширения">4.2. Возможности расширения</a></li><li class="lia"><a href="print#p4.3" title="Политика">4.3. Политика</a></li><li class="lia"><a href="print#p4.4" title="Параметры безопасности">4.4. Параметры безопасности</a></li><li class="lia"><a href="print#p4.5" title="Локализация и поддержка различных наборов символов">4.5. Локализация и поддержка различных наборов символов</a></li><li><a href="print#p5" title="Представление типов данных, используемых в протоколах SSH">5. Представление типов данных, используемых в протоколах SSH</a></li><li><a href="print#p6" title="Имена алгоритмов и методов">6. Имена алгоритмов и методов</a></li><li><a href="print#p7" title="Номера сообщений">7. Номера сообщений</a></li><li><a href="print#p8" title="Согласование с IANA">8. Согласование с IANA</a></li><li><a href="print#p9" title="Вопросы безопасности">9. Вопросы безопасности</a></li><li class="lia"><a href="print#p9.1" title="Генерация псевдослучайных чисел">9.1. Генерация псевдослучайных чисел</a></li><li class="lia"><a href="print#p9.2" title="Фильтрация управляющих символов">9.2. Фильтрация управляющих символов</a></li><li class="lia"><a href="print#p9.3" title="Транспорт">9.3. Транспорт</a></li><li class="lib"><a href="print#p9.3.1" title="Конфиденциальность">9.3.1. Конфиденциальность</a></li><li class="lib"><a href="print#p9.3.2" title="Целостность данных">9.3.2. Целостность данных</a></li><li class="lib"><a href="print#p9.3.3" title="Использование перехваченных данны">9.3.3. Использование перехваченных данных (Replay)</a></li><li class="lib"><a href="print#p9.3.4" title="Перехват с участием человека">9.3.4. Перехват с участием человека (Man-in-the-middle)</a></li><li class="lib"><a href="print#p9.3.5" title="DoS-атаки">9.3.5. DoS-атаки</a></li><li class="lib"><a href="print#p9.3.6" title="Скрытые каналы">9.3.6. Скрытые каналы</a></li><li class="lib"><a href="print#p9.3.7" title="Сохранность тайн">9.3.7. Сохранность тайн</a></li><li class="lib"><a href="print#p9.3.8" title="Упорядочивание методов обмена ключами">9.3.8. Упорядочивание методов обмена ключами</a></li><li class="lib"><a href="print#p9.3.9" title="Анализ трафика">9.3.9. Анализ трафика</a></li><li class="lia"><a href="print#p9.4" title="Протокол аутентификации">9.4. Протокол аутентификации</a></li><li class="lib"><a href="print#p9.4.1" title="Проблема небезопасного транспорта">9.4.1. Проблема небезопасного транспорта</a></li><li class="lib"><a href="print#p9.4.2" title="Отладочные сообщения">9.4.2. Отладочные сообщения</a></li><li class="lib"><a href="print#p9.4.3" title="Локальная политика безопасности">9.4.3. Локальная политика безопасности</a></li><li class="lib"><a href="print#p9.4.4" title="Аутентификация с использованием открытых ключей">9.4.4 Аутентификация с использованием открытых ключей</a></li><li class="lib"><a href="print#p9.4.5" title="Парольная аутентификация">9.4.5. Парольная аутентификация</a></li><li class="lib"><a href="print#p9.4.6" title="Аутентификация по хостам">9.4.6. Аутентификация по хостам</a></li><li class="lia"><a href="print#p9.5" title="Протокол соединений">9.5. Протокол соединений</a></li><li class="lib"><a href="print#p9.5.1" title="Безопасность конечных точек">9.5.1. Безопасность конечных точек</a></li><li class="lib"><a href="print#p9.5.2" title="Перенаправление">9.5.2. Перенаправление</a></li><li class="lib"><a href="print#p9.5.3" title="Перенаправление трафика X11">9.5.3. Перенаправление трафика X11</a></li><li><a href="print#p10" title="Литература">10. Литература</a></li><li class="lia"><a href="print#p10.1" title="Нормативные документы">10.1. Нормативные документы</a></li><li class="lia"><a href="print#p10.2" title="Дополнительная литература">10.2. Дополнительная литература</a></li></ul><h2 id="p1">1. Введение</h2><p>Протокол SSH используется для организации безопасного входа в удаленную систему (login) и организации иных безопасных служб через сети, не обеспечивающие безопасности. Протокол включает три основных компоненты:</p><ul class="dot"><li>Протокол транспортного уровня [SSH-TRANS] обеспечивает аутентификацию серверов, конфиденциальность и целостность. Этот протокол может также обеспечивать сжатие информации. Транспортный уровень работает в основном с использованием соединений TCP/IP, но может быть реализован и на базе иных потоков данных с гарантированной доставкой.</li><li>Протокол аутентификации пользователей [SSH-USERAUTH] используется на серверах для проверки полномочий клиентов. Этот протокол работает на основе протокола транспортного уровня.</li><li>Протокол соединений [SSH-CONNECT] обеспечивает мультиплексирование шифрованного туннеля в несколько логических каналов и работает поверх протокола аутентификации пользователей.</li></ul><p>Клиент передает один запрос на обслуживание в процессе организации защищенного соединения на транспортном уровне. Другой запрос на обслуживание передается после успешной проверки полномочий клиента. Такое решение обеспечивает возможность создания новых протоколов и их совместного использования с перечисленными выше протоколами.</p><p>Протокол соединений обеспечивает каналы, которые могут использоваться для решения целого ряда задач. Обеспечиваются стандартные методы для организации защищенных shell-сессий и перенаправления («туннелирования») произвольных портов TCP/IP
и соединений X11.</p><h2 id="p2">2. Разработчики</h2><p>Основными разработчиками этого комплекта документов являются: Tatu Ylonen, Tero Kivinen, Timo J. Rinne, Sami Lehtinen (все из SSH Communications Security Corp) и Markku-Juhani O. Saarinen (университет Jyvaskyla). Darren Moffat был редактором этого комплекта документов и внес важный вклад в работу.</p><p>За годы подготовки этого документа множество людей внесло свой вклад. В их число входят: Mats Andersson, Ben Harris, Bill Sommerfeld, Brent McClure, Niels Moller, Damien Miller, Derek Fawcus, Frank Cusack, Heikki Nousiainen, Jakob Schlyter, Jeff Van Dyke, Jeffrey Altman, Jeffrey Hutzelman, Jon Bright, Joseph Galbraith, Ken Hornstein, Markus Friedl, Martin Forssen, Nicolas Williams, Niels Provos, Perry Metzger, Peter Gutmann, Simon Josefsson, Simon Tatham, Wei Dai, Denis Bider, der Mouse и Tadayoshi Kohno. Указанные в списке люди могли не участвовать в написании данного документа, но они внесли свой вклад в его подготовку.</p><h2 id="p3">3. Используемые в документе соглашения</h2><p>Во всех документах, связанных с протоколом SSH, следует использовать ключевые слова: необходимо (MUST), недопустимо (MUST NOT), требуется (REQUIRED), нужно (SHALL), не нужно (SHALL NOT), следует (SHOULD), не следует (SHOULD NOT), рекомендуется (RECOMMENDED), возможно (MAY), необязательно (OPTIONAL) для описания уровня требования. Интерпретация этих слов описана в [RFC2119].</p><p>Ключевые слова приватное использование (PRIVATE USE), иерархическое выделение (HIERARCHICAL ALLOCATION), выделение в соответствии с порядком запросов (FIRST COME FIRST SERVED), экспертное рассмотрение (EXPERT REVIEW), требуется спецификация (SPECIFICATION REQUIRED), одобрение IESG (IESG APPROVAL), согласование с IETF (IETF CONSENSUS), стандартизация (STANDARDS ACTION) в данном документе при их использовании в контексте распределения пространства имен интерпретируются в соответствии с [RFC2434].</p><p>В данном наборе документов определяются поля протокола и возможные значения этих полей. Поля будут определяться в определениях протокольных сообщений. Например, поле SSH_MSG_CHANNEL_DATA определяется следующим образом.</p><pre>byte      SSH_MSG_CHANNEL_DATA
uint32    recipient channel (канал получателя)
string    data (данные)</pre><p>В данном документе поля протокола будут указываться в одинарных кавычках, а значения полей — в двойных. В приведенном выше примере поле 'data' может содержать значения "foo" и "bar".</p><h2 id="p4">4. Архитектура</h2><h3 id="p4.1">4.1. Ключи хостов</h3><p>Каждому серверному хосту следует иметь ключ (host key). Хосты могут иметь множество ключей, созданных с использованием различных алгоритмов. Возможно использование одного ключа множеством хостов. Если хост имеет ключи, он должен обеспечивать по крайней мере один ключ, который использует каждый из требуемых алгоритмов открытых ключей (DSS [FIPS-186-2]).</p><p>Ключ сервера используется в процессе обмена ключами для подтверждения того, что клиент реально связывается с нужным сервером. Для того, чтобы такая проверка стала возможной, клиент должен заранее знать открытый ключ сервера.</p><p>Могут использоваться две модели поддержки ключей:</p><ul class="dot"><li>Клиент поддерживает локальную базу данных, в которой содержатся имена всех хостов (указанные пользователем) и соответствующие открытые ключи. Этот метод не требует создания инфраструктуры централизованного управления или сторонней координации. Недостатком данного метода является трудоемкость поддержки ассоциаций между ключами и именами хостов.</li><li>Ассоциации между ключами и хостами сертифицируются специальным агентством CA (Certification Authority). Клиент знает только ключ корневого CA и может проверить все ключи хостов, сертифицированные приемлемыми агентствами CA.</li></ul><p>Второй вариант упрощает задачу поддержки, поскольку клиенту нужно хранить единственный ключ CA. С другой стороны, в этом варианте требуется централизованная сертификация каждого хоста прежде, чем станет возможной процедура проверки полномочий. Кроме того требуется обеспечить высокий уровень для централизованной инфраструктуры сертификации.</p><p>Протокол позволяет отключить проверку ассоциации «сервер — ключ» при первом подключении к хосту. Это позволяет организовать соединение с хостом до получения от него ключа или сертификации хоста. При таком соединении обеспечивается защита от пассивного прослушивания, но существует уязвимость для активного перехвата с участием человека. Реализациям в общем случае не следует разрешать такие соединения по умолчанию, поскольку они могут снижать уровень безопасности. Однако по причине отсутствия в сети Internet широко доступной структуры обмена ключами на момент написания документа эта опция может оказаться весьма полезной в переходный период, пока такая инфраструктура не будет создана, и обеспечит значительно более высокий уровень безопасности, нежели более старые решения (например, telnet [RFC0854] и rlogin [RFC1282]).</p><p>Реализациям протокола следует предпринимать разумные меры по проверке ключей хостов. Примером возможной стратегии может служить принятие ключа без проверки только при первом соединении с хостом, сохранение полученного ключа в локальной базе данных и его использование при каждом последующем подключении к данному хосту.</p><p>Реализации могут обеспечивать дополнительные возможности по проверке корректности ключей хостов (например, использование шестнадцатеричных «отпечатков», полученных хэша открытого ключа с помощью алгоритма SHA-1 [FIPS-180-2]). Такие «отпечатки» можно легко проверить по телефону или с использованием другого коммуникационного канала.</p><p>Всем реализациям следует обеспечивать опцию для запрета принятия непроверенных ключей хостов.</p><p>Члены рабочей группы полагают, что простота использования играет важную роль при выборе безопасных решений конечными пользователями и уровень безопасности не станет выше, если не будут применяться новые решения. Таким образом можно предполагать, что обеспечение опции, позволяющей отказаться от проверки ключа, будет повышать общий уровень безопасности в сети Internet, несмотря на локальное снижение уровня безопасности протокола в тех случаях, когда проверка отключена.</p><h3 id="p4.2">4.2. Возможности расширения</h3><p>Мы полагаем, что протокол будет использоваться достаточно долго и некоторые организации захотят использовать свои методы шифрования, аутентификации и обмена ключами. Централизованная регистрация всех расширений весьма обременительна, особенно для экспериментальных или засекреченных вариантов. С другой стороны, отсутствие централизованной регистрации будет приводить к конфликтам с идентификацией методов, осложняющим взаимодействие реализаций протокола.</p><p>Мы выбрали вариант идентификации алгоритмов, методов, форматов и расширений протокола с помощью текстовых имен, использующих определенный формат. Имена DNS используются для создания локальных пространств имен, где могут определяться экспериментальные или засекреченные расширения без возникновения конфликтов с другими реализациями.</p><p>Одной из задач является обеспечение максимальной простоты базового протокола и использование минимального числа алгоритмов. Однако все реализации должны поддерживать минимальный набор алгоритмов для обеспечения интероперабельности (это не означает, что локальная политика на каждом хосте должна обеспечивать поддержку этих алгоритмов). Обязательные алгоритмы указываются в соответствующих протокольных документах.</p><p>Дополнительные алгоритмы, методы, форматы и протоколы расширения могут определяться в отдельных документах. Дополнительная информация по этому вопросу содержится в разделе 6 (Алгоритм и метод именования).</p><h3 id="p4.3">4.3. Политика</h3><p>Протокол допускает полное согласование алгоритмов и форматов шифрования, обеспечения целостности, обмена ключами, сжатия данных и открытых ключей. Алгоритмы шифрования, обеспечения целостности, сжатия и открытых ключей могут отличаться для каждого из направлений.</p><p>Приведенные ниже правила следует использовать в механизмах настройки конфигурационных параметров каждой реализации:</p><ul class="dot"><li>Алгоритмы шифрования, обеспечения целостности и сжатия данных задаются раздельно для каждого направления. Политика должна задавать предпочтительный алгоритм (например, перевый алгоритм из списка для каждой категории).</li><li>Алгоритм открытых ключей и метод обмена ключами, используемые для аутентификации хоста. Существование доверенных ключей хостов для различных алгоритмов открытых ключей также должно приниматься во внимание.</li><li>Методы аутентификации, требуемые сервером от каждого пользователя. Политика сервера может требовать несколько методов аутентификации для некоторых или всех пользователей. Набор обязательных алгоритмов может зависеть от местонахождения пользователя, пытающегося получить доступ.</li><li>Операции, которые пользователю дозволено выполнять с применением протокола соединений. Некоторые аспекты политики могут быть связаны с безопасностью — например, не следует позволять серверу инициировать сессии или выполнять команды на клиентской машине и недопустимо разрешать соединения с агентом аутентификации, если не запрошено перенаправление таких соединений. Иные аспекты (такие, как возможность и назначение перенаправления портов TCP/IP) определяются локальной политикой. Многие из таких аспектов могут быть связаны с прохождением или обходом межсетевых экранов и в той или иной степени связаны с локальной политикой безопасности.</li></ul><h3 id="p4.4">4.4. Параметры безопасности</h3><p>Основной задачей протокола SSH является повышение уровня безопасности в Internet. Протокол пытается сделать это обеспечением максимальной простоты даже за счет некоторого снижения уровня безопасности.</p><ul class="dot"><li>Все алгоритмы шифрования, обеспечения целостности и открытых ключей относятся к числу известных и проверенных.</li><li>Все алгоритмы используются с криптографически обоснованным размером ключей, который позволяет надеяться на обеспечение защиты от самых мощных криптоаналитических атак в течение десятилетий.</li><li>Все алгоритмы согласуются и в тех случаях, когда тот или иной алгоритм не поддерживается, обеспечивается простой переход к использованию другого алгоритма без изменения базового протокола.</li></ul><p>Будут предприниматься специальные меры для того, чтобы упростить широкое и быстрое развертывание протокола. Частным случаем таких мер является возможность работы протокола без проверки ключа хоста при первом подключении, однако такая мера не рекомендуется. Предполагается, что принимаемые меры помогут значительно расширить использование протокола в короткие сроки, пока не будет широко развернута инфраструктура обмена открытыми ключами в сети Internet.</p><h3 id="p4.5">4.5. Локализация и поддержка различных наборов символов</h3><p>В большинстве случаев протоколы SSH не будут непосредственно передавать текст, отображаемый пользователю. Однако в некоторых случаях такие данные могут передаваться. В тех случаях, когда это применимо, набор символов для данных должен указываться явно. В большинстве случаев используется кодировка ISO-10646 UTF-8 [RFC3629]. В тех случаях, когда это применимо, обеспечивается также поле для тега языка [RFC3066].</p><p>Достаточно сложным является вопрос выбора набора символов для интерактивных сессий. Здесь нет очевидного решения, поскольку разные приложения могут отображать данные в различных форматах. У клиентов также могут быть установлены разнотипные эмуляторы терминалов и используемый набор символов будет определяться этим эмулятором. В таких случаях нет возможности прямого задания набора символов или кодировки данных для терминальных сессий. Однако тип эмулятора терминала (например, "vt100") передается удаленному сайту и неявно задает набор символов и кодировку. Приложения обычно используют тип терминала для определения применяемого набора символов с помощью тех или иных дополнительных средств. Эмулятор терминала может также поддерживать выбор используемого по умолчанию набора символов. В любом случае выбор набора символов для терминальной сессии рассматривается прежде всего как локальная задача клиента.</p><p>Внутренние имена, используемые для идентификации алгоритмов и протоколов, обычно не отображаются для пользователя и
должны содержать символы набора US-ASCII.</p><p>Требования к именам пользователей для сервера и клиентов определяются возможностями сервера. Однако в некоторых случаях эти имена могут отображаться в журнальных файлах, отчетах и т. п. В именах должен использоваться набор символов ISO 10646 UTF-8, но в некоторых случаях может потребоваться иная кодировка. Сервер сам определяет способ отображения имен пользователей в поддерживаемые сервером имена. Рекомендуется использовать прямое сравнение битов.</p><p>В целях локализации для протокола предприняты попытки минимизации числа передаваемых текстовых сообщений. Сохраненные для протокола сообщения этого типа обычно связаны с ошибками, отладочной информацией и некоторыми задаваемыми извне данными. Для отображаемой информации следует обеспечить возможность выбора локализованных сообщений взамен сообщений, передаваемых протоколом с использованием цифровых кодов. Остальные сообщения следует сделать настраиваемыми.</p><h2 id="p5">5. Представление типов данных, используемых в протоколах SSH</h2><ul class="dot"><li>byte</li><li class="lib">Байт представляет собой произвольное 8-битовое значение (октет). Данные фиксированного размера в некоторых случаях представляются как массивы байтов byte[n], где n показывает число байтов в массиве.</li><li>boolean</li><li class="lib">Логические значения сохраняются в одном бите. Значение 0 представляет логическое значение FALSE (ложь), а 1 — логическое значение TRUE (истина). Любые отличные от 0 значения должны интерпретироваться как TRUE, однако для приложений недопустимо использование для логических переменных каких-либо значений, кроме 0 и 1.</li><li>uint32</li><li class="lib">Представляет 32-битовое целое число без знака. Переменные этого типа сохраняются в четырех байтах с уменьшением значимости (сетевой порядок). Например, значение 699921578 (0x29b7f4aa) будет иметь байтовое представление 29 b7 f4 aa.</li><li>uint64</li><li class="lib">Представляет 64-битовое целое число без знака. Переменные этого типа сохраняются в восьми байтах с уменьшением значимости (сетевой порядок).</li><li>string</li><li class="lib">Двоичная строка произвольной длины. Строки могут содержать любые бинарные данные, включая 0-символ и 8-битовые символы. Строки хранятся в виде переменной типа uint32, указывающей размер (число байтов) и последовательности (возможно нулевой длины) байтов, содержащих отдельные символы строки. Завершающих 0-символов для строк не используется.<br />Строки также служат для хранения текста. В этом случае для внутренних имен используется набор символов US-ASCII, а для текста, отображаемого пользователю, служит набор символов ISO-10646 UTF-8. Завершающий 0-символ в общем случае не следует включать в строку. Например, строка US-ASCII "testing" будет представлена, как 00 00 00 07 t e s t i n g. Отображение UTF-8 не изменяет представление символов набора US-ASCII.</li><li>mpint</li><li class="lib">Представляет целые числа в формате дополнения до 2, сохраняемые как строки байтов (старший байт сначала). Отрицательные значения задаются 1 в старшем бите первого байта строки данных. Если старший бит имеет значение 0 (положительное число), все остальные биты также должны иметь значение 0 (собственно число начинается со второго байта). Недопустимо использование значений с незначимыми старшими байтами, установленным в 0 или 255. Нулевое значение должно сохраняться как строка нулевой длины.<p>По соглашению число, используемое в расчетах по модулю n (Z_n), следует представлять значением из диапазона 0 &lt;= x &lt; n.</p><p>Пример:</p><pre>значение (hex)     представление (hex)
---------------    -------------------
0                  00 00 00 00
9a378f9b2e332a7    00 00 00 08 09 a3 78 f9 b2 e3 32 a7
80                 00 00 00 02 00 80
-1234              00 00 00 02 ed cc
-deadbeef          00 00 00 05 ff 21 52 41 11</pre></li><li>name-list</li><li class="lib">Строка, содержащая список разделенных запятыми имен. Такие списки представляются значением типа uint32, показывающим длину списка (число байтов), за которым следует список (возможно пустой) разделенных запятыми (,) имен. Имена в списке должны иметь отличную от 0 длину, недопустимо включать в имена символ запятой (","). Поскольку этот тип является списком имен, все элементы списка должны быть представлены набором символов US-ASCII. В зависимости от контекста к именам в списке могут предъявляться дополнительные требования. Например, имена в списке могут быть корректными идентификаторами алгоритмов (см. раздел 6) или тегами языков [RFC3066]. Порядок имен в списке может иметь значение, но это не обязательно и зависит от контекста использования списка. Недопустимо использование завершающих null-символов ни в отдельных именах, ни в списке в целом.<p>Пример:</p><pre>значение                   представление (hex)
--------                   -------------------
(), the empty name-list    00 00 00 00
("zlib")                   00 00 00 04 7a 6c 69 62
("zlib,none")              00 00 00 09 7a 6c 69 62 2c 6e 6f 6e 65</pre></li></ul><h2 id="p6">6. Имена алгоритмов и методов</h2><p>Протоколы SSH обозначают конкретные алгоритмы и методы хеширования, шифрования, обеспечения целостности, сжатия и обмена ключами по именам. Существуют некоторые стандартные алгоритмы и методы, которые должны поддерживаться всеми реализациями. Существуют также алгоритмы и методы, которые включены в спецификацию протокола, но являются необязательными. Кроме того следует ожидать, что некоторые организации пожелают использовать свои алгоритмы и методы.</p><p>В этом протоколе все идентификаторы алгоритмов и методов должны быть непустыми строками печатаемых символов из набора US-ASCII, не превышающими по размеру 64 символов. Регистр символов в именах должен приниматься во внимание.</p><p>Существует два формата представления имен алгоритмов и методов:</p><ul class="dot"><li>Имена, не содержащие символа @, зарезервированы и выделяются по согласованию с IETF. Примерами таких имен могут служить "3des-cbc", "sha-1", "hmac-sha1", "zlib" (кавычки не являются частью имен). Имена в таком формате корректны только после их регистрации в IANA. Недопустимо включение в регистрируемые имена символов @, запятых (,), пробелов, управляющих символов (коды ASCII до 32 включительно) и символов ASCII с кодом 127 (DEL). Регистр символов в именах принимается во внимание, недопустимы имена размером более 64 символов.</li><li>Каждый может определять дополнительные имена алгоритмов и методов в формате name@domainname (например, "ourciphercbc@example.com". Формат левой части имени (до символа @) не задается спецификацией, однако эта часть должна быть строкой печатаемых символов US-ASCII и недопустимо включение в имена запятых (,), пробелов, символов управления (коды ASCII до 32 включительно) и символов с кодом ASCII 127 (DEL). Имя должно включать единственные символ @. Правая часть имени (после символа @) должна быть корректным полным доменным именем [RFC1034], контролируемым персоной или организацией, определяющей имя с этим доменом. Регистр символов в именах принимается во внимание, недопустимы имена размером более 64 символов. Каждый домен сам определяет способы управления своим пространством имен. Следует отметить, что эти имена похожи на определенные в STD 11 [RFC0822] адреса электронной почты. Однако это сходство является только  нешним и имена никак не связаны с STD 11 [RFC0822].</li></ul><h2 id="p7">7. Номера сообщений</h2><p>Пакеты SSH используют номера сообщений от 1 до 255. Эти номера распределены между различными компонентами:</p><ul class="dot"><li>Протокол транспортного уровня:<ul><li>1 - 19 — базовые сообщения транспортного уровня (например, disconnect, ignore, debug и т. п.)</li><li>20 - 29 — согласование алгоритма</li><li>30 - 49 — сообщения, связанные с обменом ключами (допускается совпадение номеров для разных методов аутентификации).</li></ul></li><li>Протокол аутентификации пользователей:<ul><li>50 - 59 — базовые сообщения протокола аутентификации</li><li>60 - 79 — сообщения, связанные с методом аутентификации (допускается совпадение номеров для различных методов).</li></ul></li><li>Протокол соединений:<ul><li>80 - 89 — базовые сообщения протокола</li><li>90 - 127 — сообщения, связанные с каналом.</li></ul></li><li>Зарезервировано для клиентских протоколов:<ul><li>128 - 191 - резерв</li></ul></li><li>Локальные расширения:<ul><li>192 - 255 — локальные расширения.</li></ul></li></ul><h2 id="p8">8. Согласование с IANA</h2><p>Этот документ является частью набора документов, задающих спецификацию протокола. Инструкции по взаимодействию с IANA относительно протокола SSH, определенные в данном документе, [SSH-USERAUTH], [SSH-TRANS] и [SSH-CONNECT], детализированы в [SSH-NUMBERS]. Далее для удобства приведена краткая информация, но реальные инструкции по взаимодействию с IANA, содержащиеся в [SSH-NUMBERS], могут впоследствии изменить или отменить написанное здесь.</p><p>Выделение перечисленных ниже типов имен для протокола SSH осуществляется по согласованию с IETF:</p><ul class="dot"><li>Имена служб:<ul class="dot"><li>методы аутентификации;</li><li>имена каналов протокола соединений;</li><li>имена глобальных запросов протокола соединений;</li><li>имена запросов канала протокола соединений.</li></ul></li><li>Названия методов обмена ключами.</li><li>Имена алгоритмов:<ul class="dot"><li>алгоритмы шифрования;</li><li>алгоритмы MAC;</li><li>алгоритмы открытых ключей;</li><li>алгоритмы сжатия данных.</li></ul></li></ul><p>Имена должны указываться с использованием набора символов US-ASCII, недопустимо включение в имена символов @, запятых, пробелов, символов управления (коды ASCII до 32 включительно), и символов ASCII с кодом 127 (DEL). Регистр символов в именах принимается во внимание; недопустимы имена размером более 64 символов.</p><p>Имена с символом @ являются локальными расширениями и не контролируются IANA.</p><p>Каждая из перечисленных выше категорий использует независимое пространство имен. Однако использования совпадающих имен в различных категориях следует избегать, чтобы не возникало путаницы.</p><p>Номера сообщений (см. раздел 7) в диапазоне от 0 до 191 выделяются по согласованию с IETF, как описано в [RFC2434]. Номера
сообщений от 192 до 255 (локальные расширения) зарезервированы для приватного использования, как описано в [RFC2434].</p><h2 id="p9">9. Вопросы безопасности</h2><p>В целях улучшения восприятия этот раздел содержит информацию по вопросам безопасности из документов, посвященных транспорту, аутентификации и соединениям.</p><p>Транспортный протокол [SSH-TRANS] обеспечивает поддержку конфиденциальных каналов через сети, не обеспечивающие безопасности. Этот протокол выполняет операции по аутентификации серверных хостов, обмену ключами, шифрованию и обеспечению целостности. Этот протокол также обеспечивает уникальный идентификатор сессии, который может использоваться протоколами вышележащих уровней.</p><p>Протокол аутентификации [SSH-USERAUTH] обеспечивает набор механизмов, который позволяет проверить полномочия пользователя на сервере. Отдельные механизмы протокола аутентификации используют идентификатор сессии, предоставленный транспортным протоколом и/или зависят от гарантий безопасности и целостности, предоставляемых транспортным протоколом.</p><p>Протокол соединений [SSH-CONNECT] задает механизм мультиплексирования множества потоков (каналов) данных через одно конфиденциальное доверенное транспортное соединение. Этот протокол также поддерживает каналы для доступа к интерактивным сеансам (shell), доставки данных различных внешних протоколов (включая любые протоколы TCP/IP) с использованием безопасного транспорта и доступа к системе к системе обеспечения безопасности серверного хоста.</p><h3 id="p9.1">9.1. Генерация псевдослучайных чисел</h3><p>Этот протокол связывает с каждым сеансом свой ключ (session key), используя случайные данные, связанные с сеансом в хэше, служащем для создания сеансовых ключей. Следует принимать специальные меры по обеспечению «высокого качества» случайных чисел. Если случайные данные (например, параметры Diffie-Hellman) являются псевдо-случайными, следует использовать криптографически защищенный генератор случайных чисел (т. е., следующий результат не должен быть предсказуемым на основе предыдущих результатов даже в тех случаях, когда известен их полный набор) с подходящим уровнем энтропии. [RFC4086] содержит рекомендации по выбору источников случайных чисел и энтропии. Разработчикам следует принимать во внимание важность энтропии и не забывать о сложностях реализации функций генерации псевдослучайных чисел.</p><p>Уровень энтропии, доступный для данного клиента или сервера, может в некоторых случаях оказаться недостаточным. В таких случаях следует воспользоваться генератором псевдослучайных, несмотря на недостаток энтропии, или отвергнуть использование протокола. Второй вариант является более предпочтительным.</p><h3 id="p9.2">9.2. Фильтрация управляющих символов</h3><p>При выводе текста для пользователя (сообщения об ошибках или отладочная информация) клиентским программам следует заменять все управляющие символы (за исключением табулятора, перевода строки и возврата каретки) безопасными последовательностями для предотвращения атак, организуемых путем передачи управляющих символов.</p><h3 id="p9.3">9.3. Транспорт</h3><h4 id="p9.3.1">9.3.1. Конфиденциальность</h4><p>В число задач этого документа и группы Secure Shell WG не входит анализ или рекомендации по выбору шифров, отличающихся от тех, которые уже разработаны и приняты в отрасли. На момент создания документа к таким шифрам относятся методы 3DES, ARCFOUR, twofish, serpent и blowfish. Алгоритм AES был опубликован The US Federal Information Processing Standards как [FIPS-197] и принят в качестве одного из стандартных методов шифрования. Как всегда разработчикам и пользователям следует обратиться к современной литературе для того, чтобы убедиться в отсутствии уязвимостей в алгоритме или его реализациях. Разработчикам следует также посмотреть какие алгоритмы считаются более сильными по сравнению с другими и рекомендовать пользователям применение более сильных алгоритмов. Хорошим тоном для разработчиков является вежливое и ненавязчивое уведомление пользователей о существовании более сильных алгоритмов шифрования при выборе пользователем более слабого алгоритма.</p><p>Режим шифрования "none" поддерживается для отладки, поэтому этим режимом не следует пользоваться для иных целей. Криптографические свойства этого режима достаточно подробно описаны в [RFC2410] т тз этого документа можно сделать вывод о неприменимости данного режима для протокола SSH.</p><p>Сравнение этих и других алгоритмов шифрования также можно найти в современной литературе. В качестве примеров таких публикаций укажем работы [SCHNEIER] и [KAUFMAN]. Оба эти документа описывают CBC-режим использования некоторых шифров и недостатки этой схемы. Важно отметить, что этот режим теоретически уязвим для атак chosen cipher-text по причине достаточно высокой предсказуемости стартовых последовательностей пакетов. Однако такие атаки достаточно сложны и не могут считаться применимыми на практике особенно в случаях использования блоков большого размера.</p><p>Атаки против режима CBC можно также предотвратить путем вставки пакетов, содержащих сообщение SSH_MSG_IGNORE. Без использования этого метода некоторые атаки могут приводить к успеху. Для того, чтобы данный тип атак (обычно их называют Rogaway-атаками [ROGAWAY], [DAI], [BELLARE]) работал, атакующему нужно знать вектор инициализации IV блока, который будет шифроваться следующим. В режиме CBC это результат шифрования предыдущего блока. Если атакующий не имеет возможности вовремя увидеть пакет (например, пакет находится в буфере модуля SSH или даже в ядре), атака не достигнет успеха.</p><p>Если пакет будет передан в сеть, к которой атакующий имеет доступ, атака может оказаться успешной.</p><p>В оптимальном варианте от разработчика требуется добавление только одного пакета, если пакет уже передан в сеть и нет других пакетов, ожидающих передачи. Разработчики могут проверить наличие пакетов ожидающих передачи, однако получение такой информации от ядра или буферов может оказаться достаточно сложной задачей. Если ожидающие передачи пакеты отсутствуют, следует передавать пакет, содержащий SSH_MSG_IGNORE. Если новый пакет будет добавляться в поток всякий раз, атакующий, даже зная IV (который по его предположению будет использоваться для шифрования следующего пакета), не сможет корректно предсказать IV и атака, таким образом, не достигнет успеха.</p><p>Рассмотрим пример:</p><pre>Клиент                                                  Сервер
------                                                  ------
TCP(seq=x, len=500)             ---->
 содержит запись Record 1

                    [прошло 500 ms, пакета ACK нет]

TCP(seq=x, len=1000)            ---->
 содержит запись Records 1,2

                                                          ACK</pre><ol><li>Алгоритм Nagle в купе с алгоритмом повтора передачи TCP подразумевают возможность включения двух записей в один сегмент TCP.</li><li>Запись Record 2 не находится в начале сегмента и никогда не будет там, поскольку она уже подтверждена с помощью ACK.</li><li>Возможность атаки сохраняется, поскольку запись Record уже передана в сеть.</li></ol><p>Этот пример показывает опасность опасность использования имеющихся в буфере TCP неотправленных данных в качестве признака необходимости передачи пустого пакета, поскольку в этом случае на момент повторного вызова write() в буфере содержится неподтвержденная запись Record 1.</p><p>Показанная ниже ситуация является совершенно безопасной:</p><pre>Клиент                                                  Сервер
------                                                  ------
TCP(seq=x, len=500)             ---->
   содержит SSH_MSG_IGNORE

TCP(seq=y, len=500)             ---->
   содержит данные (Data)</pre><p>В предположении, что IV для второй записи SSH Record фиксировано после получения данных для пакета Data, нужно выполнить следующие операции:</p><ul><li>чтение пользовательских данных;</li><li>шифрование пустого пакета;</li><li>шифрование пакета данных.</li></ul><h4 id="p9.3.2">9.3.2. Целостность данных</h4><p>Данный протокол позволяет отключить механизм проверки целостности данных (Data Integrity). Разработчикам следует с осторожностью относится к возможности использования этой функции для каких-либо целей за исключением отладки. Пользователей и администраторов следует явно предупреждать при выборе значения "none" для MAC.</p><p>Если не используется опция "none" для MAC, данный протокол обеспечивает целостность данных.</p><p>Поскольку MAC использует 32-битовый порядковый номер, возможна утечка информации после передачи 2^32 пакетов. Однако выполнение рекомендации по регенерации ключей должно предотвратить возможность таких атак. Спецификация транспортного протокола [SSH-TRANS] рекомендует менять ключ (rekeying) после передачи 1 Гигабайта данных, а минимальный размер пакета составляет 16 байтов. Следовательно, смена ключей при таких условиях должна произойти до того, как будет передано 2^28 пакетов.</p><h4 id="p9.3.3">9.3.3. Использование перехваченных данных (Replay)</h4><p>Использование для MAC опций, отличных от "none", обеспечивает целостность данных и аутентификацию. В дополнение к этому транспортный протокол обеспечивает уникальный идентификатор сессии (связанный с псевдослучайными данными, которые являются частью алгоритма и процесса обмена ключами), который может использоваться протоколами вышележащего уровня для привязки данных к текущей сессии и предотвращения случаев воспроизведения данных, перехваченных из других сессий. Например, протокол аутентификации [SSH-USERAUTH] использует идентификатор сессии для предотвращения повторного использования сигнатур предыдущих сеансов. Поскольку обмен открытыми ключами криптографически связан с текущей сессией (т. е, начальным обменом ключами), перехваченные сигнатуры невозможно повторно использовать в других сессиях. Отметим, что идентификатор сессии можно делать открытым без снижения уровня безопасности протокола.</p><p>Если две сессии имеют одинаковые идентификаторы (хэш обмена ключами), пакеты из одной сессии могут использоваться в другой. Следует подчеркнуть, что вероятность такого совпадения при использовании современных методов криптографии является минимальной. Дополнительное снижение этой вероятности может обеспечиваться увеличением размерности результата хэш-функции и параметров DH.</p><p>Детектирование попыток использования перехваченных данных с использованием монотонного роста порядковых номеров на входе MAC (или HMAC в некоторых случаях_ рассматривается в документах [RFC2085], [RFC2246], [RFC2743], [RFC1964], [RFC2025], [RFC4120]. Основа этих методов описана в документе [RFC2104]. Существенно, что различие порядковых номеров в каждом пакете гарантирует, что по крайней мере один аргумент (input) MAC-функции будет уникальным и обеспечит неповторяющийся результат MAC, который не может быть предсказан атакующим. Если сессия длится достаточно долго, порядковые номера могут начать повторяться. Такой повтор может дать атакующему возможность повторного использования ранее записанных пакетов с идентичными порядковыми номерами, но такая ситуация возможна только в тех случаях, когда партнеры не используют повторной генерации ключей до того, как начнется повтор порядковых номеров. Если партнеры выполнили регенерацию ключей, повторное использование пакетов будет обнаружено, поскольку проверка MAC даст отрицательный результат. По этой причине необходимо сделать упор на то, что партнеры должны выполнить регенерацию ключей до того, как начнется повтор порядковых номеров. Естественно, если атакующий будет пытаться повторно использовать собранные пакеты до того, как партнеры проведут регенерацию ключей, получатель дубликата не получит корректное значение MAC и пакет будет отброшен. Причина некорректности результата MAC в таких случаях обусловлена тем, что получатель будет создавать MAC на основе принятого пакета, разделяемого ключа (shared secret) и ожидаемого порядкового номера. Поскольку используемый повторно пакет не имеет ожидаемого порядкового номера (пакет с таким номером уже был принят получателем), рассчитанное значение MAC не будет соответствовать значению из принятого пакета.</p><h4 id="p9.3.4">9.3.4. Перехват с участием человека (Man-in-the-middle)</h4><p>Протокол не включает предположений о распространении открытых ключей хостов, требований к инфраструктуре обмена ключами или методам их распространения. Предполагается, что протокол в некоторых случаях будет использоваться без предварительной проверки достоверности связи между ключом и именем хоста. Такое использование уязвимо для атак с участием человек (man-in-the-middle attack). В этом параграфе рассматривается данная проблема и даются рекомендации для администраторов и пользователей по вопросам важности проверки связи между ключом и именем хоста до начала первого сеанса.</p><p>Существует три варианта атак на протокол с использованием перехвата с участием человека. В первом случае атакующий размещает устройство перехвата на пути между клиентом и сервером до начала сеанса. В этом случае устройство пытается прикинуться легитимным сервером и будет предлагать клиенту свой ключ в начале сеанса. Если устройство станет предлагать реальный ключ сервера, оно не сможет расшифровать или подписать данные, передаваемые между клиентом и легитимным сервером, пока не получит доступа к закрытому ключу (private key) хоста. Используемое для атаки устройство одновременно будет инициировать сессию с легитимным сервером, маскируя себя под клиента. Если открытый ключ сервера был до начала сессии получен клиентом с помощью безопасного канала, предложенный используемым для атаки устройством ключ не будет соответствовать ключу сервера, хранящемуся у клиента. В таким случае пользователю следует выдавать предупреждение о несоответствии ключей. Как указано в параграфе 4.1, пользователь волен принять предложенный ключ и продолжить сессию. Рекомендуется включать в предупреждение о несоответствии ключей информацию, которая позволит пользователю клиентского хоста принять обдуманное решение.</p><p>Если пользователь выберет продолжение сессии с хранящимся у него открытым ключом сервера (вместо ключа, предложенного в начале сеанса), связанные с этим сеансом данные, передаваемые между атакующим и сервером будут отличаться от данных, передаваемых между атакующим и клиентом в силу описанного выше использования случайных чисел. В результате атакующий не сможет добиться своей цели, поскольку он не сможет корректно подписывать пакеты, содержащие связанные с сессией данные от сервера, поскольку ему неизвестен закрытый ключ сервера.</p><p>Второй вариант похож на первый и также основан на перехвате на этапе организации соединения, но этот случай подчеркивает важность безопасного распространения открытых ключей. Если для открытого ключа сервера не обеспечивается безопасное распространение, клиент не может удостовериться в том, что он соединился с нужным сервером. Атакующий может воспользоваться мошенническими методами (social engineering) для передачи ключей ничего не подозревающим пользователям и после этого поместить устройство перехвата на пути между клиентом и легитимным сервером. В этом случае клиент просто соединится с устройством атакующего, а атакующий организует соединение с легитимным сервером и сможет организовать мониторинг данных от клиента и сервера, а также манипулировать этими данными. Администраторам серверов рекомендуется делать «отпечатки» ключей доступными для проверки с помощью тех или иных средств, безопасность которых не влияет на целостность реальных ключей. Возможные механизмы обсуждались в параграфе 4.1 и могут также включать защищенные Web-страницы, передачу на бумажных носителях и т. п. Разработчикам следует обеспечивать рекомендации по эффективному использованию таких мер с их реализациями. Поскольку протокол является расширяемым, в будущих версиях могут обеспечиваться более эффективные методы распространения ключей серверов до организации первого соединения. Например, могут создаваться отпечатки ключей доступные через безопасные серверы DNS или использоваться Kerberos ([RFC4120]) через GSS-API ([RFC1964]) в процессе обмена ключами для аутентификации сервера.</p><p>В третьем варианте атакующий может попытаться манипулировать пакетами в процессе их передачи между партнерами после организации сеанса. Как описано в параграфе 9.3.3, вероятность успеха при таких атаках весьма мала. Как и для описанного в параграфе 9.3.3 случая причина низкой вероятности успеха при такой атаке обусловлена тем, алгоритм MAC является достаточно безопасным и нереально подобрать входные данные для алгоритма MAC, чтобы получить на выходе желаемый результат. Более детальное обсуждение этого вопроса приводится в разделе 6 [RFC2104]. Если алгоритм MAC имеет уязвимости или достаточно слаб, атакующий может оказаться способен задать те или иные данные на входе для получения известного значения MAC. Используя это, он сможет изменить передаваемые через сеть пакеты. Кроме того, атакующий может воспользоваться уязвимостью алгоритма или его слабостью для определения разделяемого ключа (shared secret) путем просмотра MAC в захваченных пакетах. В любом из этих случаев атакующий сможет создавать пакеты и помещать их в поток SSH. Для предотвращения этого разработчикам следует использовать общепринятые проверенные алгоритмы MAC, а администраторам следует читать современную литературу и дискуссии для того, чтобы вовремя узнавать о найденных в используемых алгоритмах MAC уязвимостях или недостатках.</p><p class="note">В заключение отметим, что использование этого протокола без надлежащей проверки связи между хостами и их ключами, не обеспечивает должного уровня безопасности и не рекомендуется. Однако такое использование может оказаться необходимым для сред, где безопасность не играет критически важной роли и обеспечивается защита от пассивных атак. Разработчикам протоколов и использующих их приложений следует принимать этот факт во внимание.</p><h4 id="p9.3.5">9.3.5. DoS-атаки</h4><p>Этот протокол предназначен для работы на основе надежного транспорта. При возникновении ошибок передачи или манипуляции сообщениями соединение закрывается. В таких случаях следует предпринять попытку восстановитть соединение. Атак этого типа («обрыв провода») почти невозможно избежать.</p><p>В дополнение к сказанному данный протокол уязвим для атак на службы (denial of service attack), при которых атакующий может вывести сервер из строя за счет потребления ресурсов процессора и памяти путем организации множества соединений и обмена ключами без аутентификации. Разработчикам следует принимать меры по осложнению таких атак (например, разрешая соединения лишь для ограниченного числа известных клиентов.</p><h4 id="p9.3.6">9.3.6. Скрытые каналы</h4><p>Протокол не включает мер предотвращения скрытых каналов. Например, поля заполнения (padding), сообщения SSH_MSG_IGNORE и некоторые другие места могут использоваться для передачи скрытой информации, для которой не существует надежного способа обнаружения на принимающей стороне.</p><h4 id="p9.3.7">9.3.7. Сохранность тайн</h4><p>Следует отметить, что алгоритм обмена ключами Diffie-Hellman (DH) может обеспечивать PFS. PFS определяется как криптографическое свойство протокола организации ключей, при котором компрометация сеансового ключа или долгосрочного закрытого ключа после завершения сессии не ведет к компрометации более ранних сессий [ANSI-T1.523-2001]. Сессии SSH, основанные на обмене ключами с использованием методов DH, описанные в разделе «Обмен ключами по методу Diffie-Hellman» документа [SSH-TRANS] (включая "diffie-hellman-group1-sha1" и "diffie-hellman-group14-sha1") обеспечивают безопасность даже при последующем раскрытии ключей или данных аутентификации. Следовательно, протокол SSH обеспечивает PFS. Однако это свойство не передается каким-либо приложениям или протоколам, использующим SSH как транспорт. Транспортный уровень SSH обеспечивает конфиденциальность аутентификации и других методов, основанных на секретных данных.</p><p>Естественно при раскрытии параметров DH для клиента или сервера раскрываются сеансовые ключи, но они не представляют ценности после завершения обмена ключами. Это лишний раз подчеркивает, что такие элементы не должны сбрасываться в область подкачки и их следует удалять из памяти после завершения обмена ключами.</p><h4 id="p9.3.8">9.3.8. Упорядочивание методов обмена ключами</h4><p>Как сказано в разделе «Согласование алгоритма» документа [SSH-TRANS], каждое устройство будет передавать список предпочтительных методов обмена ключами. Наиболее предпочтительный метод указывается в списке первым. Рекомендуется сортировать алгоритмы по силе криптографических методов, размещая первым наиболее сильный. Некоторые рекомендации по этому вопросу содержатся в документе [RFC3766].</p><h4 id="p9.3.9">9.3.9. Анализ трафика</h4><p>Пассивный мониторинг любого протокола может дать атакующему некоторую информацию о сессии, пользователе, протоколе, которую не удалось бы получить иным путем. Например, показано, что анализ трафика SSH-сессии позволяет получить информацию о размере пароля — [Openwall] и [USENIX].Разработчикам следует использовать пакеты SSH_MSG_IGNORE вкупе с заполнением случайной длины для осложнения попыток анализа трафика. Для этих же целей могут использоваться и другие методы.</p><h3 id="p9.4">9.4. Протокол аутентификации</h3><p>Задачей этого протокола является аутентификация пользователей. Предполагается, что этот протокол работает на основе безопасного протокола транспортного уровня, который уже обеспечил аутентификацию сервера, организовал шифрованный коммуникационный канал и создал уникальный идентификатор для данной сессии.</p><p>Допускается использование нескольких методов аутентификации с различными параметрами безопасности. Выбор методов аутентификации (или их комбинации), дозволенных каждому пользователю определяется локальной политикой сервера. Уровень аутентификации не превышает уровень наиболее слабой из допустимых комбинаций методов.</p><p>Сервер может «засыпать» после нескольких неудачных попыток аутентификации для того, чтобы осложнить атакующему поиск ключа. Следует принимать меры, чтобы в таких не возникала возможность организации DoS-атак.</p><h4 id="p9.4.1">9.4.1. Проблема небезопасного транспорта</h4><p>Если транспортный уровень не обеспечивает конфиденциальности, методы аутентификации, основанные на секретных данных, следует отключить. Если не обеспечивается достаточной защиты целостности, следует отключить запросы на изменение параметров аутентификации (например, смена паролей) для предотвращения возможности незаметной подмены атакующим шифрованного текста или блокирования им возможности использования новых параметров аутентификации (DoS-атака).</p><p>Приведенное выше допущение о том, что протокол аутентификации использует только защищенный транспорт, имеет очень важное значение. При развертывании систем SSH не следует забывать о пагубных последствиях MITM-атак в тех случаях, когда у клиента нет способа достаточно надежно проверить связь ключа с сервером до начала сессии. В частности, применительно к протоколу аутентификации, клиент может организовать соединение с устройством перехвата, используемым атакующим, и выдать последнему используемые для аутентификации сведения (в частности, имя пользователя и пароль). Даже в тех случаях, когда используемые для аутентификации данные не будут раскрыты, атакующий может получить информацию, перехватывая данные о нажатии клавиш, подобно тому, как это делается в приманках (honeypot).</p><h4 id="p9.4.2">9.4.2. Отладочные сообщения</h4><p>Следует с осторожностью подходить к созданию отладочных сообщений. Эти сообщения могут раскрывать информацию о хосте, если к их содержанию не отнестись должным образом. Отладочные сообщения могут быть отключены (на этапе аутентификации пользователя), если требуется обеспечить высокий уровень безопасности. Администраторам хостов следует принять все возможные меры по изоляции всех уведомлений о событиях и их защите от просмотра нежелательными лицами. Разработчикам следует внимательно отнестись к возможности раскрытия информации через некоторые вполне обыденные события или отладочные сообщения. Неплохо также подготовить рекомендации для администраторов по методам предотвращения доступа к такой информации нежелательным лицам. Разработчикам следует предусмотреть возможность минимизировать с помощью локальной политики объем критичной к раскрытию информации, передаваемой пользователю на этапе аутентификации. Для решения этой задачи рекомендуется по умолчанию отключать выдачу отладочных сообщений и разрешать их включение только в результате целенаправленных действий администратора. Рекомендуется также обеспечивать выдачу администратору соответствующего предупреждения в тех случаях, когда он разрешает выдачу отладочных сообщений.</p><h4 id="p9.4.3">9.4.3. Локальная политика безопасности</h4><p>Разработчики должны обеспечить проверку пользователя на основании представленных им данных, а также возможность применения локальной политики сервера для этого пользователя. По причине гибкости протокола SSH может отсутствовать возможность определения локальной политики безопасности, которую следует применять во время аутентификации, поскольку в этот момент невозможно установить тип запрашиваемого пользователем сервиса. Например, локальная политика может разрешать пользователю доступ к файлам на сервере, но не разрешать доступ к командному процессору (interactive shell). Однако при работе протокола аутентификации неизвестно, что собирается делать пользователь — работать с файлами, использовать командный процессор или выполнять оба типа операций. В любом случае при существовании на сервере локальной политики она должна применяться корректно.</p><p>Разработчикам рекомендуется обеспечивать принятую по умолчанию локальную политику и делать ее параметры известными администраторам и пользователям. По усмотрению разработчиков эта локальная политика может разрешать пользователям выполнение любых операций или вносить ограничения в действия пользователей — администраторы могут изменить установленную по умолчанию политику в соответствии с реальными задачами. Возможен также вариант, когда принятая по умолчанию политика основана на практическом опыте и может помочь администраторам, не имеющим достаточного опыта работы с SSH. В любом случае политика должна применяться и реализаваться в соответствии с описанными выше требованиями.</p><h4 id="p9.4.4">9.4.4 Аутентификация с использованием открытых ключей</h4><p>Использование для аутентификации открытых ключей предполагает, что клиентский хост не компрометирован. Предполагается также отсутствие компрометации для закрытого ключа сервера.</p><p>В целях ослабления риска можно можно использовать для закрытых ключей дополнительные пароли (passphrase), однако это не реализуется на основе политики. Предлагается использовать смарт-карты или иные технологии для согласования парольных фраз с политикой.</p><p>Сервер может требовать одновременно пароль и открытый ключ, однако это требование ведет к тому, что пользовательский пароль становится известным серверу (см. следующий параграф).</p><h4 id="p9.4.5">9.4.5. Парольная аутентификация</h4><p>Парольный механизм, как задано протоколом аутентификации, предполагает, что сервер не компрометирован. При компрометации сервера использование парольной аутентификации будет раскрывать атакующему комбинации имен пользователей и паролей, что может вести к дальнейшему возрастанию риска.</p><p>Эту уязвимость можно преодолеть за счет использования другой формы аутентификации. Например, аутентификация на основе открытых ключей не делает допущений об уровне безопасности сервера.</p><h4 id="p9.4.6">9.4.6. Аутентификация по хостам</h4><p>Аутентификация по хостам предполагает, что клиентские хосты не компрометированы. Для этого варианта не существует стратегий снижения риска кроме использования аутентификации по хостам в комбинации с другими методами аутентификации.</p><h3 id="p9.5">9.5. Протокол соединений</h3><h4 id="p9.5.1">9.5.1. Безопасность конечных точек</h4><p>Безопасность конечных точек предполагается для протокола соединений. При компрометации сервера все терминальные сессии, перенаправление портов или доступ в систему также подвергаются компрометации. Способов предотвращения этого риска нет.</p><p>При компрометации клиента, если серверу не удается остановить атаку на уровне протокола аутентификации, все показанные службы (подсистемы и перенаправление) становятся уязвимыми для атаки. Разработчикам следует обеспечивать для администраторов механизмы управления доступными службами для снижения уровня уязвимости. Такие механизмы могут включать выбор хостов и портов, которые могут использоваться в качестве цели перенаправления, хостов, к которым пользователи получают shell-лоступ или на которых разрешается показанные подсистемы.</p><h4 id="p9.5.2">9.5.2. Перенаправление</h4><p>Протокол SSH поддерживает перенаправление (proxy forwarding) для других протоколов типа SMTP, POP3 и HTTP. Это может представлять интерес для сетевых администраторов, которые заинтересованы в контроле доступа удаленных пользователей к некоторым приложениям. Важно отметить, что перенаправление протоколов может приводить к нарушению политики безопасности для сайта, поскольку позволяет организовать незаметные туннели через межсетевые экраны. Разработчикам следует обеспечивать для администраторов механизмы контроля перенаправдения, позволяющие обеспечить выполнение политики безопасности для сайтов.</p><p>Кроме того, возможно обратное перенаправление, которое также позволяет обходить контроль в межсетевых экранах.</p><p>Как было сказано выше перенаправление предполагает безопасность конечных точек. Компрометация конечной точки будет приводить к компрометации всех данных, передаваемых с использованием перенаправления.</p><h4 id="p9.5.3">9.5.3. Перенаправление трафика X11</h4><p>Другой формой перенаправдения, обеспечиваемого протоколом соединений SSH, является перенаправление для протокола X11. При нарушении системы безопасности конечной точки перенаправление X11 может открыть возможность для атаки на сервер X11. Пользователям и администраторам следует применять соответствующие механизмы обеспечения безопасности X11 для предотвращения несанкционированного доступа к серверам X11. Разработчикам, администраторам и пользователям, желающим повысить уровень безопасности X11 рекомендуется прочесть документ [SCHEIFLER] и проанализировать известные проблемы для случаев использования SSH пересылки с X11 в бюллетенях CERT VU#363181 и VU#118892 [CERT].</p><p>X11-дисплей, использующий пересылку SSH сам по себе не может решить проблем, связанных с безопасностью X11 [VENEMA]. Однако пересылка X11 с использованием SSH (или иного безопасного протокола) в комбинации с псевдодисплеями, принимающими соединения только через локальные механизмы IPC, использующими авторизацию или списки контроля доступа (ACL), могут решить большинство проблем с безопасностью X11, если для MAC не используется режим "none". Разработчикам дисплеев X11 рекомендуется по умолчанию разрешать отображение только через локальные IPC. Разработчикам серверов SSH, поддерживающих перенаправление X11 рекомендуется по умолчанию разрешать соединения только через локальные IPC. На однопользовательских системах может оказаться разумным открывать по умолчанию также соединения через TCP/IP.</p><p>Разработчикам протоколов перенаправления X11 следует реализовать для контроля доступа механизм magic cookie, описанный в [SSH-CONNECT], в качестве дополнительного средства предотвращения несанкционированного использования прокси-сервера.</p><h2 id="p10">10. Литература</h2><h3 id="p10.1">10.1. Нормативные документы</h3><table itemprop="references"><tr><td>[SSH-TRANS]</td><td>Ylonen, T. и C. Lonvick, Ed., «The Secure Shell (SSH) Transport Layer Protocol», RFC 4253, Январь 2006.</td></tr><tr><td>[SSH-USERAUTH]</td><td>Ylonen, T. и C. Lonvick, Ed., «The Secure Shell (SSH) Authentication Protocol», RFC 4252, Январь 2006.</td></tr><tr><td>[SSH-CONNECT]</td><td>Ylonen, T. и C. Lonvick, Ed., «The Secure Shell (SSH) Connection Protocol», RFC 4254, Январь 2006.</td></tr><tr><td>[SSH-NUMBERS]</td><td>Lehtinen, S. и C. Lonvick, Ed., «The Secure Shell (SSH) Protocol Assigned Numbers», RFC 4250, Январь 2006.</td></tr><tr><td>[RFC2119]</td><td>Bradner, S., «Key words for use in RFCs to Indicate Requirement Levels», BCP 14, RFC 2119, Март 1997.</td></tr><tr><td>[RFC2434]</td><td>Narten, T. и H. Alvestrand, «Guidelines for Writing an IANA Considerations Section in RFCs», BCP 26, RFC 2434, October 1998.</td></tr><tr><td>[RFC3066]</td><td>Alvestrand, H., «Tags for the Identification of Languages», BCP 47, RFC 3066, Январь 2001.</td></tr><tr><td>[RFC3629]</td><td>Yergeau, F., «UTF-8, a transformation format of ISO 10646», STD 63, RFC 3629, Ноябрь 2003.</td></tr></table><h3 id="p10.2">10.2. Дополнительная литература</h3><table itemprop="references"><tr><td>[RFC0822]</td><td>Crocker, D., «Standard for the format of ARPA Internet text messages», STD 11, RFC 822, Август 1982.</td></tr><tr><td>[RFC0854]</td><td>Postel, J. и J. Reynolds, «Telnet Protocol Specification», STD 8, RFC 854, Май 1983.</td></tr><tr><td>[RFC1034]</td><td>Mockapetris, P., «Domain names - concepts and facilities», STD 13, RFC 1034, Ноябрь 1987.</td></tr><tr><td>[RFC1282]</td><td>Kantor, B., «BSD Rlogin», RFC 1282, Декабрь 1991.</td></tr><tr><td>[RFC4120]</td><td>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, «The Kerberos Network Authentication Service (V5)», RFC 4120, Июль 2005.</td></tr><tr><td>[RFC1964]</td><td>Linn, J., «The Kerberos Version 5 GSS-API Mechanism», RFC 1964, Июнь 1996.</td></tr><tr><td>[RFC2025]</td><td>Adams, C., «The Simple Public-Key GSS-API Mechanism (SPKM)», RFC 2025, October 1996.</td></tr><tr><td>[RFC2085]</td><td>Oehler, M. и R. Glenn, «HMAC-MD5 IP Authentication with Replay Prevention», RFC 2085, Февраль 1997.</td></tr><tr><td>[RFC2104]</td><td>Krawczyk, H., Bellare, M., and R. Canetti, «HMAC: Keyed-Hashing for Message Authentication», RFC 2104, Февраль 1997.</td></tr><tr><td>[RFC2246]</td><td>Dierks, T. и C. Allen, <a href="../2246.rfc" title="RFC 2246 - Протокол TLS 1.0">«Протокол TLS 1.0», RFC 2246</a>, Январь 1999</td></tr><tr><td>[RFC2410]</td><td>Glenn, R. и S. Kent, «The NULL Encryption Algorithm and Its Use With IPsec», RFC 2410, Ноябрь 1998.</td></tr><tr><td>[RFC2743]</td><td>Linn, J., «Generic Security Service Application Program Interface Version 2, Update 1», RFC 2743, Январь 2000.</td></tr><tr><td>[RFC3766]</td><td>Orman, H. и P. Hoffman, «Determining Strengths For Public Keys Used For Exchanging Symmetric Keys», BCP 86, RFC3766, Апрель 2004.</td></tr><tr><td>[RFC4086]</td><td>Eastlake, D., 3rd, Schiller, J., and S. Crocker, «Randomness Requirements for Security», BCP 106, RFC 4086, Июнь 2005.</td></tr><tr><td>[FIPS-180-2]</td><td>US National Institute of Standards and Technology, «Secure Hash Standard (SHS)», Federal Information Processing Standards Publication 180-2, Август 2002.</td></tr><tr><td>[FIPS-186-2]</td><td>US National Institute of Standards and Technology, «Digital Signature Standard (DSS)», Federal Information Processing Standards Publication 186-2, Январь 2000.</td></tr><tr><td>[FIPS-197]</td><td>US National Institute of Standards and Technology, «Advanced Encryption Standard (AES)», Federal Information Processing Standards Publication 197, Ноябрь 2001.</td></tr><tr><td>[ANSI-T1.523-2001]</td><td>American National Standards Institute, Inc., «Telecom Glossary 2000», ANSI T1.523-2001, Февраль 2001.</td></tr><tr><td>[SCHNEIER]</td><td>Schneier, B., «Applied Cryptography Second Edition: protocols algorithms and source in code in C», John Wiley and Sons, New York, NY, 1996.</td></tr><tr><td>[SCHEIFLER]</td><td>Scheifler, R., «X Window System : The Complete Reference to Xlib, X Protocol, Icccm, Xlfd, 3rd edition.», Digital Press, ISBN 1555580882, Февраль 1992.</td></tr><tr><td>[KAUFMAN]</td><td>Kaufman, C., Perlman, R., and M. Speciner, «Network Security: PRIVATE Communication in a PUBLIC World», Prentice Hall Publisher, 1995.</td></tr><tr><td>[CERT]</td><td>CERT Coordination Center, The., «http://www.cert.org/nav/index_red.html».</td></tr><tr><td>[VENEMA]</td><td>Venema, W., «Murphy's Law and Computer Security», Proceedings of 6th USENIX Security Symposium, San Jose CA http://www.usenix.org/publications/library/proceedings/sec96/venema.html, Июль 1996.</td></tr><tr><td>[ROGAWAY]</td><td>Rogaway, P., «Problems with Proposed IP Cryptography», Unpublished paper, 1996</td></tr><tr><td>[DAI]</td><td>Dai, W., «An attack against SSH2 protocol», Email to the SECSH Working Group ietf-ssh@netbsd.org, Feb 2002</td></tr><tr><td>[BELLARE]</td><td>Bellaire, M., Kohno, T., and C. Namprempre, «Authenticated Encryption in SSH: Fixing the SSH Binary Packet Protocol», Proceedings of the 9th ACM Conference on Computer and Communications Security, Sept 2002.</td></tr><tr><td>[Openwall]</td><td>Solar Designer and D. Song, «SSH Traffic Analysis Attacks», Presentation given at HAL2001 and NordU2002 Conferences, Sept 2001.</td></tr><tr><td>[USENIX]</td><td>Song, X.D., Wagner, D., and X. Tian, «Timing Analysis of Keystrokes and SSH Timing Attacks», Paper given at 10th USENIX Security Symposium, 2001.</td></tr></table><h2>Адреса авторов</h2><p>Tatu Ylonen<br />SSH Communications Security Corp<br />Valimotie 17<br />00380 Helsinki<br />Finland<br />EMail: <bdo dir="rtl">&#109;&#111;&#99;&#46;&#104;&#115;&#115;&#64;&#111;&#108;&#121;</bdo></p><p>Chris Lonvick (редактор)<br />Cisco Systems, Inc.<br />12515 Research Blvd.<br />Austin 78759<br />USA<br />EMail: <bdo dir="rtl">&#109;&#111;&#99;&#46;&#111;&#99;&#115;&#105;&#99;&#64;&#107;&#99;&#105;&#118;&#110;&#111;&#108;&#99;</bdo></p></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 4251 - Архитектура протокола SSH",disqus_identifier="4251.rfc",disqus_url="http://rfc2.ru/4251.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>