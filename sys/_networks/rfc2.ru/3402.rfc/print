<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../3402.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 3402 — Система DDDS. Часть 2 - Алгоритм</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../3402.rfc">RFC 3402 — Система DDDS. Часть 2 - Алгоритм</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 3402</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank"><span itemprop="alternativeHeadline">Dynamic Delegation Discovery System - Part Two: The Algorithm</span></a></dd><dd><div class="icon i7"></div> Предыдущие версии: RFC 2168, RFC 2915</dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Предложенный стандарт</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="2002-10-02">Октябрь 2002</time></dd><dd><div class="icon i5"></div> Автор: <span itemprop="author">Michael Mealling</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div id="text" itemprop="articleBody"><h3>Статус документа</h3><p>Этот документ содержит спецификацию стандартного протокола, предложенного сообществу Internet, и служит приглашением к дискуссии в целях развития. Текущее состояние стандартизации и статус описанного здесь протокола можно узнать из документа "Internet Official Protocol Standards" (STD 1). Документ может распространяться без ограничений.</p><h3>Тезисы</h3><p>Этот документ описывает алгоритм DDDS (Dynamic Delegation Discovery System — динамическая система детектирования передачи полномочий) для применения динамически отыскиваемых правил преобразования строк по отношению уникальным строкам приложений. Четко определенные правила преобразования будут отражать передачу полномочий управления информацией, связанной со строкой. Этот документ является частью серии документов, полностью указанной в "Dynamic Delegation Discovery System (DDDS) Part One: The Comprehensive DDDS" (RFC 3401). Важно отметить, что чтение и понимание каждого документа этой серии невозможно без прочтения остальных документов.</p><h2>Оглавление</h2><ul class="map"><li><a href="print#p1">1. Введение</a></li><li><a href="print#p2">2. Терминология</a></li><li><a href="print#p3">3. Алгоритм</a></li><li class="lia"><a href="print#p3.1">3.1. Компоненты правила</a></li><li class="lia"><a href="print#p3.2">3.2. Substitution Expression Syntax</a></li><li class="lia"><a href="print#p3.3">3.3. Полный алгоритм</a></li><li><a href="print#p4">4. Спецификация Приложения</a></li><li><a href="print#p5">5. Спецификация Базы данных</a></li><li><a href="print#p6">6. Примеры</a></li><li class="lia"><a href="print#p6.1">6.1. An Automobile Parts Identification System</a></li><li class="lia"><a href="print#p6.2">6.2. A Document Identification Service</a></li><li><a href="print#p7">7. Вопросы безопасности</a></li><li><a href="print#p8">8. Согласование с IANA</a></li><li><a href="print#p.references">Литература</a></li></ul><h2 id="p1">1. Введение</h2><p>Система DDDS используется для реализации простого связывания строк с данными, обеспечивающего поддержку динамически настраиваемых систем передачи полномочий (делегирования). DDDS отображает некие уникальные строки на данные, хранящиеся в DDDS Database, путем итеративного применения правил преобразования строк, пока не будут достигнуты условия завершения.</p><p>Этот документ описывает общий алгоритм DDDS, а не какие-либо частные алгоритмы или сценарии использования. Вся серия документов указана в "Dynamic Delegation Discovery System (DDDS) Part One: The Comprehensive DDDS" (RFC 3401) [1]. Важно отметить, что чтение и понимание каждого документа этой серии невозможно без прочтения остальных документов.</p><p>История DDDS включает процесс, начавшийся с работы группы Uniform Resource Name. Когда были изначально сформулированы имена URN [6], было принято решение определить полномочный сервер для URN так, чтобы (конструктивно) там не содержалось информации о местоположении в сети. Система может использовать базу данных с правилами, которые будут применяться к URN для отыскания информации о конкретных синтаксических блоках. Эта система изначально получила название RDS [7] и применялась только по отношению к URN.</p><p>С течением времени множество систем начало использовать такой же алгоритм и инфраструктуру для других, не связанных с URN, систем (см. примеры использования DDDS в главе 6). Это привело к необходимости изменения и разъяснения некоторых основополагающих допущений. Этот набор документов служит обновлением для исходных спецификаций URN, позволяющим разрабатывать новые приложения и базы правил стандартным способом.</p><p>Этот документ отменяет RFC 2168 [11] и RFC 2915 [9], а также обновляет RFC 2276 [7].</p><h2 id="p2">2. Терминология</h2><p>Ключевые слова необходимо (MUST), недопустимо (MUST NOT), требуется (REQUIRED), нужно (SHALL), не следует (SHALL NOT), следует (SHOULD), не нужно (SHOULD NOT), рекомендуется (RECOMMENDED), возможно (MAY), необязательно (OPTIONAL) в данном документе интерпретируются в соответствии с RFC 2119.</p><ul><li class="b">Application Unique String — Уникальная строка Приложения</li><li class="lib">Строка, являющаяся начальными данными для приложения DDDS. Лексическая структура этой строки должна заключать в себе уникальный путь делегирования, который анализируется и трассируется повторяющимся выбором и применением правил перезаписи (Rewrite Rule).</li><li class="b">Rewrite Rule — правило перезаписи</li><li class="lib">Правило, которое применяется к Application Unique String для создания нового ключа выбора нового правила перезаписи из базы правил или результирующей строки, которая возвращается вызвавшему приложению. Часто используется просто термин Правило (Rule).</li><li class="b">First Well Known Rule — первое общеизвестное правило</li><li class="lib">Это правило перезаписи, которое определяется приложением и реально не хранится в базе правил (Rule Database). Это праило используется для создания первого корректного ключа.</li><li class="b">Terminal Rule — конечное правило</li><li class="lib">Правило перезаписи, при использовании которого возвращается строка конечного результата процесса DDDS, а не другой ключ базы данных.</li><li class="b">Application — Приложение</li><li class="lib">Набор протоколов и спецификаций, которые задают реальные значения для различных обобщенных частей алгоритма DDDS. Приложение должно определять синтаксис и семантику Application Unique String, First Well Known Rule и одной или множества баз данных, которые корректны для этого Приложения.</li><li class="b">Rule Database — База правил</li><li class="lib">Любое хранилище правил, позволяющее по уникальному ключу идентифицировать набор правил, задающих этап передачи полномочий используемый для конкретного значения ключа (Key).</li><li class="b">Services — службы</li><li class="lib">Общая база правил может использоваться для связывания различных служб с данной строкой Application Unique String (например, различные функции протокола, разные рабочие характеристики, географическое положение, обратная совместимость и т. п.). Возможными вариантами служб могут быть, например, получение сообщения по факсу/телефону/электронной почте, распределение нагрузки между web-серверами, выбор ближайшего сервера-зеркала, учет отношения цена/производительность и т. п. Эти Службы включаются как часть Правила, чтобы позволить Приложению принять решение о выборе на основе применимости той или иной ветви процесса или иных параметрой Сервиса.</li><li class="b">Flags — флаги</li><li class="lib">Большинство Приложений будет требовать для Правил способа сигнализировать Приложению, что некие Правила обеспечивают варианты результата (например, различные форматы вывода, механизмы расширяемости, сигнализация конечного правила и т. п.), тогда, как другие правила этого не делают. Большинство Баз данных определяют поле Flags, которое Приложение может использовать для представления различных значений, выражаемых этими сигналами.</li></ul><h2 id="p3">3. Алгоритм</h2><p>Алгоритм DDDS основан на концепции Правил перезаписи (Rewrite Rule). Эти правила собираются в базу DDDS Rule Database, и доступ к ним обеспечивается по уникальным ключам. Конкретное Правило, будучи примененным к Application Unique String, преобразует эту строку в новый Ключ, который может использоваться для отыскания нового Правила в Базе. Это новое правило применяется к исходной строке Application Unique String и цикл повторяется, пока не будет выполнено условие завершения. Приложению недопустимо применять правило для вывода предыдущего правила. Все Правила перезаписи для всех Приложений должны всегда применяться точно к той же строке Application Unique String, с которой алгоритм начал работу.</p><p>Фундаментальны допущением является то, что строка Application Unique String представляет собой некий тип регулярной лексической структуры, к которой применяются правила. DDDS предполагает, что лексический элемент, используемый для принятия решения о передаче полномочий, содержится в самой строке Application Unique String. DDDS не решает задачи, когда для принятия решения о делегировании требуется информация, содержащаяся за пределами строки AUS и Правила (время сутом, финансовые транзакции и т. п..).</p><p>Схема работы алгоритма показана на рисунке.</p><pre>+--------- Application Unique String
|                 +----+
|                 |ввод|
|         +-------+    +----------+
|         | First Well Known Rule |
|         +-------+     +---------+
|                 |вывод|
|                 +-----+
|               Первый ключ
|                    |
|                    +----&lt;--------------&lt;--------------+
|                    |                                  |
|                  ключ     (База данных DDDS всегда    |
|                 +----+     принимает ключ и           |
|                 |ввод|     возвращает правило)        ^
|       +---------+    +--------+                       |
|       | Поиск в DDDS Database |                       |
|       +---------+     +-------+                       |
|                 |вывод|                               |
|                 +-----+                               |
|               Набор правил                            |
|                    |                                  |
|                    |       (вводом для правила служит |
|               Набор правил  правило и AUS.            ^
|                 +----+      Выводом всегда служит     |
+----------------&gt;|ввод|      ключ или результат)       |
  +---------------+    +-------------------+            |
  | Правила применяются к AUS,             |            |
  | пока не будет получен результат,       |            |
  | удовлетворяющий требованиям приложения |            |
  +---------------+     +------------------+            |
                  |вывод|                               |
                  +-----+                               ^
                    ключ                                |
                     |                                  |
                     v                                  |
     +-------------------------------------+            |
     | Последнее правило было завершающим? | Нет &gt;------+
     +-------------------------------------+
                     Да     (если правило не является завершающим,
                     |       его вывод служит новым ключом
                     |       для поиска следующего правила)
    +-----------------------------------+
    | Вывод последнего правила является |
    | результатом для приложения        |
    +-----------------------------------+</pre><h3 id="p3.1">3.1. Компоненты правила</h3><p>Правило содержит до 4 компонент:</p><ul><li class="b">Приоритет</li><li class="lib">Число, которое определяет приоритет в случае выбора из двух правил, совпадающих в остальном. Это позволяет включать в базу данных правила, которые дают похожие результаты, но один из путей делегирования может быть быстрее, лучше или дешевле, чем другой.</li><li class="b">Набор флагов</li><li class="lib">Флаги служат для задания атрибутов правила, которые определяют, является ли это правило последним из числа применяемых. Последнее правило называется завершающим (terminal rule) и его вывод служит результатом для приложения. Флаги являются уникальными для Приложений. Приложение может указать, что оно использует флаг, определенный другим Приложением, но в этом случае должно использоваться заданное тем Приложением определение. Одно Приложение не может переопределить Флаг, заданный другим Приложением. Это означает, что в будущем может потребоваться реестр флагов, но в настоящее время такое требование отсутствует.</li><li class="b">Описание сервиса</li><li class="lib">Описание сервиса используется для указания семантических атрибутов определенной ветви передачи полномочий. Существует множество случаев, когда две ветви идентичны за исключением того, что одна ведет к результату, обеспечивающему один набор функций, в вторая — к результату с другим набором. Эти функции могут включать эксплуатационные параметры типа распределения нагрузки, разделения трафика по географическим признакам, совместимости со старыми версиями и т.п. Например, два правила могут быть одинаково применимы к конкретному решению о делегировании для строки. Одно правило может вести к заключительному правилу, которое обеспечивает информацию для использования в среде с высоким уровнем доступности, а другое — к архивной службе, которая работает более медленно, но более стабильна во времени.</li><li class="b">Выражение для замены</li><li class="lib">Эта часть правила задает изменение строки и представляет собой комбинацию расширенного регулярного выражения POSIX [8] и строки замены (подобно выражениям для замены в Unix-редакторе sed).</li></ul><h3 id="p3.2">3.2. Синтаксис выражения для замены</h3><p>Набор (наборы) символов, используемый в выражениях для замены, определяется как Приложением, так и Базой данных. Приложение должно определить допустимый набор символов для строки AUS. Спецификация DDDS Database должна определить, какие наборы символов требуются для создания ключей и как представляется само выражение для замены. Приведенные ниже символы имеют смысл лишь при выборе определенного набора символов в базе данных и/или Приложении.</p><p>Синтаксис Выражения для замены в правилах представляет собой выражение в стиле редактора sed. Сами по себе выражения в стиле sed не подходят для использования в приложениях по ряду причин., следовательно, содержимое поля regexp должно соответствовать приведенным ниже правилам:</p><pre>subst-expr   = delim-char  ere  delim-char  repl  delim-char  *flags
delim-char   = "/" / "!" / &lt;любой октет, отсутствующий в полях 'POS-DIGIT' и 'flags'&gt;
                   ; Все вхождения delim_char в subst_expr должны быть одинаковы
ere          = &lt;POSIX Extended Regular Expression&gt;
repl         = *(string / backref)
string       = *(anychar / escapeddelim)
anychar      = &lt;любой символ, отличный от delim-char&gt;
escapeddelim = "\" delim-char
backref      = "\" POS-DIGIT
flags        = "i"
POS-DIGIT    = "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"</pre><p>Применение выражения для замены к Строке должно давать в результате ключ, который соответствует правилам базы данных (естественно, если текущий ключ не является завершающим, при котором возвращается не новый ключ, а окончательный результат). Поскольку имеется возможность некорректно задать регулярное выражение, что будет приводить к созданию неприемлемого ключа, клиентской программе следует убедиться, что результат является корректным ключом базы данных, прежде, чем использовать этот ключ.</p><p>Выражения backref в repl-части выражения для замены меняются на строку (возможно пустую) символов, заключенных в круглые скобки () в ERE-части выражения для замены. N представляет собой одиночную цифру от 1 до 9, включительно. Эта цифра задает N-ое выражение backref, которое начинается с N-ой скобки ( и продолжается до соответствующей скобки ). Например, ERE</p><pre>(A(B(C)DE)(F)G)</pre><p>имеет backref-выражения:</p><pre>\1  = ABCDEFG
\2  = BCDE
\3  = C
\4  = F
\5..\9  = ошибка - нет соответствующего субвыражения</pre><p>Флаг i показывает, что соответствие ERE следует проверять без учета регистра символов. Более того, любые backref-подстановки могут быть нормализованы к нижнему регистру при наличии флага i. Этот флаг имеет смысл только в тех случаях, когда Приложение и База данных определяют набор символов, в котором отказ от учета регистра символов является корректным.</p><p>Первый символ выражения для замены следует использовать, как символ-ограничитель компонент этого выражения. В выражении для замены должно быть ровно три символа-ограничителя без предшествующего escape-символа. Поскольку символы-ограничители с предшествующим символом escape будут интерпретироваться как собственно символы (не ограничители), недопустимо использовать в качестве ограничителей цифровые символы. При включении цифр будут возникать проблемы в выражениях backref. Кроме того, при наличии флагов в выражении для замены символ флага недопустимо использовать в качестве ограничителя.</p><h3 id="p3.3">3.3. Полный алгоритм</h3><p>Ниже приводится алгоритм DDDS целиком.</p><ol><li><p>Применяется правило First Well Known Rule к строке Application Unique String и в результате возвращается ключ Key.</p></li><li><p>Приложение запрашивает Базу данных для получения упорядоченного списка правил, соответствующих ключу Key.</p></li><li><p>Для каждого Правила в списке используется замена с помощью Substitution Expression, применяемая с соблюдением порядка к строке Application Unique String, пока не будет возвращена непустая строка. Положение в списке фиксируется и породившее непустую строку Правило используется для следующего шага. Если на следующем шаге выбранное правило отвергается, происходит возврат к использованию Substitution Expression для оставшейся части списка правил. Если список завершится без возврата корректно соответствия, приложение уведомляется об этом.</p></li><li><p>Если Описание сервиса в правиле не соответствует требованиям клиента, происходит возврат к п. 3 и продолжение работы с оставшейся частью списка правил. Если в списке имеется правило, соответствующее требованиям клиента, это Правило используется для следующего шага. В том (и только в том) случае, когда клиент способен обработать Правило и если такая обработка представляется безопасной в соответствии со спецификацией Приложения, клиент может отметить текущее Правило и продолжить выполнение п. 3, как будто правило было отвергнуто. В любом случае результатом данного этапа является одно и только одно Правило.</p></li><li><p>Если Flags в Правиле показывает, что данное правило не является завершающим (NOT Terminal), происходит возврат к п. 2 с использованием полученного результата в качестве нового Ключа.</p></li><li><p>Приложение уведомляется о завершении процесса и ему передаются из Правила значения Flags и Services вместе с выводом последнего выражения Substitution Expression.</p></li></ol><h2 id="p4">4. Спецификация Приложения</h2><p>Для того, чтобы описанный алгоритм стал используемым, нужно написать спецификации приложения и по крайней мере одной базы данных. Для задания спецификации приложения требуются перечисленные ниже компоненты.</p><ul><li class="b">Application Unique String — Уникальная Строка Приложения</li><li class="lib"><p>Это единственная строка, к которой применяются правила перезаписи. Строка должна иметь регулярную структуру и быть уникальной в приложении так, чтобы все, кто применяет Правила из одной Базы данных, получали в результате одинаковые Ключи. Например, приложение URI Resolution в качестве Application Unique String определяет URI.</p><p>Ни каким приложениям не дозволено определять Application Unique String так, чтобы Ключ, полученный правилом перезаписи, трактовался бы как Application Unique String для ввода в новое правило, поскольку это ведет к правилам перезаписи в стиле sendmail, которые отличаются склонностью к ошибкам. Единственное исключение из этого правила возможно в случае, когда Приложение определяет некий флаг или состояние, в котором правила для приложения подавляются и принимается новое Приложение DDDS или некий произвольный набор правил. Один из таких случаев можно найти в приложении URI Resolution, которое определяет флаг p, указывающий, что следующий шаг зависит от протокола (protocol specific) и, таким образом, выходит за рамки DDDS.</p></li><li class="b">First Well Known Rule — Первое Общеизвестное Правило</li><li class="lib">Это первое правило, которое применяется к Application Unique String и создает первый Ключ. Для выражения может использоваться такая же форма, какая принята для Правил, или несколько более сложная форма. Например, приложение URI Resolution может задавать, что это правило возвращает в качестве первого Ключа последовательность символов URI вплоть (но не включая) до первого двоеточия (схема URI).</li><li class="b">Valid Databases — корректные Базы данных</li><li class="lib">Приложение может определить, какая из Баз данных является корректной. Для каждой базы данных Приложение должно определить, как вывод правила First Well Known Rule (первый Ключ) может быть обращен во что-либо, подходящее для этой Базы данных. Например, приложение URI Resolution может использовать в качестве Базы данных систему DNS. Операция обращения первого Ключа во что-либо, подходящее для базы данных, будет преобразованием в некое корректное с точки зрения DNS имя. В дополнение для каждой Базы данных, которую определяет Приложение, оно должно задать допустимые наборы символов, которые будут порождать корректные Ключи. В примере URI Resolution набором символов URI является 7-битовый код ASCII, который согласуется с 8-битовым ограничением для символов в файлах зон DNS.</li><li class="b">Expected Output — ожидаемый результат</li><li class="lib">Приложение должно определить ожидаемый результат Завершающего Правила. Например, приложение URI Resolution направлено на поиск серверов, которые содержат полномочные данные о данном URI. Таким образом, результатом завершающего правила будет информация (хосты, порты, протоколы и т. п.), которая будет служить для контакта с полномочным сервером.</li></ul><p>В прошлом были некоторые недоразумения, касающиеся распределения нагрузки и использования DDDS Priority. Приложениям следует понимать, что Priority данного правила является лишь способом показать, что одно правило «быстрее, лучше, дешевле» другого. Если приложению требуется некий метод, позволяющий клиенту распределять нагрузку между серверами (например, взвешенный случайный выбор и т. п.), это следует реализовать за пределами алгоритма DDDS. Например, Приложение, использующее DNS Database может трактовать запись SRV, как способ обозначения того, что определенная служба действительно поддерживается несколькими скооперированными хостами. Распределение нагрузки будет осуществляться между хостами, которые идентичны с точки зрения DDDS в части путей передачи полномочий, которые имеют некий общий набор свойств или административный домен.</p><h2 id="p5">5. Спецификация Базы данных</h2><p>В дополнение к сказанному каждое Приложение должно иметь по крайней мере одну Базу данных, в которой отыскиваются Правила. Важно отметить, что данная База может использоваться и другими Приложениями. В таких случаях каждое правило должно использовать некую комбинацию своих служб (Service) и/или выражений для замены, соответствующую только той строке Application Unique Strings, для которой правило корректно.</p><p>Спецификация базы данных должна включать перечисленные ниже компоненты.</p><ul><li class="b">General Specification — общая спецификация</li><li class="lib">База данных должна иметь общую спецификацию, в качестве которой может использоваться ссылка на другой стандарт (SQL, DNS и т. п.) или полностью определенная новая спецификация. Спецификация Базы данных должна четко указывать допустимый набор символов, чтобы знать, какие наборы символов используются для представления Ключей и Правил.</li><li class="b">Lookup Procedure — процедура поиска</li><li class="lib">Этот параметр задает способ формулировки и подачи запросов. В случае использования базы данных для других целей (например, DNS) спецификация должна ясно показывать, как формулируются запросы применительно к случаю DDDS. Например, База данных на основе DNS должна указывать используемые типы записей RR и запросов (Query).</li><li class="b">Key Format — формат ключа</li><li class="lib">Если требуются какие-либо операции для преобразования Ключа во что-либо корректное для базы данных, такие преобразования должны быть четко определены. Например, в случае базы данных DNS Ключи должны создаваться как корректные доменные имена.</li><li class="b">Rule Format — формат правила</li><li class="lib">Спецификация выходного формата для правила.</li><li class="b">Rule Insertion Procedure процедура вставки правила</li><li class="lib">Спецификация вставки Правил в базу данных. Эта спецификация может включать политику, в соответствии с которой Правила могут или не могут добавляться в базу данных.</li><li class="b">Rule Collision Avoidance — предотвращение конфликтов между правилами</li><li class="lib">Поскольку База данных может использоваться множеством Приложений (например, ENUM и URI Resolution), спецификация должна четко описывать способы предотвращения конфликтов между правилами. Обычно для решения этой задачи используются два метода: 1) запрет для одного ключа возможности быть корректным в двух разных Приложениях; 2) если вариант 1 невозможен, создается такое выражение для замены, чтобы регулярное выражение включало достаточную часть Application Unique String для идентификации различия между двумя Приложениями.</li></ul><h2 id="p6">6. Примеры</h2><p>Приведенные ниже примеры служат лишь для учебных целей. Рассмотренные приложения не специфицированы в каких-либо реальных документах.</p><h3 id="p6.1">6.1. Система идентификации автомобильных деталей</h3><p>В этом примере рассматривается воображаемая система, в которой собраны воедино все производители автомобилей и используется стандартизованная система кодирования различных деталей (болты, гайки, шайбы, инструменты и т. п.), которая применяется в процессе производства и ремонта автомобилей. Проблема такого рода систем заключается в том, что автомобильная промышленность является сильно распределенной и многие детали производятся различными фирмами, расположенными по всему миру. Для того, чтобы найти информацию о какой-либо детали, система должна быть способна выяснить производителя этой детали и контактировать с ним.</p><p>Для облегчения задачи идентификационные номера выделяются как часть иерархической системы, в которой первые 5 цифр являются идентификатором производителя. Следующие 3 цифры идентифицируют линейку автомобилей (например, Ford, Toyota). Остальные цифры присваиваются производителями деталей по своему усмотрению.</p><p>Автомобильная промышленность приняла решение об использовании DDDS для создания распределенной системы поиска информации, которая маршрутизирует запросы к реальным держателям данных. Отрасль специфицировала базу данных и синтаксис запросов для отыскания правил перезаписи (APIDA Network) и Приложение Auto Parts Identification DDDS Application (APIDA).</p><p>Спецификация APIDA будет определять следующее:</p><ul class="dot"><li>Application Unique String — код детали;</li><li>First Well Known Rule — принимает первые 5 цифр (идентификатор производителя) и использует их в качестве Ключа;</li><li>Valid Databases — APIDA Network.</li><li>Expected Output — информация EDIFAC об интересующей детали.</li></ul><p>Спецификация Базы данных APIDA Network будет определять следующее:</p><ul class="dot"><li>General Specification — сеть поддерживающих EDI баз данных и служб, которые по заданному субномеру детали будут возвращать правила перезаписи в формате XML;</li><li>Lookup Procedure — следует обычным протоколам APIDA Network, запрашивая в сети правило перезаписи для Ключа;</li><li>Key Format — преобразования не требуется;</li><li>Rule Format: см. документацию APIDA Network для XML DTD.</li><li>Rule Insertion Procedure — определяется агентством, которое контролирует каждую часть кодов деталей; например, для получения идентификатора производителя нужно быть членом Auto Parts Manufacturers Association.</li></ul><p>В качестве иллюстрации рассмотрим деталь с кодом 4747301AB7D. Система будет брать первые 5 цифр 47473 и запрашивать в сети Правило перезаписи (Rewrite Rule). Это правило будет предоставляться базой данных о производителях деталей и позволит производителю передать полномочия далее или напрямую возвратить запрашивающему информацию EDIFAC.</p><p>Предположим для примера, что производитель возвращает Правило, которое говорит, что следующие 3 цифры нужно использовать как часть запроса к их сервису для получения нового Правила. Это новое Правило позволит производителю деталей передать полномочия на заводы по производству деталей для каждой линейки автомобилей. В нашем примере цифры 01A означают автомобили Toyota. Правило, которое возвращает производитель передает полномочия далее производителю в Японии. Это правило также означает, что данное Правило является завершающим и, таким образом, результатом последнего запроса будет информация о детали.</p><h3 id="p6.2">6.2. Служба идентификации документов</h3><p>Этот пример напоминает предыдущий, поскольку документы в этой системе можно рассматривать аналогично автомобильным деталям. Различие состоит в том, что информация о документе хранится близко к его автору (обычно на его настольном компьютере). Это означает, что число передач полномочий может быть достаточно большим. Кроме того, для того, чтобы избавиться от необходимости поддержки большого плоского пространства авторов, они организованы по компаниям и подразделениям.</p><p>Предположим, что строка Application Unique String для данного примера имеет вид:</p><pre>&lt;organization&gt;-&lt;department&gt;-&lt;author&gt;:&lt;project&gt;-&lt;bookcase&gt;-&lt;book&gt;</pre><p>Спецификация приложения может выглядеть примерно так:</p><ul class="dot"><li>Application Unique String — приведенная выше строка идентификации документа;</li><li>First Well Known Rule — символы до (но не включая) «-» трактуются, как первый Ключ;</li><li>Valid Databases — каталог DIS LDAP;</li><li>Expected Output — запись с сервера LDAP, содержащая библиографические данные о документе в формате XML.</li></ul><p>Спецификация базы данных для DIS LDAP Directory будет иметь вид:</p><ul class="dot"><li>General Specification — база данных использует службу каталогов LDAP; каждый сервер LDAP имеет запись, содержащую Правило перезаписи; правила указывают на другие серверы LDAP, используя схему LDAP URL;</li><li>Lookup Procedure — используя стандартные запросы LDAP, клиент спрашивает у сервера LDAP информацию о ключе;.</li><li>Key Format — преобразование не требуется;</li><li>Rule Format — см. спецификацию LDAP Rewrite Rule;</li><li>Rule Insertion Procedure — см. процедуры, опубликованные стороной, имеющей полномочия для данной ветви дерева DIS; первым разделом (организация) владеет Агентство DIS.</li></ul><p>В этом примере первый поиск осуществляется по организации. В результате организация может может возвратить клиенту конечный результат, если база данных этой организации содержит его. В других случаях процесс может включать дополнительные Правила и делегировать запрос вниз по иерархии к владельцу документа.</p><h2 id="p7">7. Вопросы безопасности</h2><p>Этот документ просто определяет алгоритм DDDS и, таким образом, сам по себе не оказывает влияния на безопасность. Когда алгоритм объединяется с Базой данных и Приложением, могут возникать связанные с безопасностью вопросы, одним из которых является возможность организации атак на динамические точки делегирования.</p><h2 id="p8">8. Согласование с IANA</h2><p>Этот документ не создает каких-либо требований к IANA. Спецификации Баз данных и Приложений могут выдвигать такие требования, но они не рассматриваются здесь.</p><h2 id="p.references">Литература</h2><table itemprop="references"><tr><td>[1]</td><td>Mealling, M., <a href="../3401.rfc" title="Система DDDS. Часть 1 - DDDS в целом">«Система DDDS. Часть 1 - DDDS в целом», RFC 3401</a>, Октябрь 2002.</td></tr><tr><td>[2]</td><td>Mealling, M., «Dynamic Delegation Discovery System (DDDS) Part Two: The Algorithm», RFC 3402, Октябрь 2002.</td></tr><tr><td>[3]</td><td>Mealling, M., <a href="../3403.rfc" title="Система DDDS. Часть 3 - База данных DNS">«Система DDDS. Часть 3 - База данных DNS», RFC 3403</a>, Октябрь 2002.</td></tr><tr><td>[4]</td><td>Mealling, M., <a href="../3404.rfc" title="Система DDDS. Часть 4 - Приложение для преобразования URI">«Система DDDS. Часть 4 - Приложение для преобразования URI», RFC 3404</a>, Октябрь 2002.</td></tr><tr><td>[5]</td><td>Mealling, M., <a href="../3405.rfc" title="Система DDDS. Часть 5 - Процедуры присваивания URI.ARPA">«Система DDDS. Часть 5 - Процедуры присваивания URI.ARPA», RFC 3405</a>, Октябрь 2002.</td></tr><tr><td>[6]</td><td>Moats, R., «URN Syntax», RFC 2141, Май 1997.</td></tr><tr><td>[7]</td><td>Sollins, K., «Architectural Principles of Uniform Resource Name Resolution», RFC 2276, Январь 1998.</td></tr><tr><td>[8]</td><td>The Institute of Electrical and Electronics Engineers, «IEEE Standard for Information Technology — Portable Operating System Interface (POSIX) — Part 2: Shell and Utilities (Vol. 1)», IEEE Std 1003.2-1992, ISBN 1-55937-255-9, Январь 1993.</td></tr><tr><td>[9]</td><td>Mealling, M. и R. Daniel, «The Naming Authority Pointer (NAPTR) DNS Resource Record», RFC 2915, Август 2000.</td></tr><tr><td>[10]</td><td>Faltstrom, P., «E.164 number and DNS», RFC 2916, Сентябрь 2000.</td></tr><tr><td>[11]</td><td>Daniel, R. и M. Mealling, «Resolution of Uniform Resource Identifiers using the Domain Name System», RFC 2168, Июнь 1997.</td></tr></table><h2>Адрес автора</h2><p>Michael Mealling<br />VeriSign<br />21345 Ridgetop Circle<br />Sterling, VA 20166 US<br />URI: http://www.verisignlabs.com<br />EMail: <bdo dir="rtl">&#116;&#101;&#110;&#46;&#109;&#121;&#110;&#111;&#101;&#110;&#64;&#108;&#101;&#97;&#104;&#99;&#105;&#109;</bdo></p></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 3402 - Система DDDS. Часть 2 - Алгоритм",disqus_identifier="3402.rfc",disqus_url="http://rfc2.ru/3402.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>