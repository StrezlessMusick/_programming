<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../3549.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 3549 — Linux Netlink как протокол для служб IP</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../3549.rfc">RFC 3549 — Linux Netlink как протокол для служб IP</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 3549</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank" rel="nofollow"><span itemprop="alternativeHeadline">Linux Netlink as an IP Services Protocol</span></a></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Информационный</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="2003-07-01">Июль 2003</time></dd><dd><div class="icon i5"></div> Авторы: <span itemprop="author">Jamal Hadi Salim</span>, <span itemprop="author">Hormuzd M Khosravi</span>, <span itemprop="author">Andi Kleen</span>, <span itemprop="author">Alexey Kuznetsov</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div id="text" itemprop="articleBody"><h3>Статус документа</h3><p>Этот документ содержит информацию, предназначенную для сообщества Internet, и не задает каких-либо стандартов Internet. Документ может распространяться без ограничений.</p><h3>Тезисы</h3><p>Данный документ описывает интерфейс Netlink ОС Linux, который используется операционной системой для обмена сообщениями как между процессами ядра, так и между ядром и пользовательскими процессами. Основное внимание в документе уделяется описанию функциональности Netlink как протокола, связывающего компоненты FEC (Forwarding Engine Component) и CPC (Control Plane Component), которые определяют работу сервиса IP. Прочие варианты использования Netlink, включая обмен сообщениями внутри ядра и между процессами IPC (Inter-process communication), а также настройка конфигурации служб, не относящихся к IP (несетевые службы или сетевые службы других протоколов), в данном документе не рассматриваются.</p><p>Документ предназначен для создания информационного контекста на начальном этапе работы группы ForCES IETF.1</p><h2>1. Введение</h2><p>Концепция разделения служб IP на управление и пересылку впервые была реализована в начале 1990-х годов в сокетах маршрутизации BSD 4.4 [9]. В то время наибольшую важность представляло простое решение вопроса пересылки пакетов IP (v4) и управление таблицами пересылки IPv4 в CPC (с помощью консольного интерфейса или демона динамической маршрутизации.</p><p>Мир IP-сетей с тех давних пор существенно изменился. Linux Netlink с точки зрения обеспечения сервиса и управления кроме поддержки сокетов маршрутизации обеспечивает ряд дополнительных функций. Начиная с ядра Linux 2.1, сокет Netlink обеспечивает абстракцию служб IP для нескольких типов сервиса кроме классической пересылки IPv4 в соответствии с RFC 1812.</p><p>Мотивом создания этого документа послужило отнюдь не желание описать весь набор служб, для которых можно использовать Netlink. Фактически многие типы сервиса (групповая маршрутизация, туннелирование, маршрутизация на основе правил и т. д) просто не рассматриваются в данном документе. Не предназначен документ и для использования в качестве учебника по Netlink. Идея документа заключается в общем описании Netlink и более подробном рассмотрении обязательных компонент в контексте работы группы ForCES — IPv4 и QoS. Документ также служит предварительным описанием множества механизмов, изучение которых представляет интерес в рамках ForCES. Рассматривается подмножество функций, доступных в ядре версии 2.4.6, которая была последней во время подготовки данного документа. Кроме того, документ рассматривает лишь функции, связанные с IPv4.</p><p>Документ начинается с концептуальных определений, после чего приводится рассмотрение Netlink в свете этих определений.</p><h3>1.1. Определения</h3><p>CP представляет собой среду исполнения, которая может иметь несколько субкомпонент, которые будут обозначаться как CPC. Все CPC, обеспечивающие контроль для разных служб IP, будут выполняться посредством машины пересылки FE. Такие отношения между компонентами означают возможность наличия нескольких CPC для одной физической CP, если они контролируют несколько служб IP. По сути, связь между CP и FE является абстракцией сервиса.</p><h4>1.1.1. Компоненты CPC</h4><p>Компоненты управляющего плана CPC включают сигнальные протоколы от динамических протоколов маршрутизации (например, OSPF [5]) до протоколов распространения тегов (например, CR-LDP [7]). Классические протоколы и операции управления также входят в эту категорию. Среди них такие механизмы, как SNMP [6], COPS [4] и фирменные средства настройки конфигурации CLI/GUI. Задача управляющего плана состоит в обеспечении среды исполнения для перечисленных действий с целью настройки конфигурации и управления второй компонентой элемента сети (NE) — машиной пересылки FE. Результат настройки конфигурации определяет способ трактовки пакетов, проходящих через FE.</p><h4>1.1.2. Компоненты FEC</h4><p>Машина пересылки FE представляет собой объект NE, который первым получает сетевые пакеты (из сети в NE).</p><p>Связанная с сервисом компонента FE просматривает пакет с целью обеспечения для него обработки, определенной компонентами CPC для данного типа сервиса IP. Различные службы будут использовать различные компоненты FEC. Сервисные модули могут объединяться в цепочки для поддержки более сложных типов сервиса (в рамках описанной ниже модели Linux FE).</p><p>Будучи созданной для поддержки конкретной службы, сервисная компонента FE будет по-прежнему соответствовать принципам модели пересылки.</p><h5>1.1.2.1. Модель машины пересылки IP в Linux</h5><pre>                          ____      +---------------+
                     +-&gt;-| FW |---&gt; | TCP, UDP, ... |
                     |   +----+     +---------------+
                     |                   |
                     ^                   v
                     |                  _|_
                     +----&lt;----+       | FW |
                               |       +----+
                               ^         |
                               |         Y
                         В сетевой    Из сетевого
                         стек хоста   стека хоста
                               ^         |
                               |_____    |
Приемное                             ^   Y
устройство ____    +-------+        +|---|--+   ____   +----------+ Выходное
  -&gt;-----&gt;| FW |--&gt;|Входной|--&gt;----&gt;| Пере- |-&gt;| FW |-&gt;| Выходной | устройство
          +----+   |  TC   |        | сылка |  +----+  |    TC    |--&gt;
                   +-------+        +-------+          +----------+</pre><p>На рисунке показана модель Linux FE для отдельного устройства. Единственной обязательной частью этой модели является модуль пересылки (Пересылка), соответствующий RFC 1812. Различные модули сетевого экранирования (FW), управления входящим и исходящим трафиком (TC) не являются обязательными и могут даже использоваться для обхода модуля RFC 1812. Эти модули показаны в виде простых блоков на пути передачи данных и, фактически, могут представлять собой каскады из множества субмодулей. Дополнительную информацию о таких модулях вы найдете на сайтах [10] и [11].</p><p>Пакеты, прибывающее на входное устройство, сначала проходят через модуль межсетевого экранирования (FW), который может отбрасывать (drop) и изменять (mangle) пакеты или выполнять с ними иные операции. После прохождения модуля FW входящие пакеты в зависимости от принятой политики, могут попадать во входной модуль контроля трафика TC, который выполняет операции по измерению и регулированию потоков входящего трафика. Пакеты могут отбрасываться входным модулем TC в зависимости от результатов измерения уровня трафика и принятой политики. После этого пакет передается единственному обязательному модулю, который обеспечивает пересылку в соответствии с требованиями RFC 1812. Пакет может быть отброшен, если он не соответствует требованиям RFC 1812, 1122, а также дополняющих их документов. Этот модуль является точкой выбора пути, из которой пакет, направленный принявшему его сетевому элементу NE, может быть передан сетевому стеку хоста.</p><p>Пакеты, которые не адресованы данному NE, могут проходить через субмодуль маршрутизации на базе правил (часть модуля пересылки), если такая маршрутизация поддерживается. После этого пакет передается следующему модулю сетевого экранирования, который может отбросить или изменить пакет в зависимости от настроек своих субмодулей и выбранной политики. После прохождения модуля экранирования пакет попадает в выходной фильтр контроля трафика (TC).</p><p>Выходной TC может отбрасывать пакеты с учетом политики, состояния очередей, уровня насыщения и правил управления скоростью исходящего потока. На этом этапе используются выходные очереди и задержки или отбрасывание пакета могут происходить как до его включения в очередь, так и после этого. Судьба пакета определяется выбранными для модуля алгоритмами и политикой.</p><h4>1.1.3. Службы IP</h4><p>Служба IP представляет собой процессы обработки пакета IP внутри NE. Эти процессы определяются комбинацией CPC и FEC.</p><p>Занимаемое службой время начинается с момента прихода пакета в NE и заканчивается в момент, когда пакет покидает NE. Существенно, что поведение служб IP в этом контексте определяет конкретным хостом. Компоненты CP, запущенные на NE, определяют сквозной для всего пути контроль служб с помощью управляющих приложений и сигнальных протоколов. Такие распределенные компоненты CPC унифицируют сквозное представление служб IP. Как было отмечено выше такие компоненты CP определяют поведение FE (и, следовательно, NE) по отношению к описываемому пакету.</p><p>Простым примером службы IP может служить классическая пересылка IPv4. В этом случае управляющие компоненты (протоколы маршрутизации OSPF, RIP и т. п.) и фирменные средства настройки конфигурации CLI/GUI изменяют таблицы пересылки FE для того, чтобы обеспечить простой сервис по пересылке пакетов на следующий интервал (next hop). Обычно NE, обеспечивающие такой сервис, называют маршрутизаторами.</p><p>На рисунке показан простой пример реализации FE&lt;-&gt;CP для обеспечения классической пересылки IPv4 с некоторыми дополнительными функциями QoS для управления выходными очередями.</p><pre>                        Плоскость управления (CP)
                       .------------------------------------
                       |    /^^^^^^\      /^^^^^^\         |
                       |   |        |    | COPS  |-\       |
                       |   | ospfd  |    |  PEP  |  \      |
                       |   \       /      \_____/    |     |
                     /------\_____/         |       /      |
                     | |        |           |     /        |
                     | |_________\__________|____|_________|
                     |           |          |    |
                    ******************************************
     Машина         ************* Сетевой уровень ************
     пересылки (FE) *****************************************
       .-------------|-----------|----------|---|-------------
       |       Сервисная компо-  |              |             |
       |       нента FE для     /               /             |
       |       пересылки IPv4  /               /              |
       |       ---------------/---------------/---------      |
       |       |             |                |        |      |
вход   |       |     --------|--        ------|-----   |   выход
пакета |       |     |Пересылка |      | Выходной   |  |   пакета
--&gt;---&gt;|------&gt;|----&gt;|   IPv4   |-----&gt;| планировщик|-&gt;| ----&gt;|-&gt;
       |       |     |          |      | Scheduler  |  |      |
       |       |     -----------        ------------   |      |
       |       |                                       |      |
       |        ---------------------------------------       |
       |                                                      |
       -------------------------------------------------------</pre><p>Демон ospfd управляет работой протокола OSPF, а COPS PEP представляет собой дополнительную компоненту CPC. Компонента IPv4 FE включает модуль пересылки IPv4, а также модуль выходного планировщика QoS. В качестве дополнительной службы может быть добавлен сервис пересылки на основе правил между модулем пересылки IPv4 и модулем планировщика QoS. Простейший классический вариант будет включать только модуль пересылки IPv4.</p><p>Опыт использования сетей говорит о важности добавления в маршрутизаторы новых типов сервиса, удовлетворяющих современным требованиям. Для решения этих задач были созданы и стандартизованы новые службы, которые могут выходить за пределы содержимого заголовков сетевого уровня. Однако, для обеспечивающих пересылку пакетов устройств NE по-прежнему используется термин «маршрутизатор». Новые службы (которые могут выходить за классические пределы заголовков L3) включают межсетевое экранирование, QoS с использованием Diffserv и RSVP, NAT, маршрутизацию на базе правил и т. п. Для таких служб создаются новые протоколы и средства управления.</p><p>Одним из экстремистских определений сервиса IP является «все, за что сервис-провайдеры могут взять деньги».</p><h2>2. Архитектура Netlink</h2><p>Управление компонентами IP-сервиса определяется с использованием шаблонов.</p><p>Компоненты FEC и CPC участвуют в предоставлении услуг IP-сервиса путем обмена данными с использованием таких шаблонов. FEC может непрерывно получать обновления от компоненты CPC, указывающие как предоставлять услуги (например, для пересылки пакетов IPv4, добавления, удаления или изменения маршрутов).</p><p>Взаимодействие между FEC и CPC в контексте Netlink определяется протоколом. Netlink предоставляет механизмы для CPC(находится в пользовательском пространстве) и FEC (находится в ядре), позволяющие им получить свои собственные определения для протокола. Это связано с тем, что пользовательское пространство и ядро находятся на разных уровнях безопасности. Следовательно, для обмена информацией между компонентами требуется протокол. Такой протокол обычно обеспечивается неким привилегированным сервисом, который имеет возможность копирования данных между различными уровнями безопасности. Будем называть такую службу сервисом Netlink. Этот сервис может также инкапсулироваться в протоколы транспортного уровня, если CPC и FEC выполняются на разных узлах. Компоненты FEC и CPC, используя механизмы Netlink, могут выбрать надежный протокол для обмена данными. По умолчанию, однако, Netlink не обеспечивает гарантированного обмена данными.</p><p>Отметим, что FEC и CPC могут располагаться на одном уровне защиты памяти и использовать системный вызов connect() для создания прямого пути и обмена информацией через этот путь. В данном документе этот механизм рассматриваться не будет — отметим лишь возможность его реализации. В данном документе предполагается, что FEC является частью ядра, а CPC размещается в пользовательском пространстве. Это не означает однако, что приведенная в документе информация относится лишь к случаю размещения этих компонент в разных областях защиты и не привязывает компоненты к одному узлу.</p><p>Отметим, что Netlink позволяет обеим компонентам участвовать в предоставлении сервиса IP.</p><h3>2.1. Логическая модель Netlink</h3><p>На приведенном рисунке показана простая диаграмма логических связей между компонентами FEC и CPC. В качестве примера использована FEC пересылки IPv4 (служба NETLINK_ROUTE, описанная ниже).</p><pre>                    Плоскость управления (CP)
                   .-------------------------------------
                   |    /^^^^^\        /^^^^^\           |
                   |   |       |      / CPC-2 \          |
                   |   | CPC-1 |     | COPS   |          |
                   |   | ospfd |     |  PEP   |          |
                   |   |      /       \____ _/           |
                   |    \____/            |              |
                   |      |               |              |
                *****************************************|
                ******** Широковещательная среда  *********
FE------------- *******************************************.
|     Компонента      |       |            |               |
|     пересылки IPv4  |       |            |               |
|       -------------/ -------|------------|-----------    |
|       |           /         |            |           |   |
|       |     .--------.  .---------.  .---------.     |   |
|       |     |Входная |  | IPv4    |  |Выходной |     |   |
|       |     |политика|  |Пересылка|  | планиров|     |   |
|       |     |________|  |_________|  | QoS     |     |   |
|       |                               ---------      |   |
|        ----------------------------------------------    |
|                                                          |
 ----------------------------------------------------------</pre><p>Netlink логически моделирует FEC и CPC в форме узлов, связанных между собой через широковещательную среду.</p><p>Свойства среды обусловлены сервисом. В приведенном примере показана широковещательная среда, принадлежащая к расширенному сервису пересылки IPv4.</p><p>Узлы (CPC и FEC в рассматриваемом примере) подключены к среде передачи и регистрируются для получения сообщений определенных типов. CPC может подключаться к множеству сред, если это способствует более эффективному управлению сервисом. Все узлы (CPC и FEC) принимают пакеты из широковещательной среды. Пакеты могут отбрасываться средой передачи, если они имеют некорректный формат или содержат ошибки. Отброшенные пакеты не поступают ни на один из узлов. Сервис Netlink может передавать отправителю сигналы об ошибках при обнаружении некорректных пакетов Netlink.</p><p>Передаваемые в среду пакеты могут быть широковещательными, групповыми или адресованными конкретному узлу. Узлы FEC и CPC регистрируют свою заинтересованность в сообщениях определенного типа для их обработки или простого мониторинга.</p><p>В приложениях 1 и 2 приведено более детальное рассмотрение этого взаимодействия.</p><h3>2.2. Формат сообщений</h3><p>В сообщениях Netlink существует три уровня — заголовок сообщения Netlink, шаблон IP-сервиса и связанные с IP-сервисом данные.</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                  Заголовок сообщения Netlink                  |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                       Шаблон IP-сервиса                       |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|             Связанные с IP-сервисом данные в TLV              |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><p>Сообщения Netlink используются для обмена данными между FEC и CPC, параметризации FEC, асинхронной передачи сведений о событиях FEC компонентам CPC и сбора/просмотра статистики (обычно с помощью CPC).</p><p>Заголовок сообщения Netlink используется для всех типов сервиса, тогда как шаблоны (IP Service Template) связаны с конкретными типами сервиса. Каждая служба IP передает данные параметризации (от CPC к FEC) или отклики (от FEC к CPC). Эти данные передаются в формате TLV и являются уникальными для сервиса.</p><p>Отдельные компоненты сообщений Netlink подробно рассматриваются ниже.</p><h3>2.3. Модель протокола</h3><p>В этом разделе описано как Netlink обеспечивает механизм ориентированного на службы взаимодействия между FEC и CPC.</p><h4>2.3.1. Адресация служб</h4><p>Для получения доступа сначала нужно соединиться с сервисом на FE. Соединение организуется путем системного вызова socket() для домена PF_NETLINK. Каждая компонента FEC идентифицируется номером протокола. В результате вызова могут создаваться сокеты типа SOCK_RAW или SOCK_DGRAM, хотя Netlink не различает сокеты этих типов. Соединение с сокетом обеспечивает основу для адресации FE&lt;-&gt;CP.</p><p>После этого организуется подключение к сервису (в любой момент в течение срока существования соединения) путем ввода обусловленной сервисом команды (от CPC к FEC, в основном для настройки конфигурации), команды сбора статистики или подписки/отказ на уведомления о связанных с сервисом событиях. Закрытие сокета прерывает транзакцию.</p><p>Примеры рассматриваются в приложениях 1 и 2.</p><h4>2.3.2. Заголовок сообщений Netlink</h4><p>Сообщения Netlink представляют собой поток байтов с одним или несколькими заголовками Netlink и связанными с ними данными (payload). Если данных слишком много для одного сообщения, они могут быть разделены на несколько сообщений Netlink, которые обычно называют многокомпонентным сообщением. Для таких сообщений первый и последующие заголовки, за исключением последнего, содержат флаг NLM_F_MULTI. В заголовке последнего сообщения указывается тип NLMSG_DONE.</p><p>Формат заголовка сообщения Netlink показан на рисунке:</p><pre>0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Length                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Type              |           Flags              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Process ID (PID)                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><p>Заголовок включает следующие поля:</p><ul><li class="b">Length — 32 бита</li><li class="lib">размер сообщения в байтах с учетом заголовка.</li><li class="b">Type — 16 битов</li><li class="lib"><p>Это поле определяет тип содержимого в сообщении.</p><p>Фактически поле может включать один из стандартных идентификаторов типа:</p><table class="nobrd"><tr><td>NLMSG_NOOP</td><td>Сообщение игнорируется.</td></tr><tr><td class="top">NLMSG_ERROR</td><td>Сообщение сигнализирует об ошибке и поле данных содержит структуру nlmsgerr. Такие сообщения обычно передаются от FEC к CPC и могут рассматриваться как NACK.</td></tr><tr><td>NLMSG_DONE</td><td>Сообщение является последней частью многокомпонентного сообщения.</td></tr></table><p>Отдельные службы IP могут использовать добавочные типы сообщений, например сервис NETLINK_ROUTE задает несколько таких типов, включая RTM_NEWLINK, RTM_DELLINK, RTM_GETLINK, RTM_NEWADDR, RTM_DELADDR, RTM_NEWROUTE, RTM_DELROUTE и др.</p></li><li class="b">Flags — 16 битов</li><li class="lib"><p>Стандартные флаги, используемые в заголовках Netlink, приведены в таблице:</p><table class="nobrd"><tr><td class="top">NLM_F_REQUEST</td><td>Этот флаг должен устанавливаться для всех откликов (обычно они передаются из пользовательского пространства в ядро).</td></tr><tr><td class="top">NLM_F_MULTI</td><td>Сообщение является частью (не последней) многокомпонентного сообщения. Для последней части указывается тип NLMSG_DONE.</td></tr><tr><td class="top">NLM_F_ACK</td><td>Запрос на подтверждение при успехе. Обычно этот флаг устанавливается для сообщений из пользовательского пространства (CPC) в ядро (FEC).</td></tr><tr><td class="top">NLM_F_ECHO</td><td>Возвратить «эхо» для данного запроса. Обычно этот флаг устанавливается для сообщений из пользовательского пространства (CPC) в ядро (FEC).</td></tr></table><p>В запросах GET для конфигурационной информации, передаваемых в FEC используются дополнительные флаги.</p><table class="nobrd"><tr><td class="top">NLM_F_ROOT</td><td>Возвращать полную таблицу вместо одной записи.</td></tr><tr><td class="top">NLM_F_MATCH</td><td>Возвращать все записи, соответствующие критерию, переданному в поле данных сообщения.</td></tr><tr><td class="top">NLM_F_ATOMIC</td><td>Возвращать атомарную картину (atomic snapshot) таблицы, которая указана. Установка этого флага может требовать специальных привилегий, поскольку флаг способен прерывать сервис FE на достаточно продолжительное время.</td></tr></table><p>Подходящим макросом для поля флагов является</p><table class="nobrd"><tr><td class="top">NLM_F_DUMP</td><td>This is NLM_F_ROOT or'ed with NLM_F_MATCH</td></tr></table><p>В запросах NEW также могут использоваться дополнительные флаги.</p><table class="nobrd"><tr><td>NLM_F_REPLACE</td><td>Заменить существующий объект конфигурации в соответствии с данным запросом.</td></tr><tr><td>NLM_F_EXCL</td><td>Не заменять существующий объект новым.</td></tr><tr><td>NLM_F_CREATE</td><td>Создать объект конфигурации, если его не существует.</td></tr><tr><td>NLM_F_APPEND</td><td>Добавить объект в конце списка имеющихся.</td></tr></table><p>Для тех, кто хорошо знаком с операциями на сокетах маршрутизации BSD, в таблице приведены эквиваленты таких операций:</p><table class="nobrd"><tr><td class="b">BSD</td><td class="b">Netlink</td></tr><tr><td>ADD</td><td>NLM_F_CREATE OR NLM_F_EXCL</td></tr><tr><td>CHANGE</td><td>NLM_F_REPLACE</td></tr><tr><td>Check</td><td>NLM_F_EXCL</td></tr><tr><td>APPEND</td><td>NLM_F_CREATE</td></tr></table></li><li class="b">Sequence Number — 32 бита</li><li class="lib">порядковый номер сообщения.</li><li class="b">Process ID (PID) — 32 бита</li><li class="lib">Идентификатор процесса (PID), передающего сообщение. Значение PID используется ядром для мультиплексирования в корректный сокет. При передаче сообщений из ядра в пользовательское пространство устанавливается PID = 0.</li></ul><h5>2.3.2.1. Механизмы создания протоколов</h5><p>Один из способов организации надежного протокола обмена между FEC и CPC является использование комбинации порядковых номеров, ACK и таймеров повтора передачи. Порядковые номера и подтверждения ACK обеспечиваются Netlink, таймеры обеспечиваются ОС Linux.</p><p>Можно также создать heartbeat-протокол для обмена между FEC и CPC за счет использования флагов ECHO и сообщений типа NLMSG_NOOP.</p><h5>2.3.2.2. Сообщение ACK в Netlink</h5><p>Эти сообщения используются как для передачи подтверждений (ACK), так и для передачи информации об отрицательном результате (NACK). Обычно такие сообщения передаются от FEC к CPC (в ответ на сообщение с запросом подтверждения). Однако CPC должны обеспечивать возможность передачи сообщений ACK в адрес FEC при наличии соответствующего запроса. Семантика этих сообщений специфична для IP-сервиса.</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Netlink message header                  |
|                       type = NLMSG_ERROR                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Error code                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|              Старый заголовок сообщения  Netlink              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><ul><li>Error code — integer (обычно 32 бита)</li></ul><p>Нулевое значение кода ошибки говорит о том, что сообщение является подтверждением успешного результата (ACK). Такие сообщения содержат заголовок исходного сообщения Netlink, который может использоваться для сравнения (например, порядкового номера).</p><p>Отличный от нуля код говорит об отрицательном результате (NACK). В таких ситуациях данные Netlink, которые были переданы ядру, возвращаются вместе с исходным заголовком Netlink. Устанавливается также пригодное для вывода с помощью perror() значение кода ошибки(не в заголовке сообщения, а в переменной окружения).</p><h4>2.3.3. Шаблоны FE системных служб</h4><p>Существуют системные службы, которые предлагают свой сервис для использования другими службами. Обычно они включают возможность настройки конфигурации, сбора статистики, прослушивание сведений об изменении разделяемых ресурсов, управление адресами IP, канальные события и т. п. Данный раздел включает описание подобных служб для их логического разделения (несмотря на то, что все они доступны через FEC NETLINK_ROUTE). Причина этого заключается в том, что они существуют в NETLINK_ROUTE в силу исторически сложившихся причин (ошибки), связанных с тем, что сокеты BSD 4.4 Route реализованы как часть сокетов пересылки IPv4.</p><h5>2.3.3.1. Сервисный модуль сетевого интерфейса</h5><p>Эта служба обеспечивает возможность создания и удаления сетевых интерфейсов, а также получения информации о существующем интерфейсе. Интерфейс может быть физическим или виртуальным и не связан с сетевым протоколом (например, с помощью такого сообщения можно определить интерфейс x.25). Шаблон сообщения показан на рисунке.</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Family    |   Reserved  |          Device Type              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Interface Index                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Device Flags                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Change Mask                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><ul><li class="b">Family — 8 битов</li><li class="lib">Это поле всегда имеет значение AF_UNSPEC.</li><li class="b">Device Type — 16 битов</li><li class="lib">Определяет тип канала (Ethernet, туннель и т. п.). В данном документе рассматривается только IPv4, хотя тип канала не зависит от протокола L3.</li><li class="b">Interface Index — 32 бита</li><li class="lib">Уникальный идентификатор интерфейса.</li><li class="b">Device Flags — 32 бита</li><li class="lib">Флаги интерфейса, перечисленные в таблице:<table class="nobrd"><tr><td class="b">Флаг</td><td class="b">Значение</td></tr><tr><td>IFF_UP</td><td>Интерфейс активизирован администратором.</td></tr><tr><td>IFF_NOTRAILERS</td><td>Следует избегать использования трейлеров.</td></tr><tr><td>IFF_BROADCAST</td><td>Установлен корректный широковещательный адрес.</td></tr><tr><td>IFF_ALLMULTI</td><td>Принимать все пакеты с групповыми адресами.</td></tr><tr><td>IFF_DEBUG</td><td>Флаг режима отладки для интерфейса.</td></tr><tr><td>IFF_MASTER</td><td>Ведущий интерфейс для транка с распределением нагрузки.</td></tr><tr><td>IFF_LOOPBACK</td><td>Петлевой интерфейс (loopback).</td></tr><tr><td>IFF_SLAVE</td><td>Ведомый интерфейс для транка с распределением нагрузки.</td></tr><tr><td>IFF_POINTOPOINT</td><td>Интерфейс типа «точка-точка».</td></tr><tr><td>IFF_MULTICAST</td><td>Поддержка групповой адресации.</td></tr><tr><td>IFF_RUNNING</td><td>Интерфейс находится в работающем состоянии.</td></tr><tr><td>IFF_PORTSEL</td><td>Интерфейс может выбирать тип среды с помощью ifmap.</td></tr><tr><td>IFF_NOARP</td><td>Для интерфейса не требуется протокол ARP.</td></tr><tr><td>IFF_AUTOMEDIA</td><td>Активизирован автоматический выбор типа среды.</td></tr><tr><td>IFF_PROMISC</td><td>Интерфейс работает в режиме захвата.</td></tr><tr><td>IFF_DYNAMIC</td><td>Интерфейс создан в динамическом режиме.</td></tr></table><p>Зарезервированное поле, которое должно иметь значение 0xFFFFFFFF.</p><p>Применимые к данному сервису атрибуты перечислены в таблице.</p><table class="nobrd"><tr><td class="b">Атрибут</td><td class="b">Описание</td></tr><tr><td>IFLA_UNSPEC</td><td>Не определен.</td></tr><tr><td>IFLA_MTU</td><td>Значение MTU для устройства</td></tr><tr><td>IFLA_ADDRESS</td><td>Аппаратный адрес интерфейса на уровне L2.</td></tr><tr><td>IFLA_LINK</td><td>Значение ifindex для канала, к которому подключено устройство.</td></tr><tr><td>IFLA_BROADCAST</td><td>Аппаратный широковещательный адрес интерфейса на уровне L2.</td></tr><tr><td>IFLA_QDISC</td><td>Строка ASCII, указывающая имя дисциплины управления выходными очередями.</td></tr><tr><td>IFLA_IFNAME</td><td>Имя устройства (строка ASCII).</td></tr><tr><td>IFLA_STATS</td><td>Статистика для интерфейса.</td></tr></table></li></ul><p>К данному типу сервиса относятся сообщения Netlink RTM_NEWLINK, RTM_DELLINK и RTM_GETLINK.</p><h5>2.3.3.2. Модуль службы адресов IP</h5><p>Эта служба обеспечивает возможность добавления и удаления адресов, а также получения сведений об IP-адресах, связанных с данным интерфейсом. Шаблон сообщения службы предоставления адресов показан на рисунке:</p><pre>0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Family    |     Length    |     Flags     |    Scope      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Interface Index                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><ul><li class="b">Family — 8 битов</li><li class="lib">Идентификатор семейства адресов: AF_INET для IPv4 и AF_INET6 для IPv6.</li><li class="b">Length — 8 битов</li><li class="lib">Размер маски адреса.</li><li class="b">Flags — 8 битов</li><li class="lib"><table class="nobrd"><tr><td class="b">Флаг</td><td class="b">Описание</td></tr><tr><td>IFA_F_SECONDARY</td><td>Вторичный адрес (псевдоним интерфейса)</td></tr><tr><td>IFA_F_PERMANENT</td><td>Постоянный адрес, установленный пользователем. Отсутствие этого флага говорит о динамическом выделении адреса (например, с помощью системы автоматической настройки конфигурации)</td></tr><tr><td>IFA_F_DEPRECATED</td><td>Недействующий (deprecated) адрес IP.</td></tr><tr><td>IFA_F_TENTATIVE</td><td>Предполагаемый (tentative) адрес IP. Процедура обнаружения дубликатов адресов находится в стадии разработки.</td></tr></table></li><li class="b">Scope — 8 битов</li><li class="lib"><p>Область корректности адреса:</p><table class="nobrd"><tr><td>SCOPE_UNIVERSE</td><td>Адрес глобального действия.</td></tr><tr><td>SCOPE_SITE</td><td>Адрес корректен в пределах данного сайта (только для IPv6).</td></tr><tr><td>SCOPE_LINK</td><td>Адрес имеет смысл только для данного устройства.</td></tr><tr><td>SCOPE_HOST</td><td>Адрес имеет смысл только для данного хоста.</td></tr></table><p>Атрибуты сервиса перечислены в таблице:</p><table class="nobrd"><tr><td class="b">Атрибут</td><td class="b">Описание</td></tr><tr><td>IFA_UNSPEC</td><td>Не определен.</td></tr><tr><td>IFA_BROADCAST</td><td>Широковещательный адрес для протокола RAW.</td></tr><tr><td>IFA_ADDRESS</td><td>Адрес интерфейса для протокола RAW.</td></tr><tr><td>IFA_ANYCAST</td><td>Anycast-адрес для протокола RAW.</td></tr><tr><td>IFA_LOCAL</td><td>Локальный адрес для протокола RAW.</td></tr><tr><td>IFA_CACHEINFO</td><td>Кэшированная информация об адресе.</td></tr><tr><td>IFA_LABEL</td><td>Имя интерфейса (строка ASCII).</td></tr></table><p>К данному типу сервиса относятся сообщения Netlink RTM_NEWADDR, RTM_DELADDR и RTM_GETADDR.</p></li></ul><h2>3. Определенные в данный момент IP-службы Netlink</h2><p>Хотя, как было отмечено выше, существует множество других служб IP, использующих Netlink, в данном документе рассматривается лишь небольшая часть этих служб, интегрированных в ядро версии 2.4.6. К таким службам относятся NETLINK_ROUTE, NETLINK_FIREWALL и NETLINK_ARPD.</p><h3>3.1. Служба NETLINK_ROUTE</h3><p>Эта служба позволяет CPC изменять таблицу маршрутизации IPv4 в машине пересылки FE. Кроме того, данный сервис может применяться CPC для получения данных об обновлении маршрутов и сбора статистики.</p><h4>3.1.1. Модуль службы маршрутизации</h4><p>Эта служба обеспечивает возможность создания и удаления маршрутов, а также получения информации о сетевых маршрутах. Формат шаблона сообщения показан на рисунке:</p><pre>0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Family    |  Src length   |  Dest length  |     TOS       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Table ID   |   Protocol    |     Scope     |     Type      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Flags                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><ul><li class="b">Family — 8 битов</li><li class="lib">Идентификатор семейства адресов: AF_INET для IPv4 и AF_INET6 для IPv6.</li><li class="b">Src length — 8 битов</li><li class="lib">Размер префикса IP-адреса отправителя.</li><li class="b">Dest length — 8 битов</li><li class="lib">Размер префикса IP-адреса получателя.</li><li class="b">TOS — 8 битов</li><li class="lib">Восьмибитовое поле TOS (следует отказаться от него для освобождения места под DSCP).</li><li class="b">Table ID — 8 битов</li><li class="lib"><p>Идентификатор таблицы. Поддерживается до 255 таблиц маршрутизации.</p><table class="nobrd"><tr><td>RT_TABLE_UNSPEC</td><td>Неуказанная таблица.</td></tr><tr><td>RT_TABLE_MAIN</td><td>Основная таблица.</td></tr><tr><td>RT_TABLE_DEFAULT</td><td>Используемая по умолчанию таблица.</td></tr><tr><td>RT_TABLE_LOCAL</td><td>Локальная таблица.</td></tr></table><p>Пользователь может выделять дополнительные значения в диапазоне от RT_TABLE_UNSPEC (0) до RT_TABLE_DEFAULT (253).</p></li><li class="b">Protocol — 8 битов</li><li class="lib"><p>Указывает кто добавил маршрут в таблицу.</p><table class="nobrd"><tr><td class="b">Протокол</td><td class="b">Источник маршрута</td></tr><tr><td>RTPROT_UNSPEC</td><td>Неизвестен.</td></tr><tr><td>RTPROT_BOOT</td><td>При загрузке системы.</td></tr><tr><td>RTPROT_REDIRECT</td><td>Из сообщения ICMP redirect.</td></tr><tr><td>RTPROT_STATIC</td><td>Администратор.</td></tr><tr><td>RTPROT_KERNEL</td><td>Ядро.</td></tr></table><p>Значения, превышающие RTPROT_STATIC (4), не интерпретируются ядром и включены только с информационными целями. Эти значения могут использоваться, чтобы помечать источник маршрутной информации или различать разные демоны маршрутизации. Идентификаторы уже присвоенные демонам маршрутизации вы можете найти в файле &lt;linux/rtnetlink.h&gt;.</p></li><li class="b">Scope — 8 битов</li><li class="lib"><p>Область видимости маршрута (корректная дистанция до получателя).</p><table class="nobrd"><tr><td>RT_SCOPE_UNIVERSE</td><td>Глобальный маршрут.</td></tr><tr><td>RT_SCOPE_SITE</td><td>Внутренний маршрут локальной автономной системы.</td></tr><tr><td>RT_SCOPE_LINK</td><td>Маршрут на данном канале (соединении).</td></tr><tr><td>RT_SCOPE_HOST</td><td>Маршрут на локальном хосте.</td></tr><tr><td>RT_SCOPE_NOWHERE</td><td>Получателя не существует.</td></tr></table><p>Значения в диапазоне от RT_SCOPE_UNIVERSE (0) до RT_SCOPE_SITE (200), не включая граничные, могут использоваться для пользовательских идентификаторов.</p></li><li class="b">Type — 8 битов</li><li class="lib">Тип маршрута.<table class="nobrd"><tr><td class="b">Тип</td><td class="b">Получатель</td></tr><tr><td>RTN_UNSPEC</td><td>Неизвестный маршрут</td></tr><tr><td>RTN_UNICAST</td><td>Шлюз или прямой маршрут.</td></tr><tr><td>RTN_LOCAL</td><td>Маршрут к локальному интерфейсу.</td></tr><tr><td>RTN_BROADCAST</td><td>Локальный широковещательный маршрут (передается как broadcast).</td></tr><tr><td>RTN_ANYCAST</td><td>Локальный anycast-маршрут (передается как unicast)</td></tr><tr><td>RTN_MULTICAST</td><td>Локальный групповой (multicast) маршрут.</td></tr><tr><td>RTN_BLACKHOLE</td><td>Маршрут для отбрасывания пакетов без уведомления (черная дыра).</td></tr><tr><td class="top">RTN_UNREACHABLE</td><td>Недостижимый получатель. Пакеты отбрасываются с передачей отправителю сообщения ICMP о недоступности адресата.</td></tr><tr><td class="top">RTN_PROHIBIT</td><td>Запрещенный маршрут. Пакеты отбрасываются с передачей отправителю сообщения ICMP о запрете доступа к адресату.</td></tr><tr><td class="top">RTN_THROW</td><td>При использовании маршрутизации на базе правил указывает на продолжение просмотра маршрутов в другой таблице. При обычной маршрутизации пакеты отбрасываются с передачей отправителю сообщения ICMP о недоступности адресата.</td></tr><tr><td>RTN_NAT</td><td>Правило трансляции сетевых адресов.</td></tr><tr><td>RTN_XRESOLVE</td><td>Указывает на внешний преобразователь (resolver). В настоящее время еще не реализовано.</td></tr></table></li><li class="b">Flags — 32 бита</li><li class="lib"><p>Дополнительная информация о маршруте.</p><table class="nobrd"><tr><td>RTM_F_NOTIFY</td><td>При изменении маршрута пользователю передается уведомление.</td></tr><tr><td>RTM_F_CLONED</td><td>Маршрут клонирован из другого маршрута.</td></tr><tr><td class="top">RTM_F_EQUALIZE</td><td>Маршрут допускает случайный выбор следующего интервала (next hop) в случае наличия нескольких путей (в настоящее время не реализовано).</td></tr></table><p>Имеющие отношение к данному сервису атрибуты перечислены в таблице.</p><table class="nobrd"><tr><td class="b">Атрибут</td><td class="b">Описание</td></tr><tr><td>RTA_UNSPEC</td><td>Игнорируется.</td></tr><tr><td>RTA_DST</td><td>Протокольный адрес источника маршрута.</td></tr><tr><td>RTA_SRC</td><td>Протокольный адрес конечной точки маршрута.</td></tr><tr><td>RTA_IIF</td><td>Индекс входного интерфейса.</td></tr><tr><td>RTA_OIF</td><td>Индекс выходного интерфейса.</td></tr><tr><td>RTA_GATEWAY</td><td>Протокольный адрес шлюза для маршрута.</td></tr><tr><td>RTA_PRIORITY</td><td>Приоритет маршрута.</td></tr><tr><td>RTA_PREFSRC</td><td>Предпочтительный адрес отправителя при наличии нескольких адресов.</td></tr><tr><td>RTA_METRICS</td><td>Присвоенная маршруту метрика (например, RTT, начальный размер окна TCP и т. п.).</td></tr><tr><td>RTA_MULTIPATH</td><td>Атрибуты следующего интервала для маршрута с множеством путей (Multipath route).</td></tr><tr><td>RTA_PROTOINFO</td><td>Атрибут маршрутизации, основанный на политике межсетевого экрана.</td></tr><tr><td>RTA_FLOW</td><td>Область маршрута (Route realm).</td></tr><tr><td>RTA_CACHEINFO</td><td>Кэшированная информация о маршруте.</td></tr></table><p>Для этого типа сервиса поддерживаются дополнительные сообщения Netlink RTM_NEWROUTE, RTM_DELROUTE и RTM_GETROUTE.</p></li></ul><h4>3.1.2. Модуль учета соседей</h4><p>Этот сервис обеспечивает возможность добавления и удаления записей о соседях (например, ARP, IPv4 neighbor solicitation и т. п.), а также получения информации о существующих записях таблицы соседей. Шаблон сообщений этой службы показан на рисунке:</p><pre>0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Family    |    Reserved1  |           Reserved2           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Interface Index                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           State             |     Flags     |     Type      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><ul><li class="b">Family — 8 битов</li><li class="lib">Идентификатор семейства адресов: AF_INET для IPv4 и AF_INET6 для IPv6.</li><li class="b">Interface Index — 32 бита</li><li class="lib">Уникальный индекс интерфейса.</li><li class="b">State — 16 битов</li><li class="lib"><p>Битовая маска, которая может включать перечисленные в таблице биты состояния.</p><table class="nobrd"><tr><td>NUD_INCOMPLETE</td><td>Продолжаются попытки преобразования адреса.</td></tr><tr><td>NUD_REACHABLE</td><td>Подтверждено наличием рабочей записи в кэше.</td></tr><tr><td>NUD_STALE</td><td>Просроченная запись из кэша.</td></tr><tr><td>NUD_DELAY</td><td>Сосед больше не достижим. Трафик передан, ожидается подтверждение.</td></tr><tr><td>NUD_PROBE</td><td>В настоящее время осуществляется запрос на обновление записи в кэше.</td></tr><tr><td>NUD_FAILED</td><td>Некорректная запись в кэше.</td></tr><tr><td>NUD_NOARP</td><td>Устройство, которое не выполняет обнаружения соседей (ARP).</td></tr><tr><td>NUD_PERMANENT</td><td>Статическая запись.</td></tr></table></li><li class="b">Flags — 8 битов</li><li class="lib"><table class="nobrd"><tr><td>NTF_PROXY</td><td>Запись proxy</td></tr><tr><td>ARP NTF_ROUTER</td><td>Маршрутизатор IPv6</td></tr></table><p>Применимые к этому сервису атрибуты перечислены в таблице.</p><table class="nobrd"><tr><td class="b">Атрибут</td><td class="b">Описание</td></tr><tr><td>NDA_UNSPEC</td><td>Неизвестный тип.</td></tr><tr><td>NDA_DST</td><td>Адрес сетевого уровня для кэша соседей.</td></tr><tr><td>NDA_LLADDR</td><td>Адрес канального уровня для кэша соседей.</td></tr><tr><td>NDA_CACHEINFO</td><td>Статистика кэширования.</td></tr></table><p>Для этого типа сервиса поддерживаются дополнительные сообщения Netlink RTM_NEWNEIGH, RTM_DELNEIGH и RTM_GETNEIGH.</p></li></ul><h4>3.1.3. Служба контроля трафика</h4><p>Этот сервис обеспечивает возможность генерации, запроса и прослушивания событий, связанных с контролем трафика. Эта служба включает дисциплины очередей (планировщики и алгоритмы обслуживания очередей — например, планировщики на основе уровней приоритета или алгоритм RED) и классификаторы трафика. Система управления трафиком в Linux обеспечивает высокий уровень гибкости о поддерживает иерархическое каскадирование различных блоков для совместного использования ресурсов каналов передачи трафика.</p><pre>       ++    ++                 +-----+   +-------+   ++     ++ .++
       || .  ||     +------+    |     |--&gt;| Qdisc |--&gt;||     ||  ||
       ||    ||----&gt;|Фильтр|---&gt;|Класс|   +-------+   ||-+   ||  ||
       ||    ||  |  +------+    |     +---------------+| |   ||  ||
       || .  ||  |              +----------------------+ |   || .||
       || .  ||  |  +------+                             |   ||  ||
       ||    ||  +-&gt;|Фильтр|-_  +-----+   +-------+   ++ |   || .||
       || --&gt;||  |  +------+  -&gt;|     |--&gt;| Qdisc |--&gt;|| |   ||-&gt;||
       || .  ||  |              |Класс|   +-------+   ||-+--&gt;|| .||
-&gt;dev-&gt;||    ||  |  +------+ _-&gt;|     +---------------+|     ||  ||
       ||    ||  +-&gt;|Фильтр|-   +----------------------+     || .||
       ||    ||     +------+                                 || .||
       || .  |+----------------------------------------------+|  ||
       ||    |        Родительская дисциплина очередей        | .||
       || .  +------------------------------------------------+ .||
       || . . .. . . .. . .                 . .. .. .. .      .. ||
       |+--------------------------------------------------------+|
       |             Родительская дисциплина очередей             |
       |             (связана с выходным устройством)             |
       +----------------------------------------------------------+</pre><p>На приведенном рисунке показана пример схемы выходного блока TC. В этом документе приводится весьма краткое рассмотрение этого вопроса; дополнительную информацию можно найти на сайте [11]. Пакет сначала проходит через фильтр, используемый для идентификации класса трафика, к которому может быть отнесен данный пакет. Термин «класс» относится к дисциплинам очередей и связан с конкретной очередью. Очередь может использовать простой алгоритм (например, FIFO) или более сложные механизмы типа RED или token bucket. Дисциплину очереди, наиболее удаленную от родительской дисциплины, обычно называют планировщиком. В показанной здесь иерархии планировщик может включать различные алгоритмы планирования, что делает системы управления трафиком на выходе в ОС Linux очень гибкими.</p><p>Шаблон сообщения для этого типа сервиса показан ниже. Этот шаблон используется для дисциплин входных и выходных очередей (относительно модели управления трафиком на выходе, описанной в разделе для модели FE на стр. 3). Каждая специфическая компонента модели имеет уникальные атрибуты, описывающие ее наилучшим способом. Атрибуты общего назначения рассматриваются ниже.</p><pre>0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Family    |  Reserved1    |         Reserved2             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Interface Index                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Qdisc handle                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Parent Qdisc                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        TCM Info                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><ul><li class="b">Family — 8 битов</li><li class="lib">Идентификатор семейства адресов: AF_INET для IPv4 и AF_INET6 для IPv6.</li><li class="b">Interface Index — 32 бита</li><li class="lib">Уникальный индекс интерфейса.</li><li class="b">Qdisc handle — 32 бита</li><li class="lib">Уникальный идентификатор экземпляра дисциплины очередей. Обычно эти идентификаторы рассматриваются как двухкомпонентные (старшая:младшая) по 16 битов в каждой части. Старшая часть номера будет также старшей частью в номере родителя данного экземпляра.</li><li class="b">Parent Qdisc — 32 бита</li><li class="lib">Используется для иерархической структуризации дисциплин очередей. Если это значение совпадает с идентификатором и TC_H_ROOT, данный экземпляр qdisc является называется корневым (старшим).</li><li class="b">TCM Info — 32 бита</li><li class="lib"><p>Для этого поля FE обычно устанавливает значение 1 за исключением тех случаев, когда экземпляр Qdisc уже используется (в этом случае в поле помещается значение счетчика использования данного экземпляра). При передаче со стороны CPC в направлении FEC это поле обычно имеет значение 0 за исключением тех случаев, когда оно используется в контексте фильтрации. В таких случаях 32-битовое поле делится на 16-битовые поля приоритета и протокола. Протоколы определены в исходных кодах ядра (файл &lt;include/linux/if_ether.h&gt;). Наиболее широко используемым протоколом является ETH_P_IP (протокол IP).</p><p>Значение приоритета используется для разрешения конфликтов при пересечении фильтрующих выражений.</p><p>Базовые атрибуты этого типа сервиса перечислены в таблице.</p><table class="nobrd"><tr><td class="b">Атрибут</td><td class="b">Описание</td></tr><tr><td>TCA_KIND</td><td>Каноническое имя компоненты FE.</td></tr><tr><td>TCA_STATS</td><td>Базовая статистика использования FEC.</td></tr><tr><td>TCA_RATE</td><td>Оценка скорости для FEC (расчет на основе текущего состояния).</td></tr><tr><td>TCA_XSTATS</td><td>Специфическая статистика FEC.</td></tr><tr><td>TCA_OPTIONS</td><td>Вложенные атрибуты, связанные с FEC.</td></tr></table><p>В приложении 3 дается пример конфигурации компоненты FE для дисциплины FIFO.</p><p>Для этого типа сервиса поддерживаются дополнительные сообщения Netlink RTM_NEWQDISC, RTM_DELQDISC, RTM_GETQDISC, RTM_NEWTCLASS, RTM_DELTCLASS, RTM_GETTCLASS, RTM_NEWTFILTER, RTM_DELTFILTER и RTM_GETTFILTER.</p></li></ul><h3>3.2. Служба NETLINK_FIREWALL</h3><p>Эта служба позволяет CPC принимать пакеты через сервисные модули межсетевого экрана IPv4 в FE, манипулировать этими пакетами и повторно передавать их. Правило межсетевого экрана является первым из числа вставляемых для активизации перенаправления пакетов. CPC информирует FEC о своем желании получать метаданные для пакета или реальные данные из него, а также сообщает максимальный размер данных, которые будут перенаправляться. Перенаправленные пакеты по-прежнему сохраняются в FEC, ожидая решения о своей судьбе от CPC. Решение может быть простой командой на восприятие или отбрасывание пакета (в этом случае решение применяется к пакету, все еще находящемуся в FEC) или включать измененный пакет, который должен быть передан взамен исходного.</p><p>Существует два типа сообщений, передаваемых от CPC к FEC — Mode (режим) и Verdict (решение). Сообщения типа Mode незамедлительно передаются FEC и сообщают о том, что CPC желает принимать от FEC. Сообщения типа Verdict передаются FEC после принятия решения о дальнейшей судьбе полученного пакета. Формат сообщений рассматривается ниже.</p><p>Опишем сначала сообщение, указывающее режим.</p><pre>0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Mode    |    Reserved1  |           Reserved2             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Range                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><ul><li class="b">Mode — 8 битов</li><li class="lib"><p>Определяет тип информации в пакетах, отправляемых CPC:</p><ul><li>IPQ_COPY_META — копировать в CPC только метаданные для пакета.</li><li>IPQ_COPY_PACKET — копировать в CPC метаданные и содержимое поля данных пакета.</li></ul></li><li class="b">Range — 32 бита</li><li class="lib">В режиме IPQ_COPY_PACKET это значение определяет максимальный размер копируемых данных.</li></ul><p>Пакет и связанные с ним метаданные, полученные из пользовательского пространства, показаны на рисунке:</p><pre>0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Packet ID                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Mark                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       timestamp_m                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       timestamp_u                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          hook                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       indev_name                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       outdev_name                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           hw_protocol       |        hw_type                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         hw_addrlen          |           Reserved            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       hw_addr                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       data_len                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Payload . . .                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><ul><li class="b">Packet ID — 32 бита</li><li class="lib">Уникальный идентификатор пакета, передаваемый CPC от FEC.</li><li class="b">Mark — 32 бита</li><li class="lib">Значение внутренних метаданных, установленное для описания правила, в котором был взят пакет.</li><li class="b">timestamp_m — 32 бита</li><li class="lib">Время прибытия пакета (в секундах)</li><li class="b">timestamp_u — 32 бита</li><li class="lib">Время прибытия пакета (микросекунды, добавляемые к timestamp_m)</li><li class="b">hook — 32 бита</li><li class="lib">Модуль межсетевого экрана, из которого был взят пакет.</li><li class="b">indev_name — 128 битов</li><li class="lib">Имя приемного интерфейса (строка ASCII).</li><li class="b">outdev_name — 128 битов</li><li class="lib">Имя выходного интерфейса (строка ASCII).</li><li class="b">hw_protocol — 16 битов</li><li class="lib">Аппаратный протокол (в сетевом порядке битов).</li><li class="b">hw_type — 16 битов</li><li class="lib">Тип оборудования.</li><li class="b">hw_addrlen — 8 битов</li><li class="lib">Размер аппаратного адреса.</li><li class="b">hw_addr — 64 бита</li><li class="lib">Аппаратный адрес.</li><li class="b">data_len — 32 бита</li><li class="lib">Размер данных в пакете.</li><li class="b">Payload — размер задается полем data_len</li><li class="lib">Данные из полученного пакета.</li></ul><p>Формат сообщений типа Verdict показан на рисунке:</p><pre>0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Value                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Packet ID                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Data Length                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Payload . . .                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><ul><li class="b">Value — 32 бита</li><li class="lib"><p>Решение, принятое по отношению к пакету, который по-прежнему находится в FEC. Поддерживаются значения:</p><ul><li>NF_ACCEPT — принять пакет для дальнейшей обработки.</li><li>NF_DROP — отбросить (Drop) пакет.</li></ul></li><li class="b">Packet ID — 32 бита</li><li class="lib">Уникальный идентификатор пакета, передаваемый CPC от FEC.</li><li class="b">Data Length — 32 бита</li><li class="lib">Размер данных в измененном пакете (в байтах). Если пакет не был изменен, это поле имеет значение 0.</li><li class="b">Payload — размер определяется значением поля Data Length.</li></ul><h3>3.3. Служба NETLINK_ARPD</h3><p>Этот сервис используется CPC для поддержки таблицы соседей в FE. Формат сообщений, передаваемых между FEC и CPC, описан параграфе, посвященном службе учета соседей (стр. 10).</p><p>Предполагается, что сервис CPC принимает участие в работе протоколов организации соседских отношений (neighbor solicitation protocol).</p><p>Сообщение типа RTM_NEWNEIGH передается CPC от FE для информирования CPC об изменениях, которые могут произойти с записью для этого соседа.</p><p>Сообщения RTM_GETNEIGH используются для получения информации о конкретном соседе.</p><h2>4. Литература</h2><h3>4.1. Нормативные документы</h3><table itemprop="references"><tr><td>[1]</td><td>Braden, R., Clark, D. и S. Shenker, «Integrated Services in the Internet Architecture: an Overview», RFC 1633, Июнь 1994.</td></tr><tr><td>[2]</td><td>Baker, F., «Requirements for IP Version 4 Routers», RFC 1812, Июнь 1995.</td></tr><tr><td>[3]</td><td>Blake, S., Black, D., Carlson, M., Davies, E, Wang, Z. и W. Weiss, <a href="../2475.rfc" title="RFC 2475 - Архитектура дифференцированного обслуживания (Diffserv)">«Архитектура дифференцированного обслуживания (Diffserv)», RFC 2475</a>, Декабрь 1998</td></tr><tr><td>[4]</td><td>Durham, D., Boyle, J., Cohen, R., Herzog, S., Rajan, R. и A. Sastry, «The COPS (Common Open Policy Service) Protocol», RFC 2748, Январь 2000.</td></tr><tr><td>[5]</td><td>Moy, J., «OSPF Version 2», STD 54, RFC 2328, Апрель 1998.</td></tr><tr><td>[6]</td><td>Case, J., Fedor, M., Schoffstall, M. и C. Davin, <a href="../1157.rfc" title="RFC 1157 - Протокол SNMP">«Протокол SNMP», STD 15, RFC 1157</a>, Май 1990</td></tr><tr><td>[7]</td><td>Andersson, L., Doolan, P., Feldman, N., Fredette, A. и B. Thomas, «LDP Specification», RFC 3036, Январь 2001.</td></tr><tr><td>[8]</td><td>Bernet, Y., Blake, S., Grossman, D. и A. Smith, «An Informal Management Model for DiffServ Routers», RFC 3290, Май 2002.</td></tr></table><h3>4.2. Дополнительная литература</h3><ol><li>G. R. Wright, W. Richard Stevens. "TCP/IP Illustrated Volume 2, Chapter 20", Июнь 1995.</li><li>www.netfilter.org</li><li>diffserv.sourceforge.net</li></ol><h2>5. Вопросы безопасности</h2><p>Netlink работает в безопасной среде (trusted environment) на одном хосте с разделением ядра и пользовательского пространства. Средствами Linux обеспечивается возможность открывать сокет только для процессов с флагом возможностей CAP_NET_ADMIN (обычно процессы, запущенные пользователем root).</p><h2>6. Благодарности</h2><ol><li>Andi Kleen за страницы руководства (man pages) для netlink и rtnetlink.</li><li>Alexey Kuznetsov за добавление модели службы доставки IP в Netlink. Исходный вариант символьного устройства Netlink создал Alan Cox.</li><li>Jeremy Ethridge за исполнение роли «непонимающего Netlink»и обзор документа с точки зрения его восприятия.</li></ol><h2>Приложение 1: Пример иерархии служб</h2><p>На рисунке показан пример единичного IP-сервиса foo и взаимодействие компонент CP и FE для этой службы (метки 1-3).</p><p>Эта схема используется так же как пример адресации CP&lt;-&gt;FE. В этом приложении иллюстрируется только семантика адресации. В Приложении 2 эта схема рассматривается с точки зрения протокольного взаимодействия между компонентами CPC и FEC сервиса (метки 4-10).</p><pre> CP
[--------------------------------------------------------.
|   .-----.                                              |
|  |                         . -------.                  |
|  |  CLI   |               /           \                |
|  |        |              | Протокольная|               |
|         /-&gt;&gt; -.          |  компонента | &lt;-.           |
|    __ _/      |          |  CP для IP- |   |           |
|                |         | службы foo  |   ^           |
|                Y         |             |   |           |
|                |           ___________/    ^           |
|                Y   1,4,6,8,9 /  ^ 2,5,10   | 3,7       |
 --------------- Y------------/---|----------|-----------
                 |           ^    |          ^
               **|***********|****|**********|**********
               ************* Уровень Netlink ***********
               **|***********|****|**********|**********
       FE        |           |    ^          ^
       .-------- Y-----------Y----|--------- |----.
       |                    |              /      |
       |                    Y            /        |
       |          . --------^-------.  /          |
       |          | Компонента/модуль |/          |
       |          | FE для IP-службы  |           |
---&gt;---|------&gt;---| foo               |-----&gt;-----|------&gt;--
       |           -------------------            |
       |                                          |
       |                                          |
        ------------------------------------------</pre><p>Протокол плоскости управления для IP-службы foo выполняет перечисленные ниже операции для подключения к FE (нумерация в списке соответствует номерам на рисунке).</p><ol><li>Подключение к IP-сервису foo через сокет. Обычно соединение организуется с помощью вызова socket(AF_NETLINK, SOCK_RAW, NETLINK_FOO).</li><li>Привязка с целью прослушивания специфических асинхронных событий для сервиса foo.</li><li>Привязка с целью прослушивания специфических асинхронных событий FE.</li></ol><h2>Приложение 2: Пример протокола для IP-службы Foo</h2><p>В этом примере IP-сервис foo используется теперь для демонстрации простого управления сервисом IP с использованием Netlink.</p><p>Этапы этого управления осуществляются после операций, указанных в Приложении 1 и списки используют общую нумерацию.</p><ol><li>Запрашивается текущая конфигурация компоненты FE.</li><li>Принимается отклик на запрос (4) через канал, организованный на этапе (3).</li><li>запрашивается текущее состояние IP-сервиса foo.</li><li>Принимается отклик на запрос (6) через канал (2).</li><li>регистрируются связанные с протоколом пакеты, которые хочется получать от FE.</li><li>Передаются специфические для данной службы команды foo и (при необходимости) принимаются отклики на них.</li></ol><h3>Приложение 2a: Взаимодействие с другими службами IP</h3><p>На схеме в Приложении 1 показана другая компонента, которая может конфигурировать тот же сервис. В данном случае это фирменный командный интерфейс CLI. Интерфейс CLI может или не может использоваться Netlink для взаимодействия с компонентами foo. Если CLI дает команды, которые оказывают влияние на политику FEC для сервиса foo компонента CPC получает уведомления об этом. На основе этих уведомлений может приниматься решение. Например, если FE позволяет другому сервису удалять правила, установленные иной службой и установленные foo правила были удалены сервисом bar, может возникнуть необходимость распространить это всем партнерам службы foo.</p><h2>Приложение 3: Примеры</h2><p>В этом примере рассматривается простое конфигурационное сообщение Netlink, передаваемое от TC CPC выходной очереди TC FIFO. Этот алгоритм управления очередью основан на учете пакетов и отбрасывании пакетов при достижении порогового значения 100. Предполагается, что очередь находится в иерархии с родителем Parent = 100:0 и Classid = 100:1 и размещается на устройстве с ifindex = 4.</p><pre>0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Length (52)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Type (RTM_NEWQDISC)           | Flags (NLM_F_EXCL |         |
|                               |NLM_F_CREATE | NLM_F_REQUEST)|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Sequence Number(произвольное значение)           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Process ID (0)                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Family(AF_INET)|  Reserved1    |         Reserved1           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Interface Index  (4)                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Qdisc handle  (0x1000001)              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Parent Qdisc   (0x1000000)              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        TCM Info  (0)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Type (TCA_KIND)   |           Length(4)          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Value ("pfifo")                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Type (TCA_OPTIONS) |          Length(4)          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Value (limit=100)                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><h2>Адреса авторов</h2><p>Jamal Hadi Salim<br />Znyx Networks<br />Ottawa, Ontario Canada<br />EMail: <bdo dir="rtl">&#109;&#111;&#99;&#46;&#120;&#121;&#110;&#122;&#64;&#105;&#100;&#97;&#104;</bdo></p><p>Hormuzd M Khosravi<br />Intel<br />2111 N.E. 25th Avenue JF3-206<br />Hillsboro OR 97124-5961 USA<br />Phone: +1 503 264 0334<br />EMail: <bdo dir="rtl">&#109;&#111;&#99;&#46;&#108;&#101;&#116;&#110;&#105;&#64;&#105;&#118;&#97;&#114;&#115;&#111;&#104;&#107;&#46;&#109;&#46;&#100;&#122;&#117;&#109;&#114;&#111;&#104;</bdo></p><p>Andi Kleen<br />SuSE<br />Stahlgruberring 28<br />81829 Muenchen Germany<br />EMail: <bdo dir="rtl">&#101;&#100;&#46;&#101;&#115;&#117;&#115;&#64;&#107;&#97;</bdo></p><p>Alexey Kuznetsov<br />INR/Swsoft<br />Moscow Russia<br />EMail: <bdo dir="rtl">&#117;&#114;&#46;&#99;&#97;&#46;&#114;&#110;&#105;&#46;&#50;&#115;&#109;&#64;&#116;&#101;&#110;&#122;&#117;&#107;</bdo></p></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 3549 - Linux Netlink как протокол для служб IP",disqus_identifier="3549.rfc",disqus_url="http://rfc2.ru/3549.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>