<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../793.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 793 — Протокол управления передачей (TCP)</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../793.rfc">RFC 793 — Протокол управления передачей (TCP)</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 793</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank"><span itemprop="alternativeHeadline">Transmission Control Protocol</span></a></dd><dd><div class="icon i7"></div> Предыдущие версии: RFC 761</dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Стандарт Интернета</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1981-09-08">Сентябрь 1981</time></dd><dd><div class="icon i5"></div> Автор: <span itemprop="author">J. Postel</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div id="text" itemprop="articleBody"><h2>Предисловие</h2><p>В этом документе описан стандарт Министерства обороны США для протокола управления передачей TCP (Transmission Control Protocol). До этого было выпущено девять предварительных редакций спецификации ARPA TCP, на которых основан данный стандарт, и текст документа тесно связан с предварительными спецификациями. В разработке концепций и подготовке текста документа принимало участие много людей. В данной редакции более четко изложены некоторые детали, удален механизм изменения размера буфера end-of-letter и заново описан механизм letter как функция push. Jon Postel, редактор</p><p style="font-style:italic">Этот документ уже стал достоянием истории, несмотря на то, что большинство рассмотренных здесь вопросов сохраняют актуальность. Протокол TCP является основой работы сети Internet в ее современном состоянии. Долгие годы использования TCP и связанных с ним сетевых протоколов не могли не отразиться на терминологии, определениях и т. п. Поэтому буквальный перевод исходного документа современным читателям мог бы показаться непонятным. Исходя из этого, в переводе используется современная терминология. Кроме того, в RFC-793 за время использования протокола TCP был обнаружен целый ряд неточностей и ошибок, исправленных в более поздних документах и спецификациях. Нет смысла сохранять неточности при переводе, поэтому соответствующие фрагменты RFC-793 при переводе были скорректированы с учетом действующих спецификаций. В переводе такие места отмечены сносками с указанием источника корректных сведений.</p><p style="float:right">Николай Малых, переводчик</p><h2>Оглавление</h2><ul class="map"><li><a href="print#p1">1. Введение</a></li><li class="lia"><a href="print#p1.1">1.1. Мотивация</a></li><li class="lia"><a href="print#p1.2">1.2. Сфера применимости протокола</a></li><li class="lia"><a href="print#p1.3">1.3. Структура документа</a></li><li class="lia"><a href="print#p1.4">1.4. Интерфейсы</a></li><li class="lia"><a href="print#p1.5">1.5. Работа протокола</a></li><li><a href="print#p2">2. Концепции</a></li><li class="lia"><a href="print#p2.1">2.1. Элементы межсетевого взаимодействия</a></li><li class="lia"><a href="print#p2.2">2.2. Модель работы протокола</a></li><li class="lia"><a href="print#p2.3">2.3. Среда хоста</a></li><li class="lia"><a href="print#p2.4">2.4. Интерфейсы</a></li><li class="lia"><a href="print#p2.5">2.5. Связи с другими протоколами</a></li><li class="lia"><a href="print#p2.6">2.6. Надежная связь</a></li><li class="lia"><a href="print#p2.7">2.7. Организация и разрыв соединений</a></li><li class="lia"><a href="print#p2.8">2.8. Обмен данными</a></li><li class="lia"><a href="print#p2.9">2.9. Предпочтения и безопасность</a></li><li class="lia"><a href="print#p2.10">2.10. Принцип устойчивости</a></li><li><a href="print#p3">3. Функциональная спецификация</a></li><li class="lia"><a href="print#p3.1">3.1. Формат заголовка</a></li><li class="lia"><a href="print#p3.2">3.2. Терминология</a></li><li class="lia"><a href="print#p3.3">3.3. Порядковые номера</a></li><li class="lia"><a href="print#p3.4">3.4. Организация соединения</a></li><li class="lia"><a href="print#p3.5">3.5. Завершение соединения</a></li><li class="lia"><a href="print#p3.6">3.6. Предпочтения и безопасность</a></li><li class="lia"><a href="print#p3.7">3.7. Обмен данными</a></li><li class="lia"><a href="print#p3.8">3.8. Интерфейсы</a></li><li class="lia"><a href="print#p3.9">3.9. Обработка событий</a></li><li><a href="print#p.glossary">Глоссарий</a></li><li><a href="print#p.references">Литература</a></li></ul><h2 id="p1">1. Введение</h2><p>Протокол TCP предназначен для надежной и гарантированной доставки данных между хостами в компьютерных сетях с коммутацией пакетов и между такими сетями через промежуточные системы.</p><p>В этом документе описаны функции, выполняемые протоколом TCP, программные реализации протокола и интерфейс с программами и пользователями, которым требуется сервис TCP.</p><h3 id="p1.1">1.1. Мотивация</h3><p>Компьютерные коммуникационные системы играют все более важную роль в государственных, военных и деловых средах. В этом документе основное внимание сфокусировано на требованиях военных систем компьютерных коммуникаций, особенно вопросам устойчивости при наличии коммуникационных сбоев и доступности связи при возникновении насыщения, но многие из этих проблем встречаются не только в военных приложениях.</p><p>Разработаны и реализованы стратегические и тактические компьютерные коммуникационные системы и очень важно обеспечить связь между такими системами и стандартный протокол взаимодействия между процессами, который будет поддерживать широкий спектр приложений. Предполагая необходимость такого стандарта, исследовательская группа Deputy Undersecretary of Defense for Research and Engineering подготовила протокол TCP (Transmission Control Protocol — протокол управления передачей), описываемый здесь, в качестве стандартного протокола обмена информацией между процессами для сетей Министерства обороны США.</p><p>TCP представляет собой ориентированный на соединения протокол сквозной доставки с гарантией, предназначенный для использования в многоуровневой иерархии протоколов, поддерживающей разнородные сетевые приложения. TCP обеспечивает надежный обмен данными между парами процессов на хостах, подключенных к разным, но связанным между собой сетям. Протокол исходит из незначительного числа предпосылок о надежности коммуникационных протоколов, расположенных ниже уровня TCP. Протокол TCP предполагает, что он может использовать простой и потенциально ненадежный сервис доставки дейтаграмм протоколов нижележащих уровней. В принципе протокол TCP должен работать в широком классе коммуникационных систем, имеющих электрические соединения с сетями коммутации пакетов (packet-switched) или каналов (circuit-switched).</p><p>Протокол TCP основан на концепциях, впервые изложенных Серфом и Каном в работе [1]. TCP располагается в многоуровневой модели непосредственно над базовым протоколом Internet (IP) [<a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC791</a>], который обеспечивает для TCP возможность приема и передачи сегментов информации переменной длины, "вложенных" в дейтаграммы. Дейтаграммы обеспечивают способ адресации отправителя и получателя TCP, расположенных в различных сетях. Протокол IP обеспечивает также фрагментацию и сборку сегментов TCP, требуемую для доставки информации через множество сетей и соединяющих их шлюзов (маршрутизаторов). Протокол IP также передает информацию о предпочтениях (precedence) и безопасности, а также о делении сегментов TCP на части — эта информация передается между отправителем и получателем через множество разнородных сетей.</p><pre>     Уровни протоколов

+-------------------------+
|   Вышележащий уровень   |
+-------------------------+
|           TCP           |
+-------------------------+
| Протокол Internet (IP)  |
+-------------------------+
|  Коммуникационная сеть  |
+-------------------------+

Рисунок 1</pre><p>Большая часть этого документа написана в контексте реализаций TCP, работающих на хостах вместе с протоколами вышележащего уровня. Некоторые компьютерные системы соединяются с сетью через специальные периферийные (front-end) компьютеры, которые обеспечивают поддержку уровней TCP и IP, а также сетевые программы. Спецификация TCP описывает интерфейс с протоколами вышележащего уровня, которые представляются реализуемым и для случаев front-end (с помощью специального протокола взаимодействия между хостом и периферийным компьютером).</p><h3 id="p1.2">1.2. Сфера применимости протокола</h3><p>Протокол TCP предназначен для организации надежного обмена данными между процессами в разнородных сетевых средах. Протокол TCP является протоколом общего пользования в различных сетях для обмена информацией между хостами.</p><h3 id="p1.3">1.3. Структура документа</h3><p>В этом документе содержатся спецификации функций, требуемых от любой реализации протокола TCP, а также спецификации взаимодействия с протоколами соседних уровней и протоколом TCP на других хостах. В оставшейся части данного раздела приведено краткое описание работы протокола и интерфейсов. В разделе 2 рассмотрены базовые концепции архитектуры TCP. Раздел 3 содержит детальные описания действий, выполняемых протоколом TCP в ответ на те или иные события (прием новых сегментов, пользовательские вызовы, ошибки и т. п.), и описание форматов данных в сегментах TCP.</p><h3 id="p1.4">1.4. Интерфейсы</h3><p>Протокол TCP с одной стороны взаимодействует с пользовательскими или прикладными процессами, а с другой стороны — с протоколами нижележащего уровня (такими, как IP).</p><p>Интерфейс между прикладными процессами и TCP проиллюстрирован достаточно детально. Этот интерфейс содержит набор процедур, подобных процедурам операционной системы, используемым для работы с файлами. Например, существуют процедуры открытия и закрытия соединений, а также приема данных через организованное соединение. Предполагается также, что TCP может обмениваться данными с прикладными программами в асинхронном режиме. Хотя разработчикам TCP предоставляется разумная свобода выбора реализации интерфейса, существует минимальный набор функций для интерфейса между TCP и пользовательским уровнем, который должен присутствовать во всех реализациях протокола Интерфейс между TCP и протоколом нижележащего уровня задается менее детально за исключением предположения о наличии механизма асинхронного обмена информацией между уровнями. Предполагается также, что спецификация взаимодействия будет задаваться стандартом для протокола нижележащего уровня. Протокол TCP разработан для использования в разнотипных сетевых средах. В качестве протокола нижележащего уровня в данном документе обычно предполагается протокол IP [<a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC791</a>].</p><h3 id="p1.5">1.5. Работа протокола</h3><p>Как было отмечено выше, задачей протокола TCP является обеспечение надежных и потенциально безопасных логических устройств или соединений между парами процессов. Для обеспечения такого сервиса на базе менее надежных коммуникационных систем Internet требуется поддержка следующих функций:</p><ul class="dot"><li>базовый обмен данными (Basic Data Transfer);</li><li>надежность (Reliability);</li><li>управление потоком данных (Flow Control);</li><li>мультиплексирование (Multiplexing);</li><li>поддержка соединений (Connections);</li><li>предпочтения и безопасность (Precedence and Security)</li></ul><p>В следующих параграфах рассмотрены основные аспекты TCP для каждой из перечисленных функций.</p><h4>Базовая передача данных</h4><p>Протокол TCP способен поддерживать непрерывный поток октетов в каждом направлении между двумя точками соединения, упаковывая некоторое количество октетов в сегменты для передачи через межсетевую среду. В общем случае TCP решает, когда блокировать или пересылать данные по своему усмотрению.</p><p>Иногда пользователям нужна уверенность в том, что все данные, которые были направлены протоколу TCP, будут переданы. Для решения такой задачи определена функция выталкивания данных (push). Для обеспечения гарантии передачи отправленных протоколу TCP данных пользователь на передающей стороне должен "протолкнуть" данные удаленному пользователю. Функция push заставляет TCP незамедлительно переслать и доставить данные в точку приема. Точка "выталкивания" может быть невидима для получателя и функция push не устанавливает маркер границы записи.</p><h4>Надежность</h4><p>Протокол TCP должен восстанавливать данные в случае их повреждения, потери, дублирования или доставки с нарушением порядка. Это обеспечивается с помощью порядковых номеров, присваиваемых каждому передаваемому октету и подтверждением доставки данных (ACK — acknowledgment), передаваемым приемной стороной TCP. Если подтверждение ACK не было получено в течение заданного времени (тайм-аут), данные передаются заново. На приемной стороне порядковые номера используются для корректной расстановки сегментов, которые могут быть доставлены с нарушением порядка, и обнаружения дубликатов. Для обнаружения ошибок при передаче данных используются контрольные суммы, которые добавляются в каждый передаваемый сегмент. Контрольная сумма рассчитывается на передающей стороне и включается в сегмент; на приемной стороне контрольная сумма вычисляется заново и полученное значение сравнивается с указанной в сегменте контрольной суммой. При обнаружении расхождений сегмент отбрасывается.</p><p>Пока протокол TCP работает нормально и среда Internet не сегментирована на изолированные части, никакие ошибки передачи не будут влиять на корректность доставки данных. TCP восстанавливает данные после ошибок в среде Internet.</p><h4>Управление потоком данных</h4><p>TCP предоставляет получателю способ управления количеством данных, передаваемых отправителем. Это достигается путем возврата с каждым подтверждением ACK "окна" (window), показывающего диапазон допустимых порядковых номеров за пределами последнего доставленного сегмента. Окно показывает допустимые номера октетов, которые отправитель может передать до получения следующего разрешения.</p><h4>Мультиплексирование</h4><p>Чтобы позволить множеству процессов на одном хосте использовать коммуникационные возможности TCP, этот протокол поддерживает набор адресов (портов) на каждом хосте. Вкупе с сетевыми адресами и номерами хостов (уровень internet), номера портов формируют сокет (socket). Пара сокетов позволяет уникально идентифицировать каждое соединение. Таким образом, сокет может использоваться несколькими соединениями одновременно.</p><p>Связывание (binding) портов с процессами устанавливается каждым хостом независимо. Однако, для наиболее часто используемых процессов (например, вход в систему или работа в режиме разделения времени) целесообразно применять предопределенные (фиксированные) сокеты, номера которых известны всем. Доступ к таким службам обеспечивается с использованием хорошо известных адресов. Организация и определение номеров портов для других процессов может включать динамические механизмы.</p><h4>Соединения</h4><p>Механизмы обеспечения надежности и управления потоком данных, описанные выше, требуют от TCP поддержки информации о состоянии для каждого потока данных. Комбинация этих сведений, включающая сокет, порядковые номера и размеры окна, называется соединением. Каждое соединение может быть однозначно указано парой сокетов, используемых по разные стороны соединения.</p><p>Когда два процесса хотят обмениваться информацией, протоколы TCP на хостах сначала должны организовать соединение (инициализировать информацию о состоянии на каждой стороне). Когда обмен данными завершается, соединение разрывается (terminate или close) для освобождения использованных им ресурсов.</p><p>Поскольку соединения организуются между хостами, не обеспечивающими надежность, через ненадежную сетевую среду, применяется механизм согласования параметров (handshake) с порядковыми номерами на основе текущего времени для предотвращения ошибочной инициализации соединений.</p><h4>Предпочтения и безопасность</h4><p>Пользователи TCP могут указывать режим безопасности и предпочтения для своих соединений. Когда эти возможности не используются, для соответствующих параметров устанавливаются принятые по умолчанию значения.</p><h2 id="p2">2. Концепции</h2><h3 id="p2.1">2.1. Элементы межсетевого взаимодействия</h3><p>Сетевая среда (internetwork environment) состоит хостов, подключенных к сетям, которые соединены между собой маршрутизаторами. Здесь термином сеть обозначаются локальные (например, ETHERNET) или распределенные сети (например, ARPANET), но в любом случае эти сети работают на основе коммутации пакетов. Активными агентами, которые производят и потребляют сообщения, являются процессы. Протоколы различного уровня в сети, на хостах и маршрутизаторах образуют систему обмена информацией между процессами, которая обеспечивает двунаправленные потоки данных и логические соединения между портами процессов.</p><p>Термин пакет в данном документе используется в основном для обозначения одной транзакции между хостом и его сетью. Формат блоков данных, передаваемых через сеть, в общем случае не будет рассматриваться в контексте этого документа. Хостами называют компьютеры, подключенные к сети и (с коммуникационной точки зрения) являющиеся отправителями и получателями пакетов. Процессы рассматриваются как активные элементы в хостах (в соответствии с наиболее общим определением процесса как программы на стадии выполнения). Терминалы и файлы (или иные устройства ввода-вывода) рассматриваются как взаимодействующие между собой с помощью процессов. Таким образом весь обмен информацией рассматривается как связь между процессами.</p><p>Поскольку процессу может потребоваться возможность различать коммуникационные потоки между разными процессами, мы предполагаем, что каждый процесс может иметь номер порта, через который он осуществляет взаимодействие с портами других процессов.</p><h3 id="p2.2">2.2. Модель работы протокола</h3><p>Процесс передает данные, вызывая функции TCP с передачей им буферов данных в качестве аргументов. TCP упаковывает данные из таких буферов в сегменты и вызывает модуль IP для передачи каждого сегмента адресату TCP. На приемной стороне TCP помещает данные из сегмента в приемный пользовательский буфер и уведомляет заинтересованного пользователя. TCP включает в сегменты управляющую информацию, которая служит для обеспечения гарантированной доставки с сохранением порядка сегментов.</p><p>Модель обмена информацией в IP построена на базе связанного с каждым TCP модуля протоколов internet, который обеспечивает интерфейс с локальной сетью. Модуль internet упаковывает сегменты TCP в дейтаграммы IP и маршрутизирует дейтаграммы модулю IP хоста-получателя или промежуточного шлюза. Для передачи дейтаграмм через локальную сеть они помещаются в кадры ЛВС.</p><p>Коммутация пакетов может включать дополнительное разбиение на пакеты, фрагментирование или иные операции, обеспечивающие доставку локальных пакетов модулю IP хоста-адресата.</p><p>В шлюзах между сетями дейтаграммы IP "разворачиваются" (unwrapped) из локальных пакетов и проверяются не предмет определения сети, в которую их следует переслать. После этого дейтаграмма IP снова "заворачивается" (wrapped) в локальный пакет, подходящий для следующей сети и направляется в следующий шлюз или конечному получателю.</p><p>Шлюз может разбивать дейтаграммы IP на меньшие дейтаграммы (фрагменты), если это требуется для передачи в следующую сеть. Для этого дейтаграмма делится на несколько более мелких дейтаграмм IP, каждая из которых содержит фрагмент исходной дейтаграммы. На следующих шлюзах эти фрагменты могут дополнительно фрагментироваться. Формат фрагментов организован таким способом, чтобы модуль IP конечного получателя мог заново собрать из фрагментов исходную дейтаграмму. Модуль IP конечного получателя разворачивает сегменты из дейтаграмм (после сборки фрагментов, если необходимо) и передает их конечному модулю TCP.</p><p>В рассмотренной модели опущено множество деталей. Одним из важных аспектов является тип обслуживания — он говорит маршрутизаторам (или модулю IP), какие параметры обслуживания следует выбрать для передачи в следующую сеть. Включенная в тип обслуживания информация задает преимущества (приоритет) дейтаграммы, Дейтаграмма может содержать также информацию о безопасности, позволяющую хостам и шлюзам, работающим в многоуровневой безопасной среде корректно разделять дейтаграммы с точки зрения требований безопасности.</p><h3 id="p2.3">2.3. Среда хоста</h3><p>Предполагается, что TCP является модулем операционной системы. Пользователи обращаются к TCP подобно обращению к другим функциям ОС. TCP может вызывать другие функции ОС (например, для управления структурами данных). Предполагается, что реальный интерфейс с сетью управляется драйвером сетевого адаптера. TCP не может непосредственно обращаться к драйверу сетевого устройства и взамен этого обращается к модулю протокола IP, который обращается к драйверу напрямую.</p><p>Механизмы TCP не мешают реализации протокола TCP на периферийных процессорах. Однако в таких реализациях должен обеспечиваться протокол взаимодействия между хостом и периферийным процессором для поддержки интерфейса TCP — пользователь, описанного в этом документе.</p><h3 id="p2.4">2.4. Интерфейсы</h3><p>Интерфейс между TCP и пользователем обеспечивается с помощью функций TCP для организации (OPEN) и разрыва (CLOSE) соединений, передачи (SEND) и приема (RECEIVE) данных, а также получения информации (STATUS) о соединении. Вызовы этих функций осуществляются из пользовательских программ подобно вызовам функций ОС (например, функции открытия, чтения и закрытия файла).</p><p>Интерфейс TCP — IP обеспечивается с помощью функций передачи и приема дейтаграмм, адресованных модулям TCP на любых хостах системы internet. Эти функции используют параметры для передачи адресов, типа обслуживания, предпочтений, безопасности и другой управляющей информации.</p><h3 id="p2.5">2.5. Связи с другими протоколами</h3><p>На рисунке показано местоположение TCP в иерархии протоколов:</p><pre>+------+ +-----+ +-----+       +-----+
|Telnet| | FTP | |Voice|  ...  |     |  Уровень приложений
+------+ +-----+ +-----+       +-----+
      |   |         |             |
     +-----+     +-----+       +-----+
     | TCP |     | RTP |  ...  |     |  Уровень хоста
     +-----+     +-----+       +-----+
        |           |             |
     +-------------------------------+
     |    Internet Protocol & ICMP   |  Уровень шлюза
     +-------------------------------+
                    |
       +---------------------------+
       |   Local Network Protocol  |    Сетевой уровень
       +---------------------------+

Рисунок 2. Отношения между протоколами</pre><p>Ожидается, что TCP будет эффективно поддерживать протоколы верхнего уровня. Должен обеспечиваться простой интерфейс с протоколами вышележащего уровня типа Telnet или AUTODIN II THP.</p><h3 id="p2.6">2.6. Надежная связь</h3><p>Переданный модулю TCP поток данных гарантированно и с соблюдением порядка доставляется адресату.</p><p>Надежность передачи обеспечивается за счет использования порядковых номеров и передачи подтверждений. Концептуально, каждому октету данных присваивается порядковый номер. Номер первого октета данных в сегменте передается вместе с этим сегментом и называется порядковым номером сегмента. Сегмент содержит также номер подтверждения, который является порядковым номером следующего ожидаемого октета данных, который будет передан в обратном направлении. Когда TCP передает сегмент, содержащий данные, копия этого сегмента помещается в очередь повторной передачи и включается таймер. При получении подтверждения доставки переданного сегмента его копия удаляется из очереди. Если подтверждение не поступило в течение заданного времени (тайм-аут), сегмент передается снова.</p><p>Подтверждение TCP не дает гарантии доставки данных конечному пользователю, оно лишь удостоверяет, что сегмент доставлен модулю TCP на удаленной стороне, который обеспечивает доставку клиенту.</p><p>Для управления потоками данных между хостами TCP используется специальный механизм управления потоком. TCP на приемной стороне сообщает размер "окна" передающему модулю TCP. Этот размер задает число октетов (начиная с номера подтверждения), которые модуль TCP на приемной стороне готов получить в настоящий момент.</p><h3 id="p2.7">2.7. Организация и разрыв соединений</h3><p>Для идентификации отдельных потоков данных, которыми может управлять TCP, этот протокол поддерживает идентификаторы портов. Поскольку идентификаторы портов выбираются независимо разработчиками реализаций TCP, эти идентификаторы могут оказаться неуникальными. Для обеспечения уникальной адресации каждого TCP идентификатор порта объединяется с адресом IP для хоста TCP; такая комбинация порта и адреса называется сокетом. Для сокетов обеспечивается уникальность в масштабах Сети.</p><p>Соединение однозначно идентифицируется парой сокетов для обоих концов соединения. Локальный сокет может использоваться во множестве соединений с различными внешними сокетами. Соединение может использоваться для передачи данных в обоих направлениях, т. е. является "полнодуплексным".</p><p>TCP распределяет номера портов между процессами по своему усмотрению, однако существуют базовые концепции, которым необходимо следовать в каждой реализации. Должны поддерживаться "хорошо известные" (well-known) номера портов, которые TCP будет связывать только с определенными процессами. Предполагается, что такими процессами могут быть собственные процессы TCP и эти процессы могут инициировать соединения только через такие "привилегированные" порты. Применительно к реализации распределение портов является локальным вопросом, но предполагается наличие пользовательской команды Request Port или иного метода выделения уникальной группы портов для данного процесса (например, путем связывания старших битов в номере порта с данным процессом).</p><p>При вызове OPEN соединение задается номером локального порта и удаленного сокета, передаваемыми в качестве аргументов. В ответ TCP возвращает короткое локальное имя соединения, которое пользователь может указывать в последующих вызовах функций. Есть несколько важных аспектов организации соединений, о которых следует помнить. Предполагается, что информация о соединении хранится в структуре данных TCB (Transmission Control Block — блок управления передачей). В некоторых реализациях локальное имя соединения просто указывает на структуру TCB для этого соединения. При вызове OPEN также указывается тип вызова — активный (соединение организуется сразу) или пассивный (ожидание).</p><p>Пассивный запрос OPEN означает, что процесс будет ждать входящего соединения, не делая попыток организовать соединение самому. Зачастую процесс, использовавший пассивный вызов OPEN, будет воспринимать входящие запросы соединений от любого хоста. В таких случаях внешний сокет с номером, содержащим только нули, будет использоваться для обозначения неуказанного сокета. Использование неуказанных внешних сокетов допускается только для пассивных вызовов OPEN. Сервисный процесс, который намерен обслуживать вызовы от неизвестных процессов, должен использовать пассивный вызов OPEN с неуказанным внешним сокетом. В таких случаях соединение может быть организовано с любым процессом, который запросит соединение с данным локальным сокетом. Такое решение полезно в тех случаях, когда известно, что локальный сокет связан с известным сервисом.</p><p>Сокеты Well-known обеспечивают удобный способ связывания адресов со стандартными службами. Например, серверный процесс Telnet постоянно связан с конкретным сокетом, а другие известные сокеты зарезервированы для таких служб как File Transfer, Remote Job Entry, Text Generator, Echoer, Sink (последние три используются в тестовых целях). Адрес сокета может быть зарезервирован для доступа к службе Look-Up, возвращающей номер сокета, по которому предоставляется новый сервис. Концепция хорошо известных сокетов является частью спецификации TCP, но выделение номеров для сокетов выходит за пределы этого документа (см. [RFC790]).</p><p>Процесс может использовать пассивный вызов OPEN и ждать соответствующего активного вызова OPEN другим процессом; после организации нужного соединения TCP будет информировать процесс об этом. Два процесса, одновременно использовавшие активные вызовы OPEN для связи друг с другом, будут корректно соединены. Такая гибкость очень важна для поддержки распределенных систем, в которых компоненты работают асинхронно.</p><p>Существует два важных случая соответствия между локальным пассивным вызовом OPEN и внешним активным вызовом OPEN. В первом случае локальный пассивный вызов OPEN полностью задает внешний сокет — соответствие является точным. Во втором случае локальный пассивный вызов OPEN оставляет внешний сокет неуказанным — приемлемы соединения с любыми внешними сокетами, соответствующими локальному сокету. Остальные случаи являются промежуточными вариантами. При наличии нескольких ожидающих пассивных вызовов OPEN (записанных в TCB) с одинаковым локальным сокетом внешний активный вызов OPEN будет соответствовать TCB в указанным внешним сокетом, который совпадает с внешним активным вызовом OPEN (при наличии такого TCB); в остальных случаях выбор осуществляется среди TCB с неуказанным внешним сокетом.</p><p>Процедуры организации соединений используют флаг контроля синхронизации (SYN) и включают обмен тремя сообщениями, известными three-way hand shake (трехэтапное согласование) [3].</p><p>Соединение инициируется при наличии входящего сегмента с флагом SYN и ожидающей записи TCB, которая была создана с помощью функции OPEN. Соответствие локального и внешнего сокета определяет возможность организации соединения. Соединение переходит в состояние established (организовано) после синхронизации порядковых номеров для обоих направлений. Разрыв соединения также включает обмен сегментами — в этом случае они содержат флаг завершения FIN.</p><h3 id="p2.8">2.8. Обмен данными</h3><p>Данные, передаваемые через соединение, можно трактовать как поток октетов. Передающая сторона показывает при каждом вызове SEND наличие в этом вызове (и любых предшествующих вызовах) данных, которые должны быть отправлены незамедлительно (push) на принимающую сторону, с помощью флага PUSH.</p><p>TCP на передающей стороне разрешается собирать данные от пользователей-отправителей и передавать эти данные в сегменты по своему усмотрению, пока не используется функция push (выталкивание). После вызова этой функции все неотправленные данные должны быть переданы. Когда TCP на приемной стороне видит флаг PUSH, модуль больше не должен ждать данных от передающего модуля TCP до передачи их принимающему процессу.</p><p>Нет необходимости задавать связи между функцией push и границами сегментов. Данные в любом сегменте могут быть результатом одного вызова SEND (все или часть результатов вызова) или множества обращений к SEND. Назначением функции push и флага PUSH является "проталкивание" данных от отправителя к получателю. Функция не обеспечивает сервис записи (record service).</p><p>Между функцией push и использованием буферов данных, проходящих через интерфейс TCP-пользователь, существует связь. Всякий раз флаг PUSH связывается с данными, помещенными в буфер на приемной стороне, и содержимое этого буфера передается пользователю для обработки, даже если буфер еще не полон. Если данные заполняют пользовательский буфер до получения флага PUSH, содержимое буфера передается пользователю целиком.</p><p>TCP также обеспечивает способ информирования принимающей стороны о наличии в потоке, который принимается в настоящее время, данных, требующих срочной обработки (urgent data). TCP не пытается задать, что конкретно должен делать пользователь при получении уведомления о срочных данных, но в общем случае принимающий процесс будет предпринимать попытки максимально быстрой обработки таких данных.</p><h3 id="p2.9">2.9. Предпочтения и безопасность</h3><p>TCP позволяет использовать поля типа обслуживания и безопасности протокола IP для задания предпочтений и обеспечения безопасности на уровне соединений. Не все модули TCP могут использоваться в средах с многоуровневой системой обеспечения безопасности — некоторые функции могут быть ограничены только для неклассифицированного использования, другие могут работать только для определенного уровня безопасности. Следовательно, некоторые реализации и службы TCP могут иметь ограниченную функциональность в средах с многоуровневой системой обеспечения безопасности.</p><p>Модули TCP, работающие в среде с многоуровневой системой безопасности, должны корректно помечать уровень безопасности и предпочтения для исходящих сегментов. Такие модули TCP должны также обеспечивать для своих пользователей и протоколов вышележащих уровней (типа Telnet или THP) интерфейс, позволяющий им задать желаемый уровень безопасности и предпочтения для своих соединений.</p><h3 id="p2.10">2.10. Принцип устойчивости</h3><p>Реализации TCP должны следовать общему принципу устойчивости — быть консервативным по отношению к себе и либеральным с другими.</p><h2 id="p3">3. Функциональная спецификация</h2><h3 id="p3.1">3.1. Формат заголовка</h3><p>Сегменты TCP передаются в дейтаграммах IP. Заголовок протокола IP содержит несколько информационных полей, включая адреса хостов отправителя и получателя [<a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC791</a>]. Заголовок TCP размещается вслед за заголовком IP и содержит информацию, относящуюся к протоколу TCP. Такое разделение позволяет использовать на уровне хоста протоколы, отличные от TCP.</p><h4>Формат заголовка TCP</h4><pre> 0                   1                   2                   3   
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             |
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Рисунок 3. Формат заголовка TCP</pre><ul><li class="b">Source Port — порт отправителя: 16 битов</li><li class="lib">Номер порта отправителя.</li><li class="b">Destination Port — порт назначения: 16 битов</li><li class="lib">Номер порта получателя.</li><li class="b">Sequence Number — порядковый номер: 32 бита</li><li class="lib">Порядковый номер первого октета данных в сегменте при отсутствии флага SYN. Если в сегменте присутствует бит SYN, поле номера содержит значение начального порядкового номера (ISN), а первый октет данных имеет номер ISN+1.</li><li class="b">Acknowledgment Number — номер подтверждения: 32 бита</li><li class="lib">Если бит ACK установлен, это поле содержит значение следующего порядкового номера, который отправитель сегмента ожидает получить. После организации соединения это значение передается всегда.</li><li class="b">Data Offset — смещение данных: 4 бита</li><li class="lib">Число 32-битовых слов в заголовке TCP. Это значение указывает начало данных в сегменте. Заголовок TCP (даже при наличии опций) имеет длину, кратную 32 битам.</li><li class="b">Reserved — резервное поле: 6 битов</li><li class="lib">Зарезервировано для использования в будущем и должно иметь нулевое значение.</li><li class="b">Control Bits — биты управления: 6 битов (слева направо):</li><li class="lib">URG: указывает на значимость поля Urgent Pointer</li><li class="lib">ACK: указывает на значимость поля Acknowledgment Number</li><li class="lib">PSH: функция Push</li><li class="lib">RST: сброс (Reset) соединения</li><li class="lib">SYN: синхронизация порядковых номеров</li><li class="lib">FIN: у отправителя больше нет данных</li><li class="b">Window — окно: 16 битов</li><li class="lib">Число октетов данных, начиная с указанного в поле подтверждения, которые отправитель данного сегмента ожидает принять.</li><li class="b">Checksum — контрольная сумма: 16 битов</li><li class="lib"><p>Контрольная сумма представляет собой число единиц в заголовке и данных, просуммированное по модулю 16 с добавлением 1. Если сегмент содержит в заголовке и данных нечетное число октетов, справа добавляется октет нулей для выравнивания по 16-битовой границе. Биты заполнения не передаются как часть сегмента и используются только для расчета контрольной суммы. При расчете контрольной суммы значение поля Checksum принимается нулевым.</p><p>Контрольная сумма учитывает также 96-битовый псевдозаголовок, предшествующий заголовку TCP. Этот псевдозаголовок содержит адреса отправителя и получателя, тип протокола и длину опций TCP. Перечисленные поля помогают защитить TCP против сегментов с ошибочной маршрутизацией. Эта информация транспортируется протоколом IP и передается через интерфейс TCP-сетевой уровень в качестве аргументов или результатов вызовов из TCP на уровень IP.</p><table class="c"><tr><td colspan="3">Адрес отправителя</td></tr><tr><td colspan="3">Адрес получателя</td></tr><tr><td>0</td><td>PTCL</td><td>Размер TCP</td></tr></table></li><li class="lib">Поле TCP Length содержит размер заголовка TCP и поля данных в октетах (это не явно передаваемое, а расчетное значение); 12-октетный псевдозаголовок при расчете длины не учитывается.</li><li class="b">Urgent Pointer — указатель срочности: 16 битов</li><li class="lib">Это поле содержит указатель на срочные данные — позитивное смещение начала таких данных от порядкового номера данного сегмента. Это поле имеет смысл только для сегментов с установленным флагом URG.</li><li class="b">Options — опции: переменная длина</li><li class="lib"><p>Опции размещаются в конце заголовка TCP и могут занимать целое число октетов. Все опции учитываются при расчете контрольной суммы. Опции могут начинаться на любой границе октета. Существует два варианта форматирования опций:</p><ol><li>однооктетное поле признака опций.</li><li>однооктетное поле признака опций, поле размера опций (1 октет) и собственно опции.</li></ol><p>Поле размера опций учитывает и 2 октета полей признака опций и самого поля длины, а также размер опций, как таковых. Протокол TCP должен поддерживать все опции.</p><p>Определенные к настоящему моменту опции включают (признаки указаны восьмеричными значениями):</p><table><tr><td>Признак</td><td>Размер</td><td colspan="2" style="text-align:center">Значение</td></tr><tr><td>0</td><td>-</td><td>End of option list</td><td>Конец списка опций</td></tr><tr><td>1</td><td>-</td><td>No-Operation</td><td>Нет операции</td></tr><tr><td>2</td><td>4</td><td>Maximum Segment Size</td><td>Максимальный размер сегмента</td></tr></table></li><li class="b">Определения опций</li><li class="lib"><ul><li class="b">End of Option List</li><li class="lib"><pre>+--------+
|00000000|
+--------+
признак=0</pre><p>Этот код говорит о завершении списка опций. Конец списка опций может не совпадать с концом заголовка TCP, заданным полем Data Offset. Код используется как индикатор завершения всех опций, а не какой-то конкретной и использование его требуется лишь в тех случаях, когда конец опций не совпадает с концом заголовка TCP.</p></li><li class="b">No-Operation</li><li class="lib"><pre>+--------+
|00000001|
+--------+
признак=1</pre><p>Этот код может использоваться между опциями (например, для их выравнивания по границе слова). Не существует гарантий использования этой опции отправителем, поэтому получатель должен быть готов к обработке опций, начало которых не совпадает с границей слова.</p></li><li class="b">Maximum Segment Size</li><li class="lib"><pre>+--------+--------+---------+--------+
|00000010|00000100|   max seg size   |
+--------+--------+---------+--------+
признак=2 размер=4</pre></li></ul></li><li class="b">Maximum Segment Size — максимальный размер сегмента: 16 битов</li><li class="lib">Если эта опция присутствует, она задает максимальный размер принимаемого сегмента для той стороны TCP, которая передает данный сегмент. Это поле должно передаваться только с начальным запросом организации соединения (сегмент с флагом SYN). Если эта опция не задана, допускается использование сегментов любого размера.</li><li class="b">Padding — заполнение: переменная длина</li><li class="lib">Заполнение заголовка TCP используется для выравнивания размера заголовка по 32-битовой границе. Для заполнения неиспользуемых битов служит 0.</li></ul><h3 id="p3.2">3.2. Терминология</h3><p>Прежде, чем начать обсуждение деталей TCP, дадим определения некоторых терминов. Поддержка соединений TCP требует запоминания нескольких переменных. Предполагается, что эти переменные хранятся в специальной записи TCB (Transmission Control Block — блок управления передачей). Записи TCB включают номера локального и удаленного сокетов, опции безопасности и предпочтения для сегмента, указатели на пользовательские буферы приема и передачи, указатели на очередь повторной передачи и текущий сегмент. Кроме того, в TCB хранится информация о порядковых номерах для приема и передачи.</p><ul><li class="b">Переменные порядкового номера передачи</li><li class="lib">SND.UNA — передача не подтверждена</li><li class="lib">SND.NXT — передать следующим</li><li class="lib">SND.WND — окно передачи</li><li class="lib">SND.UP — передать указатель срочности</li><li class="lib">SND.WL1 — порядковый номер сегмента, использованный при последнем обновлении окна</li><li class="lib">SND.WL2 — порядковый номер подтверждения, использованный при последнем обновлении окна</li><li class="lib">ISS — начальный порядковый номер для передачи</li><li class="b">Переменные порядкового номера приема</li><li class="lib">RCV.NXT — принять следующим</li><li class="lib">RCV.WND — окно приема</li><li class="lib">RCV.UP — прием указателя срочности</li><li class="lib">IRS — начальный порядковый номер для приема</li></ul><p>Приведенные ниже рисунки помогут понять соотношения между переменными в пространстве порядковых номеров.</p><h4>Пространство номеров для передачи</h4><pre>     1         2          3          4 
----------|----------|----------|----------
       SND.UNA    SND.NXT    SND.UNA
                            +SND.WND

Рисунок 4. Пространство номеров для передачи</pre><ol><li>старые порядковые номера, которые были подтверждены</li><li>порядковые номера неподтвержденных данных</li><li>порядковые номера, допустимые для новой передачи данных</li><li>будущие порядковые номера, которые еще не разрешены для использования</li></ol><p>Окно передачи является частью области 3 на рисунке 4.</p><h4>Пространство номеров для приема</h4><pre>    1          2          3
----------|----------|----------
       RCV.NXT    RCV.NXT
                 +RCV.WND

Рисунок 5. Пространство номеров для приема</pre><ol><li>старые порядковые номера, которые были подтверждены</li><li>порядковые номера, допустимые для нового приема данных</li><li>будущие порядковые номера, которые еще не разрешены для использования</li></ol><p>Окно приема является частью области 2 на рисунке 5.</p><p>Существует также ряд переменных, часто используемых при обсуждении, которые берут свои значения из полей текущего сегмента.</p><h4>Переменные текущего сегмента</h4><ul><li>SEG.SEQ — порядковый номер сегмента</li><li>SEG.ACK — порядковый номер сегмента подтверждения</li><li>SEG.LEN — длина сегмента</li><li>SEG.WND — окно сегмента</li><li>SEG.UP — указатель срочности сегмента</li><li>SEG.PRC — значение предпочтений для сегмента</li></ul><p>Соединение в процессе своего существования может находиться в нескольких состояниях — LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT и фиктивное состояние CLOSED (фиктивно оно потому, что представляет состояние, когда уже нет TCB и, следовательно, соединения). Ниже кратко описаны все эти состояния.</p><ul><li>LISTEN — ожидание запроса на соединение от любого удаленного TCP и порта.</li><li>SYN-SENT — ожидание соответствующего запроса на соединение после передачи своего запроса.</li><li>SYN-RECEIVED — ожидание подтверждения соединения после передачи и приема запросов на организацию соединения.</li><li>ESTABLISHED — соединение действует и принятые данные могут быть доставлены пользователю. Это нормальное состояние для процесса обмена данными через соединение.</li><li>FIN-WAIT-1 — ожидание запроса на разрыв соединения от удаленного TCP или подтверждения для ранее переданного запроса на разрыв соединения.</li><li>FIN-WAIT-2 — ожидание запроса на разрыв соединения от удаленного TCP.</li><li>CLOSE-WAIT — ожидание запроса на разрыв соединения от локального пользователя.</li><li>CLOSING — ожидание подтверждения от удаленного TCP для запроса на разрыв соединения.</li><li>LAST-ACK — ожидание подтверждения для запроса на разрыв соединения, переданного удаленному TCP (это подтверждение включается в запрос на разрыв соединения от удаленной стороны).</li><li>TIME-WAIT — ожидание пока пройдет достаточно времени, чтобы быть уверенным в приеме удаленным TCP подтверждения для его запроса на разрыв соединения.</li><li>CLOSED — соединения уже нет (разорвано).</li></ul><p>Соединение TCP переходит от одного состояния к другому в ответ на события, к числу которых относятся пользовательские вызовы OPEN, SEND, RECEIVE, CLOSE, ABORT и STATUS, входящие сегменты (в частности те, которые включают флаги SYN, ACK, RST, FIN) и тайм-ауты.</p><p>Диаграмма состояний на рисунке 65 иллюстрирует смену состояний в результате тех или иных событий и результирующие действия, но не содержит информации о возможных ошибках и действиях, не связанных с изменением состояния. В последующих параграфах будет приведено более детальное описание реакций TCP на те или иные события.</p><pre>                             +---------+ ---------\      active OPEN  
                             |  CLOSED |            \    -----------  
                             +---------+&lt;---------\   \   create TCB  
                               |     ^              \   \  snd SYN    
                  passive OPEN |     |   CLOSE        \   \           
                  ------------ |     | ----------       \   \         
                   create TCB  |     | delete TCB         \   \       
                               V     |                      \   \     
                             +---------+            CLOSE    |    \   
                             |  LISTEN |          ---------- |     |  
                             +---------+          delete TCB |     |  
                  rcv SYN      |     |     SEND              |     |  
                 -----------   |     |    -------            |     V  
+---------+      snd SYN,ACK  /       \   snd SYN          +---------+
|         |&lt;-----------------           ------------------>|         |
|   SYN   |                    rcv SYN                     |   SYN   |
|   RCVD  |&lt;-----------------------------------------------|   SENT  |
|         |                    snd ACK                     |         |
|         |------------------           -------------------|         |
+---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
  |           --------------   |     |   -----------                  
  |                  x         |     |     snd ACK                    
  |                            V     V                                
  |  CLOSE                   +---------+                              
  | -------                  |  ESTAB  |                              
  | snd FIN                  +---------+                              
  |                   CLOSE    |     |    rcv FIN                     
  V                  -------   |     |    -------                     
+---------+          snd FIN  /       \   snd ACK          +---------+
|  FIN    |&lt;-----------------           ------------------>|  CLOSE  |
| WAIT-1  |------------------                              |   WAIT  |
+---------+          rcv FIN  \                            +---------+
  | rcv ACK of FIN   -------   |                            CLOSE  |  
  | --------------   snd ACK   |                           ------- |  
  V        x                   V                           snd FIN V  
+---------+                  +---------+                   +---------+
|FINWAIT-2|                  | CLOSING |                   | LAST-ACK|
+---------+                  +---------+                   +---------+
  |                rcv ACK of FIN |                 rcv ACK of FIN |  
  |  rcv FIN       -------------- |    Timeout=2MSL -------------- |  
  |  -------              x       V    ------------        x       V  
   \ snd ACK                 +---------+delete TCB         +---------+
    ------------------------>|TIME WAIT|------------------>| CLOSED  |
                             +---------+                   +---------+

Рисунок 6. Состояния соединений TCP</pre><h3 id="p3.3">3.3. Порядковые номера</h3><p>Одним из фундаментальных аспектов TCP является нумерация данных — каждый октет, передаваемый через соединение TCP имеет свой порядковый номер. Поскольку каждый октет пронумерован, для любого из октетов может быть передано подтверждение (acknowledgment). Механизм подтверждений является кумулятивным (накопительным), поэтому подтверждение для порядкового номера X показывает, что все октеты до X (но не включая сам октет с номером X) были получены. Этот механизм позволяет обнаруживать дубликаты данных при использовании повторной передачи. Нумерация октетов в сегменте начинается от заголовка, т. е. октет, следующий сразу после заголовка, имеет наименьший порядковый номер, а номера следующих октетов последовательно возрастают.</p><p>Важно помнить, что реальное пространство порядковых номеров имеет ограниченные размеры, хотя и достаточно велико (от 0 до 2^32 - 1). Поскольку число порядковых номеров конечно, все арифметические операции с порядковыми номерами выполняются по модулю 2^32. Такая беззнаковая арифметика сохраняет соотношения между порядковыми номерами при переходе номера от 2^32 - 1 к нулю. В такой арифметике с использованием модуля существуют некоторые тонкости, которые следует принимать во внимание при разработке программ, использующих сравнение значений. Символ =&lt; означает "меньше или равно" (модуль 2^32).</p><p>Типичные операции сравнения порядковых номеров, используемые TCP, включают:</p><ul class="lat"><li>Проверка того, что подтверждение указывает на некоторый порядковый номер для посланных, но еще не подтвержденных данных.</li><li>Проверка того, что все порядковые номера, занимаемые сегментом, имеют подтверждение (например, для удаления сегмента из очереди повторной передачи).</li><li>Проверка того, что входящий сегмент содержит ожидаемые порядковые номера (например, чтобы убедиться в том, что сегмент "вписывается" в окно приема).</li></ul><p>В ответ на передачу данных TCP будет принимать подтверждения. При обработке подтверждений также выполняются операции сравнения порядковых номеров.</p><ul><li>SND.UNA = самый старый неподтвержденный номер</li><li>SND.NXT = порядковый номер для следующей передачи</li><li>SEG.ACK = подтверждение от принимающего TCP (следующий порядковый номер, ожидаемый TCP)</li><li>SEG.SEQ = первый порядковый номер для сегмента</li><li>SEG.LEN = число октетов в сегменте, занятых данными (с учетом SYN и FIN)</li><li>SEG.SEQ+SEG.LEN-1 = последний порядковый номер для сегмента</li></ul><p>Для новых подтверждений (их называют acceptable ack — подтверждение доступности) должно выполняться неравенство:</p><pre>SND.UNA &lt; SEG.ACK =&lt; SND.NXT</pre><p>Сегмент в очереди на повторную передачу считается полностью подтвержденным, если сумма его порядкового номера и длины не превышает порядковый номер во входящем подтверждении.</p><p>Для приема данных должны выполняться проверки следующих параметров:</p><ul><li>RCV.NXT = следующий порядковый номер, ожидаемый во входящем сегменте и находящийся в левой (или нижней) части окна приема</li><li>RCV.NXT+RCV.WND-1 = последний порядковый номер, ожидаемый во входящем сегменте и находящийся в правой (или верхней) части окна приема</li><li>SEG.SEQ = первый порядковый номер, занимаемый входящим сегментом</li><li>SEG.SEQ+SEG.LEN-1 = последний порядковый номер, занимаемый входящим сегментом</li></ul><p>Сегмент считается занимающим часть корректного пространства порядковых номеров при условии:</p><pre>RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND</pre><p>или</p><pre>RCV.NXT =&lt; SEG.SEQ+SEG.LEN-1 &lt; RCV.NXT+RCV.WND</pre><p>Первое неравенство проверяет "попадание" в окно начала сегмента, второе относится к окончанию сегмента. Если выполняется хотя бы одно из условий, это говорит о том, что сегмент содержит данные из окна.</p><p>Реальные проверки несколько сложнее описанных. В результате использования нулевых окон и сегментов нулевой длины могут возникать четыре разных ситуации при восприятии входящих сегментов:</p><table><tr><td>Размер сегмента</td><td>Приемное окно</td><td>Проверка</td></tr><tr><td>0</td><td>0</td><td>SEG.SEQ = RCV.NXT</td></tr><tr><td>0</td><td>>0</td><td>RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND</td></tr><tr><td>>0</td><td>0</td><td>неприемлемо</td></tr><tr><td>>0</td><td>>0</td><td>RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND или<br />RCV.NXT =&lt; SEG.SEQ+SEG.LEN-1 &lt; RCV.NXT+RCV.WND</td></tr></table><p>Отметим, что при нулевом размере приемного окна никакие сегменты не принимаются, за исключением подтверждений ACK. Таким образом, TCP может поддерживать нулевое окно приема во время повторной передачи, сохраняя возможность приема сегментов ACK. Однако даже при нулевом приемном окне протокол TCP должен обрабатывать поля RST и URG во всех входящих сегментах.</p><p>Используемая схема нумерации обеспечивает также защиту управляющей информации. Это достигается за счет включения некоторых флагов управления в пространство порядковых номеров так, что они могут быть повторно переданы и подтверждены без конфликтов (т. е., используется одна и только одна копия флагов управления). Управляющая информация не переносится физически в пространстве данных сегмента. Следовательно, требуется адаптация правил выделения порядковых номеров с учетом флагов управления. Такая защита требуется только для флагов SYN и FIN, используемых лишь при организации и разрыве соединений. С учетом процессов порядковой нумерации флаг SYN размещается перед первым октетом данных в сегменте, а флаг FIN — вслед за последним октетом данных. Размер сегмента (SEG.LEN) учитывает поля данных и флагов управления. При наличии флага SYN переменная SEG.SEQ содержит порядковый номер SYN.</p><h4>Выбор начального номера</h4><p>Протокол не задает каких-либо ограничений на повторное использование соединений. Соединение определяется парой сокетов. Новые экземпляры соединения будут рассматриваться как "инкарнации". Однако в этом случае возникает проблема различий между инкарнациями — "как протокол TCP сможет определить дубликаты от предыдущей инкарнации соединения?" Эта проблема возникает в результате кратковременных успешных соединений или при разрывах соединений с "потерей памяти" и повторной организацией.</p><p>Во избежание конфликтов с сегментами прежних инкарнаций нужно предотвратить использование тех порядковых номеров сегментов, которые могут оставаться в сети от предыдущей инкарнации. Такая возможность должна обеспечиваться даже после краха TCP и потери информации об использованных порядковых номерах. При организации нового соединения генерируется начальный порядковый номер (initial sequence number) ISN. Генерация номера основана на текущем (возможно, фиктивном) 32-битовом значении времени, в котором младший бит инкрементируется приблизительно каждые 4 микросекунды. Таким образом, цикл номеров ISN занимает около 4.55 часа. Поскольку мы предполагаем, что сегмент сохраняется в сети в течение времени, не превышающего MSL (Maximum Segment Lifetime — максимальное время жизни сегмента), и значение MSL &lt; 4.55 час., можно считать значения ISN уникальными.</p><p>Для каждого соединения существует порядковый номер для приема и передачи. Начальный порядковый номер для передачи (ISS) выбирается передающим модулем TCP, а начальный номер для приема (IRS) определяется во время процедуры организации соединения.</p><p>Для организованных и инициализированных соединений два модуля TCP должны синхронизировать между собой порядковые номера. Это осуществляется в процессе обмена сегментами организации соединения, содержащими управляющий бит SYN (для синхронизации) и начальные порядковые номера. Для краткости сегменты с флагом SYN просто называют SYN. Следовательно, решение требует подходящего механизма для подбора начальных порядковых номеров и включает процедуру согласования параметров для обмена значениями ISN.</p><p>Для синхронизации требуется, чтобы каждая из сторон передала свой начальный порядковый номер удаленной стороне и получила от той подтверждение. Каждая из сторон должна получить от удаленной стороны ее начальный порядковый номер и передать обратно подтверждение.</p><ol><li>A --&gt; B SYN — мой порядковый номер X</li><li>A &lt;-- B ACK — ваш порядковый номер X</li><li>A &lt;-- B SYN — мой порядковый номер Y</li><li>A --&gt; B ACK — ваш порядковый номер Y</li></ol><p>Поскольку пп. 2 и 3 могут быть объединены в одном сообщении, такую процедуру называют 3-этапным согласованием (three way handshake).</p><p>Трехэтапное согласование необходимо, поскольку порядковые номера не связаны с глобальным сетевым временем и TCP может использовать различные механизмы выбора ISN. Получатель первого SYN не может проверить какой это сегмент (не является ли он старой задержавшейся копией), пока не узнает последнего порядкового номера, использованного для соединения (это не всегда возможно), и поэтому он должен запросить у отправителя проверку SYN. Трехэтапное согласование и преимущества схемы выделения номеров на основе времени рассмотрены в работе [3].</p><h4>Когда нужно сохранять паузу</h4><p>Для обеспечения уверенности в том, что TCP не создает сегментов с порядковыми номерами, которые могут дублироваться в старых сегментах, остающихся в сети, TCP должен сохранять молчание в течение максимального времени жизни сегмента MSL перед выделением каких-либо порядковых номеров для организации нового соединения или восстановления после сбоя с потерей информации об использованных порядковых номерах. Для данной спецификации значение MSL выбирается равным 2 минутам и может быть изменено, если практика покажет необходимость такого изменения. Отметим, что если по каким-то причинам происходит повторная инициализация TCP информация об использованных порядковых номерах сохраняется в памяти и ожидания не требуется, нужно лишь быть уверенным в том, что новые порядковые номера превышают использованные недавно.</p><h4>Концепция паузы TCP</h4><p>В соответствии с данной спецификацией хост после "краха" без сохранения каких-либо сведений о последних порядковых номерах, переданных через каждое активное (т. е., незакрытое) соединение, будет задерживать передачу каких-либо сегментов TCP по крайней мере в течение максимального времени жизни сегмента MSL в системе internet, частью которой является "упавший" хост. В следующих параграфах приведены пояснения для этой спецификации. Разработчики TCP могут пренебречь паузой, но тогда будет возникать риск восприятия некоторых старых сегментов вместо новых или отбрасывания новых данных некоторыми получателями в internet.</p><p>TCP потребляет часть пространства порядковых номеров всякий раз при формировании сегмента и передаче его в выходную очередь хоста-отправителя. Обнаружение дубликатов и механизм нумерации в протоколе TCP полагаются на уникальное связывание сегмента данных с пространством порядковых номеров, при котором не могут быть использованы все 2^32 значений порядковых номеров, пока сегменты с выделенными номерами не будут доставлены и подтверждены получателем. Все копии сегментов удаляются из internet. Без этого два различных сегмента TCP могут получить одинаковые или перекрывающиеся порядковые номера, что приведет к конфликту на приемной стороне, поскольку невозможно будет отличить новые данные от старой копии. Напомним, что каждый сегмент ограничен в пространстве порядковых номеров числом октетов данных в этом сегменте.</p><p>При нормальных условиях TCP сохраняет следующий порядковый номер для передачи и самый старый номер из ожидающих подтверждения, чтобы избежать ошибочного использования порядкового номера снова до того момента, как будет подтверждено его первое использование. Однако это не обеспечивает гарантии того, что старые дубликаты будут удалены из сети, поэтому пространство порядковых номеров сделано очень большим, чтобы снизить вероятность конфликта при одновременной доставке сегментов с перекрывающимися номерами. При скорости 2 Мбит/с затрачивается 4.5 часов на использование 2^32 порядковых номеров. Поскольку максимальное время жизни сегмента в сети точно не превышает нескольких десятков секунд, это обеспечивает достаточную защиту для недетерминированных сетей даже при скорости 10 Мбит/с. При скорости 100 Мбит/с цикл порядковых номеров занимает 5.4 мин. — это немного, но вполне достаточно.</p><p>Однако работа механизмов нумерации и обнаружения дубликатов может быть расстроена, если TCP на передающей стороне не помнит порядковых номеров, которые последними были использованы для данного соединения. Например, если TCP будет инициировать все соединения с порядковым номером 0, тогда при "крахе" и повторном запуске TCP может восстановить прежнее соединение (возможно после полудуплексного разрешения соединения)) и передать пакеты с порядковыми номерами, которые будут совпадать или перекрываться с номерами пакетов, находящимися в сети (переданными в предыдущей инкарнации того же соединения). При отсутствии информации о порядковых номерах, используемых для конкретного соединения, спецификация TCP рекомендует отправителю сделать задержку на время MSL перед передачей сегментов в соединение, чтобы дать время на исчезновение из сети сегментов от предыдущей инкарнации. Эта проблема сохраняет актуальность даже для хостов, использующих текущее время для генерации начальных порядковых номеров.</p><p>Предположим, что при организации соединения нумерация начинается со значения S. Предположим также, что соединение используется не очень интенсивно и функция генерации начального порядкового номера ISN(t) берет значение порядкового номера (скажем, S1) последнего сегмента, переданного этим TCP для конкретного соединения. Далее предположим, что хост "упал", загрузился снова и организовал новую инкарнацию соединения. В качестве начального выбран порядковый номер S1 = ISN(t) — последний использованный предыдущей инкарнацией соединения номер! Если восстановление происходит достаточно быстро, все старые дубликаты в сети, имеющие порядковые номера по соседству с S1, могут быть доставлены и восприняты как новые пакеты получателем новой инкарнации соединения.</p><p>Проблема состоит в том, что хост при восстановлении может не знать, как долго продолжался "крах" и существуют ли в системе старые дубликаты от прежней инкарнации соединения.</p><p>Одним из способов решения этой проблемы является задержка передачи сегментов на время MSL при восстановлении после "краха" — quite time. Хосты, которые предпочитают не ждать, рискуют спровоцировать конфликт между старыми и новыми пакетами для получателя. Разработчики могут предоставить пользователям TCP возможность выбора для каждого соединения режима ожидания после краха или реализовать режим quite time для всех соединений. Обычно, даже при включенном механизме ожидания последнее становится ненужным по истечении времени MSL после загрузки хоста.</p><p>Каждый переданный сегмент занимает не менее одного порядкового номера в пространстве номеров. Используемые сегментом номера считаются занятыми в течение времени MSL. Если после после "краха" новое соединение организуется слишком быстро и будет использовать порядковые номера, выделенные для сегментов предыдущей реинкарнации соединения, возможно перекрытие порядковых номеров и возникновение проблем на приемной стороне.</p><h3 id="p3.4">3.4. Организация соединения</h3><p>Для организации соединений используется процедура трехэтапного согласования (three-way handshake). Эта процедура обычно инициируется одним TCP, а TCP на удаленной стороне дает отклик. Трехэтапное согласование будет работать и при одновременном инициировании соединения с обеих сторон. При одновременной попытке каждый модуль TCP получает сегмент SYN, не содержащий подтверждения для переданного этой стороной ранее сегмента SYN. Потенциально возможно прибытие старого дубликата SYN в процессе одновременной организации соединения. Для решения таких проблем можно использовать сегменты reset.</p><p>Ниже рассмотрены несколько примеров организации соединений. Хотя в этих примерах не рассматривается синхронизация с использованием сегментов данных, она полностью легитимна, пока принимающая сторона TCP не будет доставлять данные пользователю до проверки их корректности (т. е., данные должны буферизоваться на приемной стороне, пока соединение не перейдет в состояние ESTABLISHED). Трехэтапное согласование снижает вероятность организации ложных соединений. Это согласование является компромиссом между расходом памяти и передачей сообщений, обеспечивающих информацию для проверки соединения.</p><p>Простейший вариант трехэтапного согласования показан на рисунке 7. Стрелка вправо (--&gt;) на рисунке показывает отправку сегмента от TCP A к TCP B или прибытие сегмента в B из A. Левая стрелка (&lt;--) показывает передачу сегментов в обратном направлении. Троеточия (...) показывают сегменты, которые еще остаются в сети (задержаны). XXX обозначает потерянные или отброшенные сегменты. В скобках () приведены комментарии. Состояния TCP представлены после отправки или прибытия сегментов (содержимое сегментов показано в центральной части каждой строки). Содержимое сегментов представлено в сокращенном виде — порядковый номер, флаги управления и поле ACK. Остальные поля (размер окна, адреса, длина сегмента) для краткости и простоты опущены.</p><pre>    TCP A                                                TCP B

1.  CLOSED                                               LISTEN

2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED

3.  ESTABLISHED &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED

4.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;       --&gt; ESTABLISHED

5.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; --&gt; ESTABLISHED

Рисунок 7. Базовое 3-этапное согласование для синхронизации соединения</pre><p>В строке 2 на рисунке 7 TCP A начинает передачу сегмента SYN, говорящего об использовании порядковых номеров, начиная со 100. В строке 3 TCP B передает SYN и подтверждение для принятого SYN в адрес TCP A. Отметим, что поле подтверждения показывает ожидание TCP B приема порядкового номера 101, подтверждающего SYN с номером 100.</p><p>В строке 4 TCP A отвечает пустым сегментом с подтверждением ACK для сегмента SYN от TCP B; в строке 5 TCP A передает некоторые данные. Отметим, что порядковый номер сегмента в строке 5 совпадает с номером в строке 4, поскольку ACK не занимает пространства порядковых номеров (если это сделать, придется подтверждать подтверждения — ACK для ACK!).</p><p>Одновременное инициирование соединения лишь незначительно сложнее (см. рисунок 8). Каждое соединение TCP проходит от состояния CLOSED через SYN-SENT и SYN-RECEIVED в состояние ESTABLISHED.</p><pre>    TCP A                                            TCP B

1.  CLOSED                                           CLOSED

2.  SYN-SENT     --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;              ...

3.  SYN-RECEIVED &lt;-- &lt;SEQ=300&gt;&lt;CTL=SYN&gt;              &lt;-- SYN-SENT

4.               ... &lt;SEQ=100&gt;&lt;CTL=SYN&gt;              --&gt; SYN-RECEIVED

5.  SYN-RECEIVED --&gt; &lt;SEQ=100&gt;&lt;ACK=301&gt;&lt;CTL=SYN,ACK&gt; ...

6.  ESTABLISHED  &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt; &lt;-- SYN-RECEIVED

7.               ... &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;     --&gt; ESTABLISHED

Рисунок 8. Одновременная синхронизация соединения</pre><p>Принципиальная необходимость использования трехэтапного согласования обусловлена стремлением избавиться от недоразумений, связанных со старыми дубликатами инициирования соединений. Для решения таких проблем используется специальное управляющее сообщение — reset (сброс). Если принимающая сторона TCP еще находится в несинхронизированном состоянии (т. е., SYN-SENT, SYN-RECEIVED), она возвращается в состояние LISTEN при получении reset. Если TCP находится с засинхронизированном состоянии (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIMEWAIT), соединение после reset разрывается и пользователю передается уведомление об этом. Позднее мы обсудим этот вопрос при рассмотрении полуоткрытых (half-open) соединений.</p><pre>    TCP A                                                TCP B

1.  CLOSED                                               LISTEN

2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               ...

3.  (duplicate) ... &lt;SEQ=90&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED

4.  SYN-SENT    &lt;-- &lt;SEQ=300&gt;&lt;ACK=91&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED

5.  SYN-SENT    --&gt; &lt;SEQ=91&gt;&lt;CTL=RST&gt;               --&gt; LISTEN


6.              ... &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED

7.  SYN-SENT    &lt;-- &lt;SEQ=400&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED

8.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=401&gt;&lt;CTL=ACK&gt;      --&gt; ESTABLISHED

Рисунок 9. Действия при получении старого дубликата SYN</pre><p>На рисунке 9 показан простой пример решения проблемы со старым дубликатом. В строке 3 старый дубликат SYN принимается TCP B, который не знает об этом и дает нормальный отклик (строка 4). TCP A детектирует некорректность поля ACK и возвращает RST (reset) с полем SEQ, делающим сегмент правдоподобным (believable). TCP B, получив RST, возвращается в состояние LISTEN. Когда оригинальный сегмент SYN наконец принимается (строка 6), происходит нормальная синхронизация. Если SYN в строке 6 приходит до RST, может потребоваться более сложный обмен сообщениями с передачей RST в обоих направлениях.</p><h4>Полуоткрытые соединения и другие аномалии</h4><p>Организованное соединение называют полуоткрытым (half-open), если одна из сторон TCP закрыла или прервала соединение от себя, а другая сторона не знает об этом или обе стороны находятся в рассинхронизированном состоянии в результате краха с потерей памяти. Такие соединения будут автоматически сбрасываться при попытке передачи данных в любом направлении. Однако, полуоткрытые соединения являются не совсем обычными и процедура восстановления для них будет отличаться.</p><p>Если на сайте A соединение больше не существует, тогда попытка пользователя с сайта B передать какие-либо данные через это соединение будет приводить к тому, что TCP B получит управляющее сообщение reset. Такое сообщение говорит TCP B о некорректности соединения и необходимости его разрыва.</p><p>Предположим, что пользователи A и B обменивались данными в момент краха TCP с потерей памяти на хосте A. В зависимости от операционной системы хоста A запускается тот или иной механизм повторной загрузки TCP. После восстановления TCP хост A будет пытаться организовать соединение заново или восстановить его. В результате хост может попытаться снова вызвать функцию OPEN для восстановления соединения или попытается вызвать SEND, надеясь, что соединение существует. Во втором случае будет получено сообщение об ошибке connection not open от локального (A) TCP. При попытке организации нового соединения TCP A будет передавать сегмент, содержащий SYN (этот сценарий показан на рисунке 10). После краха TCP A пользователь пытается заново организовать соединение, а TCP B предполагает, что соединение существует по прежнему.</p><pre>    TCP A                                           TCP B

1.  (CRASH)                               (send 300,receive 100)

2.  CLOSED                                           ESTABLISHED

3.  SYN-SENT --&gt; &lt;SEQ=400&gt;&lt;CTL=SYN&gt;              --&gt; (??)

4.  (!!)     &lt;-- &lt;SEQ=300&gt;&lt;ACK=100&gt;&lt;CTL=ACK&gt;     &lt;-- ESTABLISHED

5.  SYN-SENT --&gt; &lt;SEQ=100&gt;&lt;CTL=RST&gt;              --&gt; (Abort!!)

6.  SYN-SENT                                         CLOSED

7.  SYN-SENT --&gt; &lt;SEQ=400&gt;&lt;CTL=SYN&gt;              --&gt;

Рисунок 10. Обнаружение полуоткрытого соединения</pre><p>При получении SYN (строка 3) TCP B, будучи в синхронизированном состоянии, видит входящий сегмент за пределами окна и отвечает подтверждением с порядковым номером следующего сегмента, который ожидается (ACK 100). TCP A видит, что этот сегмент (подтверждение) не подтверждает ничего из переданного им и, будучи в рассинхронизированном состоянии, передает RST, поскольку обнаружено полуоткрытое соединение. TCP B прерывает соединение (строка 5). TCP A будет продолжать попытки организовать соединение, используя стандартную трехэтапную процедуру согласования (см. рисунок 7).</p><p>Интересный случай наблюдается при крахе TCP A, когда TCP B пытается передать данные, предполагая наличие синхронизированного соединения (см. рисунок 11). В этом случае данные, приходящие TCP A от TCP B (строка 2), не могут быть восприняты по причине отсутствия соединения, поэтому TCP A будет слать RST. Сообщение RST воспринимается TCP B, после чего соединение будет разорвано.</p><pre>    TCP A                                              TCP B

1.  (CRASH)                                   (send 300,receive 100)

2.  (??)    &lt;-- &lt;SEQ=300&gt;&lt;ACK=100&gt;&lt;DATA=10&gt;&lt;CTL=ACK&gt; &lt;-- ESTABLISHED

3.          --&gt; &lt;SEQ=100&gt;&lt;CTL=RST&gt;                   --&gt; (ABORT!!)

Рисунок 11. Активная сторона пытается использовать полуоткрытое соединение</pre><p>На рисунке 12 показаны TCP A и TCP B в пассивном состоянии, ожидающие SYN. Старый дубликат, принимаемый TCP B (строка 2), заставляет B начать действия. Возвращается сегмент SYN-ACK (строка 3), который заставляет TCP A генерировать RST (ACK в строке 3 не может быть принят). TCP B принимает сигнал сброса и возвращается в свое пассивное состояние LISTEN.</p><pre>    TCP A                                         TCP B

1.  LISTEN                                        LISTEN

2.       ... &lt;SEQ=Z&gt;&lt;CTL=SYN&gt;                --&gt;  SYN-RECEIVED

3.  (??) &lt;-- &lt;SEQ=X&gt;&lt;ACK=Z+1&gt;&lt;CTL=SYN,ACK&gt;   &lt;--  SYN-RECEIVED

4.       --&gt; &lt;SEQ=Z+1&gt;&lt;CTL=RST&gt;              --&gt;  (return to LISTEN!)

5.  LISTEN                                        LISTEN

Рисунок 12. Старый дубликат SYN инициирует Reset при двух пассивных сокетах</pre><p>Возможно множество других ситуаций, каждая из которых разрешается при соблюдении рассмотренных ниже правил генерации и обработки RST.</p><h4>Генерация Reset</h4><p>Как общее правило RST следует передавать всякий раз при получении сегмента, который представляется не предназначенным для данного соединения. В сомнительных случаях сигнал сброса передавать не следует.</p><p>Существует три группы состояний:</p><ol><li><p>Если соединения не существует (CLOSED), тогда reset передается в ответ на любой входящий сегмент, за исключением другого reset. В частности, сегменты SYN, адресованные в несуществующее соединение, отбрасываются описанным способом. Если входящий сегмент содержит поле ACK, reset берет порядковый номер из поля ACK, в остальных случаях для reset используется нулевой номер, а для поля ACK устанавливается значение, равное сумме порядкового номера и размера входящего сегмента. Соединение остается в состоянии CLOSED.</p></li><li><p>Если соединение находится в любом несинхронизированном состоянии (LISTEN, SYN-SENT, SYN-RECEIVED) и входящий сегмент подтверждает что-то, еще не посланное (содержит неприемлемое подтверждение ACK), или входящий сегмент имеет уровень безопасности или запрошенное разделение (compartment), которые не соответствуют точно безопасности и разделению для соединения, передается reset.</p><p>Если наш сегмент SYN не был подтвержден и уровень предпочтения для входящего сегмента выше запрошенного уровня, повышается локальный уровень предпочтения (если это разрешено пользователем и системой) или передается reset; если же уровень предпочтения для входящего сегмента ниже запрошенного уровня, обработка продолжается как при соответствии уровней предпочтения (если удаленный TCP не может поднять уровень предпочтения до соответствия локальному уровню, это будет обнаружено в следующем полученном сегменте и соединение будет разорвано). Если наш сегмент SYN подтвержден (возможно в данном входящем сегменте), уровень предпочтения для входящего сегмента должен точно соответствовать локальному уровню; если это не так, нужно передать reset.</p><p>Если входящий сегмент содержит ACK, reset принимает порядковый номер из поля ACK; в остальных случаях используется нулевой номер, а в поле ACK помещается сумма порядкового номера и размера входящего сегмента. Состояние соединения не изменяется.</p></li><li><p>Если соединение синхронизировано (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIMEWAIT), из любого неподходящего сегмента (с порядковым номером за пределами окна или неприемлемым номером подтверждения) следует извлекать только пустой сегмент подтверждения, содержащий текущий порядковый номер передачи, и подтверждение, показывающее следующий ожидаемый порядковый номер. Состояние соединения не изменяется.</p><p>Если входящий сегмент имеет уровень безопасности, разделение или уровень предпочтения, отличные от одноименных параметров соединения, передается reset и соединение переводится в состояние CLOSED. Для reset берется порядковый номер из поля ACK входящего сегмента.</p></li></ol><h4>Обработка Reset</h4><p>Во всех состояниях, за исключением SYN-SENT, сегменты RST проверяются по их полям SEQ. Сброс считается корректным, если его порядковый номер попадает в окно. В состоянии SYN-SENT (сегмент RST принимается в ответ на изначальный сегмент SYN) RST считается приемлемым, если поле ACK подтверждает SYN.</p><p>Получатель RST сначала проверяет сегмент, а потом меняет состояние. Если получатель находился в состоянии LISTEN, сигнал сброса игнорируется. Если получатель находится в состоянии SYN-RECEIVED, а перед этим был в состоянии LISTEN, он возвращается в состояние LISTEN; в остальных случаях получатель разрывает соединение и переходит в состояние CLOSED. Если получатель был в любом другом состоянии, он прерывает соединение, уведомляя пользователя, и переходит в состояние CLOSED.</p><h3 id="p3.5">3.5. Завершение соединения</h3><p>Операция CLOSE означает отсутствие данных для передачи. Уведомление о закрытии полнодуплексного соединения может породить недоразумения, поскольку принимающая сторона может не знать, как трактовать эту операцию. Предлагается трактовать CLOSE следующим образом — передавший CLOSE пользователь может продолжать использовать RECEIVE, пока не получит информацию о том, что другая сторона также использовала CLOSE. Таким образом, программа может инициировать несколько вызовов SEND, потом вызвать CLOSE и продолжать использовать RECEIVE, пока не будет получено уведомления о сбое RECEIVE по причине использования CLOSE на удаленной стороне. Предполагается, что TCP будет информировать пользователя о закрытии соединения удаленной стороной даже в тех случаях, когда все вызовы RECEIVE успешно обработаны, позволяя пользователю корректно завершить работу программы. TCP гарантированно доставит содержимое всех буферов SENT до того, как соединение будет закрыто, поэтому пользователь, который не ждет возврата каких-либо данных, должен лишь дождаться успешного перехода соединения в состояние CLOSED, чтобы быть уверенным в передаче всей своей информации на удаленную сторону. Пользователь должен сохранять для чтения соединение, которое он закрыл для записи, пока TCP не сообщит об отсутствии каких-либо данных.</p><p>Существует три различных варианта:</p><ol><li>Пользователь сообщает TCP о необходимость использовать CLOSE для завершения соединения.</li><li>Удаленный модуль TCP инициирует разрыв передачей управляющего сигнала FIN.</li><li>Обе стороны одновременно вызывают CLOSE.</li></ol><h4>1. завершение инициирует локальный пользователь</h4><p>В этом случае сегмент FIN может быть сгенерирован и помещен в выходную очередь. После этого вызовы пользователем функции SEND уже не будут приниматься TCP и соединение перейдет в состояние FIN-WAIT-1. Вызовы функции RECEIVE в этом состоянии допустимы. Все предшествующие сегменты и сегмент FIN будут передаваться, пока не будут получены для них подтверждения. Когда удаленная сторона TCP имеет подтвержденный сегмент FIN и передала свой FIN, первая сторона TCP может передать подтверждение ACK для этого FIN. Отметим, что TCP после получения FIN будет передавать ACK, но не будет слать свой сегмент FIN, пока локальный пользователь также не закроет соединение.</p><h4>2. TCP получает FIN из сети</h4><p>При получении незапрошенного сегмента FIN из сети принимающая сторона может передать ACK и запросить у пользователя закрыть соединение. Пользователь будет вызывать CLOSE, а TCP в ответ будет передавать FIN на удаленную сторону после передачи остающихся данных. TCP после этого будет ждать подтверждения своего сегмента FIN, а потом удалит соединение. Если ACK не приходит, соединение разрывается по истечении тайм-аута и пользователю передается уведомление.</p><h4>3. оба пользователя закрывают соединение одновременно</h4><p>Одновременный вызов CLOSE на обеих сторонах соединения приводит к обмену сегментами FIN. Когда все сегменты, предшествующие FIN, будут обработаны и подтверждены, каждая из сторон TCP может передать ACK для принятого сегмента FIN. После получения ACK обе стороны закрывают соединение.</p><pre>    TCP A                                                TCP B

1.  ESTABLISHED                                          ESTABLISHED

2.  (Close)
    FIN-WAIT-1  --&gt; &lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;CTL=FIN,ACK&gt;  --&gt; CLOSE-WAIT

3.  FIN-WAIT-2  &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt;      &lt;-- CLOSE-WAIT

4.                                                       (Close)
    TIME-WAIT   &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=FIN,ACK&gt;  &lt;-- LAST-ACK

5.  TIME-WAIT   --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;      --&gt; CLOSED

6.  (2 MSL)
    CLOSED

Рисунок 13. Нормальный порядок закрытия соединения</pre><pre>    TCP A                                                TCP B

1.  ESTABLISHED                                          ESTABLISHED

2.  (Close)                                              (Close)
    FIN-WAIT-1  --&gt; &lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;CTL=FIN,ACK&gt;  ... FIN-WAIT-1
                &lt;-- &lt;SEQ=300&gt;&lt;ACK=100&gt;&lt;CTL=FIN,ACK&gt;  &lt;--
                ... &lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;CTL=FIN,ACK&gt;  --&gt;

3.  CLOSING     --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;      ... CLOSING
                &lt;-- &lt;SEQ=301&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt;      &lt;--
                ... &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;      --&gt;

4.  TIME-WAIT                                            TIME-WAIT
    (2 MSL)                                              (2 MSL)
    CLOSED                                               CLOSED

Рисунок 14. Одновременное закрытия соединения</pre><h3 id="p3.6">3.6. Предпочтения и безопасность</h3><p>Задача организации соединений заключается и в том, чтобы дозволялись только соединения между портами, работающими с одинаковым уровнем безопасности и разделения (compartment) с обеих сторон и с высшим из двух указанных уровней предпочтения (precedence).</p><p>Предпочтения и параметры безопасности, используемые TCP, в точностью совпадают с одноименными параметрами протокола IP [<a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC791</a>]. В данной спецификации термины security/compartment служат для обозначения параметров безопасности, используемых в IP, включая безопасность, разделение (compartment), группы пользователей и ограничения на обслуживание.</p><p>Попытка соединения с несовпадающими параметрами безопасности или более низким уровнем предпочтения приводит к сбросу соединения (reset). Отказ от соединения при слишком низком уровне предпочтения происходит только после того, как будет получено подтверждение для сегмента SYN.</p><p>Отметим, что модули TCP, работающие только с принятым по умолчанию уровнем предпочтения, все равно будут проверять этот уровень для входящих сегментов и возможно повышать уровень предпочтения для данного соединения.</p><p>Параметры безопасности могут использоваться даже в небезопасных средах (значения будут задавать неклассифицированные данные), поэтому хосты в небезопасной среде должны быть готовы к приему параметров безопасности, хотя им нет нужды передавать эти параметры.</p><h3 id="p3.7">3.7. Обмен данными</h3><p>После организации соединения передача данных осуществляется путем обмена сегментами. Поскольку сегменты могут теряться в результате ошибок (некорректная контрольная сумма) или насыщения сети, TCP использует механизм повторной передачи (после тайм-аута) для обеспечения доставки каждого сегмента. В результате этого могут возникать дубликаты сегментов. Как было сказано при обсуждении порядковых номеров, TCP выполняет ряд проверок для порядковых номеров и номеров подтверждений перед восприятием сегментов.</p><p>Отправитель данных сохраняет следующий порядковый номер (который будет использован) в переменной SND.NXT. Получатель сохраняет следующий порядковый номер (который предполагается получить) в переменной RCV.NXT. Отправитель данных сохраняет порядковый номер последнего неподтвержденного сегмента в переменной SND.UNA. Если поток данных сейчас не передается (momentarily idle) и все отправленные ранее данные подтверждены, значения всех трех переменных будут совпадать.</p><p>Когда отправитель создает сегмент и передает его, значение SND.NXT увеличивается. Получатель, принимая сегмент, увеличивает значение RCV.NXT и передает подтверждение. Когда отправитель данных получает для них подтверждение, он увеличивает значение SND.UNA. Различия в значениях указанных переменных связаны с задержками при передаче сегментов через сеть. Величина, на которую изменяются значения переменных, определяется длиной данных в сегменте. Отметим, что в состоянии ESTABLISHED все сегменты должны передавать текущую информацию для подтверждений.</p><p>При вызове пользователем функции CLOSE выполняется выталкивание данных (функция push), как это делает управляющий флаг FIN во входящем сегменте.</p><h4>Тайм-аут повторной передачи</h4><p>В результате постоянно происходящих в сети изменений и использования различных соединений TCP значение тайм-аута для повторной передачи должно динамически изменяться. Ниже приведен пример определения значения тайм-аута для повторной передачи.</p><ul><li class="b">Пример процедуры тайм-аута</li><li class="lib"><p>Измеряется задержка между передачей октета данных с конкретным порядковым номером и получением подтверждения, покрывающего этот порядковый номер (переданные сегменты не точно соответствуют принятым), в единицах RTT (Round Trip Time — время обхода). После этого рассчитывается значение SRTT (Smoothed Round Trip Time — взвешенное время обхода), как:</p><pre>SRTT = ( ALPHA * SRTT ) + ((1-ALPHA) * RTT)</pre><p>и на основе этого рассчитывается тайм-аут для повторной передачи (RTO):</p><pre>RTO = min[UBOUND,max[LBOUND,(BETA*SRTT)]]</pre><p>где UBOUND задает верхний предел значения тайм-аута (например, 1 минута), LBOUND — нижний предел (например, 1 секунда), ALPHA — весовой фактор (например, 0.8 — 0.9), а BETA — коэффициент вариаций задержки (например, 1.3 — 2.0).</p></li></ul><h4>Обмен срочной информацией</h4><p>Механизм разделения информации по срочности позволяет передающей стороне стимулировать принимающую сторону на восприятие некоторых срочных данных и дает приемной стороне TCP возможность проинформировать пользователя, когда все полученные данные особой срочности будут переданы ему.</p><p>Этот механизм позволяет задать в потоке данных точку завершения данных особой срочности. Когда значение этого указателя превышает текущий порядковый номер для приема (RCV.NXT), модуль TCP должен сообщить пользователю о необходимости перехода в режим urgent; когда принимаемый порядковый номер превысит значение указателя срочности модуль TCP должен сказать пользователю о том, что нужно перейти в нормальный режим. Если указатель срочности обновляется, когда пользователь находится в режиме urgent, этого изменения пользователь не увидит.</p><p>Для реализации этого метода используется флаг срочности (urgent), передаваемый в каждом сегменте. Флаг URG показывает, что поле urgent имеет смысл и его значение должно быть добавлено к порядковому номеру сегмента для получения указателя на срочные данные. Отсутствие флага срочности говорит о том, что в сегменте нет данных особой срочности.</p><p>Передача указателя срочности говорит пользователю, что он также должен передать по крайней мере один октет данных. Если передающий пользователь применяет также функцию выталкивания (push), доставка срочной информации получателю ускоряется.</p><h4>Управление окном</h4><p>Окно, передаваемое в каждом сегменте, показывает диапазон порядковых номеров отправителя окна (получателя данных), которые он готов принять. Предполагается, что это значение связано с доступным в настоящее время буферным пространством для данного соединения.</p><p>Указание большого окна стимулирует передачу. Если данных приходит больше, чем может быть воспринято, они отбрасываются, в результате чего возникают повторы передачи, добавляющие ненужную нагрузку на сеть и TCP. Задание маленького окна будет ограничивать передачу данных — это связано с задержкой обхода (round trip delay) между передачей каждого нового сегмента.</p><p>Этот механизм позволяет TCP анонсировать большое окно и впоследствии многократно снижать размер окна. Такое явление называется shrinking the window (сжатие окна) и вносит серьезные препятствия. Принцип устойчивости требует от TCP "не сжимать свое окно, но быть готовым к такому сжатию со стороны других TCP".</p><p>Передающая сторона TCP должна быть готова принять от пользователя и передать по крайней мере один октет новых данных, даже если она передала нулевое окно. Передающая сторона TCP должна регулярно повторять передачу приемной стороне даже при установке нулевого окна. При установке нулевого окна рекомендуется повторять передачу каждые 2 минуты. Такой повтор важен для обеспечения гарантии, что при использовании другой стороной TCP нулевого размера окна при повторном открытии окна (re-opening) другая сторона гарантированно узнает об этом.</p><p>Когда принимающая сторона TCP имеет нулевое окно и получает сегмент, она сначала должна передать подтверждение, показывающее следующий ожидаемый номер и текущий размер окна (0).</p><p>Когда передающая сторона TCP пакует данные для передачи в сегменты, которые помещаются в текущее окно, возможна также повторная упаковка сегментов в очереди повторной передачи. Такая перепаковка не является обязательной, но может оказаться полезной.</p><p>В соединении с односторонним потоком данных информация об окне будет передаваться в сегментах подтверждений, которые имеют те же порядковые номера, поэтому при некорректном порядке доставки порядок подтверждений также изменится. Эта проблема не очень серьезна, но может приводить к временному использованию устаревшей информации об окне. Во избежание такой проблемы следует брать информацию об окне из сегмента с максимальным номером подтверждения (т. е., сегмента с номером подтверждения не меньшим, чем любой из полученных ранее).</p><p>Процедура управления окном оказывает существенное влияние на производительность обмена данными, Ниже приведены рекомендации по реализации таких процедур.</p><h4>Предложения по управлению окном</h4><p>Выделение слишком маленького окна заставляет передавать данные очень мелкими сегментами, снижая производительность обмена информацией.</p><p>Для того, чтобы избежать использования слишком мелких окон, приемной стороне следует воздерживаться от обновления окна, пока не будет возможно выделить по крайней мере X% от максимального размера (X может принимать значение от 20 до 40). Другим способом является предотвращение передачи слишком мелких сегментов отправителем за счет ожидания перед отправкой данных расширения окна до подходящего размера. Если пользователь вызывает функцию push, данные должны передаваться даже в виде небольших сегментов.</p><p class="note">Отметим, что передача подтверждений не должна слишком задерживаться, поскольку такая задержка приведет к повторам передачи. Одним из вариантов является передача подтверждения при получении мелкого сегмента (без информации об изменении окна) и передача другого подтверждения с новой информацией об увеличении окна.</p><p>Сегмент, передаваемый для проверки нулевого окна, может инициировать разбиение данных на все более мелкие сегменты. Если сегмент с одним октетом данных передать для проверки нулевого окна, этот сегмент потребит один октет доступной части окна. Если передающая сторона TCP просто будет передавать сегменты как будто окно имеет ненулевой размер, передача данных будет вестись в форме больших и мелких сегментов поочередно. В таких ситуациях случайная пауза при выделении окна на приемной стороне будет приводить к разбиению крупных сегментов на мелкие и средние. В конечном итоге практически все данные станут передаваться в мелких сегментах.</p><p>Основным предложением для реализации TCP является необходимость активных попыток объединения мелких окон в окна большего размера, поскольку механизмы управления окном имеют тенденцию к снижению размера окна во многих простых реализациях.</p><h3 id="p3.8">3.8. Интерфейсы</h3><p>Протокол TCP поддерживает два интерфейса — с пользовательским уровнем и протоколами нижележащего уровня. Здесь будет подробно рассмотрена спецификация интерфейса между TCP и пользовательским уровнем, а взаимодействие с протоколами нижележащего уровня описано в спецификациях соответствующих протоколов, поэтому здесь мы не будем надолго останавливаться на этом интерфейсе. Для случая взаимодействия с протоколом IP мы рассмотрим некоторые параметры, которые могут использоваться в TCP.</p><h4>Интерфейс TCP — пользователь</h4><p>Ниже приведено функциональное описание пользовательских команд TCP, которые могут существенно отличаться в различных операционных системах. Поэтому мы должны предупредить читателей о том, что различные реализации TCP могут иметь существенно отличающиеся пользовательские интерфейсы. Однако, все варианты TCP должны обеспечивать минимальный набор служб, гарантирующий поддержку всеми реализациями одинаковой иерархии протоколов. В этом разделе приведено функциональное описание компонент интерфейса, требуемых для любой реализации TCP.</p><h4>Пользовательские команды TCP</h4><p>В следующих параграфах приведены функциональные характеристики интерфейса между TCP и пользовательским уровнем. Используемая здесь нотация похожа на обозначения процедур и функций в программных языках высокого уровня, но это не означает запрета на использование сервиса типа ловушек — trap (например, SVC, UUO, EMT).</p><p>Описанные ниже пользовательские команды задают базовую функциональность TCP для поддержки обмена информацией между процессами. Каждая реализация должна точно определять свой формат и может объединять комбинации или подмножества базовых функций в одном вызове. В частности, некоторые реализации могут автоматически организовывать (OPEN) соединение при первом вызове SEND или RECEIVE, сделанном пользователем для данного соединения.</p><p>Для обеспечения взаимодействия между процессами от TCP требуется обеспечить не только восприятие команд, но и возврат информации от обслуживающих эти команды процессов. Эта информация включает:</p><ul class="lat"><li>общие сведения о соединении (например, прерывания, удаленное закрытие, связывание с неуказанным внешним сокетом).</li><li>отклики на конкретные пользовательские команды, содержащие результат выполнения (например, код ошибки).</li></ul><ul><li class="b">Open</li><li class="lib b">Формат: OPEN (локальный порт, внешний сокет, активный/пассивный [, тайм-аут] [, предпочтение] [, безопасность/разделение] [, опции])-> локальное имя соединения</li><li class="lib"><p>Будем предполагать, что локальный модуль TCP способен идентифицировать обслуживаемые процессы и проверить их полномочия в части доступа к указанному соединению. В зависимости от реализации TCP идентификаторы ЛВС и TCP для адресов отправителей будут предоставляться TCP или протоколом нижележащего уровня (например, IP). Такое предположение является результатом учета вопросов безопасности, и предназначено для предотвращения маскировки программ TCP под другие программы и т. п. Точно так же никакой процесс не может маскироваться под другой процесс без конфликта с TCP.</p><p>Если флаг активности установлен в пассивное состояние, это означает вызов для перехода в состояние LISTEN (прослушивание входящих соединений). При пассивной организации внешний сокет может быть задан полностью (ждать вызова только от этого сокета) или не задан совсем (принимать любые вызовы). Пассивный вызов с указанным внешним сокетом можно впоследствии активизировать с помощью вызова SEND.</p><p>При организации соединения создается блок управления передачей TCB (transmission control block), который частично заполняется на основе параметров команды OPEN.</p><p>При активном вызове OPEN модуль TCP начинает процедуру синхронизации (организации) соединения.</p><p>Значение тайм-аута (если оно задано) позволяет вызвавшему процессу установить время ожидания для всех данных, направленных TCP. Если в течение заданного времени данные не были доставлены получателю, TCP будет разрывать соединение.</p><p>В настоящее время принято значение тайм-аута 5 мин.</p><p>TCP или компоненты операционной системы будут проверять полномочия пользователя в части организации соединений с заданным уровнем безопасности. Отсутствие параметров безопасности и уровня предпочтения при вызове OPEN говорит об использовании принятых по умолчанию значений.</p><p>TCP будет воспринимать входящие запросы только при условии точного соответствия параметров безопасности и уровне предпочтения не ниже, чем был задан при вызове OPEN.</p><p>Уровнем предпочтения для соединения выбирается большее из значений, заданных при вызове OPEN и полученных во входящем запросе. Выбранное значение фиксируется на все время существования соединения. Разработчики могут пожелать предоставить пользователю контроль за установкой уровня предпочтения. Например, пользователю может быть разрешено указывать необходимость точного соответствия уровней предпочтения или попытка повысить уровень предпочтения должна подтверждаться пользователем.</p><p>Локальное имя соединения возвращается пользователю модулем TCP. Это имя может применяться в качестве краткого обозначения соединений вместо пары &lt;локальный сокет, внешний сокет&gt;.</p></li></ul><ul><li class="b">Send</li><li class="lib b">Формат: SEND (локальное имя соединения, адрес буфера, счетчик байтов, флаг PUSH, флаг URGENT [, тайм-аут])</li><li class="lib"><p>Этот вызов заставляет передать в заданное соединение данные из указанного пользовательского буфера. Если соединение еще не организовано, вызов SEND трактуется как ошибка. Некоторые реализации могут позволять вызовы SEND до организации соединения; в таких случаях автоматически вызывается функция OPEN. Если вызывающий процесс не имеет полномочий на использование указанного соединения, возвращается сообщение об ошибке.</p><p>Если установлен флаг PUSH, данные должны быть быстро переданы получателю и флаг PUSH устанавливается для последнего сегмента TCP, созданного из буфера. При отсутствии флага PUSH данные могут объединяться с данными от последующих вызовов SEND для повышения эффективности передачи.</p><p>При установке флага URGENT сегмент передается получателю с указателем срочности. Принимающая сторона TCP будет сообщать о наличии срочных данных принимающему процессу, если указатель срочности еще не попадает в число обработанных этим процессом данных. Использование флага и указателя срочности позволяет стимулировать обработку срочных данных и информировать принимающий процесс о завершении приема срочной информации. Число флагов срочности на передающей стороне TCP не обязано совпадать с числом фактов информирования принимающего процесса о присутствии срочных данных.</p><p>Если при вызове OPEN внешний сокет не был указан, но соединение организовано (например, в состоянии LISTEN принят вызов для данного локального сокета), указанный буфер передается косвенно заданному (подразумеваемому) внешнему сокету. Пользователи, вызывающие OPEN с незаданным сокетом, могут вызывать SEND, даже не зная адрес внешнего сокета.</p><p>Однако, вызов SEND до того, как внешний сокет определится, будет приводить к возврату сообщения об ошибке. Пользователь может вызвать функцию STATUS для проверки состояния соединения. В некоторых реализациях TCP может уведомлять пользователя при отсутствии указаний на внешний сокет.</p><p>Если задан тайм-аут, текущее время ожидания для данного соединения будет заменено новым значением.</p><p>В простейших реализациях SEND может не возвращать управления вызвавшему процессу, пока не будет завершена передача или не истечет заданное время ожидания. Однако, такой подход может приводить к простоям (например, обе стороны соединения могут попытаться вызвать SEND до получения каких-либо данных с помощью RECEIVE) и не обеспечивает достаточной производительности, поэтому не рекомендуется к использованию. Более сложные реализации будут незамедлительно возвращать управление, позволяя процессу работать одновременно с сетевыми операциями ввода-вывода. В таких случаях может одновременно использоваться множество экземпляров SEND, обслуживание выполняется в порядке вызовов и TCP будет выстраивать данные в очередь.</p><p>Предполагается, что взаимодействие с пользовательским уровнем происходит асинхронно и вызов SEND сопровождается генерацией некого сигнала (или псевдопрерывания) со стороны обслуживающего вызов TCP. Другим вариантом является незамедлительный отклик. Например, SEND может незамедлительно возвращать локальное подтверждение даже при отсутствии подтверждения доставки от удаленного TCP. Будем оптимистически предполагать успешную передачу. Если это не так, соединение будет разрываться по тайм-ауту. Реализации такого типа (синхронные) продолжают использовать асинхронные сигналы, но эти сигналы относятся к соединениям, а не сегментам или буферам.</p><p>Для того, чтобы процесс мог различать сообщения (код результата) от множества SEND вместе с результатом может возвращаться адрес использованного при вызове SEND буфера. Сигналы от TCP к пользователю, обсуждаемые ниже, содержат информацию, которая должна быть возвращена вызвавшему функцию процессу.</p></li></ul><ul><li class="b">Receive</li><li class="lib b">Формат: RECEIVE (локальное имя соединения, адрес буфера, счетчик байтов) -> счетчик байтов, флаг срочности, флаг выталкивания</li><li class="lib"><p>Эта команда выделяет приемный буфер, связывая его с указанным соединением. Если до этого не было вызова OPEN или процесс не имеет полномочий на использование данного соединения, возвращается сообщение об ошибке.</p><p>В простейших реализациях управление может не возвращаться вызвавшему функцию процессу, пока не будет заполнен буфер или не произойдет какая-либо ошибка. Такое решение неэффективно, поскольку приводит к простоям. Более сложные реализации обеспечивают возможность использования нескольких экземпляров RECEIVE. Выделенные функциями буферы будут заполняться по мере прибытия сегментов. Такая стратегия позволяет повысить производительность, но требует организации механизма (возможно, асинхронного) уведомления вызывающей программы о получении флага PUSH или заполнении буфера.</p><p>Если буфер заполняется до прихода PUSH, функция не возвращает флага выталкивания PUSH. При получении флага PUSH до заполнения буфера, функция будет устанавливать при возврате флаг PUSH и содержимое частично заполненного буфера.</p><p>При получении срочных данных пользователю будет передаваться уведомление с помощью сигнала пользовательского интерфейса TCP. Принимающий пользователь должен находиться в режиме urgent. Если флаг URGENT установлен, это говорит о наличии дополнительных срочных данных. Отсутствие флага URGENT говорит о том, что функция RECEIVE возвратила все срочные данные и пользователь может перейти в нормальный режим. Отметим, что данные после указателя срочности (несрочные данные) не могут быть доставлены пользователю в том же буфере, где содержатся срочные данные, если граница не указана пользователем явно.</p><p>Для того, чтобы можно было различать буферы разных экземпляров RECEIVE и видеть полноту заполнения буфера, функция возвращает указатель на буфер и число байтов, которые были реально приняты в буфер.</p><p>Некоторые реализации RECEIVE могут использовать буферное пространство TCP или TCP может использовать кольцевой буфер совместно с пользовательскими процессами.</p></li></ul><ul><li class="b">Close</li><li class="lib b">Формат: CLOSE (локальное имя соединения)</li><li class="lib"><p>Эта команда закрывает указанное соединение. Если соединение не открыто или вызывающий процесс не имеет полномочий для работы с указанным соединением, функция возвращает сообщение об ошибке. Закрытие соединений осуществляется корректно и все данные незавершенных вызовов SEND будут переданы (возможно, повторно) с сохранением управления потоком данных. Таким образом, можно сделать несколько вызовов SEND, после которых будет следовать вызов CLOSE, и быть уверенным в передаче всех данных. Следует помнить, что пользователи должны продолжать вызовы RECEIVE для закрываемого соединения, пока другая сторона пытается передать остающиеся у нее данные. Таким образом, вызов функции CLOSE означает, что больше нет данных для передачи, но вовсе не говорит о том, что данные больше не принимаются. Может случиться (если протокол пользовательского уровня реализован некорректно), что закрывающая соединение сторона не сможет передать все имеющиеся у нее данные до завершения тайм-аута. В этом случае CLOSE транслируется в ABORT и соединение TCP рвется.</p><p>Пользователь может закрыть соединение с помощью CLOSE в любой момент по своей инициативе или в ответ на предложение со стороны TCP (например, закрытие соединения удаленной стороной, тайм-аут при передаче, недоступность получателя).</p><p>Поскольку закрытие соединения требует обмена информацией с внешним TCP, соединение в течение короткого времени может сохраняться в закрытом состоянии. Попытки открыть соединение заново до того, как TCP вернет отклик на команду CLOSE будет приводить к ошибке.</p><p>CLOSE также косвенно выполняет функцию выталкивания данных (push).</p></li></ul><ul><li class="b">Status</li><li class="lib b">Формат: STATUS (локальное имя соединения) -> информация о состоянии</li><li class="lib"><p>Эта пользовательская команда зависит от реализации и может быть исключена без вредного влияния на работу TCP.</p><p>Возвращаемая командой информация обычно является копией содержимого TCB для указанного соединения. Команда возвращает блок данных, содержащий:</p><ul><li>локальный сокет,</li><li>внешний сокет,</li><li>локальное имя соединения,</li><li>окно приема,</li><li>окно передачи,</li><li>состояние соединения,</li><li>число буферов, ожидающих подтверждения,</li><li>число буферов, ожидающих приема,</li><li>состояние срочности,</li><li>предпочтения,</li><li>безопасность/разделение,</li><li>тайм-аут для передачи.</li></ul><p>В зависимости от состояния соединения и/или реализации некоторые поля могут быть недоступными или неоднозначными. Если вызвавший функцию процесс не имеет доступа к соединению, возвращается сообщение об ошибке.</p></li><li class="b">Abort</li><li class="lib b">Формат: ABORT (локальное имя соединения)</li><li class="lib"><p>Эта команда прерывает работу всех ожидающих вызовов SEND и RECEIVE, удаляет TCB и передает специальное сообщение RESET на удаленную сторону TCP-соединения. В зависимости от реализации пользователь может получить уведомления о прерывании для всех оставшихся незавершенными вызовов SEND и RECEIVE или подтверждение операции прерывания.</p></li></ul><h4>Сообщения от TCP к пользователю</h4><p>Предполагается, что операционная система обеспечивает возможность асинхронной передачи сигналов от TCP к пользовательским программам. Когда TCP дает сигнал пользователю, с этим сигналом передается некая информация (например, сообщение об ошибке). В некоторых случаях может передаваться информация о состоянии обработки SEND, RECEIVE или других пользовательских вызовов.</p><p>В сигналах содержатся следующие сведения:</p><table class="nobrd"><tr><td>Локальное имя соединения</td><td>всегда</td></tr><tr><td>Строка отклика</td><td>всегда</td></tr><tr><td>Адрес буфера</td><td>Send и Receive</td></tr><tr><td>Счетчик принятых байтов</td><td>Receive</td></tr><tr><td>Флаг Push</td><td>Receive</td></tr><tr><td>Флаг Urgent</td><td>Receive</td></tr></table><h4>Интерфейс TCP — нижележащий уровень</h4><p>TCP обращается к модулю протокола нижележащего уровня для реальной передачи или приема данных через сеть. Одним из примеров такой реализации является система ARPA, использующая на нижележащем уровне модуль Internet Protocol (IP) [<a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC791</a>].</p><p>При использовании на нижележащем уровне протокола IP последний обеспечивает аргументы для указания типа обслуживания и времени жизни. TCP может использовать для этих параметров следующие значения:</p><ul><li>Тип обслуживания (Type of Service) = Предпочтения (Precedence): routine, Задержка (Delay): normal, Пропускная способность (Throughput): normal, Надежность (Reliability): normal (эти значения задаются числом 00000000).</li></ul><ul><li><p>Время жизни (Time to Live) = 1 минута или 00111100.</p><p class="note">Отметим, что принятое максимальное время жизни пакетов составляет две минуты и мы здесь явно указываем необходимость уничтожения пакетов, которые не были доставлены в течение 1 минуты.</p></li></ul><p>Если на нижележащем уровне работает протокол IP (или иной протокол, обеспечивающий такие возможности) и используется маршрутизация отправителем (source routing), интерфейс должен разрешать обмен маршрутной информацией. Это особенно важно потому, что адреса отправителя и получателя используются при расчете контрольной суммы TCP на приемной и передающей стороне. Важно также сохранить маршрут возврата для ответа на запрос организации соединения.</p><p>Любой протокол нижележащего уровня должен предоставлять информацию об адресах отправителя и получателя, поля протокола, а также тот или иной способ определения размера TCP. Эти данные обеспечивают функциональный эквивалент служб протокола IP и используются при расчете контрольных сумм TCP.</p><h3 id="p3.9">3.9. Обработка событий</h3><p>Рассмотренный ниже пример обработки событий является лишь одним из возможных вариантов реализации. В конкретных реализациях порядок обработки может несколько отличаться, но эти различия должны быть только в деталях, а не по сути.</p><p>Действия TCP можно рассматривать как отклики на события. Происходящие события можно разбить на три категории — пользовательские вызовы, доставка сегментов и тайм-ауты. В этом разделе описаны действия TCP в ответ на события каждого из перечисленных типов. Во многих случаях требуемая в ответ на событие обработка зависит от состояния соединения.</p><ul><li>События:</li><li class="lia">Пользовательские вызовы</li><li class="lib">OPEN</li><li class="lib">SEND</li><li class="lib">RECEIVE</li><li class="lib">CLOSE</li><li class="lib">ABORT</li><li class="lib">STATUS</li><li class="lia">Доставка сегментов</li><li class="lib">SEGMENT ARRIVES</li><li class="lia">Тайм-ауты</li><li class="lib">TIMEOUT</li><li class="lib">RETRANSMISSION TIMEOUT</li><li class="lib">TIME-WAIT TIMEOUT</li></ul><p>Модель пользовательского интерфейса TCP базируется на немедленном возврате из пользовательских вызовов и возможно задержанных откликах на вызов с помощью события или псевдопрерывания. В последующих описаниях термин сигнал будет указывать причину асинхронного отклика.</p><p>Сообщения об ошибках приводятся в форме символьных строк. Например, при вызове команды, которая обращается к несуществующему соединению, будет возвращаться сообщение "error: connection not open" (ошибка: соединение не открыто).</p><p>Отметим также, что все арифметические операции с порядковыми номерами, номерами подтверждений, окнами и т. п. основаны на модуле 2^32 (размер пространства порядковых номеров). Значок =&lt; означает "меньше или равно" (по модулю 2^32).</p><p>Естественным вариантом процесса обработки входящих сегментов является сначала проверка корректности порядкового номера (т. е., его "попадания" в окно приема), размещение в очереди и последующая обработка в порядке возрастания номеров.</p><p>Когда сегмент перекрывается с полученным ранее сегментом, он реконструируется таким образом, чтобы в сегменте содержались только новые данные (поля заголовков изменяются в соответствии с новым содержимым).</p><p>Отметим, что если изменение состояния TCP не указано, это говорит о сохранении прежнего состояния.</p><h4>Пользовательские вызовы</h4><p class="b">OPEN</p><ul><li class="b">Состояние CLOSED (TCB не существует)</li><li class="lib"><p>Создается новый блок управления передачей (TCB) для хранения данных о состоянии соединения. Заполняются поля идентификаторов локального и внешнего сокета, предпочтений, безопасности, а также пользовательский тайм-аут. Отметим, что при пассивном вызове OPEN внешний сокет может быть не указан полностью и это поле задается после приема входящего сегмента SYN. Осуществляется проверка корректности задания пользователем уровня безопасности и предпочтения — при недопустимом для пользователя уровня возвращается сообщение об ошибке "error: precedence not allowed" (недопустимый уровень предпочтения) или "error: security/compartment not allowed" (недопустимый уровень безопасности). При пассивном вызове осуществляется переход в состояние LISTEN и возврат. Если вызов активный и внешний сокет не указан, возвращается сообщение об ошибке "error: foreign socket unspecified" (внешний сокет не задан); если внешний сокет при активном вызове указан полностью, генерируется сегмент SYN. Выбирается значение начального порядкового номера ISS. Передается сегмент SYN в форме &lt;SEQ=ISS&gt;&lt;CTL=SYN&gt;. Устанавливаются значения полей SND.UNA = ISS, SND.NXT = ISS+1, осуществляется переход в состояние SYN-SENT и возврат управления.</p><p>Если вызывающий процесс не имеет доступа к указанному локальному сокету, выдается сообщение об ошибке "error: connection illegal for this process" (некорректное соединение для данного процесса). Если нет возможности организовать новое соединение, возвращается сообщение "error: insufficient resources" (нехватка ресурсов).</p></li><li class="b">Состояние LISTEN</li><li class="lib"><p>Если вызов активный и внешний сокет полностью задан, соединение переходит из пассивного состояния в активное и задается значение ISS. Передается сегмент SYN, устанавливаются значения SND.UNA = ISS, SND.NXT + ISS+1. Соединение переводится в состояние SYN-SENT. Данные, связанные с вызовом SEND, могут быть переданы в сегменте SYN или помещены в очередь на передачу для их отправки после перехода в состояние ESTABLISHED. Если при вызове команды был запрошен флаг срочности, он передается с сегментом данных, отправляемым в результате этой команды. Если в очереди запросов нет свободного места, возвращается сообщение "error: insufficient resources". Если внешний сокет не был указан, выдается сообщение "error: foreign socket unspecified".</p></li><li class="b">Состояния SYN-SENT; SYN-RECEIVED; ESTABLISHED; FIN-WAIT-1; FIN-WAIT-2; CLOSE-WAIT; CLOSING; LAST-ACK; TIME-WAIT</li><li class="lib">Возвращается сообщение об ошибке "error: connection already exists" (соединение уже существует).</li></ul><p class="b">SEND</p><ul><li class="b">Состояние CLOSED (TCB не существует)</li><li class="lib"><p>Если у пользователя нет прав доступа к соединению, возвращается сообщение "error: connection illegal for this process" (некорректное соединение для данного процесса).</p><p>В остальных случаях возвращается сообщение "error: connection does not exist" (соединения не существует).</p></li><li class="b">Состояние LISTEN</li><li class="lib"><p>Если указан внешний сокет, соединение переводится из пассивного состояния в активное и выбирается значение ISS. Передается сегмент SYN, устанавливаются значения SND.UNA = ISS, SND.NXT + ISS+1. Соединение переводится в состояние SYN-SENT. Данные, связанные с вызовом SEND, могут быть переданы в сегменте SYN или помещены в очередь на передачу для их отправки после перехода в состояние ESTABLISHED. Если при вызове команды был запрошен флаг срочности, он передается с сегментом данных, отправляемым в результате этой команды. Если в очереди запросов нет свободного места, возвращается сообщение "error: insufficient resources". Если внешний сокет не был указан, выдается сообщение "error: foreign socket unspecified".</p></li><li class="b">Состояния SYN-SENT; SYN-RECEIVED</li><li class="lib"><p>Данные помещаются в очередь для передачи после перехода в состояние ESTABLISHED. Если в очереди нет свободного места, возвращается сообщение "error: insufficient resources".</p></li><li class="b">Состояния ESTABLISHED; CLOSE-WAIT</li><li class="lib"><p>Буфер сегментируется и передается с вложенным подтверждением (RCV.NXT). При нехватке памяти для запоминания заданного буфера просто возвращается сообщение "error: insufficient resources".</p><p>Если задан флаг срочности, тогда SND.UP &lt;- SND.NXT-1 и для исходящих сегментов задается указатель срочности.</p></li><li class="b">Состояния FIN-WAIT-1; FIN-WAIT-2; CLOSING; LAST-ACK; TIME-WAIT</li><li class="lib">Возвращается сообщение "error: connection closing" (соединение закрывается) без запроса обслуживания.</li></ul><p class="b">RECEIVE</p><ul><li class="b">Состояние CLOSED (TCB не существует)</li><li class="lib"><p>Если у пользователя нет прав доступа к соединению, возвращается сообщение "error: connection illegal for this process" (некорректное соединение для данного процесса).</p><p>В остальных случаях возвращается сообщение "error: connection does not exist" (соединения не существует).</p></li><li class="b">Состояния LISTEN; SYN-SENT; SYN-RECEIVED</li><li class="lib"><p>Данные помещаются в очередь для передачи после перехода в состояние ESTABLISHED. Если в очереди нет свободного места, возвращается сообщение "error: insufficient resources".</p></li><li class="b">Состояния ESTABLISHED; FIN-WAIT-1; FIN-WAIT-2</li><li class="lib"><p>Если для выполнения запроса не хватает входящих сегментов из очереди, запрашивается очередь. Если в очереди нет свободного места для запоминания RECEIVE, выдается сообщение "error: insufficient resources".</p><p>Осуществляется сборка (Reassemble) входящих сегментов из очереди в приемный буфер и передача буфера пользователю. При наличии флага проталкивания функция возвращает пользователю флаг PUSH.</p><p>Если передаваемым пользователю данным предшествует RCV.UP, пользователь получает уведомление о наличии срочных данных.</p><p>Когда TCP принимает на себя ответственность за доставку данных пользователю, это фактически означает необходимость передачи отправителю подтверждений. Формирование подтверждений рассматривается ниже при обсуждении обработки входящих сегментов.</p></li><li class="b">Состояние CLOSE-WAIT</li><li class="lib"><p>Поскольку удаленная сторона уже передала FIN, вызов RECEIVE должен ограничиться данными, которые уже приняты, но не доставлены пользователю. Если ожидающих доставки данных уже нет, функция RECEIVE будет возвращать сообщение "error: connection closing" (соединение закрыто). В остальных случаях RECEIVE будет использовать все оставшиеся данные.</p></li><li class="b">Состояния CLOSING; LAST-ACK; TIME-WAIT</li><li class="lib"><p>Возвращается сообщение "error: connection closing".</p></li></ul><p class="b">CLOSE</p><ul><li class="b">Состояние CLOSED (TCB не существует)</li><li class="lib"><p>Если у пользователя нет прав доступа к соединению, возвращается сообщение "error: connection illegal for this process". В остальных случаях возвращается сообщение "error: connection does not exist".</p></li><li class="b">Состояние LISTEN</li><li class="lib"><p>Все незавершенные вызовы RECEIVE завершаются с сообщением "error: closing" (соединение закрывается). Удаляется TCB и соединение переводится в состояние CLOSED.</p></li><li class="b">Состояние SYN-SENT</li><li class="lib"><p>Удаляется TCB и возвращаются сообщения "error: closing" для всех поставленных в очередь вызовов SEND и RECEIVE.</p></li><li class="b">Состояние SYN-RECEIVED</li><li class="lib"><p>Если нет очереди SEND и данных, ожидающих передачи, формируется сегмент FIN и соединение переходит в состояние FINWAIT-1. В противном случае вызов помещается в очередь для обработки после завершения состояния ESTABLISHED.</p></li><li class="b">Состояние ESTABLISHED</li><li class="lib"><p>Запрос сохраняется в очереди, пока не будут сегментированы все предыдущие вызовы SEND. После этого формируется сегмент FIN и соединение переходит в состояние FIN-WAIT-1.</p></li><li class="b">Состояния FIN-WAIT-1; FIN-WAIT-2</li><li class="lib"><p>Строго говоря, такой вызов является для данных состояний ошибкой и должен возвращать сообщение "error: connection closing" (закрытие соединения). Однако отклик "ok" (нет ошибок) также допускается, пока не передан повторно сегмент FIN (хотя первый сегмент FIN может быть передан повторно).</p></li><li class="b">Состояние CLOSE-WAIT</li><li class="lib"><p>Запрос сохраняется в очереди, пока не будут сегментированы все предыдущие вызовы SEND. После этого формируется сегмент FIN и соединение переходит в состояние.</p></li><li class="b">Состояния CLOSING; LAST-ACK; TIME-WAIT</li><li class="lib"><p>Возвращается сообщение "error: connection closing".</p></li></ul><p class="b">ABORT</p><ul><li class="b">Состояние CLOSED (TCB не существует)</li><li class="lib"><p>Если у пользователя нет прав доступа к соединению, возвращается сообщение "error: connection illegal for this process". В остальных случаях возвращается сообщение "error: connection does not exist".</p></li><li class="b">Состояние LISTEN</li><li class="lib"><p>Все остающиеся вызовы RECEIVE должны быть завершены с возвратом сообщения "error: connection reset" (соединение разорвано). Удаляется TCB, соединение переходит в состояние CLOSED.</p></li><li class="b">Состояние SYN-SENT</li><li class="lib"><p>Удаляется TCB и возвращаются сообщения "error: connection reset" для всех поставленных в очередь вызовов SEND и RECEIVE, соединение переводится в состояние CLOSED.</p></li><li class="b">Состояния SYN-RECEIVED; ESTABLISHED; FIN-WAIT-1; FIN-WAIT-2; CLOSE-WAIT</li><li class="lib"><p>Передается сегмент &lt;SEQ=SND.NXT&gt;&lt;CTL=RST&gt;. Возвращаются сообщения "error: connection reset" для всех поставленных в очередь вызовов SEND и RECEIVE; все сегменты из очереди на передачу (за исключением сформированного ранее RST) или повторную передачу уничтожаются, удаляется TCB и соединение переводится в состояние CLOSED.</p></li><li class="b">Состояния CLOSING; LAST-ACK; TIME-WAIT</li><li class="lib"><p>Функция возвращает "ok" (нет ошибок), удаляется TCB и соединение переводится в состояние CLOSED.</p></li></ul><p class="b">STATUS</p><ul><li class="b">Состояние CLOSED (TCB не существует)</li><li class="lib">Если у пользователя нет прав доступа к соединению, возвращается сообщение "error: connection illegal for this rocess". В остальных случаях возвращается сообщение "error: connection does not exist".</li><li class="b">Состояние LISTEN</li><li class="lib">Возвращается сообщение "state = LISTEN" и указатель на TCB.</li><li class="b">Состояние SYN-SENT</li><li class="lib">Возвращается сообщение "state = SYN-SENT" и указатель на TCB.</li><li class="b">Состояние SYN-RECEIVED</li><li class="lib">Возвращается сообщение "state = SYN-RECEIVED" и указатель на TCB.</li><li class="b">Состояние ESTABLISHED</li><li class="lib">Возвращается сообщение "state = ESTABLISHED" и указатель на TCB.</li><li class="b">Состояние FIN-WAIT-1</li><li class="lib">Возвращается сообщение "state = FIN-WAIT-1" и указатель на TCB.</li><li class="b">Состояние FIN-WAIT-2</li><li class="lib">Возвращается сообщение "state = FIN-WAIT-2" и указатель на TCB.</li><li class="b">Состояние CLOSE-WAIT</li><li class="lib">Возвращается сообщение "state = CLOSE-WAIT" и указатель на TCB.</li><li class="b">Состояние CLOSING</li><li class="lib">Возвращается сообщение "state = CLOSING" и указатель на TCB.</li><li class="b">Состояние LAST-ACK</li><li class="lib">Возвращается сообщение "state = LAST-ACK" и указатель на TCB.</li><li class="b">Состояние TIME-WAIT</li><li class="lib">Возвращается сообщение "state = TIME-WAIT" и указатель на TCB.</li></ul><h4>Доставка сегментов</h4><ul><li class="b">Состояние CLOSED (TCB не существует)</li><li class="lib"><p>Все данные во входящем сегменте отбрасываются, отбрасывается также входящий сегмент, содержащий RST. В ответ на входящий сегмент без RST передается сегмент RST. Порядковый номер и номер подтверждения выбираются таким образом, чтобы сделать порядковый номер reset приемлемым для TCP, передавшего сегмент.</p><p>Если бит ACK не установлен, используется порядковый номер 0</p><pre>&lt;SEQ=0&gt;&lt;ACK=SEG.SEQ+SEG.LEN&gt;&lt;CTL=RST,ACK&gt;</pre><p>При наличии бита ACK</p><pre>&lt;SEQ=SEG.ACK&gt;&lt;CTL=RST&gt;</pre></li><li class="b">Состояние LISTEN</li><li><ol><li><p>Проверка RST — все входящие RST должны игнорироваться с возвратом управления.</p></li><li><p>Проверка ACK — любые подтверждения являются некорректными, если они поступают через соединение в состоянии LISTEN. В ответ на такие подтверждения должен формироваться приемлемый сегмент сброса (reset) в формате:</p><pre>&lt;SEQ=SEG.ACK&gt;&lt;CTL=RST&gt;</pre><p>Возврат управления.</p></li><li><p>Проверка SYN</p><p>Если бит SYN установлен, проверяется уровень безопасности. Если уровень безопасности/разделения для входящего сегмента не соответствует в точности уровню безопасности в TCB, передается сигнал сброса и возвращается управление.</p><pre>&lt;SEQ=0&gt;&lt;ACK=SEG.SEQ+SEG.LEN&gt;&lt;CTL=RST,ACK&gt;</pre><p>Если SEG.PRC &gt; TCB.PRC, то при наличии разрешения со стороны пользователя и системы устанавливается TCB.PRC&lt;- SEG.PRC; в противном случае передается сигнал сброса и возвращается управление.</p><pre>&lt;SEQ=0&gt;&lt;ACK=SEG.SEQ+SEG.LEN&gt;&lt;CTL=RST,ACK&gt;</pre><p>Если SEG.PRC &lt; TCB.PRC, обработка вызова продолжается.</p><p>Устанавливаются значения RCV.NXT = SEG.SEQ+1 и IRS = SEG.SEQ, все остальные данные и поля управления помещаются в очередь для последующей обработки. Должно быть выбрано значение ISS и передан сегмент SYN в форме:</p><pre>&lt;SEQ=ISS&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=SYN,ACK&gt;</pre><p>Устанавливаются значения SND.NXT = ISS+1 и SND.UNA = ISS. Соединение должно быть переведено в состояние SYNRECEIVED. Отметим, что любые другие входящие данные и поля управления (включенные в SYN) будут обрабатываться в состоянии SYN-RECEIVED, но обработка SYN и ACK не должна повторяться. Если прослушивающая сторона не задана полностью (т. е., не полностью указан внешний сокет), пропущенные поля должны быть заполнены на этом этапе обработки.</p></li><li><p>Проверка других полей</p><p>Любые другие сегменты управления и данных (не содержащие SYN) должны содержать ACK и, таким образом, будут отброшены при проверке ACK. Входящий сегмент RST не может быть корректным, поскольку он не может служить откликом на какую-либо передачу в данной реинкарнации соединения. Вероятность получения такого сегмента мала, но если это произойдет, нужно просто отбросить сегмент и возвратить управление.</p></li></ol></li></ul><ul><li class="b">Состояние SYN-SENT</li><li><ol><li><p>Проверка бита ACK</p><p>Если бит ACK установлен, выполняются следующие операции:</p><p>Если SEG.ACK =&lt; ISS или SEG.ACK > SND.NXT, передается сигнал сброса reset (если бит RST уже установлен, сегмент отбрасывается с возвратом управления)</p><pre>&lt;SEQ=SEG.ACK&gt;&lt;CTL=RST&gt;</pre><p>и сегмент отбрасывается с возвратом управления.</p><p>Если SND.UNA =&lt; SEG.ACK =&lt; SND.NXT, бит ACK считается допустимым и обработка продолжается.</p></li><li><p>Проверка бита RST</p><p>При наличии бита RST выполняются следующие операции:</p><p>Если бит ACK был допустимым, пользователю передается сообщение "error: connection reset" (сброс соединения), сегмент отбрасывается и соединение переводится в состояние CLOSED с удалением TCB и возвратом управления. В противном случае (нет ACK) сегмент отбрасывается с возвратом управления.</p></li><li><p>Проверка уровня безопасности и предпочтения</p><p>Если уровень безопасности/разделения в принятом сегменте не соответствует в точности уровню безопасности TCB, передается сигнал сброса (reset):</p><p>бит ACK установлен</p><pre>&lt;SEQ=SEG.ACK&gt;&lt;CTL=RST&gt;</pre><p>бит ACK не установлен</p><pre>&lt;SEQ=0&gt;&lt;ACK=SEG.SEQ+SEG.LEN&gt;&lt;CTL=RST,ACK&gt;</pre><p>Если уровни безопасности совпадают, выполняются следующие операции:</p><p>бит ACK установлен</p><p>если уровень предпочтения в сегменте не соответствует уровню в TCB, передается сигнал сброса</p><pre>&lt;SEQ=SEG.ACK&gt;&lt;CTL=RST&gt;</pre><p>бит ACK не установлен</p><p>если уровень предпочтения в сегменте выше уровня в TCB, с позволения пользователя и системы повышается уровень предпочтения в TCB до совпадения с уровнем в сегменте; при невозможности повысить уровень предпочтения передается сигнал сброса</p><pre>&lt;SEQ=0&gt;&lt;ACK=SEG.SEQ+SEG.LEN&gt;&lt;CTL=RST,ACK&gt;</pre><p>Если уровень предпочтения в сегменте ниже уровня в TCB, продолжается обработка вызова.</p><p>Если был передан сигнал сброса (reset), сегмент отбрасывается с возвратом управления.</p></li><li><p>Проверка бита SYN</p><p>Этот этап выполняется только при корректном ACK или отсутствии ACK, если сегмент не содержит RST.</p><p>Если бит SYN установлен и параметры безопасности/предпочтения приемлемы, устанавливаются значения RCV.NXT = SEG.SEQ+1 и IRS = SEG.SEQ. Значение SND.UNA должно быть увеличено до SEG.ACK (если имеется ACK) и все сегменты из очереди повторной передачи, которые таким образом будут подтверждены, должны быть удалены из очереди.</p><p>Если SND.UNA > ISS (сегмент SYN был подтвержден), состояние соединения меняется на ESTABLISHED, формируется и передается сегмент ACK</p><pre>&lt;SEQ=SND.NXT&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;</pre><p>В этот сегмент могут быть включены данные и сигналы управления из очереди на повторную передачу. Если в сегменте присутствуют другие данные или поля управления, продолжается обработка этого сегмента с проверки бита URG (см. этап (6) ниже), в противном случае обработка завершается с возвратом управления.</p><p>Если бит SYN не установлен, соединение переходит в состояние SYN-RECEIVED, формируется и передается сегмент SYN,ACK</p><pre>&lt;SEQ=ISS&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=SYN,ACK&gt;</pre><p>Если в сегменте присутствуют другие данные или поля управления, они помещаются в очередь для обработки после перехода соединения в состояние ESTABLISHED и возвращается управление.</p></li></ol></li></ul><ul><li><ol><li><p>Если не установлен ни бит SYN, ни бит, сегмент отбрасывается с возвратом управления.</p><p>После перечисленных для состояний CLOSED, LISTEN, SYN-SENT проверок выполняются следующие операции:</p><ol><li><p class="b">Проверка порядкового номера</p><p class="b">Состояния SYN-RECEIVED; ESTABLISHED; FIN-WAIT-1; FIN-WAIT-2; CLOSE-WAIT; CLOSING; LAST-ACK; TIME-WAIT</p><p>Начальные проверки с целью отбрасывания старых дубликатов проводятся в порядке прибытия, но дальнейшая обработка сегментов ведется в соответствии с порядковыми номерами в поле SEG.SEQ. Если сегмент включает старые и новые данные, должна обрабатываться только новая информация.</p><p>При начальной проверке прибывающих сегментов возможны 4 варианта:</p><table><tr><td>Размер сегмента</td><td>Окно приема</td><td>Проверка</td></tr><tr><td>0</td><td>0</td><td>SEG.SEQ = RCV.NXT</td></tr><tr><td>0</td><td>>0</td><td>RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND</td></tr><tr><td>>0</td><td>0</td><td>недопустимо</td></tr><tr><td>>0</td><td>>0</td><td>RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND или<br />RCV.NXT =&lt; SEG.SEQ+SEG.LEN-1 &lt; RCV.NXT+RCV.WND</td></tr></table><p>Если RCV.WND = 0, сегменты не могут приниматься за исключением корректных сегментов ACK, URG и RST.</p><p>Если входящий сегмент неприемлем, в ответ на него должно быть передано уведомление (если установлен бит RST, сегмент должен быть отброшен с возвратом управления):</p><pre>&lt;SEQ=SND.NXT&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;</pre><p>После передачи подтверждения происходит отбрасывание неприемлемого сегмента и возврат управления.</p><p>В дальнейшем сегменты предполагаются идеализированными — они начинаются с RCV.NXT и не выходят за пределы окна. Реальные сегменты могут быть подогнаны под такую идеализацию путем отрезания любой части, выходящей за пределы окна (включая SYN и FIN), и дальнейшей обработки только для сегментов, начинающихся с RCV.NXT. Сегменты с более высокими порядковыми номерами могут сохраняться для последующей обработки.</p></li><li><p class="b">Проверка бита RST</p><p class="b">Состояние SYN-RECEIVED</p><p>Если установлен бит RST</p><p class="lia">Если соединение было открыто пассивным вызовом OPEN (т. е., перешло из состояния LISTEN), оно будет возвращено в состояние LISTEN с возвратом управления. Пользователю не будет передаваться никакого уведомления об этом. Если соединение организовано активным вызовом OPEN (т. е., перешло из состояния SYN-SENT), оно будет отвергнуто (refused) и пользователь получит сообщение "connection refused". В обоих случаях все сегменты из очереди на передачу должны быть удалены. В случае активного вызова OPEN соединение переводится в состояние CLOSED с удалением TCB и возвратом управления.</p><p class="b">Состояния ESTABLISHED; FIN-WAIT-1; FIN-WAIT-2; CLOSE-WAIT</p><p>Если установлен бит RST, все остающиеся вызовы RECEIVE и SEND должны получить команду сброса (reset). Все сегменты из очередей должны быть удалены. Пользователь должен получить сигнал "connection reset" (сброс соединения). Соединение переходит в состояние CLOSED с удалением TCB и возвратом управления.</p><p class="b">Состояния CLOSING; LAST-ACK; TIME-WAIT</p><p>Если установлен бит RST, соединение переходит в состояние CLOSED с удалением TCB и возвратом управления.</p></li><li><p class="b">Проверка предпочтений и безопасности</p><p class="b">Состояние SYN-RECEIVED</p><p>Если уровни безопасности/разделения и предпочтения в сегменте не соответствуют в точности таким же уровням в TCB, передается сигнал сброса (reset) с возвратом управления.</p><p class="b">Состояния ESTABLISHED; FIN-WAIT-1; FIN-WAIT-2; CLOSE-WAIT; CLOSING; LAST-ACK; TIME-WAIT</p><p>Если уровни безопасности/разделения и предпочтения в сегменте не соответствуют в точности таким же уровням в TCB, передается сигнал сброса (reset), все остающиеся вызовы RECEIVE и SEND должны получить сигнал reset. Все очереди сегментов удаляются. Пользователь должен получить сигнал "connection reset". Соединение переходит в состояние CLOSED с удалением TCB и возвратом управления.</p><div class="note"><p>Отметим, что эта проверка проводится после проверки порядкового номера для предотвращения приема сегментов из старых соединений между теми же портами, но с другим уровнем безопасности или предпочтений, которые могут вызвать разрыв текущего соединения.</p><p>Если соединение было инициировано пассивным вызовом OPEN, оно переходит в состояние LISTEN c возвратом управления. В остальных случаях выполняется дальнейшая обработка.</p></div></li><li><p class="b">Проверка бита SYN</p><p class="b">Состояния SYN-RECEIVED; ESTABLISHED; FIN-WAIT-1; FIN-WAIT-2; CLOSE-WAIT; CLOSING; LAST-ACK; TIME-WAIT</p><p>Если SYN находится в окне, это говорит об ошибке. Передается сигнал сброса (reset), все незавершенные вызовы RECEIVE и SEND должны получить reset. Все сегменты из очередей удаляются, пользователь должен получить сигнал "connection reset". Соединение переходит в состояние CLOSED с удалением TCB и возвратом управления.</p><p>Если SYN не находится в окне, этот этап не будет выполняться, поскольку будет передано подтверждение еще на первом этапе (проверка порядкового номера).</p></li><li><p class="b">Проверка поля ACK</p><p>Если бит ACK не установлен, сегмент отбрасывается с возвратом управления.</p><p>При наличии бита ACK выполняется дальнейшая обработка.</p><p class="b">Состояние SYN-RECEIVED</p><p>Если SND.UNA =&lt; SEG.ACK =&lt; SND.NXT, соединение переходит в состояние ESTABLISHED12 и обработка продолжается.</p><p>Если сегмент подтверждения неприемлем, формируется и передается сегмент сброса (reset).</p><pre>&lt;SEQ=SEG.ACK&gt;&lt;CTL=RST&gt;</pre><p class="b">Состояние ESTABLISHED</p><p>Если SND.UNA &lt; SEG.ACK =&lt; SND.NXT, устанавливается SND.UNA &lt;- SEG.ACK. Все, так или иначе, целиком подтвержденные сегменты удаляются из очереди повторной передачи. Пользователь должен получить позитивные подтверждения для буферов, которые были переданы и полностью подтверждены (т. е., в результате вызова SEND должно быть возвращено сообщение "ok"). Если подтверждение ACK является дубликатом (SEG.ACK =&lt; SND.UNA), его можно игнорировать. Если ACK подтверждает что-то, еще не переданное (SEG.ACK > SND.NXT), посылается подтверждение ACK и сегмент отбрасывается с возвратом управления.</p><p>Если SND.UNA =&lt; SEG.ACK =&lt; SND.NXT, окно нужно обновить. Если выполняется условие</p><pre>(SND.WL1 &lt; SEG.SEQ) OR ((SND.WL1 = SEG.SEQ) AND (SND.WL2 =&lt; SEG.ACK)),</pre><p>нужно установить SND.WND &lt;- SEG.WND, SND.WL1 &lt;- SEG.SEQ и SND.WL2 &lt;- SEG.ACK.</p><p class="note">Отметим, что SND.WND задает смещение от SND.UNA, поле SND.WL1 содержит порядковый номер последнего сегмента, использованного для обновления SND.WND, а SND.WL2 содержит номер подтверждения последнего сегмента, использованного для обновления SND.WND. Описанная проверка позволяет предотвратить использование старых сегментов для обновления окна.</p><p class="b">Состояние FIN-WAIT-1</p><p>В дополнение к операциям, выполняемым в состоянии ESTABLISHED (см. выше), если наш запрос FIN уже подтвержден, соединение переводится в состояние FIN-WAIT-2 и продолжается обработка для этого состояния.</p><p class="b">Состояние FIN-WAIT-2</p><p>В дополнение к операциям, выполняемым в состоянии ESTABLISHED (см. выше), если очередь повторной передачи пуста, на пользовательский запрос CLOSE может быть передан отклик "ok", но TCB не удаляется.</p><p class="b">Состояние CLOSE-WAIT</p><p>Выполняются те же операции, что и для состояния ESTABLISHED.</p><p class="b">Состояние CLOSING</p><p>В дополнение к операциям, выполняемым в состоянии ESTABLISHED (см. выше), если ACK подтверждает наш запрос FIN, соединение переводится в состояние TIME-WAIT, в остальных случаях сегмент игнорируется.</p><p class="b">Состояние LAST-ACK</p><p>В этом состоянии могут доставляться только подтверждения для запроса FIN. Если запрос FIN уже подтвержден, удаляется TCB и соединение переводится в состояние CLOSED с возвратом управления.</p><p class="b">Состояние TIME-WAIT</p><p>В этом состоянии могут доставляться только повторы сегмента FIN с удаленной стороны. Подтвердите доставку и запустите заново отсчет тайм-аута 2 MSL.</p></li><li><p class="b">Проверка бита URG</p><p class="b">Состояния ESTABLISHED; FIN-WAIT-1; FIN-WAIT-2</p><p>При установленном бите URG, задается значение RCV.UP &lt;- max(RCV.UP,SEG.UP) и пользователю передается сигнал о том, что удаленная сторона имеет срочные данные, если указатель срочности (RCV.UP) превышает порядковые номера воспринятых данных. Если пользователю уже был передан такой сигнал (или пользователь находится в режиме "urgent") для продолжающейся последовательности срочных данных, повторять такой сигнал не нужно.</p><p class="b">Состояния CLOSE-WAIT; CLOSING; LAST-ACK; TIME-WAIT</p><p>В этих состояниях флаг срочности не должен появляться, поскольку удаленная сторона уже передала запрос FIN. Игнорируйте URG.</p></li><li><p class="b">Обработка содержимого сегмента</p><p class="b">Состояния ESTABLISHED; FIN-WAIT-1; FIN-WAIT-2</p><p>В состоянии ESTABLISHED возможна доставка содержимого сегмента в пользовательские буферы RECEIVE. Содержимое сегмента может переноситься в буфер до его заполнения или до завершения сегмента. Если закончившийся сегмент содержит флаг PUSH, пользователю передается уведомление путем установки флага PUSH при возврате управления.</p><p>Когда TCP отвечает за доставку данных пользователю, требуется также подтверждать получение данных.</p><p>Когда TCP несет ответственность за доставку данных, значение RCV.NXT увеличивается на размер принятых данных и уточняется значение RCV.WND с учетом текущего размера буфера. Сумма RCV.NXT и RCV.WND при этом не должна уменьшаться.</p><p>Пожалуйста, не забывайте о предложениях по управлению окном, рассмотренных в параграфе 3.7. Передается подтверждение в форме:</p><pre>&lt;SEQ=SND.NXT&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;</pre><p>Это подтверждение должно включаться в сегмент, который будет передаваться с минимальной возможной задержкой.</p><p class="b">Состояния CLOSE-WAIT; CLOSING; LAST-ACK; TIME-WAIT</p><p>В этих состояниях сегменты данных не должны приходить, поскольку с удаленной стороны уже получен сигнал FIN. Игнорируйте такие сегменты.</p></li><li><p class="b">Проверка бита FIN</p><p>Не обрабатывайте флаг FIN для состояний CLOSED, LISTEN или SYN-SENT, поскольку значение SEG.SEQ не может быть проверено; отбрасывайте сегмент с возвратом управления.</p><p>Если бит FIN установлен, пользователю передается сигнал "connection closing" (соединение закрывается) и все ожидающие вызовы RECEIVE должны вернуть такое же сообщение, увеличив RCV.NXT на размер FIN и передав подтверждение для FIN. Отметим, что FIN вызывает PUSH для всех сегментов, которые еще не доставлены пользователю.</p><p class="b">Состояния SYN-RECEIVED; ESTABLISHED</p><p>Переход в состояние CLOSE-WAIT.</p><p class="b">Состояние FIN-WAIT-1</p><p>Если наш запрос FIN уже подтвержден (возможно в данном сегменте), соединение переводится в состояние TIME-WAIT, начинается новый отсчет для времени ожидания и выключаются другие таймеры. В противном случае соединение переводится в состояние CLOSING.</p><p class="b">Состояние FIN-WAIT-2</p><p>Переход в состояние TIME-WAIT, начинается новый отсчет для времени ожидания и выключаются другие таймеры.</p><p class="b">Состояния CLOSE-WAIT; CLOSING; LAST-ACK; TIME-WAIT</p><p>Состояние сохраняется неизменным. В состоянии TIME-WAIT заново запускается отсчет тайм-аута 2 MSL.</p></li></ol><p>Завершение обработки и возврат управления.</p></li></ol></li></ul><h4>Тайм-ауты</h4><p class="b">Пользовательский тайм-аут</p><p>Если при любом состоянии соединения истекает время пользовательского тайм-аута, удаляются все буферы, пользователю передается сообщение "error: connection aborted due to user timeout" для всех остающихся вызовов, удаляется TCB и соединение переходит в состояние CLOSED с возвратом управления.</p><p class="b">Повторная передача</p><p>Если при любом состоянии соединения истекает время тайм-аута повторной передачи, первый сегмент из очереди повторной передачи посылается заново, таймер повторной передачи сбрасывается и управление возвращается.</p><p class="b">Время ожидания</p><p>При завершении времени ожидания для соединения удаляется TCB и соединение переходит в состояние CLOSED с возвратом управления.</p><h2 id="p.glossary">Глоссарий</h2><ul><li class="b">1822</li><li class="lib">BBN Report 1822, "The Specification of the Interconnection of a Host and an IMP" — спецификация интерфейса между хостом и ARPANET.</li><li class="b">ACK</li><li class="lib">Бит управления (подтверждение), не занимающий места в пространстве порядковых номеров и показывающий, что поле подтверждения в данном сегменте содержит следующий порядковый номер, который отправитель данного сегмента ожидает получить в подтверждение доставки всех предыдущих порядковых номеров.</li><li class="b">ARPANET message</li><li class="lib">Единица передачи информации между хостом и IMP в ARPANET. Максимальный размер сообщения составляет 1012 октетов (8096 битов).</li><li class="b">ARPANET packet</li><li class="lib">Единица передачи информации между IMP в сети ARPANET. Максимальный размер пакета составляет 126 октетов (1008 битов).</li><li class="b">Connection (соединение)</li><li class="lib">Логический путь передачи данных, задаваемый парой сокетов.</li><li class="b">Datagram (дейтагарамма)</li><li class="lib">Сообщение, передаваемое через компьютерную сеть с коммутацией пакетов.</li><li class="b">Destination Address (адрес получателя)</li><li class="lib">Адрес получателя, обычно указывающий хост или сеть.</li><li class="b">FIN</li><li class="lib">Бит управления, занимающий единицу пространства порядковых номеров, который показывает, что отправитель больше не будет передавать данные или сигналы управления, занимающие порядковые номера.</li><li class="b">Fragment (фрагмент)</li><li class="lib">Часть логической единицы данных (в частности, фрагментом называют часть дейтаграммы IP).</li><li class="b">FTP</li><li class="lib">Протокол копирования файлов.</li><li class="b">Header (заголовок)</li><li class="lib">Управляющая информация в начале сообщения, сегмента, фрагмента, пакета или блока данных.</li><li class="b">Host (хост)</li><li class="lib">Компьютер. В частности, отправитель и получатель сообщений с точки зрения коммуникационной сети.</li><li class="b">Identification (идентификация)</li><li class="lib">Поле протокола IP, содержащее идентификатор, заданный отправителем для обеспечения сборки дейтаграммы из фрагментов.</li><li class="b">IMP</li><li class="lib">Interface Message Processor — пакетный коммутатор ARPANET.</li><li class="b">internet address</li><li class="lib">Адрес отправителя или получателя, используемый на уровне хостов.</li><li class="b">internet datagram</li><li class="lib">Единица обмена данными между модулем IP и протоколом вышележащего уровня, содержащая заголовок IP и данные.</li><li class="b">internet fragment</li><li class="lib">Часть данных из дейтаграммы IP с заголовком IP.</li><li class="b">IP</li><li class="lib">Internet Protocol.</li><li class="b">IRS</li><li class="lib">Initial Receive Sequence — начальный порядковый номер для приема. Первый порядковый номер, используемый отправителем в данном соединении.</li><li class="b">ISN</li><li class="lib">Initial Sequence Number — начальный порядковый номер. Первый порядковый номер (ISS или IRS), используемый для соединения. Выбирается на основе текущего времени.</li><li class="b">ISS</li><li class="lib">Initial Send Sequence — начальный порядковый номер для передачи. Первый порядковый номер, используемый отправителем в данном соединении.</li><li class="b">left sequence</li><li class="lib">Следующий порядковый номер, который будет подтвержден данными, принимаемыми TCP (или наименьший из еще неподтвержденных порядковых номеров); в некоторых случаях трактуется как левый край окна передачи.</li><li class="b">local packet (локальный пакет)</li><li class="lib">Единица передачи данных в локальной сети.</li><li class="b">Module (модуль)</li><li class="lib">Реализация (обычно программная) протокола или другой процедуры.</li><li class="b">MSL</li><li class="lib">Maximum Segment Lifetime — максимальное время жизни сегмента TCP в сети. Произвольно выбрано значение 2 минуты.</li><li class="b">Octet (октет)</li><li class="lib">Восьмибитовый блок данных — байт.</li><li class="b">Options (опции)</li><li class="lib">Поле Option может содержать несколько опций, каждая из которых может занимать несколько октетов. Опции используются в основном для проверки или задания тех или иных условий (например, содержат временные метки). Поля опций поддерживаются как IP, так и TCP.</li><li class="b">Packet (пакет)</li><li class="lib">Единица данных с заголовком (может быть логически полным или неполным). Более часто термин пакет относят к физическим, а не логическим единицам данных.</li><li class="b">Port (порт)</li><li class="lib">Часть сокета, задающая логический канал ввода или вывода данных для процесса.</li><li class="b">Process (процесс)</li><li class="lib">Выполнение программы. Источник или потребитель данных с точки зрения TCP или других протоколов обмена между хостами.</li><li class="b">PUSH</li><li class="lib">Управляющий бит, не занимающий пространства порядковых номеров, который указывает, что сегмент содержит данные, требующие незамедлительной отправки получателю.</li><li class="b">RCV.NXT</li><li class="lib">receive next sequence number — следующий порядковый номер для приема.</li><li class="b">RCV.UP</li><li class="lib">receive urgent pointer — указатель срочности для приема.</li><li class="b">RCV.WND</li><li class="lib">receive window — окно приема.</li><li class="b">receive next sequence number (следующий порядковый номер для приема)</li><li class="lib">Следующий порядковый номер, который ожидает получить локальный модуль TCP.</li><li class="b">receive window (окно приема)</li><li class="lib">Представляет порядковый номер, который локальный (принимающий) модуль TCP ожидает получить. Таким образом, локальный модуль TCP предполагает, что сегменты, перекрывающие диапазон от RCV.NXT до RCV.NXT+RCV.WND-1, содержат приемлемые данные и поля управления. Сегмент, содержащий порядковые номера, целиком выходящие за эти пределы, рассматривается как дубликат и отбрасывается.</li><li class="b">RST</li><li class="lib">Управляющий бит (reset — сброс), не занимающий пространства порядковых номеров, который показывает, что приемная сторона должна удалить соединение без дальнейших вопросов. Приемная сторона может определить, основываясь на порядковом номере и номере подтверждения во входящем сегменте, следует воспринять команду сброса или игнорировать ее. Ни в коем случае в ответ на сегмент, содержащий RST, не следует передавать отклик с битом RST.</li><li class="b">RTP</li><li class="lib">Real Time Protocol — протокол для передачи между хостами критичной к задержкам информации.</li><li class="b">SEG.ACK</li><li class="lib">segment acknowledgment — подтверждение сегмента</li><li class="b">SEG.LEN</li><li class="lib">segment length — размер сегмента</li><li class="b">SEG.PRC</li><li class="lib">segment precedence value — уровень предпочтения для сегмента</li><li class="b">SEG.SEQ</li><li class="lib">segment sequence — порядковый номер сегмента</li><li class="b">SEG.UP</li><li class="lib">segment urgent pointer field — поле указателя срочности в сегменте</li><li class="b">SEG.WND</li><li class="lib">segment window field — поле окна в сегменте</li><li class="b">segment (сегмент)</li><li class="lib">Логическая единица данных. В частности, сегмент TCP представляет собой единицу данных, передаваемую между парой модулей TCP.</li><li class="b">segment acknowledgment</li><li class="lib">Порядковый номер в поле подтверждения прибывающего сегмента.</li><li class="b">segment length</li><li class="lib">Число порядковых номеров, занимаемое сегментом, с учетом полей управления, занимающих пространство порядковых номеров.</li><li class="b">segment sequence</li><li class="lib">Номер в поле sequence прибывающего сегмента.</li><li class="b">send sequence</li><li class="lib">Следующий порядковый номер, который будет использован локальным (передающим) TCP для данного соединения. Нумерация начинается с начального порядкового номера ISN и далее увеличивается с каждым переданных октетом данных или учитываемым октетом управляющей информации.</li><li class="b">send window</li><li class="lib">Представляет порядковые номера, которые удаленный (принимающий) TCP готов получить. Это значение поля window, указанное в сегментах от удаленного (принимающего данные) TCP. Диапазон новых порядковых номеров, которые может передать TCP, лежит между SND.NXT и SND.UNA + SND.WND — 1 (порядковые номера для повторной передачи лежат между SND.UNA и SND.NXT).</li><li class="b">SND.NXT</li><li class="lib">Порядковый номер для передачи</li><li class="b">SND.UNA</li><li class="lib">Порядковый номер оставшегося</li><li class="b">SND.UP</li><li class="lib">Указатель срочности для передачи</li><li class="b">SND.WL1</li><li class="lib">Номер сегмента при последнем обновлении окна</li><li class="b">SND.WL2</li><li class="lib">Номер сегмента подтверждения при последнем обновлении окна</li><li class="b">SND.WND</li><li class="lib">Окно передачи</li><li class="b">socket</li><li class="lib">Идентификатор, включающий номер порта TCP и адрес IP.</li><li class="b">Source Address</li><li class="lib">Адрес отправителя, обычно идентифицирующий хост или сеть.</li><li class="b">SYN</li><li class="lib">Бит управления во входящем сегменте (занимающем один порядковый номер), который используется для индикации начала отсчета порядковых номеров.</li><li class="b">TCB</li><li class="lib">Transmission control block — блок управления передачей, содержащий информацию о состоянии соединения.</li><li class="b">TCB.PRC</li><li class="lib">Предпочтения для данного соединения.</li><li class="b">TCP</li><li class="lib">Transmission Control Protocol — протокол управления передачей. Протокол обмена информацией между хостами, обеспечивающий гарантированную доставку в межсетевых средах.</li><li class="b">TOS</li><li class="lib">Type of Service — тип обслуживания. Поле протокола IP.</li><li class="b">Type of Service</li><li class="lib">Поле протокола IP, задающее тип обслуживания для данного фрагмента IP.</li><li class="b">URG</li><li class="lib">Бит управления (urgent — срочность), не включаемый в пространство порядковых номеров и служащий для индикации того, что получатель должен быть уведомлен о срочности обработки данных (эти данные должны быть восприняты сразу же после завершения работы с данными, порядковый номер которых меньшим, нежели задано указателем срочности).</li><li class="b">urgent pointer (указатель срочности)</li><li class="lib">Поле управления, имеющее смысл только при установке бита URG и содержащее значение указателя срочности, которое говорит о заданном пользователем уровне срочности данных.</li></ul><h2 id="p.references">Литература</h2><table itemprop="references"><tr><td>[1]</td><td>Cerf, V., and R. Kahn, «A Protocol for Packet Network Intercommunication», IEEE Transactions on Communications, Vol. COM-22, No. 5, pp 637-648, Май 1974.</td></tr><tr><td>[RFC791]</td><td>J. Postel, <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">«Протокол IP (Internet Protocol)», RFC 791</a>, Сентябрь 1981.</td></tr><tr><td>[3]</td><td>Dalal, Y. и C. Sunshine, «Connection Management in Transport Protocols», Computer Networks, Vol. 2, No. 6, pp. 454-473, Декабрь 1978.</td></tr><tr><td>[RFC790]</td><td>Postel, J., «Assigned Numbers», RFC 790, USC/Information Sciences Institute, Сентябрь 1981.</td></tr></table></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 793 - Протокол управления передачей (TCP)",disqus_identifier="793.rfc",disqus_url="http://rfc2.ru/793.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>