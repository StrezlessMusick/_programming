<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../917.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 917 — Подсети Internet</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../917.rfc">RFC 917 — Подсети Internet</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 917</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank" rel="nofollow"><span itemprop="alternativeHeadline">Internet Subnets</span></a></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Не определено</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1984-10-01">Октябрь 1984</time></dd><dd><div class="icon i5"></div> Автор: <span itemprop="author">Jeffrey Mogul</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div id="text" itemprop="articleBody"><h3>Статус документа</h3><p>В этом RFC описан протокол, предложенный сообществу ARPA-Internet, и содержится приглашение к дискуссии и совершенствованию протокола. Документ может распространяться без ограничений.</p><h3>Обзор</h3><p>Мы обсуждаем парадигму «подсетей» (subnet) в сетях Internet, представляющих собой видимые подмножества единой сети IP. По административным и техническим причинам многие организации делят свою сеть IP на несколько подсетей вместо приобретения дополнительных блоков адресов IP.</p><p>Мы предлагаем процедуры для использования подсетей и обсуждаем варианты решения возникающих проблем (в частности, маршрутизации).</p><h2>1. Введение</h2><p>Исходное представление сети Internet включало два уровня иерархии — верхний уровень представлял сеть catenet в целом, и нижний — множество сетей IP, каждая из которых имеет свой номер (мы не предполагаем в Internet иерархической топологии, но интерпретация адресов является иерархической).</p><p>Хотя такое представление обеспечивает простоту и мощь, многие организации считают его неадекватным и добавляют третий уровень в иерархическую схему интерпретации адресов IP. В этом случае сеть IP может быть поделена на некоторое количество подсетей.</p><p>Исходное, двухуровневое представление основано на строгом допущении о том, что для хоста в сети IP эта сеть может представляться, как единое целое; иными словами, сеть можно трактовать, как «черный ящик», к которому подключены хосты. Это верно для ARPANET, поскольку IMP маскируют использование конкретных каналов в сети. Это верно также для большинства технологий ЛВС типа Ethernet или сетей с кольцевой топологией.</p><p>Однако это допущение неверно для многих практических случаев, поскольку организациям средних размеров (например, университетам или компаниям, расположенным в нескольких зданиях) зачастую приходится использовать более одной ЛВС для покрытия «локальной области». Например, на момент подготовки этого документа в сети Стэнфордского университета использовалось 18 ЛВС и планировалось увеличение их числа.</p><p>Существует несколько причин, по которым организации могут использовать несколько ЛВС для покрытия территории:</p><ul class="dot"><li><p>Различные топологии — зачастую (особенно в исследовательских организациях) в сети могут присутствовать ЛВС различных типов (например, Ethernet и сети с кольцевой топологией).</p></li><li><p>Технологические ограничения — большинству топологий ЛВС присущи те или иные ограничения (электрические параметры, число хостов в ЛВС, общая протяженность кабеля). Использование подсетей позволяет достаточно просто преодолеть эти ограничения (особенно ограничение протяженности кабеля).</p></li><li><p>Насыщение сети — в локальных сетях могут возникать ситуации, когда небольшая группа хостов фактически монополизирует полосу пропускания сетевой среды. Общим решением таких проблем является сегментирование сети (разбиение на несколько фрагментов) с организацией раздельных кабельных систем.</p></li><li><p>Использование каналов «точка-точка» — иногда «локальная сеть» (например, кампусная сеть университета) разделена на несколько фрагментов (например, ЛВС отдельных зданий), соединенных между собой скоростными каналами «точка-точка».</p></li></ul><p>Организации, имеющие более одной ЛВС, могут выбрать один из трех вариантов распределения адресов IP:</p><ol><li><p>Получить отдельный блок адресов для каждой ЛВС.</p></li><li><p>Использовать для всей организации общий номер сети и распределять адреса независимо от принадлежности хостов к ЛВС. Такой вариант получил название transparent subnets (прозрачные подсети).</p></li><li><p>Используя один номер сети, разделить адресное пространство на несколько подсетей в соответствии с имеющимися ЛВС. Такой вариант называется explicit subnets (явные подсети).</p></li></ol><p>Каждый из вариантов имеет свои преимущества и недостатки. Первый вариант не требует добавления или изменения протоколов, но ведет к разрастанию таблиц маршрутизации Internet. Информация о внутренней структуре сети распространяется повсюду, хотя она мало кому нужна и в большинстве случаев не используется за пределами организации. В некоторых реализациях шлюзов может возникать проблема нехватки пространства в таблице маршрутов, поэтому такой вариант лучше не использовать.</p><p>Второй вариант требует использования неких соглашений или протоколов, позволяющих объединить множество ЛВС в одну сеть IP. Например, этот вариант можно реализовать в ЛВС, где каждый адрес IP транслируется в аппаратный адрес с использованием протокола ARP, имея мосты между ЛВС, которые будут перехватывать запросы ARP для нелокальных адресатов. Однако такое решение возможно не для всех технологий ЛВС, особенно в тех случаях, когда технология не использует протокол ARP или ЛВС не поддерживает широковещания. Более фундаментальная проблема заключается в том, что мосты должны узнавать к какой ЛВС принадлежит хост, возможно используя для этого широковещательные рассылки. По мере увеличения числа ЛВС расходы на поддержку такого широковещания будут быстро возрастать; расти будет и размер кэша трансляции в мостах, требуемого для преобразования адресов.</p><p>Третий вариант рещает ключевую проблему — существующие стандарты предполагают, что все хосты в сети IP подключены к одной ЛВС. Решение заключается в явной поддержке подсетей. Этот вариант тоже имеет недостатки — в частности, требуется модификация протокола IP, которая влечет за собой необходимость изменения существующих реализаций IP (если планируется использовать их с подсетями). Однако требуемые изменения сравнительно невелики и после их внесения проблема будет эффективно решена. Кроме того, этот вариант не требует каких-либо изменений, которые будут несовместимы с существующими хостами в сетях без разбиения на подсети.</p><p>После выбора одного из вариантов может оказаться, что хосты, которые предполагалось использовать в среде без подсетей, попадут в одну из подсетей, как описано ниже. Такое решение может быть полезно в тех случаях, когда нет возможности явно поддерживать подсети или требуется постепенный переход. С учетом этого для использования второго варианта, описанного выше, нет достаточно веских причин.</p><p>В остальной части этого документа описывается модель разбиения сетей IP на подсети.</p><h3>1.1. Терминология</h3><p>Во избежание раззнотолков и многословия определим термины, которые будут использоваться далее.</p><ul><li class="b">Catenet</li><li class="lib">Набор соединенных между собой сетей IP.</li><li class="b">Network — сеть</li><li class="lib">Отдельная сеть IP (поделенная или не подеренная на подсети).</li><li class="b">Subnet — подсеть</li><li class="lib">Подсеть сети IP.</li><li class="b">Network Number — номер сети</li><li class="lib">В соответствии с [<a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC791</a>].</li><li class="b">Local Address — локальный адрес</li><li class="lib">Биты адреса IP, не используемые в номере сети. Используется также термин «rest field» (остальные биты).</li><li class="b">Subnet Number — номер подсети</li><li class="lib">Номер, идентифицирующий подсеть внутри сети.</li><li class="b">Subnet Field — поле подсети</li><li class="lib">Битовое поле в адресе IP, используемое для задания номера подсети.</li><li class="b">Host Field — поле хоста</li><li class="lib">Битовое поле в адресе IP, используемое для адресации конкретного хоста.</li><li class="b">Gateway — шлюз</li><li class="lib">Узел, подключенный к двум или более сетям с различным административным управлением и/или подсетям, которому хосты направляют дейтаграммы для пересылки.</li><li class="b">Bridge — мост</li><li class="lib">Узел, подключенный к двум или более подсетям, разделенным физически, но находящимся под единым административным управлением, который автоматически пересылает между этими сетями дейтаграммы (при необходимости), оставаясь «незаметным» для остальных хостов. Для обозначения мостов используют также термин software repeater (программный повторитель).</li></ul><h2>2. Стандарты для адресации подсетей</h2><p>Следуя делению, представленному в [RFC814], мы обнаружили, что подсети являются фундаментальной проблемой адресации. В этом разделе мы впервые описываем предложенную интерпретацию адресации Internet Addressing для поддержки подсетей. Далее рассматривается взаимодействие этого формата адресации с широковещанием и в заключение представлен протокол детектирования используемого в конкретной сети способа интерпретации адресов.</p><h3>2.1. Интерпретация адресов IP</h3><p>Предположим, что организации был выделен номер сети Internet, сеть была поделена на множество подсетей и нужно распределять адреса для хостов. Как следует это делать? Поскольку существуют минимальные ограничения на выделение «локальной части» адреса Internet, предлагается несколько вариантов представления номеров подсетей:</p><ol><li><p>Поле переменной длины — для нумерации подсетей используется произвольное число битов локальной части адреса. Размер поля номера подсети сохраняется в масштабах каждой подсети, но может различаться в разных подсетях. Если поле имеет нулевой размер, это говорит об отсутствии подсетей.</p></li><li><p>Поле фиксированной длины — для нумерации подсетей используется фиксированное число битов (например, 8).</p></li><li><p>Поле переменной длины с автокодированием. Классы сетей (размер поля номера сети) определяются значениями старших битов адреса IP — аналогично этому старшие биты локальной части адреса могут задавать размер поля номера подсети.</p></li><li><p>Поле фиксированной длины с автокодированием. Для нумерации подсетей используется заданное число битов. Единица в старшем бите этого поля говорит об использовании подсетей, при нулевом значении старшего бита вся локальная часть адреса служит для нумерации хостов.</p></li></ol><p>Поскольку отсутствуют видимые признаки преимуществ ингого варианта, во всех этих схемах для нумерации подсетей используются старшие биты локальной части адреса. Поскольку для сетей класса C локальная часть достаточно мала, для этого класса адресов использование подсетей менее осмысленно, нежели для сетей класса A или B.</p><p>По каким критериям следует выбирать одну из четырех предложенных схем? Во-первых, мы хотим использовать автокодирование, позволяющее по адресу Internet определить, используется ли в сети разбиение на подсети без привлечения другой информации.</p><p>Одним из преимуществ автокодирования является возможность определить, поделена ли нелокальная сеть на подсети. Практическое использование этого преимущества не очевидно. Однако основное преимущество заключается в том, что реализации не требуется дополнительных данных для определения принадлежности двух адресов к одной подсети. Однако это может казаться недостатком, поскольку может вызывать проблемы для сетей без разбиения на подсети, в которых номера с 1 в старшем бите локальной части адреса уже используются (см. примечание 2 в конце страницы). Иными словами, полезно иметь возможность контроля разбиения сети на подсети независимо от распределения номеров хостов. Другим недостатком любой схемы с автокодированием является то, что такие схемы уменьшают доступный размер локального пространства адресов по крайней мере вдвое.</p><p>Если не использовать схему с автокодированием, ясно, что предпочтительным будет вариант с переменным размером поля номера подсети. Поскольку в любом случае требуется некий «флаг», показывающий использование подсетей, дополнительные издержки в результате использования целого числа (размер поля номера подсети) вместо логической переменной (флаг) пренебрежимо малы. Преимущество использования поля номера подсети с переменным размером заключается в том, что каждая организация получает возможность выбора способа использования достаточно скудного чсла битов локальной части адреса для нумерации подсетей и хостов.</p><p>Наше предложение, следовательно, заключается в том, что адреса Internet интепретируются, как три поля:</p><pre>&lt;network-number&gt;&lt;subnet-number&gt;&lt;host-number&gt;</pre><p>где поле &lt;network-number&gt; определено в [<a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC791</a>], поле &lt;host-number&gt; имеет размер не менее 1 бита, а поле &lt;subnet-number&gt; постоянно для данной подсети. Дополнительной структуры для полей &lt;subnet-number&gt; и &lt;host-number&gt; не требуется. Если размер поля &lt;subnet-number&gt; равен 0, сеть не делится на подсети (т. е., используется интерпретация [<a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC791</a>]).</p><p>Например, в сети класса A с 8-битовым полем номера подсети поля адреса имеют вид, показанный на рисунке:</p><pre>                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0|    NETWORK    |     SUBNET    |         Host number         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><p>Предполагается, что для упрощения и повышения эффективности реализаций протокола большинство организаций будет выбирать размер поля номера подсети, кратный восьми битам. Однако реализации должны быть готовы к обработке полей номера подсети иного размера.</p><p>Мы отказываемся от рекурсивного использования подсетей с дополнительным делением поля номера хоста по ряду причин:</p><ul class="dot"><li>четырехуровневая иерархия обычно не требуется;</li><li>число битов адреса IP недостаточно велико для такого деления;</li><li>сложность механизмов дополнительного деления.</li></ul><h3>2.2. Измнение программ хостов для поддержки подсетей</h3><p>В большинстве реализация протокола IP имеется код для обслуживания исходящих потоков типа приведенного ниже:</p><pre>IF ip_net_number(packet.ip_dest) = ip_net_number(my_ip_addr)
    THEN
        send_packet_locally(packet, packet.ip_dest)
    ELSE
        send_packet_locally(packet,
           gateway_to(ip_net_number(packet.ip_dest)))</pre><p>Код с поддержкой множества подключенных сетей несколько сложнее, но в данном случае это не имеет значения.</p><p>Для поддержки подсетей нужно сохранить одно дополнительное 32-битовое значение — маску IP (my_ip_mask). Эта битовая маска представляет собой строку битов, в которой установлены (1) значения битов, соответствующий номеру сети IP и номеру подсети. Например, для сети класса A с 8-битовым полем номера подсети маска будет иметь значение 255.255.0.0.</p><p>Упомянутый выше код тогда принимает вид:</p><pre>IF bitwise_and(packet.ip_dest, my_ip_mask)
                 = bitwise_and(my_ip_addr, my_ip_mask)
    THEN
        send_packet_locally(packet, packet.ip_dest)
    ELSE
        send_packet_locally(packet,
           gateway_to(bitwise_and(packet.ip_dest, my_ip_mask)))</pre><p>Очевидно, что часть выражения в условном операторе может быть вычислена заранее.</p><p>Может потребоваться изменение функции gateway_to с включением такого же условия сравнения.</p><p>Для поддержки хостов со множеством подключения код может быть изменен так, чтобы значения my_ip_addr и my_ip_mask сохранялись для каждого интерфейса, а выражения в условном операторе должны вычисляться для каждого интерфейса.</p><h3>2.3. Подсети и широковещание</h3><p>В отсутствии подсетей для протокола IP возможны только два варианта широковещания — всем хостам указанной сети или всем хостам данной сети. Последний вариант полезен в тех случаях, когда хост не знает номера своей сети.</p><p>При наличии подсетей ситуация слегка усложняется. Во-первых появляется возможность широковещательной передачи в масштабе подсети. Во-вторых, для широковещания всем хостам подсети требуется дополнительный механизм (в работе [<a href="../919.rfc" title="RFC 919 - Широковещательная рассылка дейтаграмм IP">RFC919</a>] предложено использовать механизм [3]). И, наконец, интерпретация широковещания в данную сеть изменяется и пакеты не пересылаются за пределы исходной подсети.</p><p>Следовательно, реализации должны распознавать три типа широковещательных адресов в дополнение к своему адресу хоста:</p><ul><li class="b">This physical network — данная физическая сеть</li><li class="lib">Адрес получателя, состоящий из одних единиц (255.255.255.255), приводит к передаче дейтаграммы как широковещательной в масштабе физической сети; для шлюзов пересылка таких дейтаграмм недопустима.</li><li class="b">Specific network — указанная сеть</li><li class="lib">Адрес получателя содержит корректный номер сети, а локальная часть адреса — только единицы (например, 36.255.255.255).</li><li class="b">Specific subnet — указанная подсеть</li><li class="lib">Адрес получателя содержит корректные номера сети и подсети, а номер хоста — только единицы (например, 36.40.255.255).</li></ul><p>Дополнительную информацию о широковещании Internet можно найти в работе [<a href="../919.rfc" title="RFC 919 - Широковещательная рассылка дейтаграмм IP">RFC919</a>].</p><p>Одним из факторов при решении вопроса об использовании подсетей является возможность широковещания всем хостам сети с подсетями в один прием со стороны передающего хоста. Если бы хосты находились в разных сетях, такая операция стала бы невозможной.</p><h3>2.4. Определение размера поля номера подсети</h3><p>Как хост (или шлюз) может определить использование поля номера подсети в подключенной к нему сети? Эта проблема аналогична проблемам, возникающим при загрузке хостов Internet, — как хост может узнать свой адрес и адрес шлюза в своей сети? Для всех ситуаций существует два варианта решения этих проблем — «аппаратная» информация и протоколы на основе шероковещания.</p><p>«Аппаратная» информация удобна для изолированных (не подключенных к сети) хостов. Она может быть «встроена» или храниться в дисковом файле (предпочтительно). Однако для широко распространенного случая загрузки бездисковых станций через ЛВС, «аппаратная» информация не подходит. Если технология ЛВС поддерживает широковещание, лучшим методом будет использование «свежезагруженным» хостом широковещательной передачи запроса на получение требуемой информации. Например, для определения адреса IP хост может использовать протокол обратного преобразования адресов RARP [<a href="../903.rfc" title="RFC 903 - Протокол RARP">RFC903</a>].</p><p>Мы предлагаем расширить протокол ICMP [<a href="../792.rfc" title="RFC 792 - Протокол ICMP">RFC792</a>], добавив пару типов сообщений — Address Format Request и Address Format Reply, аналогичных сообщениям Information Request и Information Reply (см Приложение I).</p><p>Новые сообщения ICMP используются следующим образом — хост при загрузке передает широковещательное сообщение Address Format Request, а шлюз (или хост, действующий вместо шлюза), получив такое сообщение, будет передавать отклик Address Format Reply. Если в запросе отправитель не был указан (поле IP Source Address имеет значение 0), отклик также передается в широковещательном сообщении. Запросивший информацию хост получит это сообщение и сможет определить размер поля номера подсети.</p><p>Поскольку для каждой конкретной ЛВС в сообщении Address Format Reply может содержаться только одно значение, нет необходимости проверять соответствие отклика запросу. Даже при получении отклика от нескольких шлюзов, информация во всех сообщениях будет совпадать. Предполагается, что хосты перезагружаются достаточно редко, поэтому количество широковещательных сообщений для определения маски будет достаточно мало.</p><p>Если хост подключен к множеству ЛВС, он должен использовать этот протокол для каждой из сетей, пока не будет обнаружено (по отклику одной из ЛВС), что некоторые ЛВС относятся к одной сети и, следовательно, имеют одинаковый размер поля номера подсети.</p><p>Одной из возможных проблем является отсутствие сообщений «Address Format Request» после разумного числа попыток запроса. Возможны три причины возникновения таких ситуаций:</p><ol><li>Локальная сеть постоянно изолирована от всех других сетей.</li><li>Подсети не используются и ни один из хостов не поддерживает таких запросов ICMP.</li><li>Все шлюзы локальной сети (временно) находятся в нерабочем состоянии (down).</li></ol><p>В первых двух случаях подразумевается, что поле номера подсети имеет нулевой размер. В третьем случае не существует способа определить размер поля номера подсети и самым безопасным вариантом будет считать этот размер нулевым. Хотя позднее может обнаружиться некорректность такого выбора, это не порождает проблем при передаче. После того, как восстановится нормальная работа шлюза, он будет передать широковещательное сообщение Address Format Reply; когда хост получит это сообщение, он сможет заменить свои допущения полученным от шлюза значением. Хостам и шлюзам не следует передавать сообщений Address Format Reply с «предполагаемой» маской.</p><p class="note">В заключение отметим, что хост не обязан использовать протокол ICMP для определения размера поля номера подсети — параметры хоста могут сохраняться в энергонезависимой памяти.</p><h2>3. Методы маршрутизации подсетей</h2><p>Обной из проблем, с которыми сталкиваются все хосты Internet, является определение маршрута к другому хосту. Использование подсетей лишь слегка изменяет эту проблему.</p><p>При использовании подсетей возникает два уровня процесса маршрутизации вместо одного. Если получатель находится в одной сети с отправителем, в маршрутизации участвуют только маршрутизаторы подсетей между хостами. Если получатель находится в другой сети, процесс маршрутизации требует выбора шлюза для выхода из сети отправителя и маршрута через эту сеть к выбранному шлюзу.</p><p>К счастью, большинство хостов могут игнорировать это различие (фактически, игнорировать любой выбор маршрута), используя принятый по умолчанию шлюз в качестве начала маршрута ко всем получателям и опираясь на сообщения ICMP Host Redirect для определения более подходящих маршрутов. Однако такой метод неэффективен для шлюзов и многодомных хостов, поскольку перенаправление может оказаться бесполезным при некорректном начальном выборе маршрута. Таким хостам следует использовать протокол обмена маршрутной информацией, но этот вопрос выходит за пределы настоящего документа. В любом случае, описанная выше проблема не зависит от использования подсетей.</p><p>Проблема хостов с одним подключением заключается в поиске хотя бы одного соседнего шлюза. Здесь также имеются два варианта — аппаратная информация и широковещание. Мы полагаем, что проблема поиска соседнего шлюза не зависит от использования подсетей и, следовательно, решение этой проблемы при наличии подсетей будет таким же.</p><p>Однако еще одна проблема сохраняется — отправитель должен понять, следует передавать дейтаграмму для адресата шлюзу или ее можно отправить получателю напрямую. Иными словами, находится ли адресат в одной физической сети с отправителем? Эта фаза процесса маршрутизации является единственной, которая требует от реализации явной поддержки подсетей. Фактически, если широковещание не применяется, это единственная ситуация, когда реализацию IP требуется изменить для поддержки подсетей.</p><p>В силу сказанного, возможно использовать существующие реализации без внесения изменений даже при наличии подсетей. Для того, чтобы это тсало возможным, реализация должна:</p><ul class="dot"><li>использоваться только на хостах с одним подключением, но не на шлюзах;</li><li>использоваться в широковещательной ЛВС;</li><li>использовать протокол преобразования адресов (типа ARP [<a href="../826.rfc" title="RFC 826 - Протокол преобразования адресов Ethernet (ARP)">RFC826</a>]);</li><li>не требовать поддержки соединения в случаях отказов шлюза.</li></ul><p>В такой ситуации можно ограничиться модификацией сервера ARP в подсети так, чтобы он при получении запроса ARP проверял адрес получателя на предмет определения своей принадлежности к лучшему пути в направлении получателя. При положительном результате проверки сервер передает запрашивающему хосту отклик ARP со своим аппаратным адресом. Запрашивающий хост в результате предполагает, что ему известен аппаратный адрес получателя и передает пакеты по этому адресу. Фактически пакеты получает шлюз, который пересылает их адресату обычным путем.</p><p>Этот метод требует некоторого «размывания» уровней на шлюзах, поскольку сервер ARP и таблица маршрутизации IP обычно не связаны. Однако реализовать такую связь можно достаточно просто и без существенного снижения производительности. Одна из проблем состоит в том, что при аварии исходного шлюза для отправителя не будет способа узнать другие маршруты к получателю, если такие маршруты имеются. В результате соединение будет прервано.</p><p>Не следует путать этот метод организации «подсетей на базе ARP» со слегка похожим на него использованием мостов на основе ARP. Подсети на базе ARP используют возможность шлюза проверять адрес IP и устанавливать маршрут к получателю на основе явной топологии подсети. Иными словами, малая часть процесса выбора маршрута переносится от хоста-отправителя к шлюзу. Мост на основе ARP, напротив, должен узнать расположение каждого хоста без помощи отображения между адресами хостов и топологией. Системы, построенные на основе таких мостов, не следует считать поделенными на подсети.</p><p>Важно отметить, что использование подсетей на базе ARP осложняется широковещанием. Серверу ARP [<a href="../826.rfc" title="RFC 826 - Протокол преобразования адресов Ethernet (ARP)">RFC826</a>] никогда не следует отвечать на запросы, где получатель имеет широковещательный адрес. Такие запросы могут исходить только от хостов, которые не распознают широковещательных адресов в таком качестве и ответ на подобный запрос почти всегда будет приводить к возникновению маршрутной петли. Если имеется N таких хостов, которые не распознают адрес в качестве широковещательного, пакет, переданный с TTL может приводить к возникновению T^N ненужных широковещательных пакетов.</p><h2>4. Примеры использования подсетей</h2><p>В этом разделе кратко описаны примеры использования подсетей в нескольких организациях.</p><h3>4.1. Сиэнфордский университет</h3><p>В Стенфордском университете подсети появились по историческим причинам. В сети университета использовались протоколы Pup [1] для нескольких экспериментальных сетей Ethernet [5] с 1979 года, на несколько лет раньше начала использования протоколов Internet. В работе было множество шлюзов Pup, а все хосты и шлюзы обменивались таблицами маршрутизации с использованием простого широковещательного протокола.</p><p>После появления протокола IP было принято решение об использовании восьмибитового поля номера подсети и номера подсетей Internet были выбраны в соответствии с номерами сетей Pup для данной ЛВС Ethernet и номерами хостов Pup (тоже восемь битов) в качестве номеров хостов в адресах Internet.</p><p>Шлюзы, поддерживающие только Pup, были модифицированы для пересылки дейтаграмм Internet в соответствии с таблицами маршрутизации Pup, поскольку без такой модификации они просто не понимали пакетов Internet и фактически не меняли значение поля TTL в заголовках IP. Такое решение представлялось приемлемым, поскольку ошибок, вызывающих появление маршрутных петель, не наблюдалось. Хосты Internet, которые были многодомными и могли, таким образом, функционировать в качестве маршрутизаторов, меняли значение TTL. Поскольку все такие хосты одновременно являлись шлюзами Pup дополнительного обмена маршрутными данными не требовалось.</p><p>Реализации хостов Internet были модернизированы для поддержки подсетей (различными путями, но с одинаковым результатом). Поскольку все эти хосты уже имели реализации Pup, таблицы маршрутизации Internet поддерживались теми же процессами, что и таблицы Pup — номера сетей Pup просто транслировались в номера подсетей Internet.</p><p>При добавлении сетей Ethernet 10 Мбит/с шлюзы были модифицированы для использования описанной выше схемы на базе ARP. Это позволило использовать немодифицированные хосты в сетях Ethernet 10 Мбит/с.</p><p>Подсети IP начали использоваться с 1982 г; в настоящее время насчитывается около 330 хостов, 18 подсетей и близкое число шлюзов между подсетями. Поскольку шлюзы, поддерживающие только Pup, были преобразованы в шлюзы Internet, был добавлен протокол обмена маршрутной информацией Internet, заменивший протокол Pup.</p><h3>4.2. MIT</h3><p>MIT был первым сайтом IP с большим набором локальных сетевых соединений. Поскольку это было до деления сетевых номеров на классы, выделение каждому каналу MIT своего номера сети IP привело бы к расходу значительной части адресного пространства. В MIT было принято решение использовать один номер сети IP и самостоятельно управлять оставшимися 24 битами адреса, разделив их на три 8-битовых поля — номер подсети, резервное поле (0) и номер хоста. Поскольку уже использовавшийся в MIT протокол CHAOS работает с восьмибитовым полем номера подсети, можно было выделить каждому каналу одинаковые номера для обоих протоколов. Для номера хоста IP было выбрано 8-битовое поле потому, что в тот момент большинство сетевого оборудования использовало 8-битовые адреса, как в протоколе CHAOS. Это позволило также зарезервировать часть битов адреса IP на будущее.</p><p>Первоначальный план предполагал использование протоколов динамической маршрутизации между шлюзами подсетей IP — несколько протоколов этого типа тогда обсуждалось, но ни один не был реализован, поэтому продолжают использоваться статические таблицы. Ясно, что переход к динамической маршрутизации со временем произойдет.</p><p>Для решения проблемы с необходимостью модификации импортируемых программ IP для работы в средахх с подсетями, MIT начал искать модель, позволяющую обойтись минимальными изменениями IP на хостах. В результате была выбрана модель, в которой шлюзы IP передают сообщения ICMP Host Redirect, а не Network Redirect. Сейчас все внутренние IP-шлюзы MIT поступают таким образом. С хостами, которые могут поддерживать таблицы маршрутизации IP для нелокального обмена пакетами на уровне хостов, это позволяет скрыть основную часть структуры подсетей.</p><p>Минимальные правки программ на хостах для корректной работы в средах с подсетями и без них включали поддержку алгоритма битовых масок, упомянутого выше.</p><p>У MIT нет плана незамедлительного перехода на использование одного «одобренного» протокола — это обусловлено локальной автономностью и количеством установленных программ, а также отсутствием единого индустриального стандарта. Вместо этого была принята модель обеспечения одного набора физических каналов и пакетных коммутаторов и деление на несколько «виртуальных» сетей в одном наборе физических каналов. У MIT был некоторый опыт попыток обмена маршрутной информацией между протоколами и «заворачивания» одного протокола в другой. Общей моделью было сохранение изоляции протоколов при использовании общего базового оборудования. Использование ARP для сокрытия структуры подсетей не так важно, поскольку ведет к усложнению операций преобразования адресов. В усложненной системе (с петлями и разноскоростными каналами) потребуется более изощренный обмен информацией между шлюзами, что делает этот явный (но изолированный от хоста) механизм лучшим решением.</p><h3>4.3. Университет Карнеги-Мэллона</h3><p>CMU использует сеть класса B, поделенную на 11 физических подсетей (2 сети 3Mbit Experimental Ethernet, 7 сетей Ethernet 10 Мбит/с и два кольца ProNet). Адреса хостов распределены так, что все адреса с данным третьим октетом относятся к одной подсети (обратное не обязательно верно), это важно с точки зрения удобства администрирования. Программы не знают специфики этого механизма распределения и не зависят от маршрутов между ЛВС.</p><p>Вместо этого используется схема с мостами на базе ARP. Когда хост передает широковещательный запрос ARP, все мосты, получившие этот запрос, кэшируют исходное отображение протокольного адреса и пересылают запрос (после предварительных операций), как широковещательный запрос ARP в каждую из подключенных к мосту сетей. Когда мост получает (не широковещательный) отклик ARP, в котором целевой протокольный адрес не относится к этому мосту, он просматривает кэш ARP для определения сети, в которую следует переслать отклик. Мосты, таким образом, пытаются расширить протокол ARP на гетелогенную сеть из множества ЛВС. Следовательно, мостам требуется преобразовывать широковещательные запросы ARP из одной сети в широковещательные запросы ARP во все другие сети, подключенные к мосту, даже когда мост «знает лучшую» сеть. Этот алгоритм работает только в отстуствии циклов в графе сетевой связности (в данном случае это выполняется). Ведутся работы по замене этого простого алгоритма протоколом, реализованным в мостах, для поддержки избыточных путей и снижения объема широковещания. Задача состоит в сохранении базы ARP и прозрачности хостов, если это возможно.</p><p>Реализации, поддерживающие Ethernet 3 Мбит/с и кольца proNET 10 Мбит/с в CMU, используют <a href="../826.rfc" title="RFC 826 - Протокол преобразования адресов Ethernet (ARP)">RFC 826</a> ARP (взамен того или иного аппаратного отображения типа простого использования 8-битовых аппаратных адресов в качестве четвертого октета адреса IP).</p><p>Поскольку избыточные пути между ЛВС отсутствуют, возникает вопрос поддержки соединений при аварии моста. При количестве поддерживающих IP хостов порядка 150 на сеть, размер кэша в мостах сохраняется в разумных пределах и на пересылку широковещательных запросов ARP расходуется достаточно малая полоса.</p><p>Сеть CMU растет от небольшой конфгурации с одним подключением в подразделении CS/RI до кампусной сети с множеством департаментов, 5000-10000 хостов и избыточными соединениями между ЛВС. Возможно, что схема с мостами на базе ARP не обеспечит требуемого масштабирования и может потребоваться система с явными подсетями. Среднесрочной задачей, однако, является создание среды, в которую можно импортировать необновленные реализации IP (в частности, Ethernet 10 Мбит/с), чтобы сохранить прозрачный (т. е., основанный на ARP) механизм маршрутизации как можно дольше. CMU считает, что даже при включении подсетей в стандарты IP, они не будут использоваться достаточно широко — в этом состоит основная помеха использованию подсетей в CMU.</p><h2>Приложение I. Формат пакетов ICMP</h2><p>Пакеты Address Format Request и Address Format Reply включают показанные на рисунке поля:</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |      Code     |          Checksum             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Identifier          |       Sequence Number         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><p>Поля IP:</p><ul><li class="b">Адреса</li><li class="lib">Адрес отправителя в сообщении Address Format Request будет адресом получателя Address Format Reply. При создании отклика адрес отправителя из запроса становится адресом получателя, а в качестве отправителя отклика указывается адрес отвечающего хоста, код типа меняется на A2, значение размера поля номера подсети помещается в поле Code и запово рассчитывается контрольная сумма. Однако если в качестве адреса отправителя запроса указан 0, в качестве адреса получателя отклика указывается широковещательный адрес.</li></ul><p>Поля ICMP:</p><ul><li class="b">Type — тип</li><li class="lib">A1 для запросов;<br />A2 для откликов.</li><li class="b">Code — код</li><li class="lib"><p>0 для сообщений Address Format Request.</p><p>Размер поля номера подсети в сообщениях Address Format Reply.</p></li><li class="b">Checksum — контрольная сумма</li><li class="lib"><p>Контрольная сумма представляет собой 16-битовое поразрядное дополнение до 1 суммы дополнений до 1, рассчитанной для сообщения ICMP, начиная с поля ICMP Type. При расчете контрольной суммы значение поля принимается нулевым. Механизм расчета контрольной суммы в будущем может измениться.</p></li><li class="b">Identifier — идентификатор</li><li class="lib"><p>Идентификатор служит для сопоставления запросов и откликов. Может иметь нулевое значение.</p></li><li class="b">Sequence Number — порядковый номер</li><li class="lib"><p>Номер служит для сопоставления запросов и откликов. Может иметь нулевое значение.</p></li><li class="b">Описание</li><li class="lib"><p>Шлюзу, получившему сообщение Address Format Request следует возвратить отклик на него, указав в поле Code число битов поля номера подсети в адресах IP для сети, в которую дейтаграмма была адресована. Если запрос был широковещательным, получателем будет «данная сеть». Размер поля Subnet может принимать значения от 0 до (31 — N), где N задает число битов в поле номера сети IP (т. е., 8, 16 или 24).</p><p>Если запрашивающий хост не знает своего адреса IP, он может указать значение 0 в поле адреса отправителя; отклик следует передавать по широковещательному адресу. Поскольку для сети существует один возможный формат адреса, нет необходимости устанавливать соответствие между запросами и откликами. Однако такого подхода следует, по возможности, избегать, поскольку он ведет к росту широковещательной нагрузки на сеть.</p><ul><li>Тип A1 может приходить от шлюза или хоста.</li><li>Тип A2 может приходить от шлюза или хоста, действующего в качестве шлюза.</li></ul></li></ul><h2>Приложение II. Примеры</h2><p>В приведенных здесь примерах предполагается, что запрашивающий хост имеет адрес 36.40.0.123, адрес шлюза — 36.40.0.62, сеть — 36.0.0.0, а поле номера подсети занимает 8 битов.</p><p>Сначала предположим, что широковещание разрешено и хост 36.40.0.123 знает свой адрес. Он будет отправилять дейтаграмму:</p><pre>Source address:          36.40.0.123
Destination address:     36.255.255.255
Protocol:                ICMP = 1
Type:                    Address Format Request = A1
Code:                    0</pre><p>36.40.0.62 будет слышать эту дейтаграмму в ответ на которую ему следует передать отклик:</p><pre>Source address:          36.40.0.62
Destination address:     36.40.0.123
Protocol:                ICMP = 1
Type:                    Address Format Reply = A2
Code:                    8</pre><p>В качестве следующего примера предположим, что 255.255.255.255 означает «широковещательный адрес данной физической сети», как описано в [<a href="../919.rfc" title="RFC 919 - Широковещательная рассылка дейтаграмм IP">RFC919</a>].</p><p>Предыдущий пример неэффективен, поскольку запрос может в широковещательном режиме пересылаться во множество подсетей. Более эффективный метод, который мы рекомендуем, заключается в том, что хост сначала определяет свой адрес (возможно с помощью протокола RARP, описанного в [<a href="../903.rfc" title="RFC 903 - Протокол RARP">RFC903</a>]), а после этого передает запрос ICMP по адресу 255.255.255.255:</p><pre>Source address:          36.40.0.123
Destination address:     255.255.255.255
Protocol:                ICMP = 1
Type:                    Address Format Request = A1
Code:                    0</pre><p>Шлюз в этом случае может напрямую ответить запрашивающему хосту.</p><p>Предположим, что 36.40.0.123 является бездисковой станцией, которая не знает даже свой номер хоста. Она может передать дейтаграмму:</p><pre>Source address:          0.0.0.0
Destination address:     255.255.255.255
Protocol:                ICMP = 1
Type:                    Address Format Request = A1
Code:                    0</pre><p>36.40.0.62 услышит эту дейтаграмму, на которую ему следует ответить дейтаграммой:</p><pre>Source address:          36.40.0.62
Destination address:     36.40.255.255
Protocol:                ICMP = 1
Type:                    Address Format Reply = A2
Code:                    8</pre><p class="note">Отметим, что шлюз использует максимально «узкий» широковещательный адрес для отклика (передача отклика по адресу 36.255.255.255 приведет к рассылке отклика во множество подсетей в дополнение к той, которой он предназначен). Но даже в этом случае излишнее использование широковещания приведет к неоправданному росту широковещательной нагрузки на все хосты подсети, поэтому рекомендуется использовать «анонимный» адрес отправителя запросов как можно реже.</p><p>Если широковещание не разрешено, мы предполагаем, что хост имеет «встроенную» информацию о соседних шлюзах. Таким образом, 36.40.0.123 может передать дейтаграмму:</p><pre>Source address:          36.40.0.123
Destination address:     36.40.0.62
Protocol:                ICMP = 1
Type:                    Address Format Request = A1
Code:                    0</pre><p>36.40.0.62 следует отвечать на эту дейтаграмму, как в предыдущем случае.</p><h2>Благодарности</h2><p>Эти предложения являются результатом обсуждения с некоторыми людьми. В частности, J. Noel Chiappa, Chris Kent, и Tim Mann внесли важные предложения.</p><h2>Литература</h2><table itemprop="references"><tr><td>[1]</td><td>D.R. Boggs, J.F. Shoch, E.A. Taft, and R.M. Metcalfe. «Pup: An Internetwork Architecture». IEEE Transactions on Communications COM-28, 4, pp612-624, Апрель 1980.</td></tr><tr><td>[RFC814]</td><td>David D. Clark. Names, Addresses, Ports, and Routes. RFC-814, MIT-LCS, Июль 1982.</td></tr><tr><td>[3]</td><td>Yogan K. Dalal and Robert M. Metcalfe. «Reverse Path Forwarding of Broadcast Packets». Comm. ACM 21, 12, pp1040-1048, Декабрь 1978.</td></tr><tr><td>[RFC903]</td><td>Finlayson, Mann, Mogul, и Theimer, <a href="../903.rfc" title="RFC 903 - Протокол RARP">«Протокол RARP», RFC 903</a>, Июнь 1984.</td></tr><tr><td>[5]</td><td>R.M. Metcalfe and D.R. Boggs. «Ethernet: Distributed Packet Switching for Local Computer Networks». Comm. ACM 19, 7, pp395-404, Июль 1976. Also CSL-75-7, Xerox Palo Alto Research Center, reprinted in CSL-80-2.</td></tr><tr><td>[RFC919]</td><td>Jeffrey Mogul, <a href="../919.rfc" title="RFC 919 - Широковещательная рассылка дейтаграмм IP">«Широковещательная рассылка дейтаграмм IP», RFC 919</a>, Октябрь 1984.</td></tr><tr><td>[RFC826]</td><td>David C. Plummer, <a href="../826.rfc" title="RFC 826 - Протокол преобразования адресов Ethernet (ARP)">«Протокол преобразования адресов Ethernet (ARP)», RFC 826</a>, Ноябрь 1982.</td></tr><tr><td>[RFC791]</td><td>J. Postel, <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">«Протокол IP (Internet Protocol)», RFC 791</a>, Сентябрь 1981.</td></tr><tr><td>[RFC792]</td><td>J. Postel, <a href="../792.rfc" title="RFC 792 - Протокол ICMP">«Протокол ICMP», RFC 792</a>, Сентябрь 1981.</td></tr></table></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 917 - Подсети Internet",disqus_identifier="917.rfc",disqus_url="http://rfc2.ru/917.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>