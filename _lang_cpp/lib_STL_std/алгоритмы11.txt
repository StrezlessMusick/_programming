=== операции, не меняющие последовательность ===
--- Min/max ---
1      const T&	min		const T&	const T&	??Comp??	возвращает наименьший
1	T	min		initializer_list<T>		??Comp??	возвращает наименьший
1      const T&	max		const T&	const T&	??Comp??	возвращает наибольший
1	T	max		initializer_list<T>		??Comp??	возвращает наибольший
1+ pair<cT&,cT&>minmax		const T&	const T&	??Comp??	возвращает наименьший и наибольший элементы
1+ pair<cT&,cT&>minmax		initializer_list<T>		??Comp??	возвращает наименьший и наибольший элементы
6	forw	min_element	[forw,forw),			??Comp??	возвращает наименьший элемент в диапозоне
6	forw	max_element	[forw,forw),			??Comp??	возвращает наибольший элемент в диапозоне
? pair<forw,forw> minmax_element[forw,forw),			??Comp??	возвращает наименьший и наибольший элемент в диапозоне
--- линейные ---
5+	bool	all_of		[in,in), 			UnaryPred	true, если удовлетворяют ВСЕ элементы
5+	bool	any_of		[in,in), 			UnaryPred	true, если удовлетворяют ЛЮБОЙ элемент
5+	bool	none_of		[in,in), 			UnaryPred	true, если НЕ удовлетворяют ВСЕ элементы
5	Func	for_each	[in,in), 			Func		применяет функцию
5	in	find		[in,in), 			value		находит значение в диапозоне
5	in	find_if		[in,in), 			UnaryPred	находит элемент в диапозоне
5+	in	find_if_not	[in,in), 			UnaryPred	находит элемент в диапозоне (отрицательное условие)
6	diff_t	count		[in,in), 			value		находит появляющееся значение в диапозоне
6	diff_t	count_if	[in,in), 			UnaryPred	возвращает число элементов в диапозоне, удовлетворяющие условию
11	forw	search_n	[forw,forw),	count,	val,	??BinaryPred??	находит диапозон элементов
8	forw1	find_first_of	[forw1,forw1),	[forw2,forw2),	??BinaryPred??	находит элемент из множества в диапозоне
7+	forw	is_sorted_until	[forw,forw),			??Comp??	находит первый неотсортированный элемент
8+	bool	is_sorted	[forw,forw),			??Comp??	проверяет, отсортирован ли диапозон
8+	bool	is_partitioned	[in,in),			UnaryPred	проверяет диапозон, разбит ли он на 2
3 pair<in1,in2>	mismatch	[in1,in1),	[in2,		??BinaryPred??	возвращает вервую позицию, кде два диапозона различаются
6	bool	equal		[in1,in1),	[in2,		??BinaryPred??	проверяет, эквивалентны ли элементы из двух диапозонов
7	bool	lexicographical_compare	[in1,in1), [in2,in2),	??BinaryPred??	лексикографическое меньше-чем сравнение
--- нелинейные ---
10	forw	adjacent_find	[forw,forw),			??BinaryPred??	находит одинаковые соседние элементы в диапозоне
13	forw1	search		[forw1,forw1),	[forw2,forw2),	??BinaryPred??	находит диапозон подпоследовательности
14	forw1	find_end	[forw1,forw1),	[forw2,forw2),	??BinaryPred??	находит последнюю подпоследовательность в диапозоне
11+	bool	is_permutation	[in1,in1),	[in2,		??BinaryPred??	проверяет, является ли диапозон перестановкой другого диапозона
--- бинарный поиск (операции над частично/отсортированными диапозонами) ---
10+	forw	partition_point	[forw,forw),			UnaryPred	возвращает точку разбиения
13	forw	lower_bound	[forw,forw),			val, ??Comp??	возвращает итератор на нижнюю границу
11	forw	upper_bound	[forw,forw),			val, ??Comp??	возвращает итератор на верхнюю границу
2 pair<forw,forw> equal_range	[forw,forw),			val, ??Comp??	возвращает поддиапозон равных элементов
2	bool	binary_search	[forw,forw),			val, ??Comp??	проверяет, присутствет ли значение в отсортированной последовательности
======================================================================================
=== Операции, модифицирующие последовательность, не меняющие порядок элементов ===
--- атомарные ---
1	void	swap		T&a,		T&b				обменивает значения двух объектов
1	void	iter_swap	forw1		forw2				обменивает значения объектов, указываемых двумя итераторами
--- линейные ---
5	out	copy		[in,in),	[out				копирует диапозон элементов
6+	out	copy_n		[in,	n,	[out				копирует элементы
8+	out	copy_if		[in,in),	[out,		UnaryPred	копирует определенные элементы последовательности
2	bid2	copy_backward	[bid1,bid1),		bid2)			копирует диапозон элементов в обратном порядке
5+	out	move		[in,in),	[out				сдвигает диапозон элементов
2+	bid2	move_backward	[bid1,bid1),		bid2)			сдвигает диапозон элементов назад
1+	void	swap		T(&a)[N],	T(&b)[N]			
5	forw2	swap_ranges	[forw1,forw1),	[forw2				обменивает значения двух диапозонов
4	void	replace		[forw,forw),		old_value, new_value	заменяет значение в дипозоне
4	void	replace_if	[forw,forw),		UnaryPred, new_value	заменяет значения в дипозоне
5	out	replace_copy	[in,in),	[out,	old_value, new_value	копирует диапозон, заменяя значение
5	out	replace_copy_if	[in,in),	[out,	UnaryPred, new_value	копирует диапозон, заменяя значение
4	void	fill		[forw,forw),			value		заполняет диапозон значением
5	out	fill_n		[out,	n,			value		заполняет последовательность значением
4	void	generate	[forw,forw),			Generator	генерирует значения для диапозона при помощи функции
4	out	generate_n	[out,	n,			Generator	генерирует значения для последовательности при помощи функции
5	out	transform	[in1,in1),	[out.		UnaryOp		трансформирует диапозон
5	out	transform 	[in1,in1),[in2,	[out,		BinaryOp	
--- линейные, с изменением порядка ---
4	void	reverse		[bid,bid)					обращает диапозон
6	out	reverse_copy	[bid,bid),		[out			копирует диапозон в обратном порядке
7	void	rotate		[forw,<forw>,forw)				"вращает" влево элементы в диапозоне
2	out	rotate_copy	[forw,<forw>,forw)	[out			копирет диапозон, "вращая" его
--- линейные с удалением ---
9	forw	remove			[forw,forw),			value		удаляет значение из диапозона
9	forw	remove_if		[forw,forw),			UnaryPred	удаляет элементы из диапозона
8	out	remove_copy		[in,in),		[out,	value		копирует диапозон, удаляя значение в копии
8	out	remove_copy_if		[in,in),		[out,	UnaryPred	копирует диапозон, удаляя значение в копии
 x		erase			[forw,forw),cont*		value		
 x		erase_if		[forw,forw),cont*		UnaryPred	
 x		remove_separate		[forw,forw),		[out,	value		копирует диапозон, удаляя значение в копии и в исходном диапозоне
 x		remove_separate_if	[forw,forw),		[out,	UnaryPred	
 x		erase_separate  	[forw,forw),cont*,	[out,	value		
 x		erase_separate_if  	[forw,forw),cont*,	[out,	UnaryPred	
8	forw	unique			[forw,forw),			??BinaryPred??	дубликаты оставляет в единственном экземпляре
 x		unique_erase		[forw,forw),cont*,		??BinaryPred??	
8	out	unique_copy		[in,in),		[out,	??BinaryPred??	копирует диапозон, удаляя дубликаты
 x		unique_separate		[forw,forw),cont*,	[out,	??BinaryPred??	
 x		totalunique		[forw,forw),			??BinaryPred??	удаляет дубликаты
 x		totalunique_erase	[forw,forw),cont*,		??BinaryPred??	
 x		totalunique_copy	[in,in),		[out,	??BinaryPred??	
 x		totalunique_separate	[forw,forw),cont*,	[out,	??BinaryPred??	
 x		antiunique		[forw,forw),			??BinaryPred??	оставляет дубликаты
 x		antiunique_erase	[forw,forw),cont*,		??BinaryPred??	
 x		antiunique_copy		[in,in),		[out,	??BinaryPred??	
 x		antiunique_separate	[forw,forw),cont*,	[out,	??BinaryPred??	
--- слияние (операции над отсортированными диапозонами) ---
5	out	merge			[in1,in1), [in2,in2),	[out,	??Comp??	слить отсортированные диапозоны
?	void	inplace_merge		[bid,<bid>,bid),		??Comp??	слить строго отсортированные диапозоны
6	bool	includes		[in1,in1),	[in2,in2),	??Comp??	проверяет, включает ли отсортированый диапозон другой отсортированный диапозон
9	out	set_union		[in1,in1), [in2,in2),	[out,	??Comp??	объединяет два отсортированных диапозона
10	out	set_intersection	[in1,in1), [in2,in2),	[out,	??Comp??	пересекает два отсортированных диапозона
7	out	set_difference		[in1,in1), [in2,in2),	[out,	??Comp??	вычитает два отсортированных диапозона
8	out	set_symmetric_difference[in1,in1), [in2,in2),	[out,	??Comp??	симметрично вычитает два отсортированных диапозона
======================================================================================
=== Операции, меняющие порядок элементов ===
--- разбиения ---
13	forw	partition		[forw,forw),			UnaryPred	разбивает диапозон на 2
?	bid	stable_partition	[bid,bid),			UnaryPred	разбивает диапозон на 2, соблюдая порядок
12+ pair<out_t,out_f> partition_copy	[in,in),	[out_t,	[out_f,	UnaryPred	разбивает диапозон на 2
--- сортировка ---
?	void	sort			[RA,RA),			??Comp??	сортирует элементы в диапозоне
?	void	stable_sort		[RA,RA),			??Comp??	сортирует элементы в диапозоне не меняя порядок эквивалентных
?	void	partial_sort		[RA,<RA>,RA),			??Comp??	частично сортирует элементы в диапозоне
?	RA	partial_sort_copy 	[in,in),	[RA,RA),	??Comp??	копирует частично отсортированный диапозон
?	void	nth_element		[RA,<RA>,RA),			??Comp??	сортирует элементы в диапозоне
--- разное ---
5	void	random_shuffle		[RA,RA),			??Gen??		случайно перераспределяет элементы в диапозоне	
4+	void	shuffle			[RA,RA),			URNG		случайно перераспределяет элементы в диапозоне используя генератор	
?	bool 	next_permutation	[bid,bid),			??Compare??	преобразует диапозон к следующей перестановке
?	bool 	prev_permutation	[bid,bid),			??Compare??	преобразует диапозон к предыдущей перестановке
--- куча(Heap) ---
?	void	push_heap		[RA,RA)				??Comp??	засовывает элемент в диапозон-кучу
?	void	pop_heap		[RA,RA)				??Comp??	достает элемент из диапозона-кучи
?	void	make_heap		[RA,RA)				??Comp??	создает кучу на диапозоне
?	void	sort_heap		[RA,RA)				??Comp??	сортирует элементы кучи
?+	bool	is_heap			[RA,RA)				??Comp??	проверяет диапозон, является ли он кучей
?+	RA	is_heap_until		[RA,RA)				??Comp??	находит первый элемент не подходящий в порядок кучи
