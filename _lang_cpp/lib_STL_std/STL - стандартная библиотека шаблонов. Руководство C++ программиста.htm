<html><head>
	<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
	<meta http-equiv="Content-Language" content="ru">
	<title>STL - стандартная библиотека шаблонов. Руководство C++ программиста.</title>
    <meta name="keywords" content="STL, C++, программирование, стандартная библиотека шаблонов">
    <link rel="stylesheet" type="text/css" href="STL%20-%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2.%20%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20C++%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%B0_files/main.css">
	<style>
<!--
li           { font-size: 12px; font-family: Arial }
.lem_sub_para2 { font-size: 12pt; color: #000080; text-align: center; background-color: #C6EFFD }
-->
</style>
</head>

<body>

<img src="STL%20-%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2.%20%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20C++%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%B0_files/sdk.gif" height="32" width="32" align="left" border="0">
<h1>Руководство по стандартной библиотеке шаблонов (STL)</h1>
<p class="menu_bar">
&nbsp;&nbsp;&nbsp;<a title="Титульная страница проекта" href="http://www.solarix.ru/index-ru.shtml">Главная</a>
&nbsp;&nbsp;&nbsp;<a title="Карта сайта для быстрой навигации" href="http://www.solarix.ru/map/site-map.shtml">Карта</a>
&nbsp;&nbsp;&nbsp;<a title="Стандартная библиотека C++" href="http://www.solarix.ru/for_developers/cpp/stl/stl.shtml">STL</a>
&nbsp;&nbsp;&nbsp;<a title="Библиотека BOOST C++" href="http://www.solarix.ru/for_developers/cpp/boost/boost-library.shtml">BOOST C++</a>
&nbsp;&nbsp;&nbsp;<a title="Библиотека Loki" href="http://www.solarix.ru/for_developers/cpp/loki/loki-library.shtml">Loki</a>
&nbsp;&nbsp;&nbsp;<a title="Примеры программ и алгоритмов" href="http://www.solarix.ru/for_developers/cpp/cpp-programming.shtml">Примеры</a>
&nbsp;&nbsp;&nbsp;<a title="Примеры метапрограмм и метаалгоритмов" href="http://www.solarix.ru/for_developers/cpp/cpp-metaprogramming.shtml">Метапрограммирование</a>

</p>
	

<div style="margin-left:2em"><div style="margin-left:2em">
</div><a href="#IDACRAEJ"><b>Введение</b></a><br><div style="margin-left:2em">
</div><a href="#IDASRAEJ"><b>Структура библиотеки</b></a><br><div style="margin-left:2em">
</div><a href="#IDAKWAEJ"><b>Требования</b></a><br><div style="margin-left:2em">
</div><a href="#IDA4WAEJ"><b>Основные компоненты</b></a><br><div style="margin-left:2em"><a href="#IDADXAEJ">Операторы (Operators)</a><br><a href="#IDASJBEJ">Пара (Pair)</a><br></div><a href="#IDAPMBEJ"><b>Итераторы</b></a><br><div style="margin-left:2em"><a href="#IDASSBEJ">Итераторы ввода (Input iterators)</a><br><a href="#IDANZBEJ">Итераторы вывода (Output iterators)</a><br><a href="#IDAY2BEJ">Последовательные итераторы (Forward iterators)</a><br><a href="#IDAEDCEJ">Двунаправленные итераторы (Bidirectional iterators)</a><br><a href="#IDAKFCEJ">Итераторы произвольного доступа (Random access iterators)</a><br><a href="#IDAHLCEJ">Теги итераторов (Iterator tags)</a><br><a href="#IDA50CEJ">Операции с итераторами (Iterator operations)</a><br></div><a href="#IDAA3CEJ"><b>Функциональные объекты</b></a><br><div style="margin-left:2em"><a href="#IDAL4CEJ">Базовые классы (Base)</a><br><a href="#IDAP5CEJ">Арифметические операции (Arithmetic operations)</a><br><a href="#IDAY0DEJ">Сравнения (Comparisons)</a>
<br><a href="#IDAM4DEJ">Логические операции (Logical operations)</a><br></div><a href="#IDAKACUJ"><b>Распределители</b></a><br><div style="margin-left:2em"><a href="#IDAVACUJ">Требования распределителей (Allocator requirements)</a><br><a href="#IDAVRDUJ">Распределитель по умолчанию (The default allocator)</a><br></div><a href="#IDAATDUJ"><b>Контейнеры</b></a><br><div style="margin-left:2em"><a href="#IDAMOFUJ">Последовательности (Sequences)</a><br><a href="#IDALW2AG">Ассоциативные контейнеры (Associative containers)</a><br></div><a href="#IDA1C4AG"><b>Итераторы потоков</b></a><br><div style="margin-left:2em"><a href="#IDAQD4AG">Итератор входного потока (Istream Iterator)</a><br><a href="#IDAOG4AG">Итератор выходного потока (Ostream Iterator)</a><br></div><a href="#IDAII4AG"><b>Алгоритмы</b></a><br><div style="margin-left:2em"><a href="#IDAUK4AG">Не меняющие последовательность операции (Non-mutating sequence operations)</a><br><a href="#IDAXT4AG">Меняющие последовательность операции (Mutating sequence operations)</a><br><a href="#IDAGL5AG">Операции сортировки и отношения (Sorting and related operations)</a><br><a href="#IDATJABG">Обобщённые численные операции (Generalized numeric operations)</a><br></div><a href="#IDAUPABG"><b>Адаптеры</b></a><br><div style="margin-left:2em"><a href="#IDA1PABG">Адаптеры контейнеров (Container adaptors)</a><br><a href="#IDAIZABG">Адаптеры итераторов (Iterator adaptors)</a><br><a href="#IDAEIBBG">Адаптеры функций (Function adaptors)</a><br></div><a href="#IDAWQBBG"><b>Примитивы управления памятью (Memory Handling Primitives)</b></a><br><div style="margin-left:2em">
</div>&nbsp;<div style="margin-left:2em">
</div>
</div>
<h2><a name="IDA1QAEJ"></a></h2>
<h2 class="lem_para">Введение<a name="IDACRAEJ"></a></h2>
<p class="normal_text">Стандартная Библиотека Шаблонов предоставляет набор хорошо
сконструированных и согласованно работающих вместе обобщённых компонентов
<var>C++</var>. Особая забота была проявлена для обеспечения того, чтобы все
шаблонные алгоритмы работали не только со структурами данных в библиотеке, но
также и с встроенными структурами данных <var style="font-style: normal">C++</var>. Например, все алгоритмы
работают с обычными указателями. Ортогональный проект библиотеки позволяет
программистам использовать библиотечные структуры данных со своими собственными
алгоритмами, а библиотечные алгоритмы - со своими собственными структурами
данных. Хорошо определённые семантические требования и требования сложности
гарантируют, что компонент пользователя будет работать с библиотекой и что он 
будет работать эффективно. Эта гибкость обеспечивает широкую применимость
библиотеки.</p>
<p class="normal_text">Другое важное соображение - эффективность. 
<var style="font-style: normal">C++</var> успешен, потому
что он объединяет выразительную мощность с эффективностью. Много усилий было 
потрачено, чтобы проверить, что каждый шаблонный компонент в библиотеке имеет 
обобщённую реализацию, которая имеет эффективность выполнения с разницей в 
пределах нескольких процентов от эффективности соответствующей программы ручной 
кодировки.</p>
<h2 class="lem_para">Структура библиотеки<a name="IDASRAEJ"></a></h2>
<p>Библиотека содержит пять основных видов компонентов:</p>
<ul>
	<li><b>алгоритм</b> (<i>algorithm</i>): определяет вычислительную процедуру.</li>
	<li><b>контейнер</b> (<i>container</i>): управляет набором объектов в памяти.</li>
	<li><b>итератор</b> (<i>iterator</i>): обеспечивает для алгоритма средство доступа к содержимому контейнера.</li>
	<li><b>функциональный объект</b> (<i>function object</i>): инкапсулирует функцию в объекте для использования другими компонентами.</li>
	<li><b>адаптер</b> (<i>adaptor</i>): адаптирует компонент для обеспечения различного интерфейса.</li>
</ul>
<p class="normal_text">Разделение позволяет нам уменьшить количество компонентов. 
Например, вместо написания функции поиска элемента для каждого вида контейнера 
мы обеспечиваем единственную версию, которая работает с каждым из них, пока 
удовлетворяется основной набор требований.</p>
<p class="normal_text">Описание разъясняет структуру библиотеки. Если программные 
компоненты сведены в таблицу как трёхмерный массив, где одно измерение 
представляет различные типы данных (например, <span class="class_name">int</span>, 
<span class="class_name">double</span>), второе измерение 
представляет различные контейнеры (например, вектор, связный список, файл), а 
третье измерение представляет различные алгоритмы с контейнерами (например, 
поиск, сортировка, перемещение по кругу) , если <var>i, j</var> и <var>k</var> - 
размеры измерений, тогда должно быть разработано <var>i* j *k</var> различных 
версий кода. При использовании шаблонных функций, которые берут параметрами типы 
данных, нам нужно только <var>j * k</var> версий. Далее, если заставим наши 
алгоритмы работать с различными контейнерами, то нам нужно просто <var>j+k</var> 
версий. Это значительно упрощает разработку программ, а также позволяет очень 
гибким способом использовать компоненты в библиотеке вместе с определяемыми 
пользователем компонентами. Пользователь может легко определить 
специализированный контейнерный класс и использовать для него библиотечную 
функцию сортировки. Для сортировки пользователь может выбрать какую-то другую 
функцию сравнения либо через обычный указатель на сравнивающую функцию, либо 
через функциональный объект (объект, для которого определён 
<var>operator()</var>), который сравнивает. Если пользователю необходимо 
выполнить передвижение через контейнер в обратном направлении, то используется 
адаптер <var>reverse_iterator</var>.</p>
<p class="normal_text">Библиотека расширяет основные средства C++ последовательным способом, так 
что программисту на C/C++ легко начать пользоваться библиотекой. Например, 
библиотека содержит шаблонную функцию <span class="class_name"> 
<var style="font-style: normal">merge</var></span> (слияние). Когда 
пользователю нужно два массива <var>a</var> и <var>b</var> объединить в 
<var>с</var>, то это может быть выполнено так:</p>

<table class="code" width="98%"><tbody><tr><td class="code_snippet">
int a[1000];<br>
int b[2000];<br>
int c[3000];<br>
&nbsp;... <br>
merge (a, a+1000, b, b+2000, c);
</td></tr></tbody></table>

<p class="normal_text">Когда пользователь хочет объединить вектор и список (оба - шаблонные 
классы в библиотеке) и поместить результат в заново распределённую 
неинициализированную память, то это может быть выполнено так:</p>

<div id="IDATTAEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre>vector&lt;Employee&gt; a;
list&lt;Employee&gt; b;
...
Employee* с = allocate(a.size() + b.size(), (Employee*) 0);
merge(a.begin(), a.end(), b.begin(), b.end(),
      raw_storage_iterator &lt;Employee*, Employee&gt; (c));
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text">где <var>begin()</var> и <var>end()</var> - функции-члены контейнеров, 
которые возвращают правильные типы итераторов или указателе-подобных объектов, 
позволяющие <var>merge</var> выполнить задание, а 
<var>raw_storage_iterator</var> - адаптер, который позволяет алгоритмам помещать 
результаты непосредственно в неинициализированную память, вызывая 
соответствующий конструктор копирования.</p>
<p class="normal_text">многих случаях полезно перемещаться через потоки ввода-вывода таким же 
образом, как через обычные структуры данных. Например, если мы хотим объединить 
две структуры данных и затем сохранить их в файле, было бы хорошо избежать 
создания вспомогательной структуры данных для хранения результата, а поместить 
результат непосредственно в соответствующий файл. Библиотека обеспечивает и 
<var>istream_iterator</var>, и <var>ostream_iterator</var> шаблонные классы, 
чтобы многие из библиотечных алгоритмов могли работать с потоками ввода-вывода, 
которые представляют однородные блоки данных. Далее приводится программа, 
которая читает файл, состоящий из целых чисел, из стандартного ввода, удаляя все 
числа, делящиеся на параметр команды, и записывает результат в стандартный 
вывод:</p>

<div id="IDAFUAEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre>main((<span class="KEYWORD">int</span> argc, <span class="KEYWORD">char</span>** argv) { 
    <span class="KEYWORD">if</span>(argc != 2)  <span class="KEYWORD">throw</span>(<span class="STRING">"usage: remove_if_divides integer\n "</span>);
    remove_copy_if(istream_iterator&lt;int&gt;(cin), istream_iterator&lt;int&gt;(), 
        ostream_iterator&lt;int&gt;(cout, <span class="STRING">"\n"</span>), 
        not1(bind2nd (modulus&lt;int&gt;(), atoi(argv[1]))));
}
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text">работа выполняется алгоритмом <var>remove_copy_if</var>, который 
читает целые числа одно за другим, пока итератор ввода не становится равным 
<i>end-of-stream</i> (<i>конец-потока</i>) итератору, который создаётся 
конструктором без параметров. (Вообще все алгоритмы работают способом "отсюда 
досюда", используя два итератора, которые показывают начало и конец ввода.) 
Потом <var>remove_copy_if</var> записывает целые числа, которые выдерживают 
проверку, в выходной поток через итератор вывода, который связан с 
<var>cout</var>. В качестве предиката <var>remove_copy_if</var> использует 
функциональный объект, созданный из функционального объекта 
<var>modulus&lt;int&gt;</var>, который берёт <var>i</var> и <var>j</var> и 
возвращает <var>i % j</var> как бинарный предикат, и превращает в унарный 
предикат, используя <var>bind2nd</var>, чтобы связать второй параметр с 
параметром командной строки <var>atoi(argv[1])</var>. Потом отрицание этого 
унарного предиката получается с помощью адаптера функции <var>not1</var>.</p>
<p class="normal_text">более реалистичный пример - фильтрующая программа, которая 
берёт файл и беспорядочно перетасовывает его строки.</p>
<div id="IDARVAEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre>main(<span class="KEYWORD">int</span> argc, <span class="KEYWORD">char</span>**) {
    <span class="KEYWORD">if</span>(argc != <span class="NUMBER">1</span>) <span class="KEYWORD">throw</span>(<span class="STRING">"usage: shuffle\n"</span>);
    vector&lt;string&gt; v;
    copy(istream_iterator&lt;string&gt;(cin),istream_iterator&lt;string&gt;(),
        inserter(v, v.end()));
    random_shuffle(v.begin(), v.end());
    copy(v.begin(), v.end(), ostream_iterator&lt;string&gt;(cout));
}</pre>
</td></tr></tbody></table>
</div>
<p class="normal_text">этом примере <var>copy</var> перемещает строки из стандартного ввода в 
вектор, но так как вектор предварительно не размещён в памяти, используется 
итератор вставки, чтобы вставить в вектор строки одну за другой. (Эта методика 
позволяет всем функциям копирования работать в обычном режиме замены также, как 
в режиме вставки.) Потом <var>random_shuffle</var> перетасовывает вектор, а 
другой вызов <var>copy</var> копирует его в поток <var>cout</var>.
</p>
<h2 class="lem_para">Требования<a name="IDAKWAEJ"></a></h2>
<p class="normal_text">Для гарантии совместной работы различные компоненты библиотеки должны 
удовлетворять некоторым основным требованиям. Требования должны быть общими, 
насколько это возможно, так что вместо высказывания "класс <var>X</var> должен 
определить функцию-член <var>operator++()</var>", мы говорим "для любого объекта 
<var>x</var> класса <var>X</var> определён <var>++x</var> ". (Не определено, 
является ли оператор членом или глобальной функцией.) Требования установлены в 
терминах чётких выражений, которые определяют допустимые условия типов, 
удовлетворяющих требованиям. Для каждого набора требований имеется таблица, 
которая определяет начальный набор допустимых выражений и их семантику. Любой 
обобщённый алгоритм, который использует требования, должен быть написан в 
терминах допустимых выражений для своих формальных параметров.</p>
<p class="normal_text">Если требуется, чтобы была операция линейного времени сложности, это 
значит - не хуже, чем линейного времени, и операция постоянного времени 
удовлетворяет требованию.</p>
<p class="normal_text">В некоторых случаях мы представили семантические требования, использующие 
код C++. Такой код предназначен как спецификация эквивалентности одной 
конструкции другой, не обязательно как способ, которым конструкция должна быть 
реализована (хотя в некоторых случаях данный код, однозначно, является 
оптимальной реализацией).</p>
<h3 class="lem_sub_para2">Основные компоненты<a name="IDA4WAEJ"></a></h3>
<p>Этот раздел содержит некоторые основные шаблонные функции и классы, 
которые используются в остальной части библиотеки.</p>

<h3 class="lem_sub_para2">Операторы (Operators)<a name="IDADXAEJ"></a></h3>
<p>Чтобы избежать избыточных определений <var>operator!=</var> из 
<var>operator==</var> и <var>operator&gt;</var>, <var>&lt;=</var>, 
<var>&gt;=</var> из <var>operator&lt;</var>, библиотека обеспечивает следующее: 
</p>

<div id="IDAUXAEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Tl, <span class="KEYWORD">class</span> T2&gt;
<span class="KEYWORD">inline bool operator</span>!=(<span class="KEYWORD">const</span> T1&amp; x, <span class="KEYWORD">const</span> T2&amp; y) { 
    <span class="KEYWORD">return</span> !(x == y);
}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Tl, <span class="KEYWORD">class</span> T2&gt;
<span class="KEYWORD">inline bool operator</span>&gt;(<span class="KEYWORD">const</span> T1&amp; x, <span class="KEYWORD">const</span> T2&amp; y) {
    <span class="KEYWORD">return</span> y &lt; x;
}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Tl, <span class="KEYWORD">class</span> T2&gt;
<span class="KEYWORD">inline bool operator</span>&lt;=(<span class="KEYWORD">const</span> T1&amp; x, <span class="KEYWORD">const</span> T2&amp; y) { 
    <span class="KEYWORD">return</span> !(y &lt; x);
}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Tl, <span class="KEYWORD">class</span> T2&gt;
<span class="KEYWORD">inline bool operator</span>&gt;=(<span class="KEYWORD">const</span> T1&amp; x, <span class="KEYWORD">const</span> T2&amp; y) { 
    <span class="KEYWORD">return</span> !(x &lt; y);
}
</pre>
</td></tr></tbody></table>
</div>


<h3 class="lem_sub_para2">Пара (Pair)<a name="IDASJBEJ"></a></h3>
<p>Библиотека включает шаблоны для разнородных пар значений.</p>

<div id="IDAXJBEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T1, <span class="KEYWORD">class</span> T2&gt;
<span class="KEYWORD">struct</span> pair {
    T1 first;
    T2 second;
    pair() {}
    pair(<span class="KEYWORD">const</span> T1&amp; x, <span class="KEYWORD">const</span> T2&amp; y) : first(x), second(y) {} 
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T1, <span class="KEYWORD">class</span> T2&gt;
<span class="KEYWORD">inline bool operator</span>==(<span class="KEYWORD">const</span> pair&lt;Tl,T2&gt;&amp; x, <span class="KEYWORD">const</span> pair&lt;Tl,T2&gt;&amp; y) { 
    <span class="KEYWORD">return</span> x.first == y.first &amp;&amp; x.second == y.second;
}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T1, <span class="KEYWORD">class</span> T2&gt; 
<span class="KEYWORD">inline bool operator</span>&lt;(<span class="KEYWORD">const</span> pair&lt;Tl,T2&gt;&amp; x, <span class="KEYWORD">const</span> pair&lt;Tl,T2&gt;&amp; y) {
    <span class="KEYWORD">return</span> x.first &lt; y.first 
        || (!(y.first &lt; x.first) &amp;&amp; x.second &lt; y.second);
}
</pre>
</td></tr></tbody></table>
</div>

<p>Библиотека обеспечивает соответствующую шаблонную функцию 
<var>make_pair</var>, чтобы упростить конструкцию пар. Вместо выражения, 
например:</p>

<div id="IDAFLBEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">return</span> pair&lt;<span class="KEYWORD">int</span>, <span class="KEYWORD">double</span>&gt;(<span class="NUMBER">5</span>, <span class="NUMBER">3.1415926</span>); <span class="COMMENT">// явные типы,</span>
</pre>
</td></tr></tbody></table>
</div>

<p>можно написать</p>

<div id="IDAVLBEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">return</span> make_pair(<span class="NUMBER">5</span>, <span class="NUMBER">3.1415926</span>); <span class="COMMENT">// типы выводятся.</span>

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Tl, <span class="KEYWORD">class</span> T2&gt;
<span class="KEYWORD">inline</span> pair&lt;Tl,T2&gt; make_pair(<span class="KEYWORD">const</span> T1&amp; x, <span class="KEYWORD">const</span> T2&amp; y) { 
    <span class="KEYWORD">return</span> pair&lt;Tl,T2&gt;(x, y);
}
</pre>
</td></tr></tbody></table>
</div>


<h2 class="lem_sub_para2"><a name="iterator"></a>Итераторы<a name="IDAPMBEJ"></a></h2>
<p class="normal_text">Итераторы - это обобщение указателей, которые позволяют программисту 
работать с различными структурами данных (контейнерами) единообразным способом. 
Чтобы создать шаблонные алгоритмы, которые правильно и эффективно работают с 
различными типами структур данных, нам нужно формализовать не только интерфейсы, 
но также семантику и предположения сложности итераторов. Итераторы - это 
объекты, которые имеют <var>operator*</var>, возвращающий значение некоторого 
класса или встроенного типа <var>T</var>, называемого <i>значимым типом</i> 
(<i>value type</i>) итератора. Для каждого типа итератора <var>X</var>, для 
которого определено равенство, имеется соответствующий знаковый целочисленный 
тип, называемый <i>типом расстояния</i> (<i>distanсe type</i>) итератора.</p>
<p class="normal_text">Так как итераторы - обобщение указателей, их семантика - обобщение 
семантики указателей в C++. Это гарантирует, что каждая шаблонная функция, 
которая использует итераторы, работает с обычными указателями. Есть пять 
категорий итераторов в зависимости от операций, определённых для них: 
<i>ввода</i> (<i>input iterators</i>), <i>вывода</i> (<i>output iterators</i>), 
<i>последовательные</i> (<i>forward iterators</i>), <i>двунаправленные</i> 
(<i>bidirectional iterators</i>) и <i>произвольного доступа</i> (<i>random 
access iterators</i>.) Последовательные итераторы удовлетворяют всем требованиям 
итераторов ввода и вывода и могут использоваться всякий раз, когда определяется 
тот или другой вид. Двунаправленные итераторы удовлетворяют всем требованиям 
последовательных итераторов и могут использоваться всякий раз, когда 
определяется последовательный итератор. Итераторы произвольного доступа 
удовлетворяют всем требованиям двунаправленных итераторов и могут использоваться 
всякий раз, когда определяется двунаправленный итератор. Имеется дополнительный 
атрибут, который могли быть иметь последовательные, двунаправленные и 
произвольного доступа итераторы, то есть они могут быть <i>модифицируемые</i> 
(<i>mutable</i>) или <i>постоянные</i> (<i>constant</i>) в зависимости от того, 
ведёт ли себя результат <var>operator*</var> как ссылка или как ссылка на 
константу. Постоянные итераторы не удовлетворяют требованиям итераторов вывода. 
</p>

<table border="0" cellpadding="5" cellspacing="2">
<caption>Таблица 1. Отношения среди категорий итераторов</caption>
<tbody><tr>
<td rowspan="2">Произвольного доступа</td>
<td rowspan="2" nowrap="nowrap">--&gt;</td>
<td rowspan="2">Двунаправленные</td>
<td rowspan="2" nowrap="nowrap">--&gt;</td>
<td rowspan="2">Последовательные</td>
<td rowspan="2" nowrap="nowrap">---</td>
<td nowrap="nowrap">--&gt;</td>
<td>Ввода</td>
</tr>
<tr>
<td nowrap="nowrap">--&gt;</td>
<td>Вывода</td>
</tr>
</tbody></table>

<p class="normal_text">Точно также, как обычный указатель на массив гарантирует, что имеется 
значение указателя, указывающего за последний элемент массива, так и для любого 
типа итератора имеется значение итератора, который указывает за последний 
элемент соответствующего контейнера. Эти значения называются <i>законечными</i> 
(<i>past-the-end</i>) значениями. Значения итератора, для которых 
<var>operator*</var> определён, называются <i>разыменовываемыми</i> 
(<i>dereferenceable</i>). Библиотека никогда не допускает, что законечные 
значения являются разыменовываемыми. Итераторы могут также иметь 
<i>исключительные</i> (<i>singular</i>) значения, которые не связаны ни с каким 
контейнером. Например, после объявления неинициализированного указателя 
<var>x</var> (например, <var>int* x;</var>), всегда должно предполагаться, что 
<var>x</var> имеет исключительное значение указателя. Результаты большинства 
выражений не определены для исключительных значений. Единственное исключение - 
присваивание неисключительного значения итератору, который имеет исключительное 
значение. В этом случае исключительное значение перезаписывается таким же 
образом, как любое другое значение. Разыменовываемые и законечные значения 
всегда являются неисключительными.</p>

<p class="normal_text">Итератор <var>j</var> называется <i>доступным</i> (<i>reachable</i>) из 
итератора <var>i</var>, если и только если имеется конечная последовательность 
применений <var>operator++</var> к <var>i</var>, которая делает <var>i==j</var>. 
Если <var>i</var> и <var>j</var> относятся к одному и тому же контейнеру, тогда 
или <var>j</var> доступен из <var>i</var>, или <var>i</var> доступен из 
<var>j</var>, или оба доступны (<var>i == j</var>).</p>

<p class="normal_text">Большинство алгоритмических шаблонов библиотеки, которые работают со 
структурами данных, имеют интерфейсы, которые используют диапазоны. Диапазон - 
это пара итераторов, которые указывают начало и конец вычисления. Интервал 
<var>[i,i)</var> - пустой диапазон; вообще, диапазон <var>[i,j)</var> относится 
к элементам в структуре данных, начиная с элемента, указываемого <var>i</var>, и 
до элемента, но не включая его, указываемого <var>j</var>. Диапазон 
<var>[i,j)</var> допустим, если и только если <var>j</var> доступен из 
<var>i</var>. Результат применения алгоритмов библиотеки к недопустимым 
диапазонам не определён.</p>

<p class="normal_text">Все категории итераторов требуют только те функции, которые осуществимы 
для данной категории со сложностью постоянного времени (амортизированные). 
Поэтому таблицы требований для итераторов не имеют столбца сложности.</p>

<p class="normal_text">В следующих разделах мы принимаем: <var>a</var> и <var>b</var> - значения 
<var>X</var>, <var>n</var> - значение типа расстояния <var>Distance</var>, 
<var>u, tmp</var> и <var>m</var> - идентификаторы, <var>r</var> и <var>s</var> - 
леводопустимые (lvalues) значения <var>X</var>, <var>t</var> - значение 
значимого типа <var>T</var>.</p>

<h3 class="lem_sub_para2"><a name="input_iterator"></a>Итераторы ввода (Input iterators)<a name="IDASSBEJ"></a></h3>
<p>Класс или встроенный тип <var>X</var> удовлетворяет требованиям итератора 
ввода для значимого типа <var>T</var>, если справедливы следующие выражения: 
</p>

<table bordercolorlight="#808080" bordercolordark="#808080" style="border-collapse: collapse" border="1" cellpadding="5">
<caption>Таблица 2. Требования итератора ввода</caption>
<tbody><tr>
<th>выражение</th>
<th>возвращаемый тип</th>
<th>семантика исполнения</th>
<th>утверждение/примечание состояние до/после</th>
</tr>
<tr>
<td><var>X(a)</var></td>
<td>
</td>
<td>
</td>
<td><var>X(a)</var>- копия <var>a</var>.<br>примечание: предполагается деструктор.</td>
</tr>
<tr>
<td><var>X u(a);<br>X u = a;</var></td>
<td>
</td>
<td>
</td>
<td>после: <var>u</var> - копия <var>a</var>.</td>
</tr>
<tr>
<td><var>u = a</var></td>
<td><var>X&amp;</var></td>
<td>
</td>
<td>после: <var>u</var> - копия <var>a</var>.</td>
</tr>
<tr>
<td><var>a == b</var></td>
<td>обратимый в <var>bool</var></td>
<td>
</td>
<td>если <var>a</var> - копия <var>b</var>, тогда <var>a == b</var> возвращает 
<var>true</var>. <br><var>==</var> - это отношение эквивалентности в области 
действия <var>==</var>.</td>
</tr>
<tr>
<td><var>a != b</var></td>
<td>обратимый в <var>bool</var></td>
<td><var>!(a == b)</var></td>
<td>
</td>
</tr>
<tr>
<td><var>*a</var></td>
<td>обратимый в <var>T</var></td>
<td>
</td>
<td>до: <var>a</var> - разыменовываемое.<br>если <var>a</var> - копия 
<var>b</var>, то <var>*a</var> эквивалентно <var>*b</var>.</td>
</tr>
<tr>
<td><var>++r</var></td>
<td><var>X&amp;</var></td>
<td>
</td>
<td>до: <var>r</var> - разыменовываемое.<br>после:<var>r</var> - 
разыменовываемое или <var>r</var> - законечное.</td>
</tr>
<tr>
<td><var>void r++</var></td>
<td><var>void</var></td>
<td><var>void ++r</var></td>
<td>
</td>
</tr>
<tr>
<td><var>*r++</var></td>
<td><var>Т</var></td>
<td><var>{ X tmp = r;<br>++r;<br>return tmp; }</var></td>
<td>&nbsp;</td>
</tr>
</tbody></table>

<table class="note" width="98%"><tbody><tr><td>
	<p class="normal_text"><b>ПРИМЕЧАНИЕ</b><br>Для итераторов ввода нет никаких требований на тип или 
значение <var>r++</var> кроме требования, чтобы <var>*r++</var> работал 
соответственным образом. В частности, <var>r == s</var> не подразумевает, что 
<var>++r == ++s</var>. (Равенство не гарантирует свойство замены или ссылочной 
прозрачности.) Что касается <var>++r</var>, то нет больше никаких требований на 
значения любых копий <var>r</var> за исключением того, что они могут быть 
безопасно уничтожены или присвоены. После выполнения <var>++r</var> не 
требуется, чтобы были копии (предыдущего) <var>r</var> в области <var>==</var>. 
Алгоритмы с итераторами ввода никогда не должны пытаться проходить через тот же 
самый итератор дважды. Они должны быть <i>однопроходными</i> (<i>single 
pass</i>) алгоритмами. <i>Не требуется, чтобы значимый тип <var>T</var> был 
леводопустимым типом (lvalue type)</i>. Эти алгоритмы могут использоваться с 
входными потоками как источниками входных данных через класс 
<var>istream_iterator</var>.</p></td></tr></tbody></table>


<h3 class="lem_sub_para2"><a name="output_iterator"></a>Итераторы вывода (Output iterators)<a name="IDANZBEJ"></a></h3>
<p>Класс или встроенный тип <var>X</var> удовлетворяет требованиям итератора 
вывода, если справедливы следующие выражения:</p>

<table bordercolorlight="#808080" bordercolordark="#808080" style="border-collapse: collapse" border="1" cellpadding="5">
<caption>Таблица 3. Требования итератора вывода</caption>
<tbody><tr>
<th>выражение</th>
<th>возвращаемый тип</th>
<th>семантика исполнения</th>
<th>утверждение/примечание состояние до/после</th>
</tr>
<tr>
<td><var>X(a)</var></td>
<td>
</td>
<td>
</td>
<td><var>*a = t</var> эквивалентно <var>*X(a) = t</var>. <br>примечание: предполагается деструктор.</td>
</tr>
<tr>
<td><var>X u(a);<br>X u = a;</var></td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td><var>*a = t</var></td>
<td>результат не используется</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td><var>++r</var></td>
<td><var>X&amp;</var></td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td><var>r++</var></td>
<td><var>Х</var> или <var>Х&amp;</var></td>
<td>
</td>
<td>
</td>
</tr>
</tbody></table>

<table class="note" width="98%"><tbody><tr><td><b><font size="1">ПРИМЕЧАНИЕ</font></b><font size="1"><br>Единственное допустимое использование 
<var>operator*</var> - на левой стороне выражения присваивания. <i>Присваивание 
через то же самое значение итератора происходит только однажды</i>. Алгоритмы с 
итераторами вывода никогда не должны пытаться проходить через тот же самый 
итератор дважды. Они должны быть <i>однопроходными</i> (<i>single pass</i>) 
алгоритмами. Равенство и неравенство не обязательно определены. Алгоритмы, 
которые берут итераторы вывода, могут использоваться с выходными потоками для 
помещения в них данных через класс <var>ostream_iterator</var>, также как с 
итераторами вставки и вставляющими указателями. В частности, следующие два 
условия должны соблюдаться: во-первых, через любое значение итератора должно 
выполняться присваивание до его увеличения (то есть, для итератора вывода 
<var>i</var> недопустима последовательность кода <var>i++; i++;</var>); 
во-вторых, любое значение итератора вывода может иметь только одну активную 
копию в любое данное время (например, недопустима последовательность кода <var>i 
= j; *++i = a; *j = b;</var>).</font></td></tr></tbody></table>


<h3 class="lem_sub_para2"><a name="forward_iterator"></a>Последовательные итераторы (Forward iterators)<a name="IDAY2BEJ"></a></h3>
<p>Класс или встроенный тип <var>X</var> удовлетворяет требованиям 
последовательного итератора, если справедливы следующие выражения:</p>

<table bordercolorlight="#808080" bordercolordark="#808080" style="border-collapse: collapse" border="1" cellpadding="5">
<caption>Таблица 4. Требования последовательного итератора</caption>
<tbody><tr>
<th>выражение</th>
<th>возвращаемый тип</th>
<th>семантика исполнения</th>
<th>утверждение/примечание состояние до/после</th>
</tr>
<tr>
<td><var>X u;</var></td>
<td>
</td>
<td>&nbsp;</td>
<td>примечание: <var>u</var> может иметь исключительное значение.<br>
примечание: предполагается деструктор.</td>
</tr>
<tr>
<td><var>X()</var></td>
<td>
</td>
<td>&nbsp;</td>
<td>примечание: <var>X()</var> может быть исключительным.</td>
</tr>
<tr>
<td><var>X(a);</var></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><var>a == X(a)</var></td>
</tr>
<tr>
<td><var>X u(a);</var><br><var>X u = a;</var></td>
<td>
</td>
<td><var>X u;</var> <var>u = a;</var></td>
<td>после: <var>u == a</var>.</td>
</tr>
<tr>
<td><var>a == b</var></td>
<td>обратимый в <var>bool</var></td>
<td>&nbsp;</td>
<td><var>== </var>- это отношение эквивалентности.</td>
</tr>
<tr>
<td><var>a != b</var></td>
<td>обратимый в <var>bool</var></td>
<td><var>!(a == b)</var></td>
<td>
</td>
</tr>
<tr>
<td><var>r = a</var></td>
<td><var>X&amp;</var></td>
<td>.</td>
<td>после: <var>r == a</var>.</td>
</tr>
<tr>
<td><var>*a</var></td>
<td>обратимый в <var>T</var></td>
<td>&nbsp;</td>
<td>до: <var>a</var> - разыменовываемое.<br><var>a == b</var> подразумевает 
<var>*a == *b</var>.<br>Если <var>X</var> - модифицируемый, то <var>*a = t</var> 
- допустимо.</td>
</tr>
<tr>
<td><var>++r</var></td>
<td><var>X&amp;</var></td>
<td>&nbsp;</td>
<td>до: <var>r</var> - разыменовываемое.<br>после: <var>r</var> - 
разыменовываемое или <var>r</var> - законечное. <br><var>r == s</var> и 
<var>r</var> - разыменовываемое подразумевает <var>++r == ++s</var>. 
<br><var>&amp;r == &amp;++r</var>.</td>
</tr>
<tr>
<td><var>r++</var></td>
<td><var>X</var></td>
<td><var>{ X tmp = r;<br>++ r;<br>return tmp; }</var></td>
<td>&nbsp;</td>
</tr>
</tbody></table>

<table class="note" width="98%"><tbody><tr><td><b>ПРИМЕЧАНИЕ</b><br>Тот факт, что <var>r == s</var> подразумевает <var>++r == ++s</var>
(что неверно для итераторов ввода и вывода) и что удалено 
ограничение на число присваиваний через итератор (которое применяется к 
итераторам вывода), позволяет использование многопроходных однонаправленных 
алгоритмов с последовательными итераторами.</td></tr></tbody></table>


<h3 class="lem_sub_para2"><a name="bidirectional_iterator"></a>Двунаправленные итераторы (Bidirectional iterators)<a name="IDAEDCEJ"></a></h3>
<p class="normal_text">Класс или встроенный тип <var>X</var> удовлетворяет требованиям 
двунаправленного итератора, если к таблице, которая определяет последовательные 
итераторы, мы добавим следующие строки:</p>

<table bordercolorlight="#808080" bordercolordark="#808080" style="border-collapse: collapse" border="1" cellpadding="5">
<caption>Таблица 5. Требования двунаправленного итератора (в дополнение к 
последовательному итератору)</caption>
<tbody><tr>
<th>выражение</th>
<th>возвращаемый тип</th>
<th>семантика исполнения</th>
<th>утверждение/примечание состояние до/после</th>
</tr>
<tr>
<td><var>--r</var></td>
<td><var>X&amp;</var></td>
<td>
</td>
<td>до: существует <var>s</var> такое, что <var>r == ++s</var>. <br>после: 
<var>s</var> - разыменовываемое.<br><var>--(++r) == r</var>. <br><var>--r == 
--s</var> подразумевает <var>r == s</var>. <br><var>&amp;r == 
&amp;--r</var>.</td>
</tr>
<tr>
<td><var>r--</var></td>
<td><var>X</var></td>
<td><var>{ X tmp = r;<br>--r;<br>return tmp; }</var></td>
<td>
</td>
</tr>
</tbody></table>

<table class="note" width="98%"><tbody><tr><td><b>ПРИМЕЧАНИЕ</b><br>Двунаправленные итераторы позволяют алгоритмам 
перемещать итераторы назад также, как вперёд. </td></tr></tbody></table>


<h3 class="lem_sub_para2"><a name="random_iterator"></a>Итераторы произвольного доступа (Random access iterators)<a name="IDAKFCEJ"></a></h3>
<p class="normal_text">Класс или встроенный тип <var>X</var> удовлетворяет требованиям 
итераторов произвольного доступа, если к таблице, которая определяет 
двунаправленные итераторы, мы добавим следующие строки:</p>

<table bordercolorlight="#808080" bordercolordark="#808080" style="border-collapse: collapse" border="1" cellpadding="5">
<caption>Таблица 6: Требования итератора произвольного доступа (в дополнение 
к двунаправленному итератору)</caption>
<tbody><tr>
<th>выражение</th>
<th>возвращаемый тип</th>
<th>семантика исполнения</th>
<th>утверждение/примечание состояние до/после</th>
</tr>
<tr>
<td><var>r += n</var></td>
<td><var>X&amp;</var></td>
<td><var>{ Distance m = n;<br>if(m &gt;= 0)<br>&nbsp;&nbsp;while(m--) ++r;<br>else<br>&nbsp;&nbsp; 
while(m++) --r;<br>return r; }</var></td>
<td>
</td>
</tr>
<tr>
<td><var>a + n<br>n + a</var></td>
<td><var>X</var></td>
<td><var>{ X tmp = a;<br>return tmp += n; }</var></td>
<td><var>a + n == n + a</var>.</td>
</tr>
<tr>
<td><var>r -= n</var></td>
<td><var>X&amp;</var></td>
<td><var>return r += -n;</var></td>
<td>
</td>
</tr>
<tr>
<td><var>a - n</var></td>
<td><var>X</var></td>
<td><var>{ X tmp = a;<br>return tmp -= n; }</var></td>
<td>
</td>
</tr>
<tr>
<td><var>b - a</var></td>
<td><var>Distance</var></td>
<td>
</td>
<td>до: существует значение <var>n</var> типа <var>Distance</var> такое,<br>что 
<var>a + n = b</var>.<br><var>b == a + (b - a)</var>.</td>
</tr>
<tr>
<td><var>a[n]</var></td>
<td>обратимый в <var>T</var></td>
<td><var>*(a + n)</var></td>
<td>
</td>
</tr>
<tr>
<td><var>a &lt; b</var></td>
<td>обратимый в <var>bool</var></td>
<td><var>b - a &gt; 0</var></td>
<td><var>&lt;</var> - это отношение полного упорядочения</td>
</tr>
<tr>
<td><var>a &gt; b</var></td>
<td>обратимый в <var>bool</var></td>
<td><var>b &lt; a</var></td>
<td><var>&gt;</var> - это отношение полного упорядочения, противоположное 
<var>&lt;</var>.</td>
</tr>
<tr>
<td><var>a &gt;= b</var></td>
<td>обратимый в <var>bool</var></td>
<td><var>!(a &lt; b)</var></td>
<td>
</td>
</tr>
<tr>
<td><var>a &lt;= b</var></td>
<td>обратимый в <var>bool</var></td>
<td><var>!(a &gt; b)</var></td>
<td>
</td>
</tr>
</tbody></table>


<h3 class="lem_sub_para2">Теги итераторов (Iterator tags)<a name="IDAHLCEJ"></a></h3>
<p class="normal_text">Чтобы осуществлять алгоритмы только в терминах итераторов, часто бывает 
необходимо вывести тип значения и тип расстояния из итератора. Для решения этой 
задачи требуется, чтобы для итератора <var>i</var> любой категории, отличной от 
итератора вывода, выражение <var>value_type(i)</var> возвращало 
<var>(T*)(0)</var>, а выражение <var>distance_type(i)</var> возвращало 
<var>(Distance*)(0)</var>. Для итераторов вывода эти выражения не требуются.</p>

<h4 class="lem_sub_para2">Примеры использования тегов итераторов</h4>
<p>Для всех типов обычных указателей мы можем определить 
<var>value_type</var> и <var>distance_type</var> с помощью следующего:</p>

<div id="IDA5LCEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">inline</span> T* value_type(<span class="KEYWORD">const</span> T*) { <span class="KEYWORD">return</span> (T*) (<span class="NUMBER">0</span>); }

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt; 
<span class="KEYWORD">inline</span> ptrdiff_t* distance_type(<span class="KEYWORD">const</span> T*) { <span class="KEYWORD">return</span> (ptrdiff_t*) (<span class="NUMBER">0</span>); }
</pre>
</td></tr></tbody></table>
</div>

<p>Тогда, если мы хотим осуществить обобщённую функцию <var>reverse</var>, мы пишем следующее:</p>

<div id="IDA3MCEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator&gt;
<span class="KEYWORD">inline void</span> reverse(BidirectionalIterator first, BidirectionalIterator last) 
{ 
    _reverse(first, last, value_type(first), distance_type(first));
}
</pre>
</td></tr></tbody></table>
</div>

<p>где <var>_reverse</var> определена следующим образом:</p>

<div id="IDAJNCEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">void</span> _reverse(BidirectionalIterator first, BidirectionalIterator last, T*,
              Distance*) { 
    Distance n;
    distance(first, last, n); <span class="COMMENT">// смотри раздел "Операции с итераторами"</span>
    --n;
    <span class="KEYWORD">while</span> (n &gt; <span class="NUMBER">0</span>) {
        T tmp = *first;
        *first++ = *--last;
        *last = tmp;
        n -= <span class="NUMBER">2</span>;
    } 
}
</pre>
</td></tr></tbody></table>
</div>

<p>Если имеется дополнительный тип указателя <var>_huge</var> такой, что 
разность двух указателей <var>_huge</var> имеет тип <var>long long</var>, мы 
определяем:</p>

<div id="IDAFOCEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">inline</span> T* value_type(<span class="KEYWORD">const</span> T _huge *) { <span class="KEYWORD">return</span> (T*) (<span class="NUMBER">0</span>); }

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt; 
<span class="KEYWORD">inline long long</span>* distance_type(<span class="KEYWORD">const</span> T _huge *) { 
    <span class="KEYWORD">return</span> (<span class="KEYWORD">long long</span>*)(<span class="NUMBER">0</span>); 
}
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text">Часто желательно для шаблонной функции выяснить, какова наиболее 
специфичная категория её итераторного аргумента, так чтобы функция могла 
выбирать наиболее эффективный алгоритм во время компиляции. Чтобы облегчить это, 
библиотека вводит классы <i>тегов категорий</i> (<i>category tag</i>), которые 
используются как теги времени компиляции для выбора алгоритма. Это следущие 
теги: <var>input_iterator_tag</var>, <var>output_iterator_tag</var>, 
<var>forward_iterator_tag</var>, <var>bidirectional_iterator_tag</var> и 
<var>random_access_iterator_tag</var>. Каждый итератор <var>i</var> должен иметь 
выражение <var>iterator_category(i)</var>, определённое для него, которое 
возвращает тег наиболее специфичной категории, который описывает его поведение. 
Например, мы определяем, что все типы указателей находятся в категории 
итераторов произвольного доступа:</p>

<div id="IDAVPCEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">inline</span> random_access_iterator_tag iterator_category(<span class="KEYWORD">const</span> T*) 
{
    <span class="KEYWORD">return</span> random_access_iterator_tag(); 
}
</pre>
</td></tr></tbody></table>
</div>

<p>Определяемый пользователем итератор <var>BinaryTreeIterator</var> может 
быть включен в категорию двунаправленных итераторов следующим образом:</p>

<div id="IDAIQCEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">inline</span> bidirectional_iterator_tag iterator_category(
        <span class="KEYWORD">const</span> BinaryTreeIterator&lt;T&gt;&amp;) 
{ 
    <span class="KEYWORD">return</span> bidirectional_iterator_tag();
}
</pre>
</td></tr></tbody></table>
</div>

<p>Если шаблонная функция <var>evolve</var> хорошо определена для 
двунаправленных итераторов, но может быть осуществлена более эффективно для 
итераторов произвольного доступа, тогда реализация выглядит так:</p>

<div id="IDAYQCEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator&gt;
<span class="KEYWORD">inline void</span> evolve(BidirectionalIterator first, BidirectionalIterator last)
{
    evolve(first, last, iterator_category(first));
}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator&gt; 
<span class="KEYWORD">void</span> evolve(BidirectionalIterator first, BidirectionalIterator last,
            bidirectional_iterator_tag) {
    <span class="COMMENT">// ... более универсальный, но менее эффективный алгоритм</span>
}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator&gt;
<span class="KEYWORD">void</span> evolve(RandomAccessIterator first, RandomAccessIterator last,
            random_access_iterator_tag) {
    <span class="COMMENT">// ... более эффективный, но менее универсальный алгоритм</span>
}
</pre>
</td></tr></tbody></table>
</div>


<h4 class="lem_sub_para2">Примитивы, определённые в библиотеке</h4>
<p class="normal_text">Чтобы упростить задачу определения <var>iterator_category</var>, 
<var>value_type</var> и <var>distance_type</var> для определяемых пользователем 
итераторов, библиотека обеспечивает следующие предопределённые классы и функции: 
</p>

<div id="IDA2RCEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="COMMENT">// iterator tags (теги итераторов)</span>

<span class="KEYWORD">struct</span> input_iterator_tag {};
<span class="KEYWORD">struct</span> output_iterator_tag {};
<span class="KEYWORD">struct</span> forward_iterator_tag {};
<span class="KEYWORD">struct</span> bidirectional_iterator_tag {};
<span class="KEYWORD">struct</span> random_access_iterator_tag {};

<span class="COMMENT">// iterator bases (базовые классы итераторов)</span>

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance = ptrdiff_t&gt; <span class="KEYWORD">struct</span> input_iterator {};
<span class="KEYWORD">struct</span> output_iterator {};
<span class="COMMENT">// output_iterator не шаблон, потому что у итераторов вывода</span>
<span class="COMMENT">// не определены ни значимый тип, ни тип расстояния.</span>
<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance = ptrdiff_t&gt; 
         <span class="KEYWORD">struct</span> forward_iterator {};
<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance = ptrdiff_t&gt; 
         <span class="KEYWORD">struct</span> bidirectional_iterator {};
<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance = ptrdiff_t&gt; 
         <span class="KEYWORD">struct</span> random_access_iterator {};

<span class="COMMENT">// iterator_category (функции категорий итераторов)</span>

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline</span> input_iterator_tag
iterator_category(<span class="KEYWORD">const</span> input_iterator&lt;T, Distance&gt;&amp;) {
    <span class="KEYWORD">return</span> input_iterator_tag();
} 
<span class="KEYWORD">inline</span> output_iterator_tag iterator_category(<span class="KEYWORD">const</span> output_iterator&amp;) {
    <span class="KEYWORD">return</span> output_iterator_tag();
}
<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline</span> forward_iterator_tag
iterator_category(<span class="KEYWORD">const</span> forward_iterator&lt;T, Distance&gt;&amp;) {
    <span class="KEYWORD">return</span> forward_iterator_tag();
}
<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline</span> bidirectional_iterator_tag
iterator_category(<span class="KEYWORD">const</span> bidirectional_iterator&lt;T, Distance&gt;&amp;) {
    <span class="KEYWORD">return</span> bidirectional_iterator_tag();
)
<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline</span> random_access_iterator_tag
iterator_category(<span class="KEYWORD">const</span> random_access_iterator&lt;T, Distance&gt;&amp;) {
    <span class="KEYWORD">return</span> random_access_iterator_tag();
}
<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">inline</span> random_access_iterator_tag iterator_category(<span class="KEYWORD">const</span> T*) {
    <span class="KEYWORD">return</span> random_access_iterator_tag();
}

<span class="COMMENT">// value_type of iterator (функции значимого типа итераторов)</span>

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline</span> T* value_type(<span class="KEYWORD">const</span> input_iterator&lt;T, Distance&gt;&amp;) (
    <span class="KEYWORD">return</span> (T*) (<span class="NUMBER">0</span>);
}
<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline</span> T* value_type(<span class="KEYWORD">const</span> forward_iterator&lt;T, Distance&gt;&amp;) {
    <span class="KEYWORD">return</span> (T*) (<span class="NUMBER">0</span>);
}
<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline</span> T* value_type(<span class="KEYWORD">const</span> bidirectional_iterator&lt;T, Distance&gt;&amp;) {
    <span class="KEYWORD">return</span> (T*) (<span class="NUMBER">0</span>);
}
<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline</span> T* value_type(<span class="KEYWORD">const</span> random_access_iterator&lt;T, Distance&gt;&amp;) {
    <span class="KEYWORD">return</span> (T*) (<span class="NUMBER">0</span>);
}
<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">inline</span> T* value_type(<span class="KEYWORD">const</span> T*) { <span class="KEYWORD">return</span> (T*) (<span class="NUMBER">0</span>); }

<span class="COMMENT">// distance_type of iterator (функции типа расстояния итераторов)</span>

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline</span> Distance* distance_type(<span class="KEYWORD">const</span> input_iterator&lt;T, Distance&gt;&amp;) {
    <span class="KEYWORD">return</span> (Distance*) (<span class="NUMBER">0</span>);
}
<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline</span> Distance* distance_type(<span class="KEYWORD">const</span> forward_iterator&lt;T, Distance&gt;&amp;) {
    <span class="KEYWORD">return</span> (Distance*) (<span class="NUMBER">0</span>);
}
<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline</span> Distance* distance_type(<span class="KEYWORD">const</span> bidirectional_iterator&lt;T, Distance&gt;&amp;) {
    <span class="KEYWORD">return</span> (Distance*) (<span class="NUMBER">0</span>);
}
<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline</span> Distance* distance_type(<span class="KEYWORD">const</span> random_access_iterator&lt;T, Distance&gt;&amp;) {
    <span class="KEYWORD">return</span> (Distance*) (<span class="NUMBER">0</span>);
} 
<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">inline</span> ptrdiff_t* distance_type(<span class="KEYWORD">const</span> T*) { <span class="KEYWORD">return</span> (ptrdiff_t*) (<span class="NUMBER">0</span>); }
</pre>
</td></tr></tbody></table>
</div>

<p>Если пользователь хочет определить двунаправленный итератор для некоторой 
структуры данных, содержащей <var>double</var>, и такой, чтобы работал с большой 
(large) моделью памяти компьютера, то это может быть сделано таким определением: 
</p>

<div id="IDAH0CEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">class</span> MyIterator : <span class="KEYWORD">public</span> bidirectional_iterator &lt;<span class="KEYWORD">double</span>, <span class="KEYWORD">long</span>&gt; {
<span class="COMMENT">// код, осуществляющий ++, и т.д.</span>
};
</pre>
</td></tr></tbody></table>
</div>

<p>Тогда нет необходимости определять <var>iterator_category</var>, 
<var>value_type</var>, и <var>distance_type</var> в <var>MyIterator</var>. 
</p>


<h3 class="lem_sub_para2">Операции с итераторами (Iterator operations)<a name="IDA50CEJ"></a></h3>
<p class="normal_text">Так как только итераторы произвольного доступа обеспечивают <var>+</var> 
и <var>-</var> операторы, библиотека предоставляет две шаблонные функции 
<var>advance</var> и <var>distance</var>. Эти функции используют <var>+</var> и 
<var>-</var> для итераторов произвольного доступа (и имеют, поэтому, сложность 
постоянного времени для них); для итераторов ввода, последовательных и 
двунаправленных итераторов функции используют <var>++</var>, чтобы обеспечить 
реализацию со сложностью линейного времени. <var>advance</var> берет 
отрицательный параметр <var>n</var> только для итераторов произвольного доступа 
и двунаправленных итераторов. <var>advance</var> увеличивает (или уменьшает для 
отрицательного <var>n</var>) итераторную ссылку <var>i</var> на <var>n</var>. 
<var>distance</var> увеличивает <var>n</var> на число единиц, сколько требуется, 
чтобы дойти от <var>first</var> до <var>last</var>.</p>

<div id="IDAG2CEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline void</span> advance(InputIterator&amp; i, Distance n);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline void</span> distance(InputIterator first, InputIterator last, Distance&amp; n);
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>distance</var> должна быть функцией 3-х параметров, сохраняющей 
результат в ссылке вместо возвращения результата, потому что тип расстояния не 
может быть выведен из встроенных итераторных типов, таких как <var>int*</var>. 
</p>

<h2 class="lem_para">Функциональные объекты<a name="IDAA3CEJ"></a></h2>
<p class="normal_text">Функциональные объекты - это объекты, для которых определён 
<var>operator()</var>. Они важны для эффективного использования библиотеки. В 
местах, где ожидается передача указателя на функцию алгоритмическому шаблону, 
интерфейс установлен на приём объекта с определённым <var>operator()</var>. Это 
не только заставляет алгоритмические шаблоны работать с указателями на функции, 
но также позволяет им работать с произвольными функциональными объектами. 
Использование функциональных объектов вместе с функциональными шаблонами 
увеличивает выразительную мощность библиотеки также, как делает результирующий 
код более эффективным. Например, если мы хотим поэлементно сложить два вектора 
<var>a</var> и <var>b</var>, содержащие <var>double</var>, и поместить результат 
в <var>a</var>, мы можем сделать зто так:</p>

<div id="IDAR3CEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre>transform(a.begin(), a.end(), b.begin(), a.begin(), plus&lt;<span class="KEYWORD">double</span>&gt;());
</pre>
</td></tr></tbody></table>
</div>

<p>Если мы хотим отрицать каждый элемент <var>a</var>, мы можем сделать это так:</p>

<div id="IDAZ3CEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre>transform(a.begin(), a.end(), a.begin(), negate&lt;<span class="KEYWORD">double</span>&gt;());
</pre>
</td></tr></tbody></table>
</div>

<p>Соответствующие функции вставят сложение и отрицание.</p>
<p class="normal_text">Чтобы позволить адаптерам и другим компонентам манипулировать 
функциональными объектами, которые используют один или два параметра, требуется, 
чтобы они соответственно обеспечили определение типов (typedefs) 
<var>argument_type</var> и <var>result_type</var> для функциональных объектов, 
которые используют один параметр, и <var>first_argument_type</var>, 
<var>second_argument_type</var> и <var>result_type</var> для функциональных 
объектов, которые используют два параметра.</p>

<h3 class="lem_para">Базовые классы (Base)<a name="IDAL4CEJ"></a></h3>
<p>Следующие классы предоставляются, чтобы упростить определение типов 
(typedefs) параметров и результата:</p>

<div id="IDAQ4CEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Arg, <span class="KEYWORD">class</span> Result&gt; 
<span class="KEYWORD">struct</span> unary_function {
    <span class="KEYWORD">typedef</span> Arg argument_type;
    <span class="KEYWORD">typedef</span> Result result_type;
}:

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Arg1, <span class="KEYWORD">class</span> Arg2, <span class="KEYWORD">class</span> Result&gt;
<span class="KEYWORD">struct</span> binary_function {
    <span class="KEYWORD">typedef</span> Arg1 first_argument_type;
    <span class="KEYWORD">typedef</span> Arg2 second_argument_type;
    <span class="KEYWORD">typedef</span> Result result_type;
};
</pre>
</td></tr></tbody></table>
</div>


<h3 class="lem_para">Арифметические операции (Arithmetic operations)<a name="IDAP5CEJ"></a></h3>
<p>&nbsp;Библиотека обеспечивает базовые классы функциональных объектов для всех 
арифметических операторов языка.</p>

<div id="IDAU5CEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">struct</span> plus : binary_function&lt;T, T, T&gt; {
    T <span class="KEYWORD">operator</span>()(<span class="KEYWORD">const</span> T&amp; x, <span class="KEYWORD">const</span> T&amp; y) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> x + y; } 
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">struct</span> minus : binary_function&lt;T, T, T&gt; {
    T <span class="KEYWORD">operator</span>()(<span class="KEYWORD">const</span> T&amp; x, <span class="KEYWORD">const</span> T&amp; y) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> x - y; } 
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">struct</span> times : binary_function&lt;T, T, T&gt; {
    T <span class="KEYWORD">operator</span>()(<span class="KEYWORD">const</span> T&amp; x, <span class="KEYWORD">const</span> T&amp; y) <span class="KEYWORD">const</span> ( <span class="KEYWORD">return</span> x *  y; } 
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt; 
<span class="KEYWORD">struct</span> divides : binary_function&lt;T, T, T&gt; {
    T <span class="KEYWORD">operator</span>()(<span class="KEYWORD">const</span> T&amp; x, <span class="KEYWORD">const</span> T&amp; y) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> x / y; }
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">struct</span> modulus : binary_function&lt;T, T, T&gt; {
    T <span class="KEYWORD">operator</span>()(<span class="KEYWORD">const</span> T&amp; x, <span class="KEYWORD">const</span> T&amp; y) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> x % y; } 
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt; 
<span class="KEYWORD">struct</span> negate : unary_function&lt;T, T&gt; {
    T <span class="KEYWORD">operator</span>()(<span class="KEYWORD">const</span> T&amp; x) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> -x; } 
};
</pre>
</td></tr></tbody></table>
</div>


<h3 class="lem_para">Сравнения (Comparisons)<a name="IDAY0DEJ"></a></h3>
<p>Библиотека обеспечивает базовые классы функциональных объектов для всех 
операторов сравнения языка</p>

<div id="IDA30DEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">struct</span> equal_to : binary_function&lt;T, T, <span class="KEYWORD">bool</span>&gt; {
    <span class="KEYWORD">bool operator</span>()(<span class="KEYWORD">const</span> T&amp; x, <span class="KEYWORD">const</span> T&amp; y) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> x == y; } 
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">struct</span> not_equal_to : binary_function&lt;T, T, <span class="KEYWORD">bool</span>&gt; {
    <span class="KEYWORD">bool operator</span>()(<span class="KEYWORD">const</span> T&amp; x, <span class="KEYWORD">const</span> T&amp; y) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> x != y; } 
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">struct</span> greater : binary_function&lt;T, T, <span class="KEYWORD">bool</span>&gt; {
    <span class="KEYWORD">bool operator</span>()(<span class="KEYWORD">const</span> T&amp; x, <span class="KEYWORD">const</span> T&amp; y) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> x &gt; y; }
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">struct</span> less : binary_function&lt;T, T, <span class="KEYWORD">bool</span>&gt; {
    <span class="KEYWORD">bool operator</span>()(<span class="KEYWORD">const</span> T&amp; x, <span class="KEYWORD">const</span> T&amp; y) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> x &lt; y; } 
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt; 
<span class="KEYWORD">struct</span> greater_equal : binary_function&lt;T, T, <span class="KEYWORD">bool</span>&gt; {
    <span class="KEYWORD">bool operator</span>()(<span class="KEYWORD">const</span> T&amp; x, <span class="KEYWORD">const</span> T&amp; y) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> x &gt;= y; } 
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt; 
<span class="KEYWORD">struct</span> less_equal : binary_function&lt;T, T, <span class="KEYWORD">bool</span>&gt; {
    <span class="KEYWORD">bool operator</span>()(<span class="KEYWORD">const</span> T&amp; x, <span class="KEYWORD">const</span> T&amp; y) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> x &lt;= y; } 
};
</pre>
</td></tr></tbody></table>
</div>


<h3 class="lem_para">Логические операции (Logical operations)<a name="IDAM4DEJ"></a></h3>

<div id="IDAP4DEJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">struct</span> logical_and : binary_function&lt;T, T, <span class="KEYWORD">bool</span>&gt; {
    <span class="KEYWORD">bool operator</span>()(<span class="KEYWORD">const</span> T&amp; x, <span class="KEYWORD">const</span> T&amp; y) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> x &amp;&amp; y; } 
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">struct</span> logical_or : binary_function&lt;T, T, <span class="KEYWORD">bool</span>&gt; {
    <span class="KEYWORD">bool operator</span>()(<span class="KEYWORD">const</span> T&amp; x, <span class="KEYWORD">const</span> T&amp; y) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> x || y; } 
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">struct</span> logical_not : unary_function&lt;T, <span class="KEYWORD">bool</span>&gt; {
    <span class="KEYWORD">bool operator</span>()(<span class="KEYWORD">const</span> T&amp; x) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> !x; } 
};
</pre>
</td></tr></tbody></table>
</div>

<h2 class="lem_para">Распределители<a name="IDAKACUJ"></a></h2>
<p class="normal_text">Одна из общих проблем в мобильности - это способность инкапсулировать 
информацию относительно модели памяти. Эта информация включает типы указателей, 
тип их разности, тип размера объектов в этой модели памяти, также как её 
примитивы выделения и освобождения памяти.</p>
<p class="normal_text">STL принимается за эту проблему, обеспечивая стандартный набор требований 
для <i>распределителей</i> (<i>allocators</i>), являющихся объектами, которые 
инкапсулируют эту информацию. Все контейнеры в STL параметризованы в терминах 
распределителей. Это значительно упрощает задачу взаимодействия с 
многочисленными моделями памяти.</p>

<h3 class="lem_para">Требования распределителей (Allocator requirements)<a name="IDAVACUJ"></a></h3>

<p class="normal_text">В следующей таблице мы предполагаем, что <var>X</var> - класс 
распределителей для объектов типа <var>T</var>, <var>a</var> - значение 
<var>X</var>, <var>n</var> имеет тип <var>X::size_type</var>, <var>p</var> имеет 
тип <var>X::pointer</var>, <var>r</var> имеет тип <var>X::reference</var> и 
<var>s</var> имеет тип <var>X::const_reference</var>.</p>
<p class="normal_text">Все операции c распределителями, как ожидается, сводятся к постоянному времени.</p>

<table bordercolorlight="#808080" bordercolordark="#808080" style="border-collapse: collapse" border="1" cellpadding="5">
<caption>Таблица 7. Требования распределителей</caption>
<tbody><tr>
<th>выражение</th>
<th>возвращаемый тип</th>
<th>утверждение/примечание состояние до/после</th>
</tr>
<tr>
<td><var>X::value_type</var></td>
<td><var>Т</var></td>
<td>
</td>
</tr>
<tr>
<td><var>X::reference</var></td>
<td>леводопустимое значение <var>T</var> (lvalue of <var>T</var>)</td>
<td>
</td>
</tr>
<tr>
<td><var>X::const_reference</var></td>
<td>const lvalue of <var>T</var></td>
<td>
</td>
</tr>
<tr>
<td><var>X::pointer</var></td>
<td>указатель на тип <var>T</var></td>
<td>результатом <var>operator*</var> для значений <var>X::pointer</var> является 
<var>reference</var>.</td>
</tr>
<tr>
<td><var>X::const_pointer</var></td>
<td>указатель на тип <var>const T</var></td>
<td>результат <var>operator*</var> для значений <var>X::const_pointer</var> - 
<var>const_reference</var>;<br>это - тот же самый тип указателя, как 
<var>X::pointer</var>, в частности, <var>sizeof(X::const_pointer) == 
sizeof(X::pointer)</var>.</td>
</tr>
<tr>
<td><var>X:: size_type</var></td>
<td>беззнаковый целочисленный тип</td>
<td>тип, который может представлять размер самого большого объекта в модели памяти.</td>
</tr>
<tr>
<td><var>X::difference_type</var></td>
<td>знаковый целочисленный тип</td>
<td>тип, который может представлять разность между двумя любыми указателями в 
модели памяти.</td>
</tr>
<tr>
<td><var>X a;</var></td>
<td>
</td>
<td>примечание: предполагается деструктор.</td>
</tr>
<tr>
<td><var>a.address(r)</var></td>
<td>указатель</td>
<td><var>*(a.address(r)) == r</var>.</td>
</tr>
<tr>
<td><var>a.const_address(s)</var></td>
<td><var>const_pointer</var></td>
<td><var>*(a.address(s)) == s</var>.</td>
</tr>
<tr>
<td><var>a.allocate(n)</var></td>
<td><var>X::pointer</var></td>
<td>память распределяется для <var>n</var> объектов типа <var>T</var>, но 
объекты не создаются. <var>allocate</var> может вызывать соответствующее 
исключение.</td>
</tr>
<tr>
<td><var>a.deallocate(p)</var></td>
<td>результат не используется</td>
<td>все объекты в области, указываемой <var>p</var>, должны быть уничтожены до этого запроса.</td>
</tr>
<tr>
<td><var>construct(p, a)</var></td>
<td><var>void</var></td>
<td>после: <var>*p == a</var>.</td>
</tr>
<tr>
<td><var>destroy(p)</var></td>
<td><var>void</var></td>
<td>значение, указываемое <var>p</var>, уничтожается.</td>
</tr>
<tr>
<td><var>a.init_page_size()</var></td>
<td><var>X::size_type</var></td>
<td>возвращённое значение - оптимальное значение для начального размера буфера 
данного типа. Предполагается, что если <var>k</var> возвращено функцией 
<var>init_page_size</var>, <var>t</var> - время конструирования для 
<var>T</var>, и <var>u</var> - время, которое требуется для выполнения 
<var>allocate(k)</var>, тогда <var>k * t</var> будет намного больше, чем 
<var>u</var>.</td>
</tr>
<tr>
<td><var>a.max_size()</var></td>
<td><var>X::size_type</var></td>
<td>наибольшее положительное значение <var>X::difference_type</var></td>
</tr>
</tbody></table>

<p class="normal_text"><var>pointer</var> относится к категории модифицируемых итераторов 
произвольного доступа, ссылающихся на <var>T</var>. <var>const_pointer</var> 
относится к категории постоянных итераторов произвольного доступа, ссылающихся 
на <var>T</var>. Имеется определённое преобразование из <var>pointer</var> в 
<var>const_pointer</var>.</p>
<p class="normal_text">Для любого шаблона распределителя <var>Alloc</var> имеется определение 
для типа <var>void</var>. У <var>Alloc&lt;void&gt;</var> определены только 
конструктор, деструктор и <var>Alloc&lt;void&gt;::pointer</var>. Преобразования 
определены из любого <var>Alloc&lt;T&gt;::pointer</var> в 
<var>Alloc&lt;void&gt;::pointer</var> и обратно, так что для любого <var>p</var> 
будет <var>p == Alloc&lt;T&gt;::pointer(Alloc&lt;void&gt;::pointer(p))</var>. 
</p>


<h3 class="lem_sub_para2">Распределитель по умолчанию (The default allocator)<a name="IDAVRDUJ"></a></h3>

<div id="IDAYRDUJ">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">class</span> allocator { 
<span class="KEYWORD">public</span>:
    <span class="KEYWORD">typedef</span> T* pointer;
    <span class="KEYWORD">typedef const</span> T* const_pointer;
    <span class="KEYWORD">typedef</span> T&amp; reference;
    <span class="KEYWORD">typedef const</span> T&amp; const_reference;
    <span class="KEYWORD">typedef</span> T value_type;
    <span class="KEYWORD">typedef</span> size_t size_type;
    <span class="KEYWORD">typedef</span> ptrdiff_t difference_type;
    allocator();
    ~allocator();
    pointer address(reference x);
    const_pointer const_address(const_reference x);
    pointer allocate(size_type n);
    <span class="KEYWORD">void</span> deallocate(pointer p);
    size_type init_page_size();
    size_type max_size();
};

<span class="KEYWORD">class</span> allocator&lt;<span class="KEYWORD">void</span>&gt; { 
<span class="KEYWORD">public</span>:
    <span class="KEYWORD">typedef void</span>* pointer;
    allocator();
    ~allocator();
};
</pre>
</td></tr></tbody></table>
</div>

<p>Предполагается, что в дополнение к <var>allocator</var> поставщики 
библиотеки обеспечивают распределители для всех моделей памяти.</p>

<h2 class="lem_para"><a name="container"></a>Контейнеры<a name="IDAATDUJ"></a></h2>
<p class="normal_text">Контейнеры - это объекты, которые содержат другие объекты. Они управляют 
размещением в памяти и свобождением этих объектов через конструкторы, 
деструкторы, операции вставки и удаления.</p>
<p class="normal_text">В следующей таблице мы полагаем, что <var>X</var> - контейнерный класс, 
содержащий объекты типа <var>T</var>, <var>a</var> и <var>b</var> - значения 
<var>X</var>, <var>u</var> - идентификатор, <var>r</var> - значение 
<var>X&amp;</var>.</p>

<table bordercolorlight="#808080" bordercolordark="#808080" style="border-collapse: collapse" border="1" cellpadding="5">
<caption>Таблица 8. Требования контейнеров</caption>
<tbody><tr>
<th>выражение</th>
<th>возвращаемый тип</th>
<th>семантика исполнения</th>
<th>утверждение/примечание состояние до/после</th>
<th>сложность</th>
</tr>
<tr>
<td><var>X::value_type</var></td>
<td><var>Т</var></td>
<td>
</td>
<td>
</td>
<td>время компиляции</td>
</tr>
<tr>
<td><var>X::reference</var></td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>время компиляции</td>
</tr>
<tr>
<td><var>X::const_refe<br>rence</var></td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>время компиляции</td>
</tr>
<tr>
<td><var>X::pointer</var></td>
<td>тип указателя, указывающий на <var>X::reference</var></td>
<td>
</td>
<td>указатель на <var>T</var> в модели памяти, используемой контейнером</td>
<td>время компиляции</td>
</tr>
<tr>
<td><var>X::iterator</var></td>
<td>тип итратора, указывающий на <var>X::reference</var></td>
<td>
</td>
<td>итератор любой категории, кроме итератора вывода.</td>
<td>время компиляции</td>
</tr>
<tr>
<td><var>X::const_iter<br>ator</var></td>
<td>тип итератора, указывающий на <var>X::<br>const_reference</var></td>
<td>
</td>
<td>постоянный итератор любой категории, кроме итератора вывода.</td>
<td>время компиляции</td>
</tr>
<tr>
<td><var>X::difference<br>_type</var></td>
<td>знаковый целочисленный тип</td>
<td>
</td>
<td>идентичен типу расстояния <var>X::iterator</var> и <var>X::const_iterator</var></td>
<td>время компиляции</td>
</tr>
<tr>
<td><var>X::size_type</var></td>
<td>беззнаковый целочисленный тип</td>
<td>
</td>
<td><var>size_type</var> может представлять любое неотрицательное значение <var>difference_type</var></td>
<td>время компиляции</td>
</tr>
<tr>
<td><var>X u;</var></td>
<td>
</td>
<td>
</td>
<td>после: <var>u.size() == 0</var>.</td>
<td>постоянная</td>
</tr>
<tr>
<td><var>X()</var></td>
<td>
</td>
<td>
</td>
<td><var>X().size() == 0</var>.</td>
<td>постоянная</td>
</tr>
<tr>
<td><var>X(a)</var></td>
<td>
</td>
<td>
</td>
<td><var>a == X(a)</var>.</td>
<td>линейная</td>
</tr>
<tr>
<td><var>X u(a);</var><br><var>X u == a;</var></td>
<td>
</td>
<td><var>X u;</var> <var>u = a;</var></td>
<td>после: <var>u == a</var>.</td>
<td>линейная</td>
</tr>
<tr>
<td><var>(&amp;a)-&gt;~X()</var></td>
<td>результат не используется</td>
<td>
</td>
<td>после: <var>a.size() == 0</var>. <br>примечание: деструктор применяется к каждому элементу <var>a</var>, и вся память возвращается.</td>
<td>линейная</td>
</tr>
<tr>
<td><var>a.begin()</var></td>
<td><var>iterator;</var><br><var>const_iterator</var> для постоянного <var>a</var></td>
<td>
</td>
<td>
</td>
<td>постоянная</td>
</tr>
<tr>
<td><var>a.end()</var></td>
<td><var>iterator;</var><br><var>const_iterator</var> для постоянного <var>a</var></td>
<td>
</td>
<td>
</td>
<td>постоянная</td>
</tr>
<tr>
<td><var>a == b</var></td>
<td>обратимый в <var>bool</var></td>
<td><var>a.size() == <br>b.size() &amp;&amp;<br>equal(a.begin(),<br>a.end(),<br>b.begin())</var></td>
<td><var>==</var> - это отношение эквивалентности.<br>примечание: <var>eqial</var> определяется в разделе алгоритмов.</td>
<td>линейная</td>
</tr>
<tr>
<td><var>a != b</var></td>
<td>обратимый в <var>bool</var></td>
<td><var>!(a == b)</var></td>
<td>
</td>
<td>линейная</td>
</tr>
<tr>
<td><var>r = a</var></td>
<td><var>X&amp;</var></td>
<td><var>if(&amp;r != &amp;a) { <br>&nbsp;(&amp;r)-&gt; X::~X();<br>&nbsp;new (&amp;r) X(a);<br>&nbsp;return r; } </var></td>
<td>после: <var>r == a</var>.</td>
<td>линейнaя</td>
</tr>
<tr>
<td><var>a.size()</var></td>
<td><var>size_type</var></td>
<td><var>size_type n = 0;<br>distance<br>(a.begin(),<br>a.end(), n);<br>return n;</var></td>
<td>
</td>
<td>постоянная</td>
</tr>
<tr>
<td><var>a.max_size()</var></td>
<td><var>size_type</var></td>
<td>
</td>
<td><var>size()</var> самого большого возможного контейнера.</td>
<td>постоянная</td>
</tr>
<tr>
<td><var>a.empty()</var></td>
<td>обратимый в <var>bool</var></td>
<td><var>a.size() == 0</var></td>
<td>
</td>
<td>постоянная</td>
</tr>
<tr>
<td><var>a &lt; b</var></td>
<td>обратимый в <var>bool</var></td>
<td><var>lexicographical<br>_compare<br>(a.begin(), a.end(),<br>b.begin(), b.end()) </var></td>
<td>до: <var>&lt;</var> определён для значений <var>T</var>.<br><var>&lt;</var> - отношение полного упорядочения. <br><var>lexicographical<br>_compare</var> определяется в разделе алгоритмов.</td>
<td>линейная</td>
</tr>
<tr>
<td><var>a &gt; b</var></td>
<td>обратимый в <var>bool</var></td>
<td><var>b &lt; a</var></td>
<td>
</td>
<td>линейнaя</td>
</tr>
<tr>
<td><var>a &lt;= b </var></td>
<td>обратимый в <var>bool</var></td>
<td><var>!(a &gt; b)</var></td>
<td>
</td>
<td>линейная</td>
</tr>
<tr>
<td><var>a &gt;= b</var></td>
<td>обратимый в <var>bool</var></td>
<td><var>!(a &lt; b)</var></td>
<td>
</td>
<td>линейная</td>
</tr>
<tr>
<td><var>a.swap(b)</var></td>
<td><var>void</var></td>
<td><var>swap(a, b)</var></td>
<td>
</td>
<td>постоянная</td>
</tr>
</tbody></table>

<p class="normal_text">Функция-член <var>size()</var> возвращает число элементов в контейнере. 
Её семантика определяется правилами конструкторов, вставок и удалений.</p>
<p class="normal_text"><var>begin()</var> возвращает итератор, ссылающийся на первый элемент в 
контейнере. <var>end()</var> возвращает итератор, который является законечным.</p>
<p class="normal_text">Если тип итератора контейнера принадлежит к категории двунаправленных 
итераторов или итераторов произвольного доступа, то контейнер называется 
<var>reversible</var> (обратимым) и удовлетворяет следующим дополнительным 
требованиям:</p>

<table bordercolorlight="#808080" bordercolordark="#808080" style="border-collapse: collapse" border="1" cellpadding="5">
<caption>Таблица 9. Требования обратимых контейнеров (в дополнение к контейнерам)</caption>
<tbody><tr>
<th>выражение</th>
<th>возвращаемый тип</th>
<th>семантика исполнения</th>
<th>сложность</th>
</tr>
<tr>
<td><var>X::reverse<br>_iterator</var></td>
<td>
</td>
<td><var>reverse_iterator&lt;iterator, value_type, reference, 
difference_type&gt;</var><br>для итератора произвольного 
доступа.<br><var>reverse_bidirectional_iterator&lt;<br>iterator, value_type, 
reference, difference_type&gt;</var><br>для двунаправленного итератора </td>
<td>время компиляции</td>
</tr>
<tr>
<td><var>X::const_r<br>everse_ite<br>rator</var></td>
<td>
</td>
<td><var>reverse_iterator&lt;const_iterator, value_type, const_reference, 
difference_type&gt;</var><br>для итератора произвольного 
доступа.<br><var>reverse_bidirectional_iterator&lt;<br>const_iterator, 
value_type, const_reference, difference_type&gt;</var><br>для двунаправленного 
итератора.</td>
<td>время компиляции</td>
</tr>
<tr>
<td><var>a.rbegin()</var></td>
<td><var>reverse_iterator;<br>const_reverse_iter<br>ator</var> для постоянного 
<var>a</var></td>
<td><var>reverse_iterator(end())</var></td>
<td>постоянная</td>
</tr>
<tr>
<td><var>a.rend()</var></td>
<td><var>reverse_iterator;<br>const_reverse_iter<br>ator</var> для постоянного <var>a</var></td>
<td><var>reverse_iterator(begin())</var></td>
<td>постоянная</td>
</tr>
</tbody></table>

<h3 class="lem_sub_para2">Последовательности (Sequences)<a name="IDAMOFUJ"></a></h3>
<p class="normal_text">Последовательность - это вид контейнера, который организует конечное 
множество объектов одного и того же типа в строгом линейном порядке. Библиотека 
обеспечивает три основных вида последовательных контейнеров: <var>vector</var> 
(вектор), <var>list</var> (список) и <var>deque</var> (двусторонняя очередь). 
Она также предоставляет контейнерные адаптеры, которые облегчают создание 
абстрактных типов данных, таких как стеки или очереди, из основных видов 
последовательностей (или из других видов последовательностей, которые 
пользователь может сам определить).</p>
<p class="normal_text">В следующих двух таблицах<br>
 <var>X</var> - последовательный класс, <br>
<var>a</var> - значение <var>X</var>,<br>
 <var>i</var> и <var>j</var> удовлетворяют требованиям итераторов ввода,<br>
 <var>[i, j)</var> - допустимый диапазон, <br>
<var>n</var> - значение <var>X::size_type</var>, <br>
<var>p</var> - допустимый итератор для <var>a</var>, <br>
<var>q</var> - разыменовываемый итератор для <var>a</var>,<br>
 <var>[ql, q2)</var> - допустимый диапазон в <var>a</var>, <br>
<var>t</var> - значение <var>X::value_type</var>.</p>
<p class="normal_text">Сложности выражений зависят от последовательностей.</p>

<table bordercolorlight="#808080" bordercolordark="#808080" style="border-collapse: collapse" border="1" cellpadding="5">
<caption>Таблица 10. Требования последовательностей (в дополнение к контейнерам)</caption>
<tbody><tr>
<th>выражение</th>
<th>возвращаемый тип</th>
<th>утверждение/примечание состояние до/после</th>
</tr>
<tr>
<td><var>X(n, t)<br>X a(n, t);</var></td>
<td>
</td>
<td>после: <var>size() == n</var>.<br>создаёт последовательность с <var>n</var> копиями <var>t</var>.</td>
</tr>
<tr>
<td><var>X(i, j)<br>X a(i, j);</var></td>
<td>
</td>
<td>после: <var>size() == </var>расстоянию между <var>i</var> и 
<var>j</var>.<br>создаёт последовательность, равную диапазону <var>[i, j)</var>.</td>
</tr>
<tr>
<td><var>a.insert(p, t)</var></td>
<td><var>iterator</var></td>
<td>вставляет копию <var>t</var> перед <var>p</var>.<br>возвращаемое значение указывает на вставленную копию.</td>
</tr>
<tr>
<td><var>a.insert(p, n, t)</var></td>
<td>результат не используется</td>
<td>вставляет <var>n</var> копий <var>t</var> перед <var>p</var>.</td>
</tr>
<tr>
<td><var>a.insert(p, i, j)</var></td>
<td>результат не используется</td>
<td>вставляет копии элементов из диапазона <var>[i, j)</var> перед <var>p</var>.</td>
</tr>
<tr>
<td><var>a.erase(q)</var></td>
<td>результат не используется</td>
<td>удаляет элемент, указываемый <var>q</var>.</td>
</tr>
<tr>
<td><var>a.erase(ql, q2)</var></td>
<td>результат не используется</td>
<td>удаляет элементы в диапазоне <var>[ql, q2)</var>.</td>
</tr>
</tbody></table>

<p class="normal_text"><var>vector</var> (вектор), <var>list</var> (список) и <var>deque</var> 
(двусторонняя очередь) выдвигают программисту различные предложения сложности и 
должны использоваться соответственно. <var>vectоr</var> - тип 
последовательности, которая используется по умолчанию. <var>list</var> нужно 
использовать, когда имеются частые вставки и удаления из середины 
последовательности, <var>deque</var> - структура данных для выбора, когда 
большинство вставок и удалений происходит в начале или в конце 
последовательности.</p>
<p class="normal_text">Типы <var>iterator</var> и <var>const_iterator</var> для 
последовательностей должны быть, по крайней мере, из категории последовательных 
итераторов.</p>

<table bordercolorlight="#808080" bordercolordark="#808080" style="border-collapse: collapse" border="1" cellpadding="5">
<caption>Таблица 11. Необязательные операции последовательностей</caption>
<tbody><tr>
<th>выражение</th>
<th>возвращаемый тип</th>
<th>семантика исполнения</th>
<th>контейнер</th>
</tr>
<tr>
<td><var>a.front()</var></td>
<td><var>reference;<br>const_reference</var> для постоянного <var>a</var></td>
<td><var>*a.begin()</var></td>
<td><var>vector, list, deque</var></td>
</tr>
<tr>
<td><var>a.back()</var></td>
<td><var>reference;<br>const_reference</var> для постоянного <var>a</var></td>
<td><var>*a.(--end())</var></td>
<td><var>vector, list, deque</var></td>
</tr>
<tr>
<td><var>a.push_front(t)</var></td>
<td><var>void</var></td>
<td><var>a.insert(a.begin(), t)</var></td>
<td><var>list, deque</var></td>
</tr>
<tr>
<td><var>a.push_back(t)</var></td>
<td><var>void</var></td>
<td><var>a.insert(a.end(), t)</var></td>
<td><var>vector, list, deque</var></td>
</tr>
<tr>
<td><var>a.pop_front ()</var></td>
<td><var>void</var></td>
<td><var>a.erase(a.begin())</var></td>
<td><var>list, deque</var></td>
</tr>
<tr>
<td><var>a.pop_back ()</var></td>
<td><var>void</var></td>
<td><var>a.erase(-- a.end())</var></td>
<td><var>vector, list, deque</var></td>
</tr>
<tr>
<td><var>a[n]</var></td>
<td><var>reference;<br>const_reference</var> для постоянного <var>a</var></td>
<td><var>*(a.begin() + n)</var></td>
<td><var>vector, deque</var></td>
</tr>
</tbody></table>

<p>Все операции в расположенной выше таблице обеспечиваются только для 
контейнеров, для которых они занимают постоянное время.</p>

<h4>Вектор (Vector)</h4>
<p class="normal_text"><var>vector</var> - вид последовательности, которая поддерживает 
итераторы произвольного доступа. Кроме того, он поддерживает операции вставки и 
удаления в конце с постоянным (амортизированным) временем; вставка и удаление в 
середине занимают линейное время. Управление памятью обрабатывается 
автоматически, хотя для улучшения эффективности можно давать подсказки.</p>

<div id="IDAUYLSC">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> U&gt; <span class="KEYWORD">class</span> Allocator = allocator&gt;
<span class="KEYWORD">class</span> vector {
<span class="KEYWORD">public</span>:

<span class="COMMENT">// определения типов (typedefs):</span>

    <span class="KEYWORD">typedef</span> iterator;
    <span class="KEYWORD">typedef</span> const_iterator;
    <span class="KEYWORD">typedef</span> Allocator&lt;T&gt;::pointer pointer;
    <span class="KEYWORD">typedef</span> Allocator&lt;T&gt;::reference reference;
    <span class="KEYWORD">typedef</span> Allocator&lt;T&gt;::const_reference const_reference;
    <span class="KEYWORD">typedef</span> size_type;
    <span class="KEYWORD">typedef</span> difference_type;
    <span class="KEYWORD">typedef</span> T value_type;
    <span class="KEYWORD">typedef</span> reverse_iterator;
    <span class="KEYWORD">typedef</span> const_reverse_iterator;

<span class="COMMENT">// размещение/освобождение (allocation/deallocation):</span>

    vector();
    vector(size_type n, <span class="KEYWORD">const</span> T&amp; value = T());
    vector(<span class="KEYWORD">const</span> vector&lt;T, Allocator&gt;&amp; x);
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    vector(InputIterator first, InputIterator last);
    ~vector();
    vector&lt;T, Allocator&gt;&amp; <span class="KEYWORD">operator</span>=(<span class="KEYWORD">const</span> vector&lt;T, Allocator&gt;&amp; x);
    <span class="KEYWORD">void</span> reserve(size_type n);
    <span class="KEYWORD">void</span> swap(vector&lt;T, Allocator&gt;&amp; x);

<span class="COMMENT">// средства доступа (accessors):</span>

    iterator begin();
    const_iterator begin() <span class="KEYWORD">const</span>;
    iterator end();
    const_iterator end() <span class="KEYWORD">const</span>;
    reverse_iterator rbegin();
    const_reverse_iterator rbegin();
    reverse_iterator rend();
    const_reverse_iterator rend();
    size_type size() <span class="KEYWORD">const</span>;
    size_type max_size() <span class="KEYWORD">const</span>;
    size_type capacity() <span class="KEYWORD">const</span>;
    <span class="KEYWORD">bool</span> empty() <span class="KEYWORD">const</span>;
    reference <span class="KEYWORD">operator</span>[](size_type n);
    const_reference <span class="KEYWORD">operator</span>[](size_type n) <span class="KEYWORD">const</span>;
    reference front();
    const_reference front() <span class="KEYWORD">const</span>;
    reference back();
    const_reference back() <span class="KEYWORD">const</span>;

<span class="COMMENT">// вставка/стирание (insert/irase):</span>

    <span class="KEYWORD">void</span> push_back(<span class="KEYWORD">const</span> T&amp; x);
    iterator insert(iterator position, <span class="KEYWORD">const</span> T&amp; x = T());
    <span class="KEYWORD">void</span> insert(iterator position, size_type n, <span class="KEYWORD">const</span> T&amp; x);
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    <span class="KEYWORD">void</span> insert(iterator position, InputIterator first, InputIterator last);
    <span class="KEYWORD">void</span> pop_back();
    <span class="KEYWORD">void</span> erase(iterator position);
    <span class="KEYWORD">void</span> erase(iterator first, iterator last);
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Allocator&gt;
<span class="KEYWORD">bool operator</span>==(<span class="KEYWORD">const</span> vector&lt;T, Allocator&gt;&amp; x,
                <span class="KEYWORD">const</span> vector&lt;T, Allocator&gt;&amp; y);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Allocator&gt;
<span class="KEYWORD">bool operator</span>&lt;(<span class="KEYWORD">const</span> vector&lt;T, Allocator&gt;&amp; x,
               <span class="KEYWORD">const</span> vector&lt;T, Allocator&gt;&amp; y);
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>iterator</var> - это итератор произвольного доступа, ссылающийся на 
<var>T</var>. Точный тип зависит от исполнения и определяется в 
<var>Allocator</var>.</p>
<p class="normal_text"><var>const_iterator</var> - это постоянный итератор произвольного 
доступа, ссылающийся на <var>const T</var>. Точный тип зависит от исполнения и 
определяется в <var>Allocator</var>. Гарантируется, что имеется конструктор для 
<var>const_iterator</var> из <var>iterator</var>.</p>
<p class="normal_text"><var>size_type</var> - беззнаковый целочисленный тип. Точный тип зависит 
от исполнения и определяется в <var>Allocator</var>.</p>
<p class="normal_text"><var>difference_type</var> - знаковый целочисленный тип. Точный тип 
зависит от исполнения и определяется в <var>Allocator</var>.</p>
<p class="normal_text">Конструктор <var>template &lt;class InputIterator&gt; 
vector(InputIterator first, InputIterator last)</var> делает только <var>N</var> 
вызовов конструктора копирования <var>T</var> (где <var>N</var> - расстояние 
между <var>first</var> и <var>last</var>) и никаких перераспределений, если 
итераторы <var>first</var> и <var>last</var> относятся к последовательной, 
двунаправленной или произвольного доступа категориям. Он делает, самое большее, 
<var>2N</var> вызовов конструктора копирования <var>T</var> и <var>logN</var> 
перераспределений, если они - только итераторы ввода, так как невозможно 
определить расстояние между <var>first</var> и <var>last</var> и затем сделать 
копирование.</p>
<p class="normal_text">Функция-член <var>capasity</var> (ёмкость) возвращает размер 
распределённой памяти в векторе. Функция-член <var>reserve</var> - директива, 
которая сообщает <var>vector</var>(вектору) запланированноe изменение размера, 
так чтобы он мог соответственно управлять распределением памяти. Это не изменяет 
размер последовательности и занимает, самое большее, линейное время от размера 
последовательности. Перераспределение в этом случае происходит тогда и только 
тогда, когда текущая ёмкость меньше, чем параметр <var>reserve</var>. После 
<var>reserve</var> ёмкость (<var>capasity</var>) больше или равна параметру 
<var>reserve</var>, если происходит перераспределение; а иначе равна предыдущему 
значению <var>capasity</var>. Перераспределение делает недействительными все 
ссылки, указатели и итераторы, ссылающиеся на элементы в последовательности. 
Гарантируется, что нет никакого перераспределения во время вставок, которые 
происходят после того, как <var>reserve</var> выполняется, до времени, когда 
размер вектора достигает размера, указанного <var>reserve</var>.</p>
<p class="normal_text"><var>insert</var> (вставка) вызывает перераспределение, если новый размер 
больше, чем старая ёмкость. Если никакого перераспределения не происходит, все 
итераторы и ссылки перед точкой вставки остаются справедливыми. Вставка 
единственного элемента в вектор линейна относительно расстояния от точки вставки 
до конца вектора. Амортизированная сложность во время жизни вектора, 
вставляющего единственный элемент в свой конец, постоянна. Вставка множественных 
элементов в вектор с единственным вызовом вставляющей функции-члена линейна 
относительно суммы числа элементов плюс расстояние до конца вектора. Другими 
словами, намного быстрее вставить много элементов в середину вектора сразу, чем 
делать вставку по одному элементу. Шаблонная вставляющая функция-член 
предраспределяет достаточно памяти для вставки, если итераторы <var>first</var> 
и <var>last</var> относятся к последовательной, двунаправленной или 
произвольного доступа категориям. Иначе функция вставляет элементы один за 
другим и не должна использоваться для вставки в середину векторов.</p>
<p class="normal_text"><var>erase</var> (стирание) делает недействительными все итераторы и 
ссылки после пункта стирания. Деструктор <var>T</var> вызывается столько раз, 
каково число стёртых элементов, а оператор присваивания <var>T</var> вызывается 
столько раз, каково число элементов в векторе после стёртых элементов.</p>
<p class="normal_text">Чтобы оптимизировать распределение места, даётся определение для 
<var>bool</var>.</p>

<div id="IDA25LSC">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">class</span> vector&lt;<span class="KEYWORD">bool</span>, allocator&gt; { 
<span class="KEYWORD">public</span>:

<span class="COMMENT">// битовая ссылка (bit reference):</span>

    <span class="KEYWORD">class</span> reference { 
    <span class="KEYWORD">public</span>:
        ~reference();
        <span class="KEYWORD">operator bool</span>() <span class="KEYWORD">const</span>;
        reference&amp; <span class="KEYWORD">operator</span>=(<span class="KEYWORD">const bool</span> x);
        <span class="KEYWORD">void</span> flip();        <span class="COMMENT">// инвертирует бит (flips the bit )</span>
    };

<span class="COMMENT">// определения типов (typedefs):</span>

    <span class="KEYWORD">typedef bool</span> const_reference;
    <span class="KEYWORD">typedef</span> iterator;
    <span class="KEYWORD">typedef</span> const_iterator; 
    <span class="KEYWORD">typedef</span> size_t size_type;
    <span class="KEYWORD">typedef</span> ptrdiff_t difference_type;
    <span class="KEYWORD">typedef bool</span> value_type;
    <span class="KEYWORD">typedef</span> reverse_iterator;
    <span class="KEYWORD">typedef</span> const_reverse_iterator;

<span class="COMMENT">// размещение/освобождение (allocation/deallocation):</span>
 
    vector();
    vector(size_type n, <span class="KEYWORD">const bool</span>&amp; value = <span class="KEYWORD">bool</span>());
    vector(<span class="KEYWORD">const</span> vector&lt;<span class="KEYWORD">bool</span>, allocator&gt;&amp; x);
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    vector(InputIterator first, InputIterator last);
    ~vector();
    vector&lt;<span class="KEYWORD">bool</span>, allocator&gt;&amp; <span class="KEYWORD">operator</span>=(<span class="KEYWORD">const</span> vector&lt;<span class="KEYWORD">bool</span>, 
        allocator&gt;&amp; x);
    <span class="KEYWORD">void</span> reserve(size_type n);
    <span class="KEYWORD">void</span> swap(vector&lt;<span class="KEYWORD">bool</span>, allocator&gt;&amp; x);

<span class="COMMENT">// средства доступа (accessors):</span>

    iterator begin();
    const_iterator begin() <span class="KEYWORD">const</span>;
    iterator end();
    const_iterator end() <span class="KEYWORD">const</span>;
    reverse_iterator rbegin();
    const_reverse_iterator rbegin();
    reverse_iterator rend();
    const_reverse_iterator rend();
    size_type size() <span class="KEYWORD">const</span>;
    size_type max_size() <span class="KEYWORD">const</span>;
    size_type capacity() <span class="KEYWORD">const</span>;
    <span class="KEYWORD">bool</span> empty() <span class="KEYWORD">const</span>;
    reference <span class="KEYWORD">operator</span>[](size_type n);
    const_reference <span class="KEYWORD">operator</span>[](size_type n) <span class="KEYWORD">const</span>;
    reference front();
    const_reference front() <span class="KEYWORD">const</span>;
    reference back();
    const_reference back() <span class="KEYWORD">const</span>;

<span class="COMMENT">// вставка/стирание (insert/irase):</span>

    <span class="KEYWORD">void</span> push_back(<span class="KEYWORD">const bool</span>&amp; x);
    iterator insert(iterator position, <span class="KEYWORD">const bool</span>&amp; x = <span class="KEYWORD">bool</span>());
    <span class="KEYWORD">void</span> insert(iterator position, size_type n, <span class="KEYWORD">const bool</span>&amp; x);
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    <span class="KEYWORD">void</span> insert(iterator position, InputIterator first, InputIterator last);
    <span class="KEYWORD">void</span> pop_back();
    <span class="KEYWORD">void</span> erase(iterator position);
    <span class="KEYWORD">void</span> erase(iterator first, iterator last);
};

<span class="KEYWORD">void</span> swap(vector&lt;<span class="KEYWORD">bool</span>, allocator&gt;::reference x, 
          vector&lt;<span class="KEYWORD">bool</span>, allocator&gt;::reference y);

<span class="KEYWORD">bool operator</span>==(<span class="KEYWORD">const</span> vector&lt;<span class="KEYWORD">bool</span>, allocator&gt;&amp; x,
                <span class="KEYWORD">const</span> vector&lt;<span class="KEYWORD">bool</span>, allocator&gt;&amp; y);

<span class="KEYWORD">bool operator</span>&lt;(<span class="KEYWORD">const</span> vector&lt;<span class="KEYWORD">bool</span>, allocator&gt;&amp; x,
               <span class="KEYWORD">const</span> vector&lt;<span class="KEYWORD">bool</span>, allocator&gt;&amp; y);
</pre>
</td></tr></tbody></table>
</div>

<p><var>reference</var> - класс, который имитирует поведение ссылок 
отдельного бита в <var>vector&lt;<span class="KEYWORD">bool</span>&gt;</var>.</p>
<p>Ожидается, что каждое исполнение обеспечит определение 
<var>vector&lt;<span class="KEYWORD">bool</span>&gt;</var> для всех поддерживаемых моделей памяти.</p>

<center>
<table border="0" cellpadding="5" cellspacing="2">
<tbody><tr>
<td>Сейчас невозможно шаблонизировать определение. То есть мы не можем написать: 
<pre>    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> U&gt; <span class="KEYWORD">class</span> Allocator == allocator&gt; 
    <span class="KEYWORD">class</span> vector&lt;<span class="KEYWORD">bool</span>, Allocator&gt; { <span class="COMMENT">/* ... */</span> };
</pre>
Поэтому обеспечивается только <var>vector&lt;bool, Allocator&gt;</var>. 
</td>
</tr>
</tbody></table>
</center>


<h4 class="lem_sub_para2">Список (List)</h4>
<p class="normal_text"><var>list</var> - вид последовательности, которая поддерживает 
двунаправленные итераторы и позволяет операции вставки и стирания с постоянным 
временем в любом месте последовательности, с управлением памятью, обрабатываемым 
автоматически. В отличие от векторов и двусторонних очередей, быстрый 
произвольный доступ к элементам списка не поддерживается, но многим алгоритмам, 
во всяком случае, только и нужен последовательный доступ.</p>

<div id="IDAFG2AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> U&gt; <span class="KEYWORD">class</span> Allocator = allocator&gt;
<span class="KEYWORD">class</span> list {
<span class="KEYWORD">public</span>:

<span class="COMMENT">// определения типов:</span>

    <span class="KEYWORD">typedef</span> iterator;
    <span class="KEYWORD">typedef</span> const_iterator;
    <span class="KEYWORD">typedef</span> Allocator&lt;T&gt;::pointer pointer;
    <span class="KEYWORD">typedef</span> Allocator&lt;T&gt;::reference reference;
    <span class="KEYWORD">typedef</span> Allocator&lt;T&gt;::const_reference const_reference;
    <span class="KEYWORD">typedef</span> size_type;
    <span class="KEYWORD">typedef</span> difference_type;
    <span class="KEYWORD">typedef</span> Т value_type;
    <span class="KEYWORD">typedef</span> reverse_iterator;
    <span class="KEYWORD">typedef</span> const_reverse_iterator;

<span class="COMMENT">// размещение/удаление:</span>

    list()
    list(size_type n, <span class="KEYWORD">const</span> T&amp; value = T());
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    list(InputIterator first, InputIterator last);
    list(<span class="KEYWORD">const</span> list&lt;T, Allocator&gt;&amp; x) ;
    ~list();
    list&lt;T, Allocator&gt;&amp; <span class="KEYWORD">operator</span>=(<span class="KEYWORD">const</span> list&lt;T,Allocator&gt;&amp; x);
    <span class="KEYWORD">void</span> swap(list&lt;T, Allocator&amp; x);
 
<span class="COMMENT">// средства доступа:</span>

    iterator begin();
    const_iterator begin() <span class="KEYWORD">const</span>;
    iterator end();
    const_iterator end() <span class="KEYWORD">const</span>;
    reverse_iterator rbegin();
    const_reverse_iterator rbegin();
    reverse_iterator rend();
    const_reverse_iterator rend();
    <span class="KEYWORD">bool</span> empty() <span class="KEYWORD">const</span>;
    size_type size() <span class="KEYWORD">const</span>;
    size_type max_size() <span class="KEYWORD">const</span>;
    reference front();
    const_reference front() <span class="KEYWORD">const</span>;
    reference back();
    const_reference back() <span class="KEYWORD">const</span>;

<span class="COMMENT">// вставка/стирание:</span>

    <span class="KEYWORD">void</span> push_front(<span class="KEYWORD">const</span> T&amp; x);
    <span class="KEYWORD">void</span> push_back(<span class="KEYWORD">const</span> T&amp; x);
    iterator insert(iterator position, <span class="KEYWORD">const</span> T&amp; x = T());
    <span class="KEYWORD">void</span> insert(iterator position, size_type n, <span class="KEYWORD">const</span> T&amp; x);
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    <span class="KEYWORD">void</span> insert(iterator position, InputIterator first, InputIterator last);
    <span class="KEYWORD">void</span> pop_front();
    <span class="KEYWORD">void</span> pop_back();
    <span class="KEYWORD">void</span> erase(iterator position);
    <span class="KEYWORD">void</span> erase(iterator first, iterator last);

<span class="COMMENT">// специальные модифицирующие операции cо списком:</span>

    <span class="KEYWORD">void</span> splice(iterator position, list&lt;T, Allocator&gt;&amp; x);
    <span class="KEYWORD">void</span> splice(iterator position, list&lt;T, Allocator&gt;&amp; x, 
        iterator i);
    <span class="KEYWORD">void</span> splice(iterator position, list&lt;T, Allocator&gt;&amp; x, 
        iterator first, iterator last);
    <span class="KEYWORD">void</span> remove(<span class="KEYWORD">const</span> T&amp; value);
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Predicate&gt; <span class="KEYWORD">void</span> remove_if(Predicate pred);
    <span class="KEYWORD">void</span> unique();
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BinaryPredicate&gt; <span class="KEYWORD">void</span> unique(BinaryPredicate 
        binary_pred);
    <span class="KEYWORD">void</span> merge(list&lt;T, Allocator&gt;&amp; x);
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Compare&gt; <span class="KEYWORD">void</span> merge(list&lt;T,Allocator&gt;&amp; x, 
        Compare comp);
    <span class="KEYWORD">void</span> reverse();
    <span class="KEYWORD">void</span> sort();
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Compare&gt; <span class="KEYWORD">void</span> sort(Compare comp);
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Allocator&gt; 
<span class="KEYWORD">bool operator</span>==(<span class="KEYWORD">const</span> list&lt;T, Allocator&gt;&amp; x, <span class="KEYWORD">const</span> list&lt;T,
                Allocator&gt;&amp; y);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Allocator&gt;
<span class="KEYWORD">bool operator</span>&lt;(<span class="KEYWORD">const</span> list&lt;T, Allocator&gt;&amp; x, <span class="KEYWORD">const</span> list&lt;T,
               Allocator&gt;&amp; y);
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>iterator</var> - двунаправленный итератор, ссылающийся на 
<var>T</var>. Точный тип зависит от исполнения и определяется в 
<var>Allocator</var>.</p>
<p class="normal_text"><var>const_iterator</var> - постоянный двунаправленный итератор, 
ссылающийся на <var>const T</var>. Точный тип зависит от исполнения и 
определяется в <var>Allocator</var>. Гарантируется, что имеется конструктор для 
<var>const_iterator</var> из <var>iterator</var>.</p>
<p class="normal_text"><var>size_type</var> - беззнаковый целочисленный тип. Точный тип зависит 
от исполнения и определяется в <var>Allocator</var>.</p>
<p class="normal_text"><var>difference_type</var> - знаковый целочисленный тип. Точный тип 
зависит от исполнения и определяется в <var>Allocator</var>.</p>
<p class="normal_text"><var>insert</var> не влияет на действительность итераторов и ссылок. 
Вставка единственного элемента в список занимает постоянное время, и ровно один 
раз вызывается конструктор копирования <var>T</var>. Вставка множественных 
элементов в список зависит линейно от числа вставленных элементов, а число 
вызовов конструктора копирования <var>T</var> точно равно числу вставленных 
элементов.</p>
<p class="normal_text"><var>erase</var> делает недействительными только итераторы и ссылки для 
стёртых элементов. Стирание единственного элемента - операция постоянного 
времени с единственным вызовом деструктора <var>T</var>. Стирание диапазона в 
списке занимает линейное время от размера диапазона, а число вызовов деструктора 
типа <var>T</var> точно равно размеру диапазона.</p>
<p class="normal_text">Так как списки позволяют быструю вставку и стирание в середине списка, то 
некоторые операции определяются специально для них:</p>
<p class="normal_text"><var>list</var> обеспечивает три операции стыковки, которые разрушительно 
перемещают элементы из одного списка в другой:</p>
<p class="normal_text"><var>void splice(iterator position, list&lt;T, Allocator&gt;&amp; 
x)</var> вставляет содержимое <var>x</var> перед <var>position</var>, и 
<var>x</var> становится пустым. Требуется постоянное время. Результат не 
определён, если <var>&amp;x == this</var>.</p>
<p class="normal_text"><var>void splice(iterator position, list&lt;T, Allocator&gt;&amp; x, 
iterator i)</var> вставляет элемент, указываемый <var>i</var>, из списка 
<var>x</var> перед <var>position</var> и удаляет элемент из <var>x</var>. 
Требуется постоянное время. <var>i</var> - допустимый разыменовываемый итератор 
списка <var>x</var>. Результат не изменяется, если <var>position == i</var> или 
<var>position == ++i</var>.</p>
<p class="normal_text"><var>void splice(iterator position, list&lt;T, Allocator&gt;&amp; x, 
iterator first, iterator last)</var> вставляет элементы из диапазона 
<var>[first, last)</var> перед <var>position</var> и удаляет элементы из 
<var>x</var>. Требуется постоянное время, если <var>&amp;x == this</var>; иначе 
требуется линейное время. <var>[first, last)</var> - допустимый диапазон в 
<var>x</var>. Результат не определён, если <var>position</var> - итератор в 
диапазоне <var>[first, last)</var>.</p>
<p class="normal_text"><var>remove</var> стирает все элементы в списке, указанном итератором 
списка <var>i</var>, для которого выполняются следующие условия: <var>*i == 
value</var>, <var>pred(*i) == true</var>. <var>remove</var> устойчиво, то есть 
относительный порядок элементов, которые не удалены, тот же самый, как их 
относительный порядок в первоначальном списке. Соответствующий предикат 
применяется точно <var>size()</var> раз.</p>
<p class="normal_text"><var>unique</var> стирает все, кроме первого элемента, из каждой 
последовательной группы равных элементов в списке. Соответствующий бинарный 
предикат применяется точно <var>size() - 1 </var>раз.</p>
<p class="normal_text"><var>merge</var> сливает список аргумента со списком (предполагается, что 
оба сортированы). Слияние устойчиво, то есть для равных элементов в двух списках 
элементы списка всегда предшествуют элементам из списка аргумента. <var>x</var> 
пуст после слияния. Выполняется, самое большее, <var>size() + x.size() - 1</var> 
сравнений.</p>
<p class="normal_text"><var>reverse</var> переставляет элементы в списке в обратном порядке. 
Операция линейного времени.</p>
<p class="normal_text"><var>sort</var> сортирует список согласно <var>operator&lt;</var> или 
сравнивающему функциональному объекту. Она устойчива, то есть относительный 
порядок равных элементов сохраняется. Выполняется приблизительно 
<var>NlogN</var> сравнений, где <var>N</var> равно <var>size()</var>.</p>


<h4 class="lem_sub_para2">Двусторонняя очередь (Deque)</h4>
<p class="normal_text"><var>deque</var> - вид последовательности, которая, подобно вектору, 
поддерживает итераторы произвольного доступа. Кроме того она поддерживает 
операции вставки и стирания в начале или в конце за постоянное время; вставка и 
стирание в середине занимают линейное время. Как с векторами, управление памятью 
обрабатывается автоматически.</p>

<div id="IDATQ2AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> U&gt; <span class="KEYWORD">class</span> Allocator = allocator&gt;
<span class="KEYWORD">class</span> deque {
<span class="KEYWORD">public</span>:

<span class="COMMENT">// typedefs:</span>

    <span class="KEYWORD">typedef</span> iterator;
    <span class="KEYWORD">typedef</span> const_iterator;
    <span class="KEYWORD">typedef</span> Allocator&lt;T&gt;::pointer pointer; 
    <span class="KEYWORD">typedef</span> Allocator&lt;T&gt; ::reference reference;
    <span class="KEYWORD">typedef</span> Allocator&lt;T&gt;::const_reference const_reference;
    <span class="KEYWORD">typedef</span> size_type;
    <span class="KEYWORD">typedef</span> difference_type;
    <span class="KEYWORD">typedef</span> Т value_type;
    <span class="KEYWORD">typedef</span> reverse_iterator;
    <span class="KEYWORD">typedef</span> const_revcrse_iterator;

<span class="COMMENT">// размещение/удаление:</span>

    deque();
    deque(size_type n, <span class="KEYWORD">const</span> T&amp; value = T()); 
    deque(<span class="KEYWORD">const</span> deque&lt;T, Allocator&gt;&amp; x);
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    deque(InputIterator first, InputIterator last);
    ~deque();
    deque&lt;T, Allocator&gt;&amp; <span class="KEYWORD">operator</span>=(<span class="KEYWORD">const</span> deque&lt;T,Allocator&gt;&amp; x);
    <span class="KEYWORD">void</span> swap(deque&lt;T, Allocator&gt;&amp; x);

<span class="COMMENT">// средства доступа:</span>

    iterator begin();
    const_iterator begin() <span class="KEYWORD">const</span>;
    iterator end();
    const_iterator end() <span class="KEYWORD">const</span>;
    reverse_iterator rbegin();
    const_reverse_iterator rbegin();
    reverse_iterator rend();
    const_reverse_iterator rend();
    size_type size() <span class="KEYWORD">const</span>;
    size_type max_size() <span class="KEYWORD">const</span>;
    <span class="KEYWORD">bool</span> empty() <span class="KEYWORD">const</span>;
    reference <span class="KEYWORD">operator</span>[](size_type n);
    const_reference <span class="KEYWORD">operator</span>[](size_type n) <span class="KEYWORD">const</span>;
    reference front();
    const_reference front() <span class="KEYWORD">const</span>;
    reference back();
    const_reference back() <span class="KEYWORD">const</span>;

<span class="COMMENT">// вставка/стирание:</span>

    <span class="KEYWORD">void</span> push_front(<span class="KEYWORD">const</span> T&amp; x);
    <span class="KEYWORD">void</span> push_back(<span class="KEYWORD">const</span> T&amp; x);
    iterator insert(iterator position, <span class="KEYWORD">const</span> T&amp; x = T());
    <span class="KEYWORD">void</span> insert(iterator position, size_type n, <span class="KEYWORD">const</span> T&amp; x);
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    <span class="KEYWORD">void</span> insert(iterator position, InputIterator first, InputIterator last);
    <span class="KEYWORD">void</span> pop_front();
    <span class="KEYWORD">void</span> pop_back();
    <span class="KEYWORD">void</span> erase(iterator position);
    <span class="KEYWORD">void</span> erase(iterator first, iterator last);
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Allocator&gt;
<span class="KEYWORD">bool operator</span>==(<span class="KEYWORD">const</span> deque&lt;T, Allocator&gt;&amp; x, <span class="KEYWORD">const</span> deque&lt;T,
        Allocator&gt;&amp; y);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Allocator&gt;
<span class="KEYWORD">bool operator</span>&lt;(<span class="KEYWORD">const</span> deque&lt;T, Allocator&gt;&amp; x, <span class="KEYWORD">const</span> deque&lt;T,
        Allocator&gt;&amp; y);
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>iterator</var> - итератор произвольного доступа, ссылающийся на 
<var>T</var>. Точный тип зависит от исполнения и определяется в 
<var>Allocator</var>.</p>
<p class="normal_text"><var>const_iterator</var> - постоянный итератор произвольного доступа, 
ссылающийся на <var>const T</var>. Точный тип зависит от исполнения и 
определяется в <var>Allocator</var>. Гарантируется, что имеется конструктор для 
<var>const_iterator</var> из <var>iterator</var>.</p>
<p class="normal_text"><var>size_type</var> - беззнаковый целочисленный тип. Точный тип зависит 
от исполнения и определяется в <var>Allocator</var>.</p>
<p class="normal_text"><var>difference_type</var> - знаковый целочисленный тип. Точный зависит 
от исполнения и определяется в <var>Allocator</var>.</p>
<p class="normal_text"><var>insert</var> (вставка) в середину двусторонней очереди делает 
недействительными все итераторы и ссылки двусторонней очереди. <var>insert</var> 
и <var>push</var> (помещение) с обоих концов двусторонней очереди делают 
недействительными все итераторы двусторонней очереди, но не влияют на 
действительность всех ссылок на двустороннюю очередь. В худшем случае вставка 
единственного элемента в двустороннюю очередь занимает линейное время от 
минимума двух расстояний: от точки вставки - до начала и до конца двусторонней 
очереди. Вставка единственного элемента либо в начало, либо в конец двусторонней 
очереди всегда занимает постоянное время и вызывает единственный запрос 
конструктора копии <var>T</var>. То есть двусторонняя очередь особенно 
оптимизирована для помещения и извлечения элементов в начале и в конце.</p>
<p class="normal_text"><var>erase</var> (стирание) в середине двусторонней очереди делает 
недействительными все итераторы и ссылки двусторонней очереди. <var>erase</var> 
и <var>pop</var> (извлечение) с обоих концов двусторонней очереди делают 
недействительными только итераторы и ссылки на стёртый элемент. Число вызовов 
деструктора равно числу стёртых элементов, а число вызовов оператора 
присваивания равно минимуму из числа элементов перед стёртыми элементами и числа 
элементов после стёртых элементов.</p>



<h3 class="lem_sub_para2">Ассоциативные контейнеры (Associative containers)<a name="IDALW2AG"></a></h3>
<p class="normal_text">Ассоциативные контейнеры обеспечивают быстрый поиск данных, основанных на 
ключах. Библиотека предоставляет четыре основных вида ассоциативных контейнеров: 
<var>set</var> (множество), <var>multiset</var> (множество с дубликатами), 
<var>map</var> (словарь) и <var>multimap</var> (словарь с дубликатами). </p>

<p class="normal_text">Все они берут в качестве параметров <var>Key</var> (ключ) и 
упорядочивающее отношение <var>Compare</var>, которое вызывает полное 
упорядочение по элементам <var>Key</var>. Кроме того, <var>map</var> и 
<var>multimap</var> ассоциируют произвольный тип <var>T</var> с <var>Key</var>. 
Объект типа <var>Compare</var> называется <i>сравнивающим объектом</i> 
(<i>comparison object</i>) контейнера. </p>

<p class="normal_text">В этом разделе, когда мы говорим о равенстве ключей, мы подразумеваем 
отношение эквивалентности, обусловленное сравнением и <i>не</i> (<i>not</i>) 
<var>operator==</var> для ключей. То есть считается, что два ключа <var>k1</var> 
и <var>k2</var> являются равными, если для сравнивающего объекта <var>comp</var> 
истинно <var>comp(k1, k2) == false &amp;&amp; comp(k2, k1) == false</var>. </p>

<p class="normal_text">Ассоциативный контейнер поддерживает <i>уникальные ключи</i> (<i>unique 
keys</i>), если он может содержать, самое большее, один элемент для каждого 
значения ключа. Иначе он поддерживает <i>равные ключи</i> (<i>equal keys</i>). 
<var>set</var> и <var>map</var> поддерживают уникальные ключи. 
<var>multiset</var> и <var>multimap</var> поддерживают равные ключи. </p>

<p class="normal_text">Для <var>set</var> и <var>multiset</var> значимый тип - тот же самый, что 
и тип ключа. Для <var>map</var> и <var>multimap</var> он равен 
<var>pair&lt;const Key, T&gt;</var>. </p>

<p class="normal_text"><var>iterator</var> ассоциативного контейнера относится к категории 
двунаправленного итератора. <var>insert</var> не влияет на действительность 
итераторов и ссылок контейнера, а <var>erase</var> делает недействительными 
только итераторы и ссылки на стёртые элементы. </p>

<p class="normal_text">В следующей таблице обозначается: <br>
<var>X</var> - класс ассоциативного контейнера, <br>
<var>a</var> - значение <var>X</var>, <br>
<var>a_uniq</var> - значение <var>X</var>, когда <var>X</var> поддерживает уникальные ключи, <br>
a <var>a_eq</var> - значение <var>X</var>, когда <var>X</var> поддерживает многократные ключи, <br>
<var>i</var> и <var>j</var> удовлетворяют требованиям итераторов ввода и указывают на элементы <var>value_type</var>,<br>
 <var>[i, j)</var> - допустимый диапазон,<br>
 <var>p</var> - допустимый итератор для <var>a</var>, <br>
 <var>q</var> - разыменовываемый итератор для <var>a</var>, <br>
<var>[q1, q2)</var> - допустимый диапазон в <var>a</var>,<br>
 <var>t</var> - значение <var>X::value_type</var><br>
 и <var>k</var> - значение <var>X::key_type</var>. </p><br>

<table bordercolorlight="#808080" bordercolordark="#808080" style="border-collapse: collapse" border="1" cellpadding="5">
<caption>Таблица 12. Требования ассоциативных контейнеров (в дополнение к контейнерам)</caption>
<tbody><tr>
<th>выражение</th>
<th>возвращаемый тип</th>
<th>утверждение/примечание состояние до/после</th>
<th>сложность</th>
</tr>
<tr>
<td><var>X::key_type</var></td>
<td><var>Key</var></td>
<td>
</td>
<td>время компиляции</td>
</tr>
<tr>
<td><var>X::key_compare</var></td>
<td><var>Compare</var></td>
<td>по умолчанию <var>less&lt;key_type&gt;</var>.</td>
<td>время компиляции</td>
</tr>
<tr>
<td><var>X::value_compare</var></td>
<td>тип бинарного предиката</td>
<td>то же, что <var>key_compare</var> для <var>set</var> и 
<var>multiset</var>; <br>отношение упорядочения пар, вызванное первым 
компонентом (т.е. <var>Key</var>), для <var>map</var> и <var>multimap</var>.</td>
<td>время компиляции</td>
</tr>
<tr>
<td><var>X(c)<br>X a(c);</var></td>
<td>
</td>
<td>создает пустой контейнер; <br>использует <var>с</var> как объект сравнения.</td>
<td>постоянная</td>
</tr>
<tr>
<td><var>X()<br>X a;</var></td>
<td>
</td>
<td>создает пустой контейнер; <br>использует <var>Compare()</var> как объект сравнения.</td>
<td>постоянная</td>
</tr>
<tr>
<td><var>X(i,j,c) <br>X a(i,j,c);</var></td>
<td>
</td>
<td>cоздает пустой контейнер и вставляет в него элементы из диапазона 
<var>[i, j)</var>;<br>использует <var>с</var> как объект сравнения.</td>
<td>вообще <var>NlogN</var> (<var>N</var> - расстояние от 
<var>i</var> до <var>j</var>); <br>линейная, если <var>[i, j)</var> отсортирован 
<var>value_comp()</var></td>
</tr>
<tr>
<td><var>X(i,j)<br>X a(i,j);</var></td>
<td>
</td>
<td>то же, что выше, но использует <var>Compare()</var> как объект сравнения.</td>
<td>то же, что выше</td>
</tr>
<tr>
<td><var>a.key_comp()</var></td>
<td><var>X::key_compare</var></td>
<td>возвращает объект сравнения, из которого <var>а</var> был создан.</td>
<td>постоянная</td>
</tr>
<tr>
<td><var>a.value_comp()</var></td>
<td><var>X::value_compare</var></td>
<td>возвращает объект <var>value_compare</var>, созданный из объекта сравнения.</td>
<td>постоянная</td>
</tr>
<tr>
<td><var>a_uniq.insert(t)</var></td>
<td><var>pair&lt;iterator, bool&gt;</var></td>
<td>вставляет <var>t</var>, если и только если в контейнере нет 
элемента с ключом, равным ключу <var>t</var>. Компонент <var>bool</var> 
возвращенной пары показывает, происходит ли вставка, а компонент пары 
<var>iterator</var> указывает на элемент с ключом, равным ключу <var>t</var>.</td>
<td>логарифмическая</td>
</tr>
<tr>
<td><var>a_eq.insert(t)</var></td>
<td><var>iterator</var></td>
<td>вставляет <var>t</var> и возвращает итератор, указывающий на вновь вставленный элемент.</td>
<td>логарифмическая</td>
</tr>
<tr>
<td><var>a.insert(p, t)</var></td>
<td><var>iterator</var></td>
<td>вставляет <var>t</var>, если и только если в контейнерах с 
уникальными ключами нет элемента с ключом, равным ключу <var>t</var>; всегда 
вставляет <var>t</var> в контейнеры с дубликатами. <br>всегда возвращает 
итератор, указывающий на элемент с ключом, равным ключу <var>t</var>. итератор 
<var>p</var> - подсказка, указывающая, где вставка должна начать поиск.</td>
<td>вообще логарифмическая, но сводится к постоянной, если 
<var>t</var> вставлен прямо перед <var>p</var>.</td>
</tr>
<tr>
<td><var>a.insert(i, j)</var></td>
<td>результат не используется</td>
<td>вставляет в контейнер элементы из диапазона <var>[i, j)</var>;</td>
<td>вообще <var>Nlog(size()+N)</var> (<var>N</var> - расстояние от 
<var>i</var> до <var>j</var>); <br>линейная, если <var>[i, j)</var> отсортирован 
согласно <var>value_comp()</var></td>
</tr>
<tr>
<td><var>a.erase(k)</var></td>
<td><var>size_type</var></td>
<td>стирает все элементы в контейнере с ключом, равным <var>k</var>.<br>возвращает число уничтоженных элементов.</td>
<td><var>log(size()) + count(k)</var></td>
</tr>
<tr>
<td><var>a.erase(q)</var></td>
<td>результат не используется</td>
<td>стирает элемент, указанный <var>q</var>.</td>
<td>сводится к постоянной</td>
</tr>
<tr>
<td><var>a.erase(ql, q2)</var></td>
<td>результат не используется</td>
<td>стирает все элементы в диапазоне <var>[ql, q2)</var>.</td>
<td><var>log(size())+ N</var>, где <var>N</var> - расстояние от <var>ql</var> до <var>q2</var>.</td>
</tr>
<tr>
<td><var>a.find(k) </var></td>
<td><var>iterator;</var><br><var>const_iterator</var> для константы <var>a</var></td>
<td>возвращает итератор, указывающий на элемент с ключом, равным 
<var>k</var>, или <var>a.end()</var>, если такой элемент не найден.</td>
<td>логарифмическая</td>
</tr>
<tr>
<td><var>a.count(k)</var></td>
<td><var>size_type</var></td>
<td>возвращает число элементов с ключом, равным <var>k</var>.</td>
<td><var>log(size()) + count(k)</var></td>
</tr>
<tr>
<td><var>a.lower_bound(k)</var></td>
<td><var>iterator;</var> <br><var>const_iterator</var> для константы <var>a</var></td>
<td>возвращает итератор, указывающий на первый элемент с ключом не 
меньше, чем <var>k</var>.</td>
<td>логарифмическая</td>
</tr>
<tr>
<td><var>a.upper_bound(k)</var></td>
<td><var>iterator;</var><br><var>const_iterator</var> для константы <var>a</var></td>
<td>возвращает итератор, указывающий на первый элемент с ключом 
больше, чем <var>k</var>.</td>
<td>логарифмическая</td>
</tr>
<tr>
<td><var>a.equal_range(k)</var></td>
<td><var>pair&lt;iterator, itеrator&gt;;</var><br><var>pair&lt;const_iter<br>ator, const_iterator&gt;</var> 
для константы <var>a</var></td>
<td>эквивалент <var>make_pair(lower_boud(k), upper_bound (k))</var>.</td>
<td>логарифмическая</td>
</tr>
</tbody></table>

<p class="normal_text">Основным свойством итераторов ассоциативных контейнеров является то, что 
они выполняют итерации через контейнеры в порядке неубывания ключей, где 
неубывание определено сравнением, которое использовалось для их создания. Для 
любых двух разыменованных итераторов <var>i</var> и <var>j</var> таких, что 
расстояние от <var>i</var> до <var>j</var> является положительным, 
<var>value_comp (*j, *i) == false</var>. Для ассоциативных контейнеров с 
уникальными ключами выдерживается более сильное условие <var>value_comp (*i, *j) 
== true</var>.</p>

<h4 class="lem_sub_para2">Множество (Set)</h4>

<p class="normal_text"><var>set</var> - это ассоциативный контейнер, который поддерживает 
уникальные ключи (не содержит ключи с одинаковыми значениями) и обеспечивает 
быстрый поиск ключей.</p>

<div id="IDAKI3AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Key, <span class="KEYWORD">class</span> Compare = less&lt;Key&gt;,
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> U&gt; <span class="KEYWORD">class</span> Allocator = allocator&gt; 
<span class="KEYWORD">class</span> set { 
<span class="KEYWORD">public</span>:

<span class="COMMENT">// typedefs:</span>

    <span class="KEYWORD">typedef</span> Key key_type;
    <span class="KEYWORD">typedef</span> Key value_type;
    <span class="KEYWORD">typedef</span> Allocator&lt;Key&gt;::pointer pointer;
    <span class="KEYWORD">typedef</span> Allocator&lt;Key&gt;::reference reference;
    <span class="KEYWORD">typedef</span> Allocator&lt;Key&gt;::const_reference const_reference;
    <span class="KEYWORD">typedef</span> Compare key_compare;
    <span class="KEYWORD">typedef</span> Compare value_compare;
    <span class="KEYWORD">typedef</span> iterator;
    <span class="KEYWORD">typedef</span> iterator const_iterator;
    <span class="KEYWORD">typedef</span> size_type;
    <span class="KEYWORD">typedef</span> difference_type;
    <span class="KEYWORD">typedef</span> reverse_iterator;
    <span class="KEYWORD">typedef</span> const_reverse_iterator;

<span class="COMMENT">// allocation/deallocation:</span>

    set(<span class="KEYWORD">const</span> Compare&amp; comp = Compare());
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt; 
    set(InputIterator first, InputIterator last,
        <span class="KEYWORD">const</span> Compare&amp; comp = Compare());
    set(<span class="KEYWORD">const</span> set&lt;Key, Compare, Allocator&gt;&amp; x);
    ~set();
    set&lt;Key, Compare, Allocator&gt;&amp; <span class="KEYWORD">operator</span>=(<span class="KEYWORD">const</span> set&lt;Key, Compare,
        Allocator&gt;&amp; x);
    <span class="KEYWORD">void</span> swap(set&lt;Key, Compare, Allocator&gt;&amp; x);

<span class="COMMENT">// accessors:</span>

    key_compare key_comp() <span class="KEYWORD">const</span>;
    value_compare value_comp() <span class="KEYWORD">const</span>;
    iterator begin() <span class="KEYWORD">const</span>;
    iterator end() <span class="KEYWORD">const</span>;
    reverse_iterator rbegin() <span class="KEYWORD">const</span>;
    reverse_iterator rend() <span class="KEYWORD">const</span>;
    <span class="KEYWORD">bool</span> empty() <span class="KEYWORD">const</span>;
    size_type size() <span class="KEYWORD">const</span>;
    size_type max_size() <span class="KEYWORD">const</span>;

<span class="COMMENT">// insert/erase</span>

    pair&lt;iterator, <span class="KEYWORD">bool</span>&gt; insert(<span class="KEYWORD">const</span> value_type&amp; x);
    iterator insert(iterator position, <span class="KEYWORD">const</span> value_type&amp; x);
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    <span class="KEYWORD">void</span> insert(InputIterator first, InputIterator last);
    <span class="KEYWORD">void</span> erase(iterator position);
    size_type erase(<span class="KEYWORD">const</span> key_type&amp; x);
    <span class="KEYWORD">void</span> erase(iterator first, iterator last);

<span class="COMMENT">// set operations:</span>

    iterator find(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    size_type count(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    iterator lower_bound(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    iterator upper_bound(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    pair&lt;iterator, iterator&gt; equal_range(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Key, <span class="KEYWORD">class</span> Compare, <span class="KEYWORD">class</span> Allocator&gt; 
<span class="KEYWORD">bool operator</span>==(<span class="KEYWORD">const</span> set&lt;Key, Compare, Allocator&gt;&amp; x,
    <span class="KEYWORD">const</span> set&lt;Key, Compare, Allocator&gt;&amp; y);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Key, <span class="KEYWORD">class</span> Compare, <span class="KEYWORD">class</span> Allocator&gt; 
<span class="KEYWORD">bool operator</span>&lt;(<span class="KEYWORD">const</span> set&lt;Key, Compare, Allocator&gt;&amp; x, 
    <span class="KEYWORD">const</span> set&lt;Key, Compare, Allocator&gt;&amp; y);
</pre>
</td></tr></tbody></table>
</div>
    
<p><var>iterator</var> - постоянный двунаправленный итератор, указывающий 
на <var>const value_type.</var> Точный тип зависит от реализации и определяется 
в <var>Allocator</var>. </p>
<p><var>сonst_iterator</var> - тот же самый тип, что и <var>iterator.</var></p>
<p><var>size_type</var> - целочисленный тип без знака. Точный тип зависит 
от реализации и определяется в <var>Allocator</var>. </p>
<p><var>difference_type</var> - целочисленный тип со знаком. Точный тип 
зависит от реализации и определяется в <var>Allocator</var>. </p>


<h4 class="lem_sub_para2">Множество с дубликатами (Multiset)</h4>
<p class="normal_text"><var>multiset</var> - это ассоциативный контейнер, который поддерживает 
равные ключи (возможно, содержит множественные копии того же самого значения 
ключа) и обеспечивает быстрый поиск ключей. </p>

<div id="IDAHO3AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Key, <span class="KEYWORD">class</span> Compare = less&lt;Key&gt;,
        <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> U&gt; <span class="KEYWORD">class</span> Allocator = allocator&gt;
<span class="KEYWORD">class</span> multiset { 
<span class="KEYWORD">public</span>:

<span class="COMMENT">// typedefs:</span>

    <span class="KEYWORD">typedef</span> Key key_type;
    <span class="KEYWORD">typedef</span> Key value_type;
    <span class="KEYWORD">typedef</span> Allocator&lt;Key&gt;::pointer pointer;
    <span class="KEYWORD">typedef</span> Aliocator&lt;Key&gt;::reference reference;
    <span class="KEYWORD">typedef</span> Allocator&lt;Key&gt;::const_reference const_reference;
    <span class="KEYWORD">typedef</span> Compare key_compare;
    <span class="KEYWORD">typedef</span> Compare value_compare;
    <span class="KEYWORD">typedef</span> iterator;
    <span class="KEYWORD">typedef</span> iterator const_iterator;
    <span class="KEYWORD">typedef</span> size_type;
    <span class="KEYWORD">typedef</span> difference_type;
    <span class="KEYWORD">typedef</span> reverse_iterator;
    <span class="KEYWORD">typedef</span> const_reverse_iterator;

<span class="COMMENT">// allocation/deallocation:</span>

    multiset(<span class="KEYWORD">const</span> Compare&amp; comp = Compare());
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    multiset(InputIterator first, InputIterator last,
        <span class="KEYWORD">const</span> Compare&amp; comp == Compare());
    multiset(<span class="KEYWORD">const</span> multiset&lt;Key, Compare, Allocator&gt;&amp; x);
    ~multiset();
    multiset&lt;Key, Compare, Allocator&gt;&amp; <span class="KEYWORD">operator</span>=(<span class="KEYWORD">const</span> multiset&lt;Key,
            Compare, Allocator&gt;&amp; x);
    <span class="KEYWORD">void</span> swap(multiset&lt;Key, Compare, Allocator&gt;&amp; x);

<span class="COMMENT">// accessors:</span>

    key_compare key_comp() <span class="KEYWORD">const</span>;
    value_compare value_comp() <span class="KEYWORD">const</span>;
    iterator begin() <span class="KEYWORD">const</span>;
    iterator end() <span class="KEYWORD">const</span>;
    reverse_iterator rbegin();
    revferse_iterator rend();
    <span class="KEYWORD">bool</span> empty() <span class="KEYWORD">const</span>;
    size_type size() <span class="KEYWORD">const</span>;
    size_type max_size() <span class="KEYWORD">const</span>;

<span class="COMMENT">// insert/erase:</span>

    iterator insert(<span class="KEYWORD">const</span> value_type&amp; x);
    iterator insert(iterator position, <span class="KEYWORD">const</span> value_type&amp; x);
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    <span class="KEYWORD">void</span> insert(InputIterator first, InputIterator last);
    <span class="KEYWORD">void</span> erase(iterator position);
    size_type erase(<span class="KEYWORD">const</span> key_type&amp; x);
    <span class="KEYWORD">void</span> erase(iterator first, iterator last);

<span class="COMMENT">// multiset operations:</span>

    iterator find(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    size_type count(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    iterator lower_bound(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    iterator upper_bound(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    pair&lt;iterator, iterator&gt; equal_range(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Key, <span class="KEYWORD">class</span> Compare, <span class="KEYWORD">class</span> Allocator&gt; 
<span class="KEYWORD">bool operator</span>==(<span class="KEYWORD">const</span> multiset&lt;Key, Compare, Allocator&gt;&amp; x, 
        <span class="KEYWORD">const</span> multiset&lt;Key, Compare, Allocator&gt;&amp; y);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Key, <span class="KEYWORD">class</span> Compare, <span class="KEYWORD">class</span> Allocator&gt;
<span class="KEYWORD">bool operator</span>&lt;(<span class="KEYWORD">const</span> multiset&lt;Key, Compare, Allocator&gt;&amp; x,
        <span class="KEYWORD">const</span> multiset&lt;Key, Compare, Allocator&gt;&amp; y);
</pre>
</td></tr></tbody></table>
</div>

<p><var>iterator</var> - постоянный двунаправленный итератор, указывающий 
на <var>const value_type</var>. Точный тип зависит от реализации и определяется 
в <var>Allocator</var>. </p>
<p><var>сonst_iterator</var> - тот же самый тип, что и <var>iterator</var>.</p>
<p><var>size_type</var> - целочисленный тип без знака. Точный тип зависит 
от реализации и определяется в <var>Allocator</var>. </p>
<p><var>difference_type</var> - целочисленный тип со знаком. Точный тип 
зависит от реализации и определяется в <var>Allocator</var>. </p>


<h4 class="lem_sub_para2">Словарь (Map)</h4>
<p class="normal_text"><var>map</var> - ассоциативный контейнер, который поддерживает 
уникальные ключи (не содержит ключи с одинаковыми значениями) и обеспечивает 
быстрый поиск значений другого типа <var>T</var>, связанных с ключами. </p>

<div id="IDAEU3AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Key, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Compare = less&lt;Key&gt;,
        <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> U&gt; <span class="KEYWORD">class</span> Allocator = allocator&gt;
<span class="KEYWORD">class</span> map { 
<span class="KEYWORD">public</span>:

<span class="COMMENT">// typedefs:</span>

    <span class="KEYWORD">typedef</span> Key key_type;
    <span class="KEYWORD">typedef</span> pair&lt;<span class="KEYWORD">const</span> Key, T&gt; value_type;
    <span class="KEYWORD">typedef</span> Compare key_compare;
    <span class="KEYWORD">class</span> value_compare
        : <span class="KEYWORD">public</span> binary_function&lt;value_type, value_type, <span class="KEYWORD">bool</span>&gt; {
    <span class="KEYWORD">friend class</span> map;
    <span class="KEYWORD">protected</span>:
        Compare comp;
        value_compare(Compare c) : comp(c) {} 
    <span class="KEYWORD">public</span>:
        <span class="KEYWORD">bool operator</span>()(<span class="KEYWORD">const</span> value_type&amp; x, <span class="KEYWORD">const</span> value_type&amp; y) {
            <span class="KEYWORD">return</span> comp(x.first, y.first);
        }
    };
    <span class="KEYWORD">typedef</span> iterator;
    <span class="KEYWORD">typedef</span> const_iterator;
    <span class="KEYWORD">typedef</span> Allocator&lt;value_type&gt;::pointer pointer;
    <span class="KEYWORD">typedef</span> Allocator&lt;value_type&gt;::reference reference;
    <span class="KEYWORD">typedef</span> Allocator&lt;value_type&gt;::const_reference const_reference;
    <span class="KEYWORD">typedef</span> size_type;
    <span class="KEYWORD">typedef</span> difference_type;
    <span class="KEYWORD">typedef</span> reverse_iterator;
    <span class="KEYWORD">typedef</span> const_reverse_iterator;

<span class="COMMENT">// allocation/deallocation:</span>

    map(<span class="KEYWORD">const</span> Compare&amp; comp = Compare());
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    map(InputIterator first, InputIterator last,
        <span class="KEYWORD">const</span> Compare&amp; comp = Compare());
    map(<span class="KEYWORD">const</span> map&lt;Key, T, Compare,  Allocator&gt;&amp; x);
    ~map();
    map&lt;Key, T, Compare, Allocator&gt;&amp;
        <span class="KEYWORD">operator</span>=(<span class="KEYWORD">const</span> map&lt;Key, T, Compare, Allocator&gt;&amp; x);
    <span class="KEYWORD">void</span> swap(map&lt;Key, T, Compare, Allocator&gt;&amp; x);

<span class="COMMENT">// accessors:</span>

    key_compare key_comp() <span class="KEYWORD">const</span>;
    value_compare value_comp() <span class="KEYWORD">const</span>;
    iterator begin()
    const_iterator begin() <span class="KEYWORD">const</span>;
    iterator end();
    const_iterator end() <span class="KEYWORD">const</span>;
    reverse_iterator rbegin();
    const_reverse_iterator rbegin();
    reverse_iterator rend();
    const_reverse_iterator rend();
    <span class="KEYWORD">bool</span> empty() <span class="KEYWORD">const</span>;
    size_type size() <span class="KEYWORD">const</span>;
    size_type max_size() <span class="KEYWORD">const</span>;
    Allocator&lt;T&gt;::reference <span class="KEYWORD">operator</span>[](<span class="KEYWORD">const</span> key_type&amp; x);

<span class="COMMENT">// insert/erase:</span>

    pair&lt;iterator, <span class="KEYWORD">bool</span>&gt; insert(<span class="KEYWORD">const</span> value_type&amp; x);
    iterator insert(iterator position, <span class="KEYWORD">const</span> value_type&amp; x);
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    <span class="KEYWORD">void</span> insert(InputIterator first, InputIterator last);
    <span class="KEYWORD">void</span> erase(iterator position);
    size_type erase(<span class="KEYWORD">const</span> key_type&amp; x);
    <span class="KEYWORD">void</span> erase(iterator first, iterator last);

<span class="COMMENT">// map operations:</span>

    iterator find(<span class="KEYWORD">const</span> key_type&amp; x);
    const_iterator find(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    size_type count(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    iterator lower_bound(<span class="KEYWORD">const</span> key_type&amp; x);
    const_iterator lower_bound(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    iterator upper_bound(<span class="KEYWORD">const</span> key_type&amp; x);
    const_iterator upper_bound(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    pair&lt;iterator, iterator&gt; equal_range(<span class="KEYWORD">const</span> key_type&amp; x);
    pair&lt;const_iterator, const_iterator&gt; equal_range(<span class="KEYWORD">const</span> key_type&amp; x)<span class="KEYWORD">const</span>;
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Key, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Compare, <span class="KEYWORD">class</span> Allocator&gt;
<span class="KEYWORD">bool operator</span>==(<span class="KEYWORD">const</span> map&lt;Key, T, Compare, Allocator&gt;&amp; x, 
        <span class="KEYWORD">const</span> map&lt;Key, T, Compare, Allocator&gt;&amp; y);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Key, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Compare, <span class="KEYWORD">class</span> Allocator&gt;
<span class="KEYWORD">bool operator</span>&lt;(<span class="KEYWORD">const</span> mapr&lt;Key, T, Compare, Allocator&gt;&amp; x, 
        <span class="KEYWORD">const</span> map&lt;Key, T, Compare, Allocator&gt;&amp; y);
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>iterator</var> - двунаправленный итератор, указывающий на 
<var>value_type</var>. Точный тип зависит от реализации и определяется в 
<var>Allocator</var>. </p>
<p class="normal_text"><var>const_iterator</var> - постоянный двунаправленный итератор, 
указывающий на <var>const value_type</var>. Точный тип зависит от реализации и 
определяется в <var>Allocator</var>. Гарантируется, что имеется конструктор для 
<var>const_iterator</var> из <var>iterator</var>. </p>
<p class="normal_text"><var>size_type</var> - целочисленный тип без знака. Точный тип зависит 
от реализации и определяется в <var>Allocator</var>. </p>
<p class="normal_text"><var>difference_type</var> - целочисленный тип со знаком. Точный тип 
зависит от реализации и определяется в <var>Allocator</var>. </p>
<p class="normal_text">В дополнение к стандартному набору методов ассоциативных контейнеров, 
<var>map</var> обеспечивает операцию <var>Allocator&lt;T&gt;::reference 
operator[](const key_type&amp;)</var>. Для словаря <var>m</var> и ключа 
<var>k</var> запись <var>m[k]</var> семантически эквивалентна 
<var>(*((m.insert(make_pair(k, T()))).first)).second</var>. </p>


<h4 class="lem_sub_para2">Словарь с дубликатами (Multimар)</h4>
<p class="normal_text"><var>multimар</var> - ассоциативный контейнер, который поддерживает 
равные ключи (возможно, содержит множественные копии того же самого значения 
ключа) и обеспечивает быстрый поиск значений другого типа <var>T</var>, 
связанных с ключами.</p>

<div id="IDA313AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Key, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Compare = less&lt;Key&gt;,
        <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> U&gt; <span class="KEYWORD">class</span> Allocator = allocator&gt;
<span class="KEYWORD">class</span> multimap { 
<span class="KEYWORD">public</span>:

<span class="COMMENT">// typedefs:</span>

    <span class="KEYWORD">typedef</span> Key key_type;
    <span class="KEYWORD">typedef</span> pair&lt;<span class="KEYWORD">const</span> Key, T&gt; value_type;
    <span class="KEYWORD">typedef</span> Compare key_compare;
    <span class="KEYWORD">class</span> value_compare
        : <span class="KEYWORD">public</span> binary_function&lt;value_type, value_type, <span class="KEYWORD">bool</span>&gt; {
    <span class="KEYWORD">friend class</span> multimap;
    <span class="KEYWORD">protected</span>:
        Compare comp;
        value_compare(Compare c) : comp(c) {}
    <span class="KEYWORD">public</span>:
        <span class="KEYWORD">bool operator</span>()(<span class="KEYWORD">const</span> value_type&amp; x, <span class="KEYWORD">const</span> value_type&amp; y) {
            <span class="KEYWORD">return</span> comp(x.first, y.first);
        }
    };
    <span class="KEYWORD">typedef</span> iterator;
    <span class="KEYWORD">typedef</span> const_iterator;
    <span class="KEYWORD">typedef</span> Allocator&lt;value_type&gt;::pointer pointer;
    <span class="KEYWORD">typedef</span> Allocator&lt;value_type&gt;::reference reference;
    <span class="KEYWORD">typedef</span> Allocator&lt;value_type&gt;::const_reference const_reference;
    <span class="KEYWORD">typedef</span> size_type;
    <span class="KEYWORD">typedef</span> difference_type;
    <span class="KEYWORD">typedef</span> reverse_iterator;
    <span class="KEYWORD">typedef</span> const_reverse_iterator;

<span class="COMMENT">// allocation/deallocation:</span>

    multimap(<span class="KEYWORD">const</span> Compare&amp; comp = Compare());
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    multimap(InputIterator first, InputIterator last,
        <span class="KEYWORD">const</span> Compare&amp; comp = Compare());
    multimap(<span class="KEYWORD">const</span> multimap&lt;Key, T, Compare, Allocator&gt;&amp; x);
    ~multimap();
    multimap&lt;Key, T, Compare, Allocator&gt;&amp;
        <span class="KEYWORD">operator</span>=(<span class="KEYWORD">const</span> multimap&lt;Key, T, Compare, Allocator&gt;&amp; x);
    <span class="KEYWORD">void</span> swap(multimap&lt;Key, T, Compare, Allocator&gt;&amp; x);

<span class="COMMENT">// accessors:</span>

    key_compare key_comp() <span class="KEYWORD">const</span>;
    value_compare value_comp() <span class="KEYWORD">const</span>;
    iterator begin();
    const_iterator begin() <span class="KEYWORD">const</span>;
    iterator end();
    const_iterator end() <span class="KEYWORD">const</span>;
    reverse_iterator rbegin();
    const_reverse_iterator rbegin();
    reverse_iterator rend()
    const_reverse_iterator rend();
    <span class="KEYWORD">bool</span> empty() <span class="KEYWORD">const</span>;
    size_type size() <span class="KEYWORD">const</span>;
    size_type max_size() <span class="KEYWORD">const</span>;

<span class="COMMENT">// insert/erase:</span>

    iterator insert(<span class="KEYWORD">const</span> value_type&amp; x);
    iterator insert(iterator position, <span class="KEYWORD">const</span> value_type&amp; x);
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    <span class="KEYWORD">void</span> insert(InputIterator first, InputIterator    last);
    <span class="KEYWORD">void</span> erase(iterator position);
    size_type erase(<span class="KEYWORD">const</span> key_type&amp; x);
    <span class="KEYWORD">void</span> erase(iterator first, iterator last);

<span class="COMMENT">// multimap operations:</span>

    iterator find(<span class="KEYWORD">const</span> key_type&amp; x);
    const_iterator find(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    size_type count(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    iterator lower_bound(<span class="KEYWORD">const</span> key_type&amp; x);
    const_iterator lower_bound(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    iterator upper_bound(<span class="KEYWORD">const</span> key_type&amp; x);
    const_iterator upper_bound(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
    pair&lt;iterator, iterator&gt; equal_range(<span class="KEYWORD">const</span> key_type&amp; x);
    pair&lt;const_iterator, const_iterator&gt; equal_range(<span class="KEYWORD">const</span> key_type&amp; x) <span class="KEYWORD">const</span>;
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Key, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Compare, <span class="KEYWORD">class</span> Allocator&gt;
<span class="KEYWORD">bool operator</span>==(<span class="KEYWORD">const</span> multimap&lt;Key, T, Compare, Allocator&gt;&amp; x,
         <span class="KEYWORD">const</span> multimap&lt;Key, T, Compare, Allocator&gt;&amp; y);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Key, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Compare, <span class="KEYWORD">class</span> Allocator&gt;
<span class="KEYWORD">bool operator</span>&lt;(<span class="KEYWORD">const</span> multimap&lt;Key, T, Compare, Allocator&gt;&amp; x,
         <span class="KEYWORD">const</span> multimap&lt;Key, T, Compare, Allocator&gt;&amp; y);
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>iterator</var> - двунаправленный итератор, указывающий на 
<var>value_type</var>. Точный тип зависит от реализации и определяется в 
<var>Allocator</var>. </p>
<p class="normal_text"><var>const_iterator</var> - постоянный двунаправленный итератор, 
указывающий на <var>value_type</var>. Точный тип зависит от реализации и 
определяется в <var>Allocator</var>. Гарантируется, что имеется конструктор для 
<var>const_iterator</var> из <var>iterator</var>. </p>
<p class="normal_text"><var>size_type</var> - целочисленный тип без знака. Точный тип зависит 
от реализации и определяется в <var>Allocator</var>. </p>
<p class="normal_text"><var>difference_type</var> - целочисленный тип со знаком. Точный тип 
зависит от реализации и определяется в <var>Allocator</var>. </p>


<h2 class="lem_para">Итераторы потоков<a name="IDA1C4AG"></a></h2>
<p class="normal_text">Чтобы шаблоны алгоритмов могли работать непосредственно с потоками 
ввода-вывода, предусмотрены соответствующие шаблонные классы, подобные 
итераторам. Например,</p>

<div id="IDAAD4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre>partial_sum_copy(istream_iterator&lt;<span class="KEYWORD">double</span>&gt;(cin), istream_iterator&lt;<span class="KEYWORD">double</span>&gt;(),
         ostream_iterator&lt;<span class="KEYWORD">double</span>&gt;(cout, <span class="STRING">"\n"</span>));
</pre>
</td></tr></tbody></table>
</div>

<p>читает файл, содержащий числа с плавающей запятой, из <var>cin</var> и 
печатает частичные суммы в <var>cout</var>. </p>

<h3 class="lem_sub_para2">Итератор входного потока (Istream Iterator)<a name="IDAQD4AG"></a></h3>
<p class="normal_text"><var>istream_iterator&lt;T&gt;</var> читает (используя 
<var>operator&gt;&gt;</var>) последовательные элементы из входного потока, для 
которого он был создан. После своего создания итератор каждый раз при 
использовании <var>++</var> читает и сохраняет значение <var>T</var>. Если 
достигнут конец потока (<var>operator void* ()</var> в потоке возвращает 
<var>false</var>), итератор становится равным значению <i>end-of-stream</i> 
(<i>конец-потока</i>). Конструктор без параметров <var>istream_iterator()</var> 
всегда создаёт итераторный объект конца потокового ввода, являющийся единственым 
законным итератором, который следует использовать для конечного условия. 
Результат <var>operator*</var> для конца потока не определён, а для любого 
другого значения итератора возвращается <var>const T&amp;</var>. </p>
<p class="normal_text">Невозможно записывать что-либо с использованием входных итераторов. 
Основная особенность входных итераторов - тот факт, что операторы <var>++</var> 
не сохраняют равенства, то есть <var>i == j</var> не гарантирует вообще, что 
<var>++ i == ++ j</var>. Каждый раз, когда <var>++</var> используется, читается 
новое значение. Практическое следствие этого факта - то, что входные итераторы 
могут использоваться только для однопроходных алгоритмов, что действительно 
имеет здравый смысл, так как многопроходным алгоритмам всегда более 
соответствует использование структур данных в оперативной памяти. </p>
<p class="normal_text">Два итератора <i>конец-потока</i> всегда равны. Итератор 
<i>конец-потока</i> не равен <i>не-конец-потока</i> итератору. Два 
<i>не-конец-потока</i> итератора равны, когда они созданы из того же самого 
потока. </p>

<div id="IDA5E4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance = ptrdiff_t&gt;
<span class="KEYWORD">class</span> istream_iterator : <span class="KEYWORD">public</span> input_iterator&lt;T, Distance&gt; {
<span class="KEYWORD">friend bool operator</span>==(<span class="KEYWORD">const</span> istream_iterator&lt;T, Distance&gt;&amp; x,
             <span class="KEYWORD">const</span> istream_iterator&lt;T, Distance&gt;&amp; y);
<span class="KEYWORD">public</span>:
    istream_iterator();
    istream_iterator(istream&amp; s);
    istream_iterator(<span class="KEYWORD">const</span> istream_iterator&lt;T, Distance&gt;&amp; x);
    ~istream_iterator();
    <span class="KEYWORD">const</span> T&amp; <span class="KEYWORD">operator</span>*() <span class="KEYWORD">const</span>;
    istream_iterator&lt;T, Distance&gt;&amp; <span class="KEYWORD">operator</span>++();
    istream_iterator&lt;T, Distance&gt; <span class="KEYWORD">operator</span>++(<span class="KEYWORD">int</span>);
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">bool operator</span>==(<span class="KEYWORD">const</span> istream_iterator&lt;T, Distance&gt;&amp; x,
         <span class="KEYWORD">const</span> istream_iterator&lt;T, Distance&gt;&amp; y);
</pre>
</td></tr></tbody></table>
</div>


<h3 class="lem_sub_para2">Итератор выходного потока (Ostream Iterator)<a name="IDAOG4AG"></a></h3>
<p class="normal_text"><var>istream_iterator&lt;T&gt;</var> записывает (используя 
<var>operator&lt;&lt;</var>) последовательные элементы в выходной поток, из 
которого он был создан. Если он был создан с параметром конструктора 
<var>char*</var>, эта строка, называемая <i>строкой разделителя</i> 
(<i>delimiter string</i>), записывается в поток после того, как записывается 
каждое <var>T</var>. Невозможно с помощью выходного итератора получить значение. 
Его единственное использование - выходной итератор в ситуациях, подобных 
нижеследующему: </p>

<div id="IDA5G4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">while</span> (first != last) *result++ = *first++;
</pre>
</td></tr></tbody></table>
</div>

<p><var>ostream_iterator</var> определён как: </p>

<div id="IDAHH4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">class</span> ostream_iterator : <span class="KEYWORD">public</span> output_iterator {
<span class="KEYWORD">public</span>:
    ostream_iterator(ostream&amp; s);
    ostream_iterator(ostream&amp; s, <span class="KEYWORD">const char</span>* delimiter);
    ostream_iterator(<span class="KEYWORD">const</span> ostream_iterator&lt;T&gt;&amp; x);
    ~ostream_iterator();
    ostream_iterator&lt;T&gt;&amp; <span class="KEYWORD">operator</span>=(<span class="KEYWORD">const</span> T&amp; value);
    ostream_iterator&lt;T&gt;&amp; <span class="KEYWORD">operator</span>*();
    ostream_iterator&lt;T&gt;&amp; <span class="KEYWORD">operator</span>++();
    ostream_iterator&lt;T&gt;&amp; <span class="KEYWORD">operator</span>++(<span class="KEYWORD">int</span>);
};
</pre>
</td></tr></tbody></table>
</div>

<h2 class="lem_para">Алгоритмы<a name="IDAII4AG"></a></h2>
<p class="normal_text">Все алгоритмы отделены от деталей реализации структур данных и 
используют в качестве параметров типы итераторов. Поэтому они могут работать с 
определяемыми пользователем структурами данных, когда эти структуры данных имеют 
типы итераторов, удовлетворяющие предположениям в алгоритмах. </p>
<p class="normal_text">Для некоторых алгоритмов предусмотрены и оперативные и копирующие 
версии. Решение, включать ли копирующую версию, было обычно основано на 
рассмотрении сложности. Когда стоимость выполнения операции доминирует над 
стоимостью копии, копирующая версия не включена. Например, <var>sort_copy</var> 
не включена, так как стоимость сортировки намного значительнее, и пользователи 
могли бы также делать <var>copy</var> перед <var>sort</var>. Когда такая версия 
предусмотрена для какого-то алгоритма <i>algorithm</i>, он называется 
<i>algorithm</i><var>_copy</var>. Алгоритмы, которые берут предикаты, 
оканчиваются суффиксом <var>_if</var> (который следует за суффиксом 
<var>_copy</var>). </p>
<p class="normal_text">Класс <var>Predicate</var> используется всякий раз, когда алгоритм 
ожидает функциональный объект, при применении которого к результату 
разыменования соответствующего итератора возвращается значение, обратимое в 
<var>bool</var>. Другими словами, если алгоритм берёт <var>Predicate pred</var> 
как свой параметр и <var>first</var> как свой параметр итератора, он должен 
работать правильно в конструкции <var>if (pred(*first)) {...}</var>. 
Предполагается, что функциональный объект <var>pred</var> не применяет 
какую-либо непостоянную функцию для разыменованного итератора. </p>
<p class="normal_text">Класс <var>BinaryPredicate</var> используется всякий раз, когда алгоритм 
ожидает функциональный объект, который при его применении к результату 
разыменования двух соответствующих итераторов или к разыменованию итератора и 
типа <var>T</var>, когда <var>T</var> - часть сигнатуры, возвращает значение, 
обратимое в <var>bool</var>. Другими словами, если алгоритм берёт 
<var>BinaryPredicate binary_pred</var> как свой параметр и <var>first1</var> и 
<var>first2</var> как свои параметры итераторов, он должен работать правильно в 
конструкции <var>if (binary_pred(*first, *first2)) {...}</var>. 
<var>BinaryPredicate</var> всегда берёт тип первого итератора как свой первый 
параметр, то есть в тех случаях, когда <var>T value - </var>часть сигнатуры, он 
должен работать правильно в контексте <var>if (binary_pred (*first, value)) 
{...}</var>. Ожидается, что <var>binary_pred</var> не будет применять какую-либо 
непостоянную функцию для разыменованных итераторов. </p>
<p class="normal_text">В описании алгоритмов операторы <var>+</var> и <var>-</var> используются 
для некоторых категорий итераторов, для которых они не должны быть определены. В 
этих случаях семантика <var>a+n</var> такая же, как семантика <var>{X tmp = a; 
advance(tmp, n); return tmp;}</var>, а семантика <var>a-b</var> такая же, как 
семантика <var>{Distance n; distance(a, b, n); return n;}</var>. </p>

<h3 class="lem_para">Не меняющие последовательность операции (Non-mutating sequence operations)<a name="IDAUK4AG"></a></h3>

<h4 class="lem_sub_para2">Операции с каждым элементом (For each)</h4>

<div id="IDA0K4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> Function&gt;
Function for_each(InputIterator first, InputIterator last, Function f);
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>for_each</var> применяет <var>f</var> к результату разыменования 
каждого итератора в диапазоне <var>[first, last)</var> и возвращает 
<var>f</var>. Принято, что <var>f</var> не применяет какую-то непостоянную 
функцию к разыменованному итератору. <var>f</var> применяется точно 
<var>last-first</var> раз. Если <var>f</var> возвращает результат, результат 
игнорируется. </p>


<h4 class="lem_sub_para2">Найти (Find)</h4>

<div id="IDAYL4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> T&gt;
InputIterator find(InputIterator first, InputIterator last, <span class="KEYWORD">const</span> T&amp; value);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> Predicate&gt;
InputIterator find_if(InputIterator first, InputIterator last, Predicate pred);
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>find</var> возвращает первый итератор <var>i</var> в диапазоне 
<var>[first, last)</var>, для которого соблюдаются следующие соответствующие 
условия: <var>*i == value</var>, <var>pred (*i) == true</var>. Если такой 
итератор не найден, возвращается <var>last</var>. Соответствующий предикат 
применяется точно <var>find(first, last, value) - first раз.</var> </p>


<h4 class="lem_sub_para2">Найти рядом (Аdjacent find)</h4>

<div id="IDA2M4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator&gt;
ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> BinaryPredicate&gt;
ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last,
         BinaryPredicate binary_pred);
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>adjacent_find</var> возвращает первый итератор <var>i</var> такой, 
что <var>i</var> и <var>i+1</var> находятся в диапазоне <var>[first, last)</var> 
и для которого соблюдаются следующие соответствующие условия: <var>*i == *(i + 
1)</var>, <var>binary_pred(*i, *(i + 1)) == true</var>. Если такой итератор 
<var>i</var> не найден, возвращается <var>last</var>. Соответствующий предикат 
применяется, самое большее, <var>max((last - first) - 1, 0)</var> раз. </p>


<h4 class="lem_sub_para2">Подсчет (Count)</h4>

<div id="IDACO4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Size&gt;
<span class="KEYWORD">void</span> count(InputIterator first, InputIterator last, <span class="KEYWORD">const</span> T&amp; value, Size&amp; n);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> Predicate, <span class="KEYWORD">class</span> Size&gt;
<span class="KEYWORD">void</span> count_if(InputIterator first, InputIterator last, Predicate pred, Size&amp; n);
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>count</var> добавляет к <var>n</var> число итераторов <var>i</var> 
в диапазоне <var>[first, last)</var>, для которых соблюдаются следующие 
соответствующие условия: <var>*i == value</var>, <var>pred (*i) == true</var>. 
Соответствующий предикат применяется точно <var>last-first</var> раз. </p>
<p class="normal_text"><var>count</var> должен сохранять результат в параметре ссылки вместо 
того, чтобы возвращать его, потому что тип размера не может быть выведен из 
встроенных типов итераторов, как, например,<var> int*</var>. </p>


<h4 class="lem_sub_para2">Отличие (Mismatch)</h4>

<div id="IDAUP4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2&gt;
pair&lt;InputIterator1, InputIterator2&gt; mismatch(InputIterator1 first1, 
    InputIterator1 last1, InputIterator2 first2);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, <span class="KEYWORD">class</span> BinaryPredicate&gt;
pair&lt;InputIterator1, InputIterator2&gt; mismatch(InputIterator1 first1,
    InputIterator1 last1, InputIterator2 first2,
    BinaryPredicate binary_pred);
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>mismatch</var> возвращает пару итераторов <var>i</var> и 
<var>j</var> таких, что <var>j == first2 + (i - first1)</var> и <var>i</var> 
является первым итератором в диапазоне <var>[first1, last1)</var>, для которого 
следующие соответствующие условия выполнены: <var>!(*i == *(first2 + (i - 
first1)))</var>, <var>binary_pred (*i, *(first2 + (i - first1))) == false</var>. 
Если такой итератор <var>i</var> не найден, пара <var>last1</var> и <var>first2 
+ (last1 - first1)</var> возвращается. Соответствующий предикат применяется, 
самое большее, <var>last1 - first1</var> раз. </p>


<h4 class="lem_sub_para2">Сравнение на равенство (Equal)</h4>

<div id="IDAFR4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2&gt;
<span class="KEYWORD">bool</span> equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, <span class="KEYWORD">class</span> BinaryPredicate&gt;
<span class="KEYWORD">bool</span> equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, 
        BinaryPredicate binary_pred);
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>equal</var> возвращает <var>true</var>, если для каждого итератора 
<var>i</var> в диапазоне <var>[first1, last1)</var> выполнены следующие 
соответствующие условия: <var>*i == *(first2 + (i - first1))</var>, 
<var>binary_pred(*i, *(first2 + (i - first1))) == true</var>. Иначе equal 
возвращает <var>false</var>. Соответствующий предикат применяется, самое 
большее, <var>last1 - first1</var> раз. </p>


<h4 class="lem_sub_para2">Поиск подпоследовательности (Search)</h4>

<div id="IDAPS4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator1, <span class="KEYWORD">class</span> ForwardIterator2&gt;
ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, 
    ForwardIterator2 first2, ForwardIterator2 last2);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator1, <span class="KEYWORD">class</span> ForwardIterator2, 
    <span class="KEYWORD">class</span> BinaryPredicate&gt;
ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, 
    ForwardIterator2 first2, ForwardIterator2 last2, 
    BinaryPredicate binary_pred);
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>search</var> находит подпоследовательность равных значений в 
последовательности. <var>search</var> возвращает первый итератор <var>i</var> в 
диапазоне <var>[first1, last1 - (last2 - first2))</var> такой, что для любого 
неотрицательного целого числа <var>n</var>, меньшего чем <var>last2 - 
first2</var>, выполнены следующие соответствующие условия: <var>*(i + n) == 
*(first2 + n)</var>, <var>binary_pred(*(i + n), *(first2 + n)) == true</var>. 
Если такой итератор не найден, возвращается <var>last1</var>. Соответствующий 
предикат применяется, самое большее, <var>(last1 - first1) * (last2 - 
first2)</var> раз. Квадратичное поведение, однако, является крайне 
маловероятным. </p>



<h3 class="lem_para">Меняющие последовательность операции (Mutating sequence operations)<a name="IDAXT4AG"></a></h3>

<h4 class="lem_sub_para2">Копировать (Copy)</h4>

<div id="IDA3T4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> OutputIterator&gt; 
OutputIterator copy(InputIterator first, InputIterator last, 
    OutputIterator result);</pre>
</td></tr></tbody></table>
</div>

<p><var>copy</var> копирует элементы. Для каждого неотрицательного целого 
числа <var>n &lt; (last - first)</var> выполняется присваивание <var>*( result + 
n) = *( first + n)</var>. Точно делается <var>last - first</var> присваиваний. 
Результат <var>copy</var> не определён, если <var>result </var>находится в 
диапазоне <var>[first, last)</var>. </p>

<div id="IDAVU4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator1, <span class="KEYWORD">class</span> BidirectionalIterator2&gt;
BidirectionalIterator2 copy_backward(BidirectionalIterator1 first,
    BidirectionalIterator1 last, BidirectionalIterator2 result);
</pre>
</td></tr></tbody></table>
</div>
    
<p class="normal_text"><var>copy_backward</var> копирует элементы в диапазоне <var>[first, 
last)</var> в диапазон <var>[result - (last - first), result)</var>, начиная от 
<var>last-1</var> и продолжая до <var>first</var>. Его нужно использовать вместо 
<var>copy</var>, когда <var>last</var> находится в диапазоне <var>[result - 
(last - first), result)</var>. Для каждого положительного целого числа <var>n 
&lt;= (last - first)</var> выполняется присваивание <var>*(result - n) = *(last 
- n)</var>. <var>copy_backward</var> возвращает <var>result - (last - 
first)</var>. Точно делается <var>last - first</var> присваиваний. Результат 
<var>copy_backward</var> не определён, если <var>result</var> находится в 
диапазоне <var>[first, last)</var>. </p>


<h4 class="lem_sub_para2">Обменять (Swap)</h4>

<div id="IDADW4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt; 
<span class="KEYWORD">void</span> swap(T&amp; a, T&amp; b);
</pre>
</td></tr></tbody></table>
</div>

<p><var>swap</var> обменивает значения, хранимые в двух местах.</p>

<div id="IDAPW4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator1, <span class="KEYWORD">class</span> ForwardIterator2&gt;
<span class="KEYWORD">void</span> iter_swap(ForwardIterator1 a, ForwardIterator2 b);</pre>
</td></tr></tbody></table>
</div>

<p><var>iter_swap</var> обменивает значения, указанные двумя итераторами 
<var>a</var> и <var>b</var>. </p>

<div id="IDABX4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre>tempate &lt;<span class="KEYWORD">class</span> ForwardIterator1, <span class="KEYWORD">class</span> ForwardIterator2&gt;
ForwardIterator2 swap_ranges(ForwardIterator1 first1, 
    ForwardIterator1 last1, ForwardIterator2 first2);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text">Для каждого неотрицательного целого числа <var>n &lt; (last1 - 
first1)</var> выполняется перестановка: <var>swap(*(first1 + n), *(first2 + 
n))</var>. <var>swap_ranges</var> возвращает <var>first2 + (last1 - 
first1)</var>. Выполняется точно <var>last1 - first1</var> перестановок. 
Результат <var>swap_ranges</var> не определён, если два диапазона <var>[first1, 
last1)</var> и <var>[first2, first2 + (last1 - first1))</var> перекрываются. 
</p>


<h4 class="lem_sub_para2">Преобразовать (Transform)</h4>

<div id="IDA3X4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span>  &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> OutputIterator, <span class="KEYWORD">class</span> Unary0peration&gt; 
OutputIterator transform(InputIterator first, InputIterator last, 
    OutputIterator result, UnaryOperation op);

<span class="KEYWORD">template</span>  &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, 
    <span class="KEYWORD">class</span> OutputIterator, <span class="KEYWORD">class</span> Binary0peration&gt; 
OutputIterator transform(InputIterator1 first1, InputIterator1 last1, 
    InputIterator2 first2, OutputIterator result,
    BinaryOperation binary_op);
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>transform</var> присваивает посредством каждого итератора 
<var>i</var> в диапазоне <var>[result, result + (last1 - first1))</var> новое 
соответствующее значение, равное <var>op(* (first1 + (i - result))</var> или 
<var>binary_op(*(first1 + (i - result), *(first2 + (i - result)))</var>. 
<var>transform</var> возвращает <var>result + (last1 - first1)</var>. 
Применяются <var>op</var> или <var>binary_op</var> точно <var>last1 - 
first1</var> раз. Ожидается, что <var>op</var> и <var>binary_op</var> не имеют 
каких-либо побочных эффектов. <var>result</var> может быть равен 
<var>first</var> в случае унарного преобразования или <var>first1</var> либо 
<var>first2</var> в случае бинарного. </p>


<h4 class="lem_sub_para2">Заменить (Replace)</h4>

<div id="IDA0Z4AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">void</span> replace(ForwardIterator first, ForwardIterator last, <span class="KEYWORD">const</span> T&amp; old_value, 
    <span class="KEYWORD">const</span> T&amp; new_value);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> Predicate, <span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">void</span> replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, 
    <span class="KEYWORD">const</span> T&amp; new_value);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>replace</var> заменяет элементы, указанные итератором <var>i</var> 
в диапазоне <var>[first, last)</var>, значением <var>new_value</var>, когда 
выполняются следующие соответствующие условия: <var>*i == old_value</var>, 
<var>pred(*i) == true</var>. Соответствующий предикат применяется точно 
<var>last - first</var> раз. </p>

<div id="IDAE14AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> OutputIterator, <span class="KEYWORD">class</span> T&gt; 
OutputIterator replace_copy(InputIterator first, InputIterator last,
    OutputIterator result, <span class="KEYWORD">const</span> T&amp; old_value, <span class="KEYWORD">const</span> T&amp; new_value);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Iterator, <span class="KEYWORD">class</span> OutputIterator, <span class="KEYWORD">class</span> Predicate, <span class="KEYWORD">class</span> T&gt; 
OutputIterator replace_copy_if(Iterator first, Iterator last,
    OutputIterator result, Predicate pred, <span class="KEYWORD">const</span> T&amp; new_value);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>replace_copy</var> присваивает каждому итератору <var>i</var> в 
диапазоне <var>[result, result + (last - first))</var> значение 
<var>new_value</var> или <var>*(first + (i - result))</var> в зависимости от 
выполнения следующих соответствующих условий: <var>*(first + (i - result)) == 
old_value</var>, <var>pred(*(first + (i - result))) == true</var>. 
<var>replace_copy</var> возвращает <var>result + (last - first)</var>. 
Соответствующий предикат применяется точно <var>last - first</var> раз. </p>


<h4 class="lem_sub_para2">Заполнить (Fill)</h4>

<div id="IDAY24AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> T&gt; 
<span class="KEYWORD">void</span> fill(ForwardIterator first, ForwardIterator last, <span class="KEYWORD">const</span> T&amp; value);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> OutputIterator, <span class="KEYWORD">class</span> Size, <span class="KEYWORD">class</span> T&gt;
OutputIterator fill_n(Output Iterator first, Size n, <span class="KEYWORD">const</span> T&amp; value);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>fill</var> присваивает значения через все итераторы в диапазоне 
<var>[first, last)</var> или <var>[first, first + n)</var>. <var>fill_n</var> 
возвращает <var>first + n</var>. Точно делается <var>last - first</var> (или 
<var>n</var>) присваиваний. </p>


<h4 class="lem_sub_para2">Породить (Generate)</h4>

<div id="IDAC44AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> Generator&gt; 
<span class="KEYWORD">void</span> generate(ForwardIterator first, ForwardIterator last, 
    Generator gen);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> OutputIterator, <span class="KEYWORD">class</span> Size, <span class="KEYWORD">class</span> Generator&gt; 
OutputIterator generate_n(OutputIterator first, Size n, Generator gen);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>generate</var> вызывает функциональный объект <var>gen</var> и 
присваивает возвращаемое <var>gen</var> значение через все итераторы в диапазоне 
<var>[first, last)</var> или <var>[first, first + n)</var>. <var>gen</var> не 
берёт никакие параметры. <var>generate_n</var> возвращает <var>first + n</var>. 
Точно выполняется <var>last - first</var> (или <var>n</var>) вызовов 
<var>gen</var> и присваиваний. </p>


<h4 class="lem_sub_para2">Удалить (Remove)</h4>

<div id="IDAQ54AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> T&gt;
ForwardIterator remove(ForwardIterator first, ForwardIterator last, 
    <span class="KEYWORD">const</span> T&amp; value);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> Predicate&gt;
ForwardIterator remove_if(ForwardIterator first, ForwardIterator last, 
    Predicate pred);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>remove</var> устраняет все элементы, указываемые итератором 
<var>i</var> в диапазоне <var>[first, last)</var>, для которых выполнены 
следующие соответствующие условия: <var>*i == value</var>, <var>pred (*i) == 
true</var>. <var>remove</var> возвращает конец возникающего в результате своей 
работы диапазона. <var>remove</var> устойчив, то есть относительный порядок 
элементов, которые не удалены, такой же, как их относительный порядок в 
первоначальном диапазоне. Соответствующий предикат применяется точно <var>last 
-first</var> раз. </p>

<div id="IDAVA5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> OutputIterator, <span class="KEYWORD">class</span> T&gt; 
OutputIterator remove_copy(InputIterator first, InputIterator last, 
    OutputIterator result, <span class="KEYWORD">const</span> T&amp; value);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> OutputIterator, <span class="KEYWORD">class</span> Predicate&gt; 
OutputIterator remove_copy_if(InputIterator first, InputIterator last, 
    OutputIterator result, Predicate pred);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>remove_copy</var> копирует все элементы, указываемые итератором 
<var>i</var> в диапазоне <var>[first, last)</var>, для которых не выполнены 
следующие соответствующие условия:<var>*i == value</var>, <var>pred (*i) == 
true</var>. <var>remove_copy</var> возвращает конец возникающего в результате 
своей работы диапазона. <var>remove_copy</var> устойчив, то есть относительный 
порядок элементов в результирующем диапазоне такой же, как их относительный 
порядок в первоначальном диапазоне. Соответствующий предикат применяется точно 
<var>last - first</var> раз. </p>


<h4 class="lem_sub_para2">Убрать повторы (Unique)</h4>

<div id="IDA5B5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator&gt;
ForwardIterator unique(ForwardIterator first, ForwardIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> BinaryPredicate&gt;
ForwardIterator unique(ForwardIterator first, ForwardIterator last, 
    BinaryPredicate binary_pred);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>unique</var> устраняет все, кроме первого, элементы из каждой 
последовательной группы равных элементов, указываемые итератором <var>i</var> в 
диапазоне <var>[first, last)</var>, для которых выполнены следующие 
соответствующие условия: <var>*i == *(i - 1)</var> или <var>binary_pred(*i, *(i 
- 1)) == true</var>. <var>unique</var> возвращает конец возникающего в 
результате диапазона. Соответствующий предикат применяется точно <var>(last - 
first) - 1</var> раз. </p>

<div id="IDA1C5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> OutputIterator&gt; 
OutputIterator unique_copy(InputIterator first, InputIterator last, 
    OutputIterator result);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> OutputIterator, 
    <span class="KEYWORD">class</span> BinaryPredicate&gt;
OutputIterator unique_copy(InputIterator first, InputIterator last, 
    OutputIterator result, BinaryPredicate binary_pred);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>unique_copy</var> копирует только первый элемент из каждой 
последовательной группы равных элементов, указываемых итератором <var>i</var> в 
диапазоне <var>[first, last)</var>, для которых выполнены следующие 
соответствующие условия: <var>*i == *(i - 1)</var> или <var>binary_pied(*i, *(i 
- 1)) == true</var>. <var>unique_copy</var> возвращает конец возникающего в 
результате диапазона. Соответствующий предикат применяется точно <var>(last - 
first) - 1</var> раз. </p>


<h4 class="lem_sub_para2">Расположить в обратном порядке (Reverse)</h4>

<div id="IDA5D5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator&gt;
<span class="KEYWORD">void</span> reverse(BidirectionalIterator first, 
    BidirectionalIterator last);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text">Для каждого неотрицательного целого числа <var>i &lt;= (last - first)/2 
</var>функция <var>reverse</var> применяет перестановку ко всем парам итераторов 
<var>first + i</var>, <var>(last - i) - 1</var>. Выполняется точно <var>(last - 
first)/2</var> перестановок. </p>

<div id="IDATE5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator, <span class="KEYWORD">class</span> OutputIterator&gt; 
OutputIterator reverse_copy(BidirectionalIterator first,
    BidirectionalIterator last, OutputIterator result);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>reverse_copy</var> копирует диапазон <var>[first, last)</var> в 
диапазон <var>[result, result + (last - first))</var> такой, что для любого 
неотрицательного целого числа <var>i &lt; (last - first)</var> происходит 
следующее присваивание: <var>*(result + (last - first) - i) = *(first + 
i)</var>. <var>reverse_copy </var>возвращает <var>result + (last - first). 
</var>Делается точно <var>last - first</var> присваиваний. Результат 
<var>reverse_copy</var> не определён, если <var>[first, last)</var> и 
<var>[result, result + (last - first))</var> перекрываются. </p>


<h4 class="lem_sub_para2">Переместить по кругу (Rotate)</h4>

<div id="IDAXF5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator&gt; 
<span class="KEYWORD">void</span> rotate(ForwardIterator first, ForwardIterator middle, 
    ForwardIterator last);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text">Для каждого неотрицательного целого числа <var>i &lt; (last - 
first)</var> функция <var>rotate</var> помещает элемент из позиции <var>first + 
i</var> в позицию <var>first + (i + (last - middle)) % (last - first)</var>. 
<var>[first, middle)</var> и <var>[middle, last)</var> - допустимые диапазоны. 
Максимально выполняется <var>last - first</var> перестановок. </p>

<div id="IDAPG5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> OutputIterator&gt;
OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle, 
    ForwardIterator last, OutputIterator result);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>rotate_copy</var> копирует диапазон <var>[first, last)</var> в 
диапазон <var>[result, result + (last - first))</var> такой, что для каждого 
неотрицательного целого числа <var>i &lt; (last - first)</var> происходит 
следующее присваивание: <var>*(result + (i + (last - middle)) % (last - first)) 
= *(first + i)</var>. <var>rotate_copy </var>возвращает <var>result + (last - 
first)</var>. Делается точно <var>last - first</var> присваиваний. Результат 
<var>rotate_copy</var> не определён, если <var>[first, last)</var> и 
<var>[result, result + (last - first))</var> перекрываются. </p>


<h4 class="lem_sub_para2">Перетасовать (Random shuffle)</h4>

<div id="IDATH5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator&gt;
<span class="KEYWORD">void</span> random_shuffle(RandomAccessIterator first, RandomAccessIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator, <span class="KEYWORD">class</span> RandomNumberGenerator&gt;
<span class="KEYWORD">void</span> random_shuffie(RandomAccessIterator first, RandomAccessIterator last, 
    RandomNumberGenerator&amp; rand);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>random_shuffle</var> переставляет элементы в диапазоне <var>[first, 
last)</var> с равномерным распределением. Выполняется точно <var>last - 
first</var> перестановок. <var>random_shuffle</var> может брать в качестве 
параметра особый генерирующий случайное число функциональный объект 
<var>rand</var> такой, что <var>rand</var> берёт положительный параметр 
<var>n</var> типа расстояния <var>RandomAccessIterator</var> и возвращает 
случайно выбранное значение между <var>0</var> и <var>n-1</var>. </p>


<h4 class="lem_sub_para2">Разделить (Partitions)</h4>

<div id="IDAAJ5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator, <span class="KEYWORD">class</span> Predicate&gt; 
BidirectionalIterator partition(BidirectionalIterator first, 
    BidirectionalIterator last, Predicate pred);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>partition</var> помещает все элементы в диапазоне <var>[first, 
last)</var>, которые удовлетворяют <var>pred</var>, перед всеми элементами, 
которые не удовлетворяют. Возвращается итератор <var>i</var> такой, что для 
любого итератора <var>j</var> в диапазоне <var>[first, i)</var> будет <var>pred 
(*j) == true</var>, а для любого итератора <var>k</var> в диапазоне <var>[i, 
last)</var> будет <var>pred(*k) == false</var>. Делается максимально <var>(last 
- first)/2</var> перестановок. Предикат применяется точно <var>last - 
first</var> раз. </p>

<div id="IDACK5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator, <span class="KEYWORD">class</span> Predicate&gt;
BidirectionalIterator stable_partition(BidirectionalIterator first, 
    BidirectionalIterator last, Predicate pred);</pre>
</td></tr></tbody></table>
</div>
    
<p class="normal_text"><var>stable_partition</var> помещает все элементы в диапазоне 
<var>[first, last)</var>, которые удовлетворяют <var>pred</var>, перед всеми 
элементами, которые не удовлетворяют. Возвращается итератор <var>i</var> такой, 
что для любого итератора <var>j</var> в диапазоне <var>[first, i)</var> будет 
<var>pred(*j) == true</var>, а для любого итератора <var>k</var> в диапазоне 
<var>[i, last)</var> будет <var>pred(*k) == false</var>. Относительный порядок 
элементов в обеих группах сохраняется. Делается максимально <var>(last - first) 
* log(last - first)</var> перестановок, но только линейное число перестановок, 
если имеется достаточная дополнительная память. Предикат применяется точно 
<var>last - first</var> раз. </p>



<h3 class="lem_para"><a name="sorting"></a>Операции сортировки и отношения (Sorting and related operations)<a name="IDAGL5AG"></a></h3>
<p class="normal_text">Все операции в этом разделе имеют две версии: одна берёт в качестве 
параметра функциональный объект типа <var>Compare</var>, а другая использует 
<var>operator&lt; </var>. </p>
<p class="normal_text"><var>Compare</var> - функциональный объект, который возвращает значение, 
обратимое в <var>bool</var>. <var>Compare comp</var> используется полностью для 
алгоритмов, принимающих отношение упорядочения. <var>comp</var> удовлетворяет 
стандартным аксиомам для полного упорядочения и не применяет никакую 
непостоянную функцию к разыменованному итератору. Для всех алгоритмов, которые 
берут <var>Compare</var>, имеется версия, которая использует <var>operator&lt; 
</var>взамен. То есть <var>comp(*i, *j) == true</var> по умолчанию для <var>*i &lt; *j == true</var>. </p>
<p class="normal_text">Последовательность сортируется относительно компаратора <var>comp</var>, 
если для любого итератора <var>i</var>, указывающего на элемент в 
последовательности, и любого неотрицательного целого числе <var>n</var> такого, 
что <var>i + n</var> является допустимым итератором, указывающим на элемент той 
же самой последовательности, <var>comp(*( i + n), *i) == false</var>. </p>
<p class="normal_text">В описаниях функций, которые имеют дело с упорядочивающими отношениями, 
мы часто используем представление равенства, чтобы описать такие понятия, как 
устойчивость. Равенство, к которому мы обращаемся, не обязательно 
<var>operator==</var>, а отношение равенства стимулируется полным упорядочением. 
То есть два элементa <var>a</var> и <var>b</var> считаются равными, если и 
только если <var>!(a &lt; b) &amp;&amp; !(b &lt; a)</var>. </p>

<h4 class="lem_sub_para2">Сортировка (Sort)</h4>

<div id="IDA0M5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator&gt;
<span class="KEYWORD">void</span> sort(RandomAccessIterator first, RandomAccessIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator, <span class="KEYWORD">class</span> Compare&gt; 
<span class="KEYWORD">void</span> sort(RandomAccessIterator first, RandomAccessIterator last, 
    Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>sort</var> сортирует элементы в диапазоне <var>[first, last)</var>. 
Делается приблизительно <var>NIogN</var> (где <var>N</var> равняется <var>last - 
first</var>) сравнений в среднем. Если режим наихудшего случая важен, должны 
использоваться <var>stable_sort</var> или <var>partial_sort</var>. </p>

<div id="IDA0N5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator&gt;
<span class="KEYWORD">void</span> stable_sort(RandomAccessIterator first, RandomAccessIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator, <span class="KEYWORD">class</span> Compare&gt; 
<span class="KEYWORD">void</span> stable_sort(RandomAccessIterator first, RandomAccessIterator last, 
    Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>stable_sort</var> сортирует элементы в диапазоне <var>[first, 
last)</var>. Он устойчив, то есть относительный порядок равных элементов 
сохраняется. Делается максимум <var>N(logN)<sup>2</sup></var> (где<var>N</var> 
равняется <var>last - first</var>) сравнений; если доступна достаточная 
дополнительная память, тогда зто - <var>NlogN</var>. </p>

<div id="IDAZO5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator&gt;
<span class="KEYWORD">void</span> partial_sort(RandomAccessIterator first, RandomAccessIterator middle,
     RandomAccessIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator, <span class="KEYWORD">class</span> Compare&gt;
<span class="KEYWORD">void</span> partial_sort(RandomAccessIterator first, RandomAccessIterator middle,
     RandomAccessIterator last, Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>partial_sort</var> помещает первые <var>middle - first</var> 
сортированных элементов из диапазона <var>[first, last)</var> в диапазон 
<var>[first, middle)</var>. Остальная часть элементов в диапазоне <var>[middle, 
last)</var> помещена в неопределённом порядке. Берётся приблизительно <var>(last 
- first) * log(middle - first)</var> сравнений. </p>

<div id="IDAXP5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> RandomAccessIterator&gt;
RandomAccessIterator partial_sort_copy(InputIterator first, 
    InputIterator last, RandomAccessIterator result_first, 
    RandomAccessIterator result_last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> RandomAccessIterator, 
    <span class="KEYWORD">class</span> Compare&gt; 
RandomAccessIterator partial_sort_copy(InputIterator first, 
    InputIterator last, RandomAccessIterator result_first, 
    RandomAccessIterator result_last, Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>partial_sort_copy</var> помещает первые <var>min(last - first, 
result_last - result_first)</var> сортированных элементов в диапазон 
<var>[result_first, result_first + min(last - first, result_last - 
result_first))</var>. Возвращается или <var>result_last</var>, или 
<var>result_first +(last - first)</var>, какой меньше. Берётся приблизительно 
<var>(last - first) * log(min(last - first, result_last - result_first))</var> 
сравнений. </p>


<h4 class="lem_sub_para2">N-й элемент (Nth element)</h4>

<div id="IDA2Q5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator&gt;
<span class="KEYWORD">void</span> nth_element(RandomAccessIterator first, RandomAccessIterator nth,
     RandomAccessIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator, <span class="KEYWORD">class</span> Compare&gt;
<span class="KEYWORD">void</span> nth_element(RandomAccessIterator first, RandomAccessIterator nth, 
    RandomAccessIterator last, Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text">После операции <var>nth_element</var> элемент в позиции, указанной 
<var>nth</var>, является элементом, который был бы в той позиции, если бы 
сортировался целый диапазон. Также для любого итератора <var>i</var> в диапазоне 
<var>[first, nth)</var> и любого итератора <var>j</var> в диапазоне <var>[nth, 
last)</var> считается, что <var>!(*i &gt; *j)</var> или <var>comp(*i, *j) == 
false</var>. Операция линейна в среднем. </p>


<h4 class="lem_sub_para2">Двоичный поиск (Binary search)</h4>
<p class="normal_text">Все алгоритмы в этом разделе - версии двоичного поиска. Они работают с 
итераторами не произвольного доступа, уменьшая число сравнений, которое будет 
логарифмическим для всех типов итераторов. Они особенно подходят для итераторов 
произвольного доступа, так как эти алгоритмы делают логарифмическое число шагов 
в структуре данных. Для итераторов не произвольного доступа они выполняют 
линейное число шагов. </p>

<div id="IDAES5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> T&gt;
ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, 
    <span class="KEYWORD">const</span> T&amp; value);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Compare&gt;  
ForwardIterator lower_bound(ForwardIterator first, 
    ForwardIterator last, <span class="KEYWORD">const</span> T&amp; value, Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>lower_bound</var> находит первую позицию, в которую 
<var>value</var> может быть вставлено без нарушения упорядочения. 
<var>lower_bound</var> возвращает самый дальний итератор <var>i</var> в 
диапазоне <var>[first, last)</var> такой, что для любого итератора <var>j 
</var>в диапазоне <var>[first, i)</var> выполняются следующие соответствующие 
условия: <var>*j &lt; value</var> или <var>comp(*j, value) == true</var>. 
Делается максимум <var>log(last - first) + 1</var> сравнений. </p>

<div id="IDAOT5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> T&gt;
ForwardIterator upper_bound(ForwardIterator first, 
    ForwardIterator last, <span class="KEYWORD">const</span> T&amp; value);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Compare&gt;
ForwardIterator  upper_bound(ForwardIterator first, 
    ForwardIterator last, <span class="KEYWORD">const</span> T&amp; value, Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>upper_bound</var> находит самую дальнюю позицию, в которую 
<var>value</var> может быть вставлено без нарушения упорядочения. 
<var>upper_bound</var> возвращает самый дальний итератор <var>i</var> в 
диапазоне <var>[first, last)</var> такой, что для любого итератора <var>j</var> 
в диапазоне <var>[first, i)</var> выполняются следующие соответствующие условия: 
<var>!(value &lt; *j)</var> или <var>comp(value, *j) == false</var>. Делается 
максимум <var>log(last - first) + 1</var> сравнений. </p>

<div id="IDAYU5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> T&gt;
ForwardIterator equal_range(ForwardIterator first, 
    ForwardIterator last, <span class="KEYWORD">const</span> T&amp; value);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Compare&gt;  
ForwardIterator equal_range(ForwardIterator first, 
    ForwardIterator last, <span class="KEYWORD">const</span> T&amp; value, 
    Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>equal_range</var> находит самый большой поддиапазон <var>[i, j)</var> такой, что значение может быть вставлено по любому итератору 
<var>k</var> в нём. <var>k</var> удовлетворяет соответствующим условиям: 
<var>!(*k &lt; value) &amp;&amp; !(value &lt; *k)</var> или <var>comp(*k, value) 
== false &amp;&amp; comp(value, *k) == false</var>. Делается максимум <var>2 * 
log(last - first) + 1 </var>сравнений. </p>

<div id="IDA2V5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> T&gt;
ForwardIterator binary_search(ForwardIterator first, 
    ForwardIterator last, <span class="KEYWORD">const</span> T&amp; value);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Compare&gt;
ForwardIterator binary_search(ForwardIterator first, 
    ForwardIterator last, <span class="KEYWORD">const</span> T&amp; value,</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>binary_search</var> возвращает истину, если в диапазоне 
<var>[first, last)</var> имеется итератор <var>i</var>, который удовлетворяет 
соответствующим условиям: <var>!(*i &lt; value) &amp;&amp; !(value &lt; 
*i)</var> или <var>comp(*i, value) == false &amp;&amp; comp(value, *i) == 
false</var>. Делается максимум <var>log(last - first) + 2 </var>сравнений. 
</p>


<h4 class="lem_sub_para2">Объединение (Merge)</h4>

<div id="IDACX5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> Input Iterator2, 
    <span class="KEYWORD">class</span> OutputIterator&gt;
OutputIterator merge(InputIterator1 first1, 
    InputIterator1 last1, InputIterator2 first2, 
    InputIterator2 last2, OutputIterator result);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, 
    <span class="KEYWORD">class</span> OutputIterator, <span class="KEYWORD">class</span> Compare&gt; 
OutputIterator merge(InputIterator1 first1, 
    InputIterator1 last1, InputIterator2 first2, 
    InputIterator2 last2, OutputIterator result, 
    Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>merge</var> объединяет два сортированных диапазона <var>[first1, 
last1)</var> и <var>[first2, last2)</var> в диапазон <var>[result, result + 
(last1 - first1) + (last2 - first2))</var>. Объединение устойчиво, то есть для 
равных элементов в двух диапазонах элементы из первого диапазона всегда 
предшествуют элементам из второго. <var>merge</var> возвращает <var>result + 
(last1 - first1) + (last2 - first2)</var>. Выполняется максимально <var>(last1 - 
first1) + (last2 - first2) - 1</var> сравнений. Результат <var>merge </var>не 
определён, если возникающий в результате диапазон перекрывается с любым из 
первоначальных диапазонов. </p>

<div id="IDALY5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator&gt;
<span class="KEYWORD">void</span> inplace_merge(BidirectionalIterator first, 
    BidirectionalIterator middle, 
    BidirectionalIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator, <span class="KEYWORD">class</span> Compare&gt;
<span class="KEYWORD">void</span> inplace_merge(BidirectionalIterator first, 
    BidirectionalIterator middle, 
    BidirectionalIterator last, 
    Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>inplace_merge</var> объединяет два сортированных последовательных 
диапазона <var>[first, middle)</var> и <var>[middle, last)</var>, помещая 
результат объединения в диапазон <var>[first, last)</var>. Объединение 
устойчиво, то есть для равных элементов в двух диапазонах элементы из первого 
диапазона всегда предшествуют элементам из второго. Когда доступно достаточно 
дополнительной памяти, выполняется максимально <var>(last - first) - 1</var> 
сравнений. Если никакая дополнительная память не доступна, может использоваться 
алгоритм со сложностью <var>O(NlogN)</var>. </p>


<h4 class="lem_sub_para2">Операции над множеством для сортированных структур (Set operations on sorted structures)</h4>
<p class="normal_text">Этот раздел определяет все основные операции над множеством для 
сортированных структур. Они даже работают с множествами с дубликатами, 
содержащими множественные копии равных элементов. Семантика операций над 
множеством обобщена на множества с дубликатами стандартным способом, определяя 
объединение, содержащее максимальное число местонахождений каждого элемента, 
пересечение, содержащее минимум, и так далее.</p>

<div id="IDAPZ5AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2&gt;
<span class="KEYWORD">bool</span> includes(InputIterator1 first1, InputIterator1 last1, 
    InputIterator2 first2, InputIterator2 last2);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, 
    <span class="KEYWORD">class</span> Compare&gt;
<span class="KEYWORD">bool</span> includes(InputIterator1 first1, InputIterator1 last1, 
    InputIterator2 first2, InputIterator2 last2, 
    Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>includes</var> возвращает <var>true</var>, если каждый элемент в 
диапазоне <var>[first2, last2)</var> содержится в диапазоне <var>[first1, 
last1)</var>. Иначе возвращается <var>false</var>. Выполняется максимально 
<var>((last1 - first1) + (last2 - first2)) * 2 - 1</var> сравнений. </p>

<div id="IDAR05AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, 
    <span class="KEYWORD">class</span> OutputIterator&gt;
OutputIterator set_union(InputIterator1 first1, 
    InputIterator1 last1, InputIterator2 first2, 
    InputIterator2 last2, OutputIterator result);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, 
    <span class="KEYWORD">class</span> OutputIterator, <span class="KEYWORD">class</span> Compare&gt;
OutputIterator set_union(InputIterator1 first1, 
    InputIterator1 last1, InputIterator2 first2, 
    InputIterator2 last2, OutputIterator result, 
    Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>set_union</var> создаёт сортированное объединение элементов из двух 
диапазонов. Он возвращает конец созданного диапазона. <var>set_union</var> 
устойчив, то есть, если элемент присутствует в обоих диапазонах, он копируется 
из первого диапазона. Выполняется максимально <var>((last1 - first1) + (last2 - 
first2)) * 2 - 1</var> сравнений. Результат <var>set_union </var>не определён, 
если возникающий в результате диапазон перекрывается с любым из первоначальных 
диапазонов. </p>

<div id="IDAP15AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, 
    <span class="KEYWORD">class</span> OutputIterator&gt;
OutputIterator set_intersection(InputIterator1 first1, 
    InputIterator1 last1, InputIterator2 first2, 
    InputIterator2 last2, OutputIterator result);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, 
    <span class="KEYWORD">class</span> OutputIterator, <span class="KEYWORD">class</span> Compare&gt;
OutputIterator set_intersection(InputIterator1 first1, 
    InputIterator1 last1, InputIterator2 first2, 
    InputIterator2 last2, OutputIterator result, 
    Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>set_intersection</var> создаёт сортированное пересечение элементов 
из двух диапазонов. Он возвращает конец созданного диапазона. Гарантируется, что 
<var>set_intersection</var> устойчив, то есть, если элемент присутствует в обоих 
диапазонах, он копируется из первого диапазона. Выполняется максимально 
<var>((last1 - first1) + (last2 - first2)) * 2 - 1</var> сравнений. Результат 
<var>set_union</var> не определён, если возникающий в результате диапазон 
перекрывается с любым из первоначальных диапазонов. </p>

<div id="IDAN25AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, 
    <span class="KEYWORD">class</span> OutputIterator&gt;
OutputIterator set_difference(InputIterator1 first1, 
    InputIterator1 last1, InputIterator2 first2, 
    InputIterator2 last2, OutputIterator  result);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, 
    <span class="KEYWORD">class</span> OutputIterator, <span class="KEYWORD">class</span> Compare&gt;
OutputIterator set_difference(InputIterator1 first1, 
    InputIterator1 last1, InputIterator2 first2, 
    InputIterator2 last2, OutputIterator result, 
    Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>set_difference</var> создаёт сортированную разность элементов из 
двух диапазонов. Он возвращает конец созданного диапазона. Выполняется 
максимально <var>((last1 - first1) + (last2 - first2)) * 2 - 1</var> сравнений. 
Результат <var>set_difference</var> не определён, если возникающий в результате 
диапазон перекрывается с любым из первоначальных диапазонов. </p>

<div id="IDAJ35AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, 
    <span class="KEYWORD">class</span> OutputIterator&gt;
OutputIterator set_symmetric_difference(InputIterator1 first1, 
    InputIterator1 last1, InputIterator2 first2, 
    InputIterator2 last2, OutputIterator result);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, 
    <span class="KEYWORD">class</span> OutputIterator, <span class="KEYWORD">class</span> Compare&gt;
OutputIterator set_symmetric_difference(InputIterator1 first1, 
    InputIterator1 last1, InputIterator2 first2, 
    InputIterator2 last2, OutputIterator result, 
    Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>set_symmetric_difference</var> создаёт сортированную симметричную 
разность элементов из двух диапазонов. Он возвращает конец созданного диапазона. 
Выполняется максимально <var>((last1 - first1) + (last2 - first2)) * 2 - 1</var> 
сравнений. Результат <var>set_symmetric_difference</var> не определён, если 
возникающий в результате диапазон перекрывается с любым из первоначальных 
диапазонов. </p>


<h4 class="lem_sub_para2">Операции над пирамидами (Heap operations)</h4>
<p class="normal_text">Пирамида - специфическая организация элементов в диапазоне между двумя 
итераторами произвольного доступа <var>[a, b)</var>. Два её ключевые свойства: 
(1) <var>*a</var> - самый большой элемент в диапазоне, (2) <var>*a</var> может 
быть удалён с помощью <var>pop_heap</var> или новый элемент добавлен с помощью 
<var>push_heap</var> за <var>O(logN)</var> время. Эти свойства делают пирамиды 
полезными для приоритетных очередей. <var>make_heap</var> преобразовывает 
диапазон в пирамиду, a <var>sort_heap</var> превращает пирамиду в сортированную 
последовательность. </p>

<div id="IDA145AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator&gt;
<span class="KEYWORD">void</span> push_heap(RandomAccessIterator first, 
    RandomAccessIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator, <span class="KEYWORD">class</span> Compare&gt;
<span class="KEYWORD">void</span> push_heap(RandomAccessIterator first, 
    RandomAccessIterator last, Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>push_heap</var> полагает, что диапазон <var>[first, last - 1)</var> 
является соответствующей пирамидой, и надлежащим образом помещает значение с 
позиции <var>last - 1</var> в результирующую пирамиду <var>[first, last)</var>. 
Выполняется максимально <var>log(last - first)</var> сравнений. </p>

<div id="IDAX55AG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator&gt; 
<span class="KEYWORD">void</span> pop_heap(RandomAccessIterator first, 
    RandomAccessIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator, <span class="KEYWORD">class</span> Compare&gt;
<span class="KEYWORD">void</span> pop_heap(RandomAccessIterator first, 
    RandomAccessIterator last, 
    Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>pop_heap</var> полагает, что диапазон <var>[first, last)</var> 
является соответствующей пирамидой, затем обменивает значения в позициях 
<var>first</var> и <var>last - 1</var> и превращает <var>[first, last - 1)</var> 
в пирамиду. Выполняется максимально <var>2 * log(last - first)</var> сравнений. 
</p>

<div id="IDAYAABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator&gt;
<span class="KEYWORD">void</span> make_heap(RandomAccessIterator first, 
    RandomAccessIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator, <span class="KEYWORD">class</span> Compare&gt;
<span class="KEYWORD">void</span> make_heap(RandomAccessIterator first, 
    RandomAccessIterator last, 
    Compare comp);</pre>
</td></tr></tbody></table>
</div>
    
<p><var>make_heap</var> создает пирамиду из диапазона <var>[first, 
last)</var>. Выполняется максимально <var>3 * (last - first)</var> сравнений. 
</p>

<div id="IDAQBABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator&gt; 
<span class="KEYWORD">void</span> sort_heap(RandomAccessIterator first, 
    RandomAccessIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator, <span class="KEYWORD">class</span> Compare&gt;
<span class="KEYWORD">void</span> sort_heap(RandomAccessIterator first, 
    RandomAccessIterator last, Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p><var>sort_heap</var> сортирует элементы в пирамиде <var>[first, 
last)</var>. Выполняется максимально <var>NlogN</var> сравнений, где 
<var>N</var> равно <var>last - first</var>. <var>sort_heap</var> не устойчив. 
</p>


<h4 class="lem_sub_para2">Минимум и максимум (Minimum and maximum)</h4>

<div id="IDASCABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt; 
<span class="KEYWORD">const</span> T&amp; min(<span class="KEYWORD">const</span> T&amp; a, <span class="KEYWORD">const</span> T&amp; b);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Compare&gt; 
<span class="KEYWORD">const</span> T&amp; min(<span class="KEYWORD">const</span> T&amp; a, <span class="KEYWORD">const</span> T&amp; b, Compare comp);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt; 
<span class="KEYWORD">const</span> T&amp; max(<span class="KEYWORD">const</span> T&amp; a, <span class="KEYWORD">const</span> T&amp; b);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Compare&gt; 
<span class="KEYWORD">const</span> T&amp; max(<span class="KEYWORD">const</span> T&amp; a, <span class="KEYWORD">const</span> T&amp; b, Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p><var>min</var> возвращает меньшее, а <var>max</var> большее. 
<var>min</var> и <var>max</var> возвращают первый параметр, когда их параметры 
равны. </p>

<div id="IDAKEABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator&gt; 
ForwardIterator max_element(ForwardIterator first, 
    ForwardIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> Compare&gt;
ForwardIterator max_element(ForwardIterator first, 
    ForwardIterator last, Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>max_element</var> возвращает первый такой итератор <var>i</var> в 
диапазоне <var>[first, last)</var>, что для любого итератора <var>j</var> в 
диапазоне <var>[first, last)</var> выполняются следующие соответствующие 
условия: <var>!(*i &lt; *j)</var> или <var>comp(*i, *j) == false</var>. 
Выполняется точно <var>max((last - first) - 1, 0)</var> соответствующих 
сравнений. </p>

<div id="IDAIFABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator&gt; 
ForwardIterator min_element(ForwardIterator first, 
    ForwardIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> ForwardIterator, <span class="KEYWORD">class</span> Compare&gt;
ForwardIterator min_element(ForwardIterator first, 
    ForwardIterator last, Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>min_element</var> возвращает первый такой итератор <var>i</var> в 
диапазоне <var>[first, last)</var>, что для любого итератора <var>j</var> в 
диапазоне <var>[first, last)</var> выполняются следующие соответствующие 
условия: <var>!(*j &lt; *i)</var> или <var>comp(*j, *i) == false</var>. 
Выполняется точно <var>max((last - first) - 1, 0)</var> соответствующих 
сравнений. </p>


<h4 class="lem_sub_para2">Лексикографическое сравнение (Lexicographical comparison)</h4>

<div id="IDAKGABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2&gt;
<span class="KEYWORD">bool</span> lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
     InputIterator2 first2, InputIterator2 last2);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, <span class="KEYWORD">class</span> Compare&gt; 
<span class="KEYWORD">bool</span> lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
    InputIterator2 first2, InputIterator2 last2, Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>lexicographical_compare</var> возвращает <var>true</var>, если 
последовательность элементов, определённых диапазоном <var>[first1, 
last1)</var>, лексикографически меньше, чем последовательность элементов, 
определённых диапазоном <var>[first2, last2)</var>. Иначе он возвращает ложь. 
Выполняется максимально <var>2 * min((last1 - first1), (last2 - first2))</var> 
сравнений. </p>


<h4 class="lem_sub_para2">Генераторы перестановок (Permutation generators)</h4>

<div id="IDAOHABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator&gt; 
<span class="KEYWORD">bool</span> next_permutation(BidirectionalIterator first, 
    BidirectionalIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator, <span class="KEYWORD">class</span> Compare&gt;
<span class="KEYWORD">bool</span> next_permutation(BidirectionalIterator first, 
    BidirectionalIterator last, Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>next_permutation</var> берёт последовательность, определённую 
диапазоном <var>[first, last)</var>, и трансформирует её в следующую 
перестановку. Следующая перестановка находится, полагая, что множество всех 
перестановок лексикографически сортировано относительно <var>operator&lt;</var> 
или <var>comp</var>. Если такая перестановка существует, возвращается 
<var>true</var>. Иначе он трансформирует последовательность в самую маленькую 
перестановку, то есть сортированную по возрастанию, и возвращает 
<var>false</var>. Максимально выполняется <var>(last - first)/2</var> 
перестановок. </p>

<div id="IDARIABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator&gt;
<span class="KEYWORD">bool</span> prev_permutation(BidirectionalIterator first, 
    BidirectionalIterator last);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator, <span class="KEYWORD">class</span> Compare&gt;
<span class="KEYWORD">bool</span> prev_permutation(BidirectionalIterator first, 
    BidirectionalIterator last, Compare comp);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>prev_permutation</var> берёт последовательность, определённую 
диапазоном <var>[first, last)</var>, и трансформирует её в предыдущую 
перестановку. Предыдущая перестановка находится, полагая, что множество всех 
перестановок лексикографически сортировано относительно <var>operator&lt;</var> 
или <var>comp</var>. Если такая перестановка существует, возвращается 
<var>true</var>. Иначе он трансформирует последовательность в самую большую 
перестановку, то есть сортированную по убыванию, и возвращает <var>false</var>. 
Максимально выполняется <var>(last - first)/2</var> перестановок. </p>



<h3 class="lem_para">Обобщённые численные операции (Generalized numeric operations)<a name="IDATJABG"></a></h3>
<h4 class="lem_sub_para2">Накопление (Accumulate)</h4>

<div id="IDAZJABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> T&gt;
T accumulate(InputIterator first, InputIterator last, T init);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> BinaryOperation&gt;
T accumulate(InputIterator first, InputIterator last, T init, 
    BinaryOperation binary_op);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>accumulate</var> подобен оператору APL <i>reduction</i> и функции 
Common Lisp <i>reduce</i>, но он избегает трудности определения результата 
уменьшения для пустой последовательности, всегда требуя начальное значение. 
Накопление выполняется инициализацией сумматора <var>acc</var> начальным 
значением <var>init</var> и последующим изменением его <var>acc = acc + *i</var> 
или <var>acc = binary_op(acc, *i)</var> для каждого итератора <var>i</var> в 
диапазоне <var>[first, last)</var> по порядку. Предполагается, что 
<var>binary_op</var> не вызывает побочных эффектов. </p>


<h4 class="lem_sub_para2">Скалярное произведение (Inner product)</h4>

<div id="IDADLABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, <span class="KEYWORD">class</span> T&gt; 
T inner_product(InputIterator1 first1, InputIterator1 last1, 
    InputIterator2 first2, T init);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator1, <span class="KEYWORD">class</span> InputIterator2, <span class="KEYWORD">class</span> T,
    <span class="KEYWORD">class</span> BinaryOperation1, <span class="KEYWORD">class</span> BinaryOperation2&gt; 
T inner_product(InputIterator1 first1, InputIterator1 last1,
    InputIterator2 first2, T init,
    BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>inner_product</var> вычисляет свой результат, инициализируя 
сумматор <var>acc</var> начальным значением <var>init</var> и затем изменяя его 
<var>acc = acc + (*i1) * (*i2)</var> или <var>acc = binary_op1 (acc, binary_op2 
(*i1, *i2))</var> для каждого итератора <var>i1</var> в диапазоне <var>[first, 
last)</var> и итератора <var>i2</var> в диапазоне <var>[first2, first2 + (last - 
first))</var> по порядку. Предполагается, что <var>binary_op1</var> и 
<var>binary_op2</var> не вызывают побочных эффектов. </p>


<h4 class="lem_sub_para2">Частичная сумма (Partial sum)</h4>

<div id="IDAVMABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> OutputIterator&gt;
OutputIterator partial_sum(InputIterator first, InputIterator last, 
    OutputIterator result);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> OutputIterator, <span class="KEYWORD">class</span> BinaryOperation&gt; 
OutputIterator partial_sum(InputIterator first, InputIterator last, 
    OutputIterator result, BinaryOperation binary_op);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>partial_sum</var> присваивает каждому итератору <var>i</var> в 
диапазоне <var>[result, result + (last - first))</var> значение, соответственно 
равное <var>((...(*first + *(first + 1)) + ...) + *(first + (i - result)))</var> 
или <var>binary_op(binary_op(..., binary_op(*first, *(first + 1)), ...), *(first 
+ (i - result)))</var>. Функция <var>partial_sum</var> возвращает <var>result + 
(last - first)</var>. Выполняется <var>binary_op</var> точно <var>(last - first) 
- 1</var> раз. Ожидается, что <var>binary_op</var> не имеет каких-либо побочных 
эффектов. <var>result</var> может быть равен <var>first</var>. </p>


<h4 class="lem_sub_para2">Смежная разность (Adjacent difference)</h4>

<div id="IDADOABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> OutputIterator&gt;
OutputIterator adjacent_difference(InputIterator first, InputIterator last, 
    OutputIterator result); 

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator, <span class="KEYWORD">class</span> OutputIterator, <span class="KEYWORD">class</span> BinaryOperation&gt; 
OutputIterator adjacent_difference(InputIterator first, InputIterator last, 
    OutputIterator result, BinaryOperation binary_op);</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>adjacent_difference</var> присваивает каждому элементу, 
указываемому итератором <var>i</var> в диапазоне <var>[result + 1, result + 
(last - first))</var> значение, соответственно равное <var>*(first + (i - 
result)) - *(first + (i - result) - 1)</var> или <var>binary_op(*(first + (i - 
result)), *(first + (i - result) - 1))</var>. Элемент, указываемый 
<var>result</var>, получает значение <var>*first</var>. Функция 
<var>adjacent_difference</var> возвращает <var>result + (last - first)</var>. 
Применяется <var>binary_op</var> точно <var>(last - first) - 1</var> раз. 
Ожидается, что <var>binary_op</var> не имеет каких-либо побочных эффектов. 
<var>result</var> может быть равен <var>first</var>. </p>


<h2 class="lem_para">Адаптеры<a name="IDAUPABG"></a></h2>
<p class="normal_text">Адаптеры - шаблонные классы, которые обеспечивают отображения 
интерфейса. Например, <var>insert_iterator</var> обеспечивает контейнер 
интерфейсом итератора вывода. </p>

<h3 class="lem_sub_para2">Адаптеры контейнеров (Container adaptors)<a name="IDA1PABG"></a></h3>
<p class="normal_text">Часто бывает полезно обеспечить ограниченные интерфейсы контейнеров. 
Библиотека предоставляет <var>stack</var>, <var>queue</var> и 
<var>priority_queue</var> через адаптеры, которые могут работать с различными 
типами последовательностей. </p>

<h4 class="lem_sub_para2">Стек (Stack)</h4>
<p class="normal_text">Любая последовательность, поддерживающая операции <var>back</var>, 
<var>push_back</var> и <var>pop_back</var>, может использоваться для модификации 
<var>stack</var>. В частности, могут использоваться <var>vector</var>, 
<var>list</var> и <var>deque</var>. </p>

<div id="IDA2QABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Container&gt;
<span class="KEYWORD">class</span> stack {
<span class="KEYWORD">friend bool operator</span>==(<span class="KEYWORD">const</span> stack&lt;Container&gt;&amp; o, <span class="KEYWORD">const</span> stack&lt;Container&gt;&amp; y);
<span class="KEYWORD">friend bool operator</span>&lt;(<span class="KEYWORD">const</span> stack&lt;Container&gt;&amp; o, <span class="KEYWORD">const</span> stack&lt;Container&gt;&amp; y);
<span class="KEYWORD">public</span>:
    <span class="KEYWORD">typedef</span> Container::value_type value_type;
    <span class="KEYWORD">typedef</span> Container::size_type size_type;
<span class="KEYWORD">protected</span>:
    Container c;
<span class="KEYWORD">public</span>:
    <span class="KEYWORD">bool</span> empty() <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> c.empty(); }
    size_type size() <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> c.size(); }
    value_type&amp; top() { <span class="KEYWORD">return</span> c.back(); }
    <span class="KEYWORD">const</span> value_type&amp; top() <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> c.back(); }
    <span class="KEYWORD">void</span> push(<span class="KEYWORD">const</span> value_type&amp; o) { n.push_back(o); }
    <span class="KEYWORD">void</span> pop() { c.pop_back(); }
 };

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Container&gt;
<span class="KEYWORD">bool operator</span>==(<span class="KEYWORD">const</span> stack &lt;Container&gt;&amp; o, <span class="KEYWORD">const</span> stack&lt;Container&gt;&amp; y)
    { <span class="KEYWORD">return</span> o.n == o.n;}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Container&gt;
<span class="KEYWORD">bool operator</span>&lt;(<span class="KEYWORD">const</span> stack&lt;Container&gt;&amp; o, <span class="KEYWORD">const</span> stack&lt;Container&gt;&amp; y) 
    { <span class="KEYWORD">return</span> o.n &lt; o.n; }</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text">Например, <var>stack&lt;vector&lt;int&gt; &gt;</var> - целочисленный 
стек, сделанный из <var>vector</var>, а <var>stack&lt;deque&lt;char&gt; 
&gt;</var> - символьный стек, сделанный из <var>deque</var>. </p>


<h4 class="lem_sub_para2">Очередь (Queue)</h4>
<p class="normal_text">Любая последовательность, поддерживающая операции <var>front</var>, 
<var>push_back</var> и <var>pop_front</var>, может использоваться для 
модификации <var>queue</var>. В частности, могут использоваться <var>list</var> 
и <var>deque</var>. </p>

<div id="IDAGUABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Container&gt;
<span class="KEYWORD">class</span> queue {
    <span class="KEYWORD">friend bool operator</span>==(<span class="KEYWORD">const</span> queue&lt;Container&gt;&amp; o, <span class="KEYWORD">const</span> queue&lt;Container&gt;&amp; y);
    <span class="KEYWORD">friend bool operator</span>&lt;(<span class="KEYWORD">const</span> queue&lt;Container&gt;&amp; o, <span class="KEYWORD">const</span> queue&lt;Container&gt;&amp; y);
<span class="KEYWORD">public</span>:
    <span class="KEYWORD">typedef</span> Container::value_type value_type;
    <span class="KEYWORD">typedef</span> Container::size_type size_type;
<span class="KEYWORD">protected</span>:
    Container c;
<span class="KEYWORD">public</span>:
    <span class="KEYWORD">bool</span> empty() <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> c.empty(); }
    size_type size() <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> c.size(); }
    value_type&amp; front() { <span class="KEYWORD">return</span> c.front(); }
    <span class="KEYWORD">const</span> value_type&amp; front() <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> c.front(); }
    value_type&amp; back() { <span class="KEYWORD">return</span> c.back(); }
    <span class="KEYWORD">const</span> value_type&amp; back() <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> c.back(); }
    <span class="KEYWORD">void</span> push(<span class="KEYWORD">const</span> value_type&amp; o) { n.push_back(o); }
    <span class="KEYWORD">void</span> pop() { n.pop_front(); }
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Container&gt;
    <span class="KEYWORD">bool operator</span>==(<span class="KEYWORD">const</span> queue&lt;Container&gt;&amp; o, <span class="KEYWORD">const</span> queue&lt;Container&gt;&amp; y) 
    { <span class="KEYWORD">return</span> x.c == y.c;}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Container&gt;
    <span class="KEYWORD">bool operator</span>&lt;(<span class="KEYWORD">const</span> queue&lt;Container&gt;&amp; o, <span class="KEYWORD">const</span> queue&lt;Container&gt;&amp; y) 
    { <span class="KEYWORD">return</span> x.c &lt; y.c; }</pre>
</td></tr></tbody></table>
</div>


<h4 class="lem_sub_para2">Очередь с приоритетами (Priority queue)</h4>
<p class="normal_text">Любая последовательность, с итератором произвольного доступа и 
поддерживающая операции <var>front</var>, <var>push_back</var> и 
<var>pop_front</var>, может использоваться для модификации 
<var>priority_queue</var>. В частности, могут использоваться <var>vector</var> и 
<var>deque</var>. </p>

<div id="IDAOXABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Container, <span class="KEYWORD">class</span> Compare = less&lt;Container::value_type&gt; &gt; 
<span class="KEYWORD">class</span> priority_queue { 
<span class="KEYWORD">public</span>:
    <span class="KEYWORD">typedef</span> Container::value_type value_type;
    <span class="KEYWORD">typedef</span> Container::size_type size_type;
<span class="KEYWORD">protected</span>:
    Container c;
    Compare comp;
<span class="KEYWORD">public</span>:
    priority_queue(<span class="KEYWORD">const</span> Compare&amp; х = Compare()) : c(), comp(х) {}
    <span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> InputIterator&gt;
    priority_queue(InputIterator first, InputIterator last,
        <span class="KEYWORD">const</span> Compare&amp; х = Compare()) : c(first, last), comp(x) 
        { make_heap(c.begin(), с.end(), comp); }
    <span class="KEYWORD">bool</span> empty() <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> c.empty(); }
    size_type size() <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> c.size(); }
    <span class="KEYWORD">const</span> value_type&amp; top() <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> c.front(); }
    <span class="KEYWORD">void</span> push(<span class="KEYWORD">const</span> value_type&amp; х) {
        c.push_back(х);
        push_heap(c.begin(), c.end(), comp);
    }
    <span class="KEYWORD">void</span> pop() {
        pop_heap(c.begin(), c.end(), comp);
        с<span class="NUMBER">.р</span>ор_bасk(); 
    } 
}; <span class="COMMENT">// Никакое равенство не обеспечивается</span></pre>
</td></tr></tbody></table>
</div>



<h3 class="lem_para">Адаптеры итераторов (Iterator adaptors)<a name="IDAIZABG"></a></h3>
<h4 class="lem_sub_para2">Обратные итераторы (Reverse iterators)</h4>
<p class="normal_text">Двунаправленные итераторы и итераторы произвольного доступа имеют 
соответствующие адаптеры обратных итераторов, которые выполняют итерации через 
структуру данных в противоположном направлении.Они имеют те же самые сигнатуры, 
как и соответствующие итераторы. Фундаментальное соотношение между обратным 
итератором и его соответствующим итератором <var>i</var> установлено тождеством 
<var>&amp;*(reverse_iterator(i)) == &amp;*(i - 1)</var>. Это отображение 
продиктовано тем, что, в то время как после конца массива всегда есть указатель, 
может не быть допустимого указателя перед началом массива. </p>

<div id="IDAUZABG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Reference = T&amp;,
    <span class="KEYWORD">class</span> Distance = ptrdiff_t&gt; 
<span class="KEYWORD">class</span> reverse_bidirectionaiIterator
    : <span class="KEYWORD">public</span> bidirectional_iterator&lt;T, Distance&gt; {
    <span class="KEYWORD">typedef</span> reverse_bidirectional_iterator&lt;BidirectionalIterator, T,
                        Reference, Distance&gt; self;
    <span class="KEYWORD">friend bool operator</span>==(<span class="KEYWORD">const</span> self&amp; o, <span class="KEYWORD">const</span> self&amp; y);
<span class="KEYWORD">protected</span>:
    BidirectionalIterator current;
<span class="KEYWORD">public</span>:
    reverse_bidirectional_iterator() {}
    reverse_bidirectional_iterator(BidirectionalIterator o) 
        : current(o) {}
    BidirectionalIterator base() { <span class="KEYWORD">return</span> current; }
    Reference <span class="KEYWORD">operator</span>*() <span class="KEYWORD">const</span> {
        BidirectionalIterator tmp = current;
        <span class="KEYWORD">return</span> *--tmp;
    }
    self&amp; <span class="KEYWORD">operator</span>++() {
        --current;
        <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>;
    }
    self <span class="KEYWORD">operator</span>++(<span class="KEYWORD">int</span>) {
        self tmp = *<span class="KEYWORD">this</span>;
        --current;
        <span class="KEYWORD">return</span> tmp;
    }
    self&amp; <span class="KEYWORD">operator</span>--() {
        ++current;
        <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>;
    }
    self <span class="KEYWORD">operator</span>--(<span class="KEYWORD">int</span>) {
        self tmp = *<span class="KEYWORD">this</span>;
        ++current;
        <span class="KEYWORD">return</span> tmp;
    }
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> BidirectionalIterator, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Reference, 
    <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline bool operator</span>==(
    <span class="KEYWORD">const</span> reverse_bidirectional_iterator&lt;BidirectionalIterator, T,
                        Reference, Distance&gt;&amp; x,
    <span class="KEYWORD">const</span> reverse_bidirectional_iterator&lt;BidirectionalIterator,
                        T, Reference, Distance&gt;&amp; y){ 
    <span class="KEYWORD">return</span> x.current == y.current;
}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Reference = T&amp;,
    <span class="KEYWORD">class</span> Distance = ptrdiff_t&gt;
<span class="KEYWORD">class</span> reverse_iterator : <span class="KEYWORD">public</span> random_access_iterator&lt;T, Distance&gt;{
    <span class="KEYWORD">typedef</span> reverse_iterator&lt;RandomAccessIterator, T, Reference,
                Distance&gt; self;
    <span class="KEYWORD">friend bool operator</span>==(<span class="KEYWORD">const</span> self&amp; x, <span class="KEYWORD">const</span> self&amp; y);
    <span class="KEYWORD">friend bool operator</span>&lt;(<span class="KEYWORD">const</span> self&amp; x, <span class="KEYWORD">const</span> self&amp; y);
    <span class="KEYWORD">friend</span> Distance <span class="KEYWORD">operator</span>-(<span class="KEYWORD">const</span> self&amp; x, <span class="KEYWORD">const</span> self&amp; y);
    <span class="KEYWORD">friend</span> self <span class="KEYWORD">operator</span>+(Distance n, <span class="KEYWORD">const</span> self&amp; x);
<span class="KEYWORD">protected</span>:
    RandomAccessIterator current;
<span class="KEYWORD">public</span>:
    reverse_iterator() {}
    reverse_iterator(RandomAccessIterator x) : current (x) {}
    RandomAccessIterator base() { <span class="KEYWORD">return</span> current; }
    Reference <span class="KEYWORD">operator</span>*() <span class="KEYWORD">const</span> {
        RandomAccessIterator tmp = current;
        <span class="KEYWORD">return</span> *--tmp;
    }
    self&amp; <span class="KEYWORD">operator</span>++() {
        --current;
        <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>;
    }
    self <span class="KEYWORD">operator</span>++(<span class="KEYWORD">int</span>) {
        self tmp = *<span class="KEYWORD">this</span>;
        --current;
        <span class="KEYWORD">return</span> tmp;
    }
    self&amp; <span class="KEYWORD">operator</span>--() {
        ++current;
        <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>;
    }
    self <span class="KEYWORD">operator</span>--(<span class="KEYWORD">int</span>) {
        self tmp = *<span class="KEYWORD">this</span>;
        ++current;
        <span class="KEYWORD">return</span> tmp;
    }
    self <span class="KEYWORD">operator</span>+(Distance n) <span class="KEYWORD">const</span> {
        <span class="KEYWORD">return</span> self (current - n);
    }
    self&amp; <span class="KEYWORD">operator</span>+=(Distance n) {
        current -= n;
        <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>;
    }
    self <span class="KEYWORD">operator</span>-(Distance n) <span class="KEYWORD">const</span> {
        <span class="KEYWORD">return</span> self(current + n);
    }
    self <span class="KEYWORD">operator</span>-=(Distance n) {
        current +- n;
        <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>;
    } 
    Reference <span class="KEYWORD">operator</span>[](Distance n) { <span class="KEYWORD">return</span> *(*<span class="KEYWORD">this</span> + n);}
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Reference, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline bool operator</span>==(
    <span class="KEYWORD">const</span> reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt;&amp; x,
    <span class="KEYWORD">const</span> reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt;&amp; y) {
    <span class="KEYWORD">return</span> x.current == y.current;
}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Reference, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline bool operator</span>&lt;(
    <span class="KEYWORD">const</span> reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt;&amp; x,
    <span class="KEYWORD">const</span> reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt;&amp; y) {
    <span class="KEYWORD">return</span> y.current &lt; x.current;
}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Reference, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline</span> Distance <span class="KEYWORD">operator</span>-(
    <span class="KEYWORD">const</span> reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt;&amp; o,
    <span class="KEYWORD">const</span> reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt;&amp; y) {
    <span class="KEYWORD">return</span> y.current - x.current;
}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> RandomAccessIterator, <span class="KEYWORD">class</span> T, <span class="KEYWORD">class</span> Reference, <span class="KEYWORD">class</span> Distance&gt;
<span class="KEYWORD">inline</span> reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt; <span class="KEYWORD">operator</span>+( 
    Distance n, 
    <span class="KEYWORD">const</span> reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt;&amp; x) {
    <span class="KEYWORD">return</span> reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt; 
        (x.current - n);
}</pre>
</td></tr></tbody></table>
</div>


<h4 class="normal_text">Итераторы вставки (Insert iterators)</h4>
<p class="normal_text">Чтобы было возможно иметь дело с вставкой таким же образом, как с 
записью в массив, в библиотеке обеспечивается специальный вид адаптеров 
итераторов, называемых <i>итераторами вставки</i> (<i>insert iterators</i>). С 
обычными классами итераторов <br>&nbsp;&nbsp;&nbsp;&nbsp;<var>while (first != last) *result++ = 
*first++;</var><br><br>вызывает копирование диапазона <var>[first, last)</var> в 
диапазон, начинающийся с <var>result</var>. Тот же самый код с 
<var>result</var>, являющимся итератором вставки, вставит соответствующие 
элементы в контейнер. Такой механизм позволяет всем алгоритмам копирования в 
библиотеке работать в <i>режиме вставки</i> (<i>insert mode</i>) вместо обычного 
режима наложения записей.</p>

<p class="normal_text">Итератор вставки создаётся из контейнера и, возможно, одного из его 
итераторов, указывающих, где вставка происходит, если это ни в начале, ни в 
конце контейнера. Итераторы вставки удовлетворяют требованиям итераторов вывода. 
<var>operator* </var>возвращает непосредственно сам итератор вставки. 
Присваивание <var>operator=(const T&amp; х)</var> определено для итераторов 
вставки, чтобы разрешить запись в них, оно вставляет <var>х</var> прямо перед 
позицией, куда итератор вставки указывает. Другими словами, итератор вставки 
подобен курсору, указывающему в контейнер, где происходит вставка. 
<var>back_insert_iterator</var> вставляет элементы в конце контейнера, 
<var>front_insert_iterator</var> вставляет элементы в начале контейнера, а 
<var>insert_iterator</var> вставляет элементы, куда итератор указывает в 
контейнере. <var>back_inserter</var>, <var>front_inserter</var> и 
<var>inserter</var> - три функции, создающие итераторы вставки из контейнера. 
</p>

<div id="IDARDBBG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Container&gt;
<span class="KEYWORD">class</span> back_insert_iterator : <span class="KEYWORD">public</span> output_iterator {
<span class="KEYWORD">protected</span>:
    Container&amp; container;
<span class="KEYWORD">public</span>:
    back_insert_iterator(Container&amp; x) : container(x) {}
    back_insert_iterator &lt;Container&gt;&amp;
    <span class="KEYWORD">operator</span>=(<span class="KEYWORD">const</span> Container::value_type&amp; value) {
        container.push_back(value);
        <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>;
    }
    back_insert_iterator&lt;Container&gt;&amp; <span class="KEYWORD">operator</span>*() { <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>; } 
    back_insert_iterator&lt;Container&gt;&amp; <span class="KEYWORD">operator</span>++() { <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>; }
    back_insert_iterator&lt;Container&gt;&amp; <span class="KEYWORD">operator</span>++(<span class="KEYWORD">int</span>) { <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>; }
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Container&gt;
back_insert_iterator&lt;Container&gt; back_inserter(Container&amp; x) { 
    <span class="KEYWORD">return</span> back_insert_iterator&lt;Container&gt;(x);
}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Container&gt;
<span class="KEYWORD">class</span> front_insert_iterator : <span class="KEYWORD">public</span> output_iterator {
<span class="KEYWORD">protected</span>:
    Container&amp; container;
<span class="KEYWORD">public</span>:
    front_insert_iterator(Container&amp; x) : container (x) {}
    front_insert_iterator&lt;Container&gt;&amp;
    <span class="KEYWORD">operator</span>=(<span class="KEYWORD">const</span> Container::value_type&amp; value) {
        container.push_front(value);
        <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>;
    }
    front_insert_iterator&lt;Container&gt;&amp; <span class="KEYWORD">operator</span>*() { <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>; }
    front_insert_iterator&lt;Container&gt;&amp; <span class="KEYWORD">operator</span>++() { <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>; }
    front_insert_iterator&lt;Container&gt;&amp; <span class="KEYWORD">operator</span>++(<span class="KEYWORD">int</span>) { <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>;} 
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Container&gt;
front_insert_iterator&lt;Container&gt; front_inserter(Container&amp; x) { 
    <span class="KEYWORD">return</span> front_insert_iterator&lt;Container&gt;(o);
}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Container&gt;
<span class="KEYWORD">class</span> insert_iterator : <span class="KEYWORD">public</span> output_iterator {
<span class="KEYWORD">protected</span>:
    Container&amp; container;
    Container::iterator iter;
<span class="KEYWORD">public</span>:
    insert_iterator(Container&amp; x, Container::iterator i)
        : container (x), iter(i) {}
    insert_iterator&lt;Container&gt;&amp; <span class="KEYWORD">operator</span>=(<span class="KEYWORD">const</span> Container::value_type&amp; value) { 
        iter = container.insert(iter, value);
        ++iter;
        <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>;
    }
    insert_iterator&lt;Container&gt;&amp; <span class="KEYWORD">operator</span>*() { <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>; }
    insert_iterator&lt;Container&gt;&amp; <span class="KEYWORD">operator</span>++() { <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>; }
    insert_iterator&lt;Container&gt;&amp; <span class="KEYWORD">operator</span>++(<span class="KEYWORD">int</span>) { <span class="KEYWORD">return</span> *<span class="KEYWORD">this</span>; }
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Container, <span class="KEYWORD">class</span> Iterator&gt;
insert_iterator&amp;tl;Container&gt; inserter(Container&amp; x, Iterator i) {
    <span class="KEYWORD">return</span> insert_iterator&lt;Container&gt;(x, Container::iterator(i));
}</pre>
</td></tr></tbody></table>
</div>



<h3 class="lem_para">Адаптеры функций (Function adaptors)<a name="IDAEIBBG"></a></h3>
<p>Функциональные адаптеры работают только с классами функциональных 
объектов с определёнными типами параметров и типом результата. </p>

<h4 class="lem_sub_para2">Отрицатели (Negators)</h4>
<p>Отрицатели <var>not1</var> и <var>not2</var> берут унарный и бинарный 
предикаты соответственно и возвращают их дополнения. </p>

<div id="IDASIBBG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Predicate&gt;
<span class="KEYWORD">class</span> unary_negate : <span class="KEYWORD">public</span> unary_function&lt;Predicate::argument_type, <span class="KEYWORD">bool</span>&gt; {
<span class="KEYWORD">protected</span>:
    Predicate pred;
<span class="KEYWORD">public</span>:
    unary_negate(<span class="KEYWORD">const</span> Predicate&amp; x) : pred(x) {}
    <span class="KEYWORD">bool operator</span>()(<span class="KEYWORD">const</span> argument_type&amp; x) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> !pred(x); }
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Predicate&gt;
unary_negate&lt;Predicate&gt; not1(<span class="KEYWORD">const</span> Predicate&amp; pred) { 
    <span class="KEYWORD">return</span> unary_negate&lt;Predicate&gt;(pred);
}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Predicate&gt;
<span class="KEYWORD">class</span> binary_negate : <span class="KEYWORD">public</span> binary_function&lt;Predicate::first_argument_type,
        Predicate::second_argument_type, <span class="KEYWORD">bool</span>&gt; {
<span class="KEYWORD">protected</span>:
    Predicate pred;
<span class="KEYWORD">public</span>:
    binary_negate(<span class="KEYWORD">const</span> Predicate&amp; x) : pred(x) {}
    <span class="KEYWORD">bool operator</span>()(<span class="KEYWORD">const</span> first_argument_type&amp; x,
            <span class="KEYWORD">const</span> second_argument_type&amp; y) <span class="KEYWORD">const</span> {
        <span class="KEYWORD">return</span> !pred(x, y);
    }

};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Predicate&gt;
binary_negate&lt;Predicate&gt; not2(<span class="KEYWORD">const</span> Predicate&amp; pred) {
     <span class="KEYWORD">return</span> binary_negate&lt;Predicate&gt;(pred);
}</pre>
</td></tr></tbody></table>
</div>


<h4 class="lem_sub_para2">Привязки (Binders)</h4>
<p class="normal_text">Привязки <var>bind1st</var> и <var>bind2nd</var> берут функциональный 
объект <var>f</var> двух параметров и значение <var>x</var> и возвращают 
функциональный объект одного параметра, созданный из <var>f</var> с первым или 
вторым параметром соответственно, связанным с <var>х</var>. </p>

<div id="IDAILBBG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Predicate&gt;
<span class="KEYWORD">class</span> binder1st : <span class="KEYWORD">public</span> unary_function {
<span class="KEYWORD">protected</span>:
    Operation op;
    Operation::first_argument_type value;
<span class="KEYWORD">public</span>:
    binder1st(<span class="KEYWORD">const</span> Operation&amp; x, <span class="KEYWORD">const</span> Operation::first_argument_type&amp; y)
        : op(x), value(y) {}
    result_type <span class="KEYWORD">operator</span>()(<span class="KEYWORD">const</span> argument_type&amp; x) <span class="KEYWORD">const</span> { 
        <span class="KEYWORD">return</span> op(value, x); 
    }
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Operation, <span class="KEYWORD">class</span> T&gt;
binder1st&lt;<span class="NUMBER">0</span>peration&gt; bind1st(<span class="KEYWORD">const</span> Operation&amp; op, <span class="KEYWORD">const</span> T&amp; x) {
    <span class="KEYWORD">return</span> binder1st&lt;<span class="NUMBER">0</span>peration&gt;(op, Operation::first_argument_type(x));
}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Operation&gt;
<span class="KEYWORD">class</span> binder2nd : <span class="KEYWORD">public</span> unary_function&lt;<span class="NUMBER">0</span>peration::first_argument_type,
                    Operation::result_type&gt; {
<span class="KEYWORD">protected</span>:
    Operation op;
    Operation::second_argument_type value;
<span class="KEYWORD">public</span>:
    binder2nd(<span class="KEYWORD">const</span> Operation&amp; x, <span class="KEYWORD">const</span> Operation::second_argument_type&amp; y)
        : op(x), value(y) {}
    result_type <span class="KEYWORD">operator</span>()(<span class="KEYWORD">const</span> argument_type&amp; x) <span class="KEYWORD">const</span> { 
        <span class="KEYWORD">return</span> op(x, value);
    }
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Operation, <span class="KEYWORD">class</span> T&gt;
binder2nd&lt;Operation&gt; bind2nd(<span class="KEYWORD">const</span> Operation&amp; op, <span class="KEYWORD">const</span> T&amp; x) {
    <span class="KEYWORD">return</span> binder2nd&lt;<span class="NUMBER">0</span>peration&gt;(op, Operation::second_argument_type(x));
}</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text">Например, <var>find_if(v.begin(), v.end(), bind2nd(greater&lt;int&gt;(), 
5))</var> находит первое целое число в векторе <var>v</var> большее, чем 5; 
<var>find_if(v.begin(), v.end(), bind1st(greater&lt;int&gt;(), 5))</var> находит 
первое целое число в <var>v</var> меньшее, чем 5. </p>


<h4 class="lem_sub_para2">Адаптеры указателей на функции (Adaptors for pointers to functions)</h4>
<p class="normal_text">Чтобы позволить указателям на (унарные и бинарные) функции работать с 
функциональными адаптерами, библиотека обеспечивает следующее: </p>

<div id="IDAKOBBG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Arg, <span class="KEYWORD">class</span> Result&gt;
<span class="KEYWORD">class</span> pointer_to_unary_function : <span class="KEYWORD">public</span> unary_function&lt;Arg, Result&gt; {
<span class="KEYWORD">protected</span>:
    Result (*ptr)(Arg);
<span class="KEYWORD">public</span>:
    pointer_to_unary_function() {}
    pointer_to_unary_function(Result (*x)(Arg)) : ptr(x) {}
    Result <span class="KEYWORD">operator</span>()(Arg x) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> ptr(x); } 
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Arg, <span class="KEYWORD">class</span> Result&gt;
pointer_to_unary_function&lt;Arg, Result&gt; ptr_fun(Result (*x)(Arg)) { 
    <span class="KEYWORD">return</span> pointer_to_unary_function&lt;Arg, Result&gt;(x);
}

<span class="KEYWORD">template</span> 
<span class="KEYWORD">class</span> pointer_to_binary_function : <span class="KEYWORD">public</span> binary_function {
<span class="KEYWORD">protected</span>:
    Result (*ptr)(Arg1, Arg2);
<span class="KEYWORD">public</span>:
    pointer_to_binary_function() {}
    pointer_to_binary_function(Result (*x)(Arg1, Arg2)) : ptr(o) {}
    Result <span class="KEYWORD">operator</span>()(Arg1 x, Arg2 y) <span class="KEYWORD">const</span> { <span class="KEYWORD">return</span> ptr(x, y); }
};

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> Arg1, <span class="KEYWORD">class</span> Arg2, <span class="KEYWORD">class</span> Result&gt;
pointer_to_binary_function&lt;Arg1, Arg2, Result&gt;
ptr_fun(Result (*x)(Arg1, Arg2)) {
    <span class="KEYWORD">return</span> pointer_to_binary_function&lt;Argl, Arg2, Result&gt;(x);
}</pre>
</td></tr></tbody></table>
</div>

<p>Например, <var>replace_if(v.begin(), v.end(), 
not1(bind2nd(ptr_fun(strcmp), "C")), "C++")</var> заменяет все <var>"С"</var> на 
<var>"C++"</var> в последовательности <var>v</var>. </p>
<p>Системы трансляции, которые имеют множественный указатель на типы 
функций, должны обеспечить дополнительные шаблоны функций <var>ptr_fun</var>. 
</p>


<h2 class="lem_para">Примитивы управления памятью (Memory Handling Primitives)<a name="IDAWQBBG"></a></h2>
<p>Чтобы получать типичный указатель на неинициализированный буфер памяти 
данного размера, определена следующая функция: </p>

<div id="IDA1QBBG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt; 
<span class="KEYWORD">inline</span> T* allocate(ptrdiff_t n, O*); <span class="COMMENT">// n &gt;= 0</span>
</pre>
</td></tr></tbody></table>
</div>

<p>Размер (в байтах) распределённого буфера - не меньше <var>n*sizeof(T)</var>. </p>
<p class="normal_text">Для каждой модели памяти имеется соответствующий шаблон функции 
<var>allocate</var>, определённый с типом первого параметра, являющимся типом 
расстояния указателей в модели памяти.</p>
<p>Например, если система трансляции поддерживает <var>_huge</var> 
указатели с типом расстояния <var>long long</var>, обеспечивается следующая 
шаблонная функция: </p>

<div id="IDATRBBG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">inline</span> T _huge* allocate(<span class="KEYWORD">long long</span> n, T _huge *);
</pre>
</td></tr></tbody></table>
</div>

<p>Также обеспечиваются следующие функции: </p>

<div id="IDA5RBBG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">inline void</span> deallocate(T* buffer);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T1, <span class="KEYWORD">class</span> T2&gt;
<span class="KEYWORD">inline void</span> construct(T1* p, <span class="KEYWORD">const</span> T2&amp; value) { <span class="KEYWORD">new</span> (p) T1(value);}

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">inline void</span> destroy(T* pointer) { pointer-&gt;~T();}
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>deallocate</var> освобождает буфер, выделенный <var>allocate</var>. 
Для каждой модели памяти имеются соответствующие шаблоны функций 
<var>deallocate</var>, <var>construct</var> и <var>destroy</var>, определённые с 
типом первого параметра, являющимся типом указателя в модели памяти. </p>

<div id="IDAFTBBG">
<table class="code" width="98%"><tbody><tr><td>
<pre><span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
pair&lt;T*, ptrdiff_t&gt; get_temporary_buffer(ptrdiff_t n, T*);

<span class="KEYWORD">template</span> &lt;<span class="KEYWORD">class</span> T&gt;
<span class="KEYWORD">void</span> return_temporary_buffer(T* p);
</pre>
</td></tr></tbody></table>
</div>

<p class="normal_text"><var>get_temporary_buffer</var> ищет наибольший буфер, не больше чем 
<var>n*sizeof(T)</var>, и возвращает пару, состоящую из адреса и размера (в 
единицах <var>sizeof(T)</var>) буфера. <var>return_temporary_buffer</var> 
возвращает буфер, выделенный <var>get_temporary_buffer</var>. </p>

<hr size="1" color="#C0C0C0">
	

<h5 align="right"><font size="1">Авторы: <a target="_blank" href="mailto:stepanov@mti.sgi.com" title="Отправить письмо">Александр Степанов</a>,
<a target="_blank" href="mailto:lee@hlp.hp.com" title="Отправить письмо">Менг Ли</a></font></h5>
<h5 align="right"><font size="1">Перевод: <a target="_blank" href="mailto:Sukhanov@galaktika.ru" title="Отправить письмо">Алексей Суханов</a>,
<a target="_blank" href="mailto:Ky_andry@mail.ru" title="Отправить письмо">Андрей Кутырин</a>,
Григорий Александрович Милонов
<a target="_blank" href="http://www.vega.mirea.ac.ru/%7Eandry/stl">Московский Государственный Институт Радиотехники, Электроники и Автоматики (Технический Университет)</a>
</font>
</h5>
<p class="no_indent" align="right"><b>Правка</b>: <i>Elijah 
Koziev</i> <span lang="en-us">08</span>.0<span lang="en-us">5</span>.2005</p>
<font face="Arial" size="1">
<span style="color: rgb(0, 0, 153);">
&nbsp;&nbsp;© <a href="http://solarix.ru/contacts/contacts.shtml">Mental Computing</a> 2010
</span>
</font>

<a href="http://www.solarix.ru/map/site-map.shtml" id="sitemap_link" title="Карта сайта">
<img id="img_sitemap" src="STL%20-%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2.%20%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20C++%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%B0_files/sitemap0.png" onmouseover="StartResizing('img_sitemap','/pix/menu/sitemap',0,3)" onmouseout="imgOFF('img_sitemap','/pix/menu/sitemap0.png')" border="0">
</a>

<a href="mailto:MentalComputing@gmail.com" id="mail_link" title="Связь с разработчиками">
<img id="img_mail" src="STL%20-%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2.%20%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20C++%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%B0_files/mail0.png" onmouseover="StartResizing('img_mail','/pix/menu/mail',0,3)" onmouseout="imgOFF('img_mail','/pix/menu/mail0.png')" border="0">
</a>

<a href="http://www.solarix.ru/for_users/map/map.shtml" id="download_link" title="Скачать">
<img id="img_download" src="STL%20-%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2.%20%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20C++%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%B0_files/save0.png" onmouseover="StartResizing('img_download','/pix/menu/save',0,3)" onmouseout="imgOFF('img_download','/pix/menu/save0.png')" border="0">
</a>

<a href="http://www.solarix.ru/index.shtml" id="home_link" title="Главная страница">
<img id="img_home" src="STL%20-%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2.%20%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20C++%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%B0_files/home0.png" onmouseover="StartResizing('img_home','/pix/menu/home',0,3)" onmouseout="imgOFF('img_home','/pix/menu/home0.png')" border="0">
</a>

<a href="http://feeds.feedburner.com/IntegraDesktopSearch" id="RSS_link" title="Подписка на новости в RSS">
<img id="img_rss" src="STL%20-%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2.%20%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20C++%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%B0_files/rss0.png" onmouseover="StartResizing('img_rss','/pix/menu/rss',0,3)" onmouseout="imgOFF('img_rss','/pix/menu/rss0.png')" border="0">
</a>

<a href="http://www.solarix.ru/contacts/contacts.shtml" id="home_link" title="Контакты - icq, почта, skype">
<img id="img_contacts" src="STL%20-%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2.%20%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20C++%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%B0_files/icq0.png" onmouseover="StartResizing('img_contacts','/pix/menu/icq',0,3)" onmouseout="imgOFF('img_contacts','/pix/menu/icq0.png')" border="0">
</a>

<a href="http://twitter.com/inkoziev" title="Новости в Twitter">
<img id="footer_img8" src="STL%20-%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2.%20%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20C++%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%B0_files/twitter.png" border="0">
</a>


<!-- Google.Analytics -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script><script src="STL%20-%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2.%20%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20C++%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%B0_files/ga.js" type="text/javascript"></script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-11028895-1");
pageTracker._trackPageview();
} catch(err) {}</script>
<!-- /Google.Analytics -->
      
<!-- Yandex.Metrika -->
<script src="STL%20-%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2.%20%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20C++%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%B0_files/watch.js" type="text/javascript"></script>
<script type="text/javascript">
try { var yaCounter288873 = new Ya.Metrika(288873); } catch(e){}
</script>
<noscript><div style="position: absolute;"><img src="//mc.yandex.ru/watch/288873" alt=""></div></noscript>
<!-- /Yandex.Metrika -->      




</body></html>