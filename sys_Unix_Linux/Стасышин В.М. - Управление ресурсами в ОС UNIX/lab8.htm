
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=KOI8-R">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Лабораторная работа N 8</TITLE>
</HEAD>
<BODY>

<B><FONT FACE="Times New Roman" SIZE=4><P ALIGN="CENTER">Лабораторная работа N 8</P>
<P ALIGN="CENTER">КЛИЕНТ-СЕРВЕРНЫЕ ВЗАИМОДЕЙСТВИЯ ПОСРЕДСТВОМ СОКЕТОВ В РЕЖИМЕ TCP-СОЕДИНЕНИЯ</P>                                                                                                                              
<P ALIGN="CENTER">Цель работы</P></B>
</FONT><FONT FACE="Times New Roman" SIZE=4><P ALIGN="JUSTIFY">Практическое освоение механизма сокетов. Построении TCP-соединений для межпроцессного взаимодействия программ Клиента и Сервера в модели "Клиент-сервер".</P>
<B><P ALIGN="CENTER">Содержание работы</P></B>

<OL>
<LI>Ознакомиться с заданием к лабораторной работе.</LI>
<LI>Ознакомиться с понятиями сокета, моделей взаимодействия между процессами на основе сокетов, структурами данных и адресацией, используемых при работе с сокетами, основными шагами при организации взаимодействия процессов в сети в режиме TCP-соединения.</LI>
<LI>Выбрать и изучить набор  системных вызовов, обеспечивающих решение задачи.</LI>
<LI>Для  указанного  варианта составить на языке Си две программы: программу сервера и программу клиента, реализующии требуемые действия.</LI>
<LI>Отладить и оттестировать составленную программу, используя инструментарий ОС UNIX.</LI>
<LI>Защитить лабораторную работу,  ответив на контрольные вопросы.</LI></OL>

<B><P ALIGN="CENTER">Методические указания к лабораторной работе</P></B>
<P ALIGN="JUSTIFY">Существует две модели взаимодействия между процессами в сети: модель соединений с протоколом TCP (Transmission Control Protocol), и модель дейтаграмм с протоколом UDP (User Datagram Protocol). В данной лабораторной работе используется первая из названных моделей.</P> 
<P ALIGN="JUSTIFY">Ниже приводятся основные шаги и необходимые системные вызовы для выполнения основных этапов при работе с сокетами в режиме TCP-соединения.</P>

<FONT FACE="Times New Roman"><B><P ALIGN="JUSTIFY">1. Адресация и создание сокета</P></B>
<P ALIGN="JUSTIFY">Совокупная информация об адресе, порте программы-адресата (абонента), модели соединения, протоколе взаимодействия составляет т.н. сокет (конечная абонентская точка), формально  представляющий собой структуру данных. Существует несколько видов сокетов: </P>
<UL>
<P ALIGN="JUSTIFY"><LI>обобщенный сокет (generic socket), определяется в файле <B>&lt;sys/socket.h&gt;</B>:</LI></P></UL>
<DIR>
<DIR>
<P ALIGN="JUSTIFY">struct sockaddr {</P>
<DIR>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">u_char&#9;  sa_family;&#9;&#9;/* Семейство адресов (домен)  */</P>
</FONT><P ALIGN="JUSTIFY">char<FONT FACE="Times New Roman"> &#9;  sa_data[];   };&#9;/* Адрес сокета */</P></DIR>
</DIR></DIR>
<UL>
<P ALIGN="JUSTIFY"><LI>Сокеты для связи через сеть, определяется в файле <B>&lt;netinet/in.h&gt;</B>:</LI></P></UL>
<DIR>
<DIR>
<P ALIGN="JUSTIFY">struct sockaddr_in {</P>
<DIR>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">u_char&#9;&#9; sin_len;&#9;/* Длина поля sockaddr_in (для FreeBSD)</FONT> */</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">&#9;u_char&#9;&#9; sin_family;&#9;/* Семейство адресов (домен)   */</P>
</FONT><P ALIGN="JUSTIFY">&#9;u_short <FONT FACE="Times New Roman">&#9; sin_port;&#9;/* Номер порта */</P>
</FONT><P ALIGN="JUSTIFY">&#9;struct in_addr  <FONT FACE="Times New Roman">sin_addr;&#9;/* IP-адрес */</P>
<P ALIGN="JUSTIFY">&#9;char&#9;sin_zero[8];&#9;};&#9;/* Поле выравнивания */</P>
</DIR></DIR></DIR>
<P ALIGN="JUSTIFY">где</FONT>&#9;            struct in_addr {</P><DIR>
<DIR>
<P ALIGN="JUSTIFY">n_int32_t&#9; s_addr}.</P></DIR>
</DIR>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Создается сокет при помощи системного вызова <B>socket()</B>.</P><DIR>
<DIR>
<DIR>
<DIR>
<P ALIGN="JUSTIFY"><B>#include &lt;sys/socket.h&gt;</B></P>
<P ALIGN="JUSTIFY"><B>int socket (int domain, int type, int protocol);</B></P></DIR>
</DIR>
</DIR>
</DIR>
<UL>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY"><LI>Параметр <B>domain</B> -  домен связи, в котором будет использоваться сокет (значение <B>AF_INET</B> - для домена Internet (соединение через сеть), <B>AF_UNIX</B> - домен, если процессы находятся на одном и том же компьютере);</LI></P>
<P ALIGN="JUSTIFY"><LI>Параметр <B>type</B> определяет тип создаваемого сокета (значение <B>SOCK_STREAM</B> - для  режима соединений, <B>SOCK_DGRAM</B> - для режима дейтаграмм);</LI></P>
<P ALIGN="JUSTIFY"><LI>Параметр <B>protocol</B> определяет используемый протокол (в случае protocol = 0 по умолчанию для сокета типа <B>SOCK_STREAM</B> будет использовать протокол TCP, а сокета типа <B>SOCK_DGRAM</B> - протокол UDP). </LI></P></UL>
<P ALIGN="JUSTIFY">При программировании TCP-соединения должны быть созданы сокеты (системный вызов <B>socket()</B>) и в программе сервера и в программе клиента, при этом в обеих программах сокеты связываются с адресом машины, на которую будет установлена программа сервера. Но, если в программе сервера для определения IP-адреса в структуре сокета может быть использована переменная <B>INADDR_ANY</B>, то в программе клиента для занесения в структуру сокета IP-адреса машины сервера необходимо использовать системный вызов <B>inet_addr()</B>.</P>
<P ALIGN="JUSTIFY">Сетевые вызовы <B>inet_addr()</B> и <B>inet_ntoa()</B> выполняют преобразования IP-адреса из формата текстовой строки "x.y.z.t" в структуру типа <B>in_addr</B> и обратно.<P>
<DIR>
<DIR>
<DIR>
<P ALIGN="JUSTIFY"><B>#include &lt;arpa/inet.h&gt;</B></P>
<P ALIGN="JUSTIFY"><B>in_addr_t inet_addr (const char *ip_address);</B></P>
<P ALIGN="JUSTIFY"><B>char * inet_ntoa(const struct in_addr in);</B></P>
</DIR>
</DIR>
</DIR>
<P ALIGN="JUSTIFY">Для того чтобы процесс мог ссылаться на адрес своего компьютера, файле <B>&lt;netinet/in.h&gt;</B> определена переменная <B>INADDR_ANY,</B> содержащая локальный адрес компьютера в формате <B>in_addr_t.</B></P>

<B><P>2. Связывание</P></B>
<P>Системный вызов <B>bind()</B> связывает сетевой адрес компьютера с идентификатором сокета.</P><DIR>
<DIR>
<P><B>#include&lt;sys/types.h&gt;</B></P>
<P><B>#include&lt;sys/socket.h&gt;</B></P>
<P><B>int bind (int sockfd, const struct sockaddr *address, size_t add_len);</B></P></DIR>
</DIR>
<UL>
<LI><B>sockfd</B> -<FONT FACE="Times New Roman"> дескриптор файла сокета, созданным с помощью вызова <B>socket(),</B> </LI>
<P ALIGN="JUSTIFY"><LI><B>address</B> <FONT FACE="Times New Roman">- указателем на обобщенную структуру адреса сокета, к которой преобразуется структура <B>sockaddr_in,</B> в случае передачи данных через сеть</FONT>. </LI></P>
<P ALIGN="JUSTIFY"><LI><B>size_t add_len</B> - <FONT FACE="Times New Roman">размер указанной структуры адреса сокета. </LI></P></UL>
<P ALIGN="JUSTIFY">В случае успешного завершения вызова <B>bind()</B> он возвращает значение 0. В случае ошибки, например, если сокет для этого адреса уже существует, вызов <B>bind()</B> возвращает значение -1. Переменная <B>errno</B> будет иметь при этом значение <B>EADDRINUSE</B>.</P>
<P ALIGN="JUSTIFY">Oперация связывания выполняется только в программе сервера</B>.</P>

<P><B>3. Включение приема TCP-соединений</B></P>
<P ALIGN="JUSTIFY">После выполнения связывания с адресом и перед тем, как какой-либо клиент сможет подключиться к созданному сокету, сервер должен включить прием соединений посредством системного вызова <B>listen()</B>.</P><DIR>
<DIR>
<DIR>
<DIR>
<P><B>#include&lt;sys/socket.h&gt;</B></P>
<P><B>int listen (int sockfd, int queue_size);</B></P></DIR>
</DIR>
</DIR>
</DIR>
<UL>
<LI><B>sockfd</B> - дескриптор файла сокета, созданным с помощью вызова <B>socket()</B>, </LI>
<LI><B>queue_size</B> - число запросов на соединение с сервером, которые могут стоять в очереди.</LI></UL>
<P ALIGN="JUSTIFY">Данная операция выполняется только в программе сервера</B>.</P>

<FONT FACE="Times New Roman"><B><P>4. Прием запроса на установку TCP-соединения</P></B>
<P ALIGN="JUSTIFY">Когда сервер получает от клиента запрос на соединение, он создает новый сокет для работы с новым соединением. Первый же сокет используется только для установки соединения. Дополнительный сокет для работы с соединением создается при помощи вызова <B>accept(),</B> принимающего очередное соединение.</P><DIR>
<DIR>
</FONT><P><B>#include&lt;sys/types.h&gt;</B></P>
<P><B>#include&lt;sys/socket.h&gt;</B></P>
<P><B>int accept (int sockfd, struct sockaddr *address, size_t *add_len);</B></P></DIR>
</DIR>
<UL>
<P ALIGN="JUSTIFY"><LI><B>sockfd</B> - дескриптор сокета, для которого ведется прием соединений; </LI></P>
<P ALIGN="JUSTIFY"><LI><B>address</B> - указатель на обобщенную структуру адреса сокета с информацией о клиенте; так как связь использует соединение адрес клиента знать не обязательно и допустимо задавать параметр <B>address</B> значением <B>NULL</B>;</LI></P>
<P ALIGN="JUSTIFY"><LI><B>add_len</B> - размер структуры адреса, заданной параметром <B>address</B>, если значение <B>address</B> не равно <B>NULL</B>. </LI></P></UL>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Возвращаемое значение соответствует идентификатору нового сокета, который будет использоваться для связи. До тех пор, пока от клиента не поступил запрос на соединение, процесс, выдавший системный вызов <B>accept()</B> переводится в состояние ожидания</FONT>.</P>
<P ALIGN="JUSTIFY">Данная операция выполняется только в программе сервера</B>.</P>

<P><B>5. Подключение клиента</B></P>
<P ALIGN="JUSTIFY">Для выполнения запроса на подключение к серверному процессу клиент использует системный вызов <B>connect()</B>.</P><DIR>
<DIR>
<P><B>#include&lt;sys/types.h&gt;</B></P>
<P>#<B>include&lt;sys/socket.h&gt;</B></P>
<P><B>int connect (int csockfd, const struct sockaddr *address, size_t add_len);</B></P></DIR>
</DIR>
<UL>
<FONT FACE="Times New Roman"><LI><B>сsockfd</B> - дескриптор файла сокета клиента, созданным с помощью вызова <B>socket()</B>; </LI>
<LI><B>address</B> - указателем на обобщенную структуру адреса сокета, к которой преобразуется структура <B>sockaddr_in</B>, в случае передачи данных через сеть; </LI>
<LI><B>size_t add_len</B> - размер указанной структуры адреса сокета. </LI></UL>
<P ALIGN="JUSTIFY">В случае успешного завершения вызова <B>connect()</B> он возвращает значение 0. В случае ошибки, системный вызов <B>connect()</B> возвращает значение -1, а переменная <B>errno</B> идентифицирует ошибку.</P>
<P ALIGN="JUSTIFY">Данная операция выполняется только в программе клиента</B>.</P>

<P><B>6. Пересылка данных</B></P>
<P ALIGN="JUSTIFY">Для сокетов типа <B>SOCK_STREAM</B> дескрипторы сокетов, полученные сервером посредством вызова <B>accept()</B> и клиентом с помощью вызова <B>socked()</B>, могут использоваться для чтения или записи. Для этого могут использоваться обычные вызовы <B>read()</B> и <B>write()</B>, либо специальные системные вызовы <B>send()</B> и <B>recv()</B>, позволяющие задавать дополнительные параметры пересылки данных по сети. Синхронизация данных при работе с сокетом аналогична передаче данных через программный канал. </P>
<DIR>
<DIR>
<P><B>#include&lt;sys/types.h&gt;</B></P>
<P><B>#include&lt;sys/socket.h&gt;</B></P>
<P><B>ssize_t recv (int sockfd, void *buffer, size_t length, int flags);</B></P>
<P><B>ssize_t send (int sockfd, const void *buffer, size_t length, int flags);</B></P>
</DIR>
</DIR>
<UL>
<LI><B>socfd</B> - дескриптор сокета, через который читаются или записываются данные;</LI>
<LI><B>buffer</B> - буфер, в который они помещаются или откуда отсылаются через сокет;</LI>
<LI><B>length</B> - размер буфера;</LI>
<LI><B>flags</B> - поле дополнительных опций при получении или передаче данных.</LI></UL>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">В случае успешного чтения/записи системные вызовы <B>send()</B> и <B>recv()</B> возвращают число прочитанных/отосланных байт, или -1 в случае ошибки; в случае разорванной связи (клиент разорвал TCP-соединение) вызов <B>recv()</B> (или <B>read()</B>) возвращают нулевое значение; если процесс пытается записать данные через разорванное TCP-соединение посредством <B>write()</B> или <B>send()</B>, то он получает сигнал <B>SIGPIPE</B>, который можно обработать, если предусмотрена обработка данного сигнала.</P>
<P ALIGN="JUSTIFY">В случае <B>flags = 0</B> вызовы <B>send()</B> и <B>recv()</B> полностью аналогичны системным вызовам <B>read()</B> и <B>write()</B>.</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Возможные комбинациями констант параметра <B>flags</B> системнного вызова <B>send()</B>:</P>
<UL>
<LI><B>MSG_PEEK</B>&#9;Процесс может просматривать данные, не "получая" их;</LI>
<LI><B>MSG_OOB</B>&#9;Обычные данные пропускаются. Процесс принимает только срочные данные, например, сигнал прерывания;</LI>
<LI><B>MSG_WAITALL</B>&#9;Возврат из вызова </FONT>recv<FONT FACE="Times New Roman"> произойдет только после получения всех данных.</LI>
</UL>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Возможные комбинациями констант параметра <B>flags</B> системного вызова <B>recv()</B>:</P>
<UL>
<LI><B>MSG_OOB</B>&#9;Передать срочные (out of band) данные;</LI>
<LI><P ALIGN="JUSTIFY"><B>MSG_DONTROUTE</B>&#9;При передаче сообщения игнорируются условия маршрутизации протокола более низкого уровня. Обычно это означает, что сообщение посылается по прямому, а не по самому быстрому маршруту (самый быстрый маршрут не обязательно прямой и может зависеть от текущего распределения нагрузки сети).</LI>
</UL>
<P ALIGN="JUSTIFY">Данные операции выполняются и в программе сервера и в программе клиента</B>.</P>

<P><B>7. Закрытие TCP-соединения</B></P>
<P ALIGN="JUSTIFY">Закрываются сокеты так же, как и обычные дескрипторы файлового ввода/вывода, - при помощи системного вызова <B>close()</B>. Для сокета <B>SOCK_STREAM</B> ядро гарантирует, что все записанные в сокет данные будут переданы принимающему процессу. </P>
<P ALIGN="JUSTIFY">Данные операции выполняются и в программе сервера и в программе клиента</B>.</P>

<B><P ALIGN="CENTER">Варианты заданий</P></B>

<OL>
<P ALIGN="JUSTIFY"><LI>Организовать взаимодействие типа клиент - сервер. Клиент делает запрос серверу на выполнение какой-либо команды. Сервер выполняет эту команду и возвращает результаты клиенту.</LI></P>
<P ALIGN="JUSTIFY"><LI>Организовать взаимодействие типа клиент - сервер. Клиент делает запрос серверу о передаче файлов с определенным расширением из указанной директории. Сервер сканирует указанную директорию и отправляет клиенту список файлов, удовлетворяющих запросу.</LI></P>
<P ALIGN="JUSTIFY"><LI>Организовать взаимодействие типа клиент - сервер. Сервер при подключении к нему нового клиента высылает список IP-адресов уже подключенных клиентов. А остальным клиентам рассылается сообщение в виде IP-адреса о том, что подключился такой-то клиент.</LI></P>
<P ALIGN="JUSTIFY"><LI>Организовать взаимодействие типа клиент - сервер. Клиент при входе в связь с сервером должен ввести пароль. Разрешено сделать три попытки. Если пароль не верен, сервер должен блокировать IP-адрес клиента на 5 минут.</LI></P>
<P ALIGN="JUSTIFY"><LI>Организовать взаимодействие типа клиент - сервер. Клиенты подключается к первому серверу, и передают запрос на получение определенного файла. Если этого файла нет, сервер подключается ко второму серверу и ищет файл там. Затем либо найденный файл пересылается клиенту, либо высылается сообщение, то такого файла нет.</LI></P>
<P ALIGN="JUSTIFY"><LI>Организовать взаимодействие типа клиент - сервер. К серверу одновременно может подключиться только один клиент. Остальные клиенты заносятся в очередь, и им высылается сообщение об ожидании освобождения сервера.</LI></P>
<P ALIGN="JUSTIFY"><LI>Организовать взаимодействие типа клиент - сервер. Клиент отсылает строку серверу. Сервер отсылает данную строку на другие сервера, список которых хранится в файле, а там уже осуществляется поиск файлов содержащих данную строку. Результаты поиска отсылаются клиенту.</LI></P>
<P ALIGN="JUSTIFY"><LI>Эмуляция </FONT>DNS <FONT FACE="Times New Roman">сервера. Клиент подсоединяется к серверу, IP которого хранится в файле </FONT>dns.url<FONT FACE="Times New Roman"> и делает ему запрос на подключение к серверу </FONT>&quot;<FONT FACE="Times New Roman">Имя сервера</FONT>&quot;. DNS<FONT FACE="Times New Roman">-сервер имеет список, хранящийся в файле о соответствии имен серверов и </FONT>IP-<FONT FACE="Times New Roman">адресов. Если в списке нет </FONT>&quot;<FONT FACE="Times New Roman">имени сервера</FONT>&quot;<FONT FACE="Times New Roman"> запрошенного клиентом, то сервер </FONT>DNS<FONT FACE="Times New Roman"> подключается последовательно к другим серверам, хранящимся в файле </FONT>dns.url <FONT FACE="Times New Roman">и т.д. Если сервер не найден, клиенту возвращается соответствующее сообщение.</LI></P>
<P ALIGN="JUSTIFY"><LI>Организовать чат. К серверу подключаются клиенты. При подключении клиента сервер спрашивает имя, под которым клиент будет известен в соединении. Сервер хранит IP-адреса подключаемых клиентов и их имена. Все сообщения каждого клиента рассылаются остальным в виде "</FONT>&quot;<FONT FACE="Times New Roman">имя клиента</FONT>&quot; - <FONT FACE="Times New Roman">сообщение". Сообщения рассылаются сервером всем клиентам также при вхождении в связь нового клиента, и выходе какого-либо клиента</LI></P></OL>

<B><P ALIGN="CENTER">Контрольные вопросы</P></B>
<OL>

<LI>Какова структура IP-адреса?</LI>
<LI>Как поместить и извлечь IP-адрес из структуры сокета?</LI>
<LI>В чем разница между моделями TCP-соединения и дейтаграмм ?</LI>
<LI>Каковы основные шаги межпроцессоного взаимодействия в модели TCP-соединения?</LI>
<LI>Каковы основные шаги межпроцессоного взаимодействия в модели дейтаграмм?</LI>
<LI>Как занести в структуру сокета IP-адрес своего компьютера?</LI>
<LI>Каким образом извлечь информацию о клиенте после установки TCP-соединения?</LI>
<LI>Какова реакция системных вызовов посылки и приема сообщений в модели TCP-соединения при разрыве связи?</LI></OL>


</FONT><FONT SIZE=2></FONT></BODY>
</HTML>








