<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=KOI8-R">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Лабораторная работа N 4</TITLE>
</HEAD>
<BODY>

<B><FONT FACE="Times New Roman" SIZE=4><P ALIGN="CENTER">Лабораторная работа N 4</P>
<P ALIGN="CENTER">ПОРОЖДЕНИЕ НОВОГО ПРОЦЕССА И РАБОТА С НИМ. ЗАПУСК ПРОГРАММЫ В РАМКАХ ПОРОЖДЕННОГО ПРОЦЕССА. СИГНАЛЫ И КАНАЛЫ В ОС UNIX</P>                                                                                                                              
<P ALIGN="CENTER">Цель работы</P></B>
</FONT><FONT FACE="Times New Roman" SIZE=4><P ALIGN="JUSTIFY">Изучить программные средства создания процессов, получить навыки управления и синхронизации процессов, а также простейшие способы обмена данными между процессами. Ознакомиться со средствами динамического запуска программ в рамках порожденного процесса, изучить механизм сигналов ОС UNIX, позволяющий процессам реагировать на различные события, и каналы, как одно из средств обмена информацией между процессами. </P>
<B><P ALIGN="CENTER">Содержание работы</P></B>

<OL>
<LI>Изучить правила использования системных вызовов fork(), wait(), exit().</LI>
<LI>Ознакомиться с системными вызовами getpid(), getppid(), sеtpgrp(), getpgrp().</LI>
<LI>Изучить средства динамического запуска программ в ОС UNIX ( системные вызовы execl(), execv(),...).</LI>
<LI>Изучить средства работы с сигналами и каналами в ОС UNIX.</LI>
<LI>Ознакомиться с заданием к лабораторной работе.</LI>
<LI>Для указанного  варианта составить программу на языке Си, реализующую задание.</LI>
<LI>Отладить и оттестировать составленную программу, используя инструментарий ОС UNIX.</LI>
<LI>Защитить лабораторную работу, ответив на контрольные вопросы.</LI></OL>


<B><P ALIGN="CENTER">Методические указания к лабораторной работе</P></B>
<P ALIGN="JUSTIFY">Для порождения нового процесса (процесс-потомок) используется системный вызов fork(). Формат вызова:</P>
<P ALIGN="CENTER">int fork()</P>
<P ALIGN="JUSTIFY">Порожденный таким образом процесс представляет собой точную копию своего процесса-предка. Единственное различие между ними заключается в  том, что процесс-потомок в качестве возвращаемого значения системного  вызова fork() получает 0, а процесс-предок -идентификатор процесса-потомка. Кроме того, процесс-потомок наследует и весь контекст программной среды,  включая дескрипторы файлов, каналы и т.д. Наличие у процесса идентификатора дает возможность и ОС UNIX, и любому другому пользовательскому процессу получить информацию о функционирующих в данный момент процессах.</P>
<P ALIGN="JUSTIFY">Ожидание завершения процесса-потомка  родительским  процессом выполняется с помощью системного вызова wait()</P>
<P ALIGN="CENTER">int wait(int *status)</P>
<P ALIGN="JUSTIFY">В результате осуществления процессом системного вызова wait() функционирование процесса приостанавливается до момента завершения порожденного им процесса-потомка. По завершении процесса-потомка процесс-предок пробуждается и в качестве возвращаемого значения системного вызова  wait()  получает  идентификатор завершившегося процесса-потомка,  что позволяет процессу-предку определить, какой из его процессов-потомков завершился (если он имел более одного процесса-потомка). Аргумент системного вызова wait() представляет собой указатель на целочисленную переменную status, которая после завершения выполнения этого системного вызова будет содержать в старшем байте код завершения процесса-потомка,  установленный последним в качестве системного вызова exit(), а в младшем - индикатор причины завершения процесса-потомка.</P>
<P ALIGN="JUSTIFY">Формат системного вызова exit(), предназначенного для завершения функционирования процесса:</P>
<P ALIGN="CENTER">void exit(int status)</P>
<P ALIGN="JUSTIFY">Аргумент status является статусом завершения, который передается отцу процесса, если он выполнял системный вызов wait().</P>
<P ALIGN="JUSTIFY">Для получения собственного идентификатора процесса используется системный вызов getpid(), а для получения идентификатора процесса-отца - системный вызов getppid():</P>
<P ALIGN="CENTER">int getpid()</P>
<P ALIGN="CENTER">int getppid()</P>
<P ALIGN="JUSTIFY">Вместе с идентификатором процесса каждому процессу в ОС UNIX ставится в соответствие также идентификатор группы процессов. В группу процессов объединяются все процессы,  являющиеся  процессами-потомками одного и того же процесса. Организация новой группы процессов выполняется системным вызовом getpgrp(), а получение собственного идентификатора  группы  процессов - системным вызовом getpgrp(). Их формат:</P>
<P ALIGN="CENTER">int setpgrp()</P>
<P ALIGN="CENTER">int getpgrp()</P>
<P ALIGN="JUSTIFY">С практической точки зрения в большинстве случаев в рамках порожденного процесса загружается для выполнения программа, определенная одним из системных вызовов execl(), execv(),... Каждый из этих системных вызовов осуществляет смену программы, определяющей функционирование данного процесса:</P>

<DIR><DIR>
<P>execl(name,arg0,arg1,...,argn,0)</P>
<P>char *name, *arg0, *arg1,...,*argn;</P>
<P>execv(name,argv)</P>
<P>char *name, *argv[];</P>
<P>execle(name,arg0,arg1,...,argn,0,envp)</P>
<P>char *name, *arg0, *arg1,...,*argn,*envp[];</P>
<P>execve(name,argv,envp)</P>
<P>char *name, *arg[],*envp[];</P>
</DIR></DIR>

<P ALIGN="JUSTIFY">Сигналы - это программное средство, с помощью которого может быть прервано функционирование процесса в ОС UNIX. Механизм сигналов позволяет процессам реагировать на различные события, которые могут произойти в ходе функционирования процесса внутри него самого или во внешнем мире. Каждому сигналу ставятся в соответствие номер сигнала и строковая константа, используемая для осмысленной идентификации сигнала. Эта взаимосвязь отображена в файле описаний &lt;signal.h&gt;. Для посылки  сигнала  используется  системный  вызов, имеющий формат</P>
<P ALIGN="CENTER">void kill(int pid, int sig)</P>
<P ALIGN="JUSTIFY">В результате осуществления такого системного вызова сигнал, специфицированный аргументом sig, будет послан процессу, который имеет идентификатор pid. Если pid не превосходит 1, сигнал будет послан целой группе процессов.</P>
<P ALIGN="JUSTIFY">Использование системного вызова signal() позволяет процессу самостоятельно определить свою реакцию на получение того или иного события (сигнала):</P>
<P ALIGN="CENTER">int (*signal(sig, func) ()</P>
<P ALIGN="CENTER">int sig; int (*func)();</P>
<P ALIGN="JUSTIFY">Реакцией процесса, осуществившего системный вызов signal() с аргументом func, при получении сигнала sig будет вызов функции func().</P>
<P>Системный вызов  pause()  позволяет  приостановить процесс до тех пор, пока не будет получен какой-либо сигнал:</P>
<P ALIGN="CENTER">void pause()</P>
<P>Системный вызов alarm(n) обеспечивает посылку процессу сигнала SIGALARM через n секунд.</P>
<P ALIGN="JUSTIFY">В ОС UNIX существует специальный вид взаимодействия между процессами - программный канал.  Программный канал создается с помощью системного вызова pipe(), формат которого</P>
<P ALIGN="CENTER">int fd[2];</P>
<P ALIGN="CENTER">pipe(fd)</P>
<P ALIGN="JUSTIFY">Системный вызов pipe() возвращает два дескриптора файла: один для записи данных в канал, другой - для чтения. После этого все операции передачи  данных  выполняются с помощью системных вызовов ввода-вывода read/write. При этом система ввода-вывода обеспечивает приостановку  процессов, если канал заполнен (при записи) или пуст (при чтении). Таких программных каналов процесс может установить несколько. Отметим, что установление связи через программный канал опирается на наследование файлов. Взаимодействующие процессы должны быть родственными.</P>

<B><P ALIGN="CENTER">Задание к лабораторной работе</P></B>
<P  ALIGN="JUSTIFY">I. Разработать программу, реализующую действия, указанные в задании к лабораторной работе с учетом следующих требований:</P>
<OL>
<LI>все действия, относящиеся как к родительскому процессу, так и к  порожденным процессам, выполняются в рамках одного исполняемого файла;</LI>
<LI>обмен данными между процессом-отцом и процессом-потомком предлагается выполнить посредством временного файла: процесс-отец после порождения процесса-потомка постоянно опрашивает временный файл, ожидая появления в нем информации от процесса-потомка;</LI>
<LI>если процессов-потомков несколько, и все они подготавливают некоторую информацию для процесса-родителя, каждый из процессов помещает в файл некоторую структурированную запись, при этом в этой структурированной записи содержатся сведения о том, какой процесс посылает запись, и сама подготовленная информация.</LI>
</OL>
<P>II. Модифицировать ранее разработанную программу с учетом следующих требований:</P>
<OL>
<LI>действия процесса-потомка реализуются отдельной программой, запускаемой по одному из системных вызовов execl(), execv() и т.д. из процесса-потомка;</LI>
<LI>процесс-потомок, после порождения, должен начинать и завершать свое функционирование по сигналу, посылаемому процессом-предком (это же относится и к нескольким процессам-потомкам);</LI>
<LI>обмен данными между процессами необходимо осуществить через программный канал.</LI>
</OL>
<B><P ALIGN="CENTER">Варианты заданий</P></B>
<OL>

<P ALIGN="JUSTIFY"><LI>Разработать программу, вычисляющую число сочетаний</FONT><FONT SIZE=4> C(k,n)=n!/(k!*(n-k)!). </FONT><FONT FACE="Times New Roman" SIZE=4>Для вычисления факториалов n!, </FONT><FONT SIZE=4>k!, (n-k)! </FONT><FONT FACE="Times New Roman" SIZE=4>должны быть порождены три параллельных процесса-потомка.</LI></P>
<P ALIGN="JUSTIFY"><LI>Разработать программу, вычисляющую плотность нормального</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>распределения в точке x по формуле  f(x)=Exp(-x**2/2)/Sqrt(2*Пи).</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>Для нахождения Пи и Exp(-x**2/2) программа должна породить два параллельных процесса,  вычисляющих эти величины путем разложения в</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>ряд по формулам вычислительной математики.</LI></P>
<P ALIGN="JUSTIFY"><LI>Разработать программу, вычисляющую плотность выпуклого</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>распределения в точке х по формуле f(x)=(1-Cos(x))/(Пи*x**2). Для</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>нахождения  Пи и Cos(х) программа должна породить два параллельных</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>процесса, вычисляющих эти величины путем разложения в ряд по формулам вычислительной математики.</LI></P>
<P ALIGN="JUSTIFY"><LI>Разработать программу, вычисляющую значение плотности</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>распределения  Коши в точке х=е по формуле f(x)=1/(Пи*(1+x**2)).</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>Для нахождения Пи и е**2 программа должна породить два  параллельных процесса, вычисляющих эти величины путем разложения в ряд по</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>формулам вычислительной математики.</LI></P>
<P ALIGN="JUSTIFY"><LI>Разработать программу, вычисляющую интеграл в диапазоне от</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>0 до  1 от подинтегрального выражения 4*dx/(1+x**2) с помощью последовательности равномерно</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>распределенных на отрезке [0,1] случайных чисел, параллельно  генеририруемую процессом-потомком. Процесс-потомок должен завершиться после заранее заданного числа  генераций N.</LI></P>
<P ALIGN="JUSTIFY"><LI>Разработать программу, вычисляющую значение f(x) как сумму</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>ряда от k=1 до k=N от выражения (-1)**(k+1)*x**(2k-1)/(2k-1)! для</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>значений x,  равномерно распределенных на интервале [0,Пи], и выводящую полученный результат f(x) в файл в двоичном формате. В это</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>время предварительно подготовленный процесс-потомок читает данные</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>из файла, преобразовывает их в текстовую форму и выводит на экран</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>до тех пор, пока процесс-предок не передаст ему через файл ключевое слово (например, "STOP"), свидетельствующее об окончании процессов.</LI></P>
<P ALIGN="JUSTIFY"><LI>Задание,  аналогичное варианту 6,  но для вычисления суммы</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>ряда от k=0 до k=N для выражения  x**(2k+1)/(2k+1).</LI></P>
<P ALIGN="JUSTIFY"><LI>Разработать программу, вычисляющую число размещений по </FONT><FONT SIZE=4>r </FONT><FONT FACE="Times New Roman" SIZE=4>ячейкам</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>n  элементов N=n!/n(1)!*n(2)!*...*n(r)!, удовлетворяющих</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>требованию, что в ячейку с номером i попадает ровно n(i) элементов; i=1,...,r и n(1)+n(2)+...+n(r)=n. Естественно, что на каждый</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>факториал необходимо породить один процесс-потомок,  как указано в</FONT><FONT SIZE=4> </FONT><FONT FACE="Times New Roman" SIZE=4>варианте 1.</LI></P></OL>

<B><P ALIGN="CENTER">Контрольные вопросы</P></B>
<OL>
<LI>Каким  образом  может быть порожден новый процесс?  Какова структура нового процесса?</LI>
<LI>Если процесс-предок открывает файл, а затем порождает процесс-потомок, а тот,  в свою очередь, изменяет положение указателя чтения-записи файла, то изменится  ли  положение  указателя чтения-записи файла процесса-отца?</LI>
<LI>Что  произойдет,  если  процесс-потомок завершится раньше, чем процесс-предок осуществит системный вызов wait()?</LI>
<LI>Могут ли родственные процессы разделять общую память?</LI>
<LI>Каков алгоритм системного вызова fork()?</LI>
<LI>Какова структура таблиц открытых файлов, файлов и описателей файлов после создания процесса?</LI>
<LI>Каков алгоритм системного вызова exit()?</LI>
<LI>Каков алгоритм системного вызова wait()?</LI>
<LI>В чем разница между различными формами системных вызовов типа exec()?</LI>
<LI>Для чего используются сигналы в ОС UNIX?</LI>
<LI>Какие виды сигналов существуют в ОС UNIX?</LI>
<LI>Для чего используются каналы?</LI>
<LI>Какие требования предъявляются к процессам, чтобы они могли осуществлять обмен данными посредством каналов?</LI>
<LI>Каков максимальный размер программного канала и почему? </LI>
</OL>

</FONT><FONT SIZE=2></FONT></BODY>
</HTML>



