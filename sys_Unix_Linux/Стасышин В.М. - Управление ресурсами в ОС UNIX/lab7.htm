
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=KOI8-R">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Лабораторная работа N 7</TITLE>
</HEAD>
<BODY>

<B><FONT FACE="Times New Roman" SIZE=4><P ALIGN="CENTER">Лабораторная работа N 7</P>
<P ALIGN="CENTER">МЕЖПРОЦЕССОЕ ВЗАИМОДЕЙСТВИЕ ПРОГРАММ</P>                                                                                                                              
<P ALIGN="CENTER">Цель работы</P></B>
</FONT><FONT FACE="Times New Roman" SIZE=4><P ALIGN="JUSTIFY">Освоение средств IPC. Написание программ, использующих механизм семафоров, очередей сообщений, сегментов разделяемой памяти.</P>
<B><P ALIGN="CENTER">Содержание работы</P></B>

<OL>
<LI>Ознакомиться с заданием к лабораторной работе.</LI>
<LI>Ознакомиться с основными понятиями механизма IPC. </LI>
<LI>Изучить набор  системных вызовов, обеспечивающих решение задачи.</LI>
<LI>Отладить и оттестировать составленную программу, используя инструментарий ОС UNIX. </LI>
<LI>Защитить лабораторную работу,  ответив на контрольные вопросы.</LI></OL>

<B><P ALIGN="CENTER">Методические указания к лабораторной работе</P></B>

<P ALIGN="JUSTIFY">Механизм IPC (Inter-Process Communication Facilities) включает:  </P>
<UL>
<LI>средства, обеспечивающие возможность синхронизации процессов при доступе к совместно используемым ресурсам (семафоры - semaphores);  </LI>
<LI>средства, обеспечивающие возможность посылки процессом сообщений другому произвольному процессу (очереди сообщений - message queries); </LI>
<LI>средства, обеспечивающие возможность наличия общей для процессов памяти  (сегменты разделяемой памяти - shared memory segments).      </LI>
</UL>
<P ALIGN="JUSTIFY">Наиболее общим понятием IPC является ключ, хранимый в общесистемной таблице и обозначающий объект межпроцессного взаимодействия, доступный нескольким процессам. Обозначаемый ключом объект может быть очередью сообщений, набором семафоров или сегментом разделяемой памяти. Ключ имеет тип key_t, состав которого зависит от реализации и определяется в файле &lt;sys/types.h&gt. Ключ используется для создания объекта межпроцессного взаимодействия или получения доступа к существующему объекту. Обе операции выполняются посредством операции get. Результатом операции get является его целочисленный идентификатор, который может использоваться в других функциях межпроцессного взаимодействия.</P>
<B><P>I. Семафоры.</P></B>
<P ALIGN="JUSTIFY">Для работы с семафорами поддерживаются три системных вызова: </P>
<UL>
<LI>semget() для создания и получения доступа к набору семафоров; </LI>
<LI>semop() для манипулирования значениями семафоров (это тот системный вызов, который позволяет процессам синхронизоваться на основе использования семафоров</LI>
<LI>semctl() для выполнения разнообразных управляющих операций над набором семафоров</LI>
</UL>
<P ALIGN="JUSTIFY">Прототипы перечисленных системных вызовов описаны в файлах</P>
<DIR><DIR><DIR>
<P ALIGN="JUSTIFY">#include &lt;sys/ipc.h&gt;</P>
<P ALIGN="JUSTIFY">#include &lt;sys/sem.h&gt;</P>
</DIR></DIR></DIR>
<P ALIGN="JUSTIFY">Системный вызов semget() имеет следующий синтаксис: </P>
<P ALIGN="CENTER">semid = int semget(key_t key, int count, int flag), </P>
<P ALIGN="JUSTIFY">параметрами которого является ключ (key) набора семафоров и дополнительные флаги (flags), определенные в &lt;sys/ipc.h&gt, число семафоров в наборе семафоров (count), обладающих одним и тем же ключом. Системный вызов возвращает идентификатор набора семафоров semid. После вызова semget() индивидуальный семафор идентифицируется идентификатором набора семафоров и номером семафора в этом наборе. Флаги системного вызова semget() приведены ниже в таблице.</P>
<P ALIGN="RIGHT">Таблица</P>
<P ALIGN="CENTER">Флаги системного вызова semget()</P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=768>
<TR><TD WIDTH="18%" VALIGN="TOP">
<P ALIGN="JUSTIFY">IPC_CREAT</TD>
<TD WIDTH="82%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P>Semget создает новый семафор для данного ключа. Если флаг IPC_CREAT не задан, а набор семафоров с указанным ключом уже существует, то обращающийся процесс получит идентификатор существующего набора семафоров.</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<P ALIGN="JUSTIFY">IPC_EXLC</TD>
<TD WIDTH="82%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Флаг IPC_EXLC вместе с флагом IPC_CREAT предназначен для создания (и только для создания) набора семафоров. Если набор семафоров уже существует, Semget возвратит -1, а системная переменная errno будет содержать значение EEXIST.</FONT></TD>
</TR>
</TABLE>
<P ALIGN="JUSTIFY">Младшие 9 бит флага задают права доступа к набору семафоров.</P>
<P ALIGN="JUSTIFY">Системный вызов semctl() имеет формат </P>
<P ALIGN="CENTER">int semctl (int semid, int sem_num, int command, union semun arg),</P>
<P ALIGN="JUSTIFY">где semid - это идентификатор набора семафоров, sem_numb - номер семафора в группе, command - код операции, а arg - указатель на структуру, содержимое которой интерпретируется по-разному, в зависимости от операции. </P>
<P ALIGN="JUSTIFY">Структура msg имеет вид:</P>
<DIR>
<P ALIGN="JUSTIFY">union semun {	int val;</P>
<DIR><DIR>
<P ALIGN="JUSTIFY">struct semid_ds *buf;</P>
<P ALIGN="JUSTIFY">unsigned short *array; };</P>
</DIR></DIR></DIR>
<P ALIGN="JUSTIFY">С помощью semctl() можно </P>
<UL>
<LI>уничтожить набор семафоров или индивидуальный семафор в указанной группе (IPC_RMID);</LI>
<LI>вернуть значение отдельного семафора (GETVAL) или всех семафоров (GETALL);</LI>
<LI>установить значение отдельного семафора (SETVAL) или всех семафоров (SETALL);</LI>
<LI>вернуть число семафоров в наборе семафоров (GETPID).</LI>
</UL>
<P ALIGN="JUSTIFY">Основным системным вызовом для манипулирования семафором является </P>
<P ALIGN="CENTER">int semop (int semid, struct sembuf *op_array, count),</P>
<P ALIGN="JUSTIFY">где semid - это ранее полученный дескриптор группы семафоров, op_array - массив структур sembuf, определенных в файле &lt;sys/sem.h.h&gt и содержащих описания операций над семафорами группы, а count - размер этого массива. Значение, возвращаемое системным вызовом, является значением последнего обработанного семафора. Каждый элемент массива op_array имеет следующую структуру (структура sembuf): </P>
<UL>
<LI>номер семафора в указанном наборе семафоров</LI>
<LI>операция над семафором;</LI>
<LI>флаги.</LI>
</UL>
<P ALIGN="JUSTIFY">Если указанные в массиве op_array номера семафоров не выходят за пределы общего размера набора семафоров, то системный вызов последовательно меняет значение семафора (если это возможно) в соответствии со значением поля "операция".  Возможны три случая:</P>
<P ALIGN="JUSTIFY">1. Отрицательное значение sem_op.</P>
<UL>
<LI>Если значение поля операции sem_op отрицательно, и его абсолютное значение  меньше или равно значению семафора semval, то ядро прибавляет это отрицательное значение к значению семафора. </LI>
<LI>Если в результате значение семафора стало нулевым, то ядро активизирует все процессы, ожидающие нулевого значения этого семафора. </LI>
<LI>Если же значение поля операции sem_op по абсолютной величине больше семафора semval, то ядро увеличивает на единицу число процессов, ожидающих увеличения значения семафора и усыпляет текущий процесс до наступления этого события.  </LI>
</UL>
<P ALIGN="JUSTIFY">2. Положительное значение sem_op.</P>
<P ALIGN="JUSTIFY">Если значение поля операции sem_op положительно, то оно прибавляется к значению семафора semval, а все процессы, ожидающие увеличения значения семафора, активизируются (пробуждаются в терминологии UNIX). </P>
<P ALIGN="JUSTIFY">3. Нулевое значение sem_op. </P>
<UL>
<LI>Если значение поля операции sem_op равно нулю, то если значение семафора semval также равно нулю, выбирается следующий элемент массива op_array. </LI>
<LI>Если же значение семафора semval отлично от нуля, то ядро увеличивает на единицу число процессов, ожидающих нулевого значения семафора, а обратившийся процесс переводится в состояние ожидания    </LI>
</UL>
<P ALIGN="JUSTIFY">При использовании флага IPC_NOWAIT ядро ОС UNIX не блокирует текущий процесс, а лишь сообщает в ответных параметрах о возникновении ситуации, приведшей бы к блокированию процесса при отсутствии флага IPC_NOWAIT.</P>

<B><P>II. Очереди сообщений.</P></B>
<P ALIGN="JUSTIFY">Для обеспечения возможности обмена сообщениями между процессами механизм очередей поддерживается следующими системными вызовами: </P>
<UL>
<LI>msgget() для образования новой очереди сообщений или получения дескриптора существующей очереди; </LI>
<LI>msgsnd() для постановки сообщения в указанную очередь сообщений; </LI>
<LI>msgrcv() для выборки сообщения из очереди сообщений; </LI>
<LI>msgctl() для выполнения ряда управляющих действий</LI>
</UL>
<P ALIGN="JUSTIFY">Прототипы перечисленных системных вызовов описаны в файлах</P>
<DIR><DIR><DIR>
<P ALIGN="JUSTIFY">#include &lt;sys/ipc.h&gt;</P>
<P ALIGN="JUSTIFY">#include &lt;sys/msg.h&gt;</P>
</DIR></DIR></DIR>
<P ALIGN="JUSTIFY">По системному вызову msgget() в ответ на ключ (key) и набор флагов (полностью аналогичны флагам в системном вызове semget()) ядро либо создает новую очередь сообщений и возвращает пользователю идентификатор созданной очереди, либо находит элемент таблицы очередей сообщений, содержащий указанный ключ, и возвращает соответствующий идентификатор очереди: </P>
<P ALIGN="CENTER">int msgqid = msgget(key_t key, int flag).</P>
<P ALIGN="JUSTIFY">Для помещения сообщения в очередь служит системный вызов msgsnd(): </P>
<P ALIGN="CENTER">int msgsnd (int msgqid, void *msg, size_t size, int flag),</P>
<P ALIGN="JUSTIFY">где msg - это указатель на структуру длиной size, содержащую определяемый пользователем целочисленный тип сообщения и символьный массив-сообщение. </P>
<P ALIGN="JUSTIFY">Структура msg имеет вид:</P>
<DIR>
<P ALIGN="JUSTIFY">struct msg {</P>
<DIR>
<P ALIGN="JUSTIFY">long mtype;	         		/*    тип сообщения	*/</P>
<P ALIGN="JUSTIFY">char mtext[SOMEVALUE];   /* текст сообщения (SOMEVALUE - любое  */};</P>
</DIR></DIR>
<P ALIGN="JUSTIFY">Параметр flag определяет действия ядра при выходе за пределы допустимых размеров внутренней буферной памяти (флаг IPC_NOWAIT со значением, рассмотренным выше).</P>
<P ALIGN="JUSTIFY">Условиями успешной постановки сообщения в очередь являются: </P>
<UL>
<LI>наличие прав процесса по записи в данную очередь сообщений; </LI>
<LI>не превышение длиной сообщения заданного системой верхнего предела; </LI>
<LI>положительное значение указанного в сообщении типа сообщения. </LI>
</UL>
<P ALIGN="JUSTIFY"При выполнении указанных условий обратившийся процесс успешно продолжает свое выполнение, оставив отправленное сообщение в буфере очереди сообщений, а ядро активизирует (пробуждает) все процессы, ожидающие поступления сообщений из данной очереди.></P>
<P ALIGN="JUSTIFY">Если же оказывается, что новое сообщение невозможно буферизовать в ядре по причине превышения верхнего предела суммарной длины сообщений, находящихся в данной очереди сообщений (флаг IPC_NOWAIT при этом отсутствует), то обратившийся процесс откладывается (усыпляется) до тех пор, пока очередь сообщений не разгрузится процессами, ожидающими получения сообщений.</P>
<P ALIGN="JUSTIFY">Для приема сообщения используется системный вызов msgrcv(): </P>
<P ALIGN="CENTER">int msgrcv (int msgqid, void *msg, size_t size, long msg_type, int flag);</P>
<P ALIGN="JUSTIFY"Параметр msg - это указатель на структуру данных пользователя, предназначенную для размещения принятого сообщения; size задает размер области данных (массива байтов) в структуре msg; значение msg_type специфицирует тип сообщения, которое желательно принять; значение параметра flag указывает ядру, что следует предпринять, если в указанной очереди сообщений отсутствует сообщение с указанным типом. Возвращаемое значение системного вызова задает реальное число байтов, переданных пользователю.></P>
<P ALIGN="JUSTIFY">Системный вызов msgctl() </P>
<P ALIGN="CENTER">int msgctl (int msgqid, int command, struct msqid_ds *msg_stat) </P>
<P ALIGN="JUSTIFY">используется</P>
<UL>
<LI>для опроса состояния описателя очереди сообщений (command = IPC_STAT) и помещения его в структуру msg_stat (детали опускаем);</LI>
<LI>изменения его состояния (command = IPC_SET), например, изменения прав доступа к очереди;</LI>
<LI>для уничтожения указанной очереди сообщений (command = IPC_RMID).</LI>
</UL>

<B><P>III. Работа с разделяемой памятью.</P></B>
<P ALIGN="JUSTIFY">Для работы с разделяемой памятью используются системные вызовы: </P>
<UL>
<LI>shmget() создает новый сегмент разделяемой памяти или находит существующий сегмент с тем же ключом; </LI>
<LI>shmat() подключает сегмент с указанным описателем к виртуальной памяти обращающегося процесса; </LI>
<LI>shmdt() отключает от виртуальной памяти ранее подключенный к ней сегмент с указанным виртуальным адресом начала; </LI>
<LI>shmctl() служит для управления разнообразными параметрами, связанными с существующим сегментом.</LI>
</UL>
<P ALIGN="JUSTIFY">Прототипы перечисленных системных вызовов описаны в файлах</P>
<DIR><DIR><DIR>
<P ALIGN="JUSTIFY">#include &lt;sys/ipc.h&gt;</P>
<P ALIGN="JUSTIFY">#include &lt;sys/shm.h&gt;</P>
</DIR></DIR></DIR>
<P ALIGN="JUSTIFY">После того, как сегмент разделяемой памяти подключен к виртуальной памяти процесса, этот процесс может обращаться к соответствующим элементам памяти с использованием обычных машинных команд чтения и записи.</P>
<P ALIGN="JUSTIFY">Системный вызов </P>
<P ALIGN="CENTER">int shmid = shmget (key_t key, size_t size, int flag)</P>
<P ALIGN="JUSTIFY">на основании параметра size определяет желаемый размер сегмента в байтах. Если в таблице разделяемой памяти находится элемент, содержащий заданный ключ, и права доступа не противоречат текущим характеристикам обращающегося процесса, то значением системного вызова является идентификатор существующего сегмента. В противном случае создается новый сегмент с размером не меньше установленного в системе минимального размера сегмента разделяемой памяти и не больше установленного максимального размера. Создание сегмента не означает немедленного выделения под него основной памяти и это действие откладывается до выполнения первого системного вызова подключения сегмента к виртуальной памяти некоторого процесса. Флаги IPC_CREAT и IPC_EXCL аналогичны рассмотренным выше.</P>
<P ALIGN="JUSTIFY">Подключение сегмента к виртуальной памяти выполняется путем обращения к системному вызову shmat(): </P>
<P ALIGN="CENTER">void *virtaddr = shmat(int shmid, void *daddr, int flags).</P>
<P ALIGN="JUSTIFY">Параметр shmid - это ранее полученный идентификатор сегмента, а daddr - желаемый процессом виртуальный адрес, который должен соответствовать началу сегмента в виртуальной памяти. Значением системного вызова является фактический виртуальный адрес начала сегмента. Если значением daddr является NULL, ядро выбирает наиболее удобный виртуальный адрес начала сегмента. Флаги системного вызова shmat() приведены ниже в таблице.</P>
<P ALIGN="RIGHT">Таблица</P>
<P ALIGN="CENTER">Флаги системного вызова shmat()</P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=768>
<TR><TD WIDTH="21%" VALIGN="TOP">
<P ALIGN="JUSTIFY">SHM_RDONLY</TD>
<TD WIDTH="79%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P>ядро подключает участок памяти только для чтения;</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<P ALIGN="JUSTIFY">SHM_RND</TD>
<TD WIDTH="79%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P>определяет, если возможно, способ обработки ненулевого значения daddr.</FONT></TD>
</TR>
</TABLE>
<P ALIGN="JUSTIFY">Для отключения сегмента от виртуальной памяти используется системный вызов shmdt(): </P>
<P ALIGN="CENTER">int shmdt(*daddr);</P>
<P ALIGN="JUSTIFY">где daddr - это виртуальный адрес начала сегмента в виртуальной памяти, ранее полученный от системного вызова shmat(). </P>
<P ALIGN="JUSTIFY">Системный вызов shmctl: </P>
<P ALIGN="CENTER">int shmctl (int shmid, int command, struct shmid_ds *shm_stat); </P>
<P ALIGN="JUSTIFY">по синтаксису и назначению системный вызов полностью аналогичен msgctl(). </P>

<B><P ALIGN="CENTER">Варианты заданий</P></B>

<OL>
<P ALIGN="JUSTIFY"><LI>Два дочерних процесса выполняют некоторые циклы работ, передавая после окончания очередного цикла через один и тот же сегмент разделяемой памяти родительскому процессу очередные четыре строки некоторого стихотворения, при этом первый процесс передает нечетные четырехстишья, второй - четные. Циклы работ процессов не сбалансированы по времени. Родительский процесс компонует из передаваемых фрагментов законченное стихотворение и выводит его по завершении работы обоих процессов. Решить задачу с использованием аппарата семафоров.</LI></P>
<P ALIGN="JUSTIFY"><LI>Четыре дочерних процесса выполняют некоторые циклы работ, передавая после окончания очередного цикла через один и тот же сегмент разделяемой памяти родительскому процессу очередную строку некоторого стихотворения, при этом первый процесс передает 1-ю, 5-ю, 9-ю и т.д. строки, второй - 2-ю, 6-ю, 10-ю и т.д. строки, третий - 3-ю, 7-ю, 11-ю и т.д. строки, четвертый - 4-ю, 8-ю, 12-ю и т.д. строки. Циклы работ процессов не сбалансированы по времени. Родительский процесс компонует из передаваемых фрагментов законченное стихотворение и выводит его по завершении работы всех процессов. Решить задачу с использованием аппарата семафоров.</LI></P>
<P ALIGN="JUSTIFY"><LI>Решить задачу из варианта 1 при условии, что передаваемые процессами тексты передаются родительскому процессу не через сегмент разделяемой памяти, а через очередь сообщений.</LI></P>
<P ALIGN="JUSTIFY"><LI>Решить задачу из варианта 2 при условии, что передаваемые процессами тексты передаются родительскому процессу не через сегмент разделяемой памяти, а через очередь сообщений.</LI></P>
<P ALIGN="JUSTIFY"><LI>Родительский процесс помещает в сегмент разделяемой памяти имена программ из предыдущих лабораторных работ, которые могут быть запущены. Выполняя некоторые циклы работ, порожденные процессы случайным образом выбирают имена программ из таблицы сегмента разделяемой памяти,  запускают эти программы, и продолжают свою работу. Посредством аппарата семафоров должно быть обеспечено, чтобы не были одновременно запущены две одинаковые программы. В процессе работы  через очередь сообщений родительский процесс информируется, какие программы и от имени кого запущены.</LI></P>
<P ALIGN="JUSTIFY"><LI>Решить задачу из варианта 5 при условии, что должно быть обеспечено, чтобы не были одновременно запущены две программы от одного процесса.</LI></P>
<P ALIGN="JUSTIFY"><LI>Программа моделирует работу монитора обработки сообщений. Порожденные процессы, обладающие различными приоритетами и выполняющие некоторые циклы работ, посредством очереди сообщений передают родительскому процессу имена программ из предыдущих лабораторных работ, которые им должны быть запущены. Родительский процесс, обрабатывая сообщения в соответствии с их приоритетами, следит, чтобы одновременно не было запущено более трех программ.</LI></P>
<P ALIGN="JUSTIFY"><LI>Программа моделирует работу примитивной СУБД, хранящей единственную таблицу в оперативной памяти. Выполняя некоторые циклы работ, порожденные процессы посредством очереди сообщений передают родительскому процессу информацию об операции, которая должна быть выполнена: тип операции (вставка, модификация, удаление строки), номер строки, содержимое строки. Родительский процесс от имени процесса, выдавшего запрос, выполняет операцию.</LI></P>
</OL>

<B><P ALIGN="CENTER">Контрольные вопросы</P></B>

<OL>
<LI>В чем разница между двоичным и общим семафорами?</LI>
<LI>Чем отличаются P() и V()-операции от обычных операций увеличения и уменьшения на единицу? </LI>
<LI>Для чего служит набор программных средств IPC?</LI>
<LI>Для чего введены массовые операции над семафорами в ОС UNIX? </LI>
<LI>Каково назначение механизма очередей сообщений? </LI>
<LI>Какие операции над семафорами существуют в ОС UNIX? </LI>
<LI>Каково назначение системного вызова msgget()? </LI>
<LI>Какие условия должны быть выполнены для успешной постановки сообщения в очередь? </LI>
<LI>Как получить информацию о владельце и правах доступа очереди сообщений? </LI>
<LI>Каково назначение системного вызова shmget()? </LI>
</OL>

</FONT><FONT SIZE=2></FONT></BODY>
</HTML>


