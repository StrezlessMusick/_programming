{== референс (процедуры, циклы, ветвления, переменные, и прочие фишки, связанные с интерпретатором команд) ==
Если явно не указано иначе, каждая из описанных в этом<ba> разделе встроенных команд, принимающих опции, начинающиеся с дефиса (-), 
распознает два дефиса (--) как признак завершения опций.
{=== быстрые клавишы ===
ctrl+c прерывание, отменить последнюю введенную команду
ctrl+\ прерывание с дампом
ctrl+d конец файла, выйти из терминала
ctrl+s стоп режим. Блокирует вывод на консоль. При этом все данные отображенные на экране остаются не измененными.
ctrl+q выход из стоп-режима.

ctrl+u удалить все символы от курсора до начала строки
ctrl+k удалить все символы от курсора до конца строки
ctrl+y вставляет последнюю удаленную с помощью ctrl+u или ctrl+k строку
ctrl+w удалить слово перед курсором
ctrl+b переместить курсор на один символ влево
ctrl+f переместить курсор на один символ вправо
ctrl+t поменять местами символ слева от курсора и под курсором
ctrl+h удалить символ слева от курсора
ctrl+a переместить курсор в начало строки
ctrl+e переместить курсор в конец строки

ctrl+p предыдущая команда в истории bash
ctrl+n следующая команда в истории bash
ctrl+r реверсивный поиск команд в истории bash
Tab+Tab выводит список команд. При наличии какого нибудь символа(-ов) выводит команды по введенным символам.
    Примечание:ввод осуществляется как и в режиме ввода. Будьте осторожны.

ctrl+m выполнение команды, аналог [Enter]
ctrl+o выполняет команду, при этом оставляя ее в командной строке для дальнейшего использования.
ctrl+l очистить экран, аналог команды clear.

ctrl+x,ctrl+v показать версию bash 

ctrl+z -- ???????
}
• sh<fhs/bin>	shell
 reset			/*bsd?*/перезапускает терминал и очищает экран
{:<ba>			Никакого эффекта; команда не делает ничего, кроме подстановки аргументов и выполнения указанных перенаправлений.
	: [аргументы]
Возвращает нулевой код возврата.
}
{=== управление потоком действий ===
{break<ba>		Выход из цикла for, while, until или select.
	break [n]
Если значение n указано, выход из n уровней циклов. n должно быть больше 1.
Если значение n превышает количество вложенных циклов, происходит выход из всех циклов.
Команда возвращает значение 0, если только не выполнена вне цикла.
}
{continue<ba>	Перейти к следующей итерации цикла for, while, until или select.
	continue [n]
Если указано значение n, перейти к следующей итерации n-го внешнего цикла.
Значение n должно быть больше 1.
Если n превышает количество имеющихся внешних циклов, выполняется следующая итерация самого внешнего цикла (цикла "верхнего уровня").
Возвращается значение 0, если только команда не вызвана вне цикла
}
{return<ba>		Вызывает завершение работы функции с указанным статусом выхода n.
	return [n]
Если n не указано, возвращается статус выхода последней команды, выполненной в теле функции.
При использовании вне функции, но в ходе выполнения сценария командой . (source),
вызывает прекращение выполнения сценария и возврат либо значения n, либо статуса выхода последней команды сценария.
При использовании вне функции и не при выполнении сценария командой ., возвращает 1.
}
{exit<ba>		Вызывает завершение работы командного интерпретатора со статусом n.
	exit [n]
Если значение n не указано, статусом выхода будет статус выхода последней выполненной команды.
Перед заврешением работы интерпретатора срабатыват обработчик сигнала EXIT.
}
logout<ba>		Выход из начального командного интерпретатора.
}
{=== разбор аргументов ===
{shift<ba>	Позиционные параметры n+1 ... переименовываются в $1 .... Параметры от $#-n+1 до $# сбрасываются.
	shift [n]
n должно быть неотрицательным целым числом, не превышающим $#.
Если n равно 0, параметры не изменяются.
Если n не указано, предполагается значение 1.
Если n больше $#, поизиционные параметры не изменяются.
Статус выхода - больше нуля, если n больше $# или отрицательное и 0 в противном случае.
}
{• getopts<ba>	используется процедурами командного интерпретатора для разбора позиционных параметров.
	getopts строка_опций имя [аргументы]
Строка_опций содержит буквы опций, которые необходимо распознать;
если после буквы указано двоеточие, предполагается, что у опции должен быть аргумент, отделяемый от нее пробельным символом.
При каждом вызове команда getopts помещает в переменную интерпретатора с указанным именем очередную опцию,
создавая переменную, если она еще не существует, а индекс следующего аргмента - в переменную OPTIND.
OPTIND получает значение 1 при каждом вызове командного интерпретатора или сценария.
Если опция должна иметь аргумент, команда getopts помещает этот аргумент в переменную OPTARG.
Командный интерпретатор не сбрасывает значение OPTIND автоматически.
Между вызовами команды getopts в том же командном интерпретаторе,
если необходимо использовать новый набор параметров, надо сбрасывать это значение явно.

Когда все опции обработаны, команда getopts завершает работу со значением, большим нуля.
OPTIND при этом содержит индекс первого аргумента, не являющегося опцией, а переменная имя получает значение ?.

Команда getopts обычно обрабатывает позиционные параметры, но если заданы аргументы, getopts разбирает их.

Команда getopts может сообщать об ошибках двумя способами.
Если первый символ строки_опций - двоеточие, используется немногословное информирование об ошибках.
При обычной работе выдаются диагностические сообщения, если обнаруживаются недопустимые опции или недостающие аргументы.
Если переменная OPTERR имеет значение 0, сообщения об ошибках не выдаются, даже если первым символом строки_опций не является двоеточие.

Если обнаружена недопустимая опция, getopts помещает ? в переменную имя и,
если не задано немногословное информирование, выдает сообщение об ошибке и сбрасывает переменную OPTARG.
Если getopts работает в режиме немногословного информирования, символ опции помещается в переменную OPTARG
и никакие диагностические сообщения не выдаются.

Если обязательный аргумент не обнаружен, и для getopts не задано немногословное информирование,
переменная имя получает значение ?, переменная OPTARG сбрасывается, и выдается диагностическое сообщение.
Если getopts работает в режиме немногословного информирования, переменная имя получает значение :,
а в переменную OPTARG помещается символ опции.

Команда getopts возвращает 0, если опция, указанная или не указанная, обнаружена. 
Она возвращает ложь, если достигнут конец опций или произошла ошибка.
}
• xargs<fu>		для формирования списка аргументов и выполнение команды 
}
{=== переменные ===
{shopt<ba>	Переключает значения переменных, управляющих не обязательным поведением командного интерпретатора.
	shopt [-pqsu] [-o] [имя_опции ...]
Если опции не указаны или задана опция -p, выдается список всех возможных опций,
с указанием, установлена опция или нет.
Опция -p вызывает выдачу результатов в формате, позволяющем использовать их в качестве входных команд.
Остальные опции имеют следующие значения:
-s	Включает (устанавливает) все указанные опции.
-u	Отключает (сбрасывает) все указанные опции.
-q	Подавляет выдачу стандартной информации (немногословный режим);
	статус выхода показывает, установлена опция или нет.
	Если после -q указано несколько имен_опций, статус выхода - 0,
	если все указанные опции включены и не 0 в противном случае.
-o	Ограничивает значения имен_опций только поддерживаемыми в опции -o встроенной команды set.

Если опция -s или -u использована без аргументов, выдается информация только об установленных или неустановленных опциях, соответственно.
Если не указано иначе, опции команды shopt по умолчанию отключены (сброшены).

Статус выхода при выдаче опций - 0, если все указанные опции включены и не 0 в противном случае.
При установке или сбросе опций статус выхода - 0, если только не указана недопустимая опция командного интерпретатора.

Вот список допустимых опций команды shopt:

cdable_vars
    Если эта опция установлена и переданный встроенной команде cd аргумент не является именем каталога,
	то предполагается, что это - имя переменной, значение которой - каталог для перехода.

cdspell
    Если эта опция установлена, небольшие ошибки в написании имен каталогов для команды cd будут исправляться.
	Речь идет о переставленных местами символах, пропущенном символе и одном лишнем символе.
	Если при исправлении найден подходящий вариант, выдается исправленное имя каталога и команда выполняется.
	Эта опция используется только интерактивными командными интерпретаторами.

checkhash
    Если эта опция установлена, bash проверяет, что найденная в хэше команда существует,
	прежде чем пытаться ее выполнить.
	Если находящаяся в хэше команда больше не существует, выполняется обычный поиск по каталогам.

checkwinsize
    Если эта опция установлена, bash проверяет размер окна после выполнения каждой команды и,
	при необходимости, обновляет значения переменных LINES и COLUMNS.

cmdhist
    Если эта опция установлена, bash пытается сохранить все строки многострочной команды в одной записи списка истории.
	Это позволяет легко редактировать многострочные команды.

dotglob
    Если эта опция установлена, bash включает в результаты подстановки имен файлов имена, начинающиеся с точки (.).

execfail
    Если эта опция установлена, не интерактивный командный интерпретатор не будет завершать работу,
	если не сможет выполнить файл, указанный в качестве аргумента для встроенной команды exec.
	Интерактивный командный интерпретатор не завершает работу, если команда exec не срабатывает.

expand_aliases
    Если эта опция установлена, псевдонимы заменяются так, как было описано ранее в разделе "ПСЕВДОНИМЫ".
	Эта опция включена по умолчанию в интерактивных командных интерпретаторах.

extglob
    Если эта опция установлена, поддерживаются расширенные возможности сопоставления с образцом,
	описанные ранее в разделе "Подстановка имен файлов".

histappend
    Если эта опция установлена, список истории добавляется в файл, имя которого является значением пременной HISTFILE,
	при завершении работы командного интерпретатора, а не переписывает файл.

histreedit
    Если эта опция установлена и используется библиотека readline,
	пользователь получает возможность повторно редактировать команду при невозможности подстановки из списка истории.

histverify
    Если эта опция установлена и используется библиотека readline,
	результаты подстановки из списка истории не передаются анализатору командного интерпретатора немедленно.
	Вместо этого, полученная в результате строка загружается в буфер редактирования readline для дальнейших изменений.

hostcomplete
    Если эта опция установлена и используется библиотека readline,
	bash будет пытаться выполнить подстановку имен хостов после завершения слова, содержащего символ @,
	(см. подраздел "Завершение" в разделе "БИБЛИОТЕКА READLINE" ранее). Эта опция включена по умолчанию.

huponexit
    Если эта опция установлена, bash будет посылать сигнал SIGHUP всем заданиям
	при завершении работы интерактивного начального командного интерпретатора.

interactive_comments
    Если эта опция установлена, слово, начинающееся символом #, и все остальные символы в этой строке
	игнорируются интерактивным команжным интерпретатором (см. раздел "КОММЕНТАРИИ" ранее).
	Эта опция включена по умолчанию.

lithist
    Если эта опция установлена, и установлена опция cmdhist, многострочные команды, по возможности,
	сохраняются в списке истории со встроенными символами новой строки вместо точек с запятыми.

mailwarn
    Если эта опция установлена и файл, проверяемый командным интерпретатором bash как почтовый ящик,
	читался с момента последней проверки, выдается сообщение "The mail in имя_файла has been read".

nocaseglob
    Если эта опция установлена, bash при подстановке имен файлов выполняет сопоставление с образцом
	без учета регистра символов (см. раздел "Подстановка имен файлов" ранее).

nullglob
    Если эта опция установлена, bash подставляет пустую строку вместо шаблонов,
	которым не соответствует ни один файл (см. раздел "Подстановка имен файлов" ранее), а не сам шаблон.

promptvars
    Если эта опция установлена, в строках приглашения выполняется подстановка значений переменных и параметров
	после стандартных подстановок, описанных в разделе "ПРИГЛАШЕНИЯ" ранее. Эта опция установлена по умолчанию.

restricted_shell
    Командный интерпретатор устанавливает эту опцию, если он запущен в ограниченном режиме (см. раздел " ОГРАНИЧЕННЫЙ КОМАНДНЫЙ ИНТЕРПРЕТАТОР" ниже).
	Значение этой опции изменять нельзя.
	Она не сбрасывается при выполнении файлов начального запуска, что позволяет в этих файлах учесть,
	является ли командный интерпретатор ограниченным.

shift_verbose
    Если эта опция установлена, встроенная команда shift выдает сообщение об ошибке,
	когда параметр сдвига превышает количество позиционных параметров.

sourcepath
    Если эта опция установлена, встроенная команда source (.) использует значение переменной PATH для поиска каталога,
	содержащего файл, переданный в качестве аргумента. Эта опция по умолчанию включена.
}
{set<ba>	При вызове без опций выдает имя и значение всех переменных командного интерпретатора
	set [--abefhkmnptuvxBCHP] [-o опция] [аргумент ...]
 в виде, пригодном для повторного выполнения присваиваний.
	Результат отсортирован по именам в соответствии с текущей локалью.
	Если опции указаны, они устанавливают или сбрасывают атрибуты командного интерпретатора.
Все оставшиеся после обработки опций аргументы присваиваются последовательно в качестве значений позиционным параметрам $1, $2,... $n.
Опции имеют следующие значения:
-o имя_опции
	Имя_опции может иметь одно из следующих значений:
	emacs		Использовать интерфейс редактирования командной строки в стиле редактора emacs.
				Эта опция установлена по умолчанию в интерактивных командных интерпретаторах,
				если только они не запущены с опцией --noediting
	history		Включить поддержку истории выполнения команд, как описано ранее в разделе "ИСТОРИЯ ВЫПОЛНЕНИЯ КОМАНД".
				Эта опция установлена по умолчанию для интерактивных командных интерпретаторов.
	ignoreeof	Результат такой же, как и после выполнения команды IGNOREEOF=10 (см. раздел "Переменные командного интерпретатора" ранее)
	posix		Изменяет поведение bash на соответствующее стандарту POSIX 1003.2, там, где оно отличается
	vi			Использовать интерфейс редактирования командной строки в стиле редактора vi.
	allexport	То же, что и опция -a
	braceexpand	То же, что и опция -B
	errexit		То же, что и опция -e
	hashall		То же, что и опция -h
	histexpand	То же, что и опция -H
	keyword		То же, что и опция -k
	monitor		То же, что и опция -m
	noclobber	То же, что и опция -C
	noexec		То же, что и опция -n
	noglob		То же, что и опция -f
	notify		То же, что и опция -b
	nounset		То же, что и опция -u
	onecmd		То же, что и опция -t
	physical	То же, что и опция -P
	privileged	То же, что и опция -p
	verbose		То же, что и опция -v
	xtrace		То же, что и опция -x.
	Если указана опция -o без имени_опции, выдаются значения текущих установленных опций.
	Если указана опция +o без имени_опции, в стандартный выходной поток выдается набор команд set,
	необходимый для воссоздания текущего набора опций.
-a	Автоматически помечать изменяемые или создаваемые переменные как экспортируемые в среду для последующих команд.
-b	Сообщать о состоянии прерванных фоновых заданий немедленно, а не перед выдачей следующего первичного приглашения.
	Эта опция действует только если включено управление заданиями.
-e	Немедленно завершать работу, если простая команда (см. раздел "СИНТАКСИС КОМАНД" ранее) завершает работу с ненулевым статусом выхода.
	Работа командного интерпретатора не завершается,
	если закончившаяся неудачно команда является частью цикла until или while,
	частью оператора if, частью списка && или ||, или
	если к статусу выхода команды применяется отрицание с помощью оператора !.
-f	Отключить подстановку имен файлов.
-h	Запоминать местонахождение команд, найденное при выполнении. Эта опция включена по умолчанию.
-k	Помещать в среду все аргументы в виде операторов присваивания, а не только предшествующие имени команды.
-m	Режим мониторинга. Управление заданиями включено.
	Эта опция стандартно устанавливается для интерактивных командных интерпретаторов в системах,
	где управление заданиями поддерживается (см. раздел "УПРАВЛЕНИЕ ЗАДАНИЯМИ" ранее).
	Фоновые процессы работают в отдельной группе процессов,
	и строка, содержащая их статус выхода, выдается при завершении их работы.
-n	Читать команды, но не выполнять их.
	Эту опцию можно использовать для проверки наличия синтаксических ошибок в сценариях командного интерпретатора.
	Интерактивные командные интерпретаторы ее игнорируют.
-p	Включить привилегированный режим.
	В этом режиме файлы $ENV и $BASH_ENV не обрабатываются,
	функции командного интерпертатора не наследуются из среды, а переменная среды SHELLOPTS игнорируется.
	Если командный интерпретатор запущен с эффективным идентификатором пользователя (группы),
	не совпадающим с реальным, а опция -p не задана,
	выполняются перечилсенные действия и эффективный идентификатор устанавливается равным реальному.
	Если опция -p задана при запуске, эффективный идентификатор не сбрасывается.
	Отключение данной опции приводит к установке эффективных идентификаторов пользователя и группы равными реальным.
-t	Завершить после чтения и выполнения одной команды.
-u	При подстановке значений параметров рассматривать не установленную переменную как ошибку.
	При попытке подстановки значения не существующей переменной командный интерпретатор выдает сообщение об ошибке
	и, если он - не интерактивный, завершает работу с ненулевым статусом выхода.
-v	Выдавать строки команд по мере чтения.
-x	После подстановок в каждой простой команде выдавать значение переменной PS4,
	а затем - команду с результатами подстановок в аргументах.
-B	Выполнять подстановку квадратных скобок в командном интерпретаторе (см. раздел "Подстановка выражений в скобках" ранее).
	Эта опция установлена по умолчанию.
-C	Если эта опция установлена, bash не переписывает существующий файл при перенаправлениях с помощью операторов >, >& и <>.
	Это поведение можно переопределить при создании выходных файлов, применяя оператор перенаправления |> вместо >.
-H	Включить подстановку из списка истории с помощью метасимвола !.
	Эта опция по умолчанию установлена в интерактивных командных интерпретаторах.
-P	Если эта опция установлена, командный интерпретатор не следует по символьным связям при выполнении команд
	типа cd, изменяющих текущий рабочий каталог.
	Вместо этого, он использует физическую структуру каталогов.
	По умолчанию, bash следует по логической цепочке каталогов при выполнении команд, изменяющих текущий каталог.
--	Если после этой опции нет аргументов, сбрасываются значения позиционных параметров.
	В противном случае, позиционные параметры устанавливаются в соответствии с аргументами,
	даже если некоторые из них начинаются с дефиса (-).
-	Сигнализирует об окончании опций, так что все оставшиеся аргументы присваиваются позиционным параметрам.
	Опции -x и -v при этом отключаются. Если больше аргументов нет, позиционные параметры остаются без изменений.

Опции по умолчанию отключены, если явно не сказано иначе.
При указании + вместо - перед буквой опции, опция отключается.
Опции также можно задавать как аргументы при вызове командного интерпретатора.
Текущий набор опций представлен в виде значения параметра $-.
Статус выхода - 0, если только не указана недопустимая опция.
}
{unset<ba>	Для каждого имени удаляет (сбрасывает) соответствующую переменную или функцию.
	unset [-fv] [имя ...]
Если опции не указаны или задана опция -v, удаляются только переменные.
Переменные только для чтения удалять нельзя.
Если указана опция -f, удаляются только определения соответствующих функций.
Удаляемая переменная или функция удаляется из среды, передаваемой последующим командам.
Если сбрасывается одна из переменных RANDOM, SECONDS, LINENO, HISTCMD или DIRSTACK,
эти переменные теряют специальные свойства, даже если они в дальнейшем снова устанавливаются.
Статус выхода - 0, за исключеним случаев, когда имя не существует или доступно только для чтения.
}
{declare typeset<ba>	Объявляет переменные и/или задает их атрибуты.
	declare [-afFirx] [-p] [имя[=значение]]
	typeset [-afFirx] [-p] [имя[=значение]]
Если имена не заданы, выдаются значения переменных.
Опция -p будет выдавать атрибуты и значения переменных с указанными именами.
Когда используется опция -p, остальные опции игнорируются.
Опция -F запрещает выдачу определений функций; выдаются только имена и атрибуты функций.
Опция -F автоматически устанавливает -f.
Следующие опции можно использовать для выдачи переменных только с указанными атрибутами
или для задания атрибутов переменных:
-a	Каждое имя - переменная типа массив (см. раздел "Массивы" ранее).
-f	Использовать только имена функций.
-i	Переменная считается целочисленной;
	при присваивании переменной значения вычисляются арифметические выражения (см. раздел "ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ").
-r	Делает соответствующие переменные доступными только для чтения.
	Этим переменным нельзя присваивать значения в следующих операторах и их нельзя сбрасывать.
-x	Помечает имена для экспортирования в среду для последующих команд.

При задании '+' вместо '-' атрибут сбрасывается, за исключением того, что опцию +a нельзя использовать для уничтожения массива.
При использовании в функции, команда делает каждую опцию локальной, как и команда local.
Возвращается значение 0, если только не указана недействительная опция,
не делается попытка определить функцию с помощью конструкции "-f foo=bar",
не делается попытка присвоить значение переменной, доступной только для чтения,
не делается попытка присвоить значение массиву без использования конструкции присваивания для массива (см. раздел "Массивы" ранее),
не используется имя несуществующей переменной командного интерпретатора,
не выполняется попытка отменить статус только для чтения переменной, созданной как доступная только для чтения,
не делается попытка отменить статус массива для переменной типа массив,
и не предлагается выдать определение несуществующей функции с помощью опции -f.
}
{export<ba>	Указанные имена помечаются для автоматического экспортирования в среду следующих выполняемых команд.
	export [-fn] [имя[=слово]] ...
	export -p
Если указана опция -f, экспортируются имена функций.
Если имена не указаны или задана опция -p, выдается список всех имен, экспортированных данным командным интерпретатором.
Опция -n вызывает удаление признака экспортирования с указанных переменных.
Команда export возвращает сатутус выхода 0, 
если только не указана недопустимая опция, имя несуществующей переменной 
или в опции -f не указано имя, не являющееся именем функции.
}
{local<ba>	Для каждого аргумента создается локальная переменная с указанным именем, получающая соответствующее значение.
	local [имя[=значение] ...]
Когда команда local используется в функции, она ограничивает область действия этой переменной соответствующей функцией
и вызванными из нее функциями.
При вызове без операндов команда local выдает список локальных переменных в стандартный выходной поток.
Использование команды local вне функции - ошибка.
Статус возврата - 0, если только команда local не использована вне функции или не передано недопустимое имя.
}
{readonly<ba>	Указанные имена помечаются как доступные только для чтения;
	readonly [-apf] [имя ...]
значения соответствующих переменных нельзя изменять в дальнейшем с помощью присваивания.
Если указана опция -f, функции, соответствующие именам, тоже помечаются.
Опция -a ограничивает действие только массивами.
Если ни одно имя не указано или задана опция -p, выдается список имен, доступных только для чтения.
Опция -p вызывает выдачу результатов в формате, который можно использовать как входной.
Статус выхода - 0, если только не передана недопустимая опция,
одно из имен не является именем переменной
или опция -f не указана перед именем, не являющимся именем функции.
}
• env<cu> 		исполняющая команду с изменением окружения
. printenv<cu>	выводит переменные окружения
}
{• test [ <cu>	для проверки типа файла и сравнения значений
! expr — истина, если выражение expr ложь.
expr1 -a expr2 — истина, если оба выражения expr1 и expr2 истина.
expr1 -o expr2 — истина, если или expr1 или expr2 истина.

arg1 %оператор% arg2 -eq, -ne, -lt, -le, -gt, или -ge — эти арифметические бинарные операции возвращают истину,
	если arg1 равно, не равно, меньше чем, меньше чем или равно, больше чем, или больше или равно чем arg2, соответственно.
	arg1 и arg2 могут быть положительными целыми, отрицательными целыми, или специальными выражениями -l string, которые вычисляют длину string.
-z string — истина, если длина string равна нулю.
-n string string — истина, если длина string не ноль.
string1 = string2 — истина, если строки равны.
string1 != string2 — истина, если строки не равны.
-n string — истина, если длина string не равна нулю

-e file — истина, если file существует.
-d file — истина, если file существует и каталог.
-L file — истина, если file существует и символьная ссылка.
-f file — истина, если file существует и обычный файл.
-c file — истина, если file существует и символьное устройство.
-S file — истина, если file существует и сокет.
-b file — истина, если file существует и является специальным блочным устройством.
-p file — истина, если file существует и является именованным каналом (pipe).
-g file — истина, если file существует и имеет установленным групповой идентификатор (set-group-id).
-k file — истина, если file имеет установленным «sticky» бит.
-u file — истина, если file существует и имеет установленным бит пользователя (set-user-id).
-r file — истина, если file существует и читаем.
-w file — истина, если file существует и записываем.
-x file — истина, если file существует и исполняем.
-t [fd] — истина, если fd открыт на терминале. Если fd пропущен, по умолчанию 1 (стандартное устройство вывода).
-O file — истина, если file существует и его владелец имеет эффективный идентификатор пользователя.
-G file — истина, если file существует и его владелец имеет эффективный идентификатор группы.
-s file — истина, если file существует и имеет размер больше чем ноль.
file1 -nt file2 — истина, если file1 новее (дата модификации) чем file2.
file1 -ot file2 — истина, если file1 старее чем file2.
file1 -ef file2 — истина, если file1 и file2 имеют то же устройство и номер inode .
-------
	test выражение
	[ выражение ]
Возвращает статус 0 или 1, в зависимости от результатов проверки условного выражения.
Каждый оператор или операнд должен быть отдельным аргументом.
Выражения состоят из элементов, описанных ранее в разделе "УСЛОВНЫЕ ВЫРАЖЕНИЯ".

Выражения можно комбинировать с помощью следующих операторов, перечисленных по убыванию приоритета.

! выражение
    Истинно, если выражение ложно.

( выражение )
    Возвращает значение выражения. Можно использовать для переопределения обычного приоритета выполнения операторов.

выражение1 -a выражение2
    Истинно, если истинны оба выражения.

выражение1 -o выражение2
    Истинно, если истинно выражение1 или выражение2.

Команды test и [ проверяют условные выражения с помощью набора правил, основанного на количестве аргументов.

0 аргументов
    Выражение ложно.

1 аргумент
    Выражение истинно только если аргумент - не пустой.

2 аргумента
    Если первый аргумент - !, выражение истинно только если второй аргумент - пустой.
	Если первый аргумент - один из унарных условных операторов, перечисленных ранее в разделе "УСЛОВНЫЕ ВЫРАЖЕНИЯ",
	выражение истинно, если унарный оператор возвращает истину.
	Если первый аргумент не является допустимым унарным условным оператором, выражение ложно.

3 аргумента
    Если второй аргумент - один из бинарных условных операторов, перечисленных ранее в разделе "УСЛОВНЫЕ ВЫРАЖЕНИЯ",
	результатом проверки будет значение бинарного условного выражения, использующего первый и третий аргументы в качестве операндов.
	Если первый аргумент - !, результат - отрицание двухаргументной проверки второго и третьего аргументов.
	Если первый аргумент - только (, а третий - только ), результатом будет результат одноаргументной проверки второго аргумента.
	В противном случае, выражение ложно. В этом контексте операторы -a и -o считаются бинарными.

4 аргумента
    Если первый аргумент - !, результат - отрицание трехаргументной проверки оставшихся аргументов.
	В противном случае, выражение разбирается и проверяется в соответствии с приоритетами по перечисленным выше правилам.

5 и более аргументов
    Выражение разбирается и проверяется в соответствии с приоритетами по перечисленным выше правилам.
}
{=== выполнение других команд ===
{builtin<ba>	Выполняет указанную встроенную_команду интерпретатора, передает ей аргументы и возвращает ее статус выхода. 
	builtin встроенная_команда [аргументы]
Это полезно при определении функции, имя которой совпадает с именем встроенной команды интерпретатора
так, чтобы можно использовать вызов встроенной команды в функции.
Обычно так переопределяется встроенная команда cd.
Если указанная команда не является встроенной командой интерпретатора, возвращается статус 1.
}
{• command<ba>	Выполняет команду с аргументами, не выполняя обычный поиск
	command [-pVv] команда [аргумент ...]
Выполняет команду с аргументами, не выполняя обычный поиск функций командного интерпретатора.
Выполняются только встроенные команды или команды, которые находятся в указанных в переменной PATH каталогах.
Если задана опция -p, поиск команды выполняется по стандартному значению переменной PATH, гарантирующему, что будут найдены все стандартные утилиты.
Если указана опция -V или -v, выдается описание команды.
Опция -v выдает одно слово - имя команды или имя файла, представляющего команду;
опция -V дает немного более детальное описание.
Если указана опция -V или -v, статус выхода будет 0, если команда найдена, и 1 в противном случае.
Если ни одна из этих опций не задана и возникла ошибка или команду не удалось найти, будет получен статус выхода 127.
В противном случае статусом выхода встроенной команды command является статус выхода выполненной команды.
}
{eval<ba>		Аргументы читаются и соединяются в единую команду. Эта команда затем читается и выполняется
	eval [аргумент ...]
 командным интерпретатором,
а ее статус выхода возвращается в качестве значения команды eval.
Если аргументов нет или все аргументы пустые, команда eval возвращает 0.
}
{exec<ba>		Если указана команда, она заменяет командный интерпретатор.
	exec [-cl] [-a имя] [команда [аргументы]]
При этом новый процесс не создается.
Аргументы становятся аргументами команды.
Если указана опция -l, командный интерпретатор помещает дефис в качестве нулевого аргумента, передаваемого команде.
Именно так делает команда login(1).
Опция -c вызывает выполнение команды с пустой средой.
Если указана опция -a, командный интерпретатор передает имя как нулевой аргумент выполняемой команде.
Если команда не может быть выполнена по той или иной причине, неинтерактивный командный интерпретатор завершает работу,
если только не включена опция интерпретатора execfail, - в этом случае команда возвращает код ошибки.
Интерактивный командный интерпретатор возвращает код ошибки если файл не может быть выполнен.
Если команда не указана, любые перенаправления срабатывают в текущем командном интерпретаторе и статус выхода будет 0.
Если при перенаправлении произошла ошибка, статус выхода будет 1.
}

{. source<ba>	Читает и выполняет команды из указанного файла в среде текущего командного интерпретатора
	. имя_файла [аргументы]
	source имя_файла [аргументы]
и возвращает статус выхода последней выполненной команды из файла.
Если имя_файла не содержит косой черты, файл ищется в каталогах, перечисленных в переменной PATH.
Искомый файл не обязательно должен быть выполняемым.
Если ни в одном из каталогов, перечисленных в PATH, файл с указанным именем не найден, он ищется в текущем каталоге.
Если отключена опция sourcepath встроенной команды shopt, перечисленные в PATH каталоги не просматриваются. Если переданы аргументы, они становятся позиционными параметрами при выполнении файла. Иначе значения позиционных параметров не изменяются. Статусом выхода становится статус последней выполненной в сценарии команды (статус выхода равен 0, если ни одна команда не выполнялась), или 1, если файл не найден или не может быть прочитан.
}
}
{=== встроенные и не встроенные команды, алиасы ===
{enable<ba>		Включает и отключает встроенные команды интерпретатора.
	enable [-adnps] [-f имя_файла] [имя ...]
Отключение встроенной команды позволяет выполнять без указания полного имени файл на диске,
имя которого совпадает со встроенной командой, хотя обычно встроенные команды просматриваются первыми.
Если используется опция -n, указанные по именам команды отключаются, в противном случае они влючаются.
Например, чтобы использовать двоичную программу test, которая находится в одном из указанных в переменной PATH каталогов,
вместо встроенной версии интерпретатора, выполните enable -n test.
Опция -f требует загрузить новую встроенную команду с указанным именем
из заданного разделяемого объектного файла в системах, поддерживающих динамическую загрузку.
Опция -d удаляет встроенную команду, ранее загруженную с помощью опции -f.
Если имена не заданы или если указана опция -p, выдается список встроенных команд интерпретатора.
При отсутствии других опций и аргументов этот список содержит все включенные встроенные команды интерпретатора.
Если опция -n не указана, выдаются только отключенные встроенные команды.
Если указана опция -a, выдаваемый список включает все встроенные команды с признаком включена или отключена.
Если указана опция -s, выдаются только встроенные команды, предполагаемые стандартом POSIX.
Возвращается значение 0, если только имя являеся именем встроенной команды интерпретатора
и не возникла проблема при загрузке новой встроенной команды из разделямого объектного файла.
}
{• hash<ba>		Для каждого имени определяется и запоминается полное имя команды
	hash [-r] [-p имя_файла] [имя]
 путем поиска в каталогах, перечисленных в переменной $PATH.
Если указана опция -p, поиск по каталогам не выполняется, и указанное имя файла используется как полное имя команды.
Опция -r вызывает сброс всех запомненных имен.
Если аргументы не заданы, выдается информация о запомненных командах.
Статус выхода - истина, если только имя удалось найти и не указана недопустимая опция.
}
{• type<ba>		При вызове без опций показывает, как имена будут интерпретироваться при использовании в качестве имени команды.
	type [-atp] имя [имя ...]
Если указана опция -t, type выдает одну из строк alias, keyword, function, builtin или file,
если имя, соответственно, представляет собой псевдоним, зарезервированное слово командного интерпретатора, функцию, встроенную команду или файл на диске.
Если имя не найдено, ничего не выдается и возвращается статус выхода 1.
Если указана опция -p, type вернет либо имя файла на диске, который будет выполняться при указании имени в качестве имени команды,
либо ничего, если обращения к файлу не будет.
Если команда хранится в хэше, опция -p приводит к выдаче значения из хэша,
а не обязательно первого файла, выбираемого по перечисленным в PATH каталогам.
Если использована опция -a, команда type выдает список всех каталогов,
где есть выполняемый файл с соответствующим именем.
В список включаются также псевдонимы и функции, если только не указана опция -p.
К хэшу команд не обращаются, если указана опция -a.
Команда type возвращает 0, если хоть один из аргументов найден, и 1 в противном случае.
}
{• alias<ba>	задает и показывает псевдонимы
	alias [-p] [имя[=значение] ...]
Команда alias без аргументов или с опцией -p выдает список псевдонимов команд в виде alias имя=значение в стандартный выходной поток.
Для каждого имени в списке аргументов без соответствующего значения выдается имя и значение соответствующего псевдонима.
Если переданы аргументы, каждое имя, для которого задано значение, становится псевдонимом. 
Если значение завершается пробелом, в следующем слове при подстановке будет выполняться замена псевдонима.
Команда alias возвращает истину, если только не задано имя, не являющееся именем псевдонима.
}
{• unalias<ba>	Удаляет имена из списка определенных псевдонимов.
	unalias [-a] [имя ...]
Если указана опция -a, удаляются все определения.
Возвращается значение 0, за исключением случаев, когда переданное имя не является псевдонимом.
}
}
• mkfifo<cu>	Создаёт FIFO (именованные каналы)
{=== константы, заданные последовательности ===
• false<cu><fhs/bin>	возвратить значение 1, 
• true<cu><fhs/bin>	возвратить значение 0
. seq<cu>		выводит числа по порядку
. yes<cu>		до бесконечности выводит заданную строку
}
{=== readline, история ===
{ bind<ba>		Выдает текущие привязки клавиш и функций библиотеки readline или привязывает комбинацию клавиш к функции или макросу readline.
	bind [-m keymap] [-lpsvPSV]
	bind [-m keymap] [-q функция] [-u функция] [-r keyseq]
	bind [-m keymap] -f имя_файла
	bind [-m keymap] keyseq:имя_функции
При этом поддерживается такой же синтаксис привязки, как и в файле .inputrc, 
но каждая привязка должна передаваться как отдельный аргумент; т.е. '"\C-x\C-r": re-read-init-file'.

Опции, если они переданы, имеют следующие значения:

-m keymap	Использовать набор привязок для последующих привязок. 
			Допускаются имена привязок emacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-command и vi-insert.
			vi эквивалентно vi-command; emacs эквивалентно emacs-standard.
-l			Список имен всех функций readline.
-p		    Выдает имена функций и привязки readline так, чтобы их можно было прочитать повторно.
-P		    Выдает текущие имена функций и привязки readline.
-v		    Выдает имена и значения переменных readline так, чтобы их можно было прочитать повторно.
-V		    Выдает имена и значения текущих переменных readline.
-s		    Выдает комбинации клавиш readline, привязанные к макросам, и выдаваемые при их нажатии строки так, чтобы их можно было прочитать повторно.
-S		    Выдает комбинации клавиш readline, привязанные к макросам, и выдаваемые при их нажатии строки
-f имя_файла Читать привязки клавиш из указанного файла.
-q функция  Выдает комбинации клавиш, привязанные к указанной функции.
-u функция  Снять все привязки комбинаций клавиш к указанной функции.
-r keyseq   Удалить привязку к указанной комбинации клавиш keyseq.

Команда возвращает значение 0, кроме случаев, когда передана нераспознанная опция или произошла ошибка.
}
{• fc<ba>		служащая для редактирования списка ранее введенных команд, а также их выполнения. Аналогична history.
	fc [-e редактор] [-nlr] [первая] [последняя]
	fc -s [pat=rep] [команда]
Первая форма выбирает диапазон команд, от первой до последней, из списка истории выполнения.
Первую и последнюю команду можно задавать строкой (найти последнюю команду, начинающуюся с соответствующей строки)
или числом (индекс в списке истории, причем отрицательные значения используются как смещение от номера текущей команды).
Если последняя не указана, при выдаче последней считается текущая команда (так что fc -l -10 выдает последних 10 команд),
а для остальных опций предполагается, что последняя совпадает с первой.
Если первая не указана, ею становится предыдущая команда при редактировании
и -16 (шестнадцатая с конца списка истории) при выдаче.

Опция -n подавляет выдачу номеров команд.
Опция -r изменяет порядок выдачи команд на противоположный.
Если указана опция -l, команды выдаются в стандартный выходной поток.
В противном случае вызывается указанный редактор, которому передается файл с соответствующими командами.
Если редактор не задан, используется значение переменной FCEDIT или значение переменной EDITOR, если FCEDIT не установлена.
Если не установлены обе переменные, используется редактор vi.
По завершении редактирования, отредактированные команды выдаются и выполняются.

Вторая форма требует повторного выполнения команды после замены каждого вхождения pat на rep.
Полезно задать псевдоним "r=fc -s", так что при наборе "r cc" будет выполнена последняя команда, начинавшаяся со строки "cc",
а при вводе "r" будет повторно выполняться последняя команда.

Если используется первая форма, команда возвращает значение 0,
если только не указана недопустимая опция или первая или последняя команда выходит за пределы номеров команд в списке истоии.
Если указана опция -e, возвращается статус выхода последней выполненной команды
или ошибка, произошедшая при работе с временным файлом команд.
Если используется вторая форма, возвращается статус выхода повторно выполненной команды,
если только команда не задает несуществующую строку в списке истории, - в этом случае команда fc возвращает 1.
}
{ history<ba>	Если опции не указаны, выдает список истории команд с номерами строк.
	history [-c] [n]
	history -anrw [имя_файла]
	history -p аргумент [аргумент ...]
	history -s аргумент [аргумент ...]
Строки, для которых указана звездочка (*), были изменены.
При указании аргумента n выдаются только последние n строк.
Если указано имя_файла, список истории берется из этого файла;
если файл не указан, используется значение переменной HISTFILE.
Опции имеют следующие значения:
-a	Добавлять "новые" строки истории (строки истории, введенные с начала текущего сеанса bash) в файл истории.
-n	Читать строки истории, еще не прочитанные из файла истории, в текущий список истории команд.
	Речь идет о строках, добавленных в файл истории с начала текущего сеанса bash.
-r	Читать содержимое файла истории и использовать его в качестве текущего списка истории выполнения команд.
-w	Записывать текущий список истории команд в файл истории, переписывая его текущее содержимое.
-c	Очистить список истории выполнения команд, удаляя все записи.
-p	Выполнить подстановку из списка истории для последующих аргументов
	и выдать результат в стандартный выходной поток.
	Результат не запоминается в списке истории.
	Для отключения обычной подстановки из списка истории, необходимо маскировать (брать в кавычки) каждый аргумент.
-s	Сохранить аргументы в списке истории как одну запись.
	Последняя команда в списке истории удаляется перед добавлением аргументов.

Возвращается значение 0, если не передана недопустимая опция
или при попытке чтения или записи файла истории не произошла ошибка.
}
}
{=== задания ===
{• fg<ba>		Возобновляет работу задания в приоритетном режиме и делает это задание текущим.
	fg [задание]
Если задание не указано, используется текущее задание командного интерпретатора.
Возвращается значение статуса выхода команды, переведенной в приоритетный режим,
или 1 если управление заданиями отключено или,
при включенном управлении заданиями, если указано несуществующее задание
или задание, запущенное при отключенном управлении заданиями.
}
{• bg<ba>		Возобновляет выполнение указанного задания в фоновом режиме, или в фоновый режим переводится текущее задание
	bg [задание]
Возобновляет выполнение указанного задания в фоновом режиме, как если бы оно было запущено с конструкцией &.
Если задание не указано, в фоновый режим переводится текущее задание командного интерпретатора.
Команда bg задание возвращает 0, если только управление заданиями не отключено или, 
при включенном управлении заданиями, соответствующее задание не найдено или запускалось при отключенном управлении заданиями.
}
{disown<ba>		При вызове без опций каждое указанное задание удаляется из таблицы активных заданий.
	disown [-ar] [-h] [задание ...]
Если задана опция -h, задания не удаляются из таблицы, а помечаются
так, что сигнал SIGHUP не посылается заданию при получении сигнала SIGHUP командным интерпретатором.
Если задание не указано и не заданы опции -a и -r, используется текущее задание.
Если задание не указано, опция -a означает удалить или пометить все задания;
опция -r без аргумента задание ограничивает действие выполняющимися заданиями.
Команда возвращает значение 0, если только не указано несуществующее задание.
}
{• jobs	<ba>	Первое из списка активных заданий.
	jobs [-lnprs] [ задание ... ]
	jobs -x команда [ аргументы ... ]
Опции имеют следующие значения:
-l	Помимо обычной информации выдает идентификаторы процессов.
-p	Выдает только идентификаторы процессов-лидеров групп процессов, образующих задание.
-n	Выдает информацию только о заданиях, состояние которых изменилось
	с момента последнего уведомления пользователя о состоянии заданий.
-r	Выдает только выполняющиеся задания.
-s	Выдает только остановленные задания.

Если указано задание, выдается информация только об этом задании.
Статус выхода - 0, кроме случаев, когда указана недопустимая опция или идентификатор несуществующего задания.

Если указана опция -x, команда jobs заменяет любой идентификатор задания в команде или аргументах
соответствующим идентификатором группы процессов,
и выполняет команду, передавая ей аргументы и возвращая ее статус выхода.
}
}
• sleep<cu>		выполняющая задержку на указанное время 
{• file 		предназначенная для определения типа файла.
<cygwin:file>
/*linux man*/
This manual page documents version 4.17 of the file command.

File tests each argument in an attempt to classify it. There are three sets of tests, performed in this order: filesystem tests, magic number tests, and language tests. The first test that succeeds causes the file type to be printed.

The type printed will usually contain one of the words text (the file contains only printing characters and a few common control characters and is probably safe to read on an ASCII terminal), executable (the file contains the result of compiling a program in a form understandable to some UNIX kernel or another), or data meaning anything else (data is usually `binary' or non-printable). Exceptions are well-known file formats (core files, tar archives) that are known to contain binary data. When modifying the file /usr/share/file/magic or the program itself, preserve these keywords . People depend on knowing that all the readable files in a directory have the word ``text'' printed. Don't do as Berkeley did and change ``shell commands text'' to ``shell script''. Note that the file /usr/share/file/magic is built mechanically from a large number of small files in the subdirectory Magdir in the source distribution of this program.

The filesystem tests are based on examining the return from a stat(2) system call. The program checks to see if the file is empty, or if it's some sort of special file. Any known file types appropriate to the system you are running on (sockets, symbolic links, or named pipes (FIFOs) on those systems that implement them) are intuited if they are defined in the system header file <sys/stat.h>.

The magic number tests are used to check for files with data in particular fixed formats. The canonical example of this is a binary executable (compiled program) a.out file, whose format is defined in a.out.h and possibly exec.h in the standard include directory. These files have a `magic number' stored in a particular place near the beginning of the file that tells the UNIX operating system that the file is a binary executable, and which of several types thereof. The concept of `magic number' has been applied by extension to data files. Any file with some invariant identifier at a small fixed offset into the file can usually be described in this way. The information identifying these files is read from the compiled magic file /usr/share/file/magic.mgc , or /usr/share/file/magic if the compile file does not exist. In addition file will look in $HOME/.magic.mgc , or $HOME/.magic for magic entries.

If a file does not match any of the entries in the magic file, it is examined to see if it seems to be a text file. ASCII, ISO-8859-x, non-ISO 8-bit extended-ASCII character sets (such as those used on Macintosh and IBM PC systems), UTF-8-encoded Unicode, UTF-16-encoded Unicode, and EBCDIC character sets can be distinguished by the different ranges and sequences of bytes that constitute printable text in each set. If a file passes any of these tests, its character set is reported. ASCII, ISO-8859-x, UTF-8, and extended-ASCII files are identified as ``text'' because they will be mostly readable on nearly any terminal; UTF-16 and EBCDIC are only ``character data'' because, while they contain text, it is text that will require translation before it can be read. In addition, file will attempt to determine other characteristics of text-type files. If the lines of a file are terminated by CR, CRLF, or NEL, instead of the Unix-standard LF, this will be reported. Files that contain embedded escape sequences or overstriking will also be identified.

Once file has determined the character set used in a text-type file, it will attempt to determine in what language the file is written. The language tests look for particular strings (cf names.h) that can appear anywhere in the first few blocks of a file. For example, the keyword .br indicates that the file is most likely a troff(1) input file, just as the keyword struct indicates a C program. These tests are less reliable than the previous two groups, so they are performed last. The language test routines also test for some miscellany (such as tar(1) archives).

Any file that cannot be identified as having been written in any of the character sets listed above is simply said to be ``data''.   
/*posix man*/
The file utility shall perform a series of tests in sequence on each specified file in an attempt to classify it:

If file does not exist, cannot be read, or its file status could not be determined, the output shall indicate that the file was processed, but that its type could not be determined.

If the file is not a regular file, its file type shall be identified.
>> regular file - обычный файл
The file types directory, FIFO, socket, block special, and character special shall be identified as such.
Other implementation-defined file types may also be identified.
If file is a symbolic link, by default the link shall be resolved and file shall test the type of file referenced by the symbolic link.
(See the -h and -i options below.)

If the length of file is zero, it shall be identified as an empty file.

The file utility shall examine an initial segment of file and shall make a guess at identifying its contents based on position-sensitive tests.
>> guess - думать, предполагать
(The answer is not guaranteed to be correct; see the -d, -M, and -m options below.)

The file utility shall examine file and make a guess at identifying its contents based on context-sensitive default system tests.
(The answer is not guaranteed to be correct.)

The file shall be identified as a data file.

If file does not exist, cannot be read, or its file status could not be determined, the output shall indicate that the file was processed, but that its type could not be determined.

If file is a symbolic link, by default the link shall be resolved and file shall test the type of file referenced by the symbolic link.   
}
}
{== перемещение по папкам и просмотр папок ==
{• cd<ba>		Делает указанный каталог текущим. 
	cd [-LP] [каталог]
	cd = cd ~
	cd - = cd $OLDPWD
Стандартный каталог хранится в переменной HOME. 
Пременная CDPATH определяет пути поиска каталогов, содержащих указанный каталог.

Альтернативные имена каталогов в значении CDPATH разделяются двоеточием (:).
Пустое имя каталога в CDPATH соответствует текущему каталогу, т.е. ".". Если каталог начинается с косой черты (/), то значение переменной CDPATH не используется.
Опция -P требует использовать физическую структуру каталогов вместо следования по символьным связям (см. также опцию -P встроенной команды set);
опция -L требует следовать по символьным связям.
Аргумент - эквивалентен $OLDPWD.
При успешной смене текущего каталога возвращается значение 0, в противном случае - 1.
}
{• pwd<ba><cu><fhs/bin>	(print working directory) Выдает полное имя текущего каталога.
	pwd [-LP]
Выдаваемое имя файла не содержит символьных связей, если указана опция -P или включена опция -o physical встроенной команды set.
Если использована опция -L, выполняется проход по символьным связям.
Статус выхода - 0, если не возникла ошибка при чтении имени текущего каталога или не передана недопустимая опция.
}

{• ls<cu><fhs/bin>		печатает в стандартный вывод содержимое директорий.
Использование: ls [КЛЮЧ]… [ФАЙЛ]…
Выдаёт информацию о ФАЙЛАХ (по умолчанию о текущем каталоге).
Сортирует в алфавитном порядке, если не задан ни --sort, ни один из
ключей -cftuvSUX.

Аргументы, обязательные для длинных ключей, обязательны и для коротких.
{== отображение элементов ==
  -a, --all                  не скрывать файлы начинающиеся с .
  -A, --almost-all           не выдавать подразумеваемые . и ..
  -B, --ignore-backups       не выдавать файлы, оканчивающиеся на ~
  -d, --directory            выдавать имена каталогов, а не их содержимое
  -I, --ignore=ШАБЛОН        не показывать записи, соответствующие ШАБЛОНУ
                             оболочки
      --hide=ШАБЛОН          не показывать записи, соответствующие ШАБЛОНУ
                             оболочки (отменяется ключами -a или -A)
  -R, --recursive            рекурсивно показывать каталоги
  -H, --dereference-command-line
                             следовать по символьным ссылкам в командной
                             строке
      --dereference-command-line-symlink-to-dir
                             следовать по всем символьным ссылкам в командной
                             строке, которые указывают на каталог
}
{== отображение атрибутов элементов ==
  -l                         использовать широкий формат
  -o                         как -l, но не выводить информацию о группе
  -G, --no-group             в длинном формате не печатать имена групп
  -g                         как -l, но не выводить владельца
  -n, --numeric-uid-gid      как -l, но выдавать числовые UID и GID
      --author               вместе с -l, печатать автора каждого файла

  -s, --size                 печатать размер каждого файла в блоках
  -h, --human-readable       c -l и/или -s печатать размеры в удобном для
                             человека виде (например, 1K 234M 2G)
      --si                   то же, но использовать степень 1000, а не 1024
  -k, --kibibytes            по умолчанию использовать блоки по 1024 байта
                             при показе использования диска
      --block-size=РАЗМЕР    использовать блоки указанного РАЗМЕРА; например,
                             «---block-size=M» выводит размеры в единицах,
                             равных 1048576 байтам; см. формат РАЗМЕРА далее.
  
  -i, --inode                показывать индекс каждого файла
  -L, --dereference          показывая информацию для символьной ссылки,
                             показывать информацию о файле, на который ссылка
                             ссылается

  -p,  --indicator-style=slash  добавлять индикатор / к каталогам
  -F, --classify             добавлять к элементам индикатор (один из */=>@|)
      --file-type            аналогично, но не добавлять «*»
      --indicator-style=СТИЛЬ добавлять к именам элементов индикатор с
                             указанным СТИЛЕМ: none (по умолчанию),
                             slash (-p), file-type (--file-type), classify (-F)
	  
  -Z, --context              печатать любой контекст безопасности каждого
                             файла
      --append-exe           append .exe if cygwin magic was needed
}
{== сортировка ==
  -r, --reverse              обратный порядок сортировки
  -t                         сортировать по времени изменения,
                             сначала самые новые
  -S                         сортировать по размеру файла
  -X                         сортировать по расширению в алфавитном порядке
  -v                         сортировать по номерам (версии) в текстовом
                             представлени
      --group-directories-first
                             группировать каталоги раньше файлов;
                             может дополняться ключом --sort,
                             но любое использование
                             --sort=none (-U) выключает группировку
  -U                         не сортировать; выводить в соответствии с
                             физическим расположением в каталоге
  -f                         не сортировать, включает -aU,
                             выключает -ls --color
      --sort=СЛОВО           сортировать по СЛОВУ, а не по имени: 
                             none (без сортировки) -U, size (размер) -S,
                             time (время) -t, version (версия) -v,
                             extension (расширение) -X
}
{== сортировка и отображение времени ==
  -c                         с -lt: сортировать и показывать по ctime (времени
                             последнего изменения файла);
                             с -l: показывать ctime и сортировать по имени;
                             иначе: сортировать по ctime, сначала самые новые
  -u                         с -lt: сортировать и показывать время доступа;
                             c -l: показывать время доступа и сортировать
                             по имени; иначе сортировать по времени доступа
      --time-style=СТИЛЬ     с -l, показывать время используя СТИЛЬ:
                             full-iso, long-iso, iso, locale, +ФОРМАТ;
                             ФОРМАТ интерпретируется как в «date»;
                             если ФОРМАТ — это
                             ФОРМАТ1<перевод-строки>ФОРМАТ2, то
                             ФОРМАТ1 применяется к старым файлам,
                             а ФОРМАТ2 к новым; если к СТИЛЮ добавлен
                             префикс «posix-», то он действует только
                             в локали, отличной от POSIX
      --time=СЛОВО           с ключом -l, показывать вместо времени
                             изменения время, заданное СЛОВОМ: 
                             atime, access, use (-u),
                             ctime, status (-c);
                             если --sort=time, использовать указанное
                             время в качестве ключа сортировки
      --full-time            синоним -l --time-style=full-iso
}
{== отображение ==
  -C                         выдавать список в несколько колонок
  -x                         перечислять по строкам, а не по столбцам
  -1                         перечислять по одному файлу на строке
  -m                         выдавать список на всю ширину через запятую
      --format=СЛОВО         across -x, commas -m, horizontal -x, long -l,
                             single-column -1, verbose -l, vertical -C

  -b, --escape               печатать экранирующие последовательности
                             в стиле С для не графических символов
  -Q, --quote-name           заключать имя записей в кавычки
      --quoting-style=ТИП    использовать тип заключения в кавычки ТИП:
                             literal, locale, shell, shell-always, c, escape
  -q, --hide-control-chars   выводить ? вместо непечатных символов
      --show-control-chars   показывать непечатные символы (по умолчанию,
                             если программа не «ls» и вывод не на терминал).
							 
      --color[=КОГДА]        расцвечивать вывод;
                             КОГДА может быть «always» (по умолчанию),
                             «never» или «auto». Подробней см. ниже
							 
  -T, --tabsize=РАЗМЕР       использовать табуляцию указанного РАЗМЕРА, а не 8
  -w, --width=ЧИСЛО          задает ширину экрана вместо текущего значения
  -D, --dired                генерировать вывод для режима Emacs dired
}
{=====
      --help     показать эту справку и выйти
      --version  показать информацию о версии и выйти
}

РАЗМЕР задаётся целым числом и необязательной единицей изменения
(пример: 10K это 10*1024). Единицы изменения:
K, M, G, T, P, E, Z, Y (степень 1024) или KB, MB, … (степень 1000).

Использование цветов для различения типов файла по умолчанию выключено и
с помощью --color=never. С --color=auto, ls выдаёт цветовые коды только когда
стандартный вывод подключён к терминалу. Переменная окружения LS_COLORS
служит для изменения значений. Для её установки используйте команду dircolors.

Коды выхода:
 0  всё отлично,
 1  небольшие проблемы (например, недоступен подкаталог),
 2  серьёзная проблема (например, недоступен аргумент командной строки).

Оперативная справка GNU coreutils: <http://www.gnu.org/software/coreutils/>
Об ошибках в переводе сообщений «ls» сообщайте по адресу <gnu@mx.ru>
Полная документация доступна по команде: info coreutils 'ls invocation'
}
. dircolors<cu>	Устанавливает цветовую схему для вывода команды ls
. dir<cu>		То же самое, что и ls -C -b (список файлов выводится в колонках с вертикальной сортировкой)
. vdir<cu>		То же самое, что и ls -l -b (выводит список файлов в длинном формате)

{. du<cu>		программа для оценки занимаемого файлового пространства.
Использование: du [КЛЮЧ]… [ФАЙЛ]…
       или:    du [КЛЮЧ]… --files0-from=Ф
Суммирует использование дискового пространства каждого ФАЙЛА, с каталогами.

Аргументы, обязательные для длинных ключей, обязательны и для коротких.
{== вывод и вычисление ==
  -a, --all                печатать объём для всех файлов, а не только
                           каталогов
  -c, --total              выводить общий итог
  -d, --max-depth=N       выводить общий размер каталога (или файла,
                          если --all) только для N-го или меньшего уровня
                          чем указанный аргумент командной строки;
                          значение --max-depth=0 аналогично
                          указанию --summarize
  -s, --summarize          показывать только итог для каждого аргумента
  -h, --human-readable     печатать размеры в удобном для человека виде
                           (например, 1K 234M 2G)
      --si                 как -h, но использовать множитель 1000, а не 1024
  -0, --null               заканчивать каждую выводимую строку NUL,
                           а не символом новой строки
}
{== в чем считать, размеры блоков ==
      --apparent-size      печатать действительные размеры, а не занимаемое на
                           диске  место; хотя действительный размер обычно
                           меньше, иногда он может быть больше из-за дыр в
                           («прореженных» sparse) файлах, внутренней фрагментации,
                           косвенных блоков и тому подобного
  -B, --block-size=РАЗМЕР  использовать блоки указанного РАЗМЕРА; например,
                           «-BM» выводит размеры в единицах, равных
                           1048576 байтам; см. формат РАЗМЕРА далее.
  -b, --bytes              эквивалентно «--apparent-size --block-size=1»
  -k                       синоним --block-size=1K
  -m                       синоним --block-size=1M
}
{== обработка ссылок и подкаталогов ==
  -S, --separate-dirs      у каталогов не включать размер подкаталогов
  -D, --dereference-args   следовать только по символьным ссылкам,
                          которые перечислены в командной строке
  -H                       эквивалентен ключу --dereference-args (-D)
  -L, --dereference        разыменовывать символьные ссылки
  -P, --no-dereference     не следовать по символьным ссылкам (по умолчанию)
  -l, --count-links        складывать размеры, если есть несколько жёстких
                           ссылок
}
{== добавление, исключение файлов ==
      --files0-from=Ф      вывести отчёт об использовании диска, чьи имена
                           файлов (завершённые нулем) перечислены в файле Ф;
                           если Ф равно -, то читать имена файлов из
                           стандартного ввода
  -t, --threshold=РАЗМЕР   исключить элементы, которые меньше РАЗМЕРА,
                           если это значение положительно, или размер которых
                           больше, если это значение отрицательно
  -X, --exclude-from=ФАЙЛ  исключить файлы, совпадающие с любым шаблоном
                           из ФАЙЛа
      --exclude=ШАБЛОН     исключить файлы, совпадающие с ШАБЛОНом
  -x, --one-file-system    пропускать каталоги из других файловых систем
}
{== последнее время ==
      --time               показывать время последнего изменения файлов
                           в каталоге или во всех его подкаталогах
      --time=СЛОВО         показывать указанное СЛОВОМ время, а не время
                           изменения: atime, access, use, ctime или status
      --time-style=СТИЛЬ   показывать время, используя СТИЛЬ:
                           full-iso, long-iso, iso, +ФОРМАТ
                           ФОРМАТ интерпретируется как в «date»
}
{======
      --help     показать эту справку и выйти
      --version  показать информацию о версии и выйти
}

Показывает значения в единицах первого доступного РАЗМЕРА из --block-size,
и переменных окружения DU_BLOCK_SIZE, BLOCK_SIZE и BLOCKSIZE.
Иначе, единицей по умолчанию является 1024 байта (или 512, если
установлена POSIXLY_CORRECT).

РАЗМЕР задаётся целым числом и необязательной единицей изменения
(пример: 10K это 10*1024). Единицы изменения:
K, M, G, T, P, E, Z, Y (степень 1024) или KB, MB, … (степень 1000).

Оперативная справка GNU coreutils: <http://www.gnu.org/software/coreutils/>
Об ошибках в переводе сообщений «du» сообщайте по адресу <gnu@mx.ru>
Полная документация доступна по команде: info coreutils 'du invocation'
}
{• find<fu>		утилита поиска файлов по имени и другим свойствам
Использование: find [-H] [-L] [-P] [-Oуровень] [-D help|tree|search|stat|rates|opt|exec] [путь…] [выражение]

-P — не разворачивать символические ссылки (поведение по умолчанию).
-L — разворачивать символические ссылки.

путём по умолчанию является текущий подкаталог;
выражение по умолчанию: -print
выражение может состоять из 
	операторов, 
	параметров, 
	тестов и 
	действий:

{операторы (в нисходящем порядке; -and берется по умолчанию, если не дано других):
      ( EXPR )   
	  ! EXPR   
	  -not EXPR   
	  EXPR1 -a EXPR2   
	  EXPR1 -and EXPR2
      EXPR1 -o EXPR2   
	  EXPR1 -or EXPR2   
	  EXPR1 , EXPR2
}
{позиционные параметры (всегда): 
	-daystart 
	-follow 
	-regextype тип — указание типа используемых регулярных выражений.
}
{обычные параметры (всегда указываются раньше остальных выражений):
      -depth -d — начинать поиск с самых глубоких уровней вложенности, а не с корня каталога.
	  -maxdepth LEVELS  — максимальный уровень вложенности для поиска. «-maxdepth 0» ограничивает поиск текущим каталогом.
	  -mindepth LEVELS 
	  -mount или -xdev — не переходить на другие файловые системы.
	  -xdev 
	  -noleaf
	  -ignore_readdir_race 
	  -noignore_readdir_race
	  --help 
      --version 
}
{тесты (N может быть +N или -N или N): 
	  -name ШАБЛОН  — искать по имени файла, при использовании подстановочных образцов параметр заключается в кавычки.
	  -iname ШАБЛОН 
	  -lname ШАБЛОН 
      -ilname ШАБЛОН 
      -wholename PATTERN 
	  -iwholename ШАБЛОН 
	  -regex PATTERN
	  -iregex ШАБЛОН

	  -type [bcdpflsD]  — тип искомого: f=файл, d=каталог, l=ссылка (link), p=FIFO (First In, First Out), s=сокет.
	  -xtype [bcdpfls]
	  -size N[bcwkMG]  — размер: указывается в 512-байтных блоках или байтах (признак байтов — символ «c» за числом).
	  -uid N
	  -user NAME  — владелец: имя пользователя или UID.
      -nouser 
	  -gid N 
	  -group ИМЯ — владелец: группа пользователя или GID.
	  -nogroup 
      -readable 
	  -writable 
	  -executable

	  -newer ФАЙЛ — искать файлы созданные позже, чем другой_файл.
	  -anewer ФАЙЛ 
      -cnewer ФАЙЛ 
	  -amin N 
	  -cmin N
	  -mmin N 
	  -atime N  — время последнего обращения к файлу.
	  -ctime N  — время последнего изменения владельца или прав доступа к файлу.
	  -mtime N  — время последнего изменения файла.
	  
	  -empty 
	  -true 
	  -false 
	  -fstype ТИП 
      -links N 
	  -inum N 
	  -path PATTERN 
	  -perm [-/]MODE  — указываются права доступа.
      -used N 
      -context КОНТЕКСТ
}
{действия: 
	  -print  — показывает на экране найденные файлы.
	  -fprint ФАЙЛ 
	  -print0 
      -fprint0 ФАЙЛ 
	  -printf ФОРМАТ 
	  -fprintf ФОРМАТ_ФАЙЛА 
	  -ls  — генерирует вывод как команда ls -dgils.

	  -fls ФАЙЛ 
	  -prune  — используется, когда вы хотите исключить из поиска определённые каталоги.
	  -delete  — удалять найденные файлы.

      -exec КОМАНДА {} \;  — выполняет над найденным файлом указанную команду; обратите внимание на синтаксис.
	  -exec КОМАНДА {} + -ok КОМАНДА ; — перед выполнением команды указанной в -exec, выдаёт запрос.
      -execdir КОМАНДА ; 
	  -execdir КОМАНДА {} + -okdir КОМАНДА ;
	  -quit
}
SINOPSIS
OPTIONS
EXPRESSIONS
TESTS
ACTIONS
UNUSIALFILENAMES
OPERATORS
STANDARDS CONFORMANCE (соответствие)
ENVINRONMENT VARIABLES
XAMPLES
EXIT STATUS
SEE ALSO
HISTORY
NON-BUGS
BUGS
find file - вернет file, если такой есть
find dir - вернет дир и содержащиеся в нем папки и файлы рекурсивно
}
{pushd<ba>		Добавляет каталог на вершину стека каталогов или прокручивает стек,
	pushd [-n] [каталог]
	pushd [-n] [+n] [-n]
делая новый верхний элемент стека текущим рабочим каталогом.
При вызове без аргументов, меняет местами два верхних каталога и возвращает 0, если стек каталогов не пустой.
Аргументы имеют следующие значения:
+n	Прокручивает стек так, что n-ный каталог (при подсчете слева по списку каталогов, начиная с 0) становится вершиной.
-n	Прокручивает стек так, что n-ный каталог (при подсчете справа по списку каталогов, начиная с 0) становится вершиной.
-n	Эта опция подавляет обычный переход в каталог при добавлении каталогов в стек,
	так что действия выполняются только со стеком.
каталог	Добавляет каталог на вершину стека каталогов, делая его текущим рабочим каталогом.

Если команда pushd выполнена успешно, выполняется также команда dirs.
Если используется первая форма, pushd возвращает 0 за исключением случая,
когда не удалось перейти в каталог.
При использовании второй формы pushd возвращает 0, если только
	стек каталогов не пустой,
	не указан несуществующий элемент стека и
	удалось перейти в новый текущий каталог.
}
{popd<ba>		Удаляет записи из стека каталогов.
	popd [-n] [+n] [-n]
При вызове без аргументов удаляет верхний каталог из стека и выполняет переход в новый верхний каталог.
Аргументы имеют следующие значения:
+n	Удаляет n-ную запись слева списка каталогов, начиная с нуля.
	Например: "popd +0" удаляет первый каталог, а "popd +1" - второй.
-n	Удаляет n-ную запись справа списка каталогов, начиная с нуля.
	Например: "popd -0" удаляет последний каталог, а "popd -1" - предпоследний.
-n	Подавляет обычное измнение текущего каталога при удалении каталогов из стека,
	так что изменяется только содержимое стека.

Если команда popd завершается успешно, выполняется также команда dirs и возвращается статус 0.
Команда popd возвращает ложь, если выявлена недопустимая опция,
	стек каталогов - пустой,
	указана несуществующая запись в стеке каталогов
	или не удалось перейти в соответствующий каталог.
}
{dirs<ba>		текущие каталоги
	dirs [-clpv] [+n] [-n]
Без опций эта команда выдает список текущих запомненных каталогов.
По умолчанию каталоги выдаются в одну строку через пробел.
Каталоги добавляются в список с помощью команды pushd; команда popd удаляет записи из списка.
+n	Выдает n-ную запись слева списка, выдаваемого командой dirs при вызове без опций. 
	Нумерация начинается с нуля.
-n	Выдает n-ную запись справа списка, выдаваемого командой dirs при вызове без опций.
	Нумерация начинается с нуля.
-c	Очищает стек каталогов, удаляя все записи.
-l	Выдает более длинный листинг; в стандартном формате листинга для обозначения начального каталога используется тильда.
-p	Выдает стек каталогов по одной записи в строку.
-v	Выдает стек каталогов по одной записи в строку, выдавая индекс записи перед каждой записью.

Если не указана недопустимая опция, и индекс n не выходит за пределы стека, возвращается значение 0.
}

. readlink<cu>	выводит значение символической ссылки
. realpath<cu>	Возвращает полученный абсолютный или относительный путь к файлу
}
{== редактирование папок ==
• touch<cu>		для установки времени последнего изменения файла или доступа в текущее время
{• ln<cu><fhs/bin>		устанавливающая связь между файлом и именем файла. (hard link, symbolic linc)
ln dest link
по умолчанию жесткую
--symbolic - символьную
}
• cp<cu><fhs/bin>		копирование файлов из одного в другие каталоги (возможно, с другой файловой системой)
 cpdir<??>	
• mv<cu><fhs/bin>	для перемещения или переименования файлов.
• rm<cu><fhs/bin>	для удаления файлов из файловой системы
• mkdir<cu><fhs/bin>	команда для создания новых каталогов
• rmdir<cu><fhs/bin>	удаляет каталог из файловой системы
• link 			создаёт ссылку на файл  
• unlink<cu>	Вызывает функцию unlink() для удаления заданных файлов
. chroot<cu>	изменение корневого каталога
. mknod<cu><fhs/bin>		Создаёт специальные файлы
. mktemp<cu>	Создаёт временный файл или каталог
• pathchk<cu>	проверяет имя файла на правильность или переносимость
}
{== просмотр текста ==
• more<fhs/bin> 			для просмотра содержимого текстовых файлов
• nl<cu>		выводящая указанный файл на стандартный вывод, добавляя номера строк
• od<cu>		для вывода дампа файла в восьмеричном формате. С разными параметрами, с помощью od можно увидеть содержимое файла в шестнадцатеричном, восьмеричном, десятичном и пр.(можно даже одновременно во всех форматах) виде с любого места любой длиной.
• paste<cu>		рассматривает файлы, как вертикальные колонки, соединяет их и выводит в стандартный поток вывода.
}
{== ручное редактирование текста ==
{• echo<ba><fhs/bin>	Выдает аргументы через пробел, дополняя в конце символом новой строки.
	echo [-neE] [аргумент ...]
Статус возврата - всегда 0.
Если указана опция -n, символ новой строки не выдается.
Если указана опция -e, включается интерпретация следующих управляющих комбинаций символов с обратной косой.
Опция -E отключает интерпретацию этих управляющих последовательностей даже в системах, где они интерпретируются по умолчанию.
Команда echo не интерпретирует -- как признак завершения опций.
Команда echo интерпретирует следующие управляющие последовательности:
\a		сигнал (звонок)
\b		забой
\c		не выводить завершающие символы новой строки
\e		управляющий символ
\f		прогон страницы
\n		новая строка
\r		возврат каретки
\t		горизонтальная табуляция
\v		вертикальная табуляция
\\		обратная косая
\nnn		символ, ASCII-код которого - восьмеричное значение nnn (от одной до трех цифр)
\xnnn		символ, ASCII-код которого - шестнадцатеричное значение nnn (от одной до трех цифр)
}
{• printf<ba>	Выдает аргументы в соответствии с форматом в стандартный выходной поток.
	printf формат [аргументы]
Формат - строка символов, содержащая три типа объектов:
	обычные символы, которые просто копируются в стандартный выходной поток,
	управляющие последовательности символов, преобразуемые и копируемые в стандартный выходной поток,
	и спецификации формата, каждая из которых вызывает выдачу последующего аргумента.
Помимо стандартных форматов printf(1),
спецификатор %b вызывает замену управляющих последовательностей,начинающихся с обратной косой,
а спецификатор %q требует выдать соответствующий аргумент в формате, который можно повторно использовать в качестве входных данных командного интерпретатора.

Формат при необходимости используется повторно, чтобы покрыть все аргументы.
Если формат требует больше аргументов, чем передано, дополнительные спецификации формата раскрываются
как если бы были переданы нулевые значения или пустые строки, соответственно.
}
{• read<ba>	Читает одну строку из стандартного входного потока и присваивает первое слово первому имени, второе слово - второму имени, и так далее,
	read [-er] [-a имя_массива] [-p приглашение] [имя ...]
 так что оставшиеся слова вместе с разделителями между ними присваиваются в качестве значения последнему имени.
Если из входного потока прочитано меньше слов, чем указано имен, остальные имена получают пустые значения.
Для разбиения строки на слова используются символы, указанные в значении переменной IFS.
Символ обратной косой (\) можно использовать для литеральной интерпретации следующего прочитанного символа и для продолжения ввода на следующей строке.
Опции имеют следующие значения:
-r	Обратная косая не обрабатывается как символ маскировки. Она считается частью строки.
	В частности, для продолжения на следующей строке нельзя использовать пару обратная косая/новая строка.
-p	Выдает приглашение, без завершающего перевода строки, перед чтением входного потока.
	Приглашение выдается только если входные данные идут с терминала.
-a	Слова присваиваются последовательным элементам массива имя_массива, начиная с 0.
	Имя_массива сбрасывается перед присваиванием новых значений. Другие имена в аргументах игнорируются.
-e	Если стандартный входной поток идет с терминала, для получения строки используется библиотека readline (см. раздел "БИБЛИОТЕКА READLINE" ранее).

Если имена не указаны, прочитанная строка присваивается переменной REPLY.
Статус выхода - 0, если только не встретился символ конца файла.
}
{=== текстовые редакторы ===
• ed 			первый стандартный текстовый редактор операционной системы UNIX, применялся в начале 1970-х. Расширенная его версия, известная как ex, послужила основой редактора vi.
• ex 			расширение редактора ed, наиболее значительным добавлением к которому является возможность экранного редактирования
• vi 			серия текстовых редакторов
emacs
vim
nano
}
. shred<cu>		Перезаписывает файлы чтобы скрыть содержимое (так называемое безопасное удаление), и опционально удаляет файлы
. truncate<cu>	Уменьшает или увеличивает размер файла до заданного размера
}
{== автоматическое редактирование и обработка текста ==
{=== для двоичных файлов ===
• nm 			печатающая информацию о бинарных файлах (объектных файлах, библиотеках, исполняемых файлах и т. д.), прежде всего таблицу имён. 
• strings 		применяемая для поиска печатаемых строк в двоичных файлах
• uudecode 		представление двоичных данных в текстовом формате
• uuencode 		представление двоичных данных в текстовом формате
}
• wc<cu>		выводящая число переводов строк, слов и байт для каждого указанного файла и итоговую строку, если было задано несколько файлов
• pr<cu>		Разбивает ФАЙЛЫ на страницы или колонки ДЛЯ ПЕЧАТИ
{=== для путей и мен файлов ===
• basename<cu> 	basename — встроенная утилита unix-систем, убирающая имена каталогов и суффикс из имени файла.
• dirname<cu>	предназначенная для преобразования абсолютного или относительного пути к файлу или директории в имя родительской директории.
}
{=== табуляции, кодировка, преобразования ===
• expand<cu>	преобразующая табуляции в пробелы, сохраняя форматированность текста.
• unexpand<cu> 	преобразовывающая пробелы в табуляции
• iconv 		для преобразования текста из одной кодировки в другую
• tr<cu> 		для преобразования символов
}
{=== простая общая обработка ===
• tee<cu>		выводит на экран, или же перенаправляет, выходной материал команды и копирует его в файл или в переменную
{==== объединение, разделение, голова, хвост ====
• split<cu>		копирующая файл и разбивающая его на отдельные файлы заданной длины
• csplit<cu>	разбивает файл на отдельные части, разделённые шаблоном
• cat<cu><fhs/bin>		утилита UNIX, выводящая последовательно указанные файлы (или устройства), таким образом, объединяя их в единый поток
. tac<cu>		=cat + вывод в обратном порядке
• head<cu>		выводящая первые n строк из файла, по умолчанию n равно 10
• tail<cu>		выводящая несколько (по умолчанию 10) последних строк из файла.
}
{==== алгоритмы со строками ====
• cmp<du>		Unix-утилита, сравнивает два файла, и если они различаются, сообщает о первом байте и строке, где было обнаружено различие.
• diff<du>		утилита сравнения файлов, выводящая разницу между двумя файлами
patch<*>		применят изменения к файлу
 diff3<du>		сравнивает построчно 3 файла
 sdiff<du>		построчно объединяет различия между файлом 1 и файлом 2
• sort<cu>		выводящая сортированное слияние указанных файлов на стандартный вывод с использованием установленной в среде локали.
• uniq<cu>		можно вывести или отфильтровать повторяющиеся строки в отсортированном файле
. shuf<cu>		случайная перестановка строк
}
{==== построчное разделение и объединение ====
• comm<cu>		утилита unix, читает файл1 и файл2, которые должны быть предварительно лексически отсортированы, и генерирует вывод, состоящий из трёх колонок текста: строки, найденные только в файле файл1; строки, найденные только в файле файл2; и строки, общие для обоих файлов. 
• join<cu>		объединяющая строки двух упорядоченных текстовых файлов на основе наличия общего поля
}
{==== ====
• dd<cu><fhs/bin>		программа UNIX, предназначенная как для копирования, так и для конвертации файлов
. fmt<cu>		форматирует текст
• fold<cu>		Разбивает длинные строки для устройств вывода с ограниченной шириной
}
}
{=== сложная общая обработка (рег. выражения, ~базы данных) ===
• cut<cu>		команда выборки отдельных полей из строк файла
updatedb<fu>	обновляет имена файлов в базе данных
locate<fu>		перечисляет файлы в базпх данных, которые соответствуют паттерну
• grep<*> 			находит на вводе строки, отвечающие заданному регулярному выражению, и выводит их
• awk 			интерпретируемый скриптовый C-подобный язык построчного разбора и обработки входного потока (например, текстового файла) по заданным шаблонам. Работает в bash (SH) скриптах.
• sed<fhs/bin> 			потоковый текстовый редактор (а также язык программирования), применяющий различные предопределённые текстовые преобразования к последовательному потоку текстовых данных.
}
}
{== установка и удаление пакетов команд и программ ==
install<cu>		Копирует файлы и устанавливает атрибуты
aptitude        высокоуровневый интерфейс для менеджера пакетов
apt-build world	пересборка всей системы
dpkg			
checkinstall	вызывает make install, о чем-то спрашивает пользователя, и что-то регистрирует в менеджере пакетов
}
{== справка ==
{help<ba>	Выдает полезную информацию о встроенных командах.
	help [шаблон]
Если шаблон указан, команда help выдает детальную справочную информацию о всех командах, соответствующих шаблону;
в противном случае, выдается справка по всем встроенным командам и управляющим структурам интерпретатора.
Статус выхода - 0, если удалось найти команду, соответствующую шаблону.
}

//<пакет-библиотека GNU dbm используется>
{• man 			для форматирования и вывода справочных страниц
жирным или белым	- точно соответсвующие идентификаторы
Использование: man [ПАРАМЕТР...]
            [СЕКЦИЯ] СТРАНИЦА...

  -C, --config-file=ФАЙЛ 	 использовать указанный пользовательских файл настроек
  -d, --debug                показывать сообщения отладки
  $MANOPT					 предопределенные опции
  -D, --default              сбросить все параметры в значения по умолчанию (напр. забыть $MANOPT)
      --warnings[=ПРЕДУПРЕЖДЕНИЯ]
                             включить предупреждения от groff

{=== Основные режимы работы: ===
  -f, --whatis               эквивалентно whatis
  -k, --apropos              эквивалентно apropos
  -K, --global-apropos       искать текст по всем справочным страницам
  -l, --local-file           воспринимать аргумент(ы) СТРАНИЦА как имя файл(ов)
  -w, --where, --path, --location
                             показывать физическое расположение man страницы
  -W, --where-cat, --location-cat
                             показывать физическое расположение cat файла(ов)

  -c, --catman               используется catman для переформатирования устаревших cat страниц
  -R, --recode=КОДИРОВКА
                             вывести исходную страницу в КОДИРОВКЕ
}
{=== Поиск справочных страниц: ===
  -L, --locale=ЛОКАЛЬ  	 	 задать локаль для поиска
  -m, --systems=СИСТЕМА   	 использовать справочные страницы от других систем
  -M, --manpath=ПУТЬ     	 установить путь поиска справочных страниц в значение ПУТЬ

  -S, -s, --sections=СПИСОК  использовать список секций, указанных через двоеточие

  -e, --extension=РАСШИРЕНИЕ искать только с заданным РАСШИРЕНИЕМ

  -i, --ignore-case          не учитывать регистр при поиске (по умолчанию)
  -I, --match-case           учитывать регистр при поиске

      --regex                показать все страницы, удовлетворяющие регулярному выражению
      --wildcard             показать все страницы, удовлетворяющие групповым символам

      --names-only           искать совпадение --regex и --wildcard только в именах страниц, без описаний

  -a, --all                  поиск всех подходящих справочных страниц
  -u, --update               выполнить проверку целостности кэша

      --no-subpages          не затрагивать подстраницы, например, 'man foo bar' => 'man foo-bar'
}
{=== Управление форматированием вывода: ===
  -P, --pager=ПЕЙДЖЕР 		 использовать программу ПЕЙДЖЕР для вывода на экран
                            
  -r, --prompt=СТРОКА 		 использовать пейджер `less' с подсказкой

  -7, --ascii                показать трансляцию ASCII определённых символов latin1
  -E, --encoding=КОДИРОВКА   использовать выбранную кодировку выходных данных
      --no-hyphenation, --nh выключить перенос слов
      --no-justification, --nj   выключить выравнивание
  -p, --preprocessor=СТРОКА  СТРОКА определяет запускаемые препроцессоры: 
							 e - [n]eqn, p - pic, t - tbl, g - grap, r - refer, v - vgrind

  -t, --troff                использовать groff для форматирования страниц
  -T, --troff-device[=УСТРОЙСТВО]
                             использовать groff на выбранном устройстве

  -H, --html[=БРАУЗЕР]   	 использовать lynx или БРАУЗЕР для показа HTML
  -X, --gxditview[=РАЗРЕШЕНИЕ] использовать groff и показывать с помощью gxditview (X11):
                             -X = -TX75, -X100 = -TX100, -X100-12 = -TX100-12
  -Z, --ditroff              использовать groff и заставить его генерировать ditroff
}
  -?, --help                 показать эту справку
      --usage                показать короткую справку по использованию

Обязательные или необязательные  к длинным именам параметров  таковыми и к соответствующим  параметрам.
}
whatis          показывает однострочные описания справочных страниц
{apropos         поиск в именах справочных страниц и кратких описаниях
	если указать несколько слов, он будет выдавать то, где нашел ХОТЯБЫ ОДНО слово
}
mandb(8)			создает или обновляет кэши index справочных страниц
manpath			выводит путь поиска справочных страниц

catman          создает или обновляет уже отформатированные справочные страницы

info            читает Info документы
}
--...
{== прочее общее администрирование системы ==
	(дата-время, включение, выключение компа
	управление процессами
	пользователи, права, сопоставления файлов, 
	начальная загрузка, 
	драйвера, 
	диски)
{=== терминал ===
• stty<cu><fhs/bin>		Изменяет настройки терминала
• tty<cu>		выводящая имя терминала, соединённого со стандартным вводом
}
{=== сигналы и процессы ===
{• kill<ba><fhs/bin>		Посылает указанный по имени или номеру сигнал процессам с указанными идентификаторами
	kill [-s сигнал | -n номер_сигнала | -сигнал] [идентификатор_процесса | задание] ...
	kill -l [сигнал | статус_выхода]
 или входящим в задание с указанным идентификатором.
Сигнал задается либо по имени, например, SIGKILL, либо по номеру.
Если сигнал задается по имени, имя может включать префикс SIG, а может и не включать.
Если сигнал не задан явно, предполагается сигнал SIGTERM.
При указании опции -l выдаются имена сигналов.
Если при указании опции -l заданы аргументы, выдаются только имена сигналов, соответствующих аргументам, и возвращается статус 0.
Аргумент статус_выхода опции -l - число, задающее либо номер сигнала, либо статус выхода процесса, прерванного этим сигналом.
Команда kill возвращает истину, если, по крайней мере, один сигнал был послан успешно,
или ложь, если возникла ошибка или была указана недопустимая опция.
}
killall			посылающет сигнал всем процессам, которые были запущены указанной командой. Если имя сигнала не указано, посылается сигнал SIGTERM.
{trap<ba>		Команда аргумент читается и выполняется при получении командным интерпретатором указанных сигналов.
	trap [-lp] [аргумент] [сигнал ...]
Если аргумент не указан или задан как -, для всех указанных сигналов устанавливаются исходные обработчики
(те, что были при запуске командного интерпретатора).
Если аргумент - пустая строка, все указанные сигналы игнорируются командным интерпретатором и вызываемыми им командами.
Если указана опция -p, выдаются команды trap, связанные с каждым из перечисленных сигналов.
Если аргументов нет или указана только опция -p, команда trap выдает список команд (обработчиков), связанных с каждым из сигналов.
Сигнал можно задавать как по имени, определенному в файле <signal.h>, так и по номеру.
Если в качестве сигнала указана конструкция EXIT (0),
команда-аргумент выполняется при завершении работы командного интерпретатора.
Если в качестве сигнала указано DEBUG, команда-аргумент выполняется после каждой простой команды (см. раздел "СИНТАКСИС КОМАНД" ранее).
Опция -l приводит к выдаче списка имен сигналов и соответствующих им номеров.
Сигналы, игнорировавшиеся при входе в командный интерпретатор, нельзя перехватить или переустановить.
Перехваченные сигналы сбрасываются в исходные значения в порожденных процессах при создании.
Статус возврата - 1, если указан недопустимый сигнал; в противном случае, trap возвращает 0.
}
{suspend<ba>	Приостанавливает работу текущего командного интерпретатора, пока он не получит сигнал SIGCONT.
	suspend [-f]
Опция -f отключает предупреждения, если эта команда выполняется в начальном командном интерпретаторе
- безусловно приостановить работу.
Статус выхода - 0, если только командный интерпретатор не является начальным, а опция -f - не указана,
или если управление заданиями отключено.
}
{• wait<ba>		Ждет завершения указанного процесса и возвращает статус его завершения.
	wait [n]
n может быть идентификатором процесса или спецификацией задания;
если указана спецификация задания, ждет завершения всех процессов в конвейере соответствующего задания.
Если n не указано, ожидается завершение всех текущих активных порожденных процессов, и возвращается статус ноль.
Если n задает идентификатор несуществующего процесса или задания, статус выхода - 127.
В противном случае, статусом выхода является статус завершения последнего процесса или задания, завершение которого ждали. 
}
{• ulimit<ba>	Обеспечивает управление ресурсами, доступными для командного интерпретатора
	ulimit [-SHacdflmnpstuv [ограничение]]
и запущенных им процессов в системах, поддерживающих такое управление.
Значение ограничения может быть числом единиц измерения ресурса или строкой unlimited.
Опции -H и -S указывают, что для данного ресурса устанавливается жесткое или мягкое ограничение.
Жесткое ограничение после установки превосходить нельзя; мягкое ограничение можно превосходить вплоть до значения соответствующего жесткого ограничения.
Если опции -H и -S не указаны, устанавливаются и мягкое, и жесткое ограничение.
Если ограничение не указано, выдается текущее значение мягкого ограничения на ресурс, если только не указана опция -H. Если указано несколько ресурсов, перед значением выдается название и единица измерения ресурса. Другие опции интерпретируются следующим образом:
-a	Выдается информация о всех текущих ограничениях
-c	Максимальный размер создаваемых файлов core
-d	Максимальный размер сегмента данных процесса
-f	Максимальный размер файлов, создаваемых командным интерпретатором
-l	Максимальный размер сегмента, который может быть привязан к памяти
-m	Максимальный размер резидентного набора
-n	Максимальное количество открытых файловых дескрипторов
	(большинство систем не позволяет устанавливать это значение)
-p	Размер программного канала в 512-байтовых блоках (его устанавливать нельзя)
-s	Максимальный размер стека
-t	Максимальное количество процессорного времени в секундах
-u	Максимальное количество процессов для одного пользователя
-v	Максимальный объем виртуальной памяти, доступный командному интерпретатору

Если ограничение указано, оно становится новым предельным значением для соответствующего ресурса
(опция -a только выдает информацию).
Если опции не заданы, предполагается опция -f.
Значения представляются в единицах 1024 байта, за исключением опции -t, где значения - в секундах,
-p, где значения - в 512-байтовых блоках, и опций -n и -u, для которых значения не масштабируются.
Статус выхода - 0, если не указана недопустимая опция, в качестве ограничения не задано не числовое значение,
отличное от unlimited, и при установке нового ограничения не произошла ошибка.
}
{times<ba>	    Выдает накопленные пользовательское и системное время работы для командного интерпретатора и запущенных из него процессов.
	Статус выхода - 0.
}
}
{=== управление процессами ===
• ps<fhs/bin>	выводящая отчёт о работающих процессах.
. nproc<cu>		запрашивает количество (активных) процессов.
• logger 		предоставляющая командный интерфейс для модуля системного журнала syslog.
• time<ba><*>	для определения времени выполнения определенной консольной команды
• nice<cu>		утилита, запускающая программу с измененным приоритетом для планировщика задач
• renice 		позволяющая изменить приоритет запущенных задач. 
>> hup - двигаться вперед, понукать лошадь
{• nohup<cu>	запускающая указанную команду с игнорированием сигналов потери связи (hangup
таким образом, команда будет продолжать выполняться в фоновом режиме и после того, как пользователь выйдет из системы
}
. timeout<cu>	запустить команду с ограничением по времени
. runcon<cu>	запускает программу с указанным контекстом безопасности
}
{=== получение общей информации о системе (время, пользователь, локаль, терминал) ===
• uname<cu><fhs/bin>	выводящая информацию о системе.
. arch<cu>		То же самое, что и uname -m (выводит название архитектуры машины)
. uptime<cu>	говорит, как долго система работает
• cal 			UNIX?утилита, отображающая простой календарь
• date<cu><fhs/bin>		утилита Unix для работы с системными часами. 
• locale 		выводящая информацию о локали. (это набор параметров, включая набор символов, язык пользователя, страну, часовой пояс, а также другие предустановки, которые пользователь ожидает видеть в пользовательском интерфейсе)
. hostid<cu>	выводит цифровой идентификатор для текущего хоста
. pinky<cu>		Простой finger, печатает сведения о пользователе
}
{=== выполнение по расписанию ===
• at 			unix-утилита, читающая команды со стандартного входного потока и группирующая их в виде задания at для выполнения позже, в заданное время.
• crontab (cron)	демон-планировщик задач в UNIX-подобных операционных системах, использующийся для периодического выполнения заданий в определённое время.
}
{=== пользователи ===
• who<cu>		показывает текущих пользователей в компьютерной системе
. whoami<cu>	Выводит эффективный UID
. groups<cu>	выводит группы, в которых состоит пользователь
• id<cu>		выводящая реальный/эффективный UID и GID об указанном пользователе USERNAME или текущем пользователе
• logname<cu>	выводящая имя пользователя, вызывающего команду
. users<cu>		выводит имена тех пользователей, которые вошли на текущий хост
}
{=== права доступа ===
su<fhs/bin>
sudo
• chmod<cu><fhs/bin>		программа для изменения прав доступа к файлам и директориям
• chgrp<cu><fhs/bin>		утилита UNIX. Может использоваться непривелигированными пользователями для изменения группы владельца файлов
• chown<cu><fhs/bin>		UNIX?утилита, изменяющая владельца и/или группу для указанных файлов
{• umask<ba>	изменяющая права доступа, которые присваиваются новым файлам и директориям по умолчанию
	umask [-p] [-S] [маска]
Пользовательская маска создания файла устанавливается равной аргументу маска.
Если маска начинается с цифры, она интерпретируется как восьмеричное число;
иначе - как маска в символьном формате, аналогичном используемому в команде chmod(1).
Если маска не указана или задана опция -S, выдается текущее значение маски.
Опция -S вызывает выдачу маски в символьном формате; по умолчанию выдается восьмеричное число.
Если указана опция -p, а маска не задана, результат выдается в виде, который можно использовать во входной команде.
Статус выхода - 0, если маска была успешно изменена или не указана, и 1 в противном случае.
}
• mesg 			управляет доступом на запись для терминала данного пользователя. Обычно используется для разрешения или запрета другим пользователям писать на терминал данного пользователя.
}
{=== диски ===
. stat<cu>		возвращает данные об inode
• df<cu><fhs/bin>		показывает список всех файловых систем по именам устройств, сообщает их размер, занятое и свободное пространство и точки монтирования.
• fuser 		идентифицирующая процессы, которые используют указанные файлы или сокеты.
. sync<cu><fhs/bin>	Записывает на диск буферы файловых систем
}
}
{== архиваторы ==
• ar 			unix-утилита, создающая и модифицирующая архивы, а также извлекающая файлы из архива. 
• compress 		сжимает данные для хранения, разжимает и показывает сжатые файлы
• uncompress 	сжимает данные для хранения, разжимает и показывает сжатые файлы
• zcat 			сжать или распаковать файлы  
tar<*>
gzip<*>
cpio<*>
pax
. base64<cu>	Кодирует/декодирует данные в base64 и выводит в стандартный вывод
}
{== системы контроля версий (контроль файлов) ==
• cksum<cu>		рассчитывает количество байт и контрольную сумму (CRC) в файле по стандарту ISO/IEC 8802-3:1989. 
. md5sum<cu>	Вычисляет и проверяет хеш MD5
. sha1sum<cu>
. sha224sum<cu>
. sha256sum<cu>
. sha384sum<cu>
. sha512sum<cu>
. sum<cu>		проверяет контрольные ссуммы файлов
• patch 		для переноса правок (изменений) между разными версиями текстовых файлов. 
{• sccs 		frontend для подсистемы sccs
• admin 		создание и управление sccs-файлами (первая в мире система контроля версий)
• delta 		создает разность для данного sccs файла
• get 		вычисляет версию для sccs файла
}
git
svn
}
{== сеть и интернет ==
• write 		позволяющая отправить сообщение другому пользователю, который имеет сессию в этой же системе
• lp 			вызывающая печать файлов и связанной с ними информации на принтере

• uucp 			команда копирования файлов между двумя компьютерами под управлением операционной системы UNIX, использующая одноимённый протокол

{ssh			secure shell
	ssh [[user@]host]
}
{scp			secure copy
	scp src dst
	[[user@]host:]file   //отн /home/user или абсолютный
}
}
{== модели одних систем в других системах ==
{=== cygwin ===
cygserver-config	конфигурирует сервис cygserver
cygrunsrv			запускает сервисы
cygpath				преобразовывает пути win <-> unix
}
fakeroot			в deb-системах
}
--...
{== наборы компиляторов ==
{=== binutils ===
ar<bu> 			создаёт и изменяет архивы библиотек, а также извлекает файлы из них
ranlib<bu> 		создает и добавляет индексы в архивный файл типа .ar. Т.е. именно те индексы, которые используются программой ld для поиска модулей в библиотеках.

as<bu> 			ассемблер, известный как GAS (Gnu ASsembler)
ld<bu> 			компоновщик
gold<bu> 		альтернативный компоновщик

addr2line<bu> 	переводит адрес в имя файла и номер строки, используя отладочную информацию
c++filt<bu> 	перевод искажённых (mangled) C++-символов в изначальный вид
nm<bu> 			перечисление символов в объектных файлах
objdump<bu> 	вывод информации об объектных файлах
objcopy<bu> 	транслирование объектных файлов из одного двоичного формата в другой
size<bu> 		вывод общего размера и размера секций объектноно файла
strings<bu> 	вывод читаемых строк из любого файла
strip<bu> 		удаление символьных таблиц и отладочной информации из объектных файлов

readelf<bu> 	показ содержимого исполняемых/объектных файлов в формате ELF
gprof<bu> 		профилировщик, обеспечивает наблюдение за выполнением программы, скомпилированныой со встроенной в нее профилирующей?отладочной информацией. вырабатывает профиль для оптимизации, сообщая время выполнения каждой функции.
gcov			профилирующее средство, используемое совместно с gprof для определения участков программы, отнимающих наибольшую часть времени выполнения.

nlmconv<bu> 	конвертирование объектного файла в загружаемый модуль NetWare
dlltool<bu> 	создание DLL для Windows
windmc<bu> 		генерация ресурсов сообщений Windows
windres<bu> 	компилятор файлов ресурсов окон ?Windows
}
{=== gcc ===
gcc				основная драйверная программа, координирующая выполнение компиляторов и комнпоновщиков, для получения желаемого вывода. Поддерживает большое кол-во опций.
cc				???
cc1				действующий компилятор C.
c++	g++			версия gcc, устанавливающая C++ в качестве языка по умолчанию и автоматически подключающая стандартные библиотеки с++ при компоновке. то же, что и g++.
libstdc++		динамическая библиотека, содержащая классы и функции с++, определенные, как часть стандарта языка.
cc1plus			действующий компилятор C++
libobjc			динамическая библиотека для всех программ на языке objective-c
ratfor			препроцессор - rational fortran
f77				драйверная программа для фортрана
f771			действующий компилятор фортрана
gcj				драйверная программа для java
libgcj			динамическая библиотека, содержащая классы ядра java
jc1				действующий компилятор java
gnat1			действующий компилятор для ada
gnatbind		биндер ada. Утилита, используемая для связки (подшивки) пакетов программ на языке ada.
gnatlink		Утилита, используемая для компоновки программ на языке ada.

libgcc			эта библиотека содержит функциональные блоки кода (рутины), которые могут считаться частью компилятора, т.к. компонуются практически в каждую исполнимую программу. (гапример действия числами с плавающей точкой)
crt0.o			код инициализации и завершения, особый для каждой системы, компилируется в этот файл. Он затем компануется с каждым исполняемым файлом, для обеспечения необходимых начальных и завершающих действий.
collect2		на системах, не использующих компоновщик GNU, необходимо запускать collect2 для генерирования определенного кода инициализации среды окружения (global inicialization code), подобно конструкторам и деструкторам в языке C.
cygwin1.dll		разделяемая библиотека windows, которая обеспечивает API, эмулирующий системные вызовы UNIX.
}
gdb				отладчик
GNATS			система трассировки (трэкинга) ошибок, применяемая в GNU. Встроенная система поиска ошибок компилятора GCC и другого ПО GNU
• m4 			Макропроцессор m4,
• c99 			стандартный компилятор
• fort77 		компилятор фортрана
f2c				транслятор с фортрана на си
{vcg				просмотрщик rational fortran, представляющий текстовый файл в виде графа.
в GCC есть опция -dv для генерирования данных для оптимизации в формате, поддерживаемом vcg.
}
{=== автотулс ===
autoconf		генерирует ./configure
./configure		выполнимый сценарий, находящийся в корневом каталоге дерева исходных файлов. Используется для установки значений конфигурационных величин и создания мейкфайлов.
{• make<*> 			автоматизирующая процесс преобразования файлов из одной формы в другую
`-b' `-m'			Эти опции оставлены для совместимости с другими версиями make. При работе они игнорируются. 
`-h' `--help'		Напоминает вам список опций, распознаваемых make и завершает работу. 

`-f файл' `--file=файл' `--makefile=файл'
    Указанный файл рассматривается в качестве make-файла.
	Смотрите раздел Создание make-файлов. 
`-I каталог' `--include-dir=каталог'
    Указывает каталог для поиска включаемых make-файлов. Смотрите раздел Подключение других make-файлов. При наличии нескольких опций `-I', поиск в указанных каталогах производится в том порядке, как они были перечислены. 
{`-C каталог' `--directory=каталог'	Перед чтением make-файла перейти в каталог каталог.
При наличии сразу нескольких опций `-C', каждая из них рассматривается относительно предыдущей: так, `-C / -C etc' эквивалентно `-C /etc'.
Обычно, это используется при рекурсивном вызове make (смотрите раздел Рекурсивный вызов make). 
}

`-e' `--environment-overrides'
    Дает переменным, созданным из соответствующих переменных среды "приоритет" перед переменными, определенными внутри make-файла.
	Смотрите раздел Переменные из операционного окружения. 

`-k' `--keep-going'
    После возникновения ошибки, продолжить, насколько это возможно, обработку make-файла. Хотя цель, при обновлении которой произошла ошибка, уже не сможет быть корректно обновлена, и, следовательно, не могут быть правильно обновлены и все цели, зависящие от нее, make попробует обработать другие пререквизиты этих целей. Смотрите раздел Проверка компиляции программы. 
`-i' `--ignore-errors'
    Игнорировать все ошибки, возникающие в любых командах, исполняемых для обновления файлов. Смотрите раздел Ошибки при исполнении команд. 
	
{`-d'				В дополнение к основной работе, выводить отладочную информацию.
Отладочная информация содержит в себе много интересного:
например, какие файлы make считает необходимым обновить,
для каких файлов сравнивается их время изменения и каков полученный результат,
какие неявные правила рассматриваются в качестве кандидатов на исполнение и какие из них действительно выполняются и так далее.
Опция -d эквивалентна использованию опции `--debug=a' (смотрите ниже). 
}
{`--debug[=опции]'	В дополнение к основной работе, выводить отладочную информацию.
При выводе отладочной информации можно выбрать нужный ее тип и степень "подробности".
При отсутствии аргументов, выбирается "базовый" уровень отладочной информации.
Ниже перечислены все возможные аргументы; при "разборе" аргументов учитывается только первый символ названия.
При задании нескольких аргументов, они должны разделяться пробелами или запятыми.
{    a (all)			Выдача всей имеющейся отладочной информации ("максимальный уровень").
		Эквивалентно использованию опции `-d'. 
}
{    b (basic)			"Базовый уровень" отладочной информации:
		печатаются все цели, которые были найдены "устаревшими" и информация об успешности или неуспешности попытки их обновления. 
}
{    v (verbose)        Следующий уровень после "базового";
		дополнительно выдается информация о том, какие make-файлы обрабатываются,
		какие пререквизиты не нуждаются в обновлении и так далее.
		Включение этой опции также приводит к выдаче отладочной информации "базового" уровня. 
}
{    i (implicit)		Выдается информация о процессе поиска подходящих неявных правил для каждой из целей.
		Включение этой опции также приводит к выдаче отладочной информации "базового" уровня. 
}
    j (jobs)			Выдача информации о вызове некоторых команд. 
    m (makefile)		По умолчанию, описанная выше отладочная информация не выдается на стадии, когда make пробует обновить make-файлы.
	Данная опция разрешает выдачу отладочной информации в процессе обновления make-файлов. Обратите внимание, что `all' также включает данную опцию.
	Эта опция также разрешает выдачу отладочных сообщений "базового" уровня. 
}

`-j [число_заданий]' `--jobs[=число_заданий]'
    Указывает количество одновременно выполняемых заданий (команд). При отсутствии аргумента, число одновременно выполняемых заданий не ограничено. При наличии сразу нескольких опций `-j', будет действовать только последняя из перечисленных. Смотрите раздел Параллельное исполнение команд, где подробно описан процесс запуска команд. Обратите внимание, что при работе в операционной системе MS-DOS, эта опция игнорируется. 
`-l [загрузка]' `--load-average[=загрузка]' `--max-load[=загрузка]'
    Указывает, что новые задания (команды) не должны запускаться если уже имеется хотя бы одно запущенная задание и загрузка системы равна или превышает значение загрузка (число с плавающей точкой). При отсутствии аргумента, ограничение на максимальную загрузку снимается. Смотрите раздел Параллельное исполнение команд. 
	
`-n' `--just-print' `--dry-run' `--recon'
    Печатать команды, которые должны выполняться, но не исполнять их. Смотрите раздел Вместо исполнения команд. 
`-o файл' `--old-file=файл' `--assume-old=файл'
    Не обновлять файл даже если он "старше" своих пререквизитов и при обработке других файлов не принимать в рассчет возможные изменения в этом файле. По существу, этот файл обрабатывается как "очень старый" и его правила игнорируются. Смотрите раздел Предотвращение перекомпиляции некоторых файлов. 
`-p' `--print-data-base'
    Перед началом основной работы, распечатать базу данных (правила и значения переменных), полученную в результате чтения make-файла. Печатается также информация о номере версии (аналогично опции `-v', смотрите ниже). Для того, чтобы просто распечатать базу данных, не обновляя при этом никаких файлов, используйте `make -qp'. Для распечатки базы данных с предопределенными правилами и переменными, используйте `make -p -f /dev/null'. Помимо всего прочего, выводимая информация содержит имя файла и номер строки, где было дано определение правила или переменной. Это может оказаться ценным подспорьем для отладки сложных make-файлов. 
`-q' `--question'
    "Режим проверки". Никаких команд не выполняется и не печатается никаких сообщений. Вся работа make заключается в возврате соответствующего кода завершения. В случае, если указанная цель не нуждается в обновлении, возвращается нулевой код. В случае, если обновление требуется, возвращается код, равный единице. При возникновении каких-либо ошибок ошибок, возвращается код, равный двум. Смотрите раздел Вместо исполнения команд. 
`-r'
`--no-builtin-rules'
    Отключает использование встроенных неявных правил (смотрите раздел Использование неявных правил). Однако, вы по-прежнему можете задать свои собственные неявные правила с помощью шаблонных правил (смотрите раздел Определение и переопределение шаблонных правил). Опция `-r' также очищает используемый по умолчанию список суффиксов для суффиксных правил. (смотрите раздел Устаревшие суффиксные правила). По-прежнему, вы можете использовать специальную цель .SUFFIXES для определения своего собственного списка суффиксов. Далее, эти суффиксы можно будет использовать в своих суффиксных правилах. Обратите внимание, что опция -r воздействует только на правила и никак не влияет на используемые по умолчанию переменные (смотрите раздел Используемые в неявных правилах переменные); смотрите описание опции `-R'. 
`-R'
`--no-builtin-variables'
    Отключает использование встроенных переменных, используемых неявными правилами (смотрите раздел Используемые в неявных правилах переменные). Разумеется, вы по-прежнему можете определять свои собственные переменные. Включение опции `-R' автоматически приводит к включению опции `-r' (смотрите выше), поскольку нет смысла в наличии неявных правил без наличия переменных, которые в них используются. 
`-s'
`--silent'
`--quiet'
    "Бесшумный режим". Отключается печать исполняемых команд. Смотрите раздел Отображение исполняемых команд. 
`-S'
`--no-keep-going'
`--stop'
    Отменяет опцию `-k'. Как правило, это может потребоваться только при рекурсивном использовании make, когда опция `-k' может быть "унаследована" через переменную MAKEFLAGS от make "верхнего уровня" (смотрите раздел Рекурсивный вызов make) или в случае, если эта опция была установлена через переменную среду MAKEFLAGS. 
`-t'
`--touch'
    Не выполняя команд, просто обновляет время последней модефикации файлов (в действительности не изменяя их). Таким образом, make "делает вид" что все необходимые команды были выполнены, дабы "обмануть" последующие запуски make. Смотрите раздел Вместо исполнения команд. 
`-v'
`--version'
    Выдает информацию о версии программы make, ее авторах, авторских правах, замечание об отсутствии гарантий и завершает работу. 
`-w'
`--print-directory'
    Печатать сообщение с именем текущего каталога до и после обработки make-файла. Это может оказаться полезным при поиске нетривиальных ошибок, связанных с рекурсивным вызовом make. Смотрите раздел Рекурсивный вызов make. (На практике, вам редко когда понадобится указывать эту опцию, поскольку, во многих случаях, make включает ее автоматически; смотрите раздел Опция `--print-directory'.) 
`--no-print-directory'
    Отменить печать рабочего каталога (опции -w). Эта опция может оказаться полезной в тех случаях, когда make автоматически включает опцию -w, а вы не хотели бы получать дополнительные сообщения. Смотрите раздел Опция `--print-directory'. 
`-W файл'
`--what-if=файл'
`--new-file=файл'
`--assume-new=файл'
    "Притвориться", что цель файл только что была модефицирована. Будучи использована совместно с опцией `-n', покажет, какие действия будут выполнены если этот файл действительно будет модефицирован. Без опции `-n', эффект сходен с выполнением команды touch для указанного файла с последующим запуском make, за исключеним того, что время последней модефикации этого файла происходит только в "воображении" make. Смотрите раздел Вместо исполнения команд. 
`--warn-undefined-variables'
    Когда make будет встречать ссылки на неопределенные переменные, будут выдаваться соответствующие предупреждающие сообщения. Это может оказаться полезным при отладке make-файлов, в которых переменные используются нетривиальным образом. }
libtool			сценарий поддержки базовой библиотеки, используемый в мейкфайлах для упрощения использования разделяемых динамических библиотек
}
}
{== иде ==
• ctags 		утилита, собирающая информацию об именах и позициях переменных, функций и процедур, встречающихся в исходном коде
}
{== скриптовые языки, различные вычисления ==
{let<ba>		Каждый аргумент - арифметическое выражение, которое необходимо вычислить
	let аргумент [аргумент ...]
 (см. раздел "ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ").
Если последний аргумент имеет значение 0, команда let возвращает 1, в противном случае, она возвращает зачение 0.
}
• bc 			интерактивный интерпретатор Си-подобного языка, позволяет выполнять вычисления с произвольно заданной точностью. 
• expr<cu>		вычисляющая значение выражения и выводящая результат на стандартный вывод
. numfmt<cu>	Переформатирует числа //1.0K -> 1024
. ptx<cu>		печатает перемешанный алфавитный указатель слов
• tsort 		выполняет логическуб сортировку
. factor<cu>	выдает простые множители числа
• lex 			программа для генерации лексических анализаторов, обычно используемая совместно с генератором синтаксических анализаторов yacc
• yacc 			компьютерная программа, служащая стандартным генератором синтаксических анализаторов (парсеров)
}
{== рабочий стол ==
{=== gnome ===
{ gconf-editor	графический аналог утилиты gconftool
    дает доступ к настройкам, хранящимся в xml файлах
}
 gconftool
}
}
------------------------------------------------
• - POSIX
. - GNU only
	- не подтверждено
<cu> - coreutils
	todo -> fileutils, textutils, shellutils
<ba> - bash
<du> - diffutils
<fu> - findutils
<nu> - binutils
<*> - программа из одноименного пакета
<fhs/bin>
todo 
	взять имена пакетов в угловые скобки
	распихать их по категориям
		может быть перестроить категории в соответствии с пакетами
	разбить на несколько файлов все это
		или вынести описания команд в отдельные файлы
	досортировать опции make
	досортировать неотсортированные команды
	перебрать посикс команды
{пакеты LFS 
• Bash
Этот пакет удовлетворяет требование LSB Core, по которому система должна
предоставлять интерфейс Bourne Shell. Он был выбран из большого числа других
вариантов потому, что является наиболее популярным и одним из самых мощных
по возможностям.
• Coreutils
Пакет включает в себя необходимые программы для просмотра и обработки
файлов и каталогов. Они требуются для управления файлами из командной
строки, а также для установки абсолютно всех пакетов LFS.

• Autoconf
Этот пакет содержит программы, создающие скрипты оболочки, способные
автоматически сконфигурировать исходные коды из шаблона, предоставленного
разработчиком. Он часто необходим для повторной сборки пакета после
изменений в процедуре построения.
• Automake
Пакет содержит программы для генерации Make-файлов из шаблонов. Он
часто необходим для повторной сборки пакета после изменений в процедуре
построения.
• Binutils
Этот пакет содержит компоновщик, ассемблер и другие утилиты для работы с
объектными файлами. Программы из этого пакета необходимы для компиляции
почти всех пакетов LFS и большинства остальных программ.

• Bison
Пакет содержит GNU-версию yacc (Yet Another Compiler Compiler, Еще Один
Компилятор Компиляторов), необходимого для сборки некоторых других
программ LFS.
• Bzip2
Linux From Scratch - Версия 6.8
xiii
Этот пакет содержит программы для работы со сжатыми данными. Он необходим
для распаковки многих пакетов LFS.
• DejaGNU
Содержит компоненты для тестирования других программ. Этот пакет
устанавливается только как временный инструментарий.
• Diffutils
Пакет содержит программы, которые позволяют выявить различия между
файлами или каталогами. С их помощью можно создавать патчи, а также они
необходимы для сборки многих пакетов.
• Expect
Этот пакет содержит программу для связывания скриптовых диалогов с другими
интерактивными программами. Он зачастую используется при тестировании
других пакетов. Он устанавливается только как временный инструментарий.
• E2fsprogs
Пакет включает в себя утилиты для оперирования с файловыми системами ext2,
ext3 и ext4. Это самые популярные и тщательно протестированные файловые
системы, поддержимаемые ядром Linux.
• File
Этот пакет включает в себя утилиту для определения типа переданного ей файла
или нескольких файлов. Некоторые пакеты требуют ее для сборки.
• Findutils
Пакет содержит программы для поиска файлов в файловой системе. Очень
многие пакеты используют эти утилиты при сборке.
• Flex
Этот пакет содержит утилиту для генерации программ, способных распознавать
шаблоны в тексте. Это GNU-версия lex (лексического анализатора),
необходимого для сборки некоторых пакетов LFS.
• Gawk
В этом пакете содержится программа для оперирования содержимым текстовых
файлов. Это GNU-версия awk (Aho-Weinberg-Kernighan), который используется в
скриптах сборки многих пакетов.
• Gcc
Это - Собрание Компиляторов GNU (Gnu Compiler Collection). Данный пакет
содержит компиляторы C и C++, а также многие другие, не устанавливаемые в
процессе сборки LFS.
• GDBM
Пакет предоставляет библиотеку управления базами данных GNU (GNU Database
Manager). Она используется другим пакетом, Man-DB.
Linux From Scratch - Версия 6.8
xiv
• Gettext
В данном пакете находятся утилиты для интернационализации и перевода
интерфейса программ на другие языки. Они необходимы некоторым пакетам.
• Glibc
Этот пакет содержит главную библиотеку языка C. Ни одна программа в Linux не
запустится без нее.
• GMP
This package contains math libraries and provide functions for arbitrary precision
arithmetic. It is required to build Gcc.
• Grep
This package contains programs for searching through files. These programs are used
by most packages' build scripts.
• Groff
This package contains programs for processing and formatting text. One important
function of these programs is to format man pages.
• GRUB
This package is the Grand Unified Boot Loader. It is one of several boot loaders
available, but is the most flexible.
• Gzip
This package contains programs for compressing and decompressing files. It is
needed to decompress many packages in LFS and beyond.
• Iana-etc
This package provides data for network services and protocols. It is needed to enable
proper networking capabilities.
• Inetutils
This package contains programs for basic network administration.
• IProute2
This package contains programs for basic and advanced IPv4 and IPv6 networking.
It was chosen over the other common network tools package (net-tools) for its IPv6
capabilities.
• Kbd
This package contains key-table files, keyboard utilities for non-US keyboards, and a
number of console fonts.
• Less
This package contains a very nice text file viewer that allows scrolling up or down
when viewing a file. It is also used by Man-DB for viewing manpages.
• Libtool
This package contains the GNU generic library support script. It wraps the
complexity of using shared libraries in a consistent, portable interface. It is needed by
the test suites in other LFS packages.
Linux From Scratch - Версия 6.8
xv
• Linux Kernel
This package is the Operating System. It is the Linux in the GNU/Linux environment.
• M4
This package contains a general text macro processor useful as a build tool for other
programs.
• Make
This package contains a program for directing the building of packages. It is required
by almost every package in LFS.
• Man-DB
This package contains programs for finding and viewing man pages. It was chosen
instead of the man package due to superior internationalization capabilities. It
supplies the man program.
• Man-pages
This package contains the actual contents of the basic Linux man pages.
• MPC
This package contains functions for the arithmetic of complex numbers. It is required
by Gcc.
• Module-Init-Tools
This package contains programs needed to administer Linux kernel modules.
• MPFR
This package contains functions for multiple precision arithmetic. It is required by
Gcc.
• Ncurses
This package contains libraries for terminal-independent handling of character
screens. It is often used to provide cursor control for a menuing system. It is needed
by a number of packages in LFS.
• Patch
This package contains a program for modifying or creating files by applying a patch
file typically created by the diff program. It is needed by the build procedure for
several LFS packages.
• Perl
This package is an interpreter for the runtime language PERL. It is needed for the
installation and test suites of several LFS packages.
• Pkg-config
This package contains a tool for passing the include path and/or library paths to build
tools during the configure and make processes. It is needed by many LFS packages.
• Procps
Пакет содержит программы для слежения за работой процессов. Эти программы
полезны для администрирования системы, а также используются загрузочными
скриптами LFS.
Linux From Scratch - Версия 6.8
xvi
• Psmisc
Пакет предоставляет программы, выводящие различную информацию о
запущенных процессах. Они полезны для системного администрирования.
• Readline
Пакет содержит набор библиотек, предоставляющих возможность
редактирования командной строки и хранения истории команд. Он используется
Bash.
• Sed
Этот пакет позволяет редактировать текст без открытия его в текстовом
редакторе. Он также требуется большинством конфигурационных скриптов.
• Shadow
Пакет содержит программы для безопасного управления паролями.
• Sysklogd
Этот пакет содержит программы для журналирования системных сообщений,
подобных тем, что ядро или демоны посылают в случае необычного события.
• Sysvinit
В этом пакете содержится программа init, являющаяся родителем всех
остальных процессов в системе Linux.
• Tar
Этот пакет предоставляет возможность создания архивов и их распаковки.
Необходим для извлечения абсолютно всех пакетов, используемых в LFS.
• Tcl
Пакет содержит Tool Command Language, используемый при выполнении
тестирования во многих пакетах LFS. Он устанавливается только как временный
инструментарий.
• Texinfo
Этот пакет содержит программы для чтения, создания и преобразования info-
страниц. Он используется при установке многих пакетов LFS.
• Udev
Пакет содержит программы для динамической генерации узлов устройств. Udev
является альтернативой созданию нескольких тысяч статических устройств в
директории /dev.
• Util-linux
Пакет включает в себя разнообразные утилиты. Среди них программы для
управления файловыми системами, разделами, консолью и сообщениями.
• Vim
Этот пакет содержит редактор. Он был выбран из-за совместимости с
класическим редактором vi и огромного числа мощных возможностей. Выбор
редактора - очень субъективный момент, поэтому Вы, по желанию, пожете
заменить Vim любым другим текстовым редактором.
• XZ Utils
Linux From Scratch - Версия 6.8
xvii
Данный пакет включает в себя программы для сжатия и распаковки файлов. На
данный момент, они предоставляют наилучшее вообще возможное сжатие, и
необходимы для распаковки пакетов формата XZ или LZMA.
• Zlib
Пакет содержит библиотеку процедур компрессии/декомпрессии, используемую
некоторыми программами.
}

dmesg<fhs/bin>	Utility to print or control the kernel message buffer
hostname<fhs/bin>
login<fhs/bin>
mount<fhs/bin>
umount<fhs/bin>
• getconf 	возвращает конфигурационные значения переменной
• ipcrm 	удаляет заданные очереди сообщений, множества семафоров и сегменты разделяемой памяти
• ipcs 		возвращает статус системы межпроцессного взаимодействия system V
. chcon<cu>		Изменяет контекст безопасности файла (SELinux)
. stdbuf<cu>???	 Управляет буферизацией команд, использующих stdio
• asa 
• batch 
• cflow 
• cxref 
• gencat 
• localedef 
• mailx 		
• newgrp 
• pax 
• prs 
• qalter 
• qdel 
• qhold 
• qmove 
• qmsg 
• qrerun 
• qrls 
• qselect 
• qsig 
• qstat 
• qsub 
• rmdel 
• sact 
• tabs 
• talk 
• tput 
• unget 
• uustat 
• uux 
• val 
• what 
