todo
	переменные
		прочитать
		отформатировать с однострочным названием
		отсортировать по темам
	пересортироаать все
		все крупные списки - по возможностям
***************************************************************
***************************************************************
***************************************************************
==== 1 ========================================================
* Название
* Авторские права
* Описание
*{ Опции
* -c строка
* -r
* -i
* -s
* -D
* -- 
* --dump-po-strings
* --dump-strings
* --help
* --login
* --noediting
* --noprofile
* --norc
* --posix
* --rcfile файл
* --restricted
* --verbose
* --version
}
* Аргументы
* Вызов
* Определения
* Зарезервированные слова
*{ Синтаксис команд
* Простые команды
* Конвейеры
* Списки
*{ Составные команды
* for
* select
* case
* if
* while
* until
* function
}
}
* Комментарии
* Маскировка
======= 2 =====================================================
*{ Параметры
* Позиционные параметры
* Специальные параметры
* Переменные командного интерпретатора
* Массивы
}
*{ Замены
* Замена выражений в фигурных скобках
* Замена тильды
* Подстановка значений параметров
* Подстановка результатов выполнения команд
* Подстановка значений арифметических выражений
* Подстановка процессов
* Разбиение на слова
* Подстановка имен файлов
* Сопоставление с образцом
* Удаление кавычек
}
======= 3 =====================================================
*{ Перенаправление
* Перенаправление входного потока
* Перенаправление выходного потока
* Добавление перенаправленного вывода
* Перенаправление стандартного выходного потока
* и стандартного потока ошибок
* Конструкция "документ здесь"
* Дублирование дескрипторов файлов
* Открытие дескрипторов файлов для чтения и записи
}
* Псевдонимы
* Функции
* Вычисление арифметических выражений
* Условные выражения
* Обработка простой команды
* Выполнение команды
* Среда выполнения команд
* Среда
* Статус выхода
* Сигналы
* Управление заданиями
* Приглашения
*{ Библиотека READLINE
* Соглашения по записи команд readline
* Инициализация библиотеки readline
* Горячие клавиши readline
* Переменные readline
* Управляющие конструкции readline
* Поиск
* Имена команд readline
* Команды для перемещения
* Команды для работы со списком истории
* Команды для изменения текста
* Удаление и вставка
* Числовые аргументы
* Завершение
* Клавиатурные макросы
* Прочие команды
}
======= 4 =====================================================
* История выполнения команд
*{ Подстановка команд из списка истории
* Пометки событий
* Пометки слов
* Модификаторы
}
*{ Встроенные команды интерпретатора
* . имя_файла [аргументы]
* alias [-p] [имя[=значение] ...]
* bg [задание]
* bind [-m keymap] [-lpsvPSV]
* break [n]
* builtin встроенная_команда [аргументы]
* cd [-LP] [каталог]
* command [-pVv] команда [аргумент ...]
* continue [n]
* declare [-afFirx] [-p] [имя[=значение]]
* typeset [-afFirx] [-p] [имя[=значение]]
* dirs [-clpv] [+n] [-n]
* disown [-ar] [-h] [задание ...]
* echo [-neE] [аргумент ...]
* enable [-adnps] [-f имя_файла] [имя ...]
* eval [аргумент ...]
* exec [-cl] [-a имя] [команда [аргументы]]
* exit [n]
* export [-fn] [имя[=слово]] ...
* fc [-e редактор] [-nlr] [первая] [последняя]
* fg [задание]
* getopts строка_опций имя [аргументы]
* hash [-r] [-p имя_файла] [имя]
* help [шаблон]
* let аргумент [аргумент ...]
* local [имя[=значение] ...]
* logout
* popd [-n] [+n] [-n]
* printf формат [аргументы]
* pwd [-LP]
* read [-er] [-a имя_массива] [-p приглашение] [имя ...]
* readonly [-apf] [имя ...]
* return [n]
*{ set [--abefhkmnptuvxBCHP] [-o опция] [аргумент ...]
* set -a
* set -b
* set -e
* set -f
* set -h
* set -k
* set -m
* set -n
*{ set -o имя_опции
* set -o allexport
* set -o braceexpand
* set -o emacs
* set -o errexit
* set -o hashall
* set -o histexpand
* set -o history
* set -o ignoreeof
* set -o keyword
* set -o monitor
* set -o noclobber
* set -o noexec
* set -o noglob
* set -o notify
* set -o nounset
* set -o onecmd
* set -o physical
* set -o posix
* set -o privileged
* set -o verbose
* set -o vi
* set -o xtrace
}
* set -p
* set -t
* set -u
* set -v
* set -x
* set -B
* set -C
* set -H
* set -P
* set --
* set -
}
* shift [n]
*{ shopt [-pqsu] [-o] [имя_опции ...]
* cdable_vars
* cdspell
* checkhash
* checkwinsize
* cmdhist
* dotglob
* execfail
* expand_aliases
* extglob
* histappend
* histreedit
* histverify
* hostcomplete
* huponexit
* interactive_comments
* lithist
* mailwarn
* nocaseglob
* nullglob
* promptvars
* restricted_shell
* shift_verbose
* sourcepath
}
* suspend [-f]
* test выражение
* times
* trap [-lp] [аргумент] [сигнал ...]
* type [-atp] имя [имя ...]
* ulimit [-SHacdflmnpstuv [ограничение]]
* umask [-p] [-S] [маска]
* unalias [-a] [имя ...]
* unset [-fv] [имя ...]
* wait [n]
}
======= 5 =====================================================
* Ограниченный командный интерпретатор
* Ссылки
* Файлы
* Авторы
* Информацияобошибках
* Ошибки
* Примечания
***************************************************************
***************************************************************
***************************************************************
... - не дописано
,,, - сложно
===============================================================
==== 1 ========================================================
===============================================================
* {Название
bash - командный интерпретатор GNU Bourne-Again SHell
}
* {СИНТАКСИС
    bash [опции] [файл]
}
* {Авторские права
Командный интерпретатор bash создан Фондом свободно распространяемого программного обеспечения.
Copyright (C) 1989-1999 by the Free Software Foundation, Inc.
}
* {Описание
bash - это sh-совместимый интерпретатор командного языка, выполняющий команды, прочитанные со стандартного входного потока или из файла.
Командный интерпретатор bash также включает полезные средства командных интерпретаторов Korn и C (ksh и csh).

Командный интерпретатор bash создавался как соответствующий спецификации командного интерпретатора и инструментальных средств IEEE POSIX 
(IEEE POSIX Shell and Tools specification) (IEEE Working Group 1003.2).
}
*{ Опции ...
Помимо однобуквенных опций командного интерпретатора, представленных в описании встроенной команды >>set,
bash интерпретирует при вызове следующие опции:
* -c строка
* -r
* -i
* -s
* -D
* -- 
* --dump-po-strings
* --dump-strings
* --help
* --login
* --noediting
* --noprofile
* --norc
* --posix
* --rcfile файл
* --restricted
* --verbose
* --version
}
* {Аргументы
Если после обработки опций остались аргументы и не указаны опции -c или -s,
первый аргумент считается именем файла, содержащего команды интерпретатора.
Если bash вызван таким образом, параметр $0 устанавливается равным имени файла, а значениями позиционных параметров становятся другие аргументы.
Командный интерпретатор bash читает и выполняет команды из этого файла, а затем завершает работу.
Статусом выхода bash является статус выхода последней команды, выполненной в сценарии.
Если ни одна команда не выполнена, статус выхода - 0.
}
* {Вызов ,,,
Начальный командный интерпретатор (login shell)
- это интерпретатор, первый символ нулевого аргумента которого является дефисом (-) или который запущен с опцией --login.

Интерактивным
является командный интерпретатор, стандартный входной и выходной потоки которого подключены к терминалам (что определяется с помощью функции isatty(3)), или запущенный с опцией -i.
Переменная среды PS1 устанавливается и флаги ($-) включают i, только если bash является интерактивным интерпретатором, что позволяет проверить это в файле начального запуска или в сценарии командного интерпретатора.

Следующие абзацы описывают, как bash выполняет свои файлы начального запуска.
Если любой из этих файлов существует, но не может быть прочитан, bash выдает сообщение об ошибке.
Символы тильды (~) в именах файлов заменяются так, как описано в подразделе "Замена тильды" раздела "ЗАМЕНЫ".

При вызове bash как интерактивного начального командного интерпретатора, или как неинтерактивного интерпретатора с опцией --login,
он сначала читает и выполняет команды из файла /etc/profile, если этот файл существует.
После прочтения этого файла, он последовательно ищет файлы ~/.bash_profile, ~/.bash_login и ~/.profile,
читает и выполняет команды из первого же из них, который существует и доступен на чтение.
Опция --noprofile может использоваться при запуске командного интерпретатора, чтобы отменить это действие.

При завершении работы в качестве начального командного интерпретатора
bash читает и выполняет команды в файле ~/.bash_logout, если он существует.

При запуске интерактивного командного интерпретатора, не являющегося начальным,
bash читает и выполняет команды из файла ~/.bashrc, если он существует.
Это действие можно отменить с помощью опции --norc.
Опция --rcfile файл заставляет bash читать и выполнять команды из указанного файла вместо ~/.bashrc.

При неинтерактивном запуске bash, например, для выполнения сценария,
командный интерпретатор ищет в среде переменную BASH_ENV,
получает ее значение и использует его в качестве имени файла, который необходимо прочитать и выполнить.
bash ведет себя так, как если бы была выполнена следующая команда:
    if [ -n "$BASH_ENV" ]; then . "$BASH_ENV"; fi 
но при поиске имени файла не используется значение переменной PATH.

Если bash вызван с именем sh, он пытается, наколько это возможно, имитировать поведение при запуске старых версий интерпретатора sh, соответствуя при этом стандарту POSIX.
При вызове в качестве интерактивного начального командного интерпретатора или неинтерактивного, но с опцией --login,
он сначала пытается читать и выполнять команды последовательно из файлов /etc/profile и ~/.profile.
Для отмены этого действия можно использовать опцию --noprofile.
При вызове в качестве интерактивного командного интерпретатора с именем sh,
bash ищет переменную среды ENV, получает ее значение, если оно задано, и использует это значение в качестве имени файла, который необходимо прочитать и выполнить.
Поскольку интерпретатор, вызванный как sh, не пытается читать и выполнять команды в других файлах начального запуска, опция --rcfile не действует.
Неинтерактивный командый интерпретатор, вызванный с именем sh, не пытается читать и выполнять никакие файлы начального запуска.
При вызове по имени sh, командный интерпретатор bash входит в режим posix после прочтения файлов начального запуска.

При запуске bash в режиме posix, например, с помощью опции командной строки --posix,
он следует стандарту POSIX при работе с файлами начального запуска.
В этом режиме интерактивные командные интерпретаторы берут значение переменной среды ENV, читают и выполняют команды из соответствующего файла.
Никакие другие файлы начального запуска не читаются.

Командный интерпретатор bash пытается определить, не запущен ли он демоном удаленного командного интерпретатора, обычно, rshd.
Если оказывается, что bash запущен демоном rshd, он читает и выполняет команды из файла ~/.bashrc, если этот файл существует и доступен на чтение.
Командный интерпретатор bash так не делает, если запущен как sh.
Для отмены этого действия можно использовать опцию --norc, а с помощью опции --rcfile можно заставить читать другой файл,
но обычно демон rshd не задает эти опции командному интерпретатору и не позволяет их указать.

Если командный интерпретатор запущен с эффективным идентификатором пользователя (группы), не совпадающим с реальным идентификатором пользователя (группы), и не указана опция -p,
файлы начального запуска не читаются, функции командного интерпретатора не наследуются из среды, переменная SHELLOPTS, если она задана в среде, игнорируется, а эффективный идентификатор пользователя устанавливается равным реальному.
Если при вызове задана опция -p, файлы начального запуска тоже не читаются, но эффективный идентификатор пользователя не сбрасывается.
}
===============================================================
* {Определения
В оставшейся части документа используются следующие термины.

пробел
    Символ пробела или символ табуляции.

слово
    Последовательность символов, рассматриваемая командным интерпретатором как единое целое. 
	Также называется лексемой (token).

имя
    Слово, состоящее только из алфавитноцифровых символов и символов подчеркивания, и начинающееся с буквы или символа подчеркивания.
	Также называется идентификатором.

метасимвол
    Символ, разделяющий слова, если он не замаскирован.
	Один из следующих символов:
        |	конвейер
		&	выполнять в фоне и перенаправление
		;	
		( )
		< >	перенаправление
		пробел табуляция 

управляющий оператор
    Лексема, выполняющая функцию управления.
	Это один из следующих символов:
        ||	ИЛИ
		&	выполнять в фоне
		&&	И
		;	завершение
		;;	разделитель вариантов в case
		( )	группировка в порожденном интерпретаторе
		|	конвейер, разделение образцов в одном варианте в case
		<перевод строки> завершение
}
* {Зарезервированные слова
Зарезервированными являются слова, имеющие специальное значение для командного интерпретатора.
Следующие слова распознаются как зарезервированные, если не замаскированы и являются 
	либо первым словом простой команды (см. "СИНТАКСИС КОМАНД" ниже), 
	либо третьим словом команды case или for:
!		//отрицание, конвейеры
case	//Составные команды
do		//Составные команды
done	//Составные команды
elif	//Составные команды
else	//Составные команды
esac	//Составные команды
fi		//Составные команды
for		//Составные команды
function //Составные команды
if		//Составные команды
in		//Составные команды
select	//Составные команды
then	//Составные команды
until	//Составные команды
while	//Составные команды
{ }		//группировка в текущем интерпретаторе, функции, 
//+замена в фиг. скобках - только в баш
time	//команда, возвращающая время выполнения своего аргумента, конвейеры
[[ ]]	//,,, "УСЛОВНЫЕ ВЫРАЖЕНИЯ".
}
* {Комментарии
В неинтерактивном командном интерпретаторе или в интерактивном с включенной опцией interactive_comments встроенной команды shopt (см. раздел "ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА" ниже),
слово, начинающиеся символом #, влечет игнорирование этого слова и последующих символов в строке.
Интерактивный командный интерпретатор с не включенной опцией interactive_comments не допускает использования комментариев.
Опция interactive_comments по умолчанию включается в интерактивных командных интерпретаторах.
}
* {Маскировка
Маскировка (quoting) используется для отмены специального значения для командного интерпретатора определенных символов или слов.
Маскировку можно использовать для отмены специфической обработки специальных символов, 
для предотвращения распознавания зарезервированных слов, а также для предотвращения подстановки параметров.

Каждый из метасимволов, перечисленных выше в разделе "ОПРЕДЕЛЕНИЯ", имеет специальное значение для командного интерпретатора и должен маскироваться, если используется буквально.
Имеется три механизма маскировки: символ маскировки (escape character), одиночные кавычки и двойные кавычки.

Незамаскированная ОБРАТНАЯ КОСАЯ черта (\) является символом маскировки.
Он требует использовать следующий за ним символ (за исключением перевода строки) буквально.
Если введена пара символов \<перевод строки> и сама обратная косая не замаскирована,
эта пара обрабатывается как признак продолжения строки (т.е. она удаляется из входного потока и, по сути, игнорируется).

Все символы в ОДИНОЧНЫХ КАВЫЧКАХ используются буквально.
Символ одиночной кавычки (апостроф) не должен указываться между одиночными кавычками, даже если он предваряется обратной косой.

Символы в ДВОЙНЫХ КАВЫЧКАХ используются буквально, за исключением символов $, ` и \.
Символы $ и ` в двойных кавычках имеют то же специальное значение.
Обратная косая имеет специальное значение только если после нее идет один из следующих символов:
$, `, \", \ или <перевод строки>.
Двойную кавычку можно указывать в двойных кавычках, замаскировав обратной косой.

Специальные параметры * и @ имеют специальное значение при указании в двойных кавычках (см. раздел "ПАРАМЕТРЫ" ниже).

Слова вида $'строка' обрабатываются особым образом.
Слово заменяется строкой, в которой предваренные обратной косой символы заменяются в соответствии со стандартом ANSI C.
Управляющие последовательности, начинающиеся с обратной косой, декодируются следующим образом:
\a	тревога (звонок)
\b	забой
\e	управляющий символ
\f	прогон страницы (form feed)
\n	перевод строки (new line)
\r	carriage return (возврат каретки)
\t	табуляция
\v	вертикальная табудяция
\\	обратная косая
\nnn	символ, ASCII-код которого совпадает с восьмеричным значением nnn (от одной до трех цифр)
\xnnn	символ, ASCII-код которого совпадает с шестнадцатеричным значением nnn (от одной до трех цифр)

Преобразованный результат помещается в одиночные кавычки, как если бы символа доллара просто не было.

Строка в двойных кавычках, перед которой идет символ доллара ($), будет преобразована в соответствии с текущей локалью.
Если текущая локаль - C или POSIX, символ доллара игнорируется.
Если строка преобразована и заменена, результат помещается в двойные кавычки.
}
*{ Синтаксис команд
список

* {Простые команды //присваивания, слова, перенаправления
Простая команда - это завершающаяся управляющим оператором
последовательность необязательных присваиваний значений переменным,
после которых идут слова, разделенные пробелами, и перенаправления потоков.

Первое слово задает команду, которую надо выполнить.
Оставшиеся слова передаются как аргументы вызванной команде.

Возвращаемым значением простой команды является ее статус выхода,
или 128+n, если команда завершена сигналом n.
}
* {Конвейеры //(команд) +отрицание +команда time
Конвейер - это последовательность одной или более команд, разделенных символом |.
Конвейер имеет следующий формат:
    [time [-p]] [ ! ] команда [ | команда2 ... ] 

Стандартный выходной поток команды связывается со стандартным входным потоком команды2.
Эта связь выполняется раньше, чем любые перенаправления, задаваемые командой (см. "ПЕРЕНАПРАВЛЕНИЕ" ниже).

Если перед конвейером указано зарезервированное слово !,
статус выхода такого конвейера является логическим отрицанием статуса выхода последней команды.
В противном случае, статус выхода конвейера совпадает со статусом выхода последней команды.
Прежде, чем возвращать значение, командный интерпретатор ждет завершения всех команд в конвейере.

Если перед конвейером идет зарезервированное слово time,
после завершения конвейера выдается общее, пользовательское и системное время, потраченное на его выполнение.
Опция -p изменяет формат вывода на задаваемый стандартом POSIX.
Переменная TIMEFORMAT может задавать строку формата выдачи информации о времени;
см. описание переменной TIMEFORMAT в разделе "Переменные командного интерпретатора" ниже.

Каждая команда в конвейере выполняется как отдельный процесс (т.е. в порожденном интерпретаторе).
}
* {Списки	//(конвейеров) И, ИЛИ, фоновое выполнение, ;
Список - это последовательность одного или более конвейеров,
разделенных одним из операторов ;, &, && или ||,
и не обязательно завершающаяся одним из операторов ;, & или <перевод строки>.

Из этих операторов списка && и || имеют равный приоритет,
причем больший, чем ; и &, тоже имеющие равный приоритет.

Если команда завершается управляющим оператором &,
интерпретатор выполняет команду в фоновом режиме в порожденном интерпретаторе. Командный интерпретатор не ждет завершения команды, а статус выхода в этом случае - 0. Команды, разделенные ; выполняются последовательно; командный интерпретатор ждет поочередно завершения каждой из команд. Статус возврата списка в этом случае совпадает со статусом возврата последней выполненной команды.

Управляющие операторы && и || обозначают, соответственно, И-списки и ИЛИ-списки.
И-список имеет вид
    команда && команда2 
Команда2 выполняется только и если только команда вернула статус выхода ноль.
ИЛИ-список имеет вид
    команда || команда2 
Команда2 выполняется только и если только команда вернула ненулевой статус выхода.
И- и ИЛИ-списки возвращают статус последней команды, выполненной в списке.
}
*{ Составные команды
* {(список)		//группировка в порожденном интерпретаторе
Список выполняется в порожденном командном интерпретаторе.
Присваивания переменным и встроенные команды, влияющие на среду командного интерпретатора, 
не действуют после завершения команды. 
Статусом возврата является статус выхода списка.
}
* {{ список; }	//группировка в текущем интерпретаторе
Список просто выполняется в среде текущего командного интерпретатора.
Список должен завершаться переводом строки или точкой с запятой.
Эту команду называют командой группировки.
Статусом возврата является статус выхода списка.
}
* {((выражение)) //=let арифметическое выражение, см "ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ"
Выражение вычисляется в соответствии с правилами, описанными ниже в разделе "ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ".
Если выражение имеет ненулевое значение, статус возврата равен 0; в противном случае - 1.
Эта конструкция эквивалентна конструкции let "выражение".
}
* {[[ выражение ]] //,,, "УСЛОВНЫЕ ВЫРАЖЕНИЯ"
Возвращает статус 0 или 1 в зависимости от значения указанного условного выражения.
Выражения состоят из компонентов, описанных ниже в разделе "УСЛОВНЫЕ ВЫРАЖЕНИЯ".
Деление слов и подстановка имен файлов в словах между [[ и ]] не выполняется;
выполняется замена тильды, подстановка значений параметров и переменных, 
арифметическая подстановка, подстановка результатов команд и подстановка процессов,
а также удаление кавычек.

При использовании операторов == и != строка справа оператора считается образцом
и сопоставляется по правилам, описанным ниже в подразделе "Сопоставление с образцом".
Возвращается значение 0 если строка, соответственно, сопоставляется и не сопоставляется с образцом, и 1 в противном случае.
Любая часть образца может быть взята в кавычки, чтобы сопоставление с ней шло буквально.

Выражения можно комбинировать с помощью следующих операторов,
перечисленных в порядке снижения приоритета:

    ( выражение )
        Возвращает значение выражения.
		Круглые скобки можно использовать для изменения обычного приоритета операторов.

    ! выражение
        Истинно, если выражение ложно.

    выражение1 && выражение2
        Истинно, если истинны оба выражения, выражение1 и выражение2.

    выражение1 || выражение2
        Истинно, если истинно выражение1 или выражение2.

    Операторы && и || не вычисляют выражение2, если значения выражения1 достаточно
	для определения возвращаемого значения всего условного выражения.
}
* {if
	if список;
	then список; 
	[ elif список; then список; ]... 
	[ else список; ]
	fi
Выполняется список после if.
Если его статус выхода - 0, выполняется список после then.
В противном случае, выполняется последовательно список в очередной конструкции elif, 
и если его статус выхода - 0, выполняется соответствующий список после then и команда завершается.
Если все конструкции elif проверены и ни один из списков не вернул статус 0, выполняется список после else, если эта конструкция задана.
Статусом выхода является статус выхода последней выполненной команды или 0, если ни одно из условий не оказалось истинным.
}
* {case
	case слово in 
	[ ( образец [ | образец ]... ) список ;; ]... 
	esac
Команда case сначала подставляет значение слова
и пытается его сопоставить поочередно с каждым образцом,
используя те же правила сопоставления, что и для имен файлов (см. подраздел "Подстановка имен файлов").
Если найден сопоставляющийся образец, выполняется соответствующий список.
После нахождения первого сопоставления дальнейшее сопоставление не выполняется и команда завершается.
Статус выхода равен 0, если ни один образец не сопоставился.
В противном случае, он равен статусу выхода последней выполненной команды из соответствующего списка.
}
* {while until
	while список; do список; done
	until список; do список; done
Команда while циклически выполняет список после do,
пока последняя команда списка возвращает статус выхода 0.
Команда until идентична команде while, но условие завершения - противоположно;
список после do выполняется, пока последняя команда списка возвращает ненулевой статус выхода.
Статусом выхода команд while и until является статус выхода последней выполненной команды списка
или 0, если ни одна команда не выполнена.
}
* {for	//по умолчанию по позиционным параметрам
	for имя [ in список_слов ] ; do список ; done
Выполняются подстановки в списке_слов после in,
в результате чего получается список элементов.
Переменная с соответствующим именем последовательно получает значение каждого элемента этого списка,
и каждый раз выполняется список.
Если слово in не указано, команда for выполняет список для каждого установленного позиционного параметра (см. раздел "ПАРАМЕТРЫ" ниже). 
Сатусом возврата является статус выхода последней выполненной команды.
Если в результате подстановок элементов списка_слов после in получается пустой список,
команды не выполняются и возвращается статус 0.
}
* {select //предлагает пользователю выбрать, пока не выполниться break, по умолчанию по позиционным параметрам
	select имя [ in список_слов ] ; do список ; done
Выполняются подстановки в списке_слов после in, в результате чего получается список элементов.
Набор полученных после подстановки слов выдается в стандартный поток ошибок, причем перед каждым элементом выдается его порядковый номер.
Если слово in не указано, выдаются установленные позиционные параметры (см. раздел "ПАРАМЕТРЫ" ниже).
Затем выдается приглашение PS3 и читается строка со стандартного входного потока.
Если эта строка содержит число, соответствующее одному из выданных слов, то переменная имя получает его значение.
Если строка пустая, слова и приглашение выдаются снова.
Если прочитан символ конца файла (EOF), команда заврешается.
При вводе любого другого значения переменная имя получает пустое значение.
Прочитанная строка сохраняется в переменной REPLY.
Список выполняется после каждого выбора, пока не будет выполнена команда break или return.
Статусом выхода команды select является статус выхода последней команды в списке, или 0, если ни одна команда не была выполнена.
}
* {function	//"ФУНКЦИИ"
	[ function ] имя () { список; }
Эта команда определяет функцию с указанным именем.
Тело функции образует список команд между фигурными скобками { и }.
Этот список выполняется каждый раз, когда имя функции указывается как имя простой команды.
Статусом выхода функции является статус выхода последней команды, выполненной в теле функции. (См. раздел "ФУНКЦИИ" ниже.)
}
}
}
===============================================================
======= 2 =====================================================
===============================================================
*{ Параметры,,,
{Параметр - это сущность, хранящая значение.
Это может быть имя, число или один из специальных символов, перечисленных ниже в разделе "Специальные параметры".
В контексте интерпретатора, переменная - это параметр, обозначаемый именем.

Параметр устанавливается, если ему присвоено значение.
Пустая строка является допустимым значением.
После того, как переменная установлена, она может быть удалена только с помощью встроенной команды unset
(см. раздел "ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА" ниже).

Значение переменной может быть присвоено с помощью оператора вида

    имя=[значение] 

Если значение не задано, переменной присваивается пустая строка.
Во всех значениях выполняется 
	замена тильды, 
	подстановка значений параметров и переменных, 
	обработка строк, 
	подстановка результатов выполнения команд, 
	арифметические вычисления 
	и удаление символов маскировки 
	(см. раздел "ОБРАБОТКА" ниже).
Если для переменной установлен атрибут целочисленная (integer)
(см. declare в разделе "ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА" ниже),
ее значение арифметически вычисляется, даже если арифметическое вычисление $((...)) не указано явно
(см. подраздел "Арифметическое вычисление" ниже).
Разбиение на слова не выполняется, за исключением значения "$@",
как объяснено ниже в подразделе "Специальные параметры".
	Подстановка имен файлов не выполняется.
}

*{ Позиционные параметры
Позиционный параметр - это параметр, обозначаемый одной или несколькими цифрами, кроме цифры 0.
Позиционным параметрам значения присваиваются на основе аргументов, переданных при вызове командного интерпретатора,
и могут быть переприсвоены с помощью встроенной команды set.
Позиционным параметрам нельзя присваивать значения с помощью операторов присваивания.
Позиционные параметры временно заменяются при выполнении функции командного интерпретатора
	(см. раздел "ФУНКЦИИ" ниже).

Когда позиционный параметр состоит из нескольких цифр, его надо брать в скобки (см. раздел "ОБРАБОТКА" ниже).
}
*{ Специальные параметры
Командный интерпретатор обрабатывает ряд параметров специальным образом.
Можно только ссылаться на значения этих параметров - присваивания им не разрешены.
*	{Заменяется позиционными параметрами, начиная с первого.
	Когда такая замена выполняется в двойных кавычках, результат будет одним словом,
	в котором значения параметров разделены первым символом значения специальной переменной IFS.
	То есть, "$*" эквивалентно "$1c$2c...", где c - первый символ значения переменной IFS.
	Если переменная IFS не установлена, значения параметров разделяются пробелами.
	Если переменная IFS имеет пустое значение, значения параметров просто конкатенируются, без разделителей.
}
@	{Заменяется позиционными параметрами, начиная с первого.
	Когда такая замена выполняется в двойных кавычках, каждый параметр заменяется отдельным словом.
	То есть, "$@" эквивалентно "$1" "$2" ...
	Когда позиционных параметров нет, "$@" и $@ заменяются пустой строкой (т.е. они просто удаляются).
}
#	Заменяется десятичным значением количества позиционных параметров.
?	Заменяется статусом последнего выполненного в приоритетном режиме конвейера.
-	{Заменяется флагами текущих опций, заданных при вызове, с помощью встроенной команды set
	или установленных самим командным интерпретатором (как, например, опция -i).
}
$	{Заменяется идентификатором процесса командного интерпретатора.
	В порожденном командном интерпретаторе, запущенном с помощью (),
		заменяется идентификатором процесса основного интерпретатора, а не порожденного.
}
!	Заменяется идентификатором последнего процесса, запущенного в фоновом (асинхронном) режиме.
0	{Заменяется именем командного интерпретатора или сценария.
	Это значение устанавливается при инициализации командного интерпретатора.
	Если bash вызван с командным файлом, $0 будет установлен равным имени этого файла.
	Если bash запущен с опцией -c, $0 получает значение первого аргумента после строки,
		которую надо выполнить, если он задан. 
	В противном случае, этот специальный параметр получает значение имени файла,
		использованного для вызова bash, которое задается нулевым аргументом.
}
_	{При запуске командного интерпретатора устанавливается равным полному имени файла (absolute file name) командного интерпретатора
		или выполняемого сценария, переданного в списке аргументов.
	В последствии, заменяется последним аргументом предыдущей команды, с учетом всех замен.
	Также устанавливается равным полному имени файла каждой выполняемой внешней команды
		и помещается в среду, экспортируемую для этой команды.
	При проверке почты этот параметр содержит имя проверяемого файла почты. 
}
}
*{ Переменные командного интерпретатора ...
Командный интерпретатор устанавливает следующие переменные:
BASH	Полное имя файла, использованное для вызова данного экземпляра bash.
BASH_VERSION		Строка, описывающая версию данного экземпляра bash.
BASH_VERSINFO		Доступный только для чтения массив, элементы которого содержат информацию о версии для данного экземпляра bash. Элементы массива имеют следующие значения:
BASH_VERSINFO[0]	Главный номер версии (релиз).
BASH_VERSINFO[1]	Второстепенный номер версии (версия).
BASH_VERSINFO[2]	Уровень исправлений.
BASH_VERSINFO[3]	Версия сборки.
BASH_VERSINFO[4]	Статус релиза (например, beta1).
BASH_VERSINFO[5]	Значение переменной MACHTYPE.

PPID	Идентификатор родительского процесса для командного интерпретатора.
		Эта переменная доступна только для чтения.
SHLVL	Увеличивается на 1 при каждом запуске порожденного интерпретатора bash.

PWD		Текущий рабочий каталог, установленный с помощью команды cd.
OLDPWD	Предыдущий рабочий каталог, который был установлен с помощью команды cd.
DIRSTACK	Переменная-массив (см. раздел "Массивы" далее), в которой хранится текущее содержимое стека каталогов. Каталоги находятся в стеке в том же порядке, в котором выдаются встроенной командой dirs. Путем присваивания элементам этого массива можно изменять каталоги, уже находящиеся в стеке, но для добавления и удаления каталогов надо использовать встроенные команды pushd и popd. Присваивание значения этой переменной не меняет текущий каталог. Если переменная DIRSTACK удаляется с помощью unset, она теряет свои специальные свойства, даже если в дальнейшем переустанавливается.

UID		Идентификатор текущего пользователя - устанавливается при запуске командного интерпретатора.
		Эта переменная доступна только для чтения.
EUID	Эффективный идентификатор текущего пользователя - устанавливается при запуске командного интерпретатора.
		Эта переменная доступна только для чтения.
GROUPS	Переменная-массив, содержащая список групп, в которые входит текущий пользователь. Эта переменная доступна только для чтения.

RANDOM		При каждом обращении к этому параметру генерируется случайное число от 0 до 32767. Конкретная последовательность случайных чисел может быть проинициализирована путем присваивания значения переменной RANDOM.
			Если переменная RANDOM удаляется с помощью unset, она теряет свои специальные свойства, даже если в дальнейшем переустанавливается.
SECONDS		При каждом обращении к этому параметру возвращается количество секунд, прошедших с момента вызова данного командного интерпретатора. Если переменной SECONDS присваивается значение, при последующем обращении будет получено количество секунд, прошедшее с момента присваивания, плюс присвоенное значение. Если переменная SECONDS удаляется с помощью unset, она теряет свои специальные свойства, даже если в дальнейшем переустанавливается.
LINENO		При каждом обращении к этому параметру командный интерпретатор подставляет десятичное число, представляющее порядковый номер текущей строки (начиная с 1) в сценарии или функции. При вызове не из сценария или функции, не гарантируется подстановка осмысленного значения. Если переменная LINENO удаляется с помощью unset, она теряет свои специальные свойства, даже если в дальнейшем переустанавливается.
HISTCMD		Исторический номер команды, или индекс текущей команды в списке выполненных команд. Если переменная HISTCMD удаляется с помощью unset, она теряет свои специальные свойства, даже если в дальнейшем переустанавливается.
PIPESTATUS	Переменная-массив (см. раздел "Массивы" далее), содержащая список значений статусов выхода процессов в последнем выполненном в приоритетном режиме конвейере (который может состоять и всего из одной команды).
OPTARG		Значение последнего аргумента-опции, обработанного встроенной командной getopts (см. раздел "ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА" ниже).
OPTIND		Индекс следующего аргумента, который должен быть обработан встроенной командой getopts (см. раздел "ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА" ниже).
HOSTNAME	Автоматически устанавливается равной имени текущего хоста.
HOSTTYPE	Автоматически устанавливается равной строке, уникально описывающей тип машины, на которой выполняется bash. Стандартное значение зависит от системы.
HOSTYPE		Автоматически устанавливается равной строке, описывающей операционную систему, на которой выполняется командный интерпретатор bash. Стандартное значение зависит от системы.
MACHTYPE	Автоматически устанавливается равной строке, полностью описывающей тип системы, на которой выполняется bash, в стандартном для GNU формате процессор-компания-система. Стандартное значение зависит от системы.
SHELLOPTS	Список установленных опций командного интерпретатора через двоеточие. Каждое слово в списке - допустимый аргумент для опции -o встроенной команды set (см. раздел "ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА" ниже). Опции, упоминающиеся в списке SHELLOPTS, совпадают с выдаваемыми как установленные командой set -o. Если эта переменная экспортирована в среду при запуске командного интерпретатора bash, все упомянутые в списке опции будут установлены до чтения любых файлов начального запуска. Эта перменная доступна только для чтения.

Следующие переменные используются командным интерпретатором. В некоторых случаях bash присваивает переменным стандартные значения; эти случаи указаны ниже.
IFS			Внутренний разделитель полей (Internal Field Separator), используемый для выделения слов после всех подстановок и для разбиения на слова строк, прочитанных с помощью встроенной команды read. Стандартное значение - "<пробел><табуляция><перевод строки>".
PATH		Путь поиска команд. Это список каталогов через двоеточие, в которых командный интерпретатор ищет команды (см. раздел "ВЫПОЛНЕНИЕ КОМАНД" ниже). Стандартный путь поиска зависит от системы и задается администратором, устанавливающим bash. Типичное значение: "/usr/gnu/bin :/usr/local/bin
:/usr/ucb:/bin:/usr/bin:.".
HOME		Начальный каталог текущего пользователя; стандартный аргумент для встроенной команды cd. Значение этой переменной также используется при замене тильды.
CDPATH		Путь поиска для команды cd. Это список каталогов через двоеточие, в которых командный интерпретатор ищет целевые каталоги, указанные по имени в команде cd. Пример возможного значения - ".:~:/usr".
BASH_ENV	Если этот параметр установлен при выполнении командным интерпретатором bash сценария, его значение интерпретируется как имя файла, содержащего команды инициализации интерпретатора, аналогично ~/.bashrc. В значении BASH_ENV перед интерпретацией выполняется подстановка значений параметров, подстановка результатов выполнения команд и арифметические вычисления. Переменная PATH не используется для поиска результирующего имени файла.
MAIL		Если этот параметр установлен равным имени файла и не установлена переменная MAILPATH, bash информирует пользователя о получении электронной почты в указанный файл.
MAILCHECK	Задает частоту проверки (в секундах) электронной почты командным интерпретатором bash. Стандартное значение - 60 секунд. Когда приходит время проверять наличие новой почты, командный интерпретатор делает это перед выдачей первичного приглашения. Если эта переменная не установлена, проверка почты командным интерпретатором отключается.
MAILPATH	Список имен файлов через двоеточие, в которых нужно проверять наличие новых почтовых сообщений. Можно задавать сообщение, которое должно выдаваться при поступлении почты в конкретный файл, отделяя сообщение от имени файла вопросительным знаком (?). В тексте этого сообщения метасимвол $_ заменяется именем текущего файла почты. Например:

MAILPATH='/usr/spool/mail/bfox?"You have mail"
:~/shell-mail?"$_ has mail!"'

Командный интерпретатор bash поддерживает стандартное значение для этой переменной, но используемое при этом местонахождение файлов почты пользователя зависит от системы (например, /usr/spool/mail/$USER).
PS1	Значение этого параметра обрабатывается (см. раздел "ПРИГЛАШЕНИЯ" ниже) и используется для установки строки первичного приглашения. Стандартное значение - "\s-\v\$ ".
PS2	Значение этого параметра обрабатывается, как и PS1, и используется для установки строки вторичного приглашения. Стандартное значение - "> ".
PS3	Значение этого параметра используется в качестве приглашения для команды select (см. раздел "СИНТАКСИС КОМАНД" выше).
PS4	Значение этого параметра обрабатывается, как и PS1, и выдается перед каждой командой, показываемой интерпретатором bash в ходе трассировки выполнения. Первый символ PS4 повторяется необходимое количество раз, показывая уровень вложенности. Стандартное значение - "+".
TIMEFORMAT	Значение этого параметра используется в качестве строки, задающей формат выдачи информации о времени выполнения для конвейеров, перед которыми задано зарезервированное слово time. Символ % начинает управляющую последовательность, заменяемую значением времени или другой информацией. Управляющие последовательности имеют следующие значения (в квадратных скобках представлены необязательные части):
%%	Символ %.
%[p][l]R	Время выполнения, в секундах.
%[p][l]U	Количество секунд работы процессора в пользовательском режиме.
%[p][l]S	Количество секунд работы процессора в системном режиме.
%P	Процент использования процессора, вычисляемый как (%U + %S) / %R.
Необязательный параметр p - это цифра, задающая точность, количество знаков (долей секунды) после запятой. Значение 0 отменяет выдачу долей секунды. Максимальная точность - три знака после запятой; значения p больше 3 заменяются на 3. Если p не задано, используется значение 3.

Необязательный параметр l задает длинный формат, включая минуты, в виде MMmSS.FFs. Значение праметра p определяет, включаются доли секунды или нет.

Если эта переменная не установлена, bash действует так, как если бы она имела значение $'\nreal\t%3lR\nuser\t%3lU\nsys%3lS'. Если установлено пустое значение, информация о времени выполнения не выдается. При выводе строки по формату добавляется перевод строки.
HISTSIZE	Количество команд, которые необходимо запоминать в списке истории (см. раздел "ИСТОРИЯ КОМАНД" ниже). Стандартное значение - 500.
HISTFILE	Имя файла, в котором сохраняется история команд (см. раздел "ИСТОРИЯ КОМАНД" ниже). Стандартное значение - ~/.bash_history. Если эта переменная не установлена, история команд не сохраняется при завершении работы интерактивного командного интерпретатора.
HISTFILESIZE	Максимальное количество строк, содержащееся в файле истории. Если этой переменной присвоено значение, файл истории, при необходимости, усекается, и будет содержать не больше, чем указанное количество строк. Стандартное значение - 500. Файл истории также усекается до этого размера после записи при выходе из интерактивного командного интерпретатора.
OPTERR		Если имеет значение 1, bash показывает сообщения об ошибках, выдаваемые встроенной командой getopts (см. раздел "ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА" ниже). Переменная OPTERR инициализируется значением 1 при каждом вызове командного интерпретатора или выполнении сценария.
LANG		Используется для определения локали для всех категорий, не заданных явно с помощью переменной, имя которой начинается с LC_.
LC_ALL		Эта переменная переопределяет значение переменной LANG и всех остальных переменных LC_, задающих категорию локали.
LC_COLLATE	Эта переменная задает порядок сортировки, используемый при сортировке полученных по шаблону имен файлов, и определяет интерпретацию диапазонов, классов эквивалентостей и правила сравнения символов для подстановки имен файлов и сопоставления с образцом.
LC_CTYPE	Эта переменная определяет интерпретацию символов и принадлежность символов к определенному классу для подстановки имен файлов и сопоставления с образцом.
LC_MESSAGES	Эта переменная определяет локаль, используемую для обработки строк в двойных кавычках, перед которыми указан символ $.
PROMPT_COMMAND	Если значение задано, оно выполняется как команда перед выдачей каждого первичного приглашения.
IGNOREEOF	Управляет действием командного интерпретатора при получении символа конца файла (EOF) как единственного символа в строке. Если эта переменная установлена, ее значение интерпретируется как количество подряд идущих символов EOF, с которых должна начинаться строка, чтобы в результате работа командного интерпретатора bash завершилась. Если переменная существует, но не имеет числового значения или не имеет значения вообще, по умолчанию используется значение 10. Если эта переменная не существует, EOF означает конец входных данных для командного интерпретатора.
TMOUT		Если установлено значение больше нуля, оно интерпретируется как количество секунд ожидания ввода после выдачи первичного приглашения. Командный интерпретатор bash завершает работу по истечении этого времени, если не введена команда.
FCEDIT		Задает стандартный редактор для встроенной команды fc.
FIGNORE		Список суффиксов через двоеточие, которые необходимо игнорировать при завершении имен файлов (см. раздел "БИБЛИОТЕКА READLINE" ниже). Имя файла, суффикс которого совпадает с одним из указанных в FIGNORE значений, исключается из списка соответствующих имен файлов. Пример значения - ".o:~".
GLOBIGNORE	Список шаблонов через двоеточие, задающих набор имен файлов, которые надо игнорировать при подстановке имен. Если имя файла, соответствующее шаблону, также соответствует одному из шаблонов в GLOBIGNORE, оно удаляется из списка соответствующих.
INPUTRC		Имя файла начального запуска readline, переопределяющего стандартные установки в файле ~/.inputrc (см. раздел "БИБЛИОТЕКА READLINE" ниже).
HISTCONTROL	Если имеет значение ignorespace, строки, начинающиеся символом пробела, не попадают в список выполненных команд. Если имеет значение ignoredups, строки, совпадающие с последней выполненной командой, в список выполненных команд не попадают. Значение ignoreboth сочетает действие обеих представленных опций. Если переменной нет или она имеет какое-то другое значение, кроме перечисленных выше, все строки, прочитанные синтаксическим анализатором, сохраняются в списке истории, с учетом значения переменной HISTIGNORE. Действие этой переменной переопределяется переменной HISTIGNORE. Вторая и следующие строки многострочной составной команды не проверяются, и добавляются в список истории независимо от значения HISTCONTROL.
HISTIGNORE	Список шаблонов через двоеточие, используемых для принятия решения о сохранении командных строк в списке истории. Каждый шаблон привязывается к началу строки и должен задавать всю строку ('*' неявно не добавляется). Каждый шаблон сравнивается со строкой после проверок, задаваемых переменной HISTCONTROL. Кроме обычных символов сопоставления с образцом в командном интерпретаторе, символ '&' сопоставляется с предыдущей строкой в списке истории. Символ '&' можно экранировать с помощью обратной косой. Перед сопоставлением обратная косая убирается. Вторая и последующая строки составной многострочной команды не проверяются и добавляются в список истории независимо от значения переменной HISTIGNORE.
histchars	Два или три символа, управляющих подстановкой и разбиением на лексемы уже выполненных команд (см. раздел "ПОДСТАНОВКА КОМАНД ИЗ СПИСКА ВЫПОЛНЕННЫХ" ниже). Первый символ - это символ подстановки из списка, который означает начало работы со списком истории. Обычно это символ '!'. Второй символ - это символ быстрой подстановки, используемый для быстрого повторения предыдущей введенной команды, с подстановкой указанной строки вместо другой, заданной в этой команде. По умолчанию используется символ '^'. Необязательный третий символ - это символ, указывающий, если является первым символом слова, что остаток строки - это комментарий. Обычно в этом качестве используется символ '#'. Символ комментария для списка истории приводит к отказу от подстановки из истории для оставшихся слов в командной строке. Он не обязательно приводит к обработке синтаксическим анализатором оставшейся части строки как комментария.
HOSTFILE	Содержит имя файла того же формата, что и файл /etc/hosts, который будет читаться при необходимости подстановки имени хоста. Этот файл можно менять интерактивно; при следующей попытке подстановки имени хоста bash добавит содержимое нового файла к уже существующей базе данных.
auto_resume	Эта переменная управляет взаимодействием командного интерпретатора с пользователем и средствами управления заданиями. Если она установлена, простые команды из одного слова и без перенаправлений рассматриваются как указатели возможного возобновления существующих остановленных заданий. Неоднозначность не допускается; если с введенной строки начинается более одного задания, выбирается последнее по времени приостановки задание. Имя остановленного задания, в этом контексте, - это командная строка, использовавшаяся для его запуска. Если эта переменная имеет значение exact, введенная строка должна точно совпадать с именем остановленного задания; Если же задано значение substring, введенная строка должна быть подстрокой имени остановленного задания. Это аналогично по возможностям идентификатору задания %? (см. раздел "УПРАВЛЕНИЕ ЗАДАНИЯМИ" ниже). Если установлено любое другое значение, введенная строка должна быть префиксом имени остановленного задания; это аналогично по возможностям идентификатору задания %. 
REPLY	Устанавливается равной значению, прочитанному встроенной командой read, при вызове ее без аргументов.
}
* Массивы
}
*{ Замены,,,
{Замена выполняется в командной строке после разбиения ее на слова. 
Выполняется семь видов замен: 
	замена выражений в фигурных скобках,
	замена тильды,
	подстановка значений переменных и параметров,
	подстановка результатов выполнения команд,
	подстановка значений арифметических выражений,
	разбиение слов 
	и подстановка имен файлов.

Замена выполняется в следующем порядке: 
	замена выражений в фигурных скобках, 
	замена тильды, 
	подстановка значений переменных, параметров, 
		арифметических выражений 
		и результатов выполнения команд (слева направо),
	разбиение слов
	и подстановка имен файлов.

В системах, где это может поддерживаться, выполняется дополнительная замена - подстановка процессов.

Только 
	замена выражений в фигурных скобках, 
	разбиение слов 
	и подстановка имен файлов 
может изменить количество слов в командной строке;
при других заменах одно слово просто заменяется другим.
Единственное исключение - подстановка "$@" и "${имя[@]}", как объяснялось выше (см. раздел "ПАРАМЕТРЫ").
}

{* Замена выражений в фигурных скобках//prefix{a,b,c}postfix - only bash
Замена выражений в фигурных скобках - это механизм генерации произвольных строк.
Он аналогичен подстановке имен файлов, но генерируемые имена не обязательно должны существовать.
Шаблоны в фигурных скобках имеют вид необязательного префикса, 
за которым идет набор строк через запятую в фигурных скобках, 
после чего - необязательный суффикс.
Префикс добавляется в начало каждой строки, содержащейся в фигурных скобках, 
а затем к каждой полученной так (слева направо) строке добавляется суффикс.

Выражения в фигурных скобках могут быть вложенными.
Результаты каждой замены не сортируются; порядок слева направо сохраняется. Например, конструкция a{d,c,b}e заменяется на 'ade ace abe'.

Замена выражений в фигурных скобках выполняется перед любыми другими заменами,
и в результате сохраняются все символы, имеющие специальное значение для других замен.
Эта замена - строго текстуальная.
Командный интерпретатор bash никак не учитывает контекст подстановки или текст в фигурных скобках.

Корректное выражение в фигурных скобках должно содержать незамаскированные открывающую и закрывающую фигурную скобку и, по крайней мере, одну незамаскированную запятую.
Любое некорректное выражение в фигурных скобках остается неизменным.
Символ '{' или , может маскироваться обратной косой для предотвращения его интерпретации на этапе замены выражений в фигурных скобках.

Эта конструкция обычно используется для сокращенной записи группы строк с общим префиксом, более длинным чем в представленном выше примере:
    mkdir /usr/local/src/bash/{old,new,dist,bugs} 
или
    chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}} 

Замена выражений в фигурных скобках вносит небольшое РАССОГЛАСОВАНИЕ с историческими версиями sh.
Командный интерпретатор sh не рассматривает открывающую и закрывающую фигурные скобки в слове специальным образом и просто сохраняет их.
Командный интерпретатор bash удаляет фигурные скобки из слова при замене.
Например, слово, введенное в sh как file{1,2}, остается без изменений.
Это же слово заменяется парой слов file1 file2 после замены выражения в фигурных скобках в bash.
Если требуется полная совместимость с sh, командный интерпретатор bash надо запускать с опцией +B или отключать с помощью опции +B команды set (см. раздел "ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА" ниже).
}
{* Замена тильды// ~[[+|-][N]|reg-name]/ в словах и присваиваниях после = и :
Если слово НАЧИНАЕТСЯ незамаскированным символом тильда (~),
все символы до первой незамаскированной косой черты (или все символы, если незамаскированной косой черты в слове нет) считаются ТИЛЬДА-ПРЕФИКСОМ.
Если ни один из символов тильда-префикса не замаскирован, его символы после тильды рассматриваются как возможное РЕГИСТРАЦИОННОЕ ИМЯ.
Если это регистрационное имя представляет собой пустую строку, тильда заменяется значением переменной HOME.
Если переменная HOME не установлена, подставляется начальный каталог пользователя, выполняющего процесс командного интерпретатора.
Если же тильда-префикс не пустой, подставляется начальный каталог соответствующего пользователя.

Если тильда-префикс имеет вид ~+, вместо него подставляется значение переменной PWD.
Если тильда-префикс имеет вид ~-, вместо него подставляется значение переменной OLDPWD, если эта переменная установлена.
Если среди символов после тильды в тильда-префиксе имеется число N, с необязательными префиксами + или -,
тильда-префикс заменяется соответствующим элементом из стека каталогов, который был бы выдан встроенной командой dirs при вызове с тильда-префиксом в качестве аргумента.
Если символы после тильды содержат число без начального знака + или -, предполагается +.

Если соответствующего регистрационного имени не существует или замену тиильды выполнить не удалось, исходное слово остается без изменений.

Присваивания значений переменным проверяются на наличие незамаскированных тильда-префиксов сразу после : или =. В этих случаях также выполняется замена тильды.
Соответственно, можно использовать имена файлов с тильдами в присваиваниях переменным PATH, MAILPATH и CDPATH, и командный интерпретатор выполнит необходимые замены.
}
{* Подстановка значений параметров//... ${...}
Символ $ обозначает
	подстановку значений параметров,
	подстановку реультатов выполнения команд 
	или подстановку значений арифметических выражений.
Имя параметра МОЖНО брать в фигурные скобки, что позволяет отделить его от идущих непосредственно за ним символов, которые не являются частью имени.

При использовании фигурных скобок, завершающей считается первая скобка '}', не замаскированная обратной косой, не входящая 
	в строку в кавычках, 
	встроенное арифметическое выражение 
	или подставляемую команду, 
	или в подстановку значения другого параметра.

${параметр}
    Подставляется значение указанного параметра.
	Фигурные скобки необходимы, если параметр является позиционным и номер позиции состоит из нескольких цифр 
	или когда после параметра идет символ, не входящий в его имя. 

Если первый символ параметра - ВОСКЛИЦАТЕЛЬНЫЙ знак, начинается КОСВЕННАЯ подстановка.
Командный интерпретатор bash использует значение переменной, имя которой задается остальной частью параметра, в качестве имени переменной, значение которой необходимо подставить, а не собственно значения.
Это называется косвенной заменой.

В каждом из описанных ниже случаев в полученном слове выполняется 
	замена тильды, 
	подстановка значений параметров, 
	подстановка результатов выполнения команд 
	и вычисление арифметических выражений.
Если не выполняется подстановка подстрок, bash проверяет, не является ли параметр не установленным или не имеет ли он пустого значения; если не указать двоеточие, проверяется только, установлен ли параметр.

${параметр:-слово}
    Использовать стандартное значение.
	Если параметр не установлен или имеет пустое значение, подставляется значение указанного слова. 
	Иначе подставляется значение параметра. 
${параметр:=слово}
    Присвоить стандартное значение.
	Если параметр не установлен или имеет пустое значение, параметр получает значение указанного слова.
	Затем подставляется значение параметра. Присваивать таким образом значения позиционным и специальным параметрам нельзя. 
${параметр:?слово}
    Выдавать ошибку если параметр не установлен или имеет пустое значение. 
	Если параметр имеет пустое значение или не установлен, 
	указанное слово (или стандартное сообщение, если слово не задано) выдается в стандартный поток ошибок,
	и командный интерпретатор, если он не интерактивный, завершает работу.
	В противном случае, подставляется значение параметра. 
${параметр:+слово}
    Использовать альтернативное значение.
	Если параметр не установлен или имеет пустое значение, не подставляется ничего, в противном случае, подставляется указанное слово. 
${параметр:m}
${параметр:m:n}
    Подстановка подстрок.
	Подставляет символы значения параметра, начиная с указанного смещения m и вплоть до заданной длины n. Если длина не указана, подставляет символы с указанного смещения и до конца. В качестве длины и смещения можно задавать арифметические выражения (см. раздел "ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ" ниже). Длина должна быть неотрицательным числом. Если смещение - отрицательное число, оно отсчитывается с конца значения параметра. Если параметр - @, результат - n позиционных параметров, начиная с параметра m. Если параметр - массив с индексом @ или *, результат - n элементов массива, начиная с ${параметр[m]}. Индексация подстрок начинается с нуля, за исключением позиционных параметров, которые индексируются, начиная с 1. 
${#параметр}
    Подставляется длина значения параметра в символах.
	Если параметр - * или @, подставляется количество позиционных параметров. Если параметр - массив с индексом * или @, подставляется количество элементов массива. 
${параметр#слово}
${параметр##слово}
    Слово рассматривается как шаблон, аналогичный шаблону имен файлов.
	Если шаблон сопоставляется с началом значения параметра, то результатом будет значение параметра, из которого удалена самая короткая (в случае #) или самая длинная (в случае ##) подстрока. Если параметр - @ или *, операция удаления шаблона применяется поочередно к каждому позиционному параметру и подставляется полученный в результате список. Если параметр - массив с индексом @ или *, операция удаления шаблона применяется поочередно к каждому элементу массива и подставляется полученный в результате список. 
${параметр%слово}
${параметр%%слово}
    Слово рассматривается как шаблон, аналогичный шаблону имен файлов.
	Если шаблон сопоставляется с конечной частью значения параметра, то результатом будет значение параметра, из которого удалена самая короткая (в случае %) или самая длинная (в случае %%) подстрока. Если параметр - @ или *, операция удаления шаблона применяется поочередно к каждому позиционному параметру и подставляется полученный в результате список. Если параметр - массив с индексом @ или *, операция удаления шаблона применяется поочередно к каждому элементу массива и подставляется полученный в результате список. 
${параметр/шаблон/строка}
'${параметр//шаблон/строка}'
    Шаблон задается аналогично шаблонам имен файлов.
	Самая длинная подстрока значения параметра, соответствующая шаблону, заменяется указанной строкой. В первом случае, заменяется только первое вхождение. Во втором случае, заменяются все вхождения шаблона. Если шаблон начинается с #, он должен сопоставляться начиная с начала значения параметра. Если же шаблон начинается с %, он должен сопоставляться с окончанием значения параметра. Если строка - пустая, соответсвующие шаблону подстроки удаляются и / после шаблона можно не указывать. Если параметр - @ или *, операция замены шаблона применяется поочередно к каждому позиционному параметру, и подставляется полученный в результате список. Если параметр - массив с индексом @ или *, операция замены шаблона применяется поочередно к каждому элементу массива и подставляется полученный в результате список. 
}
{* Подстановка результатов выполнения команд//$(com) $(<file) `com`
Подстановка результатов выполнения команд позволяет результат, выдаваемый командой в стандартный выходной поток, подставить вместо имени команды. Имеется две формы такой подстановки:

    $(команда) 

или

    `команда` 

Командный интерпретатор bash делает эту подстановку путем выполнения команды и замены конструкции подстановки содержимым стандартного выходного потока команды, из которого удалены завершающие переводы строк. Встроенные переводы строк не удаляются, но они могут быть удалены при разбиении на слова. Подстановку результатов выполнения команды $(cat file) можно заменить эквивалентной, но более быстрой: $(< file).

При использовании старой формы подстановки в обратных апострофах обратная косая интерпретируется как литерал, если только после нее не идут символы $, ` или \. Первый же обратный апостроф, не замаскированный обратной косой, завершает подставляемую команду. При использовании формы $(команда) все символы между круглыми скобками образуют команду - ни один не имеет специального значения.

Подстановка результатов выполнения команд может быть вложенной.
Для задания вложенной подстановки в форме с обратными апострофами замаскируйте внутренние обратные апострофы обратными косыми.

Если подстановка задана в двойных кавычках, разбиение на слова и подстановка имен файлов в результатах не выполняется.
}
{* Подстановка значений арифметических выражений//$((выражение)) 
При вычислении арифметических выражений вместо выражения подставляется результат его вычисления.
Для вычисления арифметических выражений используется следующий формат:

    $((выражение)) 

Выражение обрабатывается так, как если бы оно было взято в двойные кавычки, но двойные кавычки в самом выражении не имеют специального значения. 
Во всех лексемах выражения выполняется подстановка значений параметров, подстановка строк, подстановка результатов выполнения команд и удаление кавычек. 
Вычисления арифметических выражений могут быть вложенными.

Вычисление выполняется по правилам, перечисленным ниже в разделе "ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ".
Если выражение недопустимо, командный интерпретатор bash выдает сообщение о невозможности вычисления и подстановка не выполняется.
}
{* 	Подстановка процессов//<(список) или >(список)
Подстановка процессов доступна в системах, поддерживающих именованные каналы (FIFO) или метод именования открытых файлов через /dev/fd.
Она имеет вид <(список) или >(список).
Процесс список запускается и его входной или выходной поток связывается с именованным каналом FIFO или одним из файлов в /dev/fd.
Имя этого файла передается в качестве аргумента текущей команде как результат подстановки.
Если использована форма >(список), запись в файл будет давать входные данные процессу список.
Если же использована форма <(список), файл, переданный в качестве аргумента, необходимо читать для получения результатов работы процесса список.

Если подстановка процессов поддерживается, она выполняется одновременно с подстановкой значений параметров, подстановкой результатов выполнения команд и вычислением арифметических выражений.
}
{* Разбиение на слова//IFS
Командный интерпретатор обрабатывает 
	результаты подстановки значений параметров, 
	результатов выполнения команд 
	и арифметических вычислений, 
не взятых в двойные кавычки, разбивая их на слова.

Командный интерпретатор рассматривает каждый символ значения переменной IFS как разделитель и разбивает результаты подстановок на слова по этим символам.
Если переменная IFS не установлена или ее значение - <пробел><табуляция><перевод строки>, т.е. стандартное, то любая последовательность подряд идущих символов из IFS считается разделителем слов.
Если же переменная IFS имеет значение, отличающееся от стандартного, то последовательность пробельных символов (пробелов и символов табуляции) в начале и в конце слова игнорируется, если пробельные символы входят в значение IFS (их обобщенно называют пробельным символом IFS).
Любые символы в значении IFS, не являющиеся пробельными, вместе с любыми идущими за ними пробельными символами IFS, ограничивают слово.
Последовательность пробельных символов IFS также считается разделителем.
Если переменная IFS имеет пустое значение, разбиение на слова не происходит.

Явные пустые строки ("" или '') оставляются.
Не взятые в кавычки неявные пустые строки, получающиеся в результате подстановки параметров, не имеющих значения, удаляются.
Если параметр, не имеющий значения, подставляется в двойных кавычках, получается пустая строка, и она остается в командной строке.

Учтите, что если не было подстановок, то и разбиение на слова не выполняется.
}
{* Подстановка имен файлов ,,,
После разбиения на слова, если только не установлена опция -f,
командный интерпретатор bash просматривает каждое слово в поисках символов *, ?, ( и [.
Если найден любой из этих символов, слово считается шаблоном и заменяется упорядоченным по алфавиту списком имен файлов, соответствующих шаблону.
Если соответствующие имена файлов не найдены и опция командного интерпретатора nullglob отключена, слово остается без изменений.
Если опция nullglob установлена и соответствующие файлы не найдены, слово удаляется.
Если включена опция командного интерпретатора nocaseglob, сопоставление выполняется без учета регистра алфавитных символов.
Если шаблон используется для подстановки имен файлов, символ "." в начале имени или сразу после косой черты должен сопоставляться явно, если только не установлена опция интерпретатора dotglob.
При сопоставлении имен файлов косые черты всегда должны сопоставляться явно. В других случаях символ "." обрабатывается как любые другие символы.
См. описание опций командного интерпретатора nocaseglob, nullglob и dotglob ниже в разделе "ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА".

Переменная командного интерпретатора GLOBIGNORE может использоваться для ограничения множества имен файлов, соответствующих шаблону. Если переменная GLOBIGNORE установлена, каждое сопоставившееся имя файла, соответствующее также одному из шаблонов, заданных в GLOBIGNORE, удаляется из списка сопоставившихся. Имена файлов "." и ".." игнорируются всегда, даже если установлена переменная GLOBIGNORE. Однако при установке переменной GLOBIGNORE автоматически устанавливается опция интерпретатора dotglob, так что все остальные имена файлов, начинающиеся с ".", будут подставлены. Для получения старого поведения - игнорирования имен файлов, начинающихся с ".", - задайте ".*" как один из шаблонов в переменной GLOBIGNORE. Опция dotglob отключается, если переменная GLOBIGNORE не установлена.
}
* 	Сопоставление с образцом
* 	Удаление кавычек
}
======= 3 =====================================================
*{ Перенаправление
{Перед выполнением команды
 ее входной и выходной потоки могут быть перенаправлены
 с помощью специальных конструкций, обрабатываемых командным интерпретатором.
Перенаправления также можно использовать для открытия и закрытия файлов в текущей среде работы командного интерпретатора.
Следующие операторы перенаправления могут ПРЕДШЕСТВОВАТЬ простой команде или указываться В ЛЮБОМ ЕЕ МЕСТЕ, или указываться ПОСЛЕ команды.
Перенаправления обрабатываются в порядке их указания, слева направо.

В следующих описаниях если номер дескриптора файла не указан и первый символ оператора перенаправления - <, выполняется перенаправление стандартного входного потока (дескриптор файла 0).
Если же первым символом оператора перенаправления является символ >, выполняется перенаправление стандартного выходного потока (дескриптор файла 1).

В слове, идущем за оператором перенаправления в следующих описаниях, если не сказано иначе, выполняется 
	подстановка фигурных скобок, 
	замена тильды, 
	подстановка значений параметров, 
	подстановка результатов выполнения команд, 
	вычисление арифметических выражений,
	удаление кавычек 
	и подстановка имен файлов.
Если в результате получается более одного слова, командный интерпретатор bash выдает сообщение об ошибке.

Учтите, что порядок указания перенаправлений имеет значение. Например, команда
    ls > dirlist 2>&1 
перенаправляет в файл dirlist стандартный выходной поток и стандартный поток ошибок, тогда как команда
    ls 2>&1 > dirlist 
перенаправляет в файл dirlist только стандартный выходной поток, поскольку стандартный поток ошибок был направлен туде же, куда и стандартный выходной поток до его перенаправления в файл dirlist.

Ошибка при открытии или создании файла приводит к отмене перенаправления.
}

{* Перенаправление входного потока//[n]<слово 
Перенаправление входного потока приводит к открытию на чтение файла,
	имя которого получается в результате подстановок в слове,
через дескриптор файла n, или как стандартного входного потока (дескриптор файла 0), если n не указано.

В общем случае перенаправление входного потока имеет вид:

    [n]<слово 
}
{* Перенаправление выходного потока//[n]>слово , [n]>|слово + set noclobber
Перенаправление вЫходного потока приводит к открытию на запись файла,
	имя которого получается в результате подстановок в слове,
через дескриптор файла n, или как стандартного выходного потока (дескриптор файла 1), если n не указано.
Если файл не существует, он создается; если существует - он усекается до нулевого размера.

В общем случае перенаправление выходного потока имеет вид:

    [n]>слово 

Если используется оператор перенаправления > и с помощью встроенной команды set установлена опция noclobber, перенаправление не будет выполнено, если файл с соответствующим именем существует и является обычным файлом.
Если используется оператор перенаправления >|, либо оператор перенаправления - > и опция noclobber с помощью встроенной команды set не установлена, перенаправление выполняется, даже если соответствующий файл существует.
}
{* Добавление перенаправленного вывода//[n]>>слово 
Такое перенаправление вывода приводит к открытию файла,
	имя которого получается в результате подстановок в слове,
в режиме добавления через дескриптор файла n, или к добавлению в стандартный выходной поток (дескриптор файла 1) если n не указано. Если файл не существует, он создается.

Перенаправление вывода на добавление имеет следующий общий вид:

    [n]>>слово 
}
{* Перенаправление стандартного выходного потока и стандартного потока ошибок//&>слово = >&слово = >слово 2>&1 
Командный интерпретатор bash позволяет перенаправить как стандартный выходной поток (дескриптор файла 1), так и стандартный поток ошибок (дескриптор файла 2) в файл, имя которого получается в результате подстановок в слове.

Для этого предлагается два формата конструкции перенаправления:

    &>слово 

и

    >&слово 

Первый формат является предпочтительным. Эта конструкция семантически эквивалентна следующей:

    >слово 2>&1 
}
{* Конструкция "документ здесь"//<<[-]слово  документ-здесь  ограничитель
При этом типе перенаправления командный интерпретатор будет читать входные данные из текущего файла, пока не встретится строка, содержащая только указанное слово (без хвостовых пробелов).
Все прочитанные до этого строки затем используются как стандартный входной поток для команды.

Конструкция "документ здесь" имеет следующий формат:

    <<[-]слово
            документ-здесь
    ограничитель

В слове не выполняется подстановка 
	значений параметров, 
	результатов выполнения команд, 
	имен файлов 
	или вычисление арифметических выражений.
Если в слове есть замаскированный символ, ограничитель является результатом удаления символов маскировки из слова.
Если в слове нет замаскированных символов, во всех строках "документа здесь" выполняется подстановка 
	значений параметров, 
	результатов выполнения команд 
	и вычисление арифметических выражений.
В этом случае пара \<перевод строки> игнорируется, и необходимо использовать \ для маскировки символов \, $ и `.

Если в качестве оператора перенаправления используется <<-, то все начальные табуляции из входных строк и строки, содержащей ограничитель, удаляются.
Это позволяет естственным образом выравнивать конструкции "документ здесь" в сценариях командного интерпретатора.
}
{* Дублирование дескрипторов файлов//[n]<&слово , [n]>&слово 
Оператор перенаправления

    [n]<&слово 

используется для дублирования дескрипторов входных файлов.
Если в результате подстановок слово представляет собой одну или несколько цифр,
дескриптор файла n становится копией соответствующего дескриптора файла.
Если файл с дескриптором, задаваемым цифрами слова, не открыт на чтение, возникает ошибка перенаправления.
Если после подстановок в слове получается -, файл с дескриптором n закрывается.
Если n не указано, используется стандартный входной поток (дескриптор файла 0).

Оператор

    [n]>&слово 

используется аналогично для дублирования дескрипторов выходных файлов.
Если n не указано, используется стандартный выходной поток (дескриптор файла 1).
Если цифры в слове не задают дескриптор файла, открытого на запись, возникает ошибка перенаправления.
В качестве специального случая, если n не указано и слово после подстановок не представляет собой одну или несколько цифр, стандартный выходной поток и стандартный поток ошибок перенаправляются так, как было описано выше.
}
{* Открытие дескрипторов файлов для чтения и записи//,,, //[n]<>слово 
Оператор перенаправления

    [n]<>слово 

вызывает открытие файла,
	имя которого получается в результате подстановок в слове,
для чтения и записи через дескриптор файла n или через дескриптор файла 0, если n не указано.
Если файл не существует, он создается.
}
}
* Псевдонимы
* Функции //[ function ] имя () { список; }
* Вычисление арифметических выражений //((выражение))
* Условные выражения	//[[ выражение ]]
===============================================================
===============================================================
===============================================================
* Обработка простой команды
* Выполнение команды
* Среда выполнения команд
* Среда
* Статус выхода
* Сигналы
* Управление заданиями
===============================================================
* Приглашения
*{ Библиотека READLINE
* Соглашения по записи команд readline
* Инициализация библиотеки readline
* Горячие клавиши readline
* Переменные readline
* Управляющие конструкции readline
* Поиск
* Имена команд readline
* Команды для перемещения
* Команды для работы со списком истории
* Команды для изменения текста
* Удаление и вставка
* Числовые аргументы
* Завершение
* Клавиатурные макросы
* Прочие команды
}
======= 4 =====================================================
* История выполнения команд
*{ Подстановка команд из списка истории
* Пометки событий
* Пометки слов
* Модификаторы
}
*{ Встроенные команды интерпретатора
Если явно не указано иначе, каждая из описанных в этом разделе встроенных команд, принимающих опции, начинающиеся с дефиса (-),
распознает два дефиса (--) как признак завершения опций.
* {: [аргументы]//do nothing
Никакого эффекта; команда не делает ничего, кроме подстановки аргументов
и выполнения указанных перенаправлений.
Возвращает нулевой код возврата.
}
* {[.|source] имя_файла [аргументы]//выполняет файл в текущем командном интерпретаторе, с соотв позиционными параметрами, если уеазаны
	. имя_файла [аргументы]
	source имя_файла [аргументы]
Читает и выполняет команды из указанного файла в среде текущего командного интерпретатора и возвращает статус выхода последней выполненной команды из файла.
Если имя_файла не содержит косой черты, файл ищется в каталогах, перечисленных в переменной PATH.
Искомый файл не обязательно должен быть выполняемым.
Если ни в одном из каталогов, перечисленных в PATH, файл с указанным именем не найден, он ищется в текущем каталоге.
Если отключена опция sourcepath встроенной команды shopt, перечисленные в PATH каталоги не просматриваются.
Если переданы аргументы, они становятся позиционными параметрами при выполнении файла.
Иначе значения позиционных параметров не изменяются.
Статусом выхода становится статус последней выполненной в сценарии команды
(статус выхода равен 0, если ни одна команда не выполнялась),
или 1, если файл не найден или не может быть прочитан. 
}
* break [n]
* continue [n]
* return [n]
* {alias [-p] [имя[=значение] ...]	//псевдонимы ,,,
Команда alias без аргументов или с опцией -p выдает список псевдонимов команд в виде alias имя=значение в стандартный выходной поток.
Если переданы аргументы, каждое имя, для которого задано значение, становится псевдонимом.
Если значение завершается пробелом, в следующем слове при подстановке будет выполняться замена псевдонима.
Для каждого имени в списке аргументов без соответствующего значения выдается имя и значение соответствующего псевдонима.
Команда alias возвращает истину, если только не задано имя, не являющееся именем псевдонима. 
}
* {bg [задание]	//задание в фоновый режим
Возобновляет выполнение указанного задания в фоновом режиме, как если бы оно было запущено с конструкцией &.
Если задание не указано, в фоновый режим переводится текущее задание командного интерпретатора.
Команда bg задание возвращает 0, если только управление заданиями не отключено или, при включенном управлении заданиями, соответствующее задание не найдено или запускалось при отключенном управлении заданиями.
}
* bind [-m keymap] [-lpsvPSV] //keybindings of readline
* builtin встроенная_команда [аргументы]
* cd [-LP] [каталог]
* command [-pVv] команда [аргумент ...]
* declare [-afFirx] [-p] [имя[=значение]]
* typeset [-afFirx] [-p] [имя[=значение]]
* dirs [-clpv] [+n] [-n]
* disown [-ar] [-h] [задание ...]
* echo [-neE] [аргумент ...]
* enable [-adnps] [-f имя_файла] [имя ...]
* eval [аргумент ...]
* exec [-cl] [-a имя] [команда [аргументы]]
* exit [n]
* export [-fn] [имя[=слово]] ...
* fc [-e редактор] [-nlr] [первая] [последняя]
* fg [задание]
* getopts строка_опций имя [аргументы]
* hash [-r] [-p имя_файла] [имя]
* help [шаблон]
* let аргумент [аргумент ...]
* local [имя[=значение] ...]
* logout
* popd [-n] [+n] [-n]
* printf формат [аргументы]
* pwd [-LP]
* read [-er] [-a имя_массива] [-p приглашение] [имя ...]
* readonly [-apf] [имя ...]
*{ set [--abefhkmnptuvxBCHP] [-o опция] [аргумент ...]
* set -a
* set -b
* set -e
* set -f
* set -h
* set -k
* set -m
* set -n
*{ set -o имя_опции
* set -o allexport
* set -o braceexpand
* set -o emacs
* set -o errexit
* set -o hashall
* set -o histexpand
* set -o history
* set -o ignoreeof
* set -o keyword
* set -o monitor
* set -o noclobber
* set -o noexec
* set -o noglob
* set -o notify
* set -o nounset
* set -o onecmd
* set -o physical
* set -o posix
* set -o privileged
* set -o verbose
* set -o vi
* set -o xtrace
}
* set -p
* set -t
* set -u
* set -v
* set -x
* set -B
* set -C
* set -H
* set -P
* set --
* set -
}
* shift [n]
*{ shopt [-pqsu] [-o] [имя_опции ...]
* cdable_vars
* cdspell
* checkhash
* checkwinsize
* cmdhist
* dotglob
* execfail
* expand_aliases
* extglob
* histappend
* histreedit
* histverify
* hostcomplete
* huponexit
* interactive_comments
* lithist
* mailwarn
* nocaseglob
* nullglob
* promptvars
* restricted_shell
* shift_verbose
* sourcepath
}
* suspend [-f]
* test выражение
* times
* trap [-lp] [аргумент] [сигнал ...]
* type [-atp] имя [имя ...]
* ulimit [-SHacdflmnpstuv [ограничение]]
* umask [-p] [-S] [маска]
* unalias [-a] [имя ...]
* unset [-fv] [имя ...]
* wait [n]
}
===============================================================
======= 5 =====================================================
===============================================================
* Ограниченный командный интерпретатор
* Ссылки
* Файлы
* Авторы
* Информацияобошибках
* Ошибки
* Примечания
