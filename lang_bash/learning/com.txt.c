{== референс (процедуры, циклы, ветвления, переменные, и прочие фишки, связанные с интерпретатором команд) ==
Если явно не указано иначе, каждая из описанных в этом<ba> разделе встроенных команд, принимающих опции, начинающиеся с дефиса (-), 
распознает два дефиса (--) как признак завершения опций.
{=== быстрые клавишы ===
ctrl+c прерывание, отменить последнюю введенную команду
ctrl+\ прерывание с дампом
ctrl+d конец файла, выйти из терминала
ctrl+s стоп режим. Блокирует вывод на консоль. При этом все данные отображенные на экране остаются не измененными.
ctrl+q выход из стоп-режима.

ctrl+u удалить все символы от курсора до начала строки
ctrl+k удалить все символы от курсора до конца строки
ctrl+y вставляет последнюю удаленную с помощью ctrl+u или ctrl+k строку
ctrl+w удалить слово перед курсором
ctrl+b переместить курсор на один символ влево
ctrl+f переместить курсор на один символ вправо
ctrl+t поменять местами символ слева от курсора и под курсором
ctrl+h удалить символ слева от курсора
ctrl+a переместить курсор в начало строки
ctrl+e переместить курсор в конец строки

ctrl+p предыдущая команда в истории bash
ctrl+n следующая команда в истории bash
ctrl+r реверсивный поиск команд в истории bash
Tab+Tab выводит список команд. При наличии какого нибудь символа(-ов) выводит команды по введенным символам.
    Примечание:ввод осуществляется как и в режиме ввода. Будьте осторожны.

ctrl+m выполнение команды, аналог [Enter]
ctrl+o выполняет команду, при этом оставляя ее в командной строке для дальнейшего использования.
ctrl+l очистить экран, аналог команды clear.

ctrl+x,ctrl+v показать версию bash 

ctrl+z -- ???????
}
• sh<fhs/bin>	shell
 reset			/*bsd?*/перезапускает терминал и очищает экран
{:<ba>			Никакого эффекта; команда не делает ничего, кроме подстановки аргументов и выполнения указанных перенаправлений.
	: [аргументы]
Возвращает нулевой код возврата.
}
{=== управление потоком действий ===
{break<ba>		Выход из цикла for, while, until или select.
	break [n]
Если значение n указано, выход из n уровней циклов. n должно быть больше 1.
Если значение n превышает количество вложенных циклов, происходит выход из всех циклов.
Команда возвращает значение 0, если только не выполнена вне цикла.
}
{continue<ba>	Перейти к следующей итерации цикла for, while, until или select.
	continue [n]
Если указано значение n, перейти к следующей итерации n-го внешнего цикла.
Значение n должно быть больше 1.
Если n превышает количество имеющихся внешних циклов, выполняется следующая итерация самого внешнего цикла (цикла "верхнего уровня").
Возвращается значение 0, если только команда не вызвана вне цикла
}
{return<ba>		Вызывает завершение работы функции с указанным статусом выхода n.
	return [n]
Если n не указано, возвращается статус выхода последней команды, выполненной в теле функции.
При использовании вне функции, но в ходе выполнения сценария командой . (source),
вызывает прекращение выполнения сценария и возврат либо значения n, либо статуса выхода последней команды сценария.
При использовании вне функции и не при выполнении сценария командой ., возвращает 1.
}
{exit<ba>		Вызывает завершение работы командного интерпретатора со статусом n.
	exit [n]
Если значение n не указано, статусом выхода будет статус выхода последней выполненной команды.
Перед заврешением работы интерпретатора срабатыват обработчик сигнала EXIT.
}
logout<ba>		Выход из начального командного интерпретатора.
}
{=== разбор аргументов ===
{shift<ba>	Позиционные параметры n+1 ... переименовываются в $1 .... Параметры от $#-n+1 до $# сбрасываются.
	shift [n]
n должно быть неотрицательным целым числом, не превышающим $#.
Если n равно 0, параметры не изменяются.
Если n не указано, предполагается значение 1.
Если n больше $#, поизиционные параметры не изменяются.
Статус выхода - больше нуля, если n больше $# или отрицательное и 0 в противном случае.
}
{• getopts<ba>	используется процедурами командного интерпретатора для разбора позиционных параметров.
	getopts строка_опций имя [аргументы]
Строка_опций содержит буквы опций, которые необходимо распознать;
если после буквы указано двоеточие, предполагается, что у опции должен быть аргумент, отделяемый от нее пробельным символом.
При каждом вызове команда getopts помещает в переменную интерпретатора с указанным именем очередную опцию,
создавая переменную, если она еще не существует, а индекс следующего аргмента - в переменную OPTIND.
OPTIND получает значение 1 при каждом вызове командного интерпретатора или сценария.
Если опция должна иметь аргумент, команда getopts помещает этот аргумент в переменную OPTARG.
Командный интерпретатор не сбрасывает значение OPTIND автоматически.
Между вызовами команды getopts в том же командном интерпретаторе,
если необходимо использовать новый набор параметров, надо сбрасывать это значение явно.

Когда все опции обработаны, команда getopts завершает работу со значением, большим нуля.
OPTIND при этом содержит индекс первого аргумента, не являющегося опцией, а переменная имя получает значение ?.

Команда getopts обычно обрабатывает позиционные параметры, но если заданы аргументы, getopts разбирает их.

Команда getopts может сообщать об ошибках двумя способами.
Если первый символ строки_опций - двоеточие, используется немногословное информирование об ошибках.
При обычной работе выдаются диагностические сообщения, если обнаруживаются недопустимые опции или недостающие аргументы.
Если переменная OPTERR имеет значение 0, сообщения об ошибках не выдаются, даже если первым символом строки_опций не является двоеточие.

Если обнаружена недопустимая опция, getopts помещает ? в переменную имя и,
если не задано немногословное информирование, выдает сообщение об ошибке и сбрасывает переменную OPTARG.
Если getopts работает в режиме немногословного информирования, символ опции помещается в переменную OPTARG
и никакие диагностические сообщения не выдаются.

Если обязательный аргумент не обнаружен, и для getopts не задано немногословное информирование,
переменная имя получает значение ?, переменная OPTARG сбрасывается, и выдается диагностическое сообщение.
Если getopts работает в режиме немногословного информирования, переменная имя получает значение :,
а в переменную OPTARG помещается символ опции.

Команда getopts возвращает 0, если опция, указанная или не указанная, обнаружена. 
Она возвращает ложь, если достигнут конец опций или произошла ошибка.
}
• xargs<fu>		для формирования списка аргументов и выполнение команды 
}
{=== переменные ===
{shopt<ba>	Переключает значения переменных, управляющих не обязательным поведением командного интерпретатора.
	shopt [-pqsu] [-o] [имя_опции ...]
Если опции не указаны или задана опция -p, выдается список всех возможных опций,
с указанием, установлена опция или нет.
Опция -p вызывает выдачу результатов в формате, позволяющем использовать их в качестве входных команд.
Остальные опции имеют следующие значения:
-s	Включает (устанавливает) все указанные опции.
-u	Отключает (сбрасывает) все указанные опции.
-q	Подавляет выдачу стандартной информации (немногословный режим);
	статус выхода показывает, установлена опция или нет.
	Если после -q указано несколько имен_опций, статус выхода - 0,
	если все указанные опции включены и не 0 в противном случае.
-o	Ограничивает значения имен_опций только поддерживаемыми в опции -o встроенной команды set.

Если опция -s или -u использована без аргументов, выдается информация только об установленных или неустановленных опциях, соответственно.
Если не указано иначе, опции команды shopt по умолчанию отключены (сброшены).

Статус выхода при выдаче опций - 0, если все указанные опции включены и не 0 в противном случае.
При установке или сбросе опций статус выхода - 0, если только не указана недопустимая опция командного интерпретатора.

Вот список допустимых опций команды shopt:

cdable_vars
    Если эта опция установлена и переданный встроенной команде cd аргумент не является именем каталога,
	то предполагается, что это - имя переменной, значение которой - каталог для перехода.

cdspell
    Если эта опция установлена, небольшие ошибки в написании имен каталогов для команды cd будут исправляться.
	Речь идет о переставленных местами символах, пропущенном символе и одном лишнем символе.
	Если при исправлении найден подходящий вариант, выдается исправленное имя каталога и команда выполняется.
	Эта опция используется только интерактивными командными интерпретаторами.

checkhash
    Если эта опция установлена, bash проверяет, что найденная в хэше команда существует,
	прежде чем пытаться ее выполнить.
	Если находящаяся в хэше команда больше не существует, выполняется обычный поиск по каталогам.

checkwinsize
    Если эта опция установлена, bash проверяет размер окна после выполнения каждой команды и,
	при необходимости, обновляет значения переменных LINES и COLUMNS.

cmdhist
    Если эта опция установлена, bash пытается сохранить все строки многострочной команды в одной записи списка истории.
	Это позволяет легко редактировать многострочные команды.

dotglob
    Если эта опция установлена, bash включает в результаты подстановки имен файлов имена, начинающиеся с точки (.).

execfail
    Если эта опция установлена, не интерактивный командный интерпретатор не будет завершать работу,
	если не сможет выполнить файл, указанный в качестве аргумента для встроенной команды exec.
	Интерактивный командный интерпретатор не завершает работу, если команда exec не срабатывает.

expand_aliases
    Если эта опция установлена, псевдонимы заменяются так, как было описано ранее в разделе "ПСЕВДОНИМЫ".
	Эта опция включена по умолчанию в интерактивных командных интерпретаторах.

extglob
    Если эта опция установлена, поддерживаются расширенные возможности сопоставления с образцом,
	описанные ранее в разделе "Подстановка имен файлов".

histappend
    Если эта опция установлена, список истории добавляется в файл, имя которого является значением пременной HISTFILE,
	при завершении работы командного интерпретатора, а не переписывает файл.

histreedit
    Если эта опция установлена и используется библиотека readline,
	пользователь получает возможность повторно редактировать команду при невозможности подстановки из списка истории.

histverify
    Если эта опция установлена и используется библиотека readline,
	результаты подстановки из списка истории не передаются анализатору командного интерпретатора немедленно.
	Вместо этого, полученная в результате строка загружается в буфер редактирования readline для дальнейших изменений.

hostcomplete
    Если эта опция установлена и используется библиотека readline,
	bash будет пытаться выполнить подстановку имен хостов после завершения слова, содержащего символ @,
	(см. подраздел "Завершение" в разделе "БИБЛИОТЕКА READLINE" ранее). Эта опция включена по умолчанию.

huponexit
    Если эта опция установлена, bash будет посылать сигнал SIGHUP всем заданиям
	при завершении работы интерактивного начального командного интерпретатора.

interactive_comments
    Если эта опция установлена, слово, начинающееся символом #, и все остальные символы в этой строке
	игнорируются интерактивным команжным интерпретатором (см. раздел "КОММЕНТАРИИ" ранее).
	Эта опция включена по умолчанию.

lithist
    Если эта опция установлена, и установлена опция cmdhist, многострочные команды, по возможности,
	сохраняются в списке истории со встроенными символами новой строки вместо точек с запятыми.

mailwarn
    Если эта опция установлена и файл, проверяемый командным интерпретатором bash как почтовый ящик,
	читался с момента последней проверки, выдается сообщение "The mail in имя_файла has been read".

nocaseglob
    Если эта опция установлена, bash при подстановке имен файлов выполняет сопоставление с образцом
	без учета регистра символов (см. раздел "Подстановка имен файлов" ранее).

nullglob
    Если эта опция установлена, bash подставляет пустую строку вместо шаблонов,
	которым не соответствует ни один файл (см. раздел "Подстановка имен файлов" ранее), а не сам шаблон.

promptvars
    Если эта опция установлена, в строках приглашения выполняется подстановка значений переменных и параметров
	после стандартных подстановок, описанных в разделе "ПРИГЛАШЕНИЯ" ранее. Эта опция установлена по умолчанию.

restricted_shell
    Командный интерпретатор устанавливает эту опцию, если он запущен в ограниченном режиме (см. раздел " ОГРАНИЧЕННЫЙ КОМАНДНЫЙ ИНТЕРПРЕТАТОР" ниже).
	Значение этой опции изменять нельзя.
	Она не сбрасывается при выполнении файлов начального запуска, что позволяет в этих файлах учесть,
	является ли командный интерпретатор ограниченным.

shift_verbose
    Если эта опция установлена, встроенная команда shift выдает сообщение об ошибке,
	когда параметр сдвига превышает количество позиционных параметров.

sourcepath
    Если эта опция установлена, встроенная команда source (.) использует значение переменной PATH для поиска каталога,
	содержащего файл, переданный в качестве аргумента. Эта опция по умолчанию включена.
}
{set<ba>	При вызове без опций выдает имя и значение всех переменных командного интерпретатора
	set [--abefhkmnptuvxBCHP] [-o опция] [аргумент ...]
 в виде, пригодном для повторного выполнения присваиваний.
	Результат отсортирован по именам в соответствии с текущей локалью.
	Если опции указаны, они устанавливают или сбрасывают атрибуты командного интерпретатора.
Все оставшиеся после обработки опций аргументы присваиваются последовательно в качестве значений позиционным параметрам $1, $2,... $n.
Опции имеют следующие значения:
-o имя_опции
	Имя_опции может иметь одно из следующих значений:
	emacs		Использовать интерфейс редактирования командной строки в стиле редактора emacs.
				Эта опция установлена по умолчанию в интерактивных командных интерпретаторах,
				если только они не запущены с опцией --noediting
	history		Включить поддержку истории выполнения команд, как описано ранее в разделе "ИСТОРИЯ ВЫПОЛНЕНИЯ КОМАНД".
				Эта опция установлена по умолчанию для интерактивных командных интерпретаторов.
	ignoreeof	Результат такой же, как и после выполнения команды IGNOREEOF=10 (см. раздел "Переменные командного интерпретатора" ранее)
	posix		Изменяет поведение bash на соответствующее стандарту POSIX 1003.2, там, где оно отличается
	vi			Использовать интерфейс редактирования командной строки в стиле редактора vi.
	allexport	То же, что и опция -a
	braceexpand	То же, что и опция -B
	errexit		То же, что и опция -e
	hashall		То же, что и опция -h
	histexpand	То же, что и опция -H
	keyword		То же, что и опция -k
	monitor		То же, что и опция -m
	noclobber	То же, что и опция -C
	noexec		То же, что и опция -n
	noglob		То же, что и опция -f
	notify		То же, что и опция -b
	nounset		То же, что и опция -u
	onecmd		То же, что и опция -t
	physical	То же, что и опция -P
	privileged	То же, что и опция -p
	verbose		То же, что и опция -v
	xtrace		То же, что и опция -x.
	Если указана опция -o без имени_опции, выдаются значения текущих установленных опций.
	Если указана опция +o без имени_опции, в стандартный выходной поток выдается набор команд set,
	необходимый для воссоздания текущего набора опций.
-a	Автоматически помечать изменяемые или создаваемые переменные как экспортируемые в среду для последующих команд.
-b	Сообщать о состоянии прерванных фоновых заданий немедленно, а не перед выдачей следующего первичного приглашения.
	Эта опция действует только если включено управление заданиями.
-e	Немедленно завершать работу, если простая команда (см. раздел "СИНТАКСИС КОМАНД" ранее) завершает работу с ненулевым статусом выхода.
	Работа командного интерпретатора не завершается,
	если закончившаяся неудачно команда является частью цикла until или while,
	частью оператора if, частью списка && или ||, или
	если к статусу выхода команды применяется отрицание с помощью оператора !.
-f	Отключить подстановку имен файлов.
-h	Запоминать местонахождение команд, найденное при выполнении. Эта опция включена по умолчанию.
-k	Помещать в среду все аргументы в виде операторов присваивания, а не только предшествующие имени команды.
-m	Режим мониторинга. Управление заданиями включено.
	Эта опция стандартно устанавливается для интерактивных командных интерпретаторов в системах,
	где управление заданиями поддерживается (см. раздел "УПРАВЛЕНИЕ ЗАДАНИЯМИ" ранее).
	Фоновые процессы работают в отдельной группе процессов,
	и строка, содержащая их статус выхода, выдается при завершении их работы.
-n	Читать команды, но не выполнять их.
	Эту опцию можно использовать для проверки наличия синтаксических ошибок в сценариях командного интерпретатора.
	Интерактивные командные интерпретаторы ее игнорируют.
-p	Включить привилегированный режим.
	В этом режиме файлы $ENV и $BASH_ENV не обрабатываются,
	функции командного интерпертатора не наследуются из среды, а переменная среды SHELLOPTS игнорируется.
	Если командный интерпретатор запущен с эффективным идентификатором пользователя (группы),
	не совпадающим с реальным, а опция -p не задана,
	выполняются перечилсенные действия и эффективный идентификатор устанавливается равным реальному.
	Если опция -p задана при запуске, эффективный идентификатор не сбрасывается.
	Отключение данной опции приводит к установке эффективных идентификаторов пользователя и группы равными реальным.
-t	Завершить после чтения и выполнения одной команды.
-u	При подстановке значений параметров рассматривать не установленную переменную как ошибку.
	При попытке подстановки значения не существующей переменной командный интерпретатор выдает сообщение об ошибке
	и, если он - не интерактивный, завершает работу с ненулевым статусом выхода.
-v	Выдавать строки команд по мере чтения.
-x	После подстановок в каждой простой команде выдавать значение переменной PS4,
	а затем - команду с результатами подстановок в аргументах.
-B	Выполнять подстановку квадратных скобок в командном интерпретаторе (см. раздел "Подстановка выражений в скобках" ранее).
	Эта опция установлена по умолчанию.
-C	Если эта опция установлена, bash не переписывает существующий файл при перенаправлениях с помощью операторов >, >& и <>.
	Это поведение можно переопределить при создании выходных файлов, применяя оператор перенаправления |> вместо >.
-H	Включить подстановку из списка истории с помощью метасимвола !.
	Эта опция по умолчанию установлена в интерактивных командных интерпретаторах.
-P	Если эта опция установлена, командный интерпретатор не следует по символьным связям при выполнении команд
	типа cd, изменяющих текущий рабочий каталог.
	Вместо этого, он использует физическую структуру каталогов.
	По умолчанию, bash следует по логической цепочке каталогов при выполнении команд, изменяющих текущий каталог.
--	Если после этой опции нет аргументов, сбрасываются значения позиционных параметров.
	В противном случае, позиционные параметры устанавливаются в соответствии с аргументами,
	даже если некоторые из них начинаются с дефиса (-).
-	Сигнализирует об окончании опций, так что все оставшиеся аргументы присваиваются позиционным параметрам.
	Опции -x и -v при этом отключаются. Если больше аргументов нет, позиционные параметры остаются без изменений.

Опции по умолчанию отключены, если явно не сказано иначе.
При указании + вместо - перед буквой опции, опция отключается.
Опции также можно задавать как аргументы при вызове командного интерпретатора.
Текущий набор опций представлен в виде значения параметра $-.
Статус выхода - 0, если только не указана недопустимая опция.
}
{unset<ba>	Для каждого имени удаляет (сбрасывает) соответствующую переменную или функцию.
	unset [-fv] [имя ...]
Если опции не указаны или задана опция -v, удаляются только переменные.
Переменные только для чтения удалять нельзя.
Если указана опция -f, удаляются только определения соответствующих функций.
Удаляемая переменная или функция удаляется из среды, передаваемой последующим командам.
Если сбрасывается одна из переменных RANDOM, SECONDS, LINENO, HISTCMD или DIRSTACK,
эти переменные теряют специальные свойства, даже если они в дальнейшем снова устанавливаются.
Статус выхода - 0, за исключеним случаев, когда имя не существует или доступно только для чтения.
}
{declare typeset<ba>	Объявляет переменные и/или задает их атрибуты.
	declare [-afFirx] [-p] [имя[=значение]]
	typeset [-afFirx] [-p] [имя[=значение]]
Если имена не заданы, выдаются значения переменных.
Опция -p будет выдавать атрибуты и значения переменных с указанными именами.
Когда используется опция -p, остальные опции игнорируются.
Опция -F запрещает выдачу определений функций; выдаются только имена и атрибуты функций.
Опция -F автоматически устанавливает -f.
Следующие опции можно использовать для выдачи переменных только с указанными атрибутами
или для задания атрибутов переменных:
-a	Каждое имя - переменная типа массив (см. раздел "Массивы" ранее).
-f	Использовать только имена функций.
-i	Переменная считается целочисленной;
	при присваивании переменной значения вычисляются арифметические выражения (см. раздел "ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ").
-r	Делает соответствующие переменные доступными только для чтения.
	Этим переменным нельзя присваивать значения в следующих операторах и их нельзя сбрасывать.
-x	Помечает имена для экспортирования в среду для последующих команд.

При задании '+' вместо '-' атрибут сбрасывается, за исключением того, что опцию +a нельзя использовать для уничтожения массива.
При использовании в функции, команда делает каждую опцию локальной, как и команда local.
Возвращается значение 0, если только не указана недействительная опция,
не делается попытка определить функцию с помощью конструкции "-f foo=bar",
не делается попытка присвоить значение переменной, доступной только для чтения,
не делается попытка присвоить значение массиву без использования конструкции присваивания для массива (см. раздел "Массивы" ранее),
не используется имя несуществующей переменной командного интерпретатора,
не выполняется попытка отменить статус только для чтения переменной, созданной как доступная только для чтения,
не делается попытка отменить статус массива для переменной типа массив,
и не предлагается выдать определение несуществующей функции с помощью опции -f.
}
{export<ba>	Указанные имена помечаются для автоматического экспортирования в среду следующих выполняемых команд.
	export [-fn] [имя[=слово]] ...
	export -p
Если указана опция -f, экспортируются имена функций.
Если имена не указаны или задана опция -p, выдается список всех имен, экспортированных данным командным интерпретатором.
Опция -n вызывает удаление признака экспортирования с указанных переменных.
Команда export возвращает сатутус выхода 0, 
если только не указана недопустимая опция, имя несуществующей переменной 
или в опции -f не указано имя, не являющееся именем функции.
}
{local<ba>	Для каждого аргумента создается локальная переменная с указанным именем, получающая соответствующее значение.
	local [имя[=значение] ...]
Когда команда local используется в функции, она ограничивает область действия этой переменной соответствующей функцией
и вызванными из нее функциями.
При вызове без операндов команда local выдает список локальных переменных в стандартный выходной поток.
Использование команды local вне функции - ошибка.
Статус возврата - 0, если только команда local не использована вне функции или не передано недопустимое имя.
}
{readonly<ba>	Указанные имена помечаются как доступные только для чтения;
	readonly [-apf] [имя ...]
значения соответствующих переменных нельзя изменять в дальнейшем с помощью присваивания.
Если указана опция -f, функции, соответствующие именам, тоже помечаются.
Опция -a ограничивает действие только массивами.
Если ни одно имя не указано или задана опция -p, выдается список имен, доступных только для чтения.
Опция -p вызывает выдачу результатов в формате, который можно использовать как входной.
Статус выхода - 0, если только не передана недопустимая опция,
одно из имен не является именем переменной
или опция -f не указана перед именем, не являющимся именем функции.
}
• env<cu> 		исполняющая команду с изменением окружения
. printenv<cu>	выводит переменные окружения
}
{• test [ <cu>	для проверки типа файла и сравнения значений
! expr — истина, если выражение expr ложь.
expr1 -a expr2 — истина, если оба выражения expr1 и expr2 истина.
expr1 -o expr2 — истина, если или expr1 или expr2 истина.

arg1 %оператор% arg2 -eq, -ne, -lt, -le, -gt, или -ge — эти арифметические бинарные операции возвращают истину,
	если arg1 равно, не равно, меньше чем, меньше чем или равно, больше чем, или больше или равно чем arg2, соответственно.
	arg1 и arg2 могут быть положительными целыми, отрицательными целыми, или специальными выражениями -l string, которые вычисляют длину string.
-z string — истина, если длина string равна нулю.
-n string string — истина, если длина string не ноль.
string1 = string2 — истина, если строки равны.
string1 != string2 — истина, если строки не равны.
-n string — истина, если длина string не равна нулю

-e file — истина, если file существует.
-d file — истина, если file существует и каталог.
-L file — истина, если file существует и символьная ссылка.
-f file — истина, если file существует и обычный файл.
-c file — истина, если file существует и символьное устройство.
-S file — истина, если file существует и сокет.
-b file — истина, если file существует и является специальным блочным устройством.
-p file — истина, если file существует и является именованным каналом (pipe).
-g file — истина, если file существует и имеет установленным групповой идентификатор (set-group-id).
-k file — истина, если file имеет установленным «sticky» бит.
-u file — истина, если file существует и имеет установленным бит пользователя (set-user-id).
-r file — истина, если file существует и читаем.
-w file — истина, если file существует и записываем.
-x file — истина, если file существует и исполняем.
-t [fd] — истина, если fd открыт на терминале. Если fd пропущен, по умолчанию 1 (стандартное устройство вывода).
-O file — истина, если file существует и его владелец имеет эффективный идентификатор пользователя.
-G file — истина, если file существует и его владелец имеет эффективный идентификатор группы.
-s file — истина, если file существует и имеет размер больше чем ноль.
file1 -nt file2 — истина, если file1 новее (дата модификации) чем file2.
file1 -ot file2 — истина, если file1 старее чем file2.
file1 -ef file2 — истина, если file1 и file2 имеют то же устройство и номер inode .
-------
	test выражение
	[ выражение ]
Возвращает статус 0 или 1, в зависимости от результатов проверки условного выражения.
Каждый оператор или операнд должен быть отдельным аргументом.
Выражения состоят из элементов, описанных ранее в разделе "УСЛОВНЫЕ ВЫРАЖЕНИЯ".

Выражения можно комбинировать с помощью следующих операторов, перечисленных по убыванию приоритета.

! выражение
    Истинно, если выражение ложно.

( выражение )
    Возвращает значение выражения. Можно использовать для переопределения обычного приоритета выполнения операторов.

выражение1 -a выражение2
    Истинно, если истинны оба выражения.

выражение1 -o выражение2
    Истинно, если истинно выражение1 или выражение2.

Команды test и [ проверяют условные выражения с помощью набора правил, основанного на количестве аргументов.

0 аргументов
    Выражение ложно.

1 аргумент
    Выражение истинно только если аргумент - не пустой.

2 аргумента
    Если первый аргумент - !, выражение истинно только если второй аргумент - пустой.
	Если первый аргумент - один из унарных условных операторов, перечисленных ранее в разделе "УСЛОВНЫЕ ВЫРАЖЕНИЯ",
	выражение истинно, если унарный оператор возвращает истину.
	Если первый аргумент не является допустимым унарным условным оператором, выражение ложно.

3 аргумента
    Если второй аргумент - один из бинарных условных операторов, перечисленных ранее в разделе "УСЛОВНЫЕ ВЫРАЖЕНИЯ",
	результатом проверки будет значение бинарного условного выражения, использующего первый и третий аргументы в качестве операндов.
	Если первый аргумент - !, результат - отрицание двухаргументной проверки второго и третьего аргументов.
	Если первый аргумент - только (, а третий - только ), результатом будет результат одноаргументной проверки второго аргумента.
	В противном случае, выражение ложно. В этом контексте операторы -a и -o считаются бинарными.

4 аргумента
    Если первый аргумент - !, результат - отрицание трехаргументной проверки оставшихся аргументов.
	В противном случае, выражение разбирается и проверяется в соответствии с приоритетами по перечисленным выше правилам.

5 и более аргументов
    Выражение разбирается и проверяется в соответствии с приоритетами по перечисленным выше правилам.
}
{=== выполнение других команд ===
{builtin<ba>	Выполняет указанную встроенную_команду интерпретатора, передает ей аргументы и возвращает ее статус выхода. 
	builtin встроенная_команда [аргументы]
Это полезно при определении функции, имя которой совпадает с именем встроенной команды интерпретатора
так, чтобы можно использовать вызов встроенной команды в функции.
Обычно так переопределяется встроенная команда cd.
Если указанная команда не является встроенной командой интерпретатора, возвращается статус 1.
}
{• command<ba>	Выполняет команду с аргументами, не выполняя обычный поиск
	command [-pVv] команда [аргумент ...]
Выполняет команду с аргументами, не выполняя обычный поиск функций командного интерпретатора.
Выполняются только встроенные команды или команды, которые находятся в указанных в переменной PATH каталогах.
Если задана опция -p, поиск команды выполняется по стандартному значению переменной PATH, гарантирующему, что будут найдены все стандартные утилиты.
Если указана опция -V или -v, выдается описание команды.
Опция -v выдает одно слово - имя команды или имя файла, представляющего команду;
опция -V дает немного более детальное описание.
Если указана опция -V или -v, статус выхода будет 0, если команда найдена, и 1 в противном случае.
Если ни одна из этих опций не задана и возникла ошибка или команду не удалось найти, будет получен статус выхода 127.
В противном случае статусом выхода встроенной команды command является статус выхода выполненной команды.
}
{eval<ba>		Аргументы читаются и соединяются в единую команду. Эта команда затем читается и выполняется
	eval [аргумент ...]
 командным интерпретатором,
а ее статус выхода возвращается в качестве значения команды eval.
Если аргументов нет или все аргументы пустые, команда eval возвращает 0.
}
{exec<ba>		Если указана команда, она заменяет командный интерпретатор.
	exec [-cl] [-a имя] [команда [аргументы]]
При этом новый процесс не создается.
Аргументы становятся аргументами команды.
Если указана опция -l, командный интерпретатор помещает дефис в качестве нулевого аргумента, передаваемого команде.
Именно так делает команда login(1).
Опция -c вызывает выполнение команды с пустой средой.
Если указана опция -a, командный интерпретатор передает имя как нулевой аргумент выполняемой команде.
Если команда не может быть выполнена по той или иной причине, неинтерактивный командный интерпретатор завершает работу,
если только не включена опция интерпретатора execfail, - в этом случае команда возвращает код ошибки.
Интерактивный командный интерпретатор возвращает код ошибки если файл не может быть выполнен.
Если команда не указана, любые перенаправления срабатывают в текущем командном интерпретаторе и статус выхода будет 0.
Если при перенаправлении произошла ошибка, статус выхода будет 1.
}

{. source<ba>	Читает и выполняет команды из указанного файла в среде текущего командного интерпретатора
	. имя_файла [аргументы]
	source имя_файла [аргументы]
и возвращает статус выхода последней выполненной команды из файла.
Если имя_файла не содержит косой черты, файл ищется в каталогах, перечисленных в переменной PATH.
Искомый файл не обязательно должен быть выполняемым.
Если ни в одном из каталогов, перечисленных в PATH, файл с указанным именем не найден, он ищется в текущем каталоге.
Если отключена опция sourcepath встроенной команды shopt, перечисленные в PATH каталоги не просматриваются. Если переданы аргументы, они становятся позиционными параметрами при выполнении файла. Иначе значения позиционных параметров не изменяются. Статусом выхода становится статус последней выполненной в сценарии команды (статус выхода равен 0, если ни одна команда не выполнялась), или 1, если файл не найден или не может быть прочитан.
}
}
{=== встроенные и не встроенные команды, алиасы ===
{enable<ba>		Включает и отключает встроенные команды интерпретатора.
	enable [-adnps] [-f имя_файла] [имя ...]
Отключение встроенной команды позволяет выполнять без указания полного имени файл на диске,
имя которого совпадает со встроенной командой, хотя обычно встроенные команды просматриваются первыми.
Если используется опция -n, указанные по именам команды отключаются, в противном случае они влючаются.
Например, чтобы использовать двоичную программу test, которая находится в одном из указанных в переменной PATH каталогов,
вместо встроенной версии интерпретатора, выполните enable -n test.
Опция -f требует загрузить новую встроенную команду с указанным именем
из заданного разделяемого объектного файла в системах, поддерживающих динамическую загрузку.
Опция -d удаляет встроенную команду, ранее загруженную с помощью опции -f.
Если имена не заданы или если указана опция -p, выдается список встроенных команд интерпретатора.
При отсутствии других опций и аргументов этот список содержит все включенные встроенные команды интерпретатора.
Если опция -n не указана, выдаются только отключенные встроенные команды.
Если указана опция -a, выдаваемый список включает все встроенные команды с признаком включена или отключена.
Если указана опция -s, выдаются только встроенные команды, предполагаемые стандартом POSIX.
Возвращается значение 0, если только имя являеся именем встроенной команды интерпретатора
и не возникла проблема при загрузке новой встроенной команды из разделямого объектного файла.
}
{• hash<ba>		Для каждого имени определяется и запоминается полное имя команды
	hash [-r] [-p имя_файла] [имя]
 путем поиска в каталогах, перечисленных в переменной $PATH.
Если указана опция -p, поиск по каталогам не выполняется, и указанное имя файла используется как полное имя команды.
Опция -r вызывает сброс всех запомненных имен.
Если аргументы не заданы, выдается информация о запомненных командах.
Статус выхода - истина, если только имя удалось найти и не указана недопустимая опция.
}
{• type<ba>		При вызове без опций показывает, как имена будут интерпретироваться при использовании в качестве имени команды.
	type [-atp] имя [имя ...]
Если указана опция -t, type выдает одну из строк alias, keyword, function, builtin или file,
если имя, соответственно, представляет собой псевдоним, зарезервированное слово командного интерпретатора, функцию, встроенную команду или файл на диске.
Если имя не найдено, ничего не выдается и возвращается статус выхода 1.
Если указана опция -p, type вернет либо имя файла на диске, который будет выполняться при указании имени в качестве имени команды,
либо ничего, если обращения к файлу не будет.
Если команда хранится в хэше, опция -p приводит к выдаче значения из хэша,
а не обязательно первого файла, выбираемого по перечисленным в PATH каталогам.
Если использована опция -a, команда type выдает список всех каталогов,
где есть выполняемый файл с соответствующим именем.
В список включаются также псевдонимы и функции, если только не указана опция -p.
К хэшу команд не обращаются, если указана опция -a.
Команда type возвращает 0, если хоть один из аргументов найден, и 1 в противном случае.
}
{• alias<ba>	задает и показывает псевдонимы
	alias [-p] [имя[=значение] ...]
Команда alias без аргументов или с опцией -p выдает список псевдонимов команд в виде alias имя=значение в стандартный выходной поток.
Для каждого имени в списке аргументов без соответствующего значения выдается имя и значение соответствующего псевдонима.
Если переданы аргументы, каждое имя, для которого задано значение, становится псевдонимом. 
Если значение завершается пробелом, в следующем слове при подстановке будет выполняться замена псевдонима.
Команда alias возвращает истину, если только не задано имя, не являющееся именем псевдонима.
}
{• unalias<ba>	Удаляет имена из списка определенных псевдонимов.
	unalias [-a] [имя ...]
Если указана опция -a, удаляются все определения.
Возвращается значение 0, за исключением случаев, когда переданное имя не является псевдонимом.
}
}
• mkfifo<cu>	Создаёт FIFO (именованные каналы)
{=== константы, заданные последовательности ===
• false<cu><fhs/bin>	возвратить значение 1, 
• true<cu><fhs/bin>	возвратить значение 0
. seq<cu>		выводит числа по порядку
. yes<cu>		до бесконечности выводит заданную строку
}
{=== readline, история ===
{ bind<ba>		Выдает текущие привязки клавиш и функций библиотеки readline или привязывает комбинацию клавиш к функции или макросу readline.
	bind [-m keymap] [-lpsvPSV]
	bind [-m keymap] [-q функция] [-u функция] [-r keyseq]
	bind [-m keymap] -f имя_файла
	bind [-m keymap] keyseq:имя_функции
При этом поддерживается такой же синтаксис привязки, как и в файле .inputrc, 
но каждая привязка должна передаваться как отдельный аргумент; т.е. '"\C-x\C-r": re-read-init-file'.

Опции, если они переданы, имеют следующие значения:

-m keymap	Использовать набор привязок для последующих привязок. 
			Допускаются имена привязок emacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-command и vi-insert.
			vi эквивалентно vi-command; emacs эквивалентно emacs-standard.
-l			Список имен всех функций readline.
-p		    Выдает имена функций и привязки readline так, чтобы их можно было прочитать повторно.
-P		    Выдает текущие имена функций и привязки readline.
-v		    Выдает имена и значения переменных readline так, чтобы их можно было прочитать повторно.
-V		    Выдает имена и значения текущих переменных readline.
-s		    Выдает комбинации клавиш readline, привязанные к макросам, и выдаваемые при их нажатии строки так, чтобы их можно было прочитать повторно.
-S		    Выдает комбинации клавиш readline, привязанные к макросам, и выдаваемые при их нажатии строки
-f имя_файла Читать привязки клавиш из указанного файла.
-q функция  Выдает комбинации клавиш, привязанные к указанной функции.
-u функция  Снять все привязки комбинаций клавиш к указанной функции.
-r keyseq   Удалить привязку к указанной комбинации клавиш keyseq.

Команда возвращает значение 0, кроме случаев, когда передана нераспознанная опция или произошла ошибка.
}
{• fc<ba>		служащая для редактирования списка ранее введенных команд, а также их выполнения. Аналогична history.
	fc [-e редактор] [-nlr] [первая] [последняя]
	fc -s [pat=rep] [команда]
Первая форма выбирает диапазон команд, от первой до последней, из списка истории выполнения.
Первую и последнюю команду можно задавать строкой (найти последнюю команду, начинающуюся с соответствующей строки)
или числом (индекс в списке истории, причем отрицательные значения используются как смещение от номера текущей команды).
Если последняя не указана, при выдаче последней считается текущая команда (так что fc -l -10 выдает последних 10 команд),
а для остальных опций предполагается, что последняя совпадает с первой.
Если первая не указана, ею становится предыдущая команда при редактировании
и -16 (шестнадцатая с конца списка истории) при выдаче.

Опция -n подавляет выдачу номеров команд.
Опция -r изменяет порядок выдачи команд на противоположный.
Если указана опция -l, команды выдаются в стандартный выходной поток.
В противном случае вызывается указанный редактор, которому передается файл с соответствующими командами.
Если редактор не задан, используется значение переменной FCEDIT или значение переменной EDITOR, если FCEDIT не установлена.
Если не установлены обе переменные, используется редактор vi.
По завершении редактирования, отредактированные команды выдаются и выполняются.

Вторая форма требует повторного выполнения команды после замены каждого вхождения pat на rep.
Полезно задать псевдоним "r=fc -s", так что при наборе "r cc" будет выполнена последняя команда, начинавшаяся со строки "cc",
а при вводе "r" будет повторно выполняться последняя команда.

Если используется первая форма, команда возвращает значение 0,
если только не указана недопустимая опция или первая или последняя команда выходит за пределы номеров команд в списке истоии.
Если указана опция -e, возвращается статус выхода последней выполненной команды
или ошибка, произошедшая при работе с временным файлом команд.
Если используется вторая форма, возвращается статус выхода повторно выполненной команды,
если только команда не задает несуществующую строку в списке истории, - в этом случае команда fc возвращает 1.
}
{ history<ba>	Если опции не указаны, выдает список истории команд с номерами строк.
	history [-c] [n]
	history -anrw [имя_файла]
	history -p аргумент [аргумент ...]
	history -s аргумент [аргумент ...]
Строки, для которых указана звездочка (*), были изменены.
При указании аргумента n выдаются только последние n строк.
Если указано имя_файла, список истории берется из этого файла;
если файл не указан, используется значение переменной HISTFILE.
Опции имеют следующие значения:
-a	Добавлять "новые" строки истории (строки истории, введенные с начала текущего сеанса bash) в файл истории.
-n	Читать строки истории, еще не прочитанные из файла истории, в текущий список истории команд.
	Речь идет о строках, добавленных в файл истории с начала текущего сеанса bash.
-r	Читать содержимое файла истории и использовать его в качестве текущего списка истории выполнения команд.
-w	Записывать текущий список истории команд в файл истории, переписывая его текущее содержимое.
-c	Очистить список истории выполнения команд, удаляя все записи.
-p	Выполнить подстановку из списка истории для последующих аргументов
	и выдать результат в стандартный выходной поток.
	Результат не запоминается в списке истории.
	Для отключения обычной подстановки из списка истории, необходимо маскировать (брать в кавычки) каждый аргумент.
-s	Сохранить аргументы в списке истории как одну запись.
	Последняя команда в списке истории удаляется перед добавлением аргументов.

Возвращается значение 0, если не передана недопустимая опция
или при попытке чтения или записи файла истории не произошла ошибка.
}
}
{=== задания ===
{• fg<ba>		Возобновляет работу задания в приоритетном режиме и делает это задание текущим.
	fg [задание]
Если задание не указано, используется текущее задание командного интерпретатора.
Возвращается значение статуса выхода команды, переведенной в приоритетный режим,
или 1 если управление заданиями отключено или,
при включенном управлении заданиями, если указано несуществующее задание
или задание, запущенное при отключенном управлении заданиями.
}
{• bg<ba>		Возобновляет выполнение указанного задания в фоновом режиме, или в фоновый режим переводится текущее задание
	bg [задание]
Возобновляет выполнение указанного задания в фоновом режиме, как если бы оно было запущено с конструкцией &.
Если задание не указано, в фоновый режим переводится текущее задание командного интерпретатора.
Команда bg задание возвращает 0, если только управление заданиями не отключено или, 
при включенном управлении заданиями, соответствующее задание не найдено или запускалось при отключенном управлении заданиями.
}
{disown<ba>		При вызове без опций каждое указанное задание удаляется из таблицы активных заданий.
	disown [-ar] [-h] [задание ...]
Если задана опция -h, задания не удаляются из таблицы, а помечаются
так, что сигнал SIGHUP не посылается заданию при получении сигнала SIGHUP командным интерпретатором.
Если задание не указано и не заданы опции -a и -r, используется текущее задание.
Если задание не указано, опция -a означает удалить или пометить все задания;
опция -r без аргумента задание ограничивает действие выполняющимися заданиями.
Команда возвращает значение 0, если только не указано несуществующее задание.
}
{• jobs	<ba>	Первое из списка активных заданий.
	jobs [-lnprs] [ задание ... ]
	jobs -x команда [ аргументы ... ]
Опции имеют следующие значения:
-l	Помимо обычной информации выдает идентификаторы процессов.
-p	Выдает только идентификаторы процессов-лидеров групп процессов, образующих задание.
-n	Выдает информацию только о заданиях, состояние которых изменилось
	с момента последнего уведомления пользователя о состоянии заданий.
-r	Выдает только выполняющиеся задания.
-s	Выдает только остановленные задания.

Если указано задание, выдается информация только об этом задании.
Статус выхода - 0, кроме случаев, когда указана недопустимая опция или идентификатор несуществующего задания.

Если указана опция -x, команда jobs заменяет любой идентификатор задания в команде или аргументах
соответствующим идентификатором группы процессов,
и выполняет команду, передавая ей аргументы и возвращая ее статус выхода.
}
}
• sleep<cu>		выполняющая задержку на указанное время 
{• file 		предназначенная для определения типа файла.
<cygwin:file>
/*linux man*/
This manual page documents version 4.17 of the file command.

File tests each argument in an attempt to classify it. There are three sets of tests, performed in this order: filesystem tests, magic number tests, and language tests. The first test that succeeds causes the file type to be printed.

The type printed will usually contain one of the words text (the file contains only printing characters and a few common control characters and is probably safe to read on an ASCII terminal), executable (the file contains the result of compiling a program in a form understandable to some UNIX kernel or another), or data meaning anything else (data is usually `binary' or non-printable). Exceptions are well-known file formats (core files, tar archives) that are known to contain binary data. When modifying the file /usr/share/file/magic or the program itself, preserve these keywords . People depend on knowing that all the readable files in a directory have the word ``text'' printed. Don't do as Berkeley did and change ``shell commands text'' to ``shell script''. Note that the file /usr/share/file/magic is built mechanically from a large number of small files in the subdirectory Magdir in the source distribution of this program.

The filesystem tests are based on examining the return from a stat(2) system call. The program checks to see if the file is empty, or if it's some sort of special file. Any known file types appropriate to the system you are running on (sockets, symbolic links, or named pipes (FIFOs) on those systems that implement them) are intuited if they are defined in the system header file <sys/stat.h>.

The magic number tests are used to check for files with data in particular fixed formats. The canonical example of this is a binary executable (compiled program) a.out file, whose format is defined in a.out.h and possibly exec.h in the standard include directory. These files have a `magic number' stored in a particular place near the beginning of the file that tells the UNIX operating system that the file is a binary executable, and which of several types thereof. The concept of `magic number' has been applied by extension to data files. Any file with some invariant identifier at a small fixed offset into the file can usually be described in this way. The information identifying these files is read from the compiled magic file /usr/share/file/magic.mgc , or /usr/share/file/magic if the compile file does not exist. In addition file will look in $HOME/.magic.mgc , or $HOME/.magic for magic entries.

If a file does not match any of the entries in the magic file, it is examined to see if it seems to be a text file. ASCII, ISO-8859-x, non-ISO 8-bit extended-ASCII character sets (such as those used on Macintosh and IBM PC systems), UTF-8-encoded Unicode, UTF-16-encoded Unicode, and EBCDIC character sets can be distinguished by the different ranges and sequences of bytes that constitute printable text in each set. If a file passes any of these tests, its character set is reported. ASCII, ISO-8859-x, UTF-8, and extended-ASCII files are identified as ``text'' because they will be mostly readable on nearly any terminal; UTF-16 and EBCDIC are only ``character data'' because, while they contain text, it is text that will require translation before it can be read. In addition, file will attempt to determine other characteristics of text-type files. If the lines of a file are terminated by CR, CRLF, or NEL, instead of the Unix-standard LF, this will be reported. Files that contain embedded escape sequences or overstriking will also be identified.

Once file has determined the character set used in a text-type file, it will attempt to determine in what language the file is written. The language tests look for particular strings (cf names.h) that can appear anywhere in the first few blocks of a file. For example, the keyword .br indicates that the file is most likely a troff(1) input file, just as the keyword struct indicates a C program. These tests are less reliable than the previous two groups, so they are performed last. The language test routines also test for some miscellany (such as tar(1) archives).

Any file that cannot be identified as having been written in any of the character sets listed above is simply said to be ``data''.   
/*posix man*/
The file utility shall perform a series of tests in sequence on each specified file in an attempt to classify it:

If file does not exist, cannot be read, or its file status could not be determined, the output shall indicate that the file was processed, but that its type could not be determined.

If the file is not a regular file, its file type shall be identified.
>> regular file - обычный файл
The file types directory, FIFO, socket, block special, and character special shall be identified as such.
Other implementation-defined file types may also be identified.
If file is a symbolic link, by default the link shall be resolved and file shall test the type of file referenced by the symbolic link.
(See the -h and -i options below.)

If the length of file is zero, it shall be identified as an empty file.

The file utility shall examine an initial segment of file and shall make a guess at identifying its contents based on position-sensitive tests.
>> guess - думать, предполагать
(The answer is not guaranteed to be correct; see the -d, -M, and -m options below.)

The file utility shall examine file and make a guess at identifying its contents based on context-sensitive default system tests.
(The answer is not guaranteed to be correct.)

The file shall be identified as a data file.

If file does not exist, cannot be read, or its file status could not be determined, the output shall indicate that the file was processed, but that its type could not be determined.

If file is a symbolic link, by default the link shall be resolved and file shall test the type of file referenced by the symbolic link.   
}
}
