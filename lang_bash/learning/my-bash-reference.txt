bash - интерпретатор
--------------------------------------
комментарии (игнорируются)
	^# SPC# до конца строки
метасимволы и управляющие операторы
(имеют особое значение везде (кроме комментариев))
	| & ; ( ) < > пробел табуляция 
	|| & && ; ;; ( ) | <перевод строки> 
	$ ' "
маскировка, часть 1
	\симовл	#1 символ
	''	#внутри нельзя пользоваться \ 
	$''	#внутри \ используется как в си
-----------------------------------
программа, команда, утилита - одно и тоже
* некоторые команды встроены в интерпретатор и называются встроенными командами

каждая команда имеет 
	аргументы
		отделяются пробелом(ами)
		# часто одни команды запускают другие, переданные им в аргументах
		# аргументы "флаги" (минус буква или минус минус слово) служат для того
		#	чтобы слегка (или не очень) изменить поведение программы
		#	как можно модифицировать поведение некоторой программы - смотри по ней справку
	статус завершения
		число 0.....; 0 - OK(true), иначе неOK(false)
	поток ввода
		когда программе требуется ввод - она ждет, пока пользователь что-то введет и нажмет enter
	поток вывода и поток ошибок
		обычно экран
	переменные окружения
		набор строк, 
	текущую директория
		все относительные пути - относительно этой папки
	(может реагировать на сигналы)
		C-c, 9й, kill сигнал команда
зарезервированные слова
(имеют особое значение в качестве команд)
	! case do done elif else esac fi for function if 
	in select then until while { } time [[ ]]
	=

////////
справку по любой команде можно получить набрав
	команда --help
	man команда
для встроенных команд есть встроенная команда help:
	help команда
# попробуйте man man и help help
# обязательно посмотрите help # без аргументов
# и man bash
# а также есть в интернете старый man bash на русском 
\\\\\\\\

=== переменные ===
синтаксис:
	присваивание:
		переменная=значение # без пробелов
	использование:
		$переменная
	или
		${переменная}
	а еще можно подставлять вывод других команд
		$(команда) # такие конструкции можно вкладывать друг в друга
	или
		`команда` # а такие нельзя, это устаревшая, но все равно часто используемая конструкция
///////
echo
выводит аргументы в выходной поток
\\\\\\\

переменные бывают:
	переменные окружения
		при вызове команды переменные окружения интерпретатора становятся переменными окружния вызванной команды
////
		получить их список можно командой env
\\\\
	переменные самого интерпретатора
		при вызове команды переменные самого интерпретатора ни как не передаются в вызванную команду
////
		получить их список (вперемешку со списком переменных окружения) можно командой set
\\\\
по умолчанию создаются переменные самого интерпретатора
////
команда export делает переменные - переменными окружения
\\\\
если надо экспортировать переменные для одной команды, 
тогда присваивания надо разместить на одной строке с командой, перед командой
	var=value command args

===научимся объединять и отделять друг от друга переменные===

напишем (возможно ваш первый) скрипт:
echo hello world # это на случай если это ваш первый скрипт
echo total arguments number: $#
echo arg 1: $1
echo arg 2: $2
echo arg 3: $3
echo arg 4: $4
echo arg 5: $5
echo arg 6: $6
# 6 штук хватит
# внутри скриптов переменные $# и $N имеют особый смысл:
# $# (перед # ведь нет пробела) - количество переданных аргументов
# $N - значение N-го аргумента (нумерация с 1)
# 0й аргумент - абсолютный путь имя самого скрипта или программы
# $@ и $*
назовем его printargs и сохраним в текущей директории
и позапускаем его:
$ bash printargs
$ bash printargs abc
$ bash printargs a b c

есть более предпочтительный способ:
добавим перед первой строкой следующую строку-комментарий:
#! /bin/bash
сделаем файл исполняемым:
$ chmod +x printargs 
# man chmod # ага ;-)
и теперь позапускаем его:
$ ./printargs
$ ./printargs abc
$ ./printargs a b c
когда операционная система запускает исполняемый файл (а неисполняемый она не станет запускать)
она видит символы #! (читается ша-банк) и понимет (что она еще понимает см. man magic), что этот файл надо бы скормить интерпретатору /bin/bash, что и делает

./ при вызове необходимо писать т.к. путь "." не находится в переменной PATH
создадим директорию bin:
$ mkdir bin
добавим ее в PATH:
$ PATH="$PATH:абсолютный путь к директории bin"
(слова "абсолютный путь к директории bin" следует заменить на абсолютный путь к директории bin
: - разделитель (такой синтаксис у этой переменной)
а кавычки нужны на случай если есть директории, содержащие пробелы
)
переместим туда наш скрипт:
$ mv printargs bin

и теперь можем запускать:
$ printargs
$ printargs abc
$ printargs a b c
$ printargs 'a b c'
$ printargs a\ b c
$ printargs a\ b\<enter>
 c
$ printargs a\ b\<enter>
c
$ printargs 'a b<enter>
 c'
поиграемся с переменными:
var=qwe
printargs $qwe
printargs abc $qwe
printargs abc$qwe
printargs ${qwe}abc
var2=asdf
printargs $var $var2
printargs $var$var2
var='qwe rty'
printargs $var
printargs '$var'

и пройдем маскировку часть 2
	""	

------------------------------------------------
перенаправления и потоки (и некоторые текстовые утилитки)
------------------------------------------------
статус команды и условия
------------------------------------------------
другие подстановки и раскрытия (а также for, case)
------------------------------------------------
арифметика???
