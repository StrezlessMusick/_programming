<!doctype html><html>
<head><meta charset="UTF-8">
<link rel="STYLESHEET" href="../main.css" type="text/css">
<title>OS X Redirection and Process Substitution | SS64.com</title>
</head><!-- #BeginLibraryItem "/Library/head_osxsyntax.lbi" --><div id="tnav"><ul>
<li class="tbtn"><a href="http://ss64.com/"> ( &nbsp;SS64 &nbsp;)</a></li>
<li class="tbtn"><a href="http://ss64.com/osx">OS X</a></li>
<li class="tbtn"><a href="syntax.html">Syntax</a></li>
<li><div id="search"><form action="http://www.google.com/search" method="get">
<button tabindex="-1" type="submit" id="q-img"></button>
<input type="text" name="q" id="q" size="27" maxlength="255" onblur="if(this.value=='')this.value='Search…';" onclick="if(this.value=='Search…')this.value='';" value="Search…">
<input type="hidden" name="sitesearch" value="ss64.com/osx/"></form></div></li>
</ul></div><!-- #EndLibraryItem --><h1>Redirection and Process Substitution</h1>

<p>Both the input and output of a command may be <var>redirected</var>:</p>
<pre>command  &gt;  filename    Redirect command output into a file

command  &gt;&gt; filename    Redirect command output and APPEND into a file

command  &lt;  filename    Redirect a file into a command

command  |  filename    Redirect output from one command into another

command | <a href="tee.html">tee</a> filename | commandB    Redirect command into filename AND CommandB

       Builtin	commands are executed within the shell.	 If any component of a
       pipeline except the last is a builtin command, the pipeline is executed
       in a subshell.

       Parenthesized commands are always executed in a subshell.

	   (cd; pwd); pwd

       thus  prints  the  home directory, leaving you where you were (printing
       this after the home directory), while

	   cd; pwd

       leaves you in the home  directory.   Parenthesized  commands  are  most
       often used to prevent cd from affecting the current shell.</pre>
<p> The NOCLOBBER option can prevent you from overwriting an existing file. </p>
<h2 class="body">Redirecting Input/Output: </h2>
<pre>The standard input and standard output of a command may be redirected
with the following syntax:

       &lt; <i>name</i>  Open file <i>name</i> (which is first variable, command	 and  filename
	       expanded) as the standard input.

       &lt;&lt; <i>word</i> Read  the  shell input up to a line which is identical to <i>word</i>.
	       <i>word</i> is not subjected to variable, filename or command  substi-
	       tution, and each input line is compared to <i>word</i> before any sub-
	       stitutions are done on this input line.	Unless a quoting  `\',
	       `"',  `'	 or ``' appears in <i>word</i> variable and command substitu-
	       tion is performed on the intervening  lines,  allowing  `\'  to
	       quote  `$',  `\'	 and ``'.  Commands which are substituted have
	       all blanks, tabs, and newlines preserved, except for the	 final
	       newline	which  is dropped.  The resultant text is placed in an
	       anonymous temporary file which is given to the command as stan-
	       dard input.

       &gt; <i>name</i>
       <i>&gt;!</i> <i>name</i>
       <i>&gt;&amp;</i> <i>name</i>
       <i>&gt;&amp;!</i> <i>name</i>
	       The file <i>name</i> is used as standard output.  If the file does not
	       exist then it is created; if the file exists, it is  truncated,
	       its previous contents being lost.

	       If  the shell variable <b>noclobber</b> is set, then the file must not
	       exist or be a character	special	 file  (e.g.,  a  terminal  or
	       `/dev/null')  or an error results.  This helps prevent acciden-
	       tal destruction of files.  In this case the `!'	forms  can  be
	       used to suppress this check.

	       The  forms  involving  `&amp;' route the diagnostic output into the
	       specified file  as  well	 as  the  standard  output.   <i>name</i>  is
	       expanded in the same way as `&lt;' input filenames are.

       &gt;&gt; <i>name</i>
       <i>&gt;&gt;&amp;</i> <i>name</i>
       <i>&gt;&gt;!</i> <i>name</i>
       <i>&gt;&gt;&amp;!</i> <i>name</i>
	       Like  `&gt;', but appends output to the end of <i>name</i>.  If the shell
	       variable <b>noclobber</b> is set, then it is an error for the file <i>not</i>

	       to exist, unless one of the `!' forms is given.

       A  command  receives  the environment in which the shell was invoked as
       modified by the input-output parameters and the presence of the command
       in  a pipeline.	Thus, unlike some previous shells, commands run from a
       file of shell commands have no access to the text of  the  commands  by
       default;	 rather they receive the original standard input of the shell.
       The `&lt;&lt;' mechanism should be used to present inline data.  This permits
       shell command scripts to function as components of pipelines and allows
       the shell to block read its input.   Note  that	the  default  standard
       input  for  a command run detached is <i>not</i> the empty file <i>/dev/null</i>, but
       the original standard input of the shell.  If this is a terminal and if
       the  process  attempts to read from the terminal, then the process will
       block and the user will be notified .

       Diagnostic output may be directed through a pipe with the standard out-
       put.  Simply use the form `|&amp;' rather than just `|'.

       The  shell  cannot  presently  redirect	diagnostic output without also
       redirecting standard output, but 
           `(<i>command</i>  &gt;  <i>output-file</i>)  &gt;&amp; <i>error-</i><i>file</i>'  is often an acceptable
       workaround.  Either <i>output-file</i> or <i>error-</i><i>file</i> may be `/dev/tty' to
       send output to the terminal.</pre>
<h2 class="body"><b>Here Documents</b></h2>
<p>This type of redirection instructs the shell to read input from the current 
  source until a line containing only <var>word</var> (with no trailing blanks) 
  is seen. All of the lines read up to that point are then used as the standard 
  input for a command. </p>
<p>The format of here-documents is as follows: 
<pre>&lt;&lt;[-]<var>word</var>
        <var>here-document</var>
<var>delimiter</var></pre>
<p>No parameter expansion, command substitution, arithmetic expansion, or filename 
  expansion is performed on <var>word</var>. If any characters in <var>word</var> 
  are quoted, the <var>delimiter</var> is the result of quote removal on <var>word</var>, 
  and the lines in the here-document are not expanded. If <var>word</var> is unquoted, 
  all lines of the here-document are subjected to parameter expansion, command 
  substitution, and arithmetic expansion. In the latter case, the character sequence 
  <code>\newline</code> is ignored, and <samp>`\'</samp> must be used to quote 
  the characters <samp>`\'</samp>, <samp>`$'</samp>, and <samp>``'</samp>.</p>
<p> <b>Related:</b></p>
<p>  <a href="syntax.html">OS X Syntax</a></p><!-- #BeginLibraryItem "/Library/foot_osx.lbi" --><p><script type="text/javascript"><!--
google_ad_client = "pub-6140977852749469";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "text_image";
google_ad_channel ="3133437331";
google_color_border = "CCCCCC";
google_color_bg = "CCCCCC";
google_color_link = "000000";
google_color_text = "333333";
google_color_url = "0000FF";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script></p>
<hr>
<div id=bl class="footer"><a href="syntax-redirection.html#"><img src="../images/top.png" width="30" height="22" alt="Back to the Top"></a></div>
<div id=br class="footer, tagline">&copy; Copyright <a href="http://ss64.com/">SS64.com</a> 1999-2014<br>
Some rights reserved</div><!-- #EndLibraryItem --></body>
</html>