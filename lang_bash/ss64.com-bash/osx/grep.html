<!doctype html><html>
<head><meta charset="UTF-8">
<link rel="STYLESHEET" href="../main.css" type="text/css">
<title>grep OSX Man Page | SS64.com</title>
</head><body><!-- #BeginLibraryItem "/Library/head_osx.lbi" --><div id="tnav"><ul>
<li class="tbtn"><a href="http://ss64.com/"> ( &nbsp;SS64 &nbsp;)</a></li>
<li class="tbtn"><a href="http://ss64.com/osx">OS X</a></li>
<li class="tbtn"><a href="syntax.html">Syntax</a></li>
<li><div id="search"><form action="http://www.google.com/search" method="get">
<button tabindex="-1" type="submit" id="q-img"></button>
<input type="text" name="q" id="q" size="27" maxlength="255" onblur="if(this.value=='')this.value='Search…';" onclick="if(this.value=='Search…')this.value='';" value="Search…">
<input type="hidden" name="sitesearch" value="ss64.com/osx/"></form></div></li>
</ul></div><!-- #EndLibraryItem --><h1>grep</h1> 
<p>Search file(s) for specific text.</p>
<pre>Syntax
      grep &lt;options&gt; &quot;Search String&quot; [<i>filename</i>]

      grep &lt;options&gt; [-e <i>PATTERN</i>] [<i>FILE</i>...]

      grep &lt;options&gt; [-f <i>FILE</i>] [<i>FILE</i>...]

A simple example
grep   &quot;Needle in a Haystack&quot;  /etc/*</pre>
<p>Grep searches the named input FILEs (or standard input if no files 
  are named, or the file name - is given) for lines containing a match to the 
  given PATTERN. By default, grep prints the matching lines. </p>
<p>In addition, two 
  variant programs <span class="code">egrep</span> and <span class="code">fgrep</span> are available. Egrep is the same as <span class="code">grep -E</span>. 
  Fgrep is the same as <span class="code">grep -F</span>. </p>
<pre>Options

       -A <i>NUM</i>, --after-context=<i>NUM</i>
              Print NUM lines of trailing context after  matching
              lines.

       -a, --text
              Process  a  binary file as if it were text; this is
              equivalent to the --binary-files=text option.

       -B <i>NUM</i>, --before-context=<i>NUM</i>
              Print NUM lines of leading context before  matching
              lines.

       -b, --byte-offset
              Print  the byte offset within the input file before
              each line of output.

       -C [<i>NUM</i>], -<i>NUM,</i> --context[=<i>NUM</i>]
              Print NUM lines (default 2) of output context.

       -c, --count
              Suppress  normal  output;  instead print a count of
              matching lines for each input file.  With  the  -v,
              --invert-match option (see below), count non-match-
              ing lines.

       -d <i>ACTION</i>, --directories=<i>ACTION</i>
              If an input file is a directory, use ACTION to pro-
              cess  it.   By default, ACTION is read, which means
              that directories are read  just  as  if  they  were
              ordinary files.  If ACTION is skip, directories are
              silently skipped.  If ACTION is recurse, grep reads
              all  files  under each directory, recursively; this
              is equivalent to the -r option.

       -E, --extended-regexp
              Interpret <a href="grep_pattern.html">PATTERN</a> as an extended regular expression
              (see below).

       -e <i>PATTERN</i>, --regexp=<i>PATTERN</i>
              Use  <a href="grep_pattern.html">PATTERN</a> as the pattern; useful to protect pat-
              terns beginning with -.

       -F, --fixed-strings
              Interpret <a href="grep_pattern.html">PATTERN</a> as a list of fixed strings, sepa-
              rated by newlines, any of which is to be matched.

       -f <i>FILE</i>, --file=<i>FILE</i>
              Obtain <a href="grep_pattern.html">patterns</a> from FILE, one per line.  The empty
              file contains zero patterns, and therefore  matches
              nothing.

       -G, --basic-regexp
              Interpret <a href="grep_pattern.html">PATTERN</a> as a basic regular expression (default)

       -H, --with-filename
              Print the filename for each match.

       -h, --no-filename
              Suppress the prefixing of filenames on output  when
              multiple files are searched.

       -I     Process  a  binary  file  as  if it did not contain
              matching data; this is equivalent to the  --binary-
              files=without-match option.

       -i, --ignore-case
              Ignore  case  distinctions  in both the PATTERN and
              the input files.

       -L, --files-without-match
              Suppress normal output; instead print the  name  of
              each input file from which no output would normally
              have been printed.  The scanning will stop  on  the
              first match.

       -l, --files-with-matches
              Suppress  normal  output; instead print the name of
              each input file from which  output  would  normally
              have  been  printed.  The scanning will stop on the
              first match.

       -n, --line-number
              Prefix each line of output  with  the  line  number
              within its input file.

       -q, --quiet, --silent
              Quiet;  suppress  normal output.  The scanning will
              stop on the first match.  Also see the -s or  --no-
              messages option below.

       -r, --recursive
              Read  all  files under each directory, recursively;
              this is equivalent to the -d recurse option.

       -s, --no-messages
              Suppress  error  messages  about   nonexistent   or
              unreadable  files.   Portability  note:  unlike GNU
              grep, traditional grep did not conform to  POSIX.2,
              because traditional grep lacked a -q option and its
              -s option behaved like GNU grep's -q option.  Shell
              scripts intended to be portable to traditional grep
              should avoid both -q and  -s  and  should  redirect
              output to /dev/null instead.

       -U, --binary
              Treat the file(s) as binary.  By default, under MS-
              DOS and MS-Windows, grep guesses the file  type  by
              looking at the contents of the first 32KB read from
              the file.  If grep decides the file is a text file,
              it  strips the CR characters from the original file
              contents (to make regular expressions with ^ and  $
              work  correctly).   Specifying  -U  overrules  this
              guesswork, causing all files to be read and  passed
              to  the matching mechanism verbatim; if the file is
              a text file with CR/LF pairs at  the  end  of  each
              line,  this  will cause some regular expressions to
              fail.  This option has no effect on platforms other
              than MS-DOS and MS-Windows.

       -u, --unix-byte-offsets
              Report Unix-style byte offsets.  This switch causes
              grep to report byte offsets as  if  the  file  were
              Unix-style  text  file,  i.e.,  with  CR characters
              stripped off.  This will produce results  identical
              to running grep on a Unix machine.  This option has
              no effect unless -b option is also used; it has  no
              effect  on  platforms other than MS-DOS and MS-Win-
              dows.

       -V, --version
              Print the version number of grep to standard error.
              This  version  number should be included in all bug
              reports (see below).

       -v, --invert-match
              Invert the sense of matching, to select  non-match-
              ing lines.

       -w, --word-regexp
              Select  only  those  lines  containing matches that
              form whole words.  The test is  that  the  matching
              substring  must  either  be at the beginning of the
              line, or preceded by a non-word constituent charac-
              ter.   Similarly,  it  must be either at the end of
              the line or  followed  by  a  non-word  constituent
              character.   Word-constituent  characters  are let-
              ters, digits, and the underscore.

       -x, --line-regexp
              Select only those matches that  exactly  match  the
              whole line.

       -y     Obsolete synonym for -i.

       -Z, --null
              Output  a  zero  byte  (the  ASCII  NUL  character)
              instead of the character that  normally  follows  a
              file  name.   For  example, grep -lZ outputs a zero
              byte after each file name instead of the usual new-
              line.   This  option  makes the output unambiguous,
              even in  the  presence  of  file  names  containing
              unusual  characters like newlines.  This option can
              be used with commands like find -print0,  perl  -0,
              sort  -z,  and  xargs  -0 to process arbitrary file
              names, even those that contain newline  characters.

       --binary-files=<i>TYPE</i>
              If the first few bytes of a file indicate that  the
              file  contains binary data, assume that the file is
              of type TYPE.  By default, TYPE is binary, and grep
              normally  outputs  either a one-line message saying
              that a binary file matches, or no message if  there
              is  no  match.   If  TYPE  is  without-match,  grep
              assumes that a binary file does not match; this  is
              equivalent to the -I option.  If TYPE is text, grep
              processes a binary file as if it were text; this is
              equivalent   to   the  -a  option.   Warning:  grep
              --binary-files=text might  output  binary  garbage,
              which  can have nasty side effects if the output is
              a terminal and if the  terminal  driver  interprets
              some of it as commands.

       --help Output a brief help message.

       --mmap If possible, use the mmap(2) system  call  to  read
              input,  instead of the default read(2) system call.
              In some situations, --mmap  yields  better  perfor-
              mance.   However, --mmap can cause undefined behav-
              ior (including core dumps) if an input file shrinks
              while grep is operating, or if an I/O error occurs.

<b>Environment variables</b>

Grep's behavior can be affected by setting the following environment variables

GREP_OPTIONS                 - default options
LC_ALL, LC_MESSAGES, LANG    - language for messages
LC_CTYPE                     - foreign characters
POSIXLY_CORRECT              - Posix behaviour
_N_GNU_nonoption_argv_flags_ - ignore an operand

see `info' for more on these</pre>
<p><b>Examples</b></p>
<p>Search the file example.txt, including binary data (-a) for the string 'hunting the snark':</p>
<p>$ <span class="code">sudo grep -a  'hunting the snark' example.txt</span></p>
<p>Search the whole partition (/disk0), including binary data (-a) for the string 'hunting the snark' return all the lines<br>
starting 25 <b>B</b>efore the text found and 50 lines <b>A</b>fter the matching text found, this can be a way to discover fragments of deleted files:</p>
<p>$ <span class="code">sudo grep -a -B 25 -A 50 'hunting the snark' /dev/disk0</span>&gt; results.txt</p>
<p>Search the file <span class="code">wordlist.txt</span> for any lines that <b>don't </b>include at least one vowel:</p>
<p>$ <span class="code">grep -v [aeiou] wordlist.txt</span></p>
<p>Remove lines from <span class="code">invoices.txt</span> if they appear in <span class="code">paid.txt</span>:</p>
<p>$ <span class="code">grep -F -x -v -f paid.txt invoices.txt &gt;paidinvoices.txt</span></p>
<p>Searching an entire hard drive with grep can be very slow, using <a href="mdfind.html">mdfind</a> to identify files containing text is orders of magnitude <a href="http://hints.macworld.com/article.php?story=20100320112701285">faster</a>. </p>
<p class="quote"><i> &quot;The most dangerous of all falsehoods is a slightly distorted truth&quot; ~ G. C. Lichtenberg </i></p>
<p><b>Related:</b></p>
<p><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/grep.1.html">grep man page</a> - Apple.com<br>  
<a href="awk.html">awk</a> - Find and Replace text within file(s)<br>
<a href="mdfind.html">mdfind</a> - 
Spotlight search<br>
<a href="tr.html">tr</a> - Translate, squeeze, and/or delete characters </p><!-- #BeginLibraryItem "/Library/foot_osx.lbi" --><p><script type="text/javascript"><!--
google_ad_client = "pub-6140977852749469";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "text_image";
google_ad_channel ="3133437331";
google_color_border = "CCCCCC";
google_color_bg = "CCCCCC";
google_color_link = "000000";
google_color_text = "333333";
google_color_url = "0000FF";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script></p>
<hr>
<div id=bl class="footer"><a href="grep.html#"><img src="../images/top.png" width="30" height="22" alt="Back to the Top"></a></div>
<div id=br class="footer, tagline">&copy; Copyright <a href="http://ss64.com/">SS64.com</a> 1999-2014<br>
Some rights reserved</div><!-- #EndLibraryItem --></body>
</html>