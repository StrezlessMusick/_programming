<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html dir="ltr" lang="ru"><head>
<title>man:screen — Xgu.ru</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="MediaWiki 1.16.2">
<link rel="canonical" href="http://xgu.ru/wiki/man:screen">
<link rel="alternate" type="application/x-wiki" title="Править" href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit">
<link rel="edit" title="Править" href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit">
<link rel="shortcut icon" href="http://xgu.ru/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://xgu.ru/w/opensearch_desc.php" title="Xgu.ru (ru)">
<link rel="alternate" type="application/atom+xml" title="Xgu.ru&nbsp;— Atom-лента" href="http://xgu.ru/w/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:RecentChanges&amp;feed=atom">
<link rel="stylesheet" href="man%20screen%20%E2%80%94%20Xgu.ru_files/shared.css" media="screen">
<link rel="stylesheet" href="man%20screen%20%E2%80%94%20Xgu.ru_files/commonPrint.css" media="print">
<link rel="stylesheet" href="man%20screen%20%E2%80%94%20Xgu.ru_files/main.css" media="screen">
<!--[if lt IE 5.5000]><link rel="stylesheet" href="/w/skins/monobook/IE50Fixes.css?270" media="screen" /><![endif]-->
<!--[if IE 5.5000]><link rel="stylesheet" href="/w/skins/monobook/IE55Fixes.css?270" media="screen" /><![endif]-->
<!--[if IE 6]><link rel="stylesheet" href="/w/skins/monobook/IE60Fixes.css?270" media="screen" /><![endif]-->
<!--[if IE 7]><link rel="stylesheet" href="/w/skins/monobook/IE70Fixes.css?270" media="screen" /><![endif]-->
<link rel="stylesheet" href="man%20screen%20%E2%80%94%20Xgu.ru_files/index_004.css">
<link rel="stylesheet" href="man%20screen%20%E2%80%94%20Xgu.ru_files/index_002.css" media="print">
<link rel="stylesheet" href="man%20screen%20%E2%80%94%20Xgu.ru_files/index.css">
<link rel="stylesheet" href="man%20screen%20%E2%80%94%20Xgu.ru_files/index_003.css">
<script>
var skin="monobook",
stylepath="/w/skins",
wgUrlProtocols="http\\:\\/\\/|https\\:\\/\\/|ftp\\:\\/\\/|irc\\:\\/\\/|gopher\\:\\/\\/|telnet\\:\\/\\/|nntp\\:\\/\\/|worldwind\\:\\/\\/|mailto\\:|news\\:|svn\\:\\/\\/",
wgArticlePath="/wiki/$1",
wgScriptPath="/w",
wgScriptExtension=".php",
wgScript="/w/index.php",
wgVariantArticlePath=false,
wgActionPaths={},
wgServer="http://xgu.ru",
wgCanonicalNamespace="",
wgCanonicalSpecialPageName=false,
wgNamespaceNumber=0,
wgPageName="man:screen",
wgTitle="man:screen",
wgAction="view",
wgArticleId=2750,
wgIsArticle=true,
wgUserName=null,
wgUserGroups=null,
wgUserLanguage="ru",
wgContentLanguage="ru",
wgBreakFrames=false,
wgCurRevisionId=32503,
wgVersion="1.16.2",
wgEnableAPI=true,
wgEnableWriteAPI=true,
wgSeparatorTransformTable=[",	.", " 	,"],
wgDigitTransformTable=["", ""],
wgMainPageTitle="Заглавная страница",
wgFormattedNamespaces={"-2": "Медиа", "-1": "Служебная", "0": "", "1": "Обсуждение", "2": "Участник", "3": "Обсуждение участника", "4": "Xgu.ru", "5": "Обсуждение Xgu.ru", "6": "Файл", "7": "Обсуждение файла", "8": "MediaWiki", "9": "Обсуждение MediaWiki", "10": "Шаблон", "11": "Обсуждение шаблона", "12": "Справка", "13": "Обсуждение справки", "14": "Категория", "15": "Обсуждение категории"},
wgNamespaceIds={"медиа": -2, "служебная": -1, "": 0, "обсуждение": 1, "участник": 2, "обсуждение_участника": 3, "xgu.ru": 4, "обсуждение_xgu.ru": 5, "файл": 6, "обсуждение_файла": 7, "mediawiki": 8, "обсуждение_mediawiki": 9, "шаблон": 10, "обсуждение_шаблона": 11, "справка": 12, "обсуждение_справки": 13, "категория": 14, "обсуждение_категории": 15, "участница": 2, "обсуждение участницы": 3, "изображение": 6, "обсуждение_изображения": 7, "image": 6, "image_talk": 7},
wgSiteName="Xgu.ru",
wgCategories=["Перевёл Игорь Чубин", "Русский man"],
wgMWSuggestTemplate="http://xgu.ru/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest",
wgDBname="wikidb",
wgSearchNamespaces=[0],
wgMWSuggestMessages=["с советами", "без советов"],
wgRestrictionEdit=[],
wgRestrictionMove=[];
</script><script src="man%20screen%20%E2%80%94%20Xgu.ru_files/wikibits.js"></script>
<script src="man%20screen%20%E2%80%94%20Xgu.ru_files/ajax.js"></script>
<script src="man%20screen%20%E2%80%94%20Xgu.ru_files/mwsuggest.js"></script>
<script src="man%20screen%20%E2%80%94%20Xgu.ru_files/index.php"></script>

</head>
<body class="mediawiki ltr ns-0 ns-subject page-man_screen skin-monobook"><div style="visibility: hidden; position: absolute; overflow: hidden; padding: 0px; width: 0px; left: 0px; top: 0px;" id="WzTtDiV"></div>
<div id="globalWrapper">
<div id="column-content"><div id="content">
	<a id="top"></a>
	
	<h1 id="firstHeading" class="firstHeading">man:screen</h1>
	<div id="bodyContent">
		<h3 id="siteSub">Материал из Xgu.ru</h3>
		<div id="contentSub">(Перенаправлено с <a href="http://xgu.ru/w/index.php?title=Man:screen&amp;redirect=no" title="Man:screen">Man:screen</a>)</div>
		<div id="jump-to-nav">Перейти к: <a href="#column-one">навигация</a>, <a href="#searchInput">поиск</a></div>
		<!-- start content -->
<script src="man%20screen%20%E2%80%94%20Xgu.ru_files/wz_tooltip.js"></script><p>Перевод: <a href="http://xgu.ru/wiki/%D0%A3%D1%87%D0%B0%D1%81%D1%82%D0%BD%D0%B8%D0%BA:Igorchubin" title="Участник:Igorchubin">Игорь Чубин</a><br>
<a href="http://linux.die.net/man/1/screen" class="external free" rel="nofollow">http://linux.die.net/man/1/screen</a>
</p><p>Эта страница является переводом официальной man-страницы программы <a href="http://xgu.ru/wiki/GNU_Screen" title="GNU Screen">GNU Screen</a>,
текстового оконного менеджера, эмулирующего терминал VT100/ANSI.
</p><p><br>
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Содержание</h2> <span class="toctoggle">[<a href="javascript:toggleToc()" class="internal" id="togglelink">убрать</a>]</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#.D0.98.D0.BC.D1.8F"><span class="tocnumber">1</span> <span class="toctext">Имя</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#.D0.A1.D0.B8.D0.BD.D1.82.D0.B0.D0.BA.D1.81.D0.B8.D1.81"><span class="tocnumber">2</span> <span class="toctext">Синтаксис</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#.D0.9E.D0.BF.D0.B8.D1.81.D0.B0.D0.BD.D0.B8.D0.B5"><span class="tocnumber">3</span> <span class="toctext">Описание</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#.D0.A1_.D1.87.D0.B5.D0.B3.D0.BE_.D0.BD.D0.B0.D1.87.D0.B0.D1.82.D1.8C.3F"><span class="tocnumber">4</span> <span class="toctext">С чего начать?</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#.D0.9E.D0.BF.D1.86.D0.B8.D0.B8_.D0.BA.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D0.BD.D0.BE.D0.B9_.D1.81.D1.82.D1.80.D0.BE.D0.BA.D0.B8"><span class="tocnumber">5</span> <span class="toctext">Опции командной строки</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#.D0.9F.D1.80.D0.B8.D0.B2.D1.8F.D0.B7.D0.BA.D0.B8_.D0.BA.D0.BB.D0.B0.D0.B2.D0.B8.D1.88"><span class="tocnumber">6</span> <span class="toctext">Привязки клавиш</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#.D0.98.D0.BD.D0.B4.D0.B8.D0.B2.D0.B8.D0.B4.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D0.B0.D1.8F_.D0.BD.D0.B0.D1.81.D1.82.D1.80.D0.BE.D0.B9.D0.BA.D0.B0"><span class="tocnumber">7</span> <span class="toctext">Индивидуальная настройка</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#.D0.A1.D1.82.D1.80.D0.BE.D0.BA.D0.B0_.D1.81.D0.BE.D0.BE.D0.B1.D1.89.D0.B5.D0.BD.D0.B8.D0.B9"><span class="tocnumber">8</span> <span class="toctext">Строка сообщений</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#.D0.A2.D0.B8.D0.BF.D1.8B_.D0.BE.D0.BA.D0.BE.D0.BD"><span class="tocnumber">9</span> <span class="toctext">Типы окон</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#Escape-.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D1.81.D1.82.D0.B8"><span class="tocnumber">10</span> <span class="toctext">Escape-последовательности</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#.D0.A3.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BC"><span class="tocnumber">11</span> <span class="toctext">Управление потоком</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#.D0.9D.D0.B0.D0.B7.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F_.28.D0.B8.D0.BC.D0.B5.D0.BD.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BE.D0.BA.D0.BE.D0.BD.29"><span class="tocnumber">12</span> <span class="toctext">Названия (именование окон)</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#.D0.92.D0.B8.D1.80.D1.82.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B9_.D1.82.D0.B5.D1.80.D0.BC.D0.B8.D0.BD.D0.B0.D0.BB"><span class="tocnumber">13</span> <span class="toctext">Виртуальный терминал</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#.D0.A2.D1.80.D0.B0.D0.BD.D1.81.D0.BB.D1.8F.D1.86.D0.B8.D1.8F_.D0.BF.D1.80.D0.B8_.D0.B2.D0.B2.D0.BE.D0.B4.D0.B5"><span class="tocnumber">14</span> <span class="toctext">Трансляция при вводе</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#.D0.A1.D0.BF.D0.B5.D1.86.D0.B8.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.B2.D0.BE.D0.B7.D0.BC.D0.BE.D0.B6.D0.BD.D0.BE.D1.81.D1.82.D0.B8_.D1.82.D0.B5.D1.80.D0.BC.D0.B8.D0.BD.D0.B0.D0.BB.D0.B0"><span class="tocnumber">15</span> <span class="toctext">Специальные возможности терминала</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#.D0.9F.D1.80.D0.B5.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BA.D0.BE.D0.B4.D0.B8.D1.80.D0.BE.D0.B2.D0.BA.D0.B8_.D1.81.D0.B8.D0.BC.D0.B2.D0.BE.D0.BB.D0.BE.D0.B2"><span class="tocnumber">16</span> <span class="toctext">Преобразование кодировки символов</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="#.D0.9F.D0.B5.D1.80.D0.B5.D0.BC.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.BE.D0.BA.D1.80.D1.83.D0.B6.D0.B5.D0.BD.D0.B8.D1.8F"><span class="tocnumber">17</span> <span class="toctext">Переменные окружения</span></a></li>
<li class="toclevel-1 tocsection-18"><a href="#.D0.A4.D0.B0.D0.B9.D0.BB.D1.8B"><span class="tocnumber">18</span> <span class="toctext">Файлы</span></a></li>
<li class="toclevel-1 tocsection-19"><a href="#.D0.A1.D0.BC._.D1.82.D0.B0.D0.BA.D0.B6.D0.B5"><span class="tocnumber">19</span> <span class="toctext">См. также</span></a></li>
<li class="toclevel-1 tocsection-20"><a href="#.D0.90.D0.B2.D1.82.D0.BE.D1.80.D1.8B"><span class="tocnumber">20</span> <span class="toctext">Авторы</span></a></li>
<li class="toclevel-1 tocsection-21"><a href="#COPYLEFT"><span class="tocnumber">21</span> <span class="toctext">COPYLEFT</span></a></li>
<li class="toclevel-1 tocsection-22"><a href="#.D0.92.D0.BA.D0.BB.D0.B0.D0.B4"><span class="tocnumber">22</span> <span class="toctext">Вклад</span></a></li>
<li class="toclevel-1 tocsection-23"><a href="#.D0.92.D0.B5.D1.80.D1.81.D0.B8.D1.8F"><span class="tocnumber">23</span> <span class="toctext">Версия</span></a></li>
<li class="toclevel-1 tocsection-24"><a href="#.D0.94.D0.BE.D1.81.D1.82.D1.83.D0.BF.D0.BD.D0.BE.D1.81.D1.82.D1.8C"><span class="tocnumber">24</span> <span class="toctext">Доступность</span></a></li>
<li class="toclevel-1 tocsection-25"><a href="#.D0.91.D0.B0.D0.B3.D0.B8"><span class="tocnumber">25</span> <span class="toctext">Баги</span></a></li>
</ul>
</td></tr></tbody></table><script>if (window.showTocToggle) { var tocShowText = "показать"; var tocHideText = "убрать"; showTocToggle(); } </script>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=1" title="Править секцию: Имя">править</a>]</span> <span class="mw-headline" id=".D0.98.D0.BC.D1.8F"> Имя </span></h2>
<p>screen — оконный менеджер с эмуляцией терминала VT100/ANSI
</p>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=2" title="Править секцию: Синтаксис">править</a>]</span> <span class="mw-headline" id=".D0.A1.D0.B8.D0.BD.D1.82.D0.B0.D0.BA.D1.81.D0.B8.D1.81"> Синтаксис </span></h2>
<pre>      screen [ -options ] [ cmd [ args ] ]
      screen -r [[pid.]tty[.host]]
      screen -r sessionowner/[[pid.]tty[.host]]
</pre>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=3" title="Править секцию: Описание">править</a>]</span> <span class="mw-headline" id=".D0.9E.D0.BF.D0.B8.D1.81.D0.B0.D0.BD.D0.B8.D0.B5"> Описание </span></h2>
<p>Screen это полноэкранный оконный менеджер, который мультиплексирует физический терминал 
между несколькими процессами (обычно, интерактивными оболочками).
Каждый терминал обладает функциональностью терминала DEC VT100
и некоторыми управляющими функциями из стандартов ISO 6429 (ECMA 49, ANSI X3.64) 
и ISO 2022 (вставка/удаление строки и поддержка множеств символов).
Для каждого виртуального терминала есть буфер истории и механизм обмена, позволяющий
копировать текст между окнами.
</p><p>При вызове screen создаёт отдельное окно, в котором запускает оболочку командного интерпретатора
(или заданную программу), и вы можете работать с ней как и обычно.
Потом, в любое время, можно создавать новые (полноэкранные) окна,
в которых будут исполняться другие программы (в том числе различные оболочки),
закрывать существующие окна, просматривать список окон, включать/выключать запись,
просматривать буфер прокрутки, переключаться между окнами самыми разнообразными способами
и выполнять множество других действий.
Все окна работают полностью независимо друг от друга.
Программы продолжают работать, даже если они невидимы в настоящий момент,
или вообще весь сеанс screen полностью отключён от терминала пользователя.
Когда программа завершается, screen (по умолчанию) закрывает то окно, 
в котором она исполнялась. Если это окно было активным, screen активирует предыдущее;
если окон не осталось, screen завершается.
</p><p>Всё, что вы набираете внутри screen, отправляется программе, работающей
в текущем окне.  Единственное исключение --- комбинация клавиш,   которая
показывает, что сейчас вы  хотите работать с самим оконным  менеджером.
По умолчанию, команды работы с оконным менеджером  начинаются  нажатием
Control-a (далее C-a), за которым следует  нажатие одной  клавиши.  Эта
и другие управляющие комбинации могут быть настроены иначе, но они
обязательно должны состоять из двух символов.
</p><p>Программа screen не понимает префикс "C-" как обозначение нажатия Ctrl.
Вместо этого нужно использовать запись с символом ^ (например, ^A вместо C-a).
Это может пригодиться,  например,  как аргумент опции -e.  Кроме этого,
управляющие символы screen выводит в этом же формате.
</p><p>Стандартный способ создать новое окно --- нажать "C-a c".
Окно создаётся мгновенно, и screen сразу же делает его активным, независимо
от того, в каком состоянии находится процесс, выполняющийся в текущем окне.
Аналогично можно создавать новые окна, в которых будет выполняться какая-то своя команда.
Для этого сначала нужно привязать команду к комбинации клавиш (это делается через
конфигурационный файл <tt>.screenrc</tt> или через режим командной строки <i>C-a&nbsp;:</i>,
а потом, когда будет нужно, просто использовать эту комбинацию клавиш.
Кроме всего прочего, новые окна можно создавать при помощи команды:
</p>
<pre>   screen emacs prog.c
</pre>
<p>которая вызывается в командном интерпретаторе, работающем внутри screen.
Новая копия screen создаваться не будет, а вместо этого команда будет передана
текущему менеджеру (информация о том кто именно является текущим менеджером
находится в переменной окружения <tt>$STY</tt>), который и создаст 
новое окно.
В приведённом выше примере запускается редактор <i>emacs</i> (в котором открывается prog.c)
и окно с этим редактором становится активным.
</p><p>Если файл <tt>/var/run/utmp</tt> доступен screen для изменения, 
он сделает соответствующие записи для каждого окна при их создании, 
и удалит при их закрытии. Это очень полезно при использовании
таких программ как <i>talk</i>, <i>script</i>, <i>shutdown</i>, <i>rsend</i>, <i>sccs</i>
и многими другими, которые используют файл <tt>utmp</tt>,
для того чтобы определить кто вы (то есть, какой пользователь работает с каким терминалом).
До тех пор пока screen активен на терминале, запись про собственно этот 
терминал удаляется. Также смотрите <i>C-a L</i>.
</p>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=4" title="Править секцию: С чего начать?">править</a>]</span> <span class="mw-headline" id=".D0.A1_.D1.87.D0.B5.D0.B3.D0.BE_.D0.BD.D0.B0.D1.87.D0.B0.D1.82.D1.8C.3F"> С чего начать? </span></h2>
<p>Перед тем как приступить к работе  со  screen'ом,  нужно убедиться, что
установлен правильный тип терминала (как и для других программ, которые
используют termcap/terminfo). Это можно сделать,   например,   с помощью
программы <b>tset</b>.
</p><p>Если вы хотите побыстрее  начать  работу со screen  и  не углубляться в
долгое чтение,  вам нужно запомнить только одну команду: "C-a&nbsp;?".  Если
нажать эту комбинацию  клавиш,  будет показан список  доступных  команд
screen и привязок комбинаций  клавиш  к  ним.  Каждая комбинация клавиш
обсуждается   в  разделе  <a href="#.D0.9F.D1.80.D0.B8.D0.B2.D1.8F.D0.B7.D0.BA.D0.B8_.D0.BA.D0.BB.D0.B0.D0.B2.D0.B8.D1.88">Привязки клавиш</a>.  Раздел <a href="#.D0.98.D0.BD.D0.B4.D0.B8.D0.B2.D0.B8.D0.B4.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D0.B0.D1.8F_.D0.BD.D0.B0.D1.81.D1.82.D1.80.D0.BE.D0.B9.D0.BA.D0.B0">Индивидуальная настройка</a> рассказывает о том, что может быть в  конфигурационном файле
<tt>.screenrc</tt>.
</p><p>Если ваш терминал — это настоящий терминал с авто-отступом (auto-marign)
(не позволяет обновить последнюю позицию экрана без прокрутки), возможно
вам стоит использовать такую версию termcap  для  вашего  терминала,  в
которой автоматические отступы выключены.  В этом случае  screen  будет
правильно обновлять экран при любых обстоятельствах. Сегодня у большинства
терминалов есть  волшебные  отступы  (magic margins) — автоматические
отступы и используемая последняя колонка, что соответствует стилю VT100
и отлично подходит для screen. Если у вас терминал с авто-отступами, 
screen может его использовать, но обновление последнего символа в строке
может быть невозможным без прокрутки или перемещения символа в другую
позицию  каким-то  иным  способом.  Задержку, связанную  с  этим, можно
сократить, если использовать терминал, у которого есть возможность 
вставки символов.
</p>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=5" title="Править секцию: Опции командной строки">править</a>]</span> <span class="mw-headline" id=".D0.9E.D0.BF.D1.86.D0.B8.D0.B8_.D0.BA.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D0.BD.D0.BE.D0.B9_.D1.81.D1.82.D1.80.D0.BE.D0.BA.D0.B8"> Опции командной строки </span></h2>
<p>У программы <i>screen</i> такие ключи командной строки:
</p>
<dl><dt> <b>-a</b>
</dt><dd> включать все возможности (за некоторыми небольшими 
исключениями) в termcap каждого окна, даже если screen должен 
перерисовывать часть экрана для реализации функции.
</dd></dl>
<dl><dt> <b>-A</b>
</dt><dd>    Адаптирует  размеры  всех  окон  под  размер  текущего  
терминала.  По умолчанию screen пытается восстановить старый размер окна
 (при подключении к терминалам с изменяемыми размерами (те у кого  есть 
"WS" в описании, например, suncmd или xterm). 
</dd></dl>
<dl><dt> <b>-c</b> <i>file</i>
</dt><dd>    использовать <i>file</i> вместо стандартного "$HOME/.screenrc" в качестве конфигурационного
</dd></dl>
<dl><dt> <b>-d</b>|<b>-D</b> [<i>pid.tty.host</i>]
</dt><dd>    не запускает новый сеанс,  а отключает вместо этого уже 
запущенный ранее.  Достигается тот же эффект, что и в с случае нажатия 
клавиш "C-a d" на управляющем терминале screen. Ключ -D эквивалентен 
ключу power detach. Если ни к одному сеансу  нельзя  обратиться,   опция
 игнорируется.  В связке с -r/-R могут быть достигнуты другие более 
интересные эффекты:
</dd></dl>
<dl><dt> <b>-d -r</b>
</dt><dd> Подключить к сеансу, и если необходимо, сначала отключить его.
</dd></dl>
<dl><dt> <b>-d -R</b>
</dt><dd> Переподключиться к сеансу. Если необходимо — сначала  отключить или создать сеанс.
</dd></dl>
<dl><dt> <b>-d -RR</b>
</dt><dd> Переподключиться к сеансу. Если необходимо — сначала  
отключить или создать сеанс.  Воспользоваться первой сессией, если 
больше одной сессии создать нельзя.
</dd></dl>
<dl><dt> <b>-D -r</b>
</dt><dd> Подключиться к сеансу. Если необходимо, сначала отключить его удалённо и разрегистрироваться.
</dd></dl>
<dl><dt> <b>-D -R</b>   
</dt><dd> Подключиться здесь и сейчас. Это значит: если сессия  
работает, переподключиться. Если необходимо, сначала отключиться 
удалённо.  Если не работала — создать  и  сообщить  об  этом 
пользователю.  Любимый ключ авторов.
</dd></dl>
<dl><dt> <b>-D -RR</b>
</dt><dd> Подключиться прямо сейчас.  Не важно, что будет, просто сделать это. 
</dd><dd> Замечание: хорошая идея всегда проверять состояние сеансов screen с помощью "screen -list"
</dd></dl>
<dl><dt>  <b>-e</b> <i>xy</i>
</dt><dd>    Устанавливает  управляющий  символ равным <i>x</i> и  символ, который генерирует сам этот символ в <i>y</i>
 (после ввода командного символа).  По умолчанию это "C-a" и "a",  что 
можно явным образом указать как "-e^Aa".  При  создании  сеанса  screen 
 эта  опция  устанавливает управляющий символ. В многопользовательских 
сеансах все добавляемые пользователи будут использовать указанный 
символ.  При подключении к существующей сессии,  опция меняет 
управляющий символ только для пользователя, выполняющего подключение. 
Опция эквивалентна командам "defescape" и "escape" соответственно.  
</dd></dl>
<dl><dt> <b>-f</b>, <b>-fn</b> и <b>-fa</b>
</dt><dd>     включить,   выключить   или   перевести   в  
автоматический  режим flow-control.  Аналогичный результат достигается с
 помощью команды "defflow" конфигурационного файла.
</dd></dl>
<dl><dt> <b>-h</b> <i>num</i>
</dt><dd>    Установить размер истории буфера прокрути равным <i>num</i> строк.
</dd></dl>
<dl><dt> <b>-i</b>
</dt><dd> приводит к тому что клавиша прерывания (C-c) срабатывает мгновенно если включено аппаратное управление потоком. См. команду <b>defflow</b>.  Использование этой опции не рекомендуется.
</dd></dl>
<dl><dt> <b>-l</b> и <b>-ln</b>
</dt><dd>    Включает или выключает login-режим (для обновления /var/run/utmp).  Это же можно задать с помощью команды <b>deflogin</b> в файле <tt>~/.screenrc</tt>
</dd></dl>
<dl><dt> <b>-ls</b> и <b>-list</b>
</dt><dd>    не запускает screen, а показывает вместо этого список 
идентифицирующих сеансы screen строк pid.tty.host.  Сеансы, которые 
отмечены словом "detached" могут быть продолжены  с помощью  команды  
"screen -r".  Сеансы, которые отмечены словом "attached", работают, и у 
них есть управляющий терминал. Если сеанс  работает в 
многопользовательском режиме, он отмечен словом "multi". Сеансы, которые
 отмечены словом "unreachable" или работают на другом хосте, или умерли 
(dead).  Недоступный  (unreachable)  сеанс  считается мёртвым, если его 
имя соответствует или имени локального хоста, или указанному параметру 
(если такой есть).  Как описывать строки для выбора рассказывается в 
описании ключа -r. Сеансы, отмеченные как "dead", нужно проверить и 
удалить. Если вы не уверены, нужно ли удалять какой-то сеанс, вы можете 
обратиться к системному администратору (если это не вы сами, иначе может
 возникнуть бесконечная рекурсия).  Удалить сеансы можно с помощью опции
 -wipe.  
</dd></dl>
<dl><dt> <b>-L</b>
</dt><dd> Включить автоматическую запись (logging) для окон.
</dd></dl>
<dl><dt> <b>-m</b>
</dt><dd> Заставляет   screen   игнорировать  переменную окружения $TTY.
  При использовании "screen -m" создаётся новый сеанс, независимо от 
того вызывается ли screen изнутри другого сеанса screen  или  нет.  Этот
 флаг имеет особое значение, если вызывается с опцией:
</dd></dl>
<dl><dt> <b>-d -m</b>
</dt><dd> Запустить сеанс в "отключенном" режиме. Сессия создаётся, но  к
 ней  не  выполняется  подключение.  Это полезно для загрузочных 
системных скриптов.
</dd></dl>
<dl><dt> <b>-D -m</b>
</dt><dd> Тоже запускает <i>screen</i> в "отключенном" режиме, но не создаёт новый процесс. Команда завершается, если сессия прерывается.
</dd></dl>
<dl><dt> <b>-O</b>
</dt><dd> использует более оптимальный режим вывода вашим терминалом,  
чем в случае  с  обычной  эмуляцией VT100  (касается  только auto-margin
 терминалов без поддержки LP). Такого же результата можно  достичь, если
 установить OP в команде termcap.
</dd></dl>
<dl><dt> <b>-p</b> <i>number_or_name</i>
</dt><dd> Заранее выбирает окно. Полезно, когда вы  хотите  
переподключиться к конкретному окну или если вы хотите с помощью опции 
-X отправить команду в конкретное окно.  Как и в случае с командой 
select, знак "-" означает пустое окно.  Если вместо номера указать 
символ =, то при подключении появится меню windowlist с списком окон.
</dd></dl>
<dl><dt> <b>-q</b>
</dt><dd> Подавляет вывод сообщений об ошибках. В сочетании с "-ls" 
возвращает код завершения: 9 - нет каталога с сеансами; 10 - каталог 
есть, но нет сеансов, к которым можно подключиться. 11 (или больше) 
говорит что есть 1 (или больше) рабочий сеанс. В сочетании с "-r" 
возвращает код завершения: 10 - нет сеансов, которые можно возобновить; 
12 (или больше) что есть 2 (или больше) сеанса, работу которых можно 
возобновить, и  нужно  выбрать  какой-то  один.  Во всех остальных 
случаях ключ "<tt>-q</tt>" эффекта не имеет.  
</dd></dl>
<dl><dt> <b>-r</b> [<i>pid.tty.host</i>]
</dt><dt> <b>-r</b> <i>sessionowner</i>/[<i>pid.tty.host</i>]
</dt><dd>    возобновляет работу отключённого сеанса. Никакие другие опции  (за исключением комбинаций  с <tt>-d</tt>/<tt>-D</tt>  не  допускаются).  Необязательный параметр [<i>pid</i>.]<i>tty.host</i>
 может указываться для того чтобы определить какой именно сеанс из 
множества отключённых имеется в виду. Вторая форма используется для 
подключения к работающему в многопользовательском режиме сеансу другого 
пользователя.  Эта опция говорит о том,  что файл нужно искать в 
каталоге другого пользователя. Требует наличия бита setuid-root у 
программы screen.
</dd></dl>
<dl><dt> <b>-R</b>
</dt><dd> пытается  возобновить  работу   первого  попавшегося  
отключённого сеанса.   Если попытка успешная, все остальные аргументы 
командной строки  игнорируются.  Если  отключённых  сеансов  нет,  
запускает новый сеанс с учётом заданных опций, так как будто <tt>-R</tt>
  вообще и не указано.  Эта  опция  подразумевается  по  умолчанию, 
когда screen вызывается как login-оболочка (если быть точным,  то в этом
 случае подразумеваются опции "<tt>-xRR</tt>"). О том, что происходит, если вызвать screen в сочетании с опциями <tt>-d</tt>/<tt>-D</tt>, написано в описании этих опций.
</dd></dl>
<dl><dt> <b>-s</b>
</dt><dd> устанавливает оболочку по умолчанию равной заданной программе 
(без опции в качестве оболочки по умолчанию используется программа, что 
указана в $SHELL или "/bin/sh", если никакая не указана). Такой же 
эффект  может  быть  получен  с  помощью  команды <b>shell</b> в файле ".screenrc".
</dd></dl>
<dl><dt> <b>-S</b> <i>sessionname</i>
</dt><dd>    Эта опция может  использоваться  для задания  имени сеансу 
при его создании.  Имя  используется  для  идентификации при вызове 
"screen -list"  и  "screen -r".  Оно  заменяет постфикс "tty.host", 
использующийся по умолчанию.
</dd></dl>
<dl><dt> <b>-t</b> <i>name</i>
</dt><dd>    установить заголовок для командного интерпретатора или указанной программы. См. также команду <i>shelltitle</i> для .screenrc.
</dd></dl>
<dl><dt> <b>-U</b>
</dt><dd> Запустить <i>screen</i> в режиме UTF-8. Эта опция говорит <i>screen</i>, что терминал посылает и понимает символы в кодировке UTF-8. Этот ключ также устанавливает кодировку по умолчанию для окон <tt>utf8</tt>.
</dd></dl>
<dl><dt> <b>-v</b>
</dt><dd>   Показать номер версии.
</dd></dl>
<dl><dt> <b>-wipe</b> [<i>match</i>]
</dt><dd>    работает также как "screen -ls", только удаляет файлы 
уничтоженных сеансов вместо того чтобы помечать их как "dead" (мёртвые).
 Сеанс, который   не   отвечает,   считается   мёртвым,  или  если его 
имя соответствует имени локального хоста, или указанному явно параметру <i>match</i>. См. описание ключа -r, где рассказаны правила составления <i>match</i>.
</dd></dl>
<dl><dt> <b>-x</b>
</dt><dd> Подключиться к активной (not detached) сессии screen. (Многодисплейный режим).
</dd></dl>
<dl><dt> <b>-X</b>
</dt><dd> Отправить  указанную  команду  в  работающий  сеанс  screen.  Можно указать ключ <tt>-d</tt> или <tt>-r</tt>,
 чтобы screen смотрел только на подключённые (attached) или отключённые 
(detached) сеансы.  Обратите внимание на то, что команда не сработает, 
если сеанс защищён с помощью пароля.
</dd></dl>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=6" title="Править секцию: Привязки клавиш">править</a>]</span> <span class="mw-headline" id=".D0.9F.D1.80.D0.B8.D0.B2.D1.8F.D0.B7.D0.BA.D0.B8_.D0.BA.D0.BB.D0.B0.D0.B2.D0.B8.D1.88"> Привязки клавиш </span></h2>
<p>Каждая управляющая последовательность screen состоит из комбинации "C-a",
за которой идёт один символ.  Для удобства все команды, которые привязаны
к символу в нижнем регистре также привязаны к комбинации этого символа с
Ctrl (за исключением "C-a a"; см. ниже). Так, например, "C-a c" работает
также как "C-a C-c" — создаёт новое  окно.  См.  раздел  <a href="#.D0.98.D0.BD.D0.B4.D0.B8.D0.B2.D0.B8.D0.B4.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D0.B0.D1.8F_.D0.BD.D0.B0.D1.81.D1.82.D1.80.D0.BE.D0.B9.D0.BA.D0.B0">Индивидуальная настройка</a> для описания команд.
</p><p>В таблице показаны привязки клавиш по умолчанию:
</p>
<pre>      C-a '       (select)      Спросить название или имя окна, в которое нужно
                                переключиться.
</pre>
<pre>      C-a "       (windowlist -b)
                                Представить список всех окон для выбора.
</pre>
<pre>      C-a 0       (select 0)
       ...           ...
      C-a 9       (select 9)
      C-a -       (select -)    Переключиться в окно с номером 0  -  9 или в пустое окно.
</pre>
<pre>      C-a tab     (focus)       Переключить фокус ввода на следующий регион.
</pre>
<pre>      C-a C-a     (other)       Переключиться в ранее активное окно.
                                (по умолчанию команда привязана к управляющему символу, 
                                нажатому дважды — например, если вы вызовите screen
                                с опцией "-e]x", команда будет вызываться символами "]]").
</pre>
<pre>      C-a a       (meta)        Отправить C-a в окно. См. также команду <b>escape</b>
</pre>
<pre>      C-a A       (title)       Ввести заголовок текущего окна.
</pre>
<pre>      C-a b
      C-a C-b     (break)       Отправить break в окно.
</pre>
<pre>      C-a B       (pow_break)   Повторно открыть терминальную линию и отправить break.
</pre>
<pre>      C-a c
      C-a C-c     (screen)      Создать новое окно с запущенным интерпретатором
                                и переключиться в это окно.
</pre>
<pre>      C-a C       (clear)       Очистить экран.
</pre>
<pre>      C-a d
      C-a C-d     (detach)      Отключить screen от этого терминала.
</pre>
<pre>      C-a D D     (pow_detach)  Отключиться и разрегистрироваться.
</pre>
<pre>      C-a f
      C-a C-f     (flow)        Включить/выключить/перевести в автоматический режим 
                                управление потоком (flow control).
</pre>
<pre>      C-a F       (fit)         Изменить размер окна под размер текущего региона.
</pre>
<pre>      C-a C-g     (vbell)       Переключить режим visual-bell 
</pre>
<pre>      C-a h       (hardcopy)    Записать копию текущего окна в файл "hardcopy.n".
</pre>
<pre>      C-a H       (log)         Начать/закончить запись сессии работы в текущем окне в файл
                                "screenlog.n".
</pre>
<pre>      C-a i
      C-a C-i     (info)        Показать информацию о текущем окне.
</pre>
<pre>      C-a k
      C-a C-k     (kill)        Уничтожить текущее окно.
</pre>
<pre>      C-a l
      C-a C-l     (redisplay)   Полностью обновить текущее окно.
</pre>
<pre>      C-a L       (login)       Переключить login-запись этого окна. Доступно только в случае, 
                                когда screen настроен на обновление базы utmp.
</pre>
<pre>      C-a m
      C-a C-m     (lastmsg)     Повторить последнее сообщение, показанное в строке сообщений.
</pre>
<pre>      C-a M       (monitor)     Включить/выключить мониторинг в текущем окне.
</pre>
<pre>      C-a space
      C-a n
      C-a C-n     (next)        Переключиться на следующее окно.
</pre>
<pre>      C-a N       (number)      Показать номер (и заголовок) текущего окна.
</pre>
<pre>      C-a backspace
      C-a h
      C-a p
      C-a C-p     (prev)        Переключиться на предыдущее окно (противоположно C-a n).
</pre>
<pre>      C-a q
      C-a C-q     (xon)         Отправить CTRL-q в текущее окно.
</pre>
<pre>      C-a Q       (only)        Удалить все регионы за исключением текущего.
</pre>
<pre>      C-a r
      C-a C-r     (wrap)        Включить/выключить настройку line-wrap текущего окна
                                (включает и выключает автоматические отступы (automatic margins))
</pre>
<pre>      C-a s
      C-a C-s     (xoff)        Отправить control-s в текущее окно.
</pre>
<pre>      C-a S       (split)       Разделить текущий регион на два новых.
</pre>
<pre>      C-a t
      C-a C-t     (time)        Показать информацию о системе.
</pre>
<pre>      C-a v       (version)     Показать версию и дату сборки.
</pre>
<pre>      C-a C-v     (digraph)     Ввести диграф.
</pre>
<pre>      C-a w
      C-a C-w     (windows)     Показать список окон.
</pre>
<pre>      C-a W       (width)       Переключить количество колонок: 80/132
</pre>
<pre>      C-a x
      C-a C-x     (lockscreen)  Заблокировать текущий терминал.
</pre>
<pre>      C-a X       (remove)      Закрыть текущий регион.
</pre>
<pre>      C-a z
      C-a C-z     (suspend)     Приостановить (suspend) screen. Система должна поддерживать 
                                управление работами (job-control) в стиле BSD.
</pre>
<pre>      C-a Z       (reset)       Сбросить виртуальные терминалы в их исходные значения.
</pre>
<pre>      C-a .       (dumptermcap) Записать файл ".termcap"
</pre>
<pre>      C-a&nbsp;?       (help)        Показать привязки клавиш.
</pre>
<pre>      C-a C-\     (quit)        Закрыть все окна и завершить screen.
</pre>
<pre>      C-a&nbsp;:       (colon)       Перейти в режим ввода командной строки screen.
</pre>
<pre>      C-a [
      C-a C-[
      C-a esc     (copy)        Перейти в режим копирования/прокрутки.
</pre>
<pre>      C-a ]       (paste .)     Записать содержимое буфера обмена в стандартный поток 
                                ввода текущего окна.
</pre>
<pre>      C-a {
      C-a }       (history)     Скопировать и вставить предыдущую командную строку.
</pre>
<pre>      C-a &gt;       (writebuf)    Записать буфер обмена в файл.
</pre>
<pre>      C-a &lt;       (readbuf)     Прочитать файл обмена (screen-exchange) в буфер обмена. 
</pre>
<pre>      C-a =       (removebuf)   Удалить файл, использующийся вместе с C-a &lt; и C-a &gt;.
</pre>
<pre>      C-a ,       (license)     Показать информацию о программе GNU Screen.
</pre>
<pre>      C-a _       (silence)     Включить/выключить режим слежения за неактивностью текущего окна.
</pre>
<pre>      C-a *       (displays)    Показать список всех подключенных сейчас дисплеев.
</pre>
<hr>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=7" title="Править секцию: Индивидуальная настройка">править</a>]</span> <span class="mw-headline" id=".D0.98.D0.BD.D0.B4.D0.B8.D0.B2.D0.B8.D0.B4.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D0.B0.D1.8F_.D0.BD.D0.B0.D1.81.D1.82.D1.80.D0.BE.D0.B9.D0.BA.D0.B0"> Индивидуальная настройка </span></h2>
<p>По умолчанию каталог для сокетов (socket directory) это или $HOME/.screen, 
или /tmp/screens, или, скорее всего, /var/run/screen; задаётся при компиляции.
Если screen имеет бит setuid-root, каталог для сокетов
обязательно должен находиться не на NFS-разделе. Если screen не имеет бита setuid, 
пользователь может указывать каталог через переменную <tt>$SCREENDIR</tt>.
У этого каталога должен быть режим доступа 700.
</p><p><br>
При вызове screen исполняет настроечные команды из файла <tt>/etc/screenrc</tt>
и файла <tt>.screenrc</tt>, что расположен в домашнем каталоге.
Имена этих файлов — настройки по умолчанию, которые можно перекрыть 
одним из следующих способов:
глобальный настроечный файл указывается 
при помощи переменной окружения <tt>$SYSSCREENRC</tt> (эта возможность может 
быть отключена при компиляции),
пользовательский настроечный файл ищется по пути, указанном в <tt>$SCREENRC</tt>,
и в файле <tt>$HOME/.screenrc</tt>. Есть ещё опция командной строки <tt>-c</tt>,
которая имеет приоритет над перечисленными выше настройками имён конфигурационных файла.
</p><p>Команды в этих файлах используются для того чтобы задавать опции, привязывать
действия к функциональным клавишам, открывать несколько окон при старте сеанса screen.
Команды записываются по одной в строке. Пустые строки игнорируются.
Аргументы команд разделяются табуляцией или пробелами и могут объединяться с помощью
двойных кавычек. Строки, которые нельзя распознать, игнорируются. При этом для каждой такой строки
выдаётся предупреждение.
В командах могут использоваться ссылки на переменные окружения. Синтаксис такой же 
как в командном интерпретаторе: <tt>$VAR</tt> или <tt>${VAR}</tt>. Обратите внимание, 
что этот способ записи несовместим с предыдущими версиями screen, потому что сейчас 
символ $, если мы хотим передать именно его, нужно экранировать с помощью символа <tt>\</tt>.
От подстановки переменных также защищают одинарные кавычки.
</p><p>В дистрибутив входит два конфигурационных файла-примера: <tt>etc/etcscreenrc</tt>
и <tt>etc/screenrc</tt>. В этих файлах есть много хороших примеров различных конфигурационных
команд GNU Screen.
</p><p>Настраивать GNU Screen можно и в on-line режиме. Для того чтобы перейти в режим командной строки,
нажмите <tt>C-a&nbsp;:</tt>. Команды, начинающиеся с "def" меняют настройки по умолчанию,
а остальные меняют текущие настройки.
</p><p>Доступны следующие команды:
</p>
<dl><dt> <b>acladd</b> <i>usernames</i> [<i>crypted-pw</i>]
</dt><dt> <b>addacl</b> <i>usernames</i>
</dt><dd> Даёт пользователю возможность получения доступа к сеансу screen. В качестве параметра <i>usernames</i>
 может задаваться имя пользователя или имена нескольких пользователей, 
разделённых запятыми. Команда разрешает подключаться к screen и в том 
числе выполняет действия аналогичные действию команды <i>aclchg usernames +rwx "#?"</i>. Для того чтобы добавить пользователя с ограниченным доступом, нужно использовать команду <i>aclchg</i> указанную ниже.  В качестве опционального параметра <i>crypted-pw</i> может указываться зашифрованный пароль для заданного пользователя.  Команда <i>addacl</i> --- синоним команды <i>acladd</i>.  Только для многопользовательского режима.
</dd></dl>
<dl><dt> <b>aclchg</b> <i>usernames</i> <i>permbits</i> <i>list</i>
</dt><dt> <b>chacl</b> <i>usernames</i> <i>permbits</i> <i>list</i>
</dt><dd> Изменить права для пользователей. Список пользователей <i>usernames</i> состоит из имён пользователей, разделённых запятыми. Права представлены символами <tt>r</tt>, <tt>w</tt> и <tt>x</tt>. Префикс <tt>+</tt> обозначает добавление права, а префикс <tt>-</tt> снятие его. Третий параметр, <i>list</i> это список команд и/или окон, заданных с помощью номеров или названий. Специальный список <tt>#</tt> обозначает все окна, а <tt>?</tt> -- все команды.  Если параметр <tt>*</tt> состоит из одного единственного символа <tt>*</tt>,
 команда применяется ко всем пользователям.  Пользователь может 
выполнить команду, если у него есть бит "x" для этой команды. 
Пользователь может вводить данные в окно, если у него есть бит "w" для 
этого окна, и оно никем не заблокировано. Другие биты пока что 
игнорируются.  Для того чтобы отозвать блокировку записи в окно 2 
выполненную другим пользователем, нужно выполнить команду: "<tt>aclchg username -w+w 2</tt>". Для того чтобы предоставить доступ только для чтения: <tt>aclchg username -w "#"</tt>.
  Как только имя пользователя становится известно screen, этот 
пользователь может подключаться к сеансу и по умолчанию у него есть 
права на исполнение всех команд со всеми окнами.  Право на исполнение 
acl-команд, <i>at</i> и прочих нужно тоже удалить, иначе пользователь 
сможет восстановить себе права на запись сам.  Права специального 
пользователя nobody изменить нельзя (подробности в описании команды <i>su</i>).  Команда <i>chacl</i> это синоним для <i>aclchg</i>. Только для многопользовательского режима.
</dd></dl>
<dl><dt> <b>acldel</b> <i>username</i>
</dt><dd> Удалить пользователя из списка контроля доступа screen. Если у
 пользователя есть подключенные экраны, все они отключаются. И больше 
подключится он не может. Это только в многопользовательском режиме.
</dd></dl>
<dl><dt> <b>aclgrp</b> <i>username</i> [<i>groupname</i>]
</dt><dd> Создаёт группу пользователей с одинаковыми правами доступа. 
Название группы совпадает с названием лидера группы. Все члены группы 
наследуют права лидера группы. Это означает, что если пользователю 
доступ не дали, делается выполняется проверка для лидера. Пользователь 
удаляется изо всех групп, если в качестве имени группы используется 
специальное слово <i>none</i>. Если второй параметр не указан, на экран выводятся все группы, в которых состоит пользователь.
</dd></dl>
<dl><dt> aclumask [[<i>users</i>]+<i>bits</i> |[<i>users</i>]-<i>bits</i> .... ]
</dt><dt> umask [[<i>users</i>]+<i>bits</i> |[<i>users</i>]-<i>bits</i> .... ]
</dt></dl>
<dl><dd> Команда определяет, какие права будут у пользователей при 
доступе к окнам, которые создаст тот, кто вызывает эту команду.       
Аргумент <i>users</i> может отсутствовать или, если он есть, это список пользователей, разделённых запятыми.  Если список пользователей <i>users</i> не указан, подразумевается что перечислены все известные пользователи.  Аргумент <i>bits</i> это любая комбинация битов контроля доступа, которые могут использоваться в команде <i>aclchg</i>.  Специальное имя пользователя <tt>?</tt> определяет какие права доступа к окнам будут выдаваться пока неизвестным пользователям.       Специальное имя пользователя <tt>??</tt>
 определяет какие права вызова команд будут выдаваться пока неизвестным 
пользователям.  Права для специального пользователя nobody менять нельзя
 (см. команду "su").  Команда <i>umask</i> это синоним команды <i>aclumask</i>.
</dd></dl>
<dl><dt> <b>activity</b> <i>message</i>
</dt><dd> Если в окне, которое находится под наблюдением, возникает 
какая-то активность, screen показывает строку предупреждения. Текст 
предупреждения можно переопределить с помощью строки <i>message</i>. Символ <tt>%</tt> в сообщении заменяется номером окна, в котором возникла активность, а символ <tt>^G</tt>
 заменяется на определение звонка (bell) из termcap-файла (обычно ему 
соответствует звуковой звонок). Сообщение по умолчанию выглядит так:
</dd></dl>
<pre>   "Activity in window&nbsp;%n"
</pre>
<dl><dd> Обратите внимание на то, что мониторинг по умолчанию выключен. Его можно включить командой (C-a M).
</dd></dl>
<dl><dt> <b>allpartial</b> <i>on</i>|<i>off</i>
</dt><dd> Если установлен, обновляется только строка, содержащая курсор.
 Действует на все окна. Полезно для медленных линий. Предыдущие 
настройки обновления восстанавливаются при вызове <i>allpartial off</i>. Команда влияет на глобальный флаг, перекрывающий их собственные настройки. Команда не влияет на новые окна и их отрисовку.
</dd></dl>
<dl><dt> <b>altscreen</b> <i>on</i>|<i>off</i>
</dt><dd> Если установлен, включается поддержка альтернативного экрана 
(alternate screen), как в xterm (например, когда вы выходите из man и то
 что бы на консоли восстанавливается). Начальная настройка "off".
</dd></dl>
<p><b>at</b> [<i>identifier</i>][#|*|%] <i>command</i> [<i>args</i> ... ]
</p>
<dl><dd> Выполнить команду на другом окне или дисплее, так будто бы она была вызвана там.  Команда <i>at</i>
 меняет контекст (текущее окно или дисплей).  Если первый аргумент 
описывает не уникальный контекст, команда будет выполнена многократно.
</dd></dl>
<dl><dd> Если первый параметр задан в форме <tt>id*</tt>, тогда <i>id</i>
 проверяется на соответствие именам пользователей.  Команда выполняется 
по разу для каждого дисплея заданного пользователя.  Если идентификатор <i>identifier</i> задан в форме <i>id%</i>,
 он проверяется на соответствие дисплеям.  Дисплеи именуются в 
соответствии с названиями терминалов, к которым они подключаются.  
Префиксы <tt>/dev/</tt> и <tt>/dev/tty</tt> указывать в идентификаторе не обязательно.  Если идентификатор заканчивается <tt>#</tt> или никаких специальных символов в конце нет, он проверяется на соответствие номера и названиям окон.
</dd></dl>
<dl><dd> Если не указать идентификатор перед <tt>#</tt> <tt>*</tt> или <tt>%</tt>
 будут выбраны все пользователи, все дисплеи или все окна 
соответственно.  На экране появится короткое сообщение, описывающее, что
 происходит.  Обратите внимание, что символ "#" работает как 
комментарий, если перед ним поставить #.  Экранировать символ можно с 
помощью <tt>\</tt>.  Разрешения проверяются для того, кто вызвал команду <i>at</i>, а не для владельца дисплея, на котором будет выполняться команда.
</dd></dl>
<dl><dd> Замечание: При поиске соответствия именам окон, команда 
выполняется как минимум по разу для каждого окна. Команды, которые 
меняют порядок окон (как <i>other</i>) могут вызываться более одного 
раза.  В окнах, подключенных к нескольким дисплеям, команда будет 
выполняться для каждого дисплея.  Осторожно с переключающими (toggle) 
программами типа <b>login</b>!  Некоторые программы (например, 
"process") требуют чтобы экран был подключен к целевому окну. Такие 
команды могут не очень корректно работать, когда <i>at</i> обходит окна.
</dd></dl>
<dl><dt> <b>attrcolor</b> <i>attrib</i> [<i>attribute</i>/<i>color-modifier</i>]
</dt><dd> Команда предназначена для того чтобы подсвечивать атрибуты путём смены цвета текста. Если используется атрибут <i>attrib</i>,
 применяется модификатор attribute/color.  Если модификатор не задан, 
удаляются текущие. Подробнее о синтаксисе читайте в разделе «<a href="#Escape-.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D1.81.D1.82.D0.B8">Escape-последовательности</a>».
</dd><dd> Программа screen понимает два псевдо-атрибута: "i" обозначает яркий цвет буквы и "I" обозначает яркий цвет фона.
</dd></dl>
<pre> Примеры:
</pre>
<pre> attrcolor b "R"
      Выводить ярко-красным цветом текст, который должен быть полужирным.
</pre>
<pre> attrcolor u "-u b"
      Выводить текст синим цветом вместо подчёркнутого.
</pre>
<pre> attrcolor b ".I"
      Использовать яркие цвета для вывода полужирного текста. Большинство терминалов и так это делает.
</pre>
<pre> attrcolor i "+b"
      Сделать чтобы яркий текст был ещё и полужирным.
</pre>
<dl><dt> <b>autodetach</b> <i>on</i>|<i>off</i>
</dt><dd> Будет ли screen отключаться (detach) при разрыве связи с 
терминалом (hangup). В результате отключения команды, работающие в 
screen, должны продолжать работать и не завершаться. Восстановить 
подключение можно с помощью команды <i>screen -r</i>. Если опция выключена (<i>off</i>),
 при разрыве связи с терминалом все процессы получат сигнал потери связи
 с терминалом (hangup, HUP) и (скорее всего) завершатся. По умолчанию: <i>on</i>
</dd></dl>
<dl><dt> <b>autonuke</b> <i>on</i>|<i>off</i>
</dt><dd> Указывает, должна ли команда очистки экрана удалять вывод, который ещё не был отправлен на терминал.  См. также <b>obuflimit</b>.
</dd></dl>
<dl><dt> backtick <i>id</i> <i>lifespan</i> <i>autorefresh</i> <i>cmd</i> <i>args</i>...
</dt><dt> backtick <i>id</i>
</dt></dl>
<dl><dd> Программирует backtick-команду (командную подстановку) с заданным идентификатором <i>id</i>.  Вывод этой команды используется для замены строковой последовательности <tt>%`</tt> (<tt>%<i>номер</i>`</tt>).  Заданный промежуток времени <i>lifespan</i>
 определяет количество секунду в течение которых вывод может считаться 
действительным. Когда время заканчивается, если встретится 
соответствующая escape-последовательность, программа должна запускаться 
заново.  Параметр <i>autorefresh</i> включает автоматическое обновление заголовков после заданного количества секунд.
</dd><dd> Если и <i>lifespan</i>, и <i>autorefresh</i> равны 0, 
предполагается, что программа должна уйти в фон и изредка генерировать 
вывод. В этом случае команда запускается сразу же, и screen сохраняет 
последнюю строчку вывода. Если печатается новая строка, screen 
автоматически обновляет заголовки или hardstatus.  Вторая форма команды 
удаляет bactick с идентификатором <i>id</i>.
</dd></dl>
<dl><dt> <b>bce</b> [<i>on</i>|<i>off</i>]
</dt><dd> Настройка background-color-erase (цвет фона при очистке). Если
 bce установлено, все символы, которые в настоящий момент 
очищаются,вставляются, выводятся из буфера-прокрутки или очищаются, 
будут выводиться с текущим цветом фона. В противном случае используется 
цвет фона, заданный по умолчанию.
</dd></dl>
<dl><dt> <b>bell_msg</b> [<i>message</i>]
</dt><dd> Когда символ звонка (bell character) выводится в фоновом окне,
 screen показывает сообщение-предупреждение.  Это 
сообщение-предупреждение можно переопределить командой <i>bell_msg</i>.  Каждый символ "<tt>%</tt>" в сообщении заменяется номером окна в котором прозвучал звонок; а каждая последовательность "<tt>^G</tt>" заменяется на обозначения звонка из termcap (обычно, звуковым звонком).  По умолчанию сообщение такое:
</dd></dl>
<pre>       "Bell in window&nbsp;%n"
</pre>
<dl><dd> Можно подавить вывод сообщения, если задать пустое сообщение в качестве аргумента (<tt>bell_msg ""</tt>). При вызове <i>bell_msg</i> безе параметров показывается текущее сообщение.
</dd></dl>
<dl><dt> <b>bind</b> [-c <i>class</i>] <i>key</i> [<i>command</i> [<i>args</i>]]
</dt></dl>
<dl><dd> Привязать команду к комбинации клавиш. По умолчанию, 
большинство команд, которые есть в screen уже привязаны к каким-то 
клавишам или их комбинациям (см.  "Привязки клавиш").  Так, например, 
команда создания окна привязана к клавише "c" или "C-c".  С помощью 
команды <i>bind</i> можно переопределять существующие привязки или создавать новые.  Аргумент <i>key</i>
 это или один символ, или последовательность из двух символов в виде 
"^x" (означающая Ctrl-x), обратный слеш за которым идет восьмеричное 
число (обозначающее код ASCII-символа) или обратный слеш, за котором 
идёт другой, экранированный, символ (например, \^ или \\).  Этот 
аргумент можно брать в кавычки. Если больше аргументов нет, удаляется 
сделанная ранее привязка к этому ключу.  В качестве аргумента <i>command</i> может использоваться любая команда, описанная в этом разделе.
</dd></dl>
<dl><dd> Если при помощи опции <tt>-c</tt> указан класс команды, ключ привязывается к команде указанного класса. Класс активируется с помощью команды <i>command</i>. Классы команд можно использовать для создания множественных комбинаций или многосимвольных привязок.
</dd></dl>
<dl><dd> Некоторые примеры:
</dd></dl>
<pre>   bind ' ' windows
   bind ^k
   bind k
   bind K kill
   bind ^f screen telnet foobar
   bind \033 screen -ln -t root -h 1000 9 su
</pre>
<dl><dd> последовательность привязывает пробел к команде, которая 
показывает список окон (и команда, которая обычно доступна через C-a C-w
 теперь доступа и по нажатию C-a пробел).  Следующие три строки удаляют 
привязку kill с комбинаций "C-a C-k" и "C-a k".  После чего kill 
привязывается к "C-a K". Потом комбинация клавиш "C-f" привязывается к 
команде "создать окно с TELNET-подключением к foobar", а клавишу 
"escape"  к команде, которая создаёт с именем root в слоте 0, с 
командным интерпретатором, запущенным от имени суперпользователя и 
буфером прокрутки на 1000 строк.
</dd></dl>
<pre>   bind -c demo1 0 select 10
   bind -c demo1 1 select 11
   bind -c demo1 2 select 12
   bindkey "^B" command -c demo1
</pre>
<dl><dd> Сделать так что бы "C-b 0" выбирало окно 10, "C-b 1" окно 11 и т. д.       
</dd></dl>
<pre>   bind -c demo2 0 select 10
   bind -c demo2 1 select 11
   bind -c demo2 2 select 12
   bind - command -c demo2
</pre>
<dl><dd> Сделать так что бы "C-a - 0" выбирало окно 10, "C-a - 1" окно 11 и так далее.
</dd></dl>
<dl><dt> <b>bindkey</b> [-d] [-m] [-a] [ [-k|-t] <i>string</i> [<i>cmd</i> <i>args</i>] ]
</dt><dd>    Команда предназначена для управления таблицами трансляции 
screen. Каждая запись в таблице говорит screen как реагировать на 
нажатие определённых последовательностей клавиш при работе в разных 
режимах. Есть три таблицы: в одной хранятся действия, 
запрограммированные пользователем; во второй действия по умолчанию при 
эмуляции терминала; и одну для управления курсором в режиме копирования.
  В разделе «<a href="#.D0.A2.D1.80.D0.B0.D0.BD.D1.81.D0.BB.D1.8F.D1.86.D0.B8.D1.8F_.D0.BF.D1.80.D0.B8_.D0.B2.D0.B2.D0.BE.D0.B4.D0.B5">Трансляция при вводе</a>» приводится список привязок по умолчанию.  Если задана опция <tt>-d</tt>,  bindkey изменяет таблицу по умолчанию,  <tt>-m</tt> изменяет таблицу для режима копирования, и если ключей не задавать вообще — выбирается пользовательская таблица. Аргумент <i>string</i>
 это последовательность из двух символов, к которой привязывается 
действие.  Это может быть или строка или имя клавиатурной termcap 
возможность (выбор при помощи <tt>-k</tt>).  На терминале VT100 
некоторые клавиши могут отправлять другие последовательности, если 
включен режим приложения (например, клавиши управления курсором).  У 
таких клавиш в таблице трансляции две записи. Выбор режима приложения 
выполняется с помощью ключа <tt>-a</tt>.  Опция <tt>-t</tt> говорит 
screen, что ненужно делать межсимвольный тайминг.  Нельзя отключить 
тайминг, если используюся termcap capability.  Аргумент <i>cmd</i> может быть любой командой screen с произвольным количеством аргументов.  Если <i>cmd</i> не указано, привязка удаляется из таблицы.
</dd></dl>
<dl><dd> Вот некоторые примеры привязок:
</dd></dl>
<pre>   bindkey -d
</pre>
<dl><dd> Показать все привязки клавиш. Записи приложений (application mode entries) отмечаются символом <tt>[A]</tt>.        
</dd></dl>
<pre>   bindkey -k k1 select 1
</pre>
<dl><dd> F1 переключает на окно 1.
</dd></dl>
<pre>   bindkey -t foo stuff barfoo
</pre>
<dl><dd> Сделать слово <i>foo</i> сокращением для слова <i>barfoo</i>. Таймаут отключён, поэтому можно набирать медленно.
</dd></dl>
<pre>   bindkey "\024" mapdefault
</pre>
<dl><dd> Сделать "^T" escape-последовательностью для привязок клавиш. 
Если вы выполнили предыдущую команду, теперь слово "foo" нужно будеть 
вводить через "^T": "^Tfoo". Если вы хотите вставить "^T", надо нажать 
её дважды.  (т.е. экранировать второе нажатие с помощью первого).
</dd></dl>
<pre>   bindkey -k F1 command
</pre>
<dl><dd> Сделать F11 (не F1!) альтернативой escape-символу (^A).
</dd></dl>
<dl><dt> <b>break</b> [<i>duration</i>]
</dt><dd> Отправляет сигнал разрыва (break) длительностью duration*0.25 
секунд. Для не-POSIX систем число секунд может округляться до целого. 
Наиболее полезно в том случае, когда символьное устройство подключено к 
окну, а не процессу командного интерпретатора (см. Типы окон). 
Максимальная длительность сигнала ограничена величиной 15 секунд.
</dd></dl>
<dl><dt> <b>blanker</b>
</dt><dd> Активирует хранитель экрана. Сначала очищается экран. Потом, 
если хранитель экрана не задан, выключается курсор; если же курсор 
задан, он запускается и его вывод направляется на экран. По первому 
нажатию клавиши хранитель завершается, а его вывод стирается. Нажатая 
клавиша не запоминается. Обычно, эта команда используется совместно с 
командой <b>idle</b>.
</dd></dl>
<dl><dt> <b>blankerprg</b> [<i>program args</i>]
</dt><dd>      Указывает какая программа должна использоваться в 
качестве хранителя экрана. Или отключает хранитель экрана вообще, если 
этот параметр не задан.
</dd></dl>
<dl><dt> <b>breaktype</b> [tcsendbreak|TIOCSBRK |TCSBRK]
</dt><dd> Выбрать один из доступных способов генерирования сигнала 
разрыва (break) для терминальных устройств. Команда должна действовать 
только на текущее окно, но до сих пор она работает как <b>defbreaktype</b>. В будущем это изменится. Если вызвать <b>breaktype</b> без параметров, будет выведена текущая настройка.
</dd></dl>
<dl><dt> <b>bufferfile</b> [<i>exchange-file</i>]
</dt><dd> Изменить имя файла, использующегося для чтения и записи буфера
 обмена. Если имя файла не указано, реактивируется настройка по 
умолчанию (<tt>/tmp/screen-exchange</tt>). В этом примере системный файл <tt>passwd</tt> копируется в окно (при помощи буфера обмена, в котором остаётся копия):
</dd></dl>
<pre>   C-a&nbsp;: bufferfile /etc/passwd
   C-a &lt; C-a ]
   C-a&nbsp;: bufferfile
</pre>
<dl><dt> <b>c1</b> [<i>on</i>|<i>off</i>]
</dt></dl>
<dl><dd> Изменяет обработку кода c1. Если включить (C1 on), screen будет
 обрабатывать символы с кодом в диапазоне от 128 до 159 как специальные 
управляющие последовательности. Он будет воспринимать 8-битный код как 
комбинацию ESC и аналогичного 7-битного. По умолчанию обработка кодов C1
 включена (настройку по умолчанию можно изменить при помощи команды <i>defc1</i>). Пользователь, которому нужны символы с кодами на позициях относящихся к C1, может выключить эту функцию.
</dd></dl>
<dl><dt> <b>caption</b> <b>always</b>|<b>splitonly</b> [<i>string</i>]
</dt><dt> <b>caption</b> <b>string</b> [<i>string</i>]
</dt></dl>
<dl><dd> Команда управляет отображением заголовков окон. По умолчанию, 
заголовки показываются только если на экране больше одного окна (режим 
split screen). Если же включен режим <i>caption always</i>, заголовок будет показываться всегда. По умолчанию включён режим <i>splitonly</i>.
</dd><dd> Вторая форма вызова изменяет текст заголовка. Можно использовать escape-последовательности (см. раздел <a href="#Escape-.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D1.81.D1.82.D0.B8">Escape-последовательности</a>). По умолчанию заголовок: "%3n&nbsp;%t". Можно смешивать обе формы и задавать строку как дополнительный аргумент.
</dd></dl>
<dl><dt> <b>charset</b> <i>set</i>
</dt><dd> Изменяет текущее назначение слотов и привязку кодировок.  
Первые четыре символа рассматриваются как описание кодировки, а пятый и 
шестой должны находиться в диапазоне и задавать настройку отображения 
GL/GR. В каждой позиции символ "." может указывать на то, что 
соответствующая кодировка не должна меняться (множество добивается 
внутри screen символами . до 6).  У новых окон будет кодировка по 
умолчанию "BBBB02", кроме тех случаев, когда активна команда "encoding".
</dd></dl>
<dl><dd> Текущие настройки можно посмотреть при помощи команды <i>info</i>.
</dd></dl>
<dl><dt> <b>chdir</b> [<i>directory</i>]
</dt><dd> Изменяет текущий каталог screen на заданный или, если команда 
вызвана без аргументов, на домашний каталог пользователя (значение 
переменной <tt>$HOME</tt>). У всех программ, которые запускаются в окнах, создающихся при помощи команды <i>screen</i> из <tt>.screenrc</tt>, или при помощи C-a c, или при помощи <i>C-a&nbsp;: screen ...</i> будет этот текущий каталог. Без вызова команды <i>chdir</i> текущим каталогом будет тот, из которого вызывался <i>screen</i>.
 Hardcopy-файл и файл-журнал пишутся в текущий каталог окна (а не 
процесса, который работает в этом окне). Можно многократно использовать 
эту команду в файле <tt>.screenrc</tt>: например, для того чтобы создавать различные окна с различными рабочими каталогами. Последний вызов <i>chdir</i> будет влиять на окна, которые создаются интерактивно.
</dd></dl>
<dl><dt><b>clear</b>
</dt><dd>      Очищает текущее окно и сохраняет его образ в буфер прокрутки.
</dd></dl>
<dl><dt><b>colon</b> [<i>prefix</i>]
</dt><dd> Позволяет вводить командные строки <tt>.screenrc</tt>. Полезно
 для выполнения изменений привязки клавиш на лету, хитрого управления 
окнами. Обратите внимание на то, что ключевое слово <b>set</b> больше не
 существует. Как правило, команды воздействуют на текущее окно, а не на 
настройки для будущих окон. Если нужно поменять настройки для будущих 
окон, используются команды, начинающиеся словом <b>def...</b>.
</dd><dd> Вы можете воспринимать этот режим как режим Ex в screen, а режим вызываемый по комбинации <b>C-a esc</b> — как командный режим по аналогии с редактором Vi.
</dd></dl>
<dl><dt> <b>command</b> [-c <i>class</i>]
</dt><dd> Это команда делает то же самое, что и комбинация клавиш ^A. По
 всей видимости, толк от неё есть только при описании привязок 
комбинаций клавиш. Если задан ключ <tt>-c</tt>, определяется класс команды. См. также <b>bind</b> и <b>bindkey</b>.
</dd></dl>
<dl><dt>   <b>compacthist</b> [on|off]
</dt><dd>      Говорит <i>screen</i>, нужно ли подавлять последние пустые строки при прокрутке текста в буфере истории.
</dd></dl>
<dl><dt> <b>console</b> [<i>on</i>|<i>off</i>]
</dt><dd>      Захватывает (или отпускает захват) системной консоли 
текущим окном. Захватить консоль может только владелец файла 
/dev/console. Кроме того, система должна поддерживать ioctl TIOCCONS.
</dd></dl>
<dl><dt> <b>copy</b>
</dt></dl>
<dl><dd> Переходит в режим копирования/прокрутки. В этом режиме можно 
скопировать текст из текущего окна и его истории в буфер обмена.  В этом
 режиме активируется vi-подобный интерфейс:
</dd></dl>
<dl><dd> Клавиши для передвижения:
<ul><li> h, j, k, l перемещают курсор на одну строку или одну колонку.
</li><li> 0,  ^  и  $  перемещают курсов в самую левую колонку, в первую или последнюю позицию, где стоит непробельный символ.
</li><li> H, M и L перемещают курсор в самую левую колнонку верхней, средней или нижней строки экрана.
</li><li> + и - перемещают на одну строку вверих или вниз.
</li><li> G переходит на строку с заданным номеромt (по умолчанию: до конца буфера).
</li><li> | переходят на колонку с заданным номером.
</li><li> w, b, e передвижение по словам.
</li><li> B, E передвижение по СЛОВАМ (как в vi).
</li><li> C-u  и  C-d  прокручивает экран вверх/вниз на заданное количество строк, сохраняя при этом позицию курсора
</li><li> (По умолчанию: пол-экрана).
</li><li> C-b и C-f прокручивают на один экран ввер/вниз.
</li><li> g переходит в начало буфера.
</li><li>&nbsp;% переходит на указанный процент буфера.
</li></ul>
</dd></dl>
<dl><dd> Замечание:
</dd><dd> Команды перемещения в стиле Emacs можно настроит с помощью <tt>.screenrc</tt>
 (Например, markkeys "h=^B:l=^F:$=^E"). Нет простого способа для полной 
раскладки в стиле Emacs, поскольку нужно задействовать многосимвольные 
коды.
</dd></dl>
<dl><dd> <i>Маркировка</i>:
</dd><dd> Область копирования определяется двумя отметками. Текст между отметками подсвечивается. Отметки ставятся при помощи пробела.
<ul><li> Y и y маркируют всю строку или с начала строки.
</li><li> W маркирует ровно одно слово.
</li></ul>
</dd></dl>
<dl><dd> <i>Повтор</i>:
</dd><dd> Любую команду можно вводить после числа, которое обозначает количество повторов при вызове этой команды.
<ul><li> 0..9 обозначает количество повторов.
</li></ul>
</dd><dd> Пример:  "C-a  C-[  H  10 j 5 Y" копирует строки с 11 по 15 в буфер обмена.
</dd></dl>
<dl><dd> <i>Поиск</i>:
<ul><li> / Поиск вперёд в стиле Vi
</li><li>&nbsp;? Поиск назад в стиле Vi
</li><li> C-a s Инкрементальный поиск вперёд в стиле Emacs
</li><li> C-r Обратный интерактивный поиск в стиле Emacs
</li></ul>
</dd></dl>
<dl><dd> <i>Отличия от vi</i>:
</dd><dd> Есть несколько клавиш, которые работают не как в vi.  Vi (не 
vim) не позволяет работать с прямоугольными блоками текста, а screen 
позволяет.
<ul><li> c или C to задаёт левый или правый отступ соответственно.
</li></ul>
</dd><dd>  Если не задан повтор, отступ будет соответствовать текущей позиции курсора.
</dd><dd>  Пример: Попробуйте такую последовательность: "C-a [ M 20 l 
SPACE c 10 l 5 j C SPACE".  перейти на среднюю линию, сдвинуться на 20 
колонку, ометить начало буфера, установить левую колонку, перейти на 5 
строк вниз, установить правую колонку, отметить конец буфера обмена.
</dd><dd>           Теперь попробуйте: "C-a [ M 20 l SPACE 10 l 5 j 
SPACE" и обратите внимание на то, сколько текста скопировалось на этот 
раз.
</dd></dl>
<dl><dd><ul><li> J  объединить строки. Он переключается между 4 
режимами: строки разделяются символом новой строки (new line, 012), 
объединяются бесшовно, разделяются одним пробелом или разделяются 
запятой.  Можно сдедать так, что бы перед символом новой строки (new 
line) выводился символ перевода каретки (carriage return), для этого 
нужно дать команду <i>crlf on</i>.
</li><li> v нужна пользователям vi, которые включают ":set numbers" - переключает величину отступа между 9 и 1.
</li><li> a переключает в режим добавления (append mode). Содержимое буфера обмена не будет стёрто, а дописано.
</li><li> A переключает режим ввода (append mode) и ставит вторую отметку.
</li><li> &gt; ставит вторую отметку и записывает выделенный текст в файл screen-exchnage (по умолчанию <tt>/tmp/screen-exchange</tt>) и выходит из режима копирования.
</li></ul>
</dd></dl>
<dl><dd> Пример как записать весь буфер прокрутки в тот файл: "C-A [ g SPACE G $ &gt;".
<ul><li> C-g показывает информацию о текущей строке и колонке.
</li><li> x  меняет местами первую отметку и текущую позицию курсора. 
Можно использовать для того чтобы передвинуть уже установленную отметку.
</li><li> @ ничего не делает. Даже не выходит из режима копирования.
</li></ul>
</dd></dl>
<dl><dd> Все клавиши, которые не были описаны здесь, завершают режим копирования.
</dd></dl>
<dl><dt> <b>copy_reg</b> [<i>key</i>]
</dt><dd> Больше не существует, используйте <i>readreg</i>.
</dd></dl>
<dl><dt> <b>crlf</b> [<i>on</i>|<i>off</i>] 
</dt><dd> Команда влияет на копирование блоков текста с помощью комбинации клавиш <b>C-a [</b>. Если установить её в <i>on</i>,
 строки будут разделяться символами CR — LF. В противном случае (по 
умолчанию) они будут разделяться только LF. При вызове без параметров, 
состояние переключается.
</dd></dl>
<dl><dt> <b>debug</b> [<i>on</i>|<i>off</i>]
</dt><dd> Включает или выключает отладку. Если программа screen откомпилирована с опцией <tt>-DDEBUG</tt>,
 отладка включена по умолчанию. Обратите внимание на то, что команда 
действует на отладочный вывод только главного процесса screen. 
Отладочный вывод attacher-процессов можно только выключить, да и то 
только один раз.
</dd></dl>
<dl><dt> <b>defc1</b> <i>on</i>|<i>off</i>
</dt><dd> То же, что и команда <b>c1</b>, но настройка изменяется в том числе и для новых окон. По умочанию, равна <i>on</i>.
</dd></dl>
<dl><dt> <b>defautonuke</b> <i>on</i>|<i>off</i>
</dt><dd> То же, что и команда <b>autonuke</b>, но настройка изменяется по умолчанию и для новых окон. Начальная настройка равна <b>off</b>.
 Обратите внимание, что вы можете использовать специальную возможность 
(capability) AN терминала, если вы хотите чтобы действие зависело от 
типа терминала.
</dd></dl>
<dl><dt> <b>defbce</b> <i>on</i>|<i>off</i>
</dt><dd> То же, что и команда <b>bce</b>, но настройка изменяется в том числе и для новых окон. По умочанию, равна <i>off</i>.
</dd></dl>
<dl><dt> <b>defbreaktype</b> [<i>tcsendbreak</i>|<i>TIOCSBRK</i> |<i>TCSBRK</i>]
</dt></dl>
<dl><dd> Выбрать один из трёх доступных методов генерирования сигнала 
разрыва (break signal) для терминальных устройств.  Предпочитально 
использовать методы <i>tcsendbreak</i> и <i>TIOCSBRK</i>. Третий метод, <i>TCSBRK</i>,
 полностью блокирует сеанс screen на протяжении разрыва, но в некоторых 
случаях это может быть единственным рабочим способом сделать длинный 
разрыв. <i>Tcsendbreak</i> и <i>TIOCSBRK</i> могут делать, а могут не 
делать длинные разрывы с шипами (long breaks with spikes) (например, 4 в
 секунду). Это зависит не только от системы, но и от драйверов 
последовательных адаптеров. Если вызвать "defbreaktype" без параметров, 
будут показаны текущие настройки.
</dd></dl>
<dl><dt> <b>defcharset</b> [<i>set</i>]
</dt><dd> То же, что и команда <b>charset</b>, но настройка изменяется в том числе и для новых окон. Если вызвать без аргументов, показывает текущую настройку.
</dd></dl>
<dl><dt> <b>defescape</b> <i>xy</i>
</dt><dd> Задаёт командный символ. То же, что и escape, за исключением 
того, что может быть полезно только в многпользовательских сеансах. В 
многопользовательских сеансах <i>escape</i> меняет настройку только для вызвавшего эту команду пользователя, а <i>defescape</i> меняет настройку для пользователей, которые будут добавлены позже.
</dd></dl>
<dl><dt> <b>defflow</b> <i>on</i>|<i>off</i>|<i>auto</i> [<i>interrupt</i>]
</dt><dd> То же, что и команда <b>flow</b>, но настройка изменяется в том числе и для новых окон. Начальная настройка <i>auto</i>. Вызов <i>defflow auto interrupt</i> равносилен использованию при вызове ключей командной строки <tt>-fa</tt> и <tt>-i</tt>.
</dd></dl>
<dl><dt> <b>defgr</b> <i>on</i>|<i>off</i>
</dt><dd> То же, что и команда <b>gr</b>, но изменяет настройку в том числе для новых окон. По умочанию, равна <i>off</i>.
</dd></dl>
<dl><dt> <b>defhstatus</b> [<i>status</i>]
</dt><dd> Статусная строка (hardstatus) во всех новых окнах инициализируется строкой <i>status</i>.
 Команда нужна дла того чтобы в окнах screen в строке состояний выводить
 номера окон, их заголовки и тому подобное. В строке статуса могут 
использоваться те же директивы, что и в сообщениях для окон, только в 
качестве escape-символа используется "<tt>^E</tt>" (восьмиричное 005) вместо "<tt>%</tt>".
 Это сделано специально: чтобы уменьшить вероятность ошибочного 
распознавания сгенерированных программно статусных строк. Если параметр <i>status</i> не задан, показывается текущая строка статуса по умолчанию. По умолчанию hardstatus строка окон пустая.
</dd></dl>
<dl><dt> <b>defencoding</b> <i>enc</i>
</dt><dd> То же, что и команда <b>encoding</b>, но изменяет настройку в том числе для новых окон. Начальная настройка берётся из свойств терминала.
</dd></dl>
<dl><dt> <b>deflog</b> <i>on</i>|<i>off</i>
</dt><dd> То же, что и команда <b>log</b>, но изменяет настройку в том числе для новых окон. По умочанию, равна <i>off</i>.
</dd></dl>
<dl><dt> <b>deflogin</b> <i>on</i>|<i>off</i>
</dt><dd> То же, что и команда <b>login</b>, но изменяет настройку в том числе для новых окон. По умочанию, равна <i>on</i> (см. config.h.in в исходниках).
</dd></dl>
<dl><dt> <b>defmode</b> <i>mode</i>
</dt><dd> Режим доступа (права), которые устанавливаются для каждого 
нового псевдотерминала. Режим задаётся в виде восьмиричного числа. По 
умолчанию 0622.
</dd></dl>
<dl><dt> <b>defmonitor</b> <i>on</i>|<i>off</i>
</dt><dd> То же, что и команда <b>monitor</b>, но настройка изменяется в том числе и для новых окон. Настройка по умолчанию: <i>off</i>.
</dd></dl>
<dl><dt> <b>defnonblock</b> <i>on</i>|<i>off</i>|<i>numsecs</i>
</dt><dd> То же, что и команда <b>nonblock</b>, но настройка изменяется в том числе и для новых окон. Настройка по умолчанию: <i>off</i>.
</dd></dl>
<dl><dt> <b>defobuflimit</b> <i>limit</i>
</dt><dd> То же, что и команда <b>obuflimit</b>, но изменяется в том числе и настройка по умолчанию для новых окон. Начальное значение: <i>256 байтов</i>.
 Если вы хотите, чтобы параметр зависел от типа терминала, вы можете 
использовать специальную возможность (capability) терминала, которая 
называется <i>OL</i>.
</dd></dl>
<dl><dt> <b>defscrollback</b> <i>num</i>
</dt><dd> То же, что и команда <b>scrollblock</b>, но изменяется в том числе и настройка по умолчанию для новых окон. Начальное значение: <i>100</i>.
</dd></dl>
<dl><dt> <b>defshell</b> <i>command</i>
</dt><dd> Синоним команды <b>shell</b>. Смотрите эту команду.
</dd></dl>
<dl><dt> <b>defsilence</b> <i>on</i>|<i>off</i>
</dt><dd> То же, что и команда <b>silence</b>, но изменяется настройка по умолчанию для новых окон. Начальное значение: <i>off</i>.
</dd></dl>
<dl><dt> <b>defslowpaste</b> <i>msec</i>
</dt><dd> То же, что и команда '<i>slowpaste</i>, только меняет настройку для новых окон. Начальная настройка: 0 мс, означающая <i>off</i>.
</dd></dl>
<dl><dt> <b>defutf8</b> <i>on</i>|<i>off</i>
</dt><dd> То же, что и команда '<i>utf8</i>, только меняет настройку для новых окон. Начальная настройка: <i>off</i> или <i>on</i>, если screen был запущен с ключом <tt>-U</tt>.
</dd></dl>
<dl><dt> <b>defwrap</b> <i>on</i>|<i>off</i>
</dt><dd> То же, что и команда '<i>wrap</i>, только меняет настройку для новых окон. Начальная настройка <i>on</i>, может быть изменена командой <i>wrap</i> <i>on</i>|<i>off</i> (или с помощью "C-a r").
</dd></dl>
<dl><dt> <b>defwritelock</b> <i>on</i>|<i>off</i>|<i>auto</i>
</dt><dd> То же, что и команда '<i>writelock</i>, только меняет настройку для новых окон. Начальная настройка <i>off</i>.
</dd></dl>
<dl><dt> <b>defzombie</b> [<i>keys</i>]
</dt><dd>      Синоним команды <b>zombie</b>. В настоящий момент обе они меняют настройки по умолчанию. Смотрите эту команду.
</dd></dl>
<dl><dt> <b>detach</b> [<i>-h</i>]
</dt><dd> Отключить сеанс screen (отключить от терминала и отправить в 
фон). Происходит возврат в интерпретатор, из которого вызывался screen. 
Отключенный screen можно восстановить при помощи опции <tt>-r</tt> (см. "Опции командной строки"). Опция <tt>-h</tt> говорит, что нужно разорвать соединение с терминалом (hangup).
</dd></dl>
<dl><dt><b>dinfo</b>
</dt><dd>      Показывает, что screen думает о вашем терминале. Может 
пригодится, если нужно узнать почему не работают цвет или альтернативная
 кодировка.
</dd></dl>
<dl><dt><b>displays</b>
</dt><dd> Показывает таблицу с списком подключенных в настоящиё момент 
пользователей. Очень полезная команда для многопользовательского режима 
работы GNU Screen.
</dd></dl>
<dl><dt> <b>digraph</b> [<i>preset</i>]
</dt><dd> Ввести диграф. Выдаётся приглашение пользователю для ввода 
двухсимвольной последовательности. По введённым двум символам в 
встроенной таблице ищется диграф, найденный символ вставляется в окно. 
Например, если ввести <tt>a:</tt>, будет вставлен a-умляут. Если первый 
символ это 0 (ноль), screen будет рассматривать следующие символы как 
восьмеричное число. Опциональный аргумент <i>preset</i> рассматривается 
как обозначение нажатого символа, т.е. с его помощью можно сделать, 
например, умляут-клавишу.  Если сделать привяку "<tt>bindkey ^K digraph&nbsp;:</tt>", пользователь сможет вводить а-умляют при помощи комбинации Ctrl-K a.
</dd></dl>
<dl><dt> <b>dumptermcap</b>
</dt></dl>
<dl><dd> Сохранить записи termcap для текущего окна в .termcap-файл в каталог <tt>.screen</tt> в домашнем каталоге пользователя  "<tt>$HOME/.screen</tt>" (или в другой каталог, где screen хранит свои сокеты. См. раздел <a href="#.D0.A4.D0.B0.D0.B9.D0.BB.D1.8B">Файлы</a>).  Эта запись termcap идентична значению переменной <tt>$TERMCAP</tt>, которую screen устанавливает для каждого окна. Для систем с terminfo нужно будет запускать конвертер наподобие <b>captoinfo</b>, а потом компилировать запись при помощи <b>tic</b>.
</dd></dl>
<dl><dt> <b>echo</b> [-n] <i>message</i>
</dt><dd> Команда может использоваться для того чтобы распространять "сообщение дня". Обычно её добавляют в <tt>/etc/screenrc</tt>. При вызове с ключом <tt>-n</tt> конечный перевод строки не выводится. См. также <i>sleep</i>. Ещё может пригодиться для online-проверки переменных окружения.
</dd></dl>
<dl><dt> <b>encoding</b> <b>enc</b> [<i>enc</i>]
</dt></dl>
<dl><dd> Говорит screen как интерпретировать ввод/вывод. Первый аргумент
 устанавливает кодироку текущего окна. Каждое окно может эмулировать 
отдельную кодировку. Второй опциональный параметр перебивает кодировку 
присоединённого терминала. Обычно этот параметр не нужен, потому что 
screen может определить кодировку из настроек локали. Можно ещё выбирать
 кодировку терминала в зависимости от типа терминала, с помощью записи "<tt>KJ</tt>" в termcap.
</dd></dl>
<dl><dd> Поддерживаются кодировки eucJP, SJIS, eucKR, eucCN, Big5,  GBK,
  KOI8-R, CP1251,  UTF-8,  ISO8859-2, ISO8859-3, ISO8859-4, ISO8859-5, 
ISO8859-6, ISO8859-7, ISO8859-8, ISO8859-9, ISO8859-10, ISO8859-15, jis.
</dd></dl>
<dl><dd> См. также "defencoding", который меняет настройки по умолчанию для новых окон.
</dd></dl>
<dl><dt> <b>escape</b> <i>xy</i>
</dt><dd> Устанавливает управляющий символ равным x (похоже на опцию <tt>-e</tt>),
 а символ генерирующий литерал управляющего символа равным y. Каждый 
параметр (x и y) это или отдельный символ, или два символа в форме "^x" 
(обозначает "C-x"), или обратный слэш, за которым идёт восьмеричное 
число (ASCII-код символа), или обратный слэш за которым идёт ещё один 
символ (например, <tt>\^</tt> или <tt>\\</tt>). По умолчанию "<tt>^Aa</tt>".
</dd></dl>
<dl><dt>   <b>eval</b> <i>command1</i> [<i>command2</i> ...]
</dt><dd>      Разбирает и выполняет каждый аргумент как отдельную команду.
</dd></dl>
<dl><dt> <b>exec</b> [[<i>fdpat</i>] <i>newcommand</i> [<i>args</i> ...]]
</dt></dl>
<dl><dd> Запускает подпроцесс UNIX (соответствующий <i>newcommand</i> и её аргументам) в текущем окне.  Соединение потоков (atdin/stdout/stderr) команды <i>newcommand</i>,  процесса, работающего в окне, и собственно screen определяется шаблоном <i>fdpat</i>.  Шаблон <i>fdpat</i>
 это фактически трёхсимвольная последовательность, представляющая 
стандартный поток ввода, стандартный поток вывода и стандартный поток 
ошибок команды <i>newcommand</i>.  Символ <i>точка</i> (.) подсоединяет файловый дескриптор к screen.  Символ <i>восклицательный знак</i> (!) говорит о том, что файловый дескриптор должен быть присоединён к приложению.  Символ <i>двоеточие</i>
 (:) сочетает в себе действие двух предыдущих.  Данные, которые вводятся
 пользователем, передаются новой команде за исключением тех случаев, 
когда она подключена к потоку вывода приложения, работающего в окне 
(первый символ <i>fdpats</i> это <tt>!</tt> или <tt>:</tt>), и когда в конце <i>fdpat</i> стоит символ канала (|).  Если вызывать <i>exec</i>
 без аргументов, будут показаны именя и аргументы процессов, работающих в
 текущем окне.  В каждом окне за раз может исполняться только один 
подпроцесс.  Если подпроцесс работает, команда <i>kill</i> подействует на него, а не на процесс, работающий в окне.  В файле <tt>doc/fdpat.ps</tt>
 проиллюстрированы все 21 комбинация соединений. На каждом рисунке есть 
цифры 2,1,0 соответствующие трём файловым дескрипторам команды <i>newcomand</i>. Прямоугольник <i>W</i> это псевдотерминал, к которому с подчинённой стороны (slave side) подключено приложение.  Прямоугольник <i>P</i> это вторичный псевдотерминал, к которому с главной стороны (master side) подключен screen.
</dd></dl>
<dl><dd> Сокращения:
</dd><dd> Пробелы между словом <i>exec</i> и <i>fdpat</i> можно пропустить.  Точки в конце <i>fdpat</i> писать не обязательно; <i>fdpat</i>, состоящий из одних только точек, писать не обязательно.  Символ "<tt>|</tt>" это синоним для шаблона "!..|"; cлово <i>exec</i> в данном случае писать не обязательно, вместо него можно указать символ <tt>!</tt>.
</dd></dl>
<dl><dd> Примеры:
</dd></dl>
<pre>   exec ... /bin/sh
   exec /bin/sh
  &nbsp;!/bin/sh
</pre>
<dl><dd> Создаёт новый интерпретатор, в то время как первый продолжает 
работать.  Вывод обоих интерпретаторов попадает в окно, а ввод 
отправляется новому интерпретатору.
</dd></dl>
<pre>   exec&nbsp;!.. stty 19200
   exec&nbsp;! stty 19200
  &nbsp;!!stty 19200
</pre>
<dl><dd> Устанавливается скорость терминала окна. Если программа <b>stty</b> работает со стандартным потоком ввода, добавьте ещё один знак "<tt>!</tt>".
</dd></dl>
<pre>   exec&nbsp;!..| less
   |less
</pre>
<p>К выводу подключается pager. Специальный символ "|" нужен для того 
чтобы дать пользователю возможность управлять этим пейджером, несмотря 
на то, что данные он получает от процесса, работающего в окне.  Это 
работает, потому что less слушает стандартный поток ошибок (поведение, 
которое screen не ожидал бы без символа "<tt>|</tt>") когда стандартный поток ввода не терминал.  <b>Less</b> новее чем версия 177 будет сбоить; а старый добрый <b>pg</b> работает.
</p>
<pre>  &nbsp;!:sed -n s/.*Error.*/\007/p
</pre>
<dl><dd> Отправляет вывод на экран пользователю и на вход команде <b>sed</b>.
 Команда вставляет дополнительный символ звонка (восьмиричное 007) в 
вывод screen. Поэтому при каждом появлении на экране слова "Error" в 
строку статуса выводится сообщение "<tt>Bell in window x</tt>". 
</dd></dl>
<dl><dt> <b>fit</b>
</dt><dd> Изменить размер текущего размера под текущую область. Команда 
может пригодиться, когда screen не перестраивает размер окна, когда оно 
показывается больше чем один раз.
</dd></dl>
<dl><dt> <b>flow</b> [<i>on</i>|<i>off</i>|<i>auto</i>]
</dt><dd> Настроить режим управления потоком окна. При вызове без параметров команда циклически переключает настройки <i>auto</i>, <i>on</i>, <i>off</i>. Подробнее в разделе «<a href="#.D0.A3.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BC">Управление потоком</a>». Имейте в виду, что это настройка может поменяться в будущих выпусках screen. Настройка по умолчанию задаётся при помощи <i>defflow</i>.
</dd></dl>
<dl><dt> <b>focus</b> [<i>up</i>|<i>down</i>|<i>top</i>|<i>bottom</i>]
</dt></dl>
<dl><dd> Переместить фокус ввода на следующих регион. Выполняется 
циклически, поэтому верхний регион выбирается после самого нижнего. Если
 подкоманда не задана, подразумевается <i>down</i>. Подкоманда <i>up</i> перемещает фокус в противоположном порядке, а <i>top</i> и <i>bottom</i> переводят фокус на самый верхний или самый нижний регион. Полезные привязки
</dd></dl>
<p>(<tt>j</tt> и <tt>k</tt> как в vi)
</p>
<pre>   bind j focus down
   bind k focus up
   bind t focus top
   bind b focus bottom
</pre>
<dl><dt> <b>gr</b> [<i>on</i>|<i>off</i>]
</dt></dl>
<dl><dd> Включает/выключает GR-переключение (GR charset switching). 
Когда screen встречает 8-битный символ, он использует charset записанный
 в GR-слоте и выводит символ с удалённым восьмым битом. По умолчанию 
(см. также <i>defgr</i>)  GR не обрабатываются, потому что иначе символы ISO88591 перестанут работать.
</dd></dl>
<dl><dt> <b>hardcopy</b> [<i>-h</i>] [<i>file</i>]
</dt><dd> Записывает изображение текущего терминала в файл <i>file</i> или, если имя файла не задано, в файл <tt>hardcopy.n</tt> в текущем каталоге, где <i>n</i>
 --- это номер текущего окна. Файл или дописывается или переписывается 
сверху (см. ниже). Если указан ключ -h, скидывается и содержимое буфера 
прокрутки.
</dd></dl>
<dl><dt> <b>hardcopy_append</b> <i>on</i>|<i>off</i>
</dt><dd> Если включено (<i>on</i>), screen будет дописывать файлы созданные по нажатию "C-a h" в конец файла <tt>hardcopy.n</tt>, в противном случае он будет переписываться сверху. По умолчанию: <i>off</i>.
</dd></dl>
<dl><dt> <b>hardcopydir</b> <i>directory</i>
</dt><dd> Определяет каталог, в котором будет размешён hardcopy-файл. 
Если не задан, файлы будут размещаться в текущем каталоге программы 
screen.
</dd></dl>
<dl><dt> <b>hardstatus</b> [<i>on</i>|<i>off</i>]
</dt><dt> <b>hardstatus</b> [<i>always</i>]<i>lastline</i>|<i>message</i>|<i>ignore</i> [<i>string</i>]
</dt><dt> <b>hardstatus</b> <i>string</i> [<i>string</i>]
</dt></dl>
<dl><dd> Команда настраивает использование или эмуляцию 
hardstatus-строки терминала. Первая форма переключает использование 
аппаратной  статусной строки (hardware status line) для отображения 
сообщений. Если флаг установлен в <i>off</i>, сообщения выводятся в реверсивном видео на экране. Настройка по умолчанию: <i>on</i>.
</dd></dl>
<dl><dd> Вторая форма говорит screen что делать в том случае, когда у терминала нет строки <i>hardstatus</i> (то есть, в termcap/terminfo не установлены "hs", "ts","fs" и "ds"). Если используется тип <i>lastline</i>, screen резервирует последнюю строку экрана для строки статуса; тип <i>message</i> говорит screen о том, что надо использовать механизм сообщений screen и <i>ignore</i> -- что нужно не показывать hardstatus вообще. Если добавить слово <i>always</i> перед типом строки, screen будет использовать его даже в том случае, если терминал поддерживает hardstatus.
</dd></dl>
<dl><dd> Последняя форма описывает содержимое строки hardstatus. По 
умолчанию используется строка "%h", т.е. показывается статус текущего 
окна (устанавливается строками "<tt>ESC]0;&lt;string&gt;^G</tt>" или "<tt>ESC_&lt;string&gt;ESC\</tt>"). Можно настроить строку как угодно, для этого нужно использовать Escape-последовательности (см. раздел <a href="#Escape-.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D1.81.D1.82.D0.B8">Escape-последовательности</a>). Если вызвать команду без аргументов, будет показана текущая настройка.
</dd></dl>
<dl><dd> Можно смешивать вторую и третью формы --- задавать строку как дополнительный аргумент или нет.
</dd></dl>
<dl><dt> <b>height</b> [-w|-d] [<i>lines</i> [<i>cols</i>]]
</dt><dd> Задаёт высоту отображения равной количеству строк <i>lines</i>.
 Когда аргумент не задан, выполняется переключение между 24 и 42 
строками. Можно определить и ширину, если нужно изменить оба значения. 
Опция <tt>-w</tt> говорит, что нужно оставить размер экрана неизменным и менять только размер окна, а опция <tt>-d</tt> наоборот.
</dd></dl>
<dl><dt> <b>help</b> [-c <i>class</i>]
</dt><dd> Не совсем помощь, а просто картинка со списком комбинаций 
клавиш. На первой странице показаны все внутренние команды и их текущие 
привязки. На последующих страницах показаны пользовательские привязки, 
по одной команде на одну комбинацию. Пробел переходит к следующей 
странице; enter -- завершает просмотр. Все остальные символы 
игнорируются. Если задана опция <tt>-c</tt>, выводится список всех команд указанного класса <i>class</i>. См. также раздел <a href="#.D0.9F.D1.80.D0.B8.D0.B2.D1.8F.D0.B7.D0.BA.D0.B8_.D0.BA.D0.BB.D0.B0.D0.B2.D0.B8.D1.88">Привязки клавиш</a>.
</dd></dl>
<dl><dt> <b>history</b>
</dt><dd> В командных интерпретаторах легко посмотреть или использовать вызванные ранее команды. Например, в csh есть <tt>!!</tt>,
 которая повторяет последнюю вызванную команду. В screen есть простой 
механизм вызова команд, начинающихся с определённой последовательности: 
нужно набрать интересующую последовательность, почле чего нажать "C-a {"
 и screen попытается найти строку, начинающуюся с текста слева от 
курсора (с символом приглашения, приглашение character).  Найденная 
строка вставляется в окно. Этот механизм может использоваться как грубая
 замена механизма истории в командном интерпретаторе (в историю 
подставляются варианты как из видимой части окна, так и из буфера 
прокрутки).
</dd></dl>
<dl><dt> <b>hstatus</b> <i>status</i>
</dt><dd> Изменить строку статуса окна на status
</dd></dl>
<dl><dt> <b>idle</b> [<i>timeout</i> [<i>cmd</i> <i>args</i>]]
</dt><dd> Указывает команды, которая запускается после того как проходит
 заданное количество секунд без активности. Обычно в качестве команды 
указывается команда <i>blanker</i>, которая вызывает хранитель экрана 
screen. Если команда не задана, определяется только величина таймаута. 
Таймаут равный нулю (или специальное слово <i>off</i>) отключает таймер вообще. Если аргументы не заданы, показывается текущая настройка.
</dd></dl>
<dl><dt> <b>ignorecase</b> [on|off]
</dt><dd>      Говорит screen, что нужно игнорировать регистр символа при поиске. По умолчанию выключено.
</dd></dl>
<dl><dt> <b>info</b>
</dt><dd> Выводит информацию о текущем окне: позиция курсора в форме  
"(column,row)", начиная с "(1,1)",  ширина и высота терминала плюс 
размер буфера прокрутки в строках, например "(80,24)+50",  текущее 
состояние управления потоком (flow control) окна XON/XOFF, показанное в 
виде (см. также раздел <a href="#.D0.A3.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BC">Управление потоком</a>):
</dd></dl>
<pre>   +flow     автоматический контроль потока (automatic flow control), включен
   -flow     автоматический контроль потока (automatic flow control), выключен
   +(+)flow  контроль потока включен. Совпадает с автоматическим контролем потока
   -(+)flow  контроль потока выключен. Не совпадает с автоматическим контролем потока
   +(-)flow  контроль потока включен. Не совпадает с автоматическим контролем потока
   -(-)flow  контроль потока выключен. Совпадает с автоматическим контролем потока
</pre>
<dl><dd> Показываются настройки переноса ("<tt>+wrap</tt>" говорит, что перенос включён; "<tt>-wrap</tt>" говорит, что перенос выключен).
</dd></dl>
<dl><dd> Флаги "ins", "org", "app", "log", "mon" или "nored" 
показываются в том случае, если окно находится в режиме вставки 
(insert), исходном (origin),  приложения (application-keypad), если в 
нём включена журнализация вывода (output logging), мониторинг активности
 (activity monitoring) или частичная отрисовка (partial redraw).
</dd></dl>
<dl><dd> Показываются активный набор символов (character set; G0, G1, G2
 или G3) и в квадратных скобках символы терминала, которые выделены для 
G0-G3. Если окно в режиме UTF-8, вместо всего этого показывается строка <tt>UTF-8</tt>.
</dd></dl>
<dl><dd> В конце строки статуса выводятся дополнительные режимы (см. 
также "Типы окон"). Если машина состояний эмулятора терминала находится 
не в нормальном состоянии, строка info начинается со строки, 
идентифицирующей текущее состояние. Для получения системной информации 
используется команда <i>time</i>.
</dd></dl>
<dl><dt> <b>ins_reg</b> [<i>key</i>]
</dt><dd> Больше не существует. Используйте <i>paste</i>
</dd></dl>
<dl><dt> <b>kill</b>
</dt><dd> Завершает текущее окно. Если выполняется команда <tt>exec</tt>,
 она завершается. Если нет, процесс (командный интерпретатор), 
работающий в окне, получает сигнал HANGUP, структура окна удаляется и 
screen переключается на другое окно. Когда последнее окно закрывается, 
screen завершает свою работу. После закрытия окна screen переключается 
на окно, которое отображалось до того. 
</dd><dd> Замечание: Пользователи Emacs (да и не только Emacs, но и 
других программ имитирующих интерфейс Emacs, в частности bash) должны 
помнить об этой команде, когда удаляются текст до конца строки. Или 
лучше не использовать "C-a" как escape-последовательность или привязать 
kill на "C-a K".
</dd></dl>
<dl><dt> <b>lastmsg</b>
</dt><dd> Повторно показать содержимое статусной строки. Полезно, когда 
вы случайно сбили сообщение при наборе (сообщение пропадает, если нажать
 любую клавишу), а потом хотите его посмотреть. См. также <i>msgwait</i> и <i>msgminwait</i> (тонкая настройка режима показа сообщения).
</dd></dl>
<dl><dt> <b>license</b>
</dt><dd> Показать страницу-disclaimer. Она показывается при запуске 
screen без опций, что происходит достаточно часто. См. также команду <i>startup_message</i>.
</dd></dl>
<dl><dt> <b>lockscreen</b>
</dt></dl>
<dl><dd> Блокирует дисплей. Вызывается специальную программу блокировки (<tt>/local/bin/lck</tt> или <tt>/usr/bin/lock</tt>
 или встроенную, если других нет). Screen не обрабатывает никакие 
клавиши и комбинации клавиш до тех пор пока эта программа не завершится.
 Тем временем исполнение процессов в окнах может продолжаться, а сами 
окна находятся в отключённом (detached) состоянии. Программу screenlock 
можно укзать при помощи переменной <tt>$LOCKPRG</tt>, которая 
устанавливается в интерпретаторе, из которого вызывается screen. 
Программа выполняется от имени и с правами пользователя, который 
выполняет screen.
</dd></dl>
<dl><dd> Предупреждение: если вы оставляете другие оболочки 
разблокированными и на screen не стоит пароль, толку от блокировки 
никакого. Можно легко подключиться к screen из другой оболочки. 
Правильонее было бы назвать эту фукнцию "lockterminal".
</dd></dl>
<dl><dt> <b>log</b> [<i>on</i>|<i>off</i>]
</dt><dd> Начинает/останавливает запись журнала действий в текущем окне в файл <tt>screenlog.n</tt> в текущем каталоге окна (где <i>n</i> -- номер текущего окна). Имя файла можно изменить при помощи команды <i>logfile</i>.
 Если команда вызывается без парамеров, состояние переключается на 
противоположное. Журнал дописывается в конец файла (если файл уже есть).
 Текущее состояние экрана и буфер прокрутки не включаются в журнал. По 
умолчанию: <i>off</i>.
</dd></dl>
<dl><dt> <b>logfile</b> <i>filename</i>
</dt><dt> <b>logfile</b> <i>flush</i> <i>secs</i>
</dt></dl>
<dl><dd> Определяет имя файла журнала. По умолчанию "screenlog.%n". 
Вторая форма определяет количество секунд, которые screen будет ждать 
прежде чем сбросить буфер файла журнала на диск. По умолчанию 10 секунд.
</dd></dl>
<dl><dt> <b>login</b> [<i>on</i>|<i>off</i>]
</dt></dl>
<dl><dd> Добавляет или удаляет запись в базе данных utmp для текущего 
окна. Фактически, регистрирует (log in) окно. При вызове без параметров 
переключается состояние (регистрирует/разрегистрирует). Помимо этого, 
удобно когда есть комбинации клавиш для регистрации и разрегистрации. 
Например, "<tt>bind I login on</tt>" и "<tt>bind O login off</tt>" привязывают эти действия к "C-a I" и "C-a O". Настройка по умолчанию (в <tt>config.h.in</tt>) должна быть <i>on</i> для окон, наботающих с установленным битом suid-root. Состояние "по умолчанию" для новых окон задаётся при помощи команды <i>deflogin</i>. Обе команды есть только в том случае, если screen откомпилирован с поддержкой utmp.
</dd></dl>
<dl><dt> <b>logtstamp</b> [<i>on</i>|<i>off</i>]
</dt><dt> <b>logtstamp</b> <b>after</b> [<i>secs</i>]
</dt><dt> <b>logtstamp</b> <b>string</b> [<i>string</i>]
</dt></dl>
<dl><dd> Команда управляет временными метками в файле-журнале (logfile).
 Если временные метки включены, после двух минут без активности screen 
выводит в журнал строку, содержащую текущее время. Когда вывод 
продолжается больше двух минут, добавляется второй вывод (When output  
continues  и  more  than another two minutes have passed).  Величину 
таймаута можно изменить с помощью второй формы команды.  Третья форма 
предназначена для настройки формата строки временных меток (по умолчанию
 "<tt>--&nbsp;%n:%t -- time-stamp  --&nbsp;%M/%d/%y&nbsp;%c:%s --\n</tt>").
</dd></dl>
<dl><dt> <b>mapdefault</b>
</dt><dd> Говорит screen о том, что следующий символ он должен искать в стандартной таблице привязки клавиш. См. также <i>bindkey</i>.
</dd></dl>
<dl><dt> <b>mapnotnext</b>
</dt><dd> Как <b>mapdefault</b>, но не смотреть таблицу bindkey 
</dd></dl>
<dl><dt> <b>maptimeout</b> [<i>timo</i>]
</dt><dd> Задержка между симолами (в мс) при распознавании входных 
последовательностей. По умолчанию 300мс. При вызове без аргументов 
показывает текущую настройку. См. также <i>bindkey</i>.
</dd></dl>
<dl><dt> <b>markkeys</b> <i>string</i>
</dt></dl>
<dl><dd> Изменить привязку клавиш для режима копирования/истории. Строка <i>string</i> состоит из пар <tt>oldchar=newchar</tt>, разделённых двоеточиями.
</dd><dd> Пример: Строка "B=^B:F=^F" меняет привязку клавиш "C-b" и 
"C-f" на привязку в стиле vi (прокрутка вверх/вниз).  По умолчанию это 
привязка для клавиш <i>B</i> и <i>F</i>.  Команда "<tt>markkeys h=^B:l=^F:$=^E</tt>"
 меняет привязку клавиш на привязку в стиле GNU Emacs.  Если терминал 
отправляет символы, они снимают режим копирования, и здесь может помочь 
эта команда, которая отключает любое действие у этих символов. Символ "<tt>@</tt>" это символ no-op, он используется так: вызов "<tt>markkeys @=L=H</tt>" отключает действие команд H и L. Как показано в примере, к одной функции за раз можно привязать множество клавиш.
</dd></dl>
<dl><dt> <b>maxwin</b> <i>num</i>
</dt><dd> Максимальное количество окон, которые можно создать. Не влияет на уже существующие окна. Число можно только уменьшать.
</dd></dl>
<dl><dt> <b>meta</b>
</dt><dd> Вставляет управляющий символ (C-a) в текущий поток ввода окна.
</dd></dl>
<dl><dt> <b>monitor</b> [<i>on</i>|<i>off</i>]
</dt></dl>
<dl><dd> Включает/выключает наблюдение за активностью в окнах. Когда 
мониторинг включен для какого-то окна, и оно уходит в фон, система 
следит за активностью в нём и отправляет предупреждающее сообщение в 
строку статуса, как только хотя бы один символ будет выведен в окно. 
Название окна будет отмечено символом "<tt>@</tt>". По умолчанию мониторинг отключён для всех окон. 
</dd></dl>
<dl><dt> <b>msgminwait</b> <i>sec</i>
</dt><dd> На протяжении какого времени обязательно показывается 
сообщение, даже если на экране есть какая-то другая активность. По 
умолчанию 1 секунда.
</dd></dl>
<dl><dt> <b>msgwait</b> <i>sec</i>
</dt><dd> На протяжении какого времени показывается сообщение, если никакой другой активности нет. По умолчанию 5 секунд.
</dd></dl>
<dl><dt> <b>multiuser</b> <i>on</i>|<i>off</i>
</dt></dl>
<dl><dd> Переключается между однопользовательским и 
многопользовательским режимом. Стандартный режим работы — 
однопользовательский. В многопользовательском работают команды <i>acladd', </i>aclchg<i>, </i>aclgrp<i> и </i>acldel<i>. Они нужны для того чтобы дать (или забрать) доступ пользователям к сеансу screen.</i>
</dd></dl>
<dl><dt> <b>nethack</b> <i>on</i>|<i>off</i>
</dt><dd> Изменяет вид сообщений об ошибках, которые выводит screen.  
Если вы знакомы с игорой "nethack", возможно вам по нраву сообщения, в 
которых факты немного искажаются. Так немного веселее. В любом случае, и
 стандартные сообщения не всегда можно понять.  Опция доступна только, 
когда screen откомпилирован с флагом <tt>NETHACK</tt>.  Настройки по умолчанию определяются значением переменной <tt>$NETHACKOPTIONS</tt>.
</dd></dl>
<dl><dt> <b>next</b>
</dt><dd> Переключиться на следующее окно. Команда может использовать многократно, для того чтобы циклически обойти все окна.
</dd></dl>
<dl><dt> <b>nonblock</b> [<i>on</i>|<i>off</i>|<i>numsecs</i>]
</dt><dd> Говорит screen что нужно делать с интерфейсами (дисплеями), 
которые отказываются принимать ввод. Такое может произойти, например, 
если пользователь нажмёт ^S или разорвётся TCP/модемное соединение. Если
 nonblock выключен (так по умолчанию), screen ждёт пока дисплей 
перезапустится и будет готов принимать ввод. Если nonblock включен, 
screen подождёт окончания таймаута. Если не указано особо, таймаут 
составляет 1 секунду. Если дисплей за это время не станет принимать 
символы, он считается заблокированным и больше символы туда не 
отправляются. Если через некоторое время символы начнут приниматься, 
экран будет разблокирован и его содержимое обновлено.
</dd></dl>
<dl><dt> <b>number</b> [<i>n</i>]
</dt><dd> Изменят текущий номер окна. Если заданный номер <i>n</i> уже занят, окна меняются номерами. Если номер не задан, выводится номер (и имя) текущего окна.
</dd></dl>
<dl><dt> <b>obuflimit</b> [<i>limit</i>]
</dt><dd> Если буфер вывода содержит количество байтов больше заданного 
предела, новые данные из окон считываться не будут.  По умолчанию: 256. 
 Для быстрых дисплеев (например, для xterm) можно установить значение 
побольше.  Если аргумент не задан, выводится текущее значение.
</dd></dl>
<dl><dt> <b>only</b>
</dt><dd> Убить все регионы, за исключением текущего.
</dd></dl>
<dl><dt> <b>other</b>
</dt><dd> Переключиться на другое окно, которое было активным до этого. Если того окна уже нет, <i>other</i> работает как <i>next</i>
</dd></dl>
<dl><dt> <b>partial</b> <i>on</i>|<i>off</i>
</dt><dd> Определяет должен ли дисплей перерисовываться (как при <i>redisplay</i>)
 при переходе на текущее окно. Команда действует только на текущее окно.
 Чтобы подействовать на все окна сразу, нужно использовать команду <i>allpartial</i>. По умолчанию: <i>off</i>. Это значение по умолчанию фиксированное, команды <i>defpartial</i> нет.
</dd></dl>
<dl><dt> <b>password</b> [<i>crypted_pw</i>]
</dt><dd> Задаёт зашифрованный пароль, который screen спросит, если 
кто-то попытается подключиться к нему и возобновить его работу из 
отключённого состояния. Полезно, если в screen работают 
привилегированные программы и вы бы хотели защитись сеанс от других 
пользователей, замаскировавшихся под ваш uid (даже от 
суперпользователя). Если зашифрованный пароль не задан, screen дважды 
попросит ввести пароль и запомнит зашифрованный пароль в своём буфере 
обмена (paste buffer). По умолчанию <i>none</i>, что отключает парольную проверку вообще.
</dd></dl>
<dl><dt> <b>paste</b> [<i>registers</i> [<i>dest_reg</i>]]
</dt><dd> Вывести содержимое указанных регистров на стандартный поток 
ввода текущего окна.  Регистр "." обозначает буфер обмена screen (paste 
buffer).  Если параметров не задать, имя регистра запрашивается у 
пользователя.  В буфер обмена screen (paste buffer) информация попадает 
при помощи команд <i>copy</i>, <i>history</i> и <i>readbuf</i>. В другие регистры информация попадает при помощи команд <i>register</i>, <i>readreg</i> и <i>paste</i>. Если <i>paste</i>
 вызывается со вторым аргументом, содержимое регистров вклеивается не в 
текущее окно, а в регистр с заданным названием. Если в качестве второго 
аргумента указана ".", данные вклеиваются в буфер обмена дисплея 
(displays paste buffer). Обратите внимание, что <i>paste</i>, если 
указать второй аргумент, даже не требуется окно; если манипуляции 
происходят только с регистрами, даже не обязательно чтобы screen был 
подключен к экрану. Буфер обмена привязан к процессу screen; если с этим
 процессом работает несколько пользователей, буфер для них общий.
</dd></dl>
<dl><dt> <b>pastefont</b> [<i>on</i>|<i>off</i>]
</dt><dd> Сообщает screen нужно ли включать информацию о шрифтах в бувер
 вставки. По умолчанию включать не нужно. Эта команда имеет особо важное
 значение для многобайтных кодировкок, таких, например, как kanji.
</dd></dl>
<dl><dt> <b>pow_break</b>
</dt><dd> Повторно открыть (reopen) термиинальную линию окна (window's 
терминал line) и отправить символ разрыва (break condition). См. также <i>break</i>
</dd></dl>
<dl><dt> <b>pow_detach</b>
</dt><dd> Отключение питания (power detach). Очень похоже на обычное 
отключение (detach), но отправляется сигнал HANGUP родительскому 
процессу screen.
</dd><dd> Предупреждение. Вызов этой команды приведёт к завершению сеанса работы, если screen был запущен из login-оболочки.
</dd></dl>
<dl><dt> <b>pow_detach_msg</b> [<i>message</i>]
</dt><dd> Задаёт сообщение, которое выводится при выполнении <tt>Power detach</tt>.
  Может использоваться как замена для logout-сообщения или для сброса 
настроек линии (baud rate и т.д.).  При вызове без параметров 
показывается текущее сообщение.
</dd></dl>
<dl><dt> <b>prev</b>
</dt><dd> Переключиться на предыдущее окно. Команда может использовать многократно, для того чтобы циклически обойти все окна.
</dd></dl>
<dl><dt> <b>printcmd</b> [<i>cmd</i>]
</dt><dd> Если <i>cmd</i> не пустая, screen, когда встретит Escape-последовательность <tt>ESC [ 5</tt>, не будет использовать возможности (capabilities) терминала <tt>po/pf</tt>, а запустит вместо этого команду <i>cmd</i> и передаст вывод ей.  В качестве <i>cmd</i> хорошо подойдут команды <b>lpr</b> или "<b>cat</b> <tt>&gt; /tmp/scrprint</tt>" .  Если вызвать <i>printcmd</i> без команды, она покажет текущую настройку.  ANSI-последовательность ESC \ прекращает печать и закрывает канал.
</dd><dd> Предупреждение. Будьте осторожны с этой командой! Если у 
других пользователей есть доступ на запись в ваш терминал, они смогут 
запустить процесс печати.
</dd></dl>
<dl><dt> <b>process</b> [<i>key</i>]
</dt><dd> Вывести содержимое указанного регистра в буфер ввода. Если 
аргумент не задан, нужно будет ввести имя регистра с клавиатуры. Текст 
обрабатывается так, как будто он был введён с клавиатуры пользователя. 
Команда может использоваться для того чтобы привязать несколько действий
 к одному ключу.
</dd></dl>
<dl><dt> <b>quit</b>
</dt><dd> Убить все окна и завершить screen. Обратите внимание на то, 
что в VT100 сигналы C-4 и C-\ идентичны. Из-за этого стандартная 
привязка становится опасной: можно случайно нажать C-a C-4, когда 
выбираешь 4е окно. Для того чтобы отключить всякие действия от этой 
комбинации клавиш, можно вызывать пустой <i>bind</i>: "<tt>bind ^\</tt>".
</dd></dl>
<dl><dt> <b>readbuf</b> [-e <i>encoding</i>] [<i>filename</i>]
</dt><dd> Считывает содержимое указанного файла в буфер обмена.  Можно 
указать screen'у кодировку этого файла с помощью ключа -e. Если файл не 
указан, используется стандартный файл (см. screen-exchange). См. также 
команду <i>buffer-file</i>.
</dd></dl>
<dl><dt> <b>readreg</b> [-e <i>encoding</i>] [<i>register</i> [<i>filename</i>]]
</dt><dd> Делает одно из двух, в зависимости от количества аргументов: 
без аргументов или с одним аргументов содержимое буфера обмена 
дублируется в указанном в команде или введённом в приглашение регистре. 
При вызове с двумя аргументами содержимое файла считывается в регистр, 
точно также как при вызове команды <tt>readbuf</tt> содержимое файла <tt>screen-exchange</tt> считывается в буфер обмена. Кодировку файла можно задать при помощи опции <tt>-e</tt>. В приведённый ниже примере содержимое файла <tt>/etc/passwd</tt> вставляется в окно screen (с использованием регистра <tt>p</tt>, в котором остаётся копия):
</dd></dl>
<pre>   C-a&nbsp;: readreg p /etc/passwd
   C-a&nbsp;: paste p
</pre>
<dl><dt> <b>redisplay</b>
</dt><dd> Перерисовать текущее окно. Используется для того чтобы 
выполнить полную перерисовку при работе в режиме частичной отрисовки 
(partial redraw).
</dd></dl>
<dl><dt> <b>register</b> [-e <i>encoding</i>] <i>key</i> <i>string</i>
</dt><dd> Сохранить указанную строку в регистр с заданным ключом <i>key</i>. Кодировка строки может быть задана с помощью опции <tt>-e</tt>. Также смотрите опцию <i>command</i>.
</dd></dl>
<dl><dt> <b>remove</b>
</dt><dd> Уничтожить текущий регион. Это команда не имеет эффекта, если регион только один.
</dd></dl>
<dl><dt> <b>removebuf</b>
</dt><dd> Удалить файл screen-exchange, который использовался командами <i>writebuf</i> и <i>readbuf</i>.
</dd></dl>
<dl><dt> <b>reset</b>
</dt><dd> Приводит настройки виртуального терминала в исходное 
состояние. Полезно, когда на терминале из-за некорректного использования
 приложений появлюятся странные символы, типа квадратиков, вместо того 
чтобы выводился текст.
</dd></dl>
<dl><dt> <b>resize</b>
</dt><dd> Изменить размер текущего региона. Пространство будет добавлено
 или удалено из нижнего региона или, если его не хватит, из региона 
который выше.
</dd></dl>
<pre>   resize +N   увеличить высоту региона на N
   resize -N   уменьшить высоту региона на N
   resize  N   установить высоту региона равной N
   resize  =   сделать все регионы одинаковой высоты
   resize  max сделать текущий регион максимально высоким
   resize  min сделать текущий регион максимально низким
</pre>
<dl><dt> <b>screen</b> [-<i>opts</i>] [<i>n</i>] [<i>cmd</i> [<i>args</i>]]
</dt></dl>
<dl><dd> Создать новое окно. В команде могут быть указаны опции управления потоком (<tt>-f</tt>,  <tt>-fn</tt>  и  <tt>-fa</tt>), опция названия (<tt>-t</tt>), опции регистрации (<tt>-l</tt> и <tt>-ln</tt>) , опция типа терминала (<tt>-T</tt> <i>term</i>), опция флага всех возможностей (all-capability flag) (<tt>-a</tt>) и опция буфера прокрутки (<tt>-h</tt> <i>num</i>).  Опция <tt>-M</tt> включает мониторинг окна. Опция <tt>-L</tt> включает журнализацию вывода окна. Если задан опциональный номер <i>n</i>
 из диапазона 0..9, этот номер присваивается созданному окну (или,  если
 номер уже используется, следующий свободный).  Если после screen 
указана команда, она (вместе с заданными аргументами) запускается в 
окне; в противном случае создаётся окно с командным интерпретатором. 
Так, например, если в <tt>.screenrc</tt> есть строки:
</dd></dl>
<pre>   # example for .screenrc:
   screen 1
   screen -fn -t foobar -L 2 telnet foobar
</pre>
<dl><dd> screen создаст окно интерпретатора (в окне #1) и окно с 
TELNET-соединением на машину foobar (с отключённым flow-control, с 
заголовком "foobar", в окне #2) и будет писать журнал ("screenlog.2") 
сеанса работы в Telnet. Обратите внимание, что в отличие от предыдущих 
версий screen дополнительных окон не создаётся, если в <tt>.screenc</tt> есть хотя бы одна команда <i>screen</i>. Когда инициализации окончена, screen переключается на последнее окно, описанное в файле <tt>.screenrc</tt>, или, если таковых нет, открывает окно #0. В screen встроена некоторая функциональность <i>cu</i> и <i>telnet</i>. См. также раздел <a href="#.D0.A2.D0.B8.D0.BF.D1.8B_.D0.BE.D0.BA.D0.BE.D0.BD">Типы окон</a>.
</dd></dl>
<dl><dt> <b>scrollback</b> <i>num</i>
</dt><dd> Устанавливает размер буфера прокрутки для текущих окон равным <i>num</i> строк. По умолчанию: 100. См. также команду <i>defscrollback</i>, которая устанавливает размер буфера прокрутки по умолчанию, а также комбинацию клавиш <i>C-a i</i>, которая показывает текущую настройку.
</dd></dl>
<dl><dt> <b>select</b> [<i>WindowID</i>]
</dt></dl>
<dl><dd> Выбрать окно с идентификатором WindowID. Это может быть или 
номер окна или префикс в имени окна (алфавитно-цифровое имя). Если 
параметр не указывать, система попросит ввести идентификатор. При 
создании окон берётся первый незанятый номер. Поэтому переход на самое 
первое окно выполняется по команде <tt>select 0</tt>. Максимальное количество окон ограничивается при компиляции параметром <tt>MAXWIN</tt>.
 Есть два специальных обозначения: "-" для внутреннего окна и "." для 
текущего окна. Последнее очень полезно при использовании с "<tt>screen -X</tt>".
</dd></dl>
<dl><dt> <b>sessionname</b> [<i>name</i>]
</dt><dd> Переименовать текущий сеанс. Обратите внимание, что в выводе 
'screen -list' имя показывается с идентификатором процесса. Если 
аргумент <i>name</i> опущен, просто показывается имя сеанса. 
</dd><dd> Предупреждение: переменная <tt>$STY</tt> после переименования 
всё равно содержит старое имя. Это может привести к путанице. По 
умолчанию имя составляется из названия терминала и имени хоста.
</dd></dl>
<dl><dt> <b>setenv</b> [<i>var</i> [<i>string</i>]]
</dt><dd> Установить переменную окружения <i>var</i> равной <i>string</i>. Если указать только <i>var</i>,
 система попросит ввести значение. Если параметры не заданы вообще, 
система попросит ввести и название переменной и значение. Среда 
окружения будет наследоваться всеми оболочками, которые будут запущены 
из screen.
</dd></dl>
<dl><dt> <b>setsid</b> [<i>on</i>|<i>off</i>]
</dt></dl>
<dl><dd> В нормальном режиме screen использует отдельные группы сеансов и процессов для своих окон. Если выключить <i>setsid</i>,
 так больше не происходит, и все окна находятся в одной группе 
процессов, с основным процессом screen (screen backend proccess). 
Обратите внимание, что в этом случае не будет работать управление 
работами (job control). По умолчанию <i>setsid</i> включен. Команда редко когда может оказаться полезной.
</dd></dl>
<dl><dt> <b>shell</b> <i>command</i>
</dt><dd> Задаёт команду, которая должна использоваться при создании 
новой оболочки. Этот параметр перекрывает значение переменной окружения <tt>$SHELL</tt>. Полезно, если вы любите запускать расширитель терминала (tty-enhancer), который запускает программу, указанную в <tt>$SHELL</tt>. Если команда начинается символом <tt>-</tt>, оболочка будет запущена как login-оболочка (login-shell).
</dd></dl>
<dl><dt> <b>shelltitle</b> <i>title</i>
</dt><dd> Задаёт заголовок для всех окон с командным интерпретатором, которые создаются при запуске или при нажатии <b>C-a C-c</b>. Подробнее в разделе «<a href="#.D0.9D.D0.B0.D0.B7.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F_.28.D0.B8.D0.BC.D0.B5.D0.BD.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BE.D0.BA.D0.BE.D0.BD.29">Названия (именование окон)</a>».
</dd></dl>
<dl><dt> <b>silence</b> [<i>on</i>|<i>off</i>|<i>sec</i>]
</dt><dd> Управляет наблюдением за тишиной (silence monitoring) в окнах.
 Когда silence для окна включен, и в течение некоторого времени в нём 
нет изменений, в статусной строке появляется соответствующее сообщение. 
 Длительность ожидания можно изменять с помощью команды <i>sliencewait</i> или путём указания количества секунд в качестве аргумента (вместо <i>on</i> или <i>off</i>). По умолчанию: <i>off</i>.
</dd></dl>
<dl><dt> <b>silencewait</b> <i>sec</i>
</dt><dd> Определяет время, в течение которого в окнах, в которых 
отслеживается тишина, должно не происходить никаких действий, прежде чем
 выводить соответствующее сообщение. По умолчанию 30 секунд.
</dd></dl>
<dl><dt> <b>sleep</b> <i>num</i>
</dt><dd> Приостанавливает выполнение файла .screenrc на заданное 
количество секунд. Любая клавиатурная активность останавливает ожидание.
 Это может пригодиться, когда нужно сделать чтобы пользователь мог 
прочитать сообщение, выводимое с помощью <i>echo</i>.
</dd></dl>
<dl><dt> <b>slowpaste</b> <i>msec</i>
</dt></dl>
<dl><dd> Определяет скорость, с которой текст будет вставляться в текущее окно при вызове команды <i>paste</i> (нажатии "C-a ]"). Если значение slowpaste отлично от 0, текст вводится посимвольно и screen делает паузу <i>msec</i> миллисекунд после каждого символа, для того чтобы приложение могло успеть обработать ввод. Команду <i>slowpaste</i>
 нужно использовать только в тех случаях, когда доступная через screen 
система обрабатывает большие объёмы мгновенно вставляемого текста с 
ошибками.
</dd></dl>
<dl><dt> <b>source</b> <i>file</i>
</dt><dd> Прочитать и выполнить команды из файла <i>file</i>. Команда <i>source</i> может быть вложенной, с максимальной глубиной рекурсии до 10. Если имя <i>file</i> не содержит абсолютного пути и screen сейчас выполняет команду <i>source</i>, новый файл ищется в родительском каталоге текущей команды <i>source</i>, и если там ничего не найдено, выполняется поиск в текущем каталоге.
</dd><dd> Обратите внимание, что команды <i>termcap</i>, <i>terminfo</i> и <i>termcapinfo</i>
 работают только при запуске и при повторном подключении (reattach); 
поэтому, для того чтобы они имели эффект, их нужно вызывать из файлов 
screenrc.
</dd></dl>
<dl><dt> <b>sorendition</b> [<i>attr</i> [<i>color</i>]]
</dt><dd> Указывает способ, который screen использует для подсветки 
текста и печатаемых сообщений. Синтаксис модификаторов описан в разделе 
 «<a href="#Escape-.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D1.81.D1.82.D0.B8">Escape-последовательности</a>». Сейчас по умолчанию "=s dd" (standout, цвета по умолчанию).
</dd></dl>
<dl><dt> <b>split</b>
</dt><dd> Разделить текущий регион на два новых. Размеры всех регионов 
на экране меняются для того чтобы освободить место для ного региона. В 
новом регионе отображается пустое окно. Удалить регион можно с помощью 
команды <i>remove</i> или <i>only</i>.
</dd></dl>
<dl><dt> <b>startup_message</b> <i>on</i>|<i>off</i>
</dt><dd> Должно ли показывать сообщение с информацией о правах на программу при её старте. По умолчанию <i>on</i>, как уже можно было убедиться.
</dd></dl>
<dl><dt> <b>stuff</b> <i>string</i>
</dt><dd> Вставляет строку <i>string</i>  в текущее окно. Похоже на команду <i>paste</i>, но с меньшими накладными расходами. С помощью команды <i>stuff</i> нельзя вставить большие объёмы текста. Очень полезно для управления привязками клавиш. См. также <i>bindkey</i>.
</dd></dl>
<dl><dt> su [<i>username</i> [<i>password</i> [<i>password2</i>]]
</dt><dd> Изменить пользователя дисплея. Команда спросит все параметры, 
которые не указаны как аргументы. Если в качестве аргументов указываются
 пароли, они должны указываться не в зашифрованном виде. Первый пароль 
проверяется через системную базу паролей, а второй -- через собственную 
базу screen (в которую пароли попали через команды <i>acladd</i> и <i>password</i>). Команда <i>su</i>
 может пригодиться для администраторов screen, которые хотя проверить 
многопользовательские настройки. Если аутентификацию не пройти, доступ 
есть только к командам, доступным пользователю nobody. К этим командам 
относятся "<i>detach</i>",  "<i>license</i>",  "<i>version</i>", "<i>help</i>" и "<i>displays</i>".
</dd></dl>
<dl><dt> <b>suspend</b>
</dt><dd> Приостановить screen. Окна всё это время находятся в 
отключённом состоянии. Данная особенность полагается на возможности 
командного интерпретатора по управлению работами (job control).
</dd></dl>
<dl><dt> <b>term</b> <i>term</i>
</dt><dd> В каждом окне, которое открывает screen, переменная <tt>$TERM</tt> устанавливается по умолчанию равной <tt>screen</tt>. Но, когда в локальных базах данных termcap и terminfo нет поддержки screen, надо установить <tt>$TERM</tt> равной, скажем, <tt>vt100</tt>.
  В этом нет ничего страшного, посколько screen совместим с VT100/ANSI. 
Не рекомендуется использовать эту команду за исключением тех случаев, 
когда задаются настройки по умолчанию. Например, в случае, когда нужно 
задать настройки терминала для одной команды, скажем для <tt>screen  rlogin  othermachine</tt>, лучше использовать вызов "<tt>screen -T vt100 rlogin othermachine</tt>" чем устанавливать или сбрасывать настройки по умолчанию.
</dd></dl>
<dl><dt> <b>termcap</b> <i>term</i> <i>terminal-tweaks</i> [<i>window-tweaks</i>]
</dt><dt> <b>terminfo</b> <i>term</i> <i>terminal-tweaks</i> [<i>window-tweaks</i>]
</dt><dt> <b>termcapinfo</b> <i>term</i> <i>terminal-tweaks</i> [<i>window-tweaks</i>]
</dt></dl>
<dl><dd> Команда модифицирует termcap-запись терминала без необходимости
 выполнениях хитрых операций, связанных с созданием собственной 
termcap-записи.  Кроме того, с её помощью можно подстраивать 
termcap-записи сгенерированные для окон.  Эти команды имеет смысл 
размещать только в <tt>screenrc</tt>, поскольку после того как screen 
запущен, команды уже не нужны. Если в системе используется база данных 
terminfo, а не termcap, screen поймёт команду <b>terminfo</b>, у которой такой же эффект как и у команды <b>termcap</b>.
  Две отдельные команды существуют из-за нескольких тонких 
синтаксических отличий, в частности, там где выполняется интерполяция "<tt>%</tt>" параметров.  Обратите внимание, что даже с <i>terminfo</i> нужно использовать имена возможностей (capabilities) от termcap.  Во многих случаях, когда аргументы подходят как для <b>terminfo</b>, так и для <b>termcap</b>, можно использовать команду <b>termcapinfo</b>, которая является сокращением для пары команды (<b>termcap</b> и <b>terminfo</b>) с идентичными аргументами.
</dd></dl>
<dl><dd> Первый аргумент указывает на какой терминал (или терминалы) 
должно подействовать определение. Можно задавать множество имён 
терминалов через <tt>|</tt>, <tt>*</tt> обозначает все терминалы, а <tt>vt*</tt> -- все терминалы, начинающиеся на <tt>vt</tt>.
</dd></dl>
<dl><dd> Каждый аргумент <i>tweak</i> содержит одно (или более) 
определение termcap (разделённых сиволом ":"), которые вставляются в 
начало соответствующей записи termcap, дополняя или перекрывая 
существующие значения.  Первый <i>tweak</i>  изменяет termcap вашего 
терминала. Он содержит определения, которые терминал использует для 
выполнения определённых функций. Если указать пустую строку "", чтобы не
 делать никаких изменений.  Второй (опциональный) <i>tweak</i> изменяет  termcap'ы окон, он должен содержать определения, которые screen поймёт (см. раздел <a href="#.D0.92.D0.B8.D1.80.D1.82.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B9_.D1.82.D0.B5.D1.80.D0.BC.D0.B8.D0.BD.D0.B0.D0.BB">Виртуальный терминал</a>).
</dd></dl>
<dl><dd> Некоторые примеры:
</dd></dl>
<pre>   termcap xterm*  LP:hs@
</pre>
<dl><dd> Говорит screen о том, что у всех терминало, имя типа которых начинается с "<tt>xterm</tt>",
 должны быть жёсткие автоотступы (firm auto-margins), которые позволят 
обновляеть последнюю позицию экрана (LP), и у которых нет статусной 
строки, hardstatus (нет "hs" --- если добавить "<tt>@</tt>" в конец записи, она выключается).
</dd></dl>
<dl><dd> Обратите внимание, что "<tt>LP</tt>" подразумевается для всех терминалов, имя типа которых начинается с <tt>vt</tt>, за исключением тех терминалов, для которых указана команда <b>termcap</b>.
</dd></dl>
<pre>   termcap vt*  LP
   termcap vt102|vt220  Z0=\E[?3h:Z1=\E[?3l
</pre>
<dl><dd> Определяет возможность (capability) "<tt>LP</tt>" для всех терминалов, название типа которых начинается с "<tt>vt</tt>".
  Вторая строка добавляет поддержку escape-последовательностей для 
переключения в режим 132 символа на строку (Z0) и из него (Z1) для 
терминалов VT102 и VT220 (для того чтобы использовать команды по 
изменению ширины, нужно указать Z0 и Z1 в файле termcap)
</dd></dl>
<pre>   termcap vt100  ""  l0=PF1:l1=PF2:l2=PF3:l3=PF4
</pre>
<dl><dd> Здесь termcap vt100 остаётся нетронутым, а в termcap-записи окон добавляются метки функциональных клавиш.
</dd></dl>
<pre>   termcap h19|z19  am@:im=\E@:ei=\EO  dc=\E[P
</pre>
<dl><dd> В termcap'ах h19 и z19 выключаются автоотступы (<tt>am@</tt>, auto margin) и включаются режим вставки (<tt>im</tt>, insert mode) и конец вставки (<tt>ei</tt>, end-insert) (символ "<tt>@</tt>"  в строке "<tt>im</tt>" идёт после "<tt>=</tt>", так что это часть строки).  Если добавить определения "<tt>im</tt>" и "<tt>ei</tt>"
 в termcap терминала, где запущен screen, они автоматически будут 
передаваться в termcap каждого окна.В каждом окне появляется новая 
возможность (capability): удаление символа delete-character (dc), 
которое screen транслирует в обновление строки терминала 
(предполагается, что терминал не имеет возможности удалять символ).
</dd></dl>
<dl><dd> Если нужно полностью задать записть termcap, лучше использовать переменную <tt>$SCREENCAP</tt>, которую установить до запуска screen. Подробнее в разделе «<a href="#.D0.92.D0.B8.D1.80.D1.82.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B9_.D1.82.D0.B5.D1.80.D0.BC.D0.B8.D0.BD.D0.B0.D0.BB">Виртуальный терминал</a>» и в man-странице termcap(5), где подробно рассказывается об определениях termcap.       
</dd></dl>
<dl><dt> <b>time</b> [<i>string</i>]
</dt><dd> Показать в строке сообщений время, имя хоста и нагрузку (load 
average) за 1, 5 и 15 минут (если это поддерживается в системе). Для 
получения информации об окне используйте команду <i>info</i>. 
</dd><dd> Если задан аргумент <i>string</i>, формат меняется как описано в разделе «<a href="#Escape-.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D1.81.D1.82.D0.B8">Escape-последовательности</a>». По умолчанию "<tt>%c:%s&nbsp;%M&nbsp;%d&nbsp;%H%?&nbsp;%l%?</tt>".
</dd></dl>
<dl><dt> <b>title</b> [<i>windowtitle</i>]
</dt><dd> Задаёт имя текущего окна. Если имя не указано, screen выдаёт 
приглашение для его ввода. В более ранних версиях screen команда была 
известнка как <i>aka</i>.
</dd></dl>
<dl><dt> <b>unsetenv</b> <i>var</i>
</dt><dd> Удалить переменную окружения.
</dd></dl>
<dl><dt> <b>utf8</b> [<i>on</i>|<i>off</i> [<i>on</i>|<i>off</i>]]
</dt></dl>
<dl><dd> Изменяет кодировку текущего окна. Если включён utf8, строки 
отправляемые в окно, будут перекодированы в UTF-8 (и наоборот). Если не 
задавать параметры, настройки переключаются на противоположные. Если 
задан второй параметр, меняется также настройка отображения (display 
encoding); обычно это делается с помощью опции командной строки -U. 
Также, смотрите команду <i>defutf8</i>, которая меняет начальные настройки для новых окон.
</dd></dl>
<dl><dt> <b>vbell</b> [<i>on</i>|<i>off</i>]
</dt></dl>
<dl><dd> Настройка визуального звонка для окна. Если вызвать без 
параметра, настройка переключается. Если визуальный звонок включен, но 
терминал не поддерживает его, при поступлении символа звонка (^G) в 
строке статуса выводится сообщение <i>vbell-message</i>. Поддержка визуального звонка терминалом определяется переменной termcap <tt>vb</tt> (или <tt>flash</tt> в terminfo). По умолчанию vbell выключен и используется звуковой звонок. См. также <i>bell_msg</i>.
</dd></dl>
<dl><dt> <b>vbell_msg</b> [<i>message</i>]
</dt></dl>
<dl><dd> Задаёт сообщение для визуального звонка (visual bell). Сообщение <i>message</i>
 выводится в строке статуса в момент, когда в окно выводится символ 
звонка (bell character, ^G) и при этом vbell включен, но терминал не 
поддерживает visual vell. По умолчанию выводится сообщение <tt>Wuff, Wuff!!</tt>. Если вызывать команду без параметров, будет показано текущее сообщение.
</dd></dl>
<dl><dt> <b>vbellwait</b> <i>sec</i>
</dt><dd> Определяет задержку в секундах для каждого вывода визуального звонка (visual bell) в screen. По умолчанию 1 секунда.
</dd></dl>
<dl><dt> <b>verbose</b> [<i>on</i>|<i>off</i>]
</dt><dd> Если включено, при создании (или восстановлении) окна, 
выводится имя вызванной команды. По умолчанию выключено. При вызове без 
параметров показывается текущая настройка.
</dd></dl>
<dl><dt> <b>version</b>
</dt><dd> Вывести текущую версию и дату компиляции в строку статуса.
</dd></dl>
<dl><dt> <b>wall</b> <i>message</i>
</dt><dd> Вывести сообщения на все окна. Это сообщение будет показано в строке статуса терминала.
</dd></dl>
<dl><dt> <b>width</b> [-w|-d] [<i>cols</i> [<i>lines</i>]]
</dt></dl>
<dl><dd> Переключает ширину окна между 80 и 132 (или устанавливает 
равной заданной, при условии, если она указана). Требует поддержки со 
стороны терминала (записи Z0 и Z1). См. команду <i>termcap</i>. Можно 
менять не только ширину6 но и высоту. Для этого нужно указать второй 
аргумент. Если задать ключ -w, меняется только ширина окна; если задать 
ключ -d, меняется только размер видимой области (display size).
</dd></dl>
<dl><dt> <b>windowlist</b> [-b] [-m]
</dt><dt> <b>windowlist</b> <b>string</b> [<i>string</i>]
</dt><dt> <b>windowlist</b> <b>title</b> [<i>title</i>]
</dt></dl>
<dl><dd> Показывает список всех окон в виде таблицы для того чтобы можно
 было выбрать окно визуально. Окно выбирается стандартными клавишами 
управления курсором (см. команды <i>copy</i>) и активируется клавишей <i>return</i>. Если задана опция <tt>-b</tt>, screen перед тем как показать список переключится на пустое окно, поэтому текущее окно можно тоже будет выбрать. Опция <tt>-m</tt>
 задаёт порядок окон: вместо того чтобы сортировать их в порядке 
возрастания номеров, они сортируются по принципу, кто использовался 
последним.
</dd></dl>
<dl><dd> Формат таблицы можно изменить опциями <i>string</i> и <i>title</i>; в качестве заголовка таблицы показывается <i>title</i>, а строки создаются на основе строк <i>string</i>. По умолчанию: заголовок "Num Name%=Flags" и строки "%3n&nbsp;%t%=%f". См. раздел <a href="#Escape-.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D1.81.D1.82.D0.B8">Escape-последовательности</a>, где описано большее число кодов (в том числе цветовых).
</dd></dl>
<dl><dt> <b>windows</b>
</dt></dl>
<dl><dd> Выводит в строке сообщений список всех окон. Каждое окно 
выводится с номером и именем процесса, который запущен в этом окне (или 
заголовком); текущее окно отмечено символом "*", а предыдущее --- 
символом "-"; все окна, которые зарегистрированы (logged in) отмечены 
символом "<tt>$</tt>"; фоновые окна, в которых был звонок (bell), отмечены символом "<tt>!</tt>"; фоновые окна, за которыми выполняется наблюдение, и в которых была замечена активность, отмечаются символом "<tt>@</tt>"; окна, в которых включена запись (logging),  отмечены символом "<tt>(L)</tt>"; окна, занятые другим пользователем, отмечены символом "<tt>&amp;</tt>"; окна, находящиеся в состоянии зомби, отмечены символом "<tt>Z</tt>". Если список окон слишком большой и не влазит полностью на терминал, выводится только его часть.
</dd></dl>
<dl><dt> <b>wrap</b> [<i>on</i>|<i>off</i>]
</dt><dd> Задаёт настройки переноса (line-wrap) для текущего окна. Если 
line-wrap включен, символ, следующий за последним выведенным в строке, 
будет выводиться на следующей строке. Backspace (^H) при этом будет 
переходить на предыдущую строку через левый край. По умолчанию: <i>on</i>
</dd></dl>
<dl><dt> <b>writebuf</b> [-e <i>encoding</i>] [<i>filename</i>]
</dt><dd> Выводит содержимое буфера обмена в указанный файл или в 
общедоступный файл screen-exchnage, если никакой файл не указан. Эту 
команду можно использовать для организации примитивного обмена данными 
между пользователями screen, работающими на одном компьютере. Если 
указана кодировка, текст налету перекодируется. Имя файла для обмена 
задаётся с помощью команды <i>bufferfile</i>; по умолчанию равно <tt>/tmp/screen-exchange</tt>.
</dd></dl>
<dl><dt> <b>writelock</b> [<b>on</b>|<b>off</b>|<b>auto</b>]
</dt><dd> В дополнение к спискам контроля доступа есть еще ограничение, 
которое запрещает писать нескольким пользователем в одно окно 
одновременно. По умолчанию, writelock находится в режиме <i>auto</i> и 
эксклюзивный доступ на запись предоставляется тому пользователю, который
 первым переключился в это окно. Когда этот пользователь покидает окно, 
другие пользователи могут захватить блокировку (автоматически). 
Блокировка записи в текущее окно может быть отключена при помощи команды
 <i>writelock off</i>. Если пользователь даст команду <i>writelock on</i>, он сохранит за собой экслюзивную блокировку даже на время переключения в другие окна.
</dd></dl>
<dl><dt>   <b>xoff</b>
</dt><dt>   <b>xon</b>
</dt><dd>      Вставляет символ CTRL-s / CTRL-q в поток stdin текущего окна.
</dd></dl>
<dl><dt> <b>zmodem</b> [<b>off</b>|<b>auto</b>|<b>catch</b>|<b>pass</b>]
</dt><dt> <b>zmodem</b> <b>sendcmd</b> [<i>string</i>]
</dt><dt> <b>zmodem</b> <b>recvcmd</b> [<i>string</i>]
</dt></dl>
<dl><dd> Настройка поддержки zmodem. Когда программа screen видит запрос zmodem, она понимает два режима работы: <i>pass</i> и <i>catch</i>. Если задан режим <i>pass</i>, screen будет ретранслировать все данные, до тех пор пока передача не окончится. В режиме <i>cactch</i> screen сам работает как конечная точка zmodem и выполняет соответствующие команды rz/sz. Если включен режим <i>auto</i>, screen смотрит является ли окно терминалом tty (например, последовательным портом) и переходит в режим <i>cacth</i>, иначе использует <i>pass</i>. Можно задавать шаблоны для режима <i>catch</i> при помощи второй и третьей формы вызова. 
</dd><dd> <i>Это экспериментальная возможность!</i>
</dd></dl>
<dl><dt> <b>zombie</b> [<i>keys</i>]
</dt><dt>  <b>defzombie</b> [<i>keys</i>]
</dt><dd> По умолчанию окна screen удаляются из списка, как только процессы окон (т.е. оболочки) завершаются. Если вызвать команду <i>zombie</i>
 с аргументом из двух ключей, мёртвые окна будут оставаться. Убить такое
 окно можно с помощью команды kill.  Нажатие первой кнопки в мёртвом 
окне делает то же самое.  Если нажать вторую кнопку, screen пытается 
оживить окно. Процесс, который изначально работал в окне, запускается 
снова.  Если вызвать <i>zombie</i> без параметров, настройки собьются, то есть окна будут исчезать, как только процессы в них завершаются.
</dd><dd> Посколько настройки для зомби задаются одновременно на все окна, эту команду правильнее было бы назвать <i>defzombie</i>. Пока не возникнет необходимость в команде действующей на отдельное окно, команды <i>zombie</i> и <i>defzombie</i> синонимы.
</dd></dl>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=8" title="Править секцию: Строка сообщений">править</a>]</span> <span class="mw-headline" id=".D0.A1.D1.82.D1.80.D0.BE.D0.BA.D0.B0_.D1.81.D0.BE.D0.BE.D0.B1.D1.89.D0.B5.D0.BD.D0.B8.D0.B9"> Строка сообщений </span></h2>
<p>Screen выводит информационные и другие диагностические сообщения в строку сообщений (message line).
По умолчанию она показывается в самом низу окна, но при компиляции можно задать, 
чтобы эта строка показывалась вверху. Если у терминала есть статусная строка (status line),
будет использоваться она. Иначе, вывод на текущий экран будет временно переписан сверху.
Сообщение удаляется после нескольких секунд задержки, но оно может быть удалено и раньше, 
если начать печатать.
</p><p>Строку сообщение можно использовать в приложениях с помощью управляющей последовательности
ANSI Privacy message. Например, можно в командном интерпретаторе дать команду:
</p>
<pre>   echo '&lt;esc&gt;^Hello world from window '$WINDOW'&lt;esc&gt;\\'
</pre>
<p>Здесь &lt;esc&gt; ­— это escape, <tt>^ </tt>­— это стрелка вверх, а <tt>\\</tt> превращается в обратный слэш.
</p>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=9" title="Править секцию: Типы окон">править</a>]</span> <span class="mw-headline" id=".D0.A2.D0.B8.D0.BF.D1.8B_.D0.BE.D0.BA.D0.BE.D0.BD"> Типы окон </span></h2>
<p>У screen есть три различных типа окон.
Новые окна создаются при помощи команды <i>screen</i> (см. соответствующую запись в разделе «<a href="#.D0.98.D0.BD.D0.B4.D0.B8.D0.B2.D0.B8.D0.B4.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D0.B0.D1.8F_.D0.BD.D0.B0.D1.81.D1.82.D1.80.D0.BE.D0.B9.D0.BA.D0.B0">Индивидуальная настройка</a>»).
Первый аргумент команды screen задаёт тип создаваемого окна. Различные типы окон — это модификации
нормального типа.  Они были сделаны для эффективной работы при количестве окон от 100 и выше.
</p>
<ul><li>  Нормальное окно, в котором запущен командный интерпретатор (по
 умолчанию) или любая другая команда, которая должна исполняться изнутри
 интерпретатора.
</li></ul>
<ul><li>  Если в качестве первого параметра указан специальный файл 
устройства (например, "/dev/ttya"), screen напрямую пытается к нему 
подключиться.  Окно этого типа равносильно окну, в котором запущено 
"screen cu -l /dev/ttya".  Нужны права на чтение и запись для 
соответствующего файла устройства; для того чтобы показать что линия 
занята, screen пытается открыть файл эксклюзивно.  Опциональный параметр
 может принимать значение разделённого запятыми списка флагов в нотации <b>stty</b>:
</li></ul>
<dl><dt>          &lt;baud_rate&gt;
</dt><dd>                 Обычно 300,  1200, 9600 или 19200. Влияет как на скорость передачи, так и на скорость приёма.
</dd></dl>
<dl><dt>          cs8 или cs7
</dt><dd>                 Задаёт передачу восьми или семи битов на байт.
</dd></dl>
<dl><dt>          ixon или -ixon
</dt><dd>                 Включает (или выключает) программное управление потоком (CTRL-S/CTRL-Q) при передаче данных.
</dd></dl>
<dl><dt>          ixoff или -ixon
</dt><dd>                 Включает (или выключает) программное управление потоком при приёме данных.
</dd></dl>
<dl><dt>          istrip или -istrip
</dt><dd>                 Удаляет (или сохраняет) восьмой бит в каждом полученном байте.
</dd></dl>
<dl><dd> Можно указывать столько этих опций сколько нужно.  Если опции 
не задавать, решение о значении параметров соединения принимает драйвер 
терминала.  Эти значения зависят от системы. Они могут или принимать 
значения по умолчанию или значения, сохранённые с прошлого соединения.
</dd></dl>
<dl><dd> Для tty-окон команда <i>info</i> показывает в строке статуса 
состояние управляющих линий модема.  В их числе могут быть "RTS", "CTS",
  "DTR", "DSR",  "CD"  и другие.  Список линий зависит от того какие 
ioctl() доступны, от системных заголовчных файлов, а также от физических
 возможностей платы последовательных портов.  Перед названием неактивных
 (low level) сигналов ставится восклицательный знак (!).  Если знака 
нет, значит сигнал активен (high level).  Сигналы, которые не 
поддерживаются оборудованием, но доступны через ioctl(), обычно 
показываются выключенными (low level).  Если локальный бит состояния 
CLOCAL включен, весь набор сигналов модема выводится в фигурных скобках 
({ и }).  Если установлен бит CRTSCTS или TIOCSOFTCAR, в скобках 
показываются сигналы "CTS" или "CD",  соответственно.
</dd></dl>
<dl><dd> Для tty-окон команда <i>break</i> переводит линию передачи 
данных (Data transmission line) (TxD) в неактивное состояние на заданный
 период времени. На той стороне это должно проинтерпретироваться как 
сигнал разрыва.  При нажатии break данные не отправляются, линии 
управления модемом не трогаются.
</dd></dl>
<ul><li>  Если первый параметр это "//telnet",  второй параметр должен 
быть именем хоста, опциональный третий параметр — номером порта (по 
умолчанию 23, десятиричное).  Screen подсоединится к удалённому серверу 
при помощи протокола Telnet.  Для telnet-окон команда <i>info</i> показывает в конце статусной строки в квадратных скобках ([ и ]) детальную информацию о соединении.
</li></ul>
<pre>   b      BINARY. Соединение в двоичном (бинарном) режиме.
   e      ECHO. Локальное эхо выключено.
   c      SGA.  Соединение в символьном режиме (character mode). По умолчанию в режиме строки (line mode).
   t      TTYPE. Тип терминала был запрошен удалённым хостом.
       Screen отправляет имя "screen", если не задано ничего другого
       (см. также команду <i>term</i>).
   w      NAWS. Удалённая система предупреждается об изменении размера окна.
   f      LFLOW.  Удалённый хост отправит информацию об управлении потоком.
       (Сейчас игнорируется.)
</pre>
<p>Дополнительные флаги для отладки: <tt>x</tt>, <tt>t</tt> и <tt>n</tt> (XDISPLOC, TSPEED  и NEWENV).
</p><p>Для окон telnet команда <i>break</i> отправляет удалённому хосту Telnet-код IAC BREAK (десятичный 243).
</p><p>Этот тип окна доступен только в том случае, если screen был откомпилирован с опцией BUILTIN_TELNET.
</p>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=10" title="Править секцию: Escape-последовательности">править</a>]</span> <span class="mw-headline" id="Escape-.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D1.81.D1.82.D0.B8"> Escape-последовательности </span></h2>
<p>У screen есть механизм escape-последовательностей,  с  помощью которых
в сообщения или имена  файлов  можно  вставлять  различную  информацию,
например, такую  как текущее время.  Escape-символ это всегда символ&nbsp;%,
за одним исключением: внутри строки hardstatus используется ^% (^E).
</p><p>Полный список поддерживаемых escape-последовательностей:
</p>
<pre>     &nbsp;%      сам escape-символ
      a      или "am", или "pm" 
      A      или "AM", или "PM"
      c      текущее время HH:MM в 24-часовом формате
      C      текущее время HH:MM в 12-часовом формате
      d      номер дня
      D      название дня недели
      f      флаги окна
      F      устанавливает&nbsp;%? равным true (истина), если окно получает фокус
      h      статус окна (hardstatus)
      H      имя системы (hostname)
      l      текущий уровень нагрузки на систему
      m      номер месяца
      M      имя месяца
      n      номер окна
      s      секунды
      t      заголовок окна
      u      остальные пользователи на этом окне
      w      номера и имена всех окон. С символом "-" до текущего окна; с символом "+"
             после текущего окна
      W      номера и имена всех окон за исключением текущего 
      y      последние две цифры года
      Y      полный год
     &nbsp;?      показывается часть до следующего знака&nbsp;%? (только если&nbsp;% внутри этой части 
             раскрывается в не пустую строку)
     &nbsp;:      часть else&nbsp;%?
</pre>
<pre>      =      заполнить строку на ширину экрана (как hfill в TeX). Если задан номер, 
             number is specified, pad  to  the  percentage  of  the  window's
             width.   Квалификатор  "0"  говорит о том, что номер надо воспринимать как 
             абсолютную позицию.
             You can specify to pad relative to the  last
             absolute  pad position by adding a "+" qualifier or to pad relative
             to the right margin by using "-". The padding truncates the
             string  if  the specified position lies before the current position.
             Для того чтобы изменить это, нужно использовать квалификатор "L".
</pre>
<pre>      &lt;      то же что и "%=", но только обрезать, и не заполнять пробелами
</pre>
<pre>      &gt;      поставить отметку в текущей позиции для следующей обрезки.
             Когда screen должен сделать обрезку, он старается сделать её так,
             что бы маркированная позиция переместилась на заданный процент 
             области вывода.
             (Область начинается с последней абсолютной позиции заполнителя
             и заканчивается в месте, заданном оператором обрезки).
             Дополнительный символ "L" говорит screen о том, что нужно отметить
             обрезанный кусочек символами "...".
</pre>
<pre>      {      строка-модификатор атрибута/цвета, заканчивающаяся следующим "}"
</pre>
<pre>      `      Заменить команды внутри кавычек результатом их выполнения. The  length
             qualifier is misused to identify one of the commands.
</pre>
<p>С последовательностями "c"  и "C" можно использовать квалификатор "0"
 — тогда для заполнения пустого 
пространства будет использоваться "0", а не пробел. Если использовать 
квалификатор "0", в escape-последовательности
"=" позиции начинают восприниматься как абсолютные.
Escape-коды "n" и "=" понимают квалификатор длины
(например, "%3n"); перед "D" и "M" можно ставить "L" для того чтобы 
генерировать длинные имена "L", а если поставить "L" перед "w" или "W",
будут показываться флаги окон.
</p><p>Модификатор атрибута/цвета используется для изменения настроек атрибута
или цвета. Его формат "[модификатор атрибута] [описание цвета]".   Если 
модификатор атрибута можно перепутать с описанием цвета, перед ним надо
ставить специальный индикатор изменения типа.   Это  один  из следующих
символов:
</p>
<pre>   +      добавляет указанное множество к текущим атрибутам 
   -      удаляет указанное множество из текущих атрибутов
  &nbsp;!      инвертирует множество текущих атрибутов
   =      заменяет множество текущих атрибутов на указанное множество
</pre>
<p>Множество атрибутов может быть задано или в виде шестнадцатеричного числа 
или в виде комбинации следующих букв:
</p>
<pre>   d      тусклый
   u      подчёркнутый
   b      полужирный
   r      реверсивный
   s      выдающийся
   B      мигающий
</pre>
<p>Цвета или кодируются шестнадцатеричным числом или комбинацией двух букв,
указывающих цвет фона и цвет символа (в таком порядке). Известны  такие
цвета:
</p>
<pre>   k      чёрный
   r      красный
   g      зелёный
   y      жёлтый
   b      синий
   m      фиолетовый
   c      цвета морской волны
   w      белый 
   d      по умолчанию
   .      оставить цвет без изменения
</pre>
<p>Буквы в верхнем регистре обозначают яркие цвета. Можно использовать букву
псевдо-цвет "i", которая меняет яркость, но оставляет сам цвет таким же.
A one digit/letter color description is treated as foreground or background 
color dependant on the current attributes: если установлен реверсивный режим, 
меняется фон, а не цвет символа.
Если поставить перед цветом ".", так происходить не будет. 
Если нужно такое же поведение, как при двусимвольном описании цвета,
нужно тоже ставить ".".
Особый случай, "%{-}" восстанавливает атрибуты и цвет, которые были 
установлены до того как были сделаны последние изменения (грубо говоря, 
выталкивает один уровень изменений цвета из стека).
</p><p>Примеры:
</p>
<pre>   "G"    установить ярко-зелёный цвет
</pre>
<pre>   "+b r" использовать красный полужирный
</pre>
<pre>   "= yd" стереть все атрибуты, писать цветом по умолчанию на жёлтом фоне
</pre>
<pre>  &nbsp;%-Lw%{= BW}%50&gt;%n%f*&nbsp;%t%{-}%+Lw%&lt;
           Список окон обрезанный до доступной величины (слева и справа). Имя
           текущего окна выводится белым на синем фоне. Можно использовать
           вместе с "hardstatus alwayslastline".
</pre>
<pre>  &nbsp;%?%F%{.R.}%?%3n&nbsp;%t%? [%h]%?
           Номер окна, заголовок и hardstatus, если он установлен. Красный 
           фон, если есть фокус. Удобно для строки заголовка.
</pre>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=11" title="Править секцию: Управление потоком">править</a>]</span> <span class="mw-headline" id=".D0.A3.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BC"> Управление потоком </span></h2>
<p>У каждого окна есть настройки управления потоком (flow-control), которые определяют,
как screen будет работать с XON и XOFF символами (и, возможно, символом разрыва).
Когда управление потоком выключено, screen игнорирует XON и XOFF символы, 
и пользователю для того чтобы отправить их в программу, нужно просто нажать их
(это полезно, например, для редактора Emacs).
Минус в том, что обычной программе нужно больше времени для того чтобы 
остановиться, когда она увидит XOFF. Если управление потоком включено,
XON и XOFF немедленно останавливают вывод в текущее окно.
Эти символы по-прежнему можно отправить программе, но для этого нужно 
использовать соответствующие двухсимвольные команды screen ("C-a q" (xon) и "C-a s" (xoff)).
Команды xon/xoff также полезны для передачи симолов C-s и C-q в обход терминала,
который перехватывает эти символы.
</p><p>У каждого окна есть начальная настройка управления потоком, которая задаётся
или опцией <tt>-f</tt> или командой <i>defflow</i> из файла <tt>.screenrc</tt>.
По умолчанию окна настроены на автоматическое переключение потока.
Потом состояние можно интерактивно переключать с помощью комбинации
клави "C-a f" или команды "flow" между вариантами
"fixed on", "fixed off" и "automatic".
</p><p><br>
Режим автоматического переключения потока (automatic flow-switching mode)
работает с управлением потоком через режим TIOCPKT  (как "rlogin"). Если драйвер терминала не поддерживает
TIOCPKT, screen пытается найти правильный режим исходя из текущих настроек
клавиш приложения (application keypad) — когда они включены, управление потоком выключено
и наоборот. Конечно, можно по-прежнему манипулировать управлением потоком вручную,
если нужно.
</p><p>Если screen работает с включённым аппаратным управлением потоком,
и нажатие клавиши прерывания (обычно C-c) срабатывает не сразу, а 
после того как прокрутятся ещё 6-8 строк, нужно попробовать запустить
screen с опцией "interrupt" (нужно добавить флаг "interrupt" к команде "flow" в файле <tt>.screenrc</tt>
или использовать опцию <tt>-i</tt>).
В этом случае вывод, который screen накопил от интерактивных программ,
очищается.
Минус заключается в том, что память виртуального терминала 
хранит не выведенный вывод, что иногда может приводить к неточностям
при отображении.  Например, если переключить экран, а потом вернуться,
или обновить экран при помощи "C-a l",
на экране будет вывод такой же, как если бы "interrupt" был выключен.
Если выполнять программу, которой нужно передать символ прерывания как ввод
(например, прервать вывод виртуального терминала на физический),
нужно выключать управление потоком (или использовать режим auto-flow для того чтобы выключать его автоматически)
В этой ситуации простое обновление экрана screen с помощью "C-a l" вернёт всё в исходное состояние.
Можно попробовать все режимы, и использовать тот, который удобнее.
</p>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=12" title="Править секцию: Названия (именование окон)">править</a>]</span> <span class="mw-headline" id=".D0.9D.D0.B0.D0.B7.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F_.28.D0.B8.D0.BC.D0.B5.D0.BD.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BE.D0.BA.D0.BE.D0.BD.29"> Названия (именование окон) </span></h2>
<p>Имена окон (которые выводятся, например, по команде <i>windows</i>, "C-a w")
можно настраивать одной из команд <i>title</i>.
Обычно имя окна это имя команды, запущенной в этом окне.
Но иногда хочется что бы окна с одной командой как-то отличались,
или что бы имя менялось на ходу и отражало текущее состояние окна.
</p><p>Имя по умолчанию для всех окон с оболчками (shell windows) можно задать командой <i>shelltitle</i>
из файла <tt>.screenrc</tt>. Имена окон, которые создаются по команде screen, 
можно задать при помощи ключа <tt>-t</tt> в этой команде.
Для интерактивной смены есть escape-последовательность
(&lt;esc&gt;kname&lt;esc&gt;\)  и команда <i>title</i> (C-a A).
В первом случае строку может выводить приложение, работающее в окне, автоматически,
а во втором — имя вводится интерактивно в соответствующее приглашение.
И ещё можно создавать привязки установку предопределённых имён
на комбинации клавиш и не вводить их каждый раз.
</p><p>Кроме всего прочего, у screen есть специальный механизм,
который включается путём установки имени окна равным "search|name".
Для этого нужно чтобы в приглашение выводилась специальная невидимая
escape-последовательность.
Часть "search" задаёт строку которая будет считаться концом приглашения,
а часть "name" определяет имя по умолчанию для этого окна.
Если имя оканчивается на ":", screen дописывает имя текущей команды (с его точки зрения), работающей в окне,
к названию оболочки окна (например, "name:cmd"). Иначе имя команды, пока она выполняется, перекрывает имя оболочки.
</p><p>Вот как это работает:  нужно изменить приглашение командного интерпретатора
так, чтобы невидимая строка title-escape-sequence (&lt;esc&gt;k&lt;esc&gt;\) выводилась как его часть.
Последняя часть приглашения должна быть в точности равна 
строке, которая была задана как строка для поиска заголовка окна.
При такой настройке screen при помощи title-escape-sequence будет очищать название предыдущей
команды и ждать следующей.
Потом, когда он увидит что от оболочки получен перевод строки, он ищет окончание приглашения.
Если находит, первое слово после него считает именем команды.
Если команда начинается с "!", "%" или "^", screen возьмёт имя не из этой строки, а из следующей за ней.
Это нужно для тех, кто пользуется механизмами управления работами (job control) и истории.
</p><p>Вот несколько примеров команд из .screenrc:
</p>
<pre>   screen -t top 2 nice top
</pre>
<p>Если добавить эту строку в файл .screenrc, то на окне 2 будет запускаться 
top с пониженным приоритетом (через nice).  Окно будет называться "top",
а не "nice".
</p>
<pre>   shelltitle '&gt; |csh'
   screen 1
</pre>
<p>В результате  выполнения  команды  будет  запущена  оболочка  с  заданным
заголовком shelltitle. 
Заголовок автоматический, который предполагает что 
приглашение  и  команда выглядят следующим образом:
</p>
<pre>   /usr/joe/src/dir&gt; trn
</pre>
<p>(имя команды ищется после <tt>&gt;</tt>).
В строке статуса окна будет "trn" пока команда выполнятся 
и "csh", после того как она завершится.
</p>
<pre>   bind R screen -t '% |root:' su
</pre>
<p>Если добавить такую команду в файл .screenrc, комбинация клавиш 'C-a R'
будет привязана к команде "su" (с заголовком "root:"). Если это автоматическое именование работает, будет происходить так:
</p>
<pre>  &nbsp;%&nbsp;!em
   emacs file.c
</pre>
<p>Здесь пользователь ввёл команду истории "!em", которая вызвала введённую ранее
команду <i>emacs</i>.  Статусная строка окна во время исполнения команды 
будет показывать "root:emacs", а после того как она завершится, 
превратится в просто "root:".
</p>
<pre>   bind o title
   bind E title ""
   bind u title (unknown)
</pre>
<p>У  первой  привязки  нет  аргументов, поэтому при нажатии "C-a o" нужно
будет ввести заголовок. При нажатии второй комбинации "C-a E" очищаются настройки 
текущие автоматического заголовка (auto-title).
Третья привязка: по нажатию C-a u 
устанавливать заголовок текущего окна равным "(unknown)".
</p><p>При добавлении невидимой строки в приглашение нужно помнить, что некоторые интерпретаторы 
(такие как csh) учитывают все неуправляющие символы 
при вычислении длины приглашения.
Если число этих невидимых символов не кратно 8, то при удалении табуляции с помощью backspace
появится ошибки при отображении.
Один способ обойти эту проблему — использовать
приглашение наподобие такого:
</p>
<pre>   set prompt='^[[0000m^[k^[\% '
</pre>
<p>Escape-последовательность "&lt;esc&gt;[0000m" не только нормализует атрибуты символов,
но и округляет нулями число невидимых символов до кратного 8.
Пользователи <b>bash</b> могут задавать escape-последовательности в
переменной <tt>PROMPT_COMMAND</tt>:
</p>
<pre>   PROMPT_COMMAND='echo -n -e "\033k\033\134"'
</pre>
<p>(Здесь используется строка "134" для вывода символа \ из за ошибки в версии 1.04).
</p>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=13" title="Править секцию: Виртуальный терминал">править</a>]</span> <span class="mw-headline" id=".D0.92.D0.B8.D1.80.D1.82.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B9_.D1.82.D0.B5.D1.80.D0.BC.D0.B8.D0.BD.D0.B0.D0.BB"> Виртуальный терминал </span></h2>
<p>Каждое окно в сеансе screen эмулирует терминал VT100 с некоторыми дополнительными функциями.
Может эмулироваться только VT100, это жёстко зашитое ограничение screen.
Как правило, screen старается выполнять эмуляцию как можно ближе к VT100/ANSI.
Но если у терминала, на котором выполняется screen, не хватает некоторых возможностей,
эмуляция будет частичной. 
В этом случае screen должен сообщить приложению, что некоторых возможностей
не будет. Это несложно на машинах, использующих termcap, 
потому что screen может использовать переменную <tt>$TERMCAP</tt>
для подстройки своего стандартного termcap.
</p><p>Но при удалённом заходе на машину, которая поддерживает только terminfo, 
этот метод работать не будет. У screen есть способ, который он использует
в этой ситуации.
</p><p>Когда screen хочет определить имя терминала для себя,
сначала он пытается найти запись "screen.&lt;term&gt;", где &lt;term&gt; это содержимое переменной
$TERM.  Если такой записи нет, screen пробует найти "screen"
(или  "screen-w" для широких терминалов (132 колонки или больше)).  Если и эту запись найти не удаётся,
используется "vt100" как заменитель.
</p><p>Если терминал не поддерживает важную функцию (например, удаление символа или очистку до конца строки),
можно сделать новую запись termcap/terminfo для screen (и назвать её "screen.&lt;dumbterm&gt;"),
в которой эта возможность будет отключена. 
</p><p>Когда такая запись есть на машине, при удалённом заходе на неё termcap/termifo-запись будет правильной.
Имя терминала указывается в переменной  $TERM новых окон.
Кроме этого, screen устанавливает переменную <tt>$TERMCAP</tt>, так что бы она отражала возможности
эмулируемого терминала. Следует заметить, что на машинах, где используется
база данных terminfo, эта переменная ничего не значит.
И ещё в переменной $WINDOW устанавливается номер окна.
</p><p>Действительное множество возможностей, поддерживаемых виртуальным терминалом, 
зависит от того какие возможности поддерживаются физическим терминалом.
Если, физический терминал не поддерживает, скажем, режим подчёркивания,
screen не указывает возможности <i>us</i> и <i>ue</i> в переменной <tt>$TERMCAP</tt>
для окон. Тем не менее, для того чтобы screen работал, минимум возможностей
терминалом должен поддерживаться всё равно; в частности, прокрутка, очистка,
прямая адресация курсора (кроме того, screen не будет работать на hardcopy-терминалах
и на overstrike-терминалах).
</p><p>Значение переменной <tt>$TERMCAP</tt> можно изменить с помощью 
команды .screenrc  "termcap" или, если задать переменную <tt>$SCREENCAP</tt> 
до запуска screen.
В последнем случае её значение копируется в неизменном виде в переменную TERMCAP для каждого окна.
В ней может быть или полное определение терминала или имя файла, где 
определён терминал "screen" и/или "screen-w".
</p><p>Если в системе используется база данных terminfo, а не termcap,
имейте в виду, что у screen есть команда <i>terminfo</i>.
</p><p>Если в записи termcap терминала, на котором был вызван screen, присутствует 
булевая возможность "G0", терминал поддерживает несколько наборов символов (charsets).
Это даёт возможность приложению использовать,
например, или псевдографическое множество символов, или множество символов национального алфавита
в терминале VT100.  Поддерживаются следующие управляющие функции из ISO 2022: 
lock  shift  G0  (SI), lock shift G1 (SO), lock shift G2, lock
shift G3, single shift G2, и single shift G3.  При создании или сбросе виртуального терминала
таблица символов ASCII назначается на G0, G1, G2 и G3.
Если есть возможность "G0" возможность, screen вычисляет возможности
"S0", "E0", и "C0", если есть. "S0" это последовательность, которую
терминал использует для того, чтобы включить псевдографический набор символов вместо SI.
"E0"  соответствующая замена для SO. "C0" даёт строку посимвольного соответствия.
Эта строка используется в псевдографическом режиме.
Строка строится так же как и возможность "acsc" terminfo.
</p><p>Если в termcap-записи терминала присутствуют возможности "po" и "pf",
приложения, работающие в screen, могут отправлять вывод на печать
через порт печати терминала.
Приложение в одном окне отправляет данные на принтер, подсоединённый к терминалу,
а другие окна при этом продолжают работать
(порт принтера активируется и деактивируется заново для каждой порции выводимых данных).
Побочный эффект: программы, работающие в разных окнах одновременно, могут отправлять данные на печать одновременно.
Данные, которые отправляются на печать, не показываются в окне.
Пока печать активна, команда <i>info</i> будет показывать строку, начинающуюся символами <tt>PRIN</tt>.
</p><p>Каждому экрану screen предоставляет статусную строку hardstatus.  Когда какое-то окно становится
активным, hardstatus дисплея обновляется, и он отражает hardstatus соответствующего окна.
Если у дисплея нет строки hardstatus, строка показывается как обычное сообщение screen.
Строку hardstatus можно поменять с помощью  ANSI   Application   Program   Command   (APC):
"ESC_&lt;string&gt;ESC\". Для удобства пользователей xterm принимается строка "ESC]0..2;&lt;string&gt;^G".
</p><p>Некоторые возможности только тогда указываются в переменной $TERMCAP для виртуального терминала,
если они могут быть эффективно реализованы с помощью физического терминала.
Например, "dl" (delete line) указывается в переменной $TERMCAP только при условии, если терминал 
поддерживает или удаление строки, или прокрутку регионов.
При переподключении с другого терминала может возникнуть путаница,
потому что значение <tt>$TERMCAP</tt> родительские процессы у дочерних
уже изменить не смогут.
</p><p>Альтернативный экран (alternate  screen) не включен по умолчанию. Для того чтобы его включить, 
нужно вызвать команду <i>altscreen</i>.
</p><p>Ниже приводится список управляющих последовательностей,
которые распознаёт screen.
"(V)" и "(A)" обозначают функции специфичные для VT100- и для ANSI- или ISO- соответственно.
</p><p><br>
</p>
<pre>      ESC E                      Следующая строка
      ESC D                      Индекс
      ESC M                      Обратный индекс
      ESC H                      Horizontal Tab Set
      ESC Z                      Send VT100 Identification String
      ESC 7                 (V)  Save Cursor и Attributes
      ESC 8                 (V)  Восстановить курсор и атрибуты
      ESC [s                (A)  Save Cursor и Attributes
      ESC [u                (A)  Restore Cursor и Attributes
      ESC c                      Сбросить в начальное состояние
      ESC g                      Визуальный звонок
      ESC Pn p                   Видимость курсора (97801)
          Pn = 6                 Невидимый
               7                 Видимый
      ESC =                 (V)  Режим клавиатуры приложения
      ESC &gt;                 (V)  Режим цифровой клавиатуры
      ESC # 8               (V)  Заполнить экран E
      ESC \                 (A)  Завершение строки (string terminator)
      ESC ^                 (A)  Privacy Message String
      ESC&nbsp;!                      Global Message String
      ESC k                      A.k.a. Definition String
      ESC P                 (A)  Device Control  String.   Выводит строку прямо на терминал,
                                 без обработки.
      ESC _                 (A)  Команда приложения (Hardstatus)
      ESC ] 0&nbsp;; string ^G   (A)  Команда операционной систем (Hardstatus, xterm title hack)
      ESC ] 83&nbsp;; cmd ^G     (A)  Выполнить команду screen. Работает только если в screen вкомпилирована
                                 многопользовательская поддержка.
                                 При проверке acl используется псевдопользователь ":window:".
                                 Команда "addacl &nbsp;:window:  -rwx  #?"  создаёт пользователя без прав,
                                 разрешает ему только нужные команды.
      Control-N             (A)  Lock Shift G1 (SO)
      Control-O             (A)  Lock Shift G0 (SI)
      ESC n                 (A)  Lock Shift G2
      ESC o                 (A)  Lock Shift G3
      ESC N                 (A)  Single Shift G2
      ESC O                 (A)  Single Shift G3
      ESC ( Pcs             (A)  Designate character set as G0
      ESC ) Pcs             (A)  Designate character set as G1
      ESC * Pcs             (A)  Designate character set as G2
      ESC + Pcs             (A)  Designate character set as G3
      ESC [ Pn&nbsp;; Pn H            Прямая адресация курсора
      ESC [ Pn&nbsp;; Pn f            то же
      ESC [ Pn J                 Удалить на экране
            Pn = None or 0       От курсора до конца экрана
                 1               От начала экрана до курсора
                 2               Весь экран
      ESC [ Pn K                 Удалить в строке
            Pn = None or 0       От курсора до конца строки
                 1               От начала строки до курсора
                 2               Всю строку
      ESC [ Pn X                 Удалить символ
      ESC [ Pn A                 Курсор вверх
      ESC [ Pn B                 Курсор вниз
      ESC [ Pn C                 Курсор вправо
      ESC [ Pn D                 Курсор влево
      ESC [ Pn E                 Курсор на следующую строку (cursor next line)
      ESC [ Pn F                 Курсор на предыдущую строку (cursor previous line)
      ESC [ Pn G                 Горизонтальная позиция курсора
      ESC [ Pn '                 то же
      ESC [ Pn d                 Вертикальная позиция курсора
      ESC [ Ps&nbsp;;...; Ps m        Выбрать графическое начертание
            Ps = None or 0       Стандартное начертание
                 1               Полужирный
                 2          (A)  Бледный (faint)
                 3          (A)  Выделяющийся (ANSI: курсив)
                 4               Подчеркнутый
                 5               Мигающий
                 7               Инвертированный
                 22         (A)  Нормальная интенсивность
                 23         (A)  Выделение выключено (ANSI: курсив выключен)
                 24         (A)  Без подчёркивания
                 25         (A)  Не мигать
                 27         (A)  Позитивное изображение
                 30         (A)  Цвет символов чёрный
                 31         (A)  Цвет символов красный
                 32         (A)  Цвет символов зелёный
                 33         (A)  Цвет символов жёлтый
                 34         (A)  Цвет символов синий
                 35         (A)  Цвет символов фиолетовый
                 36         (A)  Цвет символов морской волны
                 37         (A)  Цвет символов белый
                 39         (A)  Цвет символов по умолчанию
                 40         (A)  Цвет фона чёрный
                 ...
                 49         (A)  Цвет фона по умолчанию
      ESC [ Pn g                 Удалить табуляцию
            Pn = None or 0       Удалить табуляцию на текущей позиции
                 3               Стереть все табуляции
      ESC [ Pn&nbsp;; Pn r       (V)  Задать регион прокрутки
      ESC [ Pn I            (A)  Горизонтальная табуляция
      ESC [ Pn Z            (A)  Обратная табуляция
      ESC [ Pn L            (A)  Вставить строку
      ESC [ Pn M            (A)  Удалить строку
      ESC [ Pn @            (A)  Вставить символ
      ESC [ Pn P            (A)  Удалить символ
      ESC [ Pn S                 Прокрутить область прокрутки вверх
      ESC [ Pn T                 Прокрутить область прокрутки вниз
      ESC [ Pn ^                 то же
      ESC [ Ps&nbsp;;...; Ps h        Режим Set
      ESC [ Ps&nbsp;;...; Ps l        Режим Reset
            Ps = 4          (A)  Режим вставки (Insert)
                 20         (A)  Режим автоматической прокрутки (Automatic Linefeed)
                 34              Нормальная видимость курсора
                &nbsp;?1         (V)  Клавиши управления курсором приложения
                &nbsp;?3         (V)  Изменить ширину терминала на 132 колонки
                &nbsp;?5         (V)  Реверсивное видео
                &nbsp;?6         (V)  Origin-режим
                &nbsp;?7         (V)  Wrap-режим
                &nbsp;?9              Отслеживание мыши X10
                &nbsp;?25        (V)  Видимый курсор
</pre>
<pre>                &nbsp;?47             Alternate Screen (old xterm code)
                &nbsp;?1000      (V)  Отслеживание мыши VT200
                &nbsp;?1047           Альтернативный экран (новый xterm-код)
                &nbsp;?1049           Альтернативный экран (новый xterm-код)
</pre>
<pre>      ESC [ 5 i             (A)  Начать ретрансляцию на принтер (ANSI Media Copy)
      ESC [ 4 i             (A)  Остановить ретрансляцию на принтер (ANSI Media Copy)
      ESC [ 8&nbsp;; Ph&nbsp;; Pw t        Изменить размер для Resize the window to  "Ph"  lines  и  "Pw"
                                 колонок (для SunView)
      ESC [ c                    Отправить идентификационную строку VT100
      ESC [ x                    Отправить отчёт с параметрами терминала
      ESC [ &gt; c                  Отправить строку атрибутов вторчного устройства VT220 
                                 (VT220   Secondary  Device  Attributes)
      ESC [ 6 n                  Отправить отчёт о позиции курсора
</pre>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=14" title="Править секцию: Трансляция при вводе">править</a>]</span> <span class="mw-headline" id=".D0.A2.D1.80.D0.B0.D0.BD.D1.81.D0.BB.D1.8F.D1.86.D0.B8.D1.8F_.D0.BF.D1.80.D0.B8_.D0.B2.D0.B2.D0.BE.D0.B4.D0.B5"> Трансляция при вводе </span></h2>
<p>Для того чтобы полностью эмулировать VT100 
screen должен определять, нажатием какой клавиши
была сгенерирована последовательность во входном потоке,
и превращать её в последовательность подходящую VT100.
</p><p>Screen очень гибок в этом вопросе — он позволяет привызывать произвольные команды
к произвольным последовательностям символов.
В случае простой эмуляции VT100 команда будет вставлять 
строку в буфер ввода окна (см. команду <i>stuff</i>).
Последовательности, которые генерируются по нажатию клавиши,
могут измениться при подключении из терминала с другим типом.
Чтобы обойти эту проблему, можно привязывать команды к termcap-именам клавиш.
Screen будет делать правильные привязки после каждого повторного подключения.
Более подробная информация и примеры использования есть в описании команды <i>bindkey</i>.
</p><p>Ниже представлена таблица привязок по умолчанию (default key bindings). (A) обозначает,
что команда выполняется, если клавиатура переключена в режим приложения.
</p>
<pre>      Клавиша           Имя termcap     Команда
      ______________________________________________________
      Курсор вверх          ku          stuff \033[A
                                        stuff \033OA    (A)
      Курсор вниз           kd          stuff \033[B
                                        stuff \033OB    (A)
      Курсор вниз           kr          stuff \033[C
                                        stuff \033OC    (A)
      Курсор влево          kl          stuff \033[D
                                        stuff \033OD    (A)
      F0                    k0          stuff \033[10~
      F1                    k1          stuff \033OP
      F2                    k2          stuff \033OQ
      F3                    k3          stuff \033OR
      F4                    k4          stuff \033OS
      F5                    k5          stuff \033[15~
      F6                    k6          stuff \033[17~
      F7                    k7          stuff \033[18~
      F8                    k8          stuff \033[19~
      F9                    k9          stuff \033[20~
      F10                   k;          stuff \033[21~
      F11                   F1          stuff \033[23~
      F12                   F2          stuff \033[24~
      Home                  kh          stuff \033[1~
      End                   kH          stuff \033[4~
      Insert                kI          stuff \033[2~
      Delete                kD          stuff \033[3~
      Page up               kP          stuff \033[5~
      Page down             kN          stuff \033[6~
      Серый  0              f0          stuff 0
                                        stuff \033Op    (A)
      Серый  1              f1          stuff 1
                                        stuff \033Oq    (A)
      Серый  2              f2          stuff 2
                                        stuff \033Or    (A)
      Серый  3              f3          stuff 3
                                        stuff \033Os    (A)
      Серый  4              f4          stuff 4
                                        stuff \033Ot    (A)
      Серый  5              f5          stuff 5
                                        stuff \033Ou    (A)
      Серый  6              f6          stuff 6
                                        stuff \033Ov    (A)
      Серый  7              f7          stuff 7
                                        stuff \033Ow    (A)
      Серый  8              f8          stuff 8
                                        stuff \033Ox    (A)
      Серый  9              f9          stuff 9
                                        stuff \033Oy    (A)
      Серый  +              f+          stuff +
                                        stuff \033Ok    (A)
      Серый  -              f-          stuff -
                                        stuff \033Om    (A)
      Серый  *              f*          stuff *
                                        stuff \033Oj    (A)
      Серый  /              f/          stuff /
                                        stuff \033Oo    (A)
      Серый  =              fq          stuff =
                                        stuff \033OX    (A)
      Серый  .              f.          stuff .
                                        stuff \033On    (A)
      Серый  ,              f,          stuff ,
                                        stuff \033Ol    (A)
      Серый  enter          fe          stuff \015
                                        stuff \033OM    (A)
</pre>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=15" title="Править секцию: Специальные возможности терминала">править</a>]</span> <span class="mw-headline" id=".D0.A1.D0.BF.D0.B5.D1.86.D0.B8.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.B2.D0.BE.D0.B7.D0.BC.D0.BE.D0.B6.D0.BD.D0.BE.D1.81.D1.82.D0.B8_.D1.82.D0.B5.D1.80.D0.BC.D0.B8.D0.BD.D0.B0.D0.BB.D0.B0"> Специальные возможности терминала </span></h2>
<p>Приведённая ниже таблица описывает все возможности терминала, которые распознаются screen, и отсутствуют
в руководстве <i>termcap(5)</i>. Можно поместить эти возможности в записи termcap (в файле <tt>/etc/termcap</tt>) или 
использовать их с командами <i>termcap</i>, <i>terminfo</i> и <i>termcapinfo</i> в файле
screenrc. Добавить возможности внутрь базы terminfo чаще всего нельзя.
</p>
<pre>    LP   (bool)  У терминала есть отступы в стиле  VT100 ("волшебные отступы", "magic margins"). Эта
                 возможность устаревшая, screen использует стандартную xn вместо неё.
    Z0   (str)   Установить ширину равной 132 колонкам.
    Z1   (str)   Установить ширину равной 80 колонкам.
    WS   (str)   Изменить размер экрана. Желаемая ширина и высота передаются как аргументы.
                 Пример для SunView(tm): "\E[8;%d;%dt".
    NF   (bool)  Терминалу не нужно управление потоком. Передавать ^S и ^Q  непосредственно приложению.
                 То же, что и "flow off". Возможность противоположная "nx".
    G0   (bool)  Терминал может работать с последовательностями выбора шрифта ISO 2022.
    S0   (str)   Переключить charset "G0" на заданный. По умолчанию "\E(%.".
    E0   (str)   Переключить charset "G0" обратно на стандартный.  По умолчанию "\E(B".
    C0   (str)   Использовать строку как таблицу преобразования для шрифта "0". См. также возможность "AC".
    CS   (str)   Переключить клавиши управления курсором в режим приложения.
    CE   (str)   Переключить клавиши управления курсором обратно в нормальный режим.
    AN   (bool)  Включить autonuke. См. команду ''autonuke''  
    OL   (num)   Задаёт лимит буфера вывода. См. команду ''obuflimit''.
    KJ   (str)   Задать кодировку терминала. Для списка допустимых кодировок см. "encoding".
    AF   (str)   Изменить цвет символов способом соответствующим ANSI.
                 Эта возможность почти всегда равна "\E[3%dm"
                 (или "\E[3%p1%dm" на машинах с terminfo).

    AB   (str)   То же, что и "AF", но изменяет фон.
    AX   (bool)  Понимает ANSI-последовательности для установки цвета букв и цвета фона (\E[39m / \E[49m).
    XC   (str)   Описать преобразование символов в строки в зависимости от текущего шрифта. Детали в следующем разделе.
    XT   (bool)  Терминал понимает специальные последовательности xterm (OSC, слежение за мышью).
    C8   (bool)  Терминалу нужен полужирный текст для того чтобы выводить цвета высокой яркости (например, eterm).
    TF   (bool)  Добавляет недостающие возможности в  запись termcap/info.  (Установлено по умолчанию).
</pre>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=16" title="Править секцию: Преобразование кодировки символов">править</a>]</span> <span class="mw-headline" id=".D0.9F.D1.80.D0.B5.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BA.D0.BE.D0.B4.D0.B8.D1.80.D0.BE.D0.B2.D0.BA.D0.B8_.D1.81.D0.B8.D0.BC.D0.B2.D0.BE.D0.BB.D0.BE.D0.B2"> Преобразование кодировки символов </span></h2>
<p>У screen есть мощный механизм трансляции символов в зависимости
от текущего шрифта и типа терминала.
Эту возможность можно использовать, когда возникает необходимость
со стандартным набором символов на терминалах,
работающих с какими-то более экзотическими наборами.
</p><p>Синтаксис:
</p>
<pre>   XC=&lt;charset-mapping&gt;{,,&lt;charset-mapping&gt;}
   &lt;charset-mapping&gt;&nbsp;:= &lt;designator&gt;&lt;template&gt;{,&lt;mapping&gt;}
   &lt;mapping&gt;&nbsp;:= &lt;char-to-be-mapped&gt;&lt;template-arg&gt;
</pre>
<p>Элементы, заключённые в скобки, могут повторяться произвольное число раз.
</p><p>Последовательность &lt;charset-mapping&gt; говорит screen как 
отображать символы в кодировке &lt;designator&gt; ("B": ASCII, "A": UK, 
"K":  german и т.д.) в строки.
Каждый &lt;mapping&gt; описывает какие символы преобразуются в какие.
Используется механизм шаблонов, поскольку чаще всего кодировки имеют 
много общего
(например, строки которые нужны для того чтобы переключиться на другую и
 с другой кодировки).
Каждое вхождение символа "%" в шаблон &lt;template&gt; заменяется на
&lt;template-arg&gt;, заданный вместе с символом. 
Если строки вообще не похожи, нужно использовать "%" как шаблон и 
задавать полную строку в &lt;template-arg&gt;.
Для использования настоящего символа "%" есть специальный механизм 
экранирования:
символ "\" экранирует специальные символы "\", "%" и ",".
</p><p>Вот пример:
</p>
<pre>   termcap hp700 "XC=B\E(K%\E(B,\304[,\326\\\\,\334]"
</pre>
<p><br>
Строка говорит screen как транслировать символы с умляутами в верхнем регистре в кодировке ISOlatin1 (кодировка "B")
на терминале hp700, на котором немецкая "german" кодировка:  "\304" транслируется в "\E(K[\E(B"  и так далее.
</p><p>Прежде чем построится внутренняя таблица поиска эти строки подвергаются обработке в три прохода,
поэтому для того чтобы вставить обычный "\" нужно столько экранов.
</p><p>Для того чтобы эмуляция была лучше, сделано ещё одно расширение: 
Если отображение транслирует неэкранированный символ "%",
он отправляет на терминал каждый раз когда screen переключается на 
соответствующую кодировку &lt;designator&gt;.
</p><p>В этом особенном случае предполагается что шаблон это просто "%", 
потому что последовательность смены кодировок и отображение символом
имеют мало общего.
</p><p>В этом примере показан один из способов использования расширения:
</p>
<pre>   termcap xterm 'XC=K%,%\E(B,[\304,\\\\\326,]\334'
</pre>
<p>Здесь на xterm эмулируется часть немецкого ("K") набора символов (charset).
Если screen нужно будет перейти на набор символов "K", он отправит на терминал 
символ "\E(B", т.е. будет использоваться кодировка ASCII.
Шаблон это просто "%", поэтому отображение прямое: "[" на "\304", "\" на "\326" и "]" на "\334".
</p>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=17" title="Править секцию: Переменные окружения">править</a>]</span> <span class="mw-headline" id=".D0.9F.D0.B5.D1.80.D0.B5.D0.BC.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.BE.D0.BA.D1.80.D1.83.D0.B6.D0.B5.D0.BD.D0.B8.D1.8F"> Переменные окружения </span></h2>
<pre>   COLUMNS        Количество столбцов терминала (перекрывает запись termcap)
   HOME           Каталог, в котором нужно искать файл <tt>.screenrc</tt>
   LINES          Количество строк терминала (перекрывает запись termcap)
   LOCKPRG        Программа блокирования (lock) терминала 
   NETHACKOPTIONS Включает опцию nethack
   PATH           Используется для обнаружения программ перед запуском
   SCREENCAP      Для модификации значения TERMCAP терминала
   SCREENDIR      Альтернативный катало для сокетов
   SCREENRC       Альтернативный конфигурационный файл .screenrc
   SHELL          Имя интерпретатора, который используется для открытия окон (по умолчанию
                  "/bin/sh").
   STY            Альтернативное имя сокета
   SYSSCREENRC    Альтернативный системный конфигурационный файл <tt>screenrc</tt>
   TERM           Имя терминала
   TERMCAP        Описание терминала
   WINDOW         Номер окна (в момент создания)
</pre>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=18" title="Править секцию: Файлы">править</a>]</span> <span class="mw-headline" id=".D0.A4.D0.B0.D0.B9.D0.BB.D1.8B"> Файлы </span></h2>
<pre>      .../screen-4.?.??/etc/screenrc
      .../screen-4.?.??/etc/etcscreenrc Примеры в пользовательского и глобального
                                        инициализационных файлов,
                                        входящие в дистрибутив <i>screen</i>
      $SYSSCREENRC
      /etc/screenrc                     Команды инициализации screen
      $SCREENRC
      $HOME/.screenrc                   Считывается после /etc/screenrc
      $SCREENDIR/S-&lt;login&gt;
      /var/run/screen/S-&lt;login&gt;         Каталог с гнёздами(сокетами) screen (по умолчанию)
      /usr/tmp/screens/S-&lt;login&gt;        Альтернативный каталог с гнёздами
      &lt;socket directory&gt;/.termcap       Записанный функцией вывода "termcap"
      /usr/tmp/screens/screen-exchange  
      /tmp/screen-exchange              Буфер для межпроцессного взаимодействия screen
      hardcopy.[0-9]                    Образы screen, созданные функцией hardcopy
      screenlog.[0-9]                   Журнал, созданный функцией log
      /usr/lib/terminfo/?/* или
      /etc/termcap                      База данных возможностей терминала (Terminal capability databases)
      /var/run/utmp                     Записи о входе в систему
      $LOCKPRG                          Программа, которая блокирует (lock) терминал
</pre>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=19" title="Править секцию: См. также">править</a>]</span> <span class="mw-headline" id=".D0.A1.D0.BC._.D1.82.D0.B0.D0.BA.D0.B6.D0.B5"> См. также </span></h2>
<p><a href="http://xgu.ru/w/index.php?title=man:termcap&amp;action=edit&amp;redlink=1" class="new" title="man:termcap (такой страницы не существует)">termcap(5)</a>, <a href="http://xgu.ru/w/index.php?title=man:utmp&amp;action=edit&amp;redlink=1" class="new" title="man:utmp (такой страницы не существует)">utmp(5)</a>, <a href="http://xgu.ru/w/index.php?title=man:vi&amp;action=edit&amp;redlink=1" class="new" title="man:vi (такой страницы не существует)">vi(1)</a>, <a href="http://xgu.ru/w/index.php?title=man:captoinfo&amp;action=edit&amp;redlink=1" class="new" title="man:captoinfo (такой страницы не существует)">captoinfo(1)</a>, <a href="http://xgu.ru/w/index.php?title=man:tic&amp;action=edit&amp;redlink=1" class="new" title="man:tic (такой страницы не существует)">tic(1)</a>
</p>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=20" title="Править секцию: Авторы">править</a>]</span> <span class="mw-headline" id=".D0.90.D0.B2.D1.82.D0.BE.D1.80.D1.8B"> Авторы </span></h2>
<p>Изначально программа была создана Оливером Ломанном (Oliver Laumann).
Последняя (эта) версия была сделана 
Вайеном Дэвисоном (Wayne Davison), Юргеном Вигертом (Juergen Weigert)
и Михаелем Шрёдером (Michael Schroeder).
</p>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=21" title="Править секцию: COPYLEFT">править</a>]</span> <span class="mw-headline" id="COPYLEFT"> COPYLEFT </span></h2>
<p>Copyright (C) 1993-2003
</p>
<ul><li>    Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
</li><li>    Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
</li></ul>
<p>Copyright (C) 1987 Oliver Laumann
</p><p>This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published  by  the
Free  Software  Foundation;  either  version 2, or (at your option) any
later version.
</p><p>This program is distributed in the hope that it  will  be  
useful,  but
WITHOUT  ANY  WARRANTY;  without  even  the  implied  warranty  of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  
General
Public License for more details.
</p><p>You should have received a copy of the GNU General Public License along
with this program (see the file COPYING); if not,  write  to  the  Free
Software  Foundation,  Inc.,  59  Temple  Place - Suite 330, Boston, MA
02111-1307, USA
</p>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=22" title="Править секцию: Вклад">править</a>]</span> <span class="mw-headline" id=".D0.92.D0.BA.D0.BB.D0.B0.D0.B4"> Вклад </span></h2>
<p>В развитие <i>GNU screen</i> сделали вклад:
</p>
<ul><li> Ken Beal (kbeal@amber.ssd.csd.harris.com),
</li><li> Rudolf Koenig (rfkoenig@immd4.informatik.uni-erlangen.de),
</li><li> Toerless Eckert (eckert@immd4.informatik.uni-erlangen.de),
</li><li> Wayne Davison (davison@borland.com),
</li><li> Patrick Wolfe (pat@kai.com, kailand!pat),
</li><li> Bart Schaefer (schaefer@cse.ogi.edu),
</li><li> Nathan Glasser (nathan@brokaw.lcs.mit.edu),
</li><li> Larry W. Virden (lvirden@cas.org),
</li><li> Howard Chu (hyc@hanauma.jpl.nasa.gov),
</li><li> Tim MacKenzie (tym@dibbler.cs.monash.edu.au),
</li><li> Markku Jarvinen (mta@{cc,cs,ee}.tut.fi),
</li><li> Marc Boucher (marc@CAM.ORG),
</li><li> Doug Siebert (dsiebert@isca.uiowa.edu),
</li><li> Ken Stillson (stillson@tsfsrv.mitre.org),
</li><li> Ian Frechett (frechett@spot.Colorado.EDU),
</li><li> Brian Koehmstedt (bpk@gnu.ai.mit.edu),
</li><li> Don Smith (djs6015@ultb.isc.rit.edu),
</li><li> Frank van der Linden (vdlinden@fwi.uva.nl),
</li><li> Martin Schweikert (schweik@cpp.ob.open.de),
</li><li> David Vrona (dave@sashimi.lcu.com),
</li><li> E. Tye McQueen (tye%spillman.UUCP@uunet.uu.net),
</li><li> Matthew Green (mrg@eterna.com.au),
</li><li> Christopher Williams (cgw@pobox.com),
</li><li> Matt Mosley (mattm@access.digex.net),
</li><li> Gregory Neil Shapiro (gshapiro@wpi.WPI.EDU),
</li><li> Johannes Zellner (johannes@zellner.org),
</li><li> Pablo Averbuj (pablo@averbuj.com).
</li></ul>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=23" title="Править секцию: Версия">править</a>]</span> <span class="mw-headline" id=".D0.92.D0.B5.D1.80.D1.81.D0.B8.D1.8F"> Версия </span></h2>
<p>Документация написана для <i>screen</i> версии 4.0.2.
Она основана на объединении версии 2.3 Вайана Дэвисона (Wayne Davison)
и нескольких улучшений к версии 2.0 Оливера Ломанна (Oliver Laumann).
Следует иметь в виду, что все версии 2.x принадлежат
Оливеру Ломанну (Oliver Laumann).
</p>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=24" title="Править секцию: Доступность">править</a>]</span> <span class="mw-headline" id=".D0.94.D0.BE.D1.81.D1.82.D1.83.D0.BF.D0.BD.D0.BE.D1.81.D1.82.D1.8C"> Доступность </span></h2>
<p>Последний официальный релиз <i>screen</i>
доступен с помощью анонимного FTP на
gnudist.gnu.org, nic.funet.fi 
и других сайтах, распространяющих GNU.
Домашний сайт <i>screen</i> это  ftp.uni-erlangen.de,
каталог <tt>pub/utilities/screen</tt>.
Подкаталог <tt>private/</tt>
содержит последний тестовый бета-релиз.
Если вы хотите помочь, 
отправьте сообщение на <tt>screen@uni-erlangen.de</tt>.
</p>
<h2><span class="editsection">[<a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit&amp;section=25" title="Править секцию: Баги">править</a>]</span> <span class="mw-headline" id=".D0.91.D0.B0.D0.B3.D0.B8"> Баги </span></h2>
<ul><li>  "dm" (delete mode, режим удаления) и "xs" не обрабатываются 
корректно, они игнорируются. "xn" воспринимается как волшебный индикатор
 отступа.
</li><li>  Screen ничего не знает о символах двойной высоты и двойной ширины. Но это единственное место, где vttest может не работать.
</li><li>  При подключении из-под терминала с другим типом нет возможности поменять переменную окружения $TERMCAP
</li><li>  Поддержка terminfo-систем очень ограничена. Добавление новых возможностей в $TERMCAP не будет иметь должного эффекта.
</li><li>  Screen не использует аппаратные табы.
</li><li>  В большинстве случаев screen должен быть установлен с битом 
set-uid и пользователем root. Это нужно для того, чтобы он мог корректно
 менять владельца tty-устройства для каждого окна. Особые права ещё 
могут понадобиться для того, чтобы изменять файл "/var/run/utmp".
</li><li>  Записи в "/var/run/utmp" не удаляются, когда screen 
завершается по SIGKILL.  В результате некоторые программы (такие как "w"
 или "rwho") показывают, что пользователь зарегистрирован в системе, 
когда его на самом деле нет.
</li><li>  Screen может выдавать странное сообщение, когда для терминала нет записи в utmp
</li><li>  Если модемная линия разорвалась, screen может и не 
отключиться (или завершиться) автоматически, если драйвер устройства не 
настроен так, что отправляет сигнал HANGUP signal.   Для отключения 
сеанса screen нужно использовать опции командной строки <tt>-D</tt> или <tt>-d</tt>.
</li><li>  Опции -d и -D отключают сеанс без спроса, даже если установлен пароль.
</li><li>  И  "breaktype",  и  "defbreaktype"  меняют способ 
генерирования разрыва для всех терминальных устройств. Правда, первый 
меняет только текущие настройки, а второй — задаёт настройки для новых, 
будущих окон.
</li><li>  При подключении к многопользовательскому сеансу файл 
.screenrc пользователя не обрабатывается. Настройки пользователей должны
 быть включены в файл .screenrc пользователя, который запускает screen, 
или их нужно задавать вручную, когда screen уже работает.
</li><li>  Для того чтобы воспользоваться всеми фичами, нужно иметь весьма незаурядное воображение.
</li><li>  Сообщения об ошибках, исправления, улучшения, футболки, деньги, пиво и пиццу отправляйте по адресу <i>screen@uni-erlangen.de</i>.
</li></ul>

<!-- 
NewPP limit report
Preprocessor node count: 119/1000000
Post-expand include size: 134/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:2750-0!1!0!!ru!2 and timestamp 20150315200328 -->
<div class="printfooter">
Источник — «<a href="http://xgu.ru/wiki/man:screen">http://xgu.ru/wiki/man:screen</a>»</div>
		<div id="catlinks" class="catlinks"><div id="mw-normal-catlinks"><a href="http://xgu.ru/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:Categories" title="Служебная:Categories">Категории</a>: <span dir="ltr"><a href="http://xgu.ru/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%9F%D0%B5%D1%80%D0%B5%D0%B2%D1%91%D0%BB_%D0%98%D0%B3%D0%BE%D1%80%D1%8C_%D0%A7%D1%83%D0%B1%D0%B8%D0%BD" title="Категория:Перевёл Игорь Чубин">Перевёл Игорь Чубин</a></span> | <span dir="ltr"><a href="http://xgu.ru/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9_man" title="Категория:Русский man">Русский man</a></span></div></div>		<!-- end content -->
				<div class="visualClear"></div>
	</div>
</div></div>
<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Просмотры</h5>
		<div class="pBody">
			<ul>
				 <li id="ca-nstab-main" class="selected"><a href="http://xgu.ru/wiki/man:screen" title="Содержание статьи [alt-shift-c]" accesskey="c">Статья</a></li>
				 <li id="ca-talk" class="new"><a href="http://xgu.ru/w/index.php?title=%D0%9E%D0%B1%D1%81%D1%83%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5:man:screen&amp;action=edit&amp;redlink=1" title="Обсуждение содержания страницы [alt-shift-t]" accesskey="t">Обсуждение</a></li>
				 <li id="ca-edit"><a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=edit" title="Эту страницу можно изменять. Используйте, пожалуйста, предварительный просмотр перед сохранением [alt-shift-e]" accesskey="e">Править</a></li>
				 <li id="ca-history"><a href="http://xgu.ru/w/index.php?title=man:screen&amp;action=history" title="Журнал изменений страницы [alt-shift-h]" accesskey="h">История</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Личные инструменты</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="http://xgu.ru/w/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:UserLogin&amp;returnto=man:screen" title="Здесь можно зарегистрироваться в системе, но это необязательно. [alt-shift-o]" accesskey="o">Представиться / зарегистрироваться</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(/pics/xguru.png);" href="http://xgu.ru/wiki/%D0%97%D0%B0%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0" title="Заглавная страница"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class="generated-sidebar portlet" id="p-navigation">
		<h5>Навигация</h5>
		<div class="pBody">
			<ul>
				<li id="n-mainpage"><a href="http://xgu.ru/wiki/%D0%97%D0%B0%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0" title="Перейти на заглавную страницу [alt-shift-z]" accesskey="z">Заглавная страница</a></li>
				<li id="n-recentchanges"><a href="http://xgu.ru/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:RecentChanges" title="Список последних изменений [alt-shift-r]" accesskey="r">Свежие правки</a></li>
				<li id="n-randompage"><a href="http://xgu.ru/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:Random" title="Посмотреть случайную страницу [alt-shift-x]" accesskey="x">Случайная статья</a></li>
				<li id="n-help"><a href="http://xgu.ru/wiki/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0:%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5" title="Справочник по проекту «Xgu.ru»">Справка</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Поиск</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/w/index.php" id="searchform">
				<input name="title" value="Служебная:Search" type="hidden">
				<input autocomplete="off" id="searchInput" title="Искать это слово" accesskey="f" name="search" type="search">
				<input name="go" class="searchButton" id="searchGoButton" value="Перейти" title="Перейти к странице, имеющей в точности такое название" type="submit">&nbsp;
				<input name="fulltext" class="searchButton" id="mw-searchButton" value="Найти" title="Найти страницы, содержащие указанный текст" type="submit">
			</form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Инструменты</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="http://xgu.ru/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:WhatLinksHere/man:screen" title="Список всех страниц, которые ссылаются на эту страницу [alt-shift-j]" accesskey="j">Ссылки сюда</a></li>
				<li id="t-recentchangeslinked"><a href="http://xgu.ru/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:RecentChangesLinked/man:screen" title="Последние изменения в страницах, на которые ссылается эта страница [alt-shift-k]" accesskey="k">Связанные правки</a></li>
<li id="t-specialpages"><a href="http://xgu.ru/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:SpecialPages" title="Список служебных страниц [alt-shift-q]" accesskey="q">Спецстраницы</a></li>
				<li id="t-print"><a href="http://xgu.ru/w/index.php?title=man:screen&amp;printable=yes" rel="alternate" title="Версия этой страницы для печати [alt-shift-p]" accesskey="p">Версия для печати</a></li>				<li id="t-permalink"><a href="http://xgu.ru/w/index.php?title=man:screen&amp;oldid=32503" title="Постоянная ссылка на эту версию страницы">Постоянная ссылка</a></li>			</ul>
		</div>
	</div>
</div><!-- end of the left (by default at least) column -->


<div class="visualClear"></div>
<div id="footer">
	<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="man%20screen%20%E2%80%94%20Xgu.ru_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" height="31" width="88"></a></div>
	<ul id="f-list">
		<li id="lastmod"> Последнее изменение этой страницы: 09:54, 10 мая 2013.</li>
		<li id="viewcount">К этой странице обращались 118&nbsp;265 раз.</li>
		<li id="privacy"><a href="http://xgu.ru/wiki/Xgu.ru:%D0%9F%D0%BE%D0%BB%D0%B8%D1%82%D0%B8%D0%BA%D0%B0_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B4%D0%B5%D0%BD%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="Xgu.ru:Политика конфиденциальности">Политика конфиденциальности</a></li>
		<li id="about"><a href="http://xgu.ru/wiki/Xgu.ru:%D0%9E%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5" title="Xgu.ru:Описание">Описание Xgu.ru</a></li>
		<li id="disclaimer"><a href="http://xgu.ru/wiki/Xgu.ru:%D0%9E%D1%82%D0%BA%D0%B0%D0%B7_%D0%BE%D1%82_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="Xgu.ru:Отказ от ответственности">Отказ от ответственности</a></li>
	</ul>
	
</div>
</div>

<script>if (window.runOnloadHook) runOnloadHook();</script>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script><script src="man%20screen%20%E2%80%94%20Xgu.ru_files/ga.js" type="text/javascript"></script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3276870-1");
pageTracker._trackPageview();
</script><!-- Served in 1.383 secs. -->
<style class="ublock-postload-1ae7a5f130fc79b4fdb8a4272d9426b5">#content > #center > .dose > .dosesingle,
#content > #right > .dose > .dosesingle
{display:none !important;}</style></body></html>