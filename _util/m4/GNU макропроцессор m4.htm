<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1251">
<title>GNU макропроцессор</title>
</head>
<body text="#000000" bgcolor="#FFFFFF">
<h1>GNU m4, версия 1.4</h1>
<h2>Мощный макропроцессор</h2>
<h2>Редакция 1.4, Ноябрь 1994</h2>
<address>Ren'e Seindal</address>
<p>
Русский перевод - (C) <a href="mailto:alex%3Cat%3Elviv.bank.gov.ua">А.Гавва</a><br>
<i>г.Львов январь 2003г.</i>
</p><p>
</p><p></p><hr><p>
</p><h1>Содержание</h1>
<ul>
<li><a name="TOC1" href="#SEC1">Введение и предварительные замечания</a>
<ul>
<li><a name="TOC2" href="#SEC2">Введение в <code>m4</code></a>
</li><li><a name="TOC3" href="#SEC3">Исторические сведения</a>
</li><li><a name="TOC4" href="#SEC4">Запуск <code>m4</code></a>
</li><li><a name="TOC5" href="#SEC5">Проблемы и ошибки</a>
</li><li><a name="TOC6" href="#SEC6">Использование этого руководства</a>
</li></ul>
</li><li><a name="TOC7" href="#SEC7">Лексические и синтаксические соглашения</a>
<ul>
<li><a name="TOC8" href="#SEC8">Имена</a>
</li><li><a name="TOC9" href="#SEC9">Строки в кавычках (цитирование)</a>
</li><li><a name="TOC10" href="#SEC10">Прочие токены</a>
</li><li><a name="TOC11" href="#SEC11">Комментарии</a>
</li></ul>
</li><li><a name="TOC12" href="#SEC12">Как вызывать макросы</a>
<ul>
<li><a name="TOC13" href="#SEC13">Вызов макроса</a>
</li><li><a name="TOC14" href="#SEC14">Предотвращение вызова макроса</a>
</li><li><a name="TOC15" href="#SEC15">Макро-аргументы</a>
</li><li><a name="TOC16" href="#SEC16">Помещение макро-аргументов в кавычки</a>
</li><li><a name="TOC17" href="#SEC17">Макро-расширение</a>
</li></ul>
</li><li><a name="TOC18" href="#SEC18">Как определять новые макросы</a>
<ul>
<li><a name="TOC19" href="#SEC19">Определение макроса</a>
</li><li><a name="TOC20" href="#SEC20">Аргументы для макроса</a>
</li><li><a name="TOC21" href="#SEC21">Специальные аргументы для макроса</a>
</li><li><a name="TOC22" href="#SEC22">Удаление макроса</a>
</li><li><a name="TOC23" href="#SEC23">Переименование макроса</a>
</li><li><a name="TOC24" href="#SEC24">Временное переопределение макроса</a>
</li><li><a name="TOC25" href="#SEC25">Косвенные вызовы макросов</a>
</li><li><a name="TOC26" href="#SEC26">Косвенные вызовы встроенных макросов</a>
</li></ul>
</li><li><a name="TOC27" href="#SEC27">Условия, циклы и рекурсия</a>
<ul>
<li><a name="TOC28" href="#SEC28">Проверка макро-определений</a>
</li><li><a name="TOC29" href="#SEC29">Сравнение строк</a>
</li><li><a name="TOC30" href="#SEC30">Циклы и рекурсия</a>
</li></ul>
</li><li><a name="TOC31" href="#SEC31">Как отлаживать макросы и ввод</a>
<ul>
<li><a name="TOC32" href="#SEC32">Отображение макро-определений</a>
</li><li><a name="TOC33" href="#SEC33">Трассировка макро-вызовов</a>
</li><li><a name="TOC34" href="#SEC34">Управление отладочным выводом</a>
</li><li><a name="TOC35" href="#SEC35">Сохранение отладочного вывода</a>
</li></ul>
</li><li><a name="TOC36" href="#SEC36">Управление вводом</a>
<ul>
<li><a name="TOC37" href="#SEC37">Удаление пробелов из ввода</a>
</li><li><a name="TOC38" href="#SEC38">Изменение символов кавычек</a>
</li><li><a name="TOC39" href="#SEC39">Изменение ограничителей комментариев</a>
</li><li><a name="TOC40" href="#SEC40">Изменение лексической структуры слов</a>
</li><li><a name="TOC41" href="#SEC41">Сохранение ввода</a>
</li></ul>
</li><li><a name="TOC42" href="#SEC42">Включение файлов</a>
<ul>
<li><a name="TOC43" href="#SEC43">Включение именованых файлов</a>
</li><li><a name="TOC44" href="#SEC44">Поиск включаемых файлов</a>
</li></ul>
</li><li><a name="TOC45" href="#SEC45">Перенаправление (diverting) и отмена перенаправления (undiverting) вывода</a>
<ul>
<li><a name="TOC46" href="#SEC46">Перенаправление (diverting) вывода</a>
</li><li><a name="TOC47" href="#SEC47">Отмена перенаправления (undiverting) вывода</a>
</li><li><a name="TOC48" href="#SEC48">Нумерация перенаправлений (diversion)</a>
</li><li><a name="TOC49" href="#SEC49">Отброс перенаправленного (diverted) текста</a>
</li></ul>
</li><li><a name="TOC50" href="#SEC50">Макросы для обработки текста</a>
<ul>
<li><a name="TOC51" href="#SEC51">Определение длины строки</a>
</li><li><a name="TOC52" href="#SEC52">Поиск подстроки</a>
</li><li><a name="TOC53" href="#SEC53">Поиск регулярного выражения</a>
</li><li><a name="TOC54" href="#SEC54">Извлечение подстроки</a>
</li><li><a name="TOC55" href="#SEC55">Трансляция символов</a>
</li><li><a name="TOC56" href="#SEC56">Подстановка текста с помощью регулярного выражения</a>
</li><li><a name="TOC57" href="#SEC57">Форматирование вывода</a>
</li></ul>
</li><li><a name="TOC58" href="#SEC58">Арифметические макросы</a>
<ul>
<li><a name="TOC59" href="#SEC59">Декремент и инкремент</a>
</li><li><a name="TOC60" href="#SEC60">Оценка значений целочисленных выражений</a>
</li></ul>
</li><li><a name="TOC61" href="#SEC61">Выполнение команд UNIX</a>
<ul>
<li><a name="TOC62" href="#SEC62">Выполнение простых команд</a>
</li><li><a name="TOC63" href="#SEC63">Чтение вывода команд</a>
</li><li><a name="TOC64" href="#SEC64">Коды завершения</a>
</li><li><a name="TOC65" href="#SEC65">Создание имен для временных файлов</a>
</li></ul>
</li><li><a name="TOC66" href="#SEC66">Различные встроенные макросы</a>
<ul>
<li><a name="TOC67" href="#SEC67">Печать сообщений об ошибках</a>
</li><li><a name="TOC68" href="#SEC68">Выход из <code>m4</code></a>
</li></ul>
</li><li><a name="TOC69" href="#SEC69">Быстрая загрузка "замороженных" состояний</a>
</li><li><a name="TOC70" href="#SEC70">Совместимость с другими версиями <code>m4</code></a>
<ul>
<li><a name="TOC71" href="#SEC71">Расширения в GNU <code>m4</code></a>
</li><li><a name="TOC72" href="#SEC72">Возможности версии <code>m4</code> для System V, отсутствующие в GNU <code>m4</code></a>
</li><li><a name="TOC73" href="#SEC73">Прочие несовместимости</a>
</li></ul>
<!---
<LI><A NAME="TOC74" HREF="#SEC74">Concept index</A>
<LI><A NAME="TOC75" HREF="#SEC75">Macro index</A>
--->
</li></ul>
<p></p><hr><p>

</p><p>
Copyright (C) 1989, 90, 91, 92, 93, 94 Free Software Foundation, Inc.

</p>
<p>
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

</p>
<p>
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

</p>
<p>
Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.

</p>



<h1><a name="SEC1" href="#TOC1">Введение и предварительные замечания</a></h1>

<p>
Эта глава - вводная.

Она рассказывает о том, что такое GNU <code>m4</code>,
как <code>m4</code> появился,
как читать и использовать эту документацию,
как запусть программу <code>m4</code> на выполнение
и как сообщать об обнаруженных в этой программе ошибках.

Таким образом, эта глава содержит некоторые подсказки
которые будут полезны при чтении остального материала
этого учебника.
</p>

<p>
Остальные главы учебника предоставляют детальные сведения
об особенностях языка <code>m4</code>.
</p>



<h2><a name="SEC2" href="#TOC2">Введение в <code>m4</code></a></h2>

<p>
<code>m4</code> - это макропроцессор
который осуществляет копирование данных с его входа
на выход, расширяя макросы по мере их поступления.

Макросы бывают строенными или определяемыми пользователем,
и могут содержать любое количество аргументов.

Кроме выполнения макрорасширений (макроподстановок),
<code>m4</code> имеет встроенные функции для включения именованых файлов,
запуска команд UNIX, выполнения целочисленной арифметики,
различного манипулирования текстом,
осуществления рекурсии, и т.д.

<code>m4</code> может быть использован как препроцессор (<i>front-end</i>) какого-либо компилятора,
или как самостоятельный макропроцессор.
</p>


<p>
Макропроцессор <code>m4</code> широко используется во всех системах UNIX.

Обычно, о его наличии беспокоится достаточно не большой процент пользователей.

<!---
However, those who do often become commited users.  
--->
Однако, есть и те кто используют его часто.

Растущая популярность пакета GNU Autoconf, который требует наличия GNU <code>m4</code>
для генерации скриптов <tt>`configure'</tt>, стимулирует многих пользователей
устанавливать <code>m4</code> даже если они никогда не будут его реально использовать
для программирования.

GNU <code>m4</code> в большинстве случаев совместим с версией
для системы <i>System V Release 3</i>, исключая несколько
небольших различий.

Более полная информация содержится в секции
<a href="#SEC70">Совместимость с другими версиями <code>m4</code></a>.
</p>


<p>
Некоторые люди привыкают к использованию <code>m4</code>.

Сначала они используют <code>m4</code> для решения простых задач,
потом решаемы задачи становятся более сложными,
требуя значительно больше времени на отладку скриптов <code>m4</code>
чем на выполнение непосредственной работы.

Учтите, что <code>m4</code> может стать опасен для здоровья некоторых
заядлых программистов.
</p>



<h2><a name="SEC3" href="#TOC3">Исторические сведения</a></h2>


<p>
Упоминаемые здесь исторические сведения очень не полные
и абсолютно не авторитарны.

Для более полного написания этой секции,
необходима помощь осведомленных пользователей.
</p>



<p>
Важным прародителем <code>m4</code> был <code>GPM</code>.

См. <i>C. Stratchey: "A General Purpose Macro generator", Computer Journal
8,3 (1965), pp. 225 ff.</i>.

Кроме того, <code>GPM</code> описан в классической книге
<i>David Gries "Compiler Construction for Digital Computers"</i>.
</p>



<p>
В то время как <code>GPM</code> был <em>чистым</em>, <code>m4</code> был
задуман как средство для работы с истинной запутанностью реальной жизни:
макросы могли быть распознаны как предопределенные,
отброс пробелов или символов завершения строки был сделан более легким,
множество конструкций было встроено вместо использования производных, и т.д.
</p>



<p>
В оригинале, <code>m4</code> был разработан как основа препроцессора для <i>Rational FORTRAN</i>,
таким образом, <code>ratfor</code> является эквивалентом <code>cpp</code>.
</p>



<h2><a name="SEC4" href="#TOC4">Запуск <code>m4</code></a></h2>

<p>
Формат командной строки для запуска <code>m4</code>, следующий:
</p>

<pre><code>m4</code> [<var>option</var>...] [<var>macro-definitions</var>...] [<var>input-file</var>...]
</pre>

<p>
<a name="IDX1"></a>
<a name="IDX2"></a>
Все опции начинаются с <samp>`-'</samp>, или, при использовании опций с длинными именами,
с <samp>`--'</samp>.

Длинные имена опций могут быть записаны не полностью,
использование недвусмысленных префиксов достаточно.

<code>m4</code> понимает следующие опции:

</p>
<dl compact="compact">

<dt><code>--version</code>
</dt><dd>
Распечатывает в стандартный вывод номер версии программы,
после чего работа <code>m4</code> завершается немедленно, без чтения каких-либо входных
файлов <var>input-files</var>.

</dd><dt><code>--help</code>
</dt><dd>
Распечатывает в стандартный вывод общую подсказку,
после чего работа <code>m4</code> завершается немедленно, без чтения каких-либо входных
файлов <var>input-files</var>.

</dd><dt><code>-G</code>
</dt><dd>
</dd><dt><code>--traditional</code>
</dt><dd>
Подавить все расширения, в сравнении с версией System V, сделанные в этой реализации.
Для более полной информации
см. секцию <a href="#SEC70">Совместимость с другими версиями <code>m4</code></a>.

</dd><dt><code>-E</code>
</dt><dd>
</dd><dt><code>--fatal-warnings</code>
</dt><dd>
Остановить выполнение и выйти из <code>m4</code> при первой же выдаче предупреждающего сообщения,
рассматривая выдачу предупреждающего сообщения как фатальное.


</dd><dt><code>-d<var>flags</var></code>
</dt><dd>
</dd><dt><code>--debug=<var>flags</var></code>
</dt><dd>
Установить уровень отладки в соответствии с флагами <var>flags</var>.
Уровень отладки управляет форматом и количеством информации предоставляемой функциями отладки.
Для более полной информации о форматах и смысловому значению <var>flags</var>
см. секцию <a href="#SEC34">Управление отладочным выводом</a>.


</dd><dt><code>-l<var>num</var></code>
</dt><dd>
</dd><dt><code>--arglength=<var>num</var></code>
</dt><dd>
Ограничить размер вывода, генерируемого трассировкой макросов.
Для более полной информации
см. секцию <a href="#SEC34">Управление отладочным выводом</a>.

</dd><dt><code>-o<var>file</var></code>
</dt><dd>
</dd><dt><code>--error-output=<var>file</var></code>
</dt><dd>
Перенаправить вывод отладки и трассировки в указанный файл.
Вывод сообщений об ошибках на стандартное устройство вывода ошибок сохраняется.
Для более полной информации
см. секцию <a href="#SEC35">Сохранение отладочного вывода</a>.

</dd><dt><code>-I<var>dir</var></code>
</dt><dd>
</dd><dt><code>--include=<var>dir</var></code>
</dt><dd>
Указывает <code>m4</code> необходимоть поиска включаемых файлов в каталоге <var>dir</var>
когда включаемые файлы не найдены в текущем каталоге.
Для более полной информации
см. секцию <a href="#SEC44">Поиск включаемых файлов</a>.

</dd><dt><code>-e</code>
</dt><dd>
</dd><dt><code>--interactive</code>
</dt><dd>
Сделать этот вызов <code>m4</code> интерактивным.
Это подразумевает, что весь вывод не будет буферизироваться,
и прерывания будут игнорироваться.

</dd><dt><code>-s</code>
</dt><dd>
</dd><dt><code>--synclines</code>
</dt><dd>
Генерировать строки синхронизации для использования препроцессора C или подобных средств.

Это полезно, например, когда <code>m4</code> используется как препроцессор для какго-либо компилятора.

Имена исходных файлов и информация о нумерации строк передаются директивами вида
<samp>`#line <var>linenum</var> "<var>filename</var>"'</samp>, 
которые необходимым образом вставляются в середину ввода.

Подобные директивы подразумевают, что следующие строки порождены или расширены
из содержимого входного файла <var>filename</var> в строке <var>linenum</var>.

Часть <samp>`"<var>filename</var>"'</samp> часто бывает опущена
когда имя файла не было изменено предыдущей директивой.



Указание директив синхронизации всегда занимает самостоятельную строку.

При возникновении расхождений в синхронизации в середине выводимой строки,
ассоциируемая директива синхронизации задерживается до начала следующей
сгенерированной строки.

</dd><dt><code>-P</code>
</dt><dd>
</dd><dt><code>--prefix-builtins</code>
</dt><dd>
Выполняет внутреннюю модификацию <em>всех</em> встроенных макросов,
так чтобы они начинались с префикса <samp>`m4_'</samp>.

Например, при использовании этой опции, необходимо писать
<samp>`m4_define'</samp> вместо <samp>`define'</samp>, и
SAMP&gt;`m4___file__' вместо <samp>`__file__'</samp>.

</dd><dt><code>-W<var>REGEXP</var></code>
</dt><dd>
</dd><dt><code>--word-regexp=<var>REGEXP</var></code>
</dt><dd>
Использовать альтернативный синтаксис для имен макросов.
Эта экспериментальная опция может отсутствовать в некоторых реализациях GNU <code>m4</code>.
(Для более полной информации
см. секцию <a href="#SEC40">Изменение лексической структуры слов</a>).

</dd><dt><code>-H<var>n</var></code>
</dt><dd>
</dd><dt><code>--hashsize=<var>n</var></code>
</dt><dd>
Устанавливает длину внутренней хэш таблицы поиска символов в <var>n</var>.
Число должно быть простым. Используемое значение по умолчанию 509.
Без описания обширного количества макросов необходимость в увеличении этого числа не возникает.

</dd><dt><code>-L<var>n</var></code>
</dt><dd>
</dd><dt><code>--nesting-limit=<var>n</var></code>
</dt><dd>
Искусственно ограничивает вложенность макро-вызовов до <var>n</var> уровней,
останавливая выполнение программы в случае достижения или превышения этого уровня.
Без указания, уровень вложенности макро-вызовов ограничен величиной 250.
Более точный эффект действия этой опции может быть более корректно ассоциирован
с текстуальной вложенностью, а не как динамическая рекурсия.
Это может быть полезно когда подразумевается, что сложные входные данные <code>m4</code>
генерируются механически.
Большинству пользователей никогда не потребуется использование этой опции.
Если показанное будет навязываться, то эта опция (которая остается экспериментальной)
пожет исчезнуть.

Эта опция <em>не</em> имеет возможности прекратить бесконечные циклы пересканирования,
пока не будет исчерпано доступное пространство памяти или стека.
Удачное использование циклов пересканирования
может вызвать сложные и длительные вычисления <code>m4</code> с полезными результатами.
Установка ограничений в этой области может уменьшить мощность <code>m4</code>.

Существует множество патологических ситуаций.
Пример <samp>`define(`a', `a')a'</samp> является одним из простейших
(Для более полной информации
см. секцию <a href="#SEC70">Совместимость с другими версиями <code>m4</code></a>).

Ожидание чтобы GNU <code>m4</code> детектировал подобные ситуации
может показаться подобным ожиданию чтобы система компиляции детектировала
и проверяла наличие бесконечных циклов:
в общем это весьма <em>трудная</em> проблема, которая в общем является неразрешимой!

</dd><dt><code>-Q</code>
</dt><dd>
</dd><dt><code>--quiet</code>
</dt><dd>
</dd><dt><code>--silent</code>
</dt><dd>
Подавляет предупреждающие сообщения об отсутствующих или излишних (superflous)
аргументах в макро-вызовах.

</dd><dt><code>-B</code>
</dt><dd>
</dd><dt><code>-S</code>
</dt><dd>
</dd><dt><code>-T</code>
</dt><dd>
Наличие этих опций представлено только с целью обеспечения совместимости с версией <code>m4</code>
для System V, однако реально они ничего не делают.


</dd><dt><code>-N<var>n</var></code>
</dt><dd>
</dd><dt><code>--diversions=<var>n</var></code>
</dt><dd>
<!---
These options are present only for compatibility with previous
versions of GNU <CODE>m4</CODE>, 
and were controlling the number of possible
diversions which could be used at the same time.  

They do nothing, because there is no fixed limit anymore.
--->
Наличие этих опций представлено только с целью обеспечения совместимости
с предыдущими версиями <code>m4</code>
где присутствовало управление количеством возможных отклонений
которые согли быть использованы одновременно.

Реально, эти опции ничего не делают, поскольку теперь такой лимит больше не фиксируется.

</dd></dl>

<p>
<a name="IDX3"></a>
<a name="IDX4"></a>
Описание и удаление макро-определения может быть выполнено в командной строке
с помощбю использования опций <samp>`-D'</samp> и <samp>`-U'</samp>.

Это имеет следующий фомат:

</p>
<dl compact="compact">

<dt><code>-D<var>name</var></code>
</dt><dd>
</dd><dt><code>-D<var>name</var>=<var>value</var></code>
</dt><dd>
</dd><dt><code>--define=<var>name</var></code>
</dt><dd>
</dd><dt><code>--define=<var>name</var>=<var>value</var></code>
</dt><dd>
Это помещает <var>name</var> в таблицу символов, до чтения любого входного файла.
Если <samp>`=<var>value</var>'</samp> отсутствует, то значение символа содержит пустую строку.
Значение <var>value</var> может быть любой строкой
и макро-определение может описывать наличие макро-аргументов,
также, как это делается при описании макро-определения
на входе (во входном файле).

</dd><dt><code>-U<var>name</var></code>
</dt><dd>
</dd><dt><code>--undefine=<var>name</var></code>
</dt><dd>
Это удаляет любой предопределенный смысл <var>name</var>.
Очевидно, что таким образом можно удалять только предопределенные макро-определения.

</dd><dt><code>-t<var>name</var></code>
</dt><dd>
</dd><dt><code>--trace=<var>name</var></code>
</dt><dd>
Это вводит <var>name</var> в таблицу символов как неописанное, но трассируемое.
В результате, макро-определение будет трассироваться начиная от точки его описания.

</dd><dt><code>-F<var>file</var></code>
</dt><dd>
</dd><dt><code>--freeze-state <var>file</var></code>
</dt><dd>
Как только заканчивается выполнение, осуществляется запись "замороженного" состояния
в указанный файл <var>file</var>
(для более полной информации
см. секцию <a href="#SEC69">Быстрая загрузка "замороженных" состояний</a>).


</dd><dt><code>-R<var>file</var></code>
</dt><dd>
</dd><dt><code>--reload-state <var>file</var></code>
</dt><dd>
До начала выполнения, восстановить внутреннее состояние из указанного
файла "замороженного" состояния <var>file</var>
(для более полной информации
см. секцию <a href="#SEC69">Быстрая загрузка "замороженных" состояний</a>).

</dd></dl>



<p>
<a name="IDX5"></a>
<a name="IDX6"></a>
Остальныме аргументы командной строки принимаются как имена входных файлов.
Если не указано ни одного имени входного файла, то производится чтение
устройства стандартного ввода.
Принимается имя файла <tt>`-'</tt>, которое подразумевает
устройство стандартного ввода.
</p>


<p>
Чтение входных файлов осуществляется в указанной последовательности.
Устройство стандартного ввода может быть прочитано только однократно,
таким образом, имя файла <tt>`-'</tt> может быть указано в командной строке
не более одного раза.
</p>



<h2><a name="SEC5" href="#TOC5">Проблемы и ошибки</a></h2>

<p>
Если в процессе использования GNU <code>m4</code> у вас возникли проблемы,
или вам показалось, что вы обнаружили ошибку, пожалуйста сообщите об этом.

Перед тем как сообщать об ошибке, убедитесь в том,
что вы действительно обнаружили реальную ошибку.

Внимательно перечитайте документацию и убедитесь
в том, что вы можете сделать то, что вы пытаетесь.

Если после чтения документации остается не понятным,
можете-ли вы сделать то, что вы пытаетесь сделать,
то сообщите об этом также, поскольку это указывает на наличие ошибки в документации!
</p>


<p>
Перед тем как сообщать об ошибке или попытке исправить ее самостоятельно,
попытайте изолировать ее в минимальном (по размеру), насколько это возможно,
входном файле который способен воспроизвести проблему.

Затем, пошлите нам входной файл и полученные вами результаты работы <code>m4</code>.

Также, опишите то что вы ожидали получить как результат работы <code>m4</code>;
это поможет нам определить содержится-ли проблема в документации.
</p>


<p>
Как только вы получите точное воспроизведение проблемы,
пошлите через e-mail по адресу (Internet)
<tt>`bug-gnu-utils@prep.ai.mit.edu'</tt>
или (UUCP) <tt>`mit-eddie!prep.ai.mit.edu!bug-gnu-utils'</tt>.  

При этом, пожалуйста, укажите номер используемой вами версии <code>m4</code>.
Вы можете узнать эту информацию с помощью команды <samp>`m4 --version'</samp>.
</p>


<p>
Сообщения не об ошибках, с предложениями также всегда приветствуются.
Если вы имеете вопросы о чем-либо, что плохо описано в документации
или затемняет использование средств,
пожалуйста,сообщите об этом также.
</p>



<h2><a name="SEC6" href="#TOC6">Использование этого руководства</a></h2>


<p>
Это руководство содержит множество примеров ввода и вывода <code>m4</code>,
для того чтобы четко различать ввод, вывод и сообщения об ошибках <code>m4</code>
используется простая нотация.

Текст примеров также отличается от обычного текста и показан шрифтом
с фиксированной шириной, подобно следующему:
</p>

<pre>Это пример текста примера!
</pre>

<p>
Для различия ввода от вывода, весь вывод <code>m4</code> предваряется строкой <samp>`=&gt;'</samp>,
а все сообщения об ошибках - строкой <samp>`error--&gt;'</samp>.
Таким образом:
</p>


<pre>пример строки ввода
=&gt;строка вывода m4
error--&gt;сообщение об ошибке
</pre>


<p>
Поскольку макро-определения (макросы), предопределенные в <code>m4</code>, описаны,
прототип вызова макроса будет показан предоставляя информативно-наглядные имена
аргументов, например:
</p>


<pre>regexp(<var>string</var>, <var>regexp</var>, opt <var>replacement</var>)
</pre>


<p>
В <code>m4</code>, все аргументы макросов являются строками,
но некоторые имеют специальную интерпретацию, например числа, имена файлов, регулярные выражения
и т.д.
</p>


<p>
Указвние <samp>`opt'</samp> перед третьим аргументом,
говорит о том, что этот аргумент опционален,
и если он отсутствует, то значение его содержимого будет пустой строкой.

Указание многоточия (<samp>`...'</samp>) в конце списка аргументов
индицирует, что далее может следовать любое число аргументов
</p>


<p>
<!---
This document consistently writes and uses <EM>builtin</EM>, without an
hyphen, as if it were an English word.  

This is how the <CODE>builtin</CODE> primitive is spelled within <CODE>m4</CODE>.
--->
Этот документ согласованно пишет и использует <em>builtin</em>
без дефиса, как это требовалось бы при написании английского слова.

Именно таким образом примитив <code>builtin</code> записывается внутри <code>m4</code>.
</p>


<h1><a name="SEC7" href="#TOC7">Лексические и синтаксические соглашения</a></h1>

<p>
<a name="IDX7"></a>
<a name="IDX8"></a>
В процессе чтения ввода <code>m4</code>, он разделяет его в <em>токены</em> (<em>tokens</em>).

Токены могут быть именами, строками в кавычках или любыми одиночными символами,
которые не являются частью какого-либо имени или строки.

Ввод <code>m4</code> может также содержать комментарии.
</p>



<h2><a name="SEC8" href="#TOC8">Имена</a></h2>


<p>
<a name="IDX9"></a>
Имя - это любая последовательность букв, цифр и символов подчеркивания <kbd>_</kbd>,
не начинающаяся с цифры.

Если имя имеет макро-определение, то оно будет субъектом для макро-расширения
(см. секцию <a href="#SEC12">Как вызывать макросы</a>).
</p>


<p>
Примерами допустимых имен могут служить:
<samp>`foo'</samp>, <samp>`_tmp'</samp>, and <samp>`name01'</samp>.
</p>


<h2><a name="SEC9" href="#TOC9">Строки в кавычках (цитирование)</a></h2>

<p>
<a name="IDX10"></a>
Строки в кавычках (иначе, цитируемые строки) являются последовательностями символов,
заключенных в кавычки <kbd>`</kbd> и <kbd>'</kbd>,
причем число начальных и завершающих кавычек сбалансировано.

Значение строкового токена является текстом у которого один уровень кавычек отброшен.

Таким образом:
</p>

<pre>`'
</pre>

<p>
является пустой строкой, а
</p>

<pre>``quoted''
</pre>

<p>
является строкой
</p>

<pre>`quoted'
</pre>

<p>
Символы кавычек могут быть изменены в любой момент,
с помощью использования встроенного макроса <code>changequote</code>.

Для более полной информации
см. секцию <a href="#SEC38">Изменение символов кавычек</a>.
</p>


<h2><a name="SEC10" href="#TOC10">Прочие токены</a></h2>

<p>
Любой символ, который не является частью имени или строки в кавычках,
является самостоятельным токеном.
</p>


<h2><a name="SEC11" href="#TOC11">Комментарии</a></h2>

<p>
<a name="IDX11"></a>
Комментарии <code>m4</code> нормально ограниченны символом <samp>`#'</samp>
и символом новой строки.

Все символы между символами ограничения комментариев игнорируются,
но содержимое всего коментария (включая символы ограничения комментариев)
передается на вывод, то есть, комментарии не отбрасываются <code>m4</code>.
</p>


<p>
Комментарии не могут быть вложенными, таким образом,
первый же символ новой строки, после символа <samp>`#'</samp>,
завершает комментарий.

Комментирующий эффект символа начала комментария
может быть подавлен помещением этого символа в кавычки.
</p>


<p>
В любой момент времени, с помощью встроенного макроса <code>changecom</code>,
символы ограничения комментариев могут быть изменены на любую строку.

Для более полной информации
см. секцию <a href="#SEC39">Изменение ограничителей комментариев</a>.
</p>



<h1><a name="SEC12" href="#TOC12">Как вызывать макросы</a></h1>

<p>
Эта глава демонстрирует макро-вызовы, макро-аргументы
и то как трактуется макро-расширение.
</p>



<h2><a name="SEC13" href="#TOC13">Вызов макроса</a></h2>


<p>
<a name="IDX12"></a>
Макро-вызовы имеют одну из форм
</p>

<pre>name
</pre>

<p>
которая является макро-вызовом без единого аргумента, или
</p>

<pre>name(arg1, arg2, ..., arg<var>n</var>)
</pre>


<p>
которая является макро-вызовом с <var>n</var> аргументами.
Макросы могут иметь любое количество аргументов.
Все аргументы являются строками, но различные макросы могут интерпретировать свои артументы
различными способами.
</p>


<p>
Открывающие скобки <em>должны</em> непосредственно сопровождаться <var>name</var>,
без пробелов между ними.

Если это не так, то макрос будет вызван без единого аргумента.
</p>


<p>
Для макро-вызова, который не должен иметь аргументов, <em>не должны</em>
использоваться скобки. Макро-вызов
</p>

<pre>name()
</pre>

<p>
является вызовом с одним аргументом, которым является пустая строка,
а не вызовом без аргументов.
</p>



<h2><a name="SEC14" href="#TOC14">Предотвращение вызова макроса</a></h2>

<p>
Одной из инноваций языка <code>m4</code>, в сравнении с его предшественниками
(подобно Stratchey's <code>GPM</code>, например),
является возможность распознавания макро-вызовы без использования каких-либо специальных,
предшествующих вызову символов.

Хотя это удобно в общем,
такое свойство может иногда быть источником ложного, нежелательного макро-вызова.

Таким образом, GNU <code>m4</code> предоставляет некоторые механизмы или приемы
для предотвращения расценивания имен как макро-вызовов.
</p>


<p>
Прежде всего, многие встроенные макросы не могут быть осмысленно вызваны без аргументов.

Для любого из этих макросов,
когда за открывающей скобкой непосредственно не следует имя параметра,
вызов встроенного макроса не воспринимается.

Это позволяет распутать большинство обычных случаев, подобных использованию
<samp>`include'</samp> или <samp>`eval'</samp>.  

<!---
Later in this document, the sentence
"This macro is recognized only when given arguments" 
refers to this specific provision.
--->
Позже, в этом документе, предложение
"This macro is recognized only when given arguments" 
ссылается к этому специфическому соглашению.
</p>


<p>
Существует также опции командной строки
(<code>--prefix-builtins</code> или <code>-P</code>) 
которые требуют, чтобы все имена встроенных макросов предварялись <samp>`m4_'</samp>
(иначе, использовали <samp>`m4_'</samp> как префикс),
с целью правильного распознавания встроенных макросов.

Опция не имеет эффекта для любого макроса, объявленного пользователем.

Например, с этой опцией, можно написать <code>m4_dnl</code> и даже <code>m4_m4exit</code>.
</p>


<p>
Если версия GNU <code>m4</code>, используемая вами,
содержит прекомпилированное средство <code>changeword</code>,
то она предлагает большую гибкость в спецификации синтаксиса
как встроенных, так и определяемых пользователем макро-имен.

Для более полной информации об этом экспериментальном средстве
см. секцию <a href="#SEC40">Изменение лексической структуры слов</a>.
</p>


<p>
Естественно, самым простым способом предотвратить интерпретацию какого-либо имени
как вызов существующего макроса является помещение этого имени в кавычки.

Остальная часть этой секции немного глубже рассматривает то,
как помещение в кавычки влияет на вызов макроса,
и как помещение в кавычки может быть использовано для предотвращения макро-вызова.
</p>


<p>
Даже если помещение в кавычки выполняется обычно для всего имени макроса,
это может быть сделано только для нескольких символов этого имени макроса.

Возможно также заключение в кавычки пустой строки,
но это будет работать только <em>внутри</em> имени.

Например:
</p>

<pre>`divert'
`d'ivert
di`ver't
div`'ert
</pre>

<p>
все это дает строку <samp>`divert'</samp>.

В то время как оба варианта:
</p>

<pre>`'divert
divert`'
</pre>

<p>
будет вызывать встроенный макрос <code>divert</code>.
</p>


<p>
Вывод оценки макроса всегда пересканируется.

Следующий пример будет вызывать строку <samp>`de'</samp>,
точно также если на ввод <code>m4</code> будет выдано
<samp>`substr(abcde, 3, 2)'</samp>:
</p>

<pre>define(`x', `substr(ab')
define(`y', `cde, 3, 2)')
x`'y
</pre>

<p>
Строки, не помещенные в кавычки, с обоих сторон строк, помещенных в кавычки,
являются субъектами, распознаваемыми как имена макросов.

В следующем примере, помещение в кавычки пустой строки,
позволяет распознать макрос <code>dnl</code> следующим образом:
</p>

<pre>define(`macro', `di$1')
macro(v)`'dnl
</pre>

<p>
Без использования кавычек, это даст строку <samp>`divdnl'</samp>
сопровождаемую символом конца строки.
</p>


<p>
Помещение в кавычки может предотвратить распознавание
конкатенации макро-расширения с окружающими символами
как имени макроса.

В этом примере:
</p>

<pre>define(`macro', `di$1')
macro(v)`ert'
</pre>

<p>
ввод будет создавать строку <samp>`divert'</samp>.
Если убрать кавычки, то вместо этого, будет вызван встроенный макрос <code>divert</code>.
</p>



<h2><a name="SEC15" href="#TOC15">Макро-аргументы</a></h2>


<p>
<a name="IDX13"></a>
<a name="IDX14"></a>
Когда имя распознано, и оно имеет макро-определение,
то оно будет расширено как макрос.
</p>

<p>
Если имя сопровождается открывающейся скобкой,
то, до того как выполняется вызов макроса, осуществляется накопление аргументов.
Если указанных аргументов меньше, то отсутствующие аргументы трактуются как пустые строки.
Если предоставлено больше аргументов, то лишние аргументы игнорируются.
</p>


<p>
Обычно <code>m4</code> генерирует предупреждающие сообщения,
когда встроенные макросы вызываются с не подходящим количеством аргументов,
но предупреждающие сообщения могут быть подавлены
опцией командной строки <samp>`-Q'</samp>.

Проверка количества аргументов, для определяемых пользователем макросов, отсутствует.
</p>


<p>
Обычно, макросы расширяются в процессе накопления аргументов,
и все запятые, кавычки и скобки, которые могут быть показаны в результирующем
расширенном тексте, будут также обеспечивать описание аргументов.

Таким образом, если <var>foo</var> расширяется в <samp>`, b, c'</samp>,
то макро-вызов:
</p>

<pre>bar(a foo, d)
</pre>

<p>
является макро-вызовом с четырьмя аргументами, которыми являются
<samp>`a '</samp>, <samp>`b'</samp>, <samp>`c'</samp> и <samp>`d'</samp>.

Чтобы понять почему первый аргумент содержит пробел,
следует иметь в виду, что предшествующие (лидирующие) не помещенные в кавычки пробелы
никогда не являются частью аргумента,
но последующие (завершающие) пробелы всегда являются частью аргумента.
</p>


<h2><a name="SEC16" href="#TOC16">Помещение макро-аргументов в кавычки</a></h2>

<p>
<a name="IDX15"></a>
<a name="IDX16"></a>
<a name="IDX17"></a>
Каждый аргумент не должен иметь предшествующие (лидирующие) пробелы
которые не помещены в кавычки.
Внутри каждого аргумента, все скобки, которые не помещены в кавычки, должны быть парными.
Например, если <var>foo</var> является макросом,
</p>

<pre>foo(() (`(') `(')
</pre>

<p>
является вызовом макроса с одним аргументом, значением которого будет <samp>`() (() ('</samp>.
</p>


<p>
Существует общая практика помещать в кавычки все аргументы макроса,
если нет уверенности в том, что необходима возможность расширения аргументов.

Таким образом, в показанном выше примере со скобками,
правильным способом выполнения этого будет:
</p>

<pre>foo(`() (() (')
</pre>

<p>
Однако, в некоторых случаях возникает необходимость
не заключать в кавычки некоторые аргументы, и в этом нет ничего страшного.

Это делает жизнь несколько труднее, если вы не очень внимательны.
</p>


<h2><a name="SEC17" href="#TOC17">Макро-расширение</a></h2>

<p>
<a name="IDX18"></a>
<a name="IDX19"></a>
Когда аргументы (если они есть) для макро-вызова накоплены,
то происходит расширение макроса, и текст расширения возвращается обратно на вход
(без помещения его в кавычки) и перечитывается.

Таким образом, текст расширения одного макро-вызова может привести к вызову множества макросов,
если вызовы включены (полностью или частично) в первое расширение макро-вызова.
</p>


<p>
Рассмотрим очень простой пример.
Если <var>foo</var> будет расширен в <samp>`bar'</samp>,
а <var>bar</var> расширяется в<samp>`Hello world'</samp>,
то ввод
</p>

<pre>foo
</pre>

<p>
сначала будет расширен в <samp>`bar'</samp>,
а затем, перечитан и расширен в <samp>`Hello world'</samp>.
</p>



<h1><a name="SEC18" href="#TOC18">Как определять новые макросы</a></h1>


<p>
<a name="IDX20"></a>
<a name="IDX21"></a>
Макросы могут быть определены, переопределены и удалны различными способами.

Также, существует возможность переопределять любой макрос,
без потери его первоначального значения, которое позже может быть восстановлено обратно.
</p>



<h2><a name="SEC19" href="#TOC19">Определение макроса</a></h2>


<p>
<a name="IDX22"></a>
Обычным способом определения и переопределения макросов
является использование встроенного макроса <code>define</code>:
</p>

<pre>define(<var>name</var> [, <var>expansion</var>])
</pre>

<p>
который определяет, что имя <var>name</var> может быть расширено как <var>expansion</var>.
Если <var>expansion</var> не указано, то считается, что расширение - пустое.
</p>

<p>
Встроенный макрос <code>define</code> имеет пустое (void) расширение.
</p>


<p>
Следующий пример определяет, что макрос <var>foo</var>
расширяется как текст <samp>`Hello World.'</samp>.
</p>

<pre>define(`foo', `Hello world.')
=&gt;
foo
=&gt;Hello world.
</pre>

<p>
Появление пустой строки в выводе обусловлено тем, что новая строка (newline)
не является частью макро-определения, и, следовательно, она копируется в вывод.

Этого можно избежать путем использования макроса <code>dnl</code>.

Более полная информация содержится в секции
<a href="#SEC37">Удаление пробелов из ввода</a>.
</p>


<p>
Макрос <code>define</code> распознается только при наличии параметров.
</p>


<h2><a name="SEC20" href="#TOC20">Аргументы для макроса</a></h2>

<p>
<a name="IDX23"></a>
<a name="IDX24"></a>
Макросы могут иметь параметры.

Аргумент с порядковым номером <var>n</var> обозначается как <code>$n</code> в тексте расширения,
и заменяется фактическим значением аргумента с порядковым номером <var>n</var>,
во время расширения макроса.

Рассмотрим пример макроса с двумя аргументами.

Этот макрос осуществляет простое изменение порядка следования двух аргументов.
</p>

<pre>define(`exch', `$2, $1')
=&gt;
exch(arg1, arg2)
=&gt;arg2, arg1
</pre>

<p>
Это может быть использовано, например, если вам нравится чтобы порядок следования
аргументов макроса <code>define</code> был обратным.
</p>

<pre>define(`exch', `$2, $1')
=&gt;
define(exch(``expansion text'', ``macro''))
=&gt;
macro
=&gt;expansion text
</pre>

<p>
За объяснениями по использовинию двойных кавычек обратитесь к секции
<a href="#SEC16">Помещение макро-аргументов в кавычки</a>.
</p>
<p>
<a name="IDX25"></a>
GNU <code>m4</code> допускает, чтобы числа, следующие за <samp>`$'</samp>,
состояли из одной и более цифр, позволяя макросам иметь любое количество аргументов.

Это не поддерживается реализациями <code>m4</code> для UNIX,
которые способны распознать только одну цифру.
</p>


<p>
Как специальный случай, нулевой аргумент, <code>$0</code>, всегда является именем
расширяемого макроса.
</p>

<pre>define(`test', ``Macro name: $0'')
=&gt;
test
=&gt;Macro name: test
</pre>

<p>
Если необходимо, чтобы текст в кавычках появился как часть текста расширения,
помните, что кавычки могут быть вложенными в строки заключенные в кавычки.
Таким образом, в
</p>

<pre>define(`foo', `This is macro `foo'.')
=&gt;
foo
=&gt;This is macro foo.
</pre>

<p>
указанное в тексте расширения <samp>`foo'</samp> <em>не</em> расширено,
поскольку является строкой помещенной в кавычки, а не именем.
</p>



<h2><a name="SEC21" href="#TOC21">Специальные аргументы для макроса</a></h2>


<p>
<a name="IDX26"></a>
<a name="IDX27"></a>
<a name="IDX28"></a>
Существует специальная нотация для определения числа фактически переданных аргументов
и для всех фактических аргументов (одновременно).
</p>


<p>
Число фактических аргументов макро-вызова обозначается в тексте расширения с помощью  <code>$#</code>.
Таким образом, макрос, отображающий число фактически переданных ему аргументов, может иметь вид
</p>

<pre>define(`nargs', `$#')
=&gt;
nargs
=&gt;0
nargs()
=&gt;1
nargs(arg1, arg2, arg3)
=&gt;3
</pre>

<p>
Для определения, в тексте расширения, всех фактических аргументов (одновременно),
без помещения их в кавычки и разделяя их запятыми, может быть использована нотация <code>$*</code>.
Например
</p>

<pre>define(`echo', `$*')
=&gt;
echo(arg1,    arg2, arg3 , arg4)
=&gt;arg1,arg2,arg3 ,arg4
</pre>

<p>
Часто каждый аргумент должен быть помещен в кавычки, и нотация вида <code>$@</code>
может это обработать.
Это подобно <code>$*</code>, за исключением того, что в кавычки помещается каждый аргумент.

Простым примером этого является:
</p>

<pre>define(`echo', `$@')
=&gt;
echo(arg1,    arg2, arg3 , arg4)
=&gt;arg1,arg2,arg3 ,arg4
</pre>

<p>
А куда делись кавычки?
Естественно, они были "съедены", когда расширенный текст был перечитан <code>m4</code>.
Для того, чтобы продемонстрировать разницу, попробуйте
</p>

<pre>define(`echo1', `$*')
=&gt;
define(`echo2', `$@')
=&gt;
define(`foo', `This is macro `foo'.')
=&gt;
echo1(foo)
=&gt;This is macro This is macro foo..
echo2(foo)
=&gt;This is macro foo.
</pre>

<p>
Посмотрите секцию <a href="#SEC33">Трассировка макро-вызовов</a>,
если вы этого не поняли.
</p>


<p>
В тексте расширения, самостоятельный знак <samp>`$'</samp>, который не сопровождается ничем
что понимается <code>m4</code>, просто копируется в макро-расширение,
также как и любой другой текст.
</p>

<pre>define(`foo', `$$$ hello $$$')
=&gt;
foo
=&gt;$$$ hello $$$
</pre>

<p>
Если необходимо расширить макрос в что-нибудь подобное <samp>`$12'</samp>,
поместите пару кавычек после <code>$</code>.

Это предохранит <code>m4</code> от интерпретации знака <code>$</code>
как обрашение к какому-либо аргументу.
</p>


<h2><a name="SEC22" href="#TOC22">Удаление макроса</a></h2>

<p>
<a name="IDX29"></a>
<a name="IDX30"></a>
<a name="IDX31"></a>
<a name="IDX32"></a>
Любое макро-определение может быть удалено с помощью встроенного макроса <code>undefine</code>:
</p>

<pre>undefine(<var>name</var>)
</pre>

<p>
который удаляет макрос с именем <var>name</var>.
Макро-имя <var>name</var> должно быть помещено в кавычки,
поскольку, в противном случае, оно будет расширено.
</p>


<p>
Встроенный макрос <code>undefine</code> имеет пустое (void) расширение.
</p>

<pre>foo
=&gt;foo
define(`foo', `expansion text')
=&gt;
foo
=&gt;expansion text
undefine(`foo')
=&gt;
foo
=&gt;foo
</pre>

<p>
Не будет ошибкой если для имени <var>name</var> не определено макро-расширение.
В таком случае, <code>undefine</code> просто ничего не делает.
</p>


<p>
Встроенный макрос <code>undefine</code> распознается только при наличии параметров.
</p>


<h2><a name="SEC23" href="#TOC23">Переименование макроса</a></h2>

<p>
<a name="IDX33"></a>
<a name="IDX34"></a>
<a name="IDX35"></a>
Есть возможность осуществлять переименование любого уже определенного макроса.
Для выполнения этого, необходимо использовать встроенный макрос <code>defn</code>:
</p>

<pre>defn(<var>name</var>)
</pre>

<p>
который осуществляет расширение <em>заключенного в кавычки</em> определения имени <var>name</var>.
Если аргумент не является определенным макросом, то расширение будет пустым (void).
</p>

<p>
Если имя <var>name</var> является макросом, определенным пользователем,
то заключенное в кавычки определение будет просто заключенным в кавычки
текстом расширения.

Если имя <var>name</var> является встроенным макросом,
то расширение будет специальным токеном,
который указывает на внутреннее определение встроенного макроса.

Этот токен имеет смысл только как второй аргумент для
<code>define</code> (и <code>pushdef</code>),
и игнорируется в любом другом контексте.
</p>


<p>
Его номальное использование легче понять на примере,
который показывает как переименовать <code>undefine</code> в <code>zap</code>:
</p>

<pre>define(`zap', defn(`undefine'))
=&gt;
zap(`undefine')
=&gt;
undefine(`zap')
=&gt;undefine(zap)
</pre>

<p>
Таким способом, <code>defn</code> может быть использован для копирования макро-определений,
а также определений встроенных макросов.

Даже когда оригинальный макрос удален,
другое имя может быть использовано для доступа к определению.
</p>


<p>
Встроенный макрос <code>defn</code> распознается только при наличии параметров.
</p>


<h2><a name="SEC24" href="#TOC24">Временное переопределение макроса</a></h2>

<p>
<a name="IDX36"></a>
<a name="IDX37"></a>
<a name="IDX38"></a>
Существует возможность временного переопределения макроса,
с возвращением предыдущего определения позже.
<a name="IDX39"></a>
<a name="IDX40"></a>
Это выполняется с помощью встроенных макросов <code>pushdef</code> и <code>popdef</code>:
</p>

<pre>pushdef(<var>name</var> [, <var>expansion</var>])
popdef(<var>name</var>)
</pre>

<p>
которые очень подобны встроенным макросам <code>define</code> и <code>undefine</code>.
</p>


<p>
Работа этих макросов очень похожа на работу стека.

С помощью <code>pushdef</code> макросы переопределяются временно,
поскольку <code>pushdef</code> заменяет существующее определение имени <var>name</var>,
сохраняя предыдущее определение, перед тем как устанавливает новое.

Если предыдущее определение не существует, то поведение <code>pushdef</code>
подобно <code>define</code>.
</p>


<p>
Если макрос имеет несколько определений (из которых доступно только одно),
то самое последнее, "верхнее", определение может быть удалено с помощью <code>popdef</code>.

Если предидущего определения не существует, то поведение <code>popdef</code>
подобно <code>undefine</code>.
</p>

<pre>define(`foo', `Expansion one.')
=&gt;
foo
=&gt;Expansion one.
pushdef(`foo', `Expansion two.')
=&gt;
foo
=&gt;Expansion two.
popdef(`foo')
=&gt;
foo
=&gt;Expansion one.
popdef(`foo')
=&gt;
foo
=&gt;foo
</pre>

<p>
Если макрос имеет несколько определений и переопределение выполнялось с помощью <code>define</code>,
то последнее, "верхнее", определение <em>заменяется</em> новым определением.

Если определение удаляется с помощью <code>undefine</code>,
то удаляются <em>все</em> определения, а не только "верхнее".
</p>

<pre>define(`foo', `Expansion one.')
=&gt;
foo
=&gt;Expansion one.
pushdef(`foo', `Expansion two.')
=&gt;
foo
=&gt;Expansion two.
define(`foo', `Second expansion two.')
=&gt;
foo
=&gt;Second expansion two.
undefine(`foo')
=&gt;
foo
=&gt;foo
</pre>

<p>
Существует возможность временного переопределения встроенных макросов с помощью
<code>pushdef</code> и <code>defn</code>.
</p>


<p>
Макросы <code>pushdef</code> и <code>popdef</code> распознаются только при наличии параметров.
</p>


<h2><a name="SEC25" href="#TOC25">Косвенные вызовы макросов</a></h2>

<p>
<a name="IDX41"></a>
<a name="IDX42"></a>
<a name="IDX43"></a>
<a name="IDX44"></a>
<a name="IDX45"></a>
С помощью <code>indir</code> любой макрос можетбыть вызван косвенно:

</p>

<pre>indir(<var>name</var>, ...)
</pre>

<p>
что в результате приводит к вызову макроса с именем <var>name</var>,
которому передаются все оставшиеся аргументы.

Это может быть использовано для вызова макросов с "недопустимыми" именами
(<code>define</code> позволяет определять такие имена):
</p>

<pre>define(`$$internal$macro', `Internal macro (name `$0')')
=&gt;
$$internal$macro
=&gt;$$internal$macro
indir(`$$internal$macro')
=&gt;Internal macro (name $$internal$macro)
</pre>

<p>
Смысл заключается в том, что большие пакеты макросов могут иметь определения приватных макросов,
которые не должны быть вызваны каким-либо случайным образом.

Такие приватные макросы могут быть вызваны <em>только</em>
с помощью встроенного макроса <code>indir</code>.
</p>



<h2><a name="SEC26" href="#TOC26">Косвенные вызовы встроенных макросов</a></h2>

<p>
<a name="IDX46"></a>
<a name="IDX47"></a>
<a name="IDX48"></a>
<a name="IDX49"></a>
<a name="IDX50"></a>
Встроенные макросы могут быть вызваны косвенно с помощью <code>builtin</code>:
</p>

<pre>builtin(<var>name</var>, ...)
</pre>

<p>
что в результате приводит к вызову встроенного макроса с именем <var>name</var>,
которому передаются все оставшиеся аргументы.

Это может быть использовано когда имени <var>name</var>
дано другое определение которое скрывает оригинал.
</p>


<p>
Макрос <code>builtin</code> распознается только при наличии параметров.
</p>



<h1><a name="SEC27" href="#TOC27">Условия, циклы и рекурсия</a></h1>


<p>
Возможность использования макросов которые способны только расширяться в простой текст
не достаточна.

Нам необходима возможность выполнять различные расширения макросов,
в зависимости от условий, возникающих во время выполнения

Например, нам необходима возможность учитывать некоторые условия.

Кроме того, нам необходима возможность использования каких-либо циклических конструкций,
так, чтобы мы могли выполнять что-либо какое-то количество раз,
или пока какое-либо условие оценивается как истинное.
</p>



<h2><a name="SEC28" href="#TOC28">Проверка макро-определений</a></h2>


<p>
<a name="IDX51"></a>
<a name="IDX52"></a>
В <code>m4</code> существует два различных встроенных макроса
для обработки условий.
Первым из них является  <code>ifdef</code>:
</p>

<pre>ifdef(<var>name</var>, <var>string-1</var>, opt <var>string-2</var>)
</pre>

<p>
который предоставляет возможность проверять определен какой-либо макрос или нет.

Если имя <var>name</var> является определенным макросом,
то <code>ifdef</code> расширяется в строку <var>string-1</var>,
а в противном случае, в строку <var>string-2</var>.

Если <var>string-2</var> опущена, то полагается что ее значение - пустая строка
(что согласовано с нормальными правилами).
</p>

<pre>ifdef(`foo', ``foo' is defined', ``foo' is not defined')
=&gt;foo is not defined
define(`foo', `')
=&gt;
ifdef(`foo', ``foo' is defined', ``foo' is not defined')
=&gt;foo is defined
</pre>

<p>
Макрос <code>ifdef</code> распознается только при наличии параметров.
</p>



<h2><a name="SEC29" href="#TOC29">Сравнение строк</a></h2>

<p>
<a name="IDX53"></a>
<a name="IDX54"></a>
Другим, более мощным встроенным макросом, для обработки условий, является <code>ifelse</code>.

В зависимости от числа принимаемых аргументов,
он может быть использован как средсство вставки длинных комментариев,
как конструкция <b>if</b>-<b>else</b>
или как разветвитель:
</p>

<pre>ifelse(<var>comment</var>)
ifelse(<var>string-1</var>, <var>string-2</var>, <var>equal</var>, opt <var>not-equal</var>)
ifelse(<var>string-1</var>, <var>string-2</var>, <var>equal</var>, ...)
</pre>

<p>
При использовании только одного аргумента, <code>ifelse</code> просто отбрасывает аргумент
и не производит вывод.

Это общая идиома <code>m4</code> для вставки блока комментариев,
используемая как альтернатива использованию повторяющихся <code>dnl</code>.

Такое специальное использование распознается в GNU <code>m4</code>,
и, таким образом, никогда не вызывает предупреждения о нехватке аргументов.
</p>


<p>
Если <code>ifelse</code> вызывается с тремя или четырьмя аргументами,
то он будет расширяться в <var>equal</var>, когда строки <var>string-1</var> и <var>string-2</var>
равны. В противном случае, он расширяется в <var>not-equal</var>.
</p>

<pre>ifelse(foo, bar, `true')
=&gt;
ifelse(foo, foo, `true')
=&gt;true
ifelse(foo, bar, `true', `false')
=&gt;false
ifelse(foo, foo, `true', `false')
=&gt;true
</pre>

<p>
<a name="IDX55"></a>
Однако, <code>ifelse</code> способен принимать более четырех аргументов.

При предоставлении более четырех аргументов,
<code>ifelse</code> работает подобно инструкциям <code>case</code> или <code>switch</code>
традиционных языков программирования.

Если <var>string-1</var> и <var>string-2</var> равны, то <code>ifelse</code> расширяется
в <var>equal</var>.
В противном случае, процедура повторяется, а первые три аргумента отбрасываются.

Пример такого вызова:
</p>

<pre>ifelse(foo, bar, `third', gnu, gnats, `sixth', `seventh')
=&gt;seventh
</pre>

<p>
Обычно, вариант такого использования будет несколько сложнее этого примера.
Наиболее часто <code>ifelse</code> используется в макросах которые реализуют различные циклы.
</p>


<p>
Макрос <code>ifelse</code> распознается только при наличии параметров.
</p>


<h2><a name="SEC30" href="#TOC30">Циклы и рекурсия</a></h2>

<p>
<a name="IDX56"></a>
<a name="IDX57"></a>
<code>m4</code> не обладает непосредственной поддержкой циклов,
но макросы могут быть рекурсивными.

На глубину вложенности рекурсии не существует никаких ограничений,
кроме тех которые накладываются используемыми оборудованием и опрерационной системой.
</p>


<p>
<a name="IDX58"></a>
Циклы могут быть запрограммированы с помощью использования рекурсии
и средств обработки условий, которые были описаны ранее.
</p>


<p>
<a name="IDX59"></a>
Существует встроенный макрос <code>shift</code>, который, кроме прочего, может
быть использован для итерации фактических параметров макроса:
</p>

<pre>shift(...)
</pre>

<p>
Он принимает любое число аргументов и расширяется списком всех своих аргументов,
кроме первого отделенного запятой аргумента, с каждым аргументом заключенным в кавычки.
</p>

<pre>shift(bar)
=&gt;
shift(foo, bar, baz)
=&gt;bar,baz
</pre>

<p>
Примером использования <code>shift</code>, является макрос
который изменяет порядок следования его аргументов на противоположный:
</p>

<pre>define(`reverse', `ifelse($#, 0, , $#, 1, ``$1'',
			  `reverse(shift($@)), `$1'')')
=&gt;
reverse
=&gt;
reverse(foo)
=&gt;foo
reverse(foo, bar, gnats, and gnus)
=&gt;and gnus, gnats, bar, foo
</pre>

<p>
Хотя этот пример макроса не очень интересен, он показывает простой способ
создания цикла с помощью <code>shift</code>, <code>ifelse</code> и рекурсии.
</p>


<p>
<a name="IDX60"></a>
<a name="IDX61"></a>
<a name="IDX62"></a>
Рассмотрим простой пример циклического макроса <code>forloop</code>.
Он может быть применен, например, для простой организации счета:
</p>

<pre>forloop(`i', 1, 8, `i ')
=&gt;1 2 3 4 5 6 7 8
</pre>

<p>
<!---
The arguments are a name for the iteration variable, the starting value,
the final value, and the text to be expanded for each iteration.  

With this macro, the macro <CODE>i</CODE> is defined only within the loop.  

After the loop, it retains whatever value it might have had before.
--->
Аргументы имеют имя для итерационной переменной,
стартовое значение, конечное значение и текст для расширения в каждой итерации.

В этом макросе, макрос <code>i</code> описан только внутри цикла.

После итерации цикла, он сохраняет предшествующее значение.
</p>


<p>
Циклы могут быть вложенными, подобно
</p>

<pre>forloop(`i', 1, 4, `forloop(`j', 1, 8, `(i, j) ')
')
=&gt;(1, 1) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7) (1, 8)
=&gt;(2, 1) (2, 2) (2, 3) (2, 4) (2, 5) (2, 6) (2, 7) (2, 8)
=&gt;(3, 1) (3, 2) (3, 3) (3, 4) (3, 5) (3, 6) (3, 7) (3, 8)
=&gt;(4, 1) (4, 2) (4, 3) (4, 4) (4, 5) (4, 6) (4, 7) (4, 8)
=&gt;
</pre>

<p>
Реализация макроса цикла <code>forloop</code> очень проста.

Цикл <code>forloop</code> сам по себе является оберткой,
которая сохраняет предшествующее определение первого аргумента,
вызывает внутренний макрос <code>_forloop</code>
и переустанавливает сохраненное определение первого аргумента.
</p>


<p>
Макрос <code>_forloop</code> однократно расширяет четвертый аргумент
и проверяет условие завершения.

Если условие завершения не выполняется, то он инкрементирует итерационную переменную
(использование предопределенного макроса <code>incr</code>,
see см. секцию <a href="#SEC59">Декремент и инкремент</a>),
и выполняет следующую рекурсию.
</p>


<p>
Рассмотрим более реальную реализацию <code>forloop</code>:
</p>

<pre>define(`forloop',
       `pushdef(`$1', `$2')_forloop(`$1', `$2', `$3', `$4')popdef(`$1')')
define(`_forloop',
       `$4`'ifelse($1, `$3', ,
		   `define(`$1', incr($1))_forloop(`$1', `$2', `$3', `$4')')')
</pre>

<p>
Следует заметить, что при использовании кавычек требуется внимательность.

Только три макро-аргумента не заключены в кавычки,
и для каждого аргумента это имеет свой собственный смысл.

Попробуйте самостоятельно догадаться <em>почему</em> эти три аргумента
не заключены в кавычки, и что произойдет, если их поместить в кавычки.
</p>


<p>
Теперь, даже несмотря на то, что показанные макросы работоспособны,
они не совсем пригодны для повсеместного использования.

В них отсутствует даже базовая обработка ошибок в случаях когда
начальное значение меньше конечного значения,
или когда первый аргумент не является именем.

Исправление этих недостатков предоставляется читателю,
в качестве упражнения.
</p>




<h1><a name="SEC31" href="#TOC31">Как отлаживать макросы и ввод</a></h1>


<p>
При написании макросов для <code>m4</code>,
очень часто оказывается, что они работают не так как ожидается
(что свойственно многим языкам программирования).

Макропроцессор <code>m4</code> обеспечивает некоторую поддержку в отладке макросов.
</p>



<h2><a name="SEC32" href="#TOC32">Отображение макро-определений</a></h2>

<p>
<a name="IDX63"></a>
<a name="IDX64"></a>
<a name="IDX65"></a>
<a name="IDX66"></a>
Если необходимо увидеть во что расширяется какое-либо имя,
можно использовать встроенный макрос <code>dumpdef</code>:

</p>

<pre>dumpdef(...)
</pre>

<p>
который принимает любое число аргументов.

Если этот встроенный макрос вызван без указания аргументов,
то он отображает определения всех известных имен,
в противном случае, он отображает определения для указанных имен.

Вывод распечатывается непосредственно в стандартный вывод ошибок.
</p>


<p>
Встроенный макрос <code>dumpdef</code> имеет пустое (void) расширение.
</p>

<pre>define(`foo', `Hello world.')
=&gt;
dumpdef(`foo')
error--&gt;foo:	`Hello world.'
=&gt;
dumpdef(`define')
error--&gt;define:	&lt;define&gt;
=&gt;
</pre>

<p>
Последний пример показывает как отображаются определения встроенных макросов.
</p>


<p>
Для получения более подробной информации по управлению особенностями отображения
см. секцию <a href="#SEC34">Управление отладочным выводом</a>.
</p>


<h2><a name="SEC33" href="#TOC33">Трассировка макро-вызовов</a></h2>

<p>
<a name="IDX67"></a>
<a name="IDX68"></a>
<a name="IDX69"></a>
<a name="IDX70"></a>
<a name="IDX71"></a>
С помощью встроенных макросов <code>traceon</code> и <code>traceoff</code>,
предоставляется возможность трассировки макро-вызовов и макро-расширений:

</p>

<pre>traceon(...)
traceoff(...)
</pre>

<p>
Когда макросы <code>traceon</code> и <code>traceoff</code>
вызываются без указания каких-либо аргументов,
то они осуществляют, соответственно, включение (on) или выключение (off) трассировки
для всех определенных макросов.

Когда эти макросы вызываются с аргументами, то они затрагивают
только те макросы, имена которых были указаны при вызове.
</p>


<p>
Встроенный макросы <code>traceon</code> и <code>traceoff</code> имеют пустое (void) расширение.
</p>


<p>
Всякий раз, при вызове трассируемого макроса, после того как осуществлено накопление его аргументов,
производится отображение вызова.

Если расширение макро-вызова не пустое (void),
то расширение может быть отображено после вызова.

Вывод распечатывается непосредственно в стандартный вывод ошибок.
</p>

<pre>define(`foo', `Hello World.')
=&gt;
define(`echo', `$@')
=&gt;
traceon(`foo', `echo')
=&gt;
foo
error--&gt;m4trace: -1- foo -&gt; `Hello World.'
=&gt;Hello World.
echo(gnus, and gnats)
error--&gt;m4trace: -1- echo(`gnus', `and gnats') -&gt; ``gnus',`and gnats''
=&gt;gnus,and gnats
</pre>

<p>
Числа между дефисами отображают глубину вложенности расширения.

Каждый уровень вложенности упрощает расширение во внешнем уровне,
но уровень вложенности увеличивается когда аргументы содержат макро-вызовы не помещенные в кавычки.
</p>


<p>
Для получения дополнительной информации по управлению отображением
см. секцию <a href="#SEC34">Управление отладочным выводом</a>.
</p>


<h2><a name="SEC34" href="#TOC34">Управление отладочным выводом</a></h2>

<p>
<a name="IDX72"></a>
<a name="IDX73"></a>
Опция <samp>`-d'</samp> командной строки запуска <code>m4</code> управляет
степенью детализации отладочной информации,
когда используются описанные в предыдущей секции макросы.
</p>


<p>
В качестве флагов <var>flags</var>, сопровождающих эту опцию,
может быть один или более нижеперечисленных флагов:
</p>


<dl compact="compact">

<dt><code><b>t</b></code>
</dt><dd>
Трассировать все макро-вызовы в процессе текущего запуска <code>m4</code>.

</dd><dt><code><b>a</b></code>
</dt><dd>
Показывать все фактические аргументы каждого макро-вызова.
Это применяется для каждого макро-вызова если использован флаг <samp>`t'</samp>.
В противном случае, только для тех макросов, которые были указаны в вызовах <code>traceon</code>.

</dd><dt><code><b>e</b></code>
</dt><dd>
Показывать расширения для всех макросов, имеющих не пустые (void) расширения.
Это применяется для каждого макро-вызова если использован флаг <samp>`t'</samp>.
В противном случае, только для тех макросов, которые были указаны в вызовах <code>traceon</code>.

</dd><dt><code><b>q</b></code>
</dt><dd>
<!---
Quote actual arguments and macro expansions in the display with the current quotes.
--->
Отображение фактических аргументов и макро-расширений помещать в кавычки
вместе с их текущим размещением в кавычках.

</dd><dt><code><b>c</b></code>
</dt><dd>
Показывать трассировку в отдельных строках для каждого макро-вызова.

Первая строка отображается в момент обнаружения макроса,
но до того как произошло накопление его аргументов;
вторая строка отображается после того как произошло накопление аргументов;
третья строка отображается после того как вызов макроса завершен.

</dd><dt><code><b>x</b></code>
</dt><dd>
Добавить уникальный идентификатор макро-вызова (`macro call id')
к каждой строке вывода трассировки.
Это полезно при совместном использовании с флагом <samp><b>`c'</b></samp>.

</dd><dt><code><b>f</b></code>
</dt><dd>
Показывать имя текущего файла ввода в каждой строке вывода трассировки.

</dd><dt><code><b>l</b></code>
</dt><dd>
Показывать номер текущей строки ввода в каждой строке вывода трассировки.

</dd><dt><code><b>p</b></code>
</dt><dd>
Печатать сообщение когда указанный файл обнаружен с помощью механизма
поиска файла по заданному пути (path) поиска
(см. секцию <a href="#SEC44">Поиск включаемых файлов</a>), 
предоставляя фактически используемое имя файла.

</dd><dt><code><b>i</b></code>
</dt><dd>
Печатать сообщение при каждой смене текущего файла ввода,
предоставляя данное имя файла и номер строки ввода.

</dd><dt><code><b>V</b></code>
</dt><dd>
Краткая форма одновременного указания всех флагов сразу.
</dd></dl>

<p>
Если при указании опции <samp>`-d'</samp>,
то, по умолчанию, автоматически устанавливаются флаги <samp>`aeq'</samp>.

Показанные в двух предыдущих секциях примеры подразумевают использование
установки флагов по умолчанию.
</p>


<p>
<a name="IDX74"></a>
<a name="IDX75"></a>
Существует встроенный макрос <code>debugmode</code>,
который позволяет управлять формой отладочного вывода "на лету":
</p>

<pre>debugmode(opt <var>flags</var>)
</pre>

<p>
Аргумент <var>flags</var> должен быть подмножеством букв, перечисленных выше.

Как специальный случай, если аргумент начинается с <samp>`+'</samp>,
флаги добавляются к текущим флагам отладки <var>flags</var>,
и если аргумент начинается с <samp>`и'</samp>, то флаги удаляются.

Если аргументы не указаны, то отладочные флаги установлены в отсутствующие
(как будто опция <samp>`-d'</samp> не была указана),
и, наконец, при "пустом" аргументе, флаги устанавливаются в значение по умолчанию.
</p>


<h2><a name="SEC35" href="#TOC35">Сохранение отладочного вывода</a></h2>

<p>
<a name="IDX76"></a>
<a name="IDX77"></a>
<a name="IDX78"></a>
<a name="IDX79"></a>
<a name="IDX80"></a>
Отладочный и трассировочный вывод может быть перенаправлен в файлы
как с помощью использования опции <samp>`-o'</samp> командной строки <code>m4</code>,
так и с помощью использования встроенного макроса <code>debugfile</code>:
</p>

<pre>debugfile(opt <var>filename</var>)
</pre>

<p>
отправит весь последующий отладочный и трассировочный вывод в файл <var>filename</var>.

Если указано пустое имя файла <var>filename</var>,
то отладочный и трассировочный вывод будет отброшен,
а если макрос <code>debugfile</code> вызван без аргументов,
то отладочный и трассировочный вывод будет отправлен в стандартный вывод ошибок.
</p>


<h1><a name="SEC36" href="#TOC36">Управление вводом</a></h1>

<p>
Эта глава описывает различные встроенные макросы управляющие вводом <code>m4</code>.
</p>



<h2><a name="SEC37" href="#TOC37">Удаление пробелов из ввода</a></h2>

<p>
<a name="IDX81"></a>
<a name="IDX82"></a>
Встроенный макрос <code>dnl</code>,
вплоть до первого встреченного символа новой строки,
читает и отбрасывает все символы, включая символ новой строки:
</p>

<pre>dnl
</pre>

<p>
и он часто используется совместно с макросом <code>define</code>,
для удаления символов новой строки которые сопровождают вызов<code>define</code>.
Таким образом
</p>

<pre>define(`foo', `Macro `foo'.')dnl A very simple macro, indeed.
foo
=&gt;Macro foo.
</pre>

<p>
отбрасывает ввод, вплоть до символа новой строки, и включая символ новой строки,
что противоположно трактовке комментариев
(см. секцию <a href="#SEC11">Комментарии</a>).
</p>


<p>
Обычно, <code>dnl</code> немедленно сопровождается символом новой строки
или пробелами.

GNU <code>m4</code> генерирует предупреждающее сообщение
когда <code>dnl</code> сопровождается открытой скобкой.

В этом случае,<code>dnl</code> будет накапливать и обрабатывать все аргументы,
осуществляя поиск парной закрывающей скобки.

<!---
All predictable side effects resulting from this collection will take place.  
--->
При этом будут иметь место все предсказуемые побочные эффекты,
происходящие в результате такого накопления.

<code>dnl</code> не возвращает вывода.

<!---
The input following the matching close parenthesis up to and including the next newline, 
on whatever line containing it, will still be discarded.
--->
Ввод, последующий за парной закрывающей скобкой, вплоть до и включая символ новой строки
(на той строке где обнаружена парная скобка), будет отброшен.
</p>


<h2><a name="SEC38" href="#TOC38">Изменение символов кавычек</a></h2>

<p>
<a name="IDX83"></a>
<a name="IDX84"></a>
<a name="IDX85"></a>
Символы кавычек (иначе, символы цитирования), установленные по умолчанию,
могут быть заменены с помощью встроенного макроса <code>changequote</code>:
</p>

<pre>changequote(opt <var>start</var>, opt <var>end</var>)
</pre>

<p>
где <var>start</var> является новым ограничителем начала цитирования (стартовые кавычки),
а <var>end</var> является новым ограничителем завершения цитирования (завершающие кавычки).

Если любой из аргументов отсутствует,
то вместо отсутствующего аргумента используется соответствующий
символ по умолчанию (<code>`</code> или <code>'</code>).
</p>


<p>
Встроенный макрос <code>changequote</code> имеет пустое (void) расширение.
</p>

<pre>changequote([, ])
=&gt;
define([foo], [Macro [foo].])
=&gt;
foo
=&gt;Macro foo.
</pre>

<p>
Если односимвольные значения не желательны,
то <var>start</var> и <var>end</var> могут быть любой длины.
</p>

<pre>changequote([[, ]])
=&gt;
define([[foo]], [[Macro [[[foo]]].]])
=&gt;
foo
=&gt;Macro [foo].
</pre>

<p>
Изменение значений символов кавычек (цитирования) на пустые строки
будет эффективно блокировать механизм помещения в кавычки (цитирования),
не предоставляя способа поместить текст в кавычки (цитировать текст).
</p>

<pre>define(`foo', `Macro `FOO'.')
=&gt;
changequote(, )
=&gt;
foo
=&gt;Macro `FOO'.
`foo'
=&gt;`Macro `FOO'.'
</pre>

<p>
<!---
There is no way in <CODE>m4</CODE> to quote a string containing an unmatched left quote, 
except using <CODE>changequote</CODE> to change the current quotes.
--->
В <code>m4</code> не существует способа поместить строку в кавычки (цитировать строку)
используя какие-либо непарные отсутствующие кавычки,
кроме как использовать <code>changequote</code> для изменения текущих кавычек.
</p>


<p>
Никакая строка в кавычках не должна начинаться с буквы или символа подчеркивания <samp>`_'</samp>,
поскольку они будут смешиваться с именами во вводе.

Выполнение таких действий блокирует мехпнизм цитирования.
</p>


<h2><a name="SEC39" href="#TOC39">Изменение ограничителей комментариев</a></h2>

<p>
<a name="IDX86"></a>
<a name="IDX87"></a>
<a name="IDX88"></a>
Ограничители комментариев, принимаемые по умолчанию, могут быть заменены с помощью
встроенного макроса<code>changecom</code>:
</p>

<pre>changecom(opt <var>start</var>, opt <var>end</var>)
</pre>

<p>
где <var>start</var> является новым ограничителем начала комментария,
а <var>end</var> является новым ограничителем завершения комментария.

Если любой из аргументов  отсутствует,
то вместо отсутствующего аргумента используется соответствующий
символ по умолчанию (<code>`</code> и символ новой строки).

Ограничители комментариев могут быть любой длины.
</p>


<p>
Встроенный макрос <code>changecom</code> имеет пустое (void) расширение.
</p>

<pre>define(`comment', `COMMENT')
=&gt;
# A normal comment
=&gt;# A normal comment
changecom(`/*', `*/')
=&gt;
# Not a comment anymore
=&gt;# Not a COMMENT anymore
But: /* this is a comment now */ while this is not a comment
=&gt;But: /* this is a comment now */ while this is not a COMMENT
</pre>

<p>
<a name="IDX89"></a>
Примечательно, что комментарии копируются в вывод подобно строкам помещенным в кавычки.

Если необходимо выполнять расширение текста внутри комментария,
то можно поместить в кавычки ограничитель начала комментария.
</p>


<p>
Вызов макроса <code>changecom</code> без аргументов полностью блокирует механизм комментирования.
</p>

<pre>define(`comment', `COMMENT')
=&gt;
changecom
=&gt;
# Not a comment anymore
=&gt;# Not a COMMENT anymore
</pre>



<h2><a name="SEC40" href="#TOC40">Изменение лексической структуры слов</a></h2>

<p>
<a name="IDX90"></a>
<a name="IDX91"></a>
<a name="IDX92"></a>

</p><blockquote>
<p>
Макрос <code>changeword</code> и вся ассоциируемая с ним функциональность
является экспериментальными.

Все это доступно только в том случае, если при запуске скрипта <code>configure</code>,
в процессе инсталляции GNU <code>m4</code>,
была указана опция <code>--enable-changeword</code>.

Эта функциональность может быть изменена или даже удалена в будущем,
поэтому на нее не стоит полагаться.

Пожалуйста, направьте свои комментарии об этом по адресу,
которому необходимо отправлять сообщения об ошибках.
</p></blockquote>

<p>
Файл который будет обрабатываться <code>m4</code> разделен
на строки помещенные в кавычки,
слова (потенциальные имена макросов)
и простые токены (любые другие одиночные символы).

Изначально, любое слово описано с помощью следующего регулярного выражения:
</p>

<pre>[_a-zA-Z][_a-zA-Z0-9]*
</pre>

<p>
Используя <code>changeword</code>, вы можете изменить это регулярное выражение.

Ослабление лексических правил <code>m4</code> может быть полезно (например)
если вы хотите попытаться транслировать файл с числами:
</p>

<pre>changeword(`[_a-zA-Z0-9]+')
define(1, 0)
=&gt;1
</pre>

<p>
<!---
Tightening the lexical rules is less useful, because it will generally
make some of the builtins unavailable.  

You could use it to prevent accidental call of builtins, for example:
--->
Ужесточение лексических правил - менее полезно,
поскольку это, в основном, сделает некоторые встроенные макросы не доступными.

Вы могли бы использовать это для предотвращения непредвиденных вызовов
встроенных макросов, например:
</p>

<pre>define(`_indir', defn(`indir'))
changeword(`_[_a-zA-Z0-9]*')
esyscmd(foo)
_indir(`esyscmd', `ls')
</pre>

<p>
Поскольку <code>m4</code> конструирует свои слова посимвольно, то
существует ограничение на регулярные выражения,
которые могут быть переданы <code>changeword</code>.  

Таким образом, если ваше регулярное выражение принимает <samp>`foo'</samp>,
то оно должно также принимать <samp>`f'</samp> и <samp>`fo'</samp>.
</p>


<p>
<code>changeword</code> имеет другую функцию.

<!---
If the regular expression supplied contains any bracketed subexpressions, then text outside
the first of these is discarded before symbol lookup.  
--->
Когда принятое регулярное выражение содержит любые подвыражения в скобках,
тогда текст, за пределами первого из них, отбрасывается до поиска символа.

Таким образом:
</p>

<pre>changecom(`/*', `*/')
changeword(`#\([_a-zA-Z0-9]*\)')
#esyscmd(ls)
</pre>

<p>
<!---
<CODE>m4</CODE> now requires a <SAMP>`#'</SAMP> mark at the beginning of every macro invocation, 
so one can use <CODE>m4</CODE> to preprocess shell scripts 
without getting <CODE>shift</CODE> commands swallowed, 
and plain text without losing various common words.
--->
Теперь, <code>m4</code> требует метку <samp>`#'</samp> в начале каждого вызова макроса,
благодаря чему <code>m4</code> может быть использован для препроцессирования
shell-скриптов, без получения "проглатывания" команды <code>shift</code>,
и "плоского" текста, без потери различных общих слов.
</p>


<p>
Подстановка макросов<code>m4</code> базирована на тексте,
в то время как <code>TeX</code> базируется на токенах

<!---
<CODE>changeword</CODE> can throw this difference into relief.  
--->
<code>changeword</code> может изменить это различие.

Например, существует такая же идея представленная в <code>TeX</code> и в <code>m4</code>.

Сначала, версия <code>TeX</code>:
</p>

<pre>\def\a{\message{Hello}}
\catcode`\@=0
\catcode`\\=12
=&gt;@a
=&gt;@bye
</pre>

<p>
Теперь, версия <code>m4</code>:

</p>

<pre>define(a, `errprint(`Hello')')
changeword(`@\([_a-zA-Z0-9]*\)')
=&gt;@a
</pre>

<p>
В версии примера <code>TeX</code>, первая строка описывает макрос <code>a</code>
для печати сообщения <samp>`Hello'</samp>.

Вторая строка описывает <kbd>@</kbd>
для использования вместо <kbd>\</kbd>, как escape-символа.

Третья строка описывает <kbd>\</kbd> как нормально печатаемый символ, а не escape-символ.

Четвертая строка вызывает макрос <code>a</code>.

Таким образом, когда <code>TeX</code> выполняется на этом файле,
то он отображает сообщение <samp>`Hello'</samp>.
</p>


<p>
Когда версия примера <code>m4</code> пропускается через <code>m4</code>,
то это выводит <samp>`errprint(Hello)'</samp>.

<!---
The reason for this is that TeX does
lexical analysis of macro definition when the macro is <EM>defined</EM>.
--->
Смысл этого заключается в том, что <code>TeX</code>
выполняет лексический анализ макро-определения тогда, когда макрос <em>определен</em>.

<!---
<CODE>m4</CODE> just stores the text, postponing the lexical analysis until
the macro is <EM>used</EM>.
--->
<code>m4</code> выполняет только сохранение текста, откладывая лексический анализ
до момента использования макроса.
</p>


<p>
Вы должны заметить, что использование <code>changeword</code>
будет значительно замедлять <code>m4</code> (раз в семь).
</p>


<h2><a name="SEC41" href="#TOC41">Сохранение ввода</a></h2>

<p>
<a name="IDX93"></a>
<a name="IDX94"></a>
<a name="IDX95"></a>
Существует возможность сохранить некоторый текст до того как будет обнаружено
окончание нормального ввода.

Текст может быть сохранен, для того чтобы он был вновь прочитан <code>m4</code>
когда нормальный ввод будет исчерпан.

Эта особенность используется обычно для инициализации действий очистки перед нормальным выходом,
например, удаление временных файлов.
</p>


<p>
Для сохранения текста ввода, необходимо использовать встроенный макрос <code>m4wrap</code>:
</p>

<pre>m4wrap(<var>string</var>, ...)
</pre>

<p>
который сохраняет строку <var>string</var> и остальные аргументы в сохранном месте,
для того чтобы перечитать вновь, после достижения завершения ввода.
</p>

<pre>define(`cleanup', `This is the `cleanup' actions.
')
=&gt;
m4wrap(`cleanup')
=&gt;
This is the first and last normal input line.
=&gt;This is the first and last normal input line.
^D
=&gt;This is the cleanup actions.
</pre>

<p>
Сохраненный ввод перечитывается только когда будет обнаружено окончание нормального ввода
и при этом не будет использован встроенный макрос <code>m4exit</code>,
для выхода из <code>m4</code>.
</p>


<p>
Существует возможность вызвать из сохраненного текста <code>m4wrap</code>,
но тогда порядок, в котором будет перечитан сохраненный текст, - не определен.

Если <code>m4wrap</code> не использован рекурсивно,
то сохраненные части текста будут перечитаны в порядке,
противоположном порядку ихнего сохранения,
т.е. последний сохраненный читается первым
(LIFO--last in, first out).
</p>


<h1><a name="SEC42" href="#TOC42">Включение файлов</a></h1>

<p>
<a name="IDX96"></a>
<a name="IDX97"></a>

</p>
<p>
<code>m4</code> позволяет включать именованные файлы в любой точке ввода.
</p>



<h2><a name="SEC43" href="#TOC43">Включение именованых файлов</a></h2>

<p>
<a name="IDX98"></a>
<a name="IDX99"></a>
В <code>m4</code> существует два встроенных макроса для включения файлов:
</p>

<pre>include(<var>filename</var>)
sinclude(<var>filename</var>)
</pre>

<p>
Оба этих макроса позволяют <code>m4</code> прочитать именованный файл <var>filename</var>.

Когда будет достигнут конец файла, то ввод продолжится из предыдущего файла.
</p>


<p>
Расширением макросов <code>include</code> и <code>sinclude</code>, таким образом,
является содержимое файла <var>filename</var>.
</p>


<p>
Отсутствие указанного файла будет являться ошибкой.

Если, при отсутствии файлов, вы не хотите получать сообщения об ошибках,
то для включения файлов может быть использован макрос <code>sinclude</code>,
который расширяется в содержимое файла, если файл существует,
или ни во что не расширяется, когда файл отсутствует.
</p>

<pre>include(`no-such-file')
=&gt;
error--&gt;30.include:2: m4: Cannot open no-such-file: No such file or directory
sinclude(`no-such-file')
=&gt;
</pre>

<p>
Предположим, что файл с именем  <tt>`incl.m4'</tt> содержит следующие строки:


</p><pre>Include file start
foo
Include file end
</pre>

<p>
Обычно, включение файла используется для вставки содержимого файла внутрь потока ввода.

Содержимое файла будет прочитано <code>m4</code> и макро-вызовы,
расположенные в этом файле, будут расширены:
</p>

<pre>define(`foo', `FOO')
=&gt;
include(`incl.m4')
=&gt;Include file start
=&gt;FOO
=&gt;Include file end
=&gt;
</pre>

<p>
Факт того, что макросы <code>include</code> и <code>sinclude</code> расширяются в содержимое файла,
может быть использован для определения макросов которые оперируют на целых файлах.

Существует пример, который определяет макрос <samp>`bar'</samp>
для расширения содержимого <tt>`incl.m4'</tt>:
</p>

<pre>define(`bar', include(`incl.m4'))
=&gt;
This is `bar':  &gt;&gt;&gt;bar&lt;&lt;&lt;
=&gt;This is bar:  &gt;&gt;&gt;Include file start
=&gt;foo
=&gt;Include file end
=&gt;&lt;&lt;&lt;
</pre>

<p>
Такое использование макроса <code>include</code> не тривиально, 
поскольку файлы могут содержать строки в кавычках, запятые и скобки,
которые могут интерферировать со способом работы парсера <code>m4</code>.
</p>


<p>
Встроенные макросы <code>include</code> и <code>sinclude</code>
распознаются только в случае наличия аргументов.
</p>


<h2><a name="SEC44" href="#TOC44">Поиск включаемых файлов</a></h2>

<p>
<a name="IDX100"></a>
<a name="IDX101"></a>
<a name="IDX102"></a>
GNU <code>m4</code> позволяет, чтобы поиск включаемых файлов осуществлялся не только
в текущем рабочем каталоге, но и в других каталогах.
</p>


<p>
Если файл не найден в текущем каталоге, и имя файла не является абсолютным,
то поиск указанного файла будет осуществляться используя определенные пути поиска.

Сначала, поиск осуществляется в каталогах указываемых с помощью опции командной строки
<samp>`-I'</samp>, а порядок поиска определяется последовательностью
перечисления каталогов.

Затем, если установлена переменная окружения <samp>`M4PATH'</samp>,
которая содержит список каталогов поиска отделенных друг от друга символом точки с запятой,
то поиск осуществляется в соответствии с последовательностью перечисления каталогов
в этой переменной окружения.
</p>


<p>
Если автоматический поиск включаемых файлов вызывает проблемы,
то применение отладочного флага <samp>`p'</samp>
(см. секцию <a href="#SEC34">Управление отладочным выводом</a>)
может помочь изолировать проблему.
</p>


<h1><a name="SEC45" href="#TOC45">Перенаправление (diverting) и отмена перенаправления (undiverting) вывода</a></h1>

<p>
<!---
Diversions are a way of temporarily saving output.  

The output of <CODE>m4</CODE> can at any time be diverted to a temporary file, 
and be reinserted into the output stream, <EM>undiverted</EM>, again at a later time.
--->
Перенаправление (diversions) является способом временного сохранения вывода.

Вывод <code>m4</code> может быть перенаправлен (diverted) во временный файл
в любой момент времени, и вставлен заново в поток вывода,
путем отмены перенаправления (undiverted), в любой момент времени позже.
</p>


<p>
Нумерованные перенаправления (diversions) считаются от 0,
перенаправление (diversion) номер 0 является нормальным потоком вывода.

Число одновременных перенаправлений (diversions) ограничено в основном
размерами памяти используемой для их описания,
поскольку GNU <code>m4</code> пытается хранить перенаправления (diversions) в пямяти.

Однако, существует предел для общего использования памяти всеми перенаправлениями (diversions).
В настоящее время этот предел равен 512K.

При достижении этого максимума,
открывается временный файл для получения содержимого наибольшего перенаправления (diversion)
находящегося в памяти, и освобождения этой памяти для других перенаправлений (diversions).

Таким образом, теоретически возможно, что число перенаправлений (diversions)
будет лимитировано количеством доступных файловых дескрипторов.
</p>



<h2><a name="SEC46" href="#TOC46">Перенаправление (diverting) вывода</a></h2>

<p>
<a name="IDX103"></a>
<a name="IDX104"></a>
<a name="IDX105"></a>
<a name="IDX106"></a>
Перенаправление вывода осуществляется с помощью использования встроенного макроса
<code>divert</code>:
</p>

<pre>divert(opt <var>number</var>)
</pre>

<p>
где число <var>number</var> является перенаправлением (diversion)
которое будет использовано.

<!---
If <VAR>number</VAR> is left out, it is assumed to be zero.
--->
Если число <var>number</var> отсутствует, то подразумевается, что оно нуль.
</p>


<p>
Встроенный макрос <code>divert</code> имеет пустое (void) расширение.
</p>


<p>
Когда весь ввод <code>m4</code> будет обработан,
то все существующие перенаправления будут автоматически отменены (undiverted),
в соответствии с порядком нумерации.
</p>


<pre>divert(1)
This text is diverted.
divert
=&gt;
This text is not diverted.
=&gt;This text is not diverted.
^D
=&gt;
=&gt;This text is diverted.
</pre>

<p>
Последовательные вызовы <code>divert</code> с одним и тем же аргументом
не осуществляют перезапись перенаправленного (diverted) ранее текста,
а добавляют к нему текст.
</p>


<p>
Если вывод перенаправлен (diverted) в не существующее перенаправление (diversion),
то он просто отбрасывается.

Это может быть использовано для подавления нежелательного вывода.

Общим примером нежелательного вывода являются завершающие символы новой строки
после макро-определения.

Здесь показано как отменить их.
</p>

<pre>divert(-1)
define(`foo', `Macro `foo'.')
define(`bar', `Macro `bar'.')
divert
=&gt;
</pre>

<p>
Это является общей идиомой программирования в <code>m4</code>.
</p>


<h2><a name="SEC47" href="#TOC47">Отмена перенаправления (undiverting) вывода</a></h2>

<p>
<a name="IDX107"></a>
Отмена пренаправления текста может быть указана явно, с помощью встроенного
макроса <code>undivert</code>:
</p>

<pre>undivert(opt <var>number</var>, ...)
</pre>

<p>
который отменяет перенаправление в соответствии с указанными аргументами,
согласно порядка их указания.

Если аргументы не указаны, то осуществляется отмена всех перенаправлений,
в соответствии с порядком нумерации.
</p>


<p>
Встроенный макрос <code>undivert</code> имеет пустое (void) расширение.
</p>

<pre>divert(1)
This text is diverted.
divert
=&gt;
This text is not diverted.
=&gt;This text is not diverted.
undivert(1)
=&gt;
=&gt;This text is diverted.
=&gt;
</pre>

<p>
Примечательны две пустые строки.

Одна из них появляется из-за символа новой строки, следующей за макросом <code>undivert</code>,
а вторая - из-за символа новой строки, следующей за макросом <code>divert</code>!

Подобно этому, перенаправление часто начинается с пустой строки.
</p>


<p>
<!---
When diverted text is undiverted, it is <EM>not</EM> reread by <CODE>m4</CODE>,
but rather copied directly to the current output, and it is therefore
not an error to undivert into a diversion.
--->
Когда осуществляется отмена перенапраления перенаправленного текста,
перечитывание ввода <code>m4</code> <em>не</em> выолняется,
а перенаправленный текст непосредственно копируется в текущий вывод,
и, таким образом, нет ошибок отмены перенаправления внутри перенаправленного текста.
</p>


<p>
Когда осуществляется отмена перенапраления перенаправленного текста,
перенаправленный тект отбрасывается из-за чего нет возможности
использовать перенаправленный текст более одного раза.
</p>

<pre>divert(1)
This text is diverted first.
divert(0)undivert(1)dnl
=&gt;
=&gt;This text is diverted first.
undivert(1)
=&gt;
divert(1)
This text is also diverted but not appended.
divert(0)undivert(1)dnl
=&gt;
=&gt;This text is also diverted but not appended.
</pre>

<p>
Попытки отменить текущее перенаправление молчаливо игнорируются.
</p>


<p>
<a name="IDX108"></a>
<a name="IDX109"></a>
<a name="IDX110"></a>
GNU <code>m4</code> позволяет отменять перенаправление для именованных файлов.

Для данного не численного аргумента,
в текущий вывод будет скопировано без интерпретации содержимое именованного файла.

Это дополняет встроенный макрос <code>include</code>
(см. секцию <a href="#SEC43">Включение именованых файлов</a>).  

Для иллюстрации различий, предположим, что файл
<tt>`foo'</tt> содержит слово <samp>`bar'</samp>:
</p>

<pre>define(`bar', `BAR')
=&gt;
undivert(`foo')
=&gt;bar
=&gt;
include(`foo')
=&gt;BAR
=&gt;
</pre>



<h2><a name="SEC48" href="#TOC48">Нумерация перенаправлений (diversion)</a></h2>

<p>
<a name="IDX111"></a>
<a name="IDX112"></a>
Встроенный макрос <code>divnum</code>:
</p>

<pre>divnum
</pre>

<p>
расширяется в номер текущего перенаправления (diversion).
</p>

<pre>Initial divnum
=&gt;Initial 0
divert(1)
Diversion one: divnum
divert(2)
Diversion two: divnum
divert
=&gt;
^D
=&gt;
=&gt;Diversion one: 1
=&gt;
=&gt;Diversion two: 2
</pre>

<p>
Последний вызов макроса <code>divert</code> без аргументов необходим,
поскольку не перенаправленный (undiverted) текст будет иначе
перенаправлять (be diverted) сам себя.
</p>


<h2><a name="SEC49" href="#TOC49">Отброс перенаправленного (diverted) текста</a></h2>

<p>
<a name="IDX113"></a>
<a name="IDX114"></a>
Часто, когда вывод перенаправлен (diverted), не известно
будет-ли перенаправленный текст реально необходим.

Поскольку все не пустые перенаправления
возвращаются обратно в основной поток вывода
когда обнаружен конец ввода,
то неодходим метод для отбрасывания перенаправления (diversion).

Если все перенаправления (diversions) должны быть отброшены,
то проще всего завершить ввод  <code>m4</code>
вызовом <samp>`divert(-1)'</samp> который сопровождается
явным <samp>`undivert'</samp>:
</p>

<pre>divert(1)
Diversion one: divnum
divert(2)
Diversion two: divnum
divert(-1)
undivert
^D
</pre>

<p>
Не производится никакого вывода вообще.
</p>


<p>
Очистка выбранных перенаправлений (diversions) может быть выполнена следующими макросами:
</p>

<pre>define(`cleardivert',
`pushdef(`_num', divnum)divert(-1)undivert($@)divert(_num)popdef(`_num')')
=&gt;
</pre>

<p>
Вызов осуществляется подобно <code>undivert</code>,
но результатом будет очистка перенаправлений (diversions),
заданных аргументами.

<!---
(This macro has a nasty bug!  
You should try to see 
if you can find it and correct it.)
--->
(Этот макрос имеет одну мерзкую ошибку!
Вы должны попытаться увидеть
если вы обнаружили ее и скорректировали ее)
</p>


<h1><a name="SEC50" href="#TOC50">Макросы для обработки текста</a></h1>

<p>
В <code>m4</code> существует некоторое количество встроенных макросов
для осуществления разного рода манипуляций над текстом:
извлечение подстроки, поиск, замена и т.д.
</p>



<h2><a name="SEC51" href="#TOC51">Определение длины строки</a></h2>

<p>
<a name="IDX115"></a>
<a name="IDX116"></a>
<a name="IDX117"></a>
Длина строки может быть вычислена с помощью встроенного макроса <code>len</code>:
</p>

<pre>len(<var>string</var>)
</pre>

<p>
который расширяется в длину строки <var>string</var>, как десятичное число.
</p>

<pre>len()
=&gt;0
len(`abcdef')
=&gt;6
</pre>

<p>
Встроенный макрос <code>len</code> распознается только при наличии аргументов.
</p>


<h2><a name="SEC52" href="#TOC52">Поиск подстроки</a></h2>

<p>
<a name="IDX118"></a>
Поиск подстрок может быть осуществлен с помощью встроенного макроса <code>index</code>:
</p>

<pre>index(<var>string</var>, <var>substring</var>)
</pre>

<p>
который расширяется в индекс первого появления подстроки <var>substring</var>
в строке <var>string</var>.

Первый символ в строке <var>string</var> имеет индекс 0.

Если подстрока <var>substring</var> не обнаружена в строке <var>string</var>,
то макрос <code>index</code> расширяется в <samp>`-1'</samp>.
</p>

<pre>index(`gnus, gnats, and armadillos', `nat')
=&gt;7
index(`gnus, gnats, and armadillos', `dag')
=&gt;-1
</pre>

<p>
Встроенный макрос  <code>index</code> распознается только приналичии аргументов.
</p>


<h2><a name="SEC53" href="#TOC53">Поиск регулярного выражения</a></h2>

<p>
<a name="IDX119"></a>
<a name="IDX120"></a>
<a name="IDX121"></a>
Поиск регулярных выражений осуществляется с помощью встроенного макроса <code>regexp</code>:
</p>

<pre>regexp(<var>string</var>, <var>regexp</var>, opt <var>replacement</var>)
</pre>

<p>
который осуществляет поиск регулярного выражения <var>regexp</var> в строке <var>string</var>.

Для регулярных выражений используется такой же синтаксис как и в GNU Emacs.

Для более полной информации обратитесь к секции
"<i>Syntax of Regular Expressions</i>" в руководстве по GNU Emacs "<i>The GNU Emacs Manual</i>".
</p>


<p>
Если строка замены <var>replacement</var> опущена,
то макрос <code>regexp</code> расширяется в индекс
первого совпадения строки, заданной регулярным выражением <var>regexp</var>,
в строку <var>string</var>.

Если строка, заданная регулярным выражением <var>regexp</var>,
ни с чем не совпадает в строке <var>string</var>,
то макрос <code>regexp</code> расширяется в -1.
</p>

<pre>regexp(`GNUs not Unix', `\&lt;[a-z]\w+')
=&gt;5
regexp(`GNUs not Unix', `\&lt;Q\w*')
=&gt;-1
</pre>

<p>
Если строка замены <var>replacement</var> задана,
то макрос <code>regexp</code> заменяет расширение в значение этого аргумента
с <samp>`\<var>n</var>'</samp> подставленным вместо
текста совпадающего с <var>n</var>-м подвыражением строки замены <var>regexp</var>
заключенным в скобки.

Указание <samp>`\&amp;'</samp> соответствует всему тексту,
который совпадает с регулярным выражением <var>regexp</var>.
</p>

<pre>regexp(`GNUs not Unix', `\w\(\w+\)$', `*** \&amp; *** \1 ***')
=&gt;*** Unix *** nix ***
</pre>

<p>
Встроенный макрос <code>regexp</code> распознается только приналичии аргументов.
</p>


<h2><a name="SEC54" href="#TOC54">Извлечение подстроки</a></h2>

<p>
<a name="IDX122"></a>
<a name="IDX123"></a>
<a name="IDX124"></a>
Извлечение подстроки может быть осуществлено с помощью встроенного макроса <code>substr</code>:
</p>

<pre>substr(<var>string</var>, <var>from</var>, opt <var>length</var>)
</pre>

<p>
который расширяется в подстроку строки <var>string</var>,
которая начинается в индексе <var>from</var>,
и состоит из <var>length</var> символов,
или продолжается вплоть до конца строки <var>string</var>,
если параметр <var>length</var> отсутствует.

Начальный индекс строки всегда 0.
</p>

<pre>substr(`gnus, gnats, and armadillos', 6)
=&gt;gnats, and armadillos
substr(`gnus, gnats, and armadillos', 6, 5)
=&gt;gnats
</pre>

<p>
Встроенный макрос <code>substr</code> распознается только приналичии аргументов.
</p>


<h2><a name="SEC55" href="#TOC55">Трансляция символов</a></h2>

<p>
<a name="IDX125"></a>
<a name="IDX126"></a>
<a name="IDX127"></a>
Трансляция символов может быть выполнена с помощью встроенного макроса <code>translit</code>:
</p>

<pre>translit(<var>string</var>, <var>chars</var>, <var>replacement</var>)
</pre>

<p>
который расширяется в строку <var>string</var>,
при этом каждый символ строки <var>string</var>, который обнаружен в строке <var>chars</var>
транслируется в символ, с таким же индексом, из строки <var>replacement</var>.
</p>


<p>
Если строка <var>replacement</var> короче строки <var>chars</var>,
то лишние символы удаляются из расширения.

Если строка <var>replacement</var> не указана,
то все символы строки <var>string</var>,
которые присутствуют в строке <var>chars</var>
будут удалены из расширения.
</p>


<p>
Обе строки, <var>chars</var> и <var>replacement</var>,
могут содержать указания диапазонов символов,
напримен, <samp>`a-z'</samp> (подразумевая все символы латинского алфавита в нижнем регистре)
или <samp>`0-9'</samp> (подразумевая все цифры).

Для включения символа дефиса <samp>`-'</samp> в строку <var>chars</var>
или строку <var>replacement</var>, необходимо поместить его как первый или как последний
символ в строке.
</p>


<p>
Не будет ошибкой если последний символ, указанный в диапазоне, будет `больше' чем первый.

В этом случае, диапазон символов перечисляется в обратном порядке,
то есть <samp>`9-0'</samp> подразумевает строку <samp>`9876543210'</samp>.
</p>

<pre>translit(`GNUs not Unix', `A-Z')
=&gt;s not nix
translit(`GNUs not Unix', `a-z', `A-Z')
=&gt;GNUS NOT UNIX
translit(`GNUs not Unix', `A-Z', `z-a')
=&gt;tmfs not fnix
</pre>

<p>
Первый пример удаляет все символы верхнего регистра,
второй, преобразует символы нижнего регистра в символы верхнего регистра,
и третий, `отзеркаливает'  все символы верхнего регистра,
в процессе преобразования их в символы нижнего регистра.

Первые два случая более общие.
</p>


<p>
Встроенный макрос <code>translit</code> распознается только при наличии аргументов.
</p>


<h2><a name="SEC56" href="#TOC56">Подстановка текста с помощью регулярного выражения</a></h2>

<p>
<a name="IDX128"></a>
<a name="IDX129"></a>
<a name="IDX130"></a>
<a name="IDX131"></a>
<a name="IDX132"></a>
Глобальная замена в строке может быть выполнена с помощью встроенного макроса
<code>patsubst</code>:
</p>

<pre>patsubst(<var>string</var>, <var>regexp</var>, opt <var>replacement</var>)
</pre>

<p>
который осуществляет поиск совпадений регулярного выражения <var>regexp</var>
в строке <var>string</var> и осуществляет замену на строку <var>replacement</var>,
при каждом обнаруженном совпадении.

Для регулярных выражений используется такой же синтаксис как и в GNU Emacs.
</p>


<p>
Части строки <var>string</var>, которые не конвертированы в результате совпадения
с регулярным выражением <var>regexp</var>,
копируются в результат расширения.

При обнаружении каждого совпадения,
процесс поиска продолжается с конца совпадения,
таким образом, символ из строки <var>string</var>
никогда не будет подставлен дважды.

Если регулярное выражение <var>regexp</var> совпадает со строкой нулевой длины,
то начальная позиция для поиска инкрементируется,
во избежание бесконечных циклов.
</p>


<p>
После выполнения замены,
и вставки строки <var>replacement</var> в расширение,
осуществляется подстановка <samp>`\<var>n</var>'</samp> вместо
текста совпадающего с <var>n</var>-м подвыражением строки регулярного выражения <var>regexp</var>
заключенного в скобки.

Указание <samp>`\&amp;'</samp> соответствует всему тексту,
который совпадает с регулярным выражением <var>regexp</var>.
</p>


<p>
Строка <var>replacement</var> может отсутствовать.
В этом случае, текст, совпадающий со строкой <var>regexp</var>, будет удален.
</p>

<pre>patsubst(`GNUs not Unix', `^', `OBS: ')
=&gt;OBS: GNUs not Unix
patsubst(`GNUs not Unix', `\&lt;', `OBS: ')
=&gt;OBS: GNUs OBS: not OBS: Unix
patsubst(`GNUs not Unix', `\w*', `(\&amp;)')
=&gt;(GNUs)() (not)() (Unix)
patsubst(`GNUs not Unix', `\w+', `(\&amp;)')
=&gt;(GNUs) (not) (Unix)
patsubst(`GNUs not Unix', `[A-Z][a-z]+')
=&gt;GN not 
</pre>

<p>
Здесь показан более реалистичный пример,
котоорый осуществляет капитализацию (первый символ в верхнем регистре, а остальные - в нижнем)
слова или целой фразы,
заменяя вызововы макросов <code>upcase</code> и <code>downcase</code>
в строках.
</p>

<pre>define(`upcase', `translit(`$*', `a-z', `A-Z')')dnl
define(`downcase', `translit(`$*', `A-Z', `a-z')')dnl
define(`capitalize1',
     `regexp(`$1', `^\(\w\)\(\w*\)', `upcase(`\1')`'downcase(`\2')')')dnl
define(`capitalize',
     `patsubst(`$1', `\w+', `capitalize1(`\&amp;')')')dnl
capitalize(`GNUs not Unix')
=&gt;Gnus Not Unix
</pre>

<p>
Встроенный макрос <code>patsubst</code> распознается только при наличии аргументов.
</p>


<h2><a name="SEC57" href="#TOC57">Форматирование вывода</a></h2>

<p>
<a name="IDX133"></a>
<a name="IDX134"></a>
<a name="IDX135"></a>
<a name="IDX136"></a>
Форматирование вывода может быть выполнено с помощью встроенного макроса <code>format</code>:
</p>

<pre>format(<var>format-string</var>, ...)
</pre>

<p>
который работает подобно функции <code>printf</code> языка C.

Первый аргумент является форматируемой строкой,
которая может содержать <samp>`%'</samp> спецификации,
а расширением макроса <code>format</code> будет форматированная строка.
</p>


<p>
Использование этого встроенного макроса лучше всего пояснить на нескольких примерах:
</p>

<pre>define(`foo', `The brown fox jumped over the lazy dog')
=&gt;
format(`The string "%s" is %d characters long', foo, len(foo))
=&gt;The string "The brown fox jumped over the lazy dog" is 38 characters long
</pre>

<p>
Использование встроенного макроса <code>forloop</code> описывается в секции
<a href="#SEC30">Циклы и рекурсия</a>,
этот пример показывает как использовать макрос <code>format</code>
для получения табулированного вывода.
</p>

<pre>forloop(`i', 1, 10, `format(`%6d squared is %10d
', i, eval(i**2))')
=&gt;     1 squared is	    1
=&gt;     2 squared is	    4
=&gt;     3 squared is	    9
=&gt;     4 squared is	   16
=&gt;     5 squared is	   25
=&gt;     6 squared is	   36
=&gt;     7 squared is	   49
=&gt;     8 squared is	   64
=&gt;     9 squared is	   81
=&gt;    10 squared is	  100
</pre>

<p>
Встроенный макрос <code>format</code> смоделирован подобно функции <samp>`printf'</samp>
языка программирования ANSI C,
и он поддерживает обычные <samp>`%'</samp> спецификаторы:

<samp>`c'</samp>, <samp>`s'</samp>, <samp>`d'</samp>, <samp>`o'</samp>, <samp>`x'</samp>, 
<samp>`X'</samp>, <samp>`u'</samp>, <samp>`e'</samp>, <samp>`E'</samp> and <samp>`f'</samp>; 

он поддерживает указание ширин и точности полей, а также модификаторы

<samp>`+'</samp>, <samp>`-'</samp>, <samp>` '</samp>, <samp>`0'</samp>, 
<samp>`#'</samp>, <samp>`h'</samp> and <samp>`l'</samp>.  

Для получения информации, более детально описывающей функционирование <code>printf</code>,
следует обратиться к руководству по библиотеке языка программирования C.
</p>



<h1><a name="SEC58" href="#TOC58">Арифметические макросы</a></h1>

<p>
<a name="IDX137"></a>
<a name="IDX138"></a>
Целочисленная арифметика, включенная в <code>m4</code>,
использует C-подобный синтаксис.

Как согласованные сокращения,
существуют встроенные макросы для выполнения операций простого инкрементирования и декрементирования.
</p>



<h2><a name="SEC59" href="#TOC59">Декремент и инкремент</a></h2>

<p>
<a name="IDX139"></a>
<a name="IDX140"></a>
<a name="IDX141"></a>
<a name="IDX142"></a>
Инкремент и декремент целочисленных значений поддерживается использованием встроенных макросов
<code>incr</code> и <code>decr</code>:

</p>

<pre>incr(<var>number</var>)
decr(<var>number</var>)
</pre>

<p>
которые расширяются в соответственно инкрементированное или декрементированное на единицу
численное значение <var>number</var>.

</p>

<pre>incr(4)
=&gt;5
decr(7)
=&gt;6
</pre>

<p>
Встроенные макросы <code>incr</code> и <code>decr</code> распознаются только при наличии
аргументов.
</p>


<h2><a name="SEC60" href="#TOC60">Оценка значений целочисленных выражений</a></h2>

<p>
<a name="IDX143"></a>
<a name="IDX144"></a>
<a name="IDX145"></a>
<a name="IDX146"></a>
Целочисленные выражения могут быть оценены с помощью встроенного макроса <code>eval</code>:
</p>

<pre>eval(<var>expression</var>, opt <var>radix</var>, opt <var>width</var>)
</pre>

<p>
который расширяется в значение выражения <var>expression</var>.
</p>


<p>
Выражения могут содержать следующие знаки операций,
которые перечисляются в порядке уменьшения приоритета.
</p>
<dl compact="compact">

<dt><code>-</code>
</dt><dd>
Унарный минус
</dd><dt><code>**</code>
</dt><dd>
Возведение в степень
</dd><dt><code>*  /  %</code>
</dt><dd>
Умножение, деление и модуль
</dd><dt><code>+  -</code>
</dt><dd>
Сложение и вычитание
</dd><dt><code>&lt;&lt;  &gt;&gt;</code>
</dt><dd>
Сдвиг влево или вправо
</dd><dt><code>==  !=  &gt;  &gt;=  &lt;  &lt;=</code>
</dt><dd>
Операции отношения
</dd><dt><code>!</code>
</dt><dd>
Логическое отрицание
</dd><dt><code>~</code>
</dt><dd>
Побитное отрицание
</dd><dt><code>&amp;</code>
</dt><dd>
Побитное "И" ("AND")
</dd><dt><code>^</code>
</dt><dd>
Побитное "ИСКЛЮЧАЮЩЕЕ ИЛИ" ("XOR")
</dd><dt><code>|</code>
</dt><dd>
Побитное "ИЛИ" ("OR")
</dd><dt><code>&amp;&amp;</code>
</dt><dd>
Логическое "И" ("AND")
</dd><dt><code>||</code>
</dt><dd>
Логическое "ИЛИ" ("OR")
</dd></dl>

<p>
Все знаки операций, кроме возведения в степень, лево-ассоциированные.
</p>


<p>
Примечательно, что множество реализаций <code>m4</code>
используют <samp>`^'</samp> как альтернативный знак операции для возведения в степень,
в то время как множество других реализаций используют <samp>`^'</samp> как
побитное "ИСКЛЮЧАЮЩЕЕ ИЛИ" ("XOR").

GNU <code>m4</code> изменил его поведение:
раньше <samp>`^'</samp> использовался для возведения в степень,
а теперь - для вычисления побитного "ИСКЛЮЧАЮЩЕЕ ИЛИ" ("XOR").
</p>


<p>
Числа без специального префикса являются десятичными.

Простой префикс <samp>`0'</samp> указывает на то, что число восьмеричное.

<samp>`0x'</samp> указывает шестнадцатеричное число.
<samp>`0b'</samp> указывает двоичное число.
<samp>`0r'</samp> указывает число имеющего основание системы счисления от 1 до 36:
префикс немедленно сопровождается десятичным выражением указывающим основание системы счисления,
после которого следует двоеточие, а затем, цифры являющиеся числом.

Для любого основания системы счисления используются следующие цифры:
<samp>`0'</samp>, <samp>`1'</samp>, <samp>`2'</samp>, ....  
после <samp>`9'</samp>, цифрами являются
<samp>`a'</samp>, <samp>`b'</samp> ... вплоть до <samp>`z'</samp>.  

Буквы верхнего и нижнего регистра могут быть использованы взаимозаменяемо
в числах префикса и числах, префиксах и как цифры чисел.
</p>


<p>
При необходимости, для группирования подвыражений могут быть использованы скобки.

Операции отношения возвращают <code>1</code>, в случае результата "истина" (<code>True</code>),
и <code>0</code>, в случае результата "ложь" (<code>False</code>).
</p>


<p>
Здесь представлено несколько примеров использования встроенного макроса <code>eval</code>.
</p>

<pre>eval(-3 * 5)
=&gt;-15
eval(index(`Hello world', `llo') &gt;= 0)
=&gt;1
define(`square', `eval(($1)**2)')
=&gt;
square(9)
=&gt;81
square(square(5)+1)
=&gt;676
define(`foo', `666')
=&gt;
eval(`foo'/6)
error--&gt;51.eval:14: m4: Bad expression in eval: foo/6
=&gt;
eval(foo/6)
=&gt;111
</pre>

<p>
Второй особенностью, которую показывает последний пример,
является то, что встроенный макрос <code>eval</code> не обрабатывает макро-имена,
даже если они расширяются в допустивые выражения
(или часть допустимого выражения).

Следовательно, все макросы должны быть расширены до того как они будут переданы
макросу <code>eval</code>.
</p>


<p>
Если указано основание системы счисления <var>radix</var>,
то оно определяет основание системы счисления, используемое в расширении.

По умолчанию, основание системы счисления 10.

Результат <code>eval</code> всегда имеет знак.

Аргумент <var>width</var> специфицирует минимальную ширину вывода.

Результат дополняется нулями для дополнения текста расширения до требуемой ширины.
</p>

<pre>eval(666, 10)
=&gt;666
eval(666, 11)
=&gt;556
eval(666, 6)
=&gt;3030
eval(666, 6, 10)
=&gt;0000003030
eval(-666, 6, 10)
=&gt;-000003030
</pre>

<p>
Следует заметить, что основание системы счисления <var>radix</var>
не может быть больше чем 36.
</p>


<p>
Встроенный макрос <code>eval</code> распознается только при наличии аргументов.
</p>


<h1><a name="SEC61" href="#TOC61">Выполнение команд UNIX</a></h1>

<p>
<a name="IDX147"></a>
<a name="IDX148"></a>
<a name="IDX149"></a>
<a name="IDX150"></a>
Существует несколько встроенных макросов <code>m4</code> которые позволяют
запускать на выполнение команды UNIX из <code>m4</code>.
</p>



<h2><a name="SEC62" href="#TOC62">Выполнение простых команд</a></h2>

<p>
<a name="IDX151"></a>
Любая команда командного интерпритатора shell может быть выполнена
с помощью использования встроенного макроса <code>syscmd</code>:
</p>

<pre>syscmd(<var>shell-command</var>)
</pre>

<p>
который запускает на выполнение команду <var>shell-command</var>
как команду командного интерпритатора shell.
</p>


<p>
Встроенный макрос <code>syscmd</code> имеет пустое (void) расширение,
а <em>не</em> вывод команды <var>shell-command</var>!

Вывод или сообщения об ошибках команды <var>shell-command</var>
не читаются <code>m4</code> непосредственно.

См. секцию <a href="#SEC63">Чтение вывода команд</a> 
если вам необходимо обрабатывать вывод команды.
</p>


<p>
Перед запуском команды, <code>m4</code> "сбрасывает" свои буферы вывода.

По умолчанию, стандартный ввод, вывод и вывод ошибок для <var>shell-command</var>
являются теми же самыми, что и для <code>m4</code>.
</p>


<p>
Встроенный макрос <code>syscmd</code> распознается только при наличии аргументов.
</p>


<h2><a name="SEC63" href="#TOC63">Чтение вывода команд</a></h2>

<p>
<a name="IDX152"></a>
<a name="IDX153"></a>
Если необходимо прочитать вывод команды UNIX,
то необходимо использовать встроенный макрос
<code>esyscmd</code>:

</p>

<pre>esyscmd(<var>shell-command</var>)
</pre>

<p>
который расширяет стандартный вывод команды
командного интерпретатора <var>shell-command</var>.
</p>


<p>
Перед запуском команды, <code>m4</code> "сбрасывает" свои буферы вывода.

По умолчанию, стандартный ввод и вывод ошибок для <var>shell-command</var>
являются теми же самыми, что и для <code>m4</code>.

Вывод ошибок команды <var>shell-command</var>
не является частью расширения макроса:
он появляется как часть вывода ошибок <code>m4</code>.
</p>


<p>
Предположим, что вы находитесь в каталоге <tt>`checks'</tt>
дистрибутива GNU <code>m4</code>, тогда:
</p>

<pre>define(`vice', `esyscmd(grep Vice ../COPYING)')
=&gt;
vice
=&gt;  Ty Coon, President of Vice
=&gt;
</pre>

<p>
Примечательно, что расширение макроса <code>esyscmd</code> имеет сопровождающие
символы новой строки.
</p>


<p>
Встроенный макрос <code>esyscmd</code> распознается только при наличии аргументов.
</p>


<h2><a name="SEC64" href="#TOC64">Коды завершения</a></h2>

<p>
<a name="IDX154"></a>
<a name="IDX155"></a>
<a name="IDX156"></a>
<a name="IDX157"></a>
Для проверки результата завершения команды командного интерпретатора,
можно использовать встроенный макрос <code>sysval</code>:
</p>

<pre>sysval
</pre>

<p>
который расширяется в статус завершения последней выполненной
с помощью макроса <code>syscmd</code> или <code>esyscmd</code>
команды командного интерпретатора.
</p>

<pre>syscmd(`false')
=&gt;
ifelse(sysval, 0, zero, non-zero)
=&gt;non-zero
syscmd(`true')
=&gt;
sysval
=&gt;0
</pre>



<h2><a name="SEC65" href="#TOC65">Создание имен для временных файлов</a></h2>

<p>
<a name="IDX158"></a>
<a name="IDX159"></a>
<a name="IDX160"></a>
Крманды командного интерпретатора, которые запускаются с помощью встроенных макросов
<code>syscmd</code> и/или <code>esyscmd</code>,
могут нуждаться во временных файлах для вывода или каких-либо других нужд.

Существует встроенный макрос <code>maketemp</code>
позволяющий создавать имена для временных файлов:
</p>

<pre>maketemp(<var>template</var>)
</pre>

<p>
который расширяется в имя несуществующего файла,
созданного из строки <var>template</var>,
которая должна заканчиваться строкой <samp>`XXXXXX'</samp>.

Шесть символов <code>X</code> будет заменено,
как правило чем-либо включающим идентификатор процесса <code>m4</code>,
что позволяет создать уникальное имя файла.
</p>

<pre>maketemp(`/tmp/fooXXXXXX')
=&gt;/tmp/fooa07346
maketemp(`/tmp/fooXXXXXX')
=&gt;/tmp/fooa07346
</pre>

<p>
Как показано в примере, несколько вызовов макроса <code>maketemp</code>
может быть расширено в одну и ту же строку,
поскольку критерием выбора является существование файла.

Если файл не был создан до следующего вызова,
то два последовательных вызова могут быть расширены в одно и то же имя файла.
</p>


<p>
Встроенный макрос <code>maketemp</code> распознается только при наличии аргументов.
</p>


<h1><a name="SEC66" href="#TOC66">Различные встроенные макросы</a></h1>

<p>
Эта глава описывает различные встроенные макросы,
которые реально не могли принадлежать какой-либо из предыдущих глав.
</p>



<h2><a name="SEC67" href="#TOC67">Печать сообщений об ошибках</a></h2>

<p>
<a name="IDX161"></a>
<a name="IDX162"></a>
<a name="IDX163"></a>
<a name="IDX164"></a>
Сооьщения об ошибках могут быть напечатаны с помощью использования встроенного макроса
<code>errprint</code>:
</p>

<pre>errprint(<var>message</var>, ...)
</pre>

<p>
который просто печатает строку сообщения <var>message</var> и остальные аргументы
в стандартный вывод ошибок.
</p>

<p>
Встроенный макрос <code>errprint</code> имеет пустое (void) расширение.
</p>

<pre>errprint(`Illegal arguments to forloop
')
error--&gt;Illegal arguments to forloop
=&gt;
</pre>

<p>
Сопровождающие символы новой строки <em>не</em> печатаются автоматически,
таким образом, они должны обеспечиваться как часть аргумента,
как показано в примере выше.

(Клоны <code>m4</code> для BSD выполняют добавление сопровождающих символов новой строки
при каждом вызове макроса <code>errprint</code>).
</p>


<p>
Для обеспечения возможности определения места возникновения ошибки
существуют два полезных встроенных макроса:
</p>


<p>
<a name="IDX165"></a>
<a name="IDX166"></a>

</p><pre>__file__
__line__
</pre>

<p>
которые соответственно расширяются в помещенное в кавычки имя текущего файла ввода
и в номер строки, в этом файле.
</p>

<pre>errprint(`m4:'__file__:__line__: `Input error
')
error--&gt;m4:56.errprint:2: Input error
=&gt;
</pre>



<h2><a name="SEC68" href="#TOC68">Выход из <code>m4</code></a></h2>

<p>
<a name="IDX167"></a>
<a name="IDX168"></a>
Если необходимо выйти из <code>m4</code>, до того как будет прочитан весь ввод,
можно использовать встроенный макрос <code>m4exit</code>:
</p>

<pre>m4exit(opt <var>code</var>)
</pre>

<p>
который приводит к тому, что <code>m4</code> завершает свою работу
с кодом возврата <var>code</var>.

Если код возврата <var>code</var> не указан, то код возврата <code>m4</code> будет нуль.
</p>

<pre>define(`fatal_error', `errprint(`m4: '__file__: __line__`: fatal error: $*
')m4exit(1)')
=&gt;
fatal_error(`This is a BAD one, buster')
error--&gt;m4: 57.m4exit: 5: fatal error: This is a BAD one, buster
</pre>

<p>
После вызова этого макроса, <code>m4</code> завершит свою работу с кодом возврата 1.

Этот макрос предназначен только для выхода по ошибке,
поскольку нормальная процедура выхода, в этом случае, не выполняется,
например, не выполняется отмена перенаправления (undivert)
для перенаправленного (diverted) текста
и не выполняется перечитывание сохраненного текста
(См. секцию <a href="#SEC41">Сохранение ввода</a>).
</p>


<h1><a name="SEC69" href="#TOC69">Быстрая загрузка "замороженных" состояний</a></h1>

<p>
<a name="IDX169"></a>
<a name="IDX170"></a>
<a name="IDX171"></a>
<a name="IDX172"></a>
<a name="IDX173"></a>
<a name="IDX174"></a>
Некоторые большие приложения <code>m4</code> могут быть построены
на основе общей программной базы, которая содержит сотни различных определений
и множество дополнительных ресурсоемких инициализаций.

Обычно, такая общая база хранится в одном или нескольких файлах описаний,
которые перечисляются при каждом запуске <code>m4</code>
перед файлами ввода пользователя, или подключаются
в файлах ввода пользователя с помощью <code>include</code>.
</p>


<p>
Каждое повторное перечитывание общей базы большого приложения
может привести к большим затратам времени.

Для ускорения запуска приложений использующих объемную общую базу,
GNU <code>m4</code> предлагает некоторые вспомогательные механизмы.

Предположим, что пользователь постоянно повторяет использование:
</p>

<pre>m4 base.m4 input.m4
</pre>

<p>
с несколько изменяющимся содержимым файла <tt>`input.m4'</tt>,
но неизменным содержимым в файле <tt>`base.m4'</tt>.

Тогда, пользователю лучше один раз использовать:
</p>

<pre>m4 -F base.m4f base.m4
</pre>

<p>
а во всех последующих запусках использовать:
</p>

<pre>m4 -R base.m4f input.m4
</pre>

<p>
с различными изменениями ввода в <tt>`input.m4'</tt>.

Первый запуск <code>m4</code>, содержащий опцию <code>-F</code>,
осуществляет только чтение и обработку файла <tt>`base.m4'</tt>,
в котором выполняется определение различных макросов приложения и прочие вычисления,
необходимые для какой-либо общей начальной инициализации всего приложения.

После того как файл ввода <tt>`base.m4'</tt> будет полностью обработан,
GNU <code>m4</code> сгенерирует файл <tt>`base.m4f'</tt>, который называют
"<em>замороженным</em>" файлом, поскольку он содержит своеобразный образ
внутреннего состояния <code>m4</code> после обработки файла ввода <tt>`base.m4'</tt>.
</p>


<p>
Последующие запуски <code>m4</code>, содержащие опцию <code>-R</code>,
способны загрузить в память образ внутреннего состояния <code>m4</code>
после обработки файла ввода <tt>`base.m4'</tt> из файла <tt>`base.m4f'</tt>,
и это осуществляется <em>перед</em> тем как начать чтение любого другого файла ввода.

Такой подход подразумевает,
что вместо того чтобы каждый раз начинать обработку большого приложения
с выполнения повторной обработки одного и того же ввода <code>m4</code>,
ввод <code>m4</code> будет читаться только после восстановления состояния,
сохраненного в результате предыдущего запуска.

В нашем примере, после восстановления состояния из файла <tt>`base.m4f'</tt>,
эффект будет таким же самым как и после повторной обработки файла <tt>`base.m4'</tt>.

Однако, восстановление состояния из файла <tt>`base.m4f'</tt>
выполняется намного быстрее.
</p>


<p>
Только один "замороженный" файл может быть создан или прочитан
в результате одного запуска <code>m4</code>.

Нельзя осуществить восстановление внутреннего состояния <code>m4</code>
из двух "замороженных" файлов одновременно.

Однако,
"замороженные" файлы могут быть инкрементно обновлены
с помощью совместного последовательного использования опций
<code>-R</code> и <code>-F</code>.

Например, команда запуска <code>m4</code>:
</p>

<pre>m4 file1.m4 file2.m4 file3.m4 file4.m4
</pre>

<p>
может быть разделена на следующую последовательность запусков <code>m4</code>,
накапливающую одинаковый вывод:
</p>

<pre>m4 -F file1.m4f file1.m4
m4 -R file1.m4f -F file2.m4f file2.m4
m4 -R file2.m4f -F file3.m4f file3.m4
m4 -R file3.m4f file4.m4
</pre>

<p>
При этом необходима определенная осторожность,
поскольку не во всех абсолютно случаях
подобная попытка будет выполняться одинаково корректно.

В частности, не обрабатываются атрибуты трассировки макросов
и не обрабатываются текущие установки для <code>changeword</code>.

Также, взаимодействие некоторых опций <code>m4</code>,
которое использовалось при одном запуске и не используемое для следующего запуска,
в настоящий момент еще полностью не проанализировано.

С другой стороны,
вы должны быть уверены в том, что стек определений <code>pushdef</code>
обрабатывается корректно,
а это затрагивает <code>undefine</code> или переименование встроенных макросов,
а также изменение вида строк для кавычек и комментариев.
</p>


<p>
Когда какой-либо запуск <code>m4</code> "заморожен",
то запрещена автоматическая отмена перенаправления (undiversion),
которая осуществляется в конце обработки.

Вместо этого,
все позитивно нумерованные перенаправления (diversions)
сохраняются в "замороженном" файле.

Передается также номер активного перенаправления (diversion).
</p>


<p>
Загружаемый "замороженный" файл не обязан находиться в текущем каталоге.

Его поиск осуществляется также как и поиск включаемых,
с помощью <code>include</code>, файлов
(См. секцию <a href="#SEC44">Поиск включаемых файлов</a>).
</p>


<p>
"Замороженные" файлы могут быть общими для целой архитектуры.

Не будет опасно записать "замороженный" файл на одной машине и прочитать его на другой машине,
подразумевая, что вторая машина использует ту же самую
или более новую версию GNU <code>m4</code>.

Существуют простые (редактируемые) текстовые файлы,
состоящие из директив,
каждый из которых начинается с прописной (большой) буквы и заканчивается
символом новой строки
(<kbd>NL</kbd>).  

В любом месте, где ожидается появление директивы,
символ <kbd>#</kbd> вставляет строку комментария,
пустые строки - игнорируются.

В следующем описании,
длина <var>length</var> всегда ссылается на соответствующую строку <var>string</var>.

Все числа представлены как десятичные.

Директивами являются:
</p>


<dl compact="compact">

<dt><code>V <var>number</var> <kbd>NL</kbd></code>
</dt><dd>
Подтверждает формат файла. <var>number</var> должно быть 1.

</dd><dt><code>C <var>length1</var> , <var>length2</var> <kbd>NL</kbd> <var>string1</var> <var>string2</var> <kbd>NL</kbd></code>
</dt><dd>
Использовать строку <var>string1</var> и строку <var>string2</var>
как строки начала и конца комментария.

</dd><dt><code>Q <var>length1</var> , <var>length2</var> <kbd>NL</kbd> <var>string1</var> <var>string2</var> <kbd>NL</kbd></code>
</dt><dd>
Использовать строку <var>string1</var> и строку <var>string2</var>
как строки начала и конца кавычек (цитирования).

</dd><dt><code>F <var>length1</var> , <var>length2</var> <kbd>NL</kbd> <var>string1</var> <var>string2</var> <kbd>NL</kbd></code>
</dt><dd>
Определяет, с помощью <code>pushdef</code>, определение для строки <var>string1</var>
как расширяющееся в функцию, которая имеет имя встроенного макроса как строку <var>string2</var>.

</dd><dt><code>T <var>length1</var> , <var>length2</var> <kbd>NL</kbd> <var>string1</var> <var>string2</var> <kbd>NL</kbd></code>
</dt><dd>
Определяет, с помощью <code>pushdef</code>, определение для строки <var>string1</var>
как расширяющееся в текст, который указан как строка <var>string2</var>.

</dd><dt><code>D <var>number</var>, <var>length</var> <kbd>NL</kbd> <var>string</var> <kbd>NL</kbd></code>
</dt><dd>
Выбирает перенаправление (diversion) <var>number</var> как текущее,
после чего копирует строку <var>string</var> в текущее перенаправление.

Число <var>number</var> может быть отрицательным числом,
для не существующего перенаправления.

Для единственного специфицирования активного выбора,
используйте эту команду с пустой строкой <var>string</var>.

При указании перенаправления (diversion) <var>number</var> как 0,
строка <var>string</var> будет выдана в стандартный вывод во время перезагрузки,
однако, это может быть не выполнено изнутри <code>m4</code>.
</dd></dl>



<h1><a name="SEC70" href="#TOC70">Совместимость с другими версиями <code>m4</code></a></h1>

<p>
<a name="IDX175"></a>
Эта глава описывает различия между этой реализацией <code>m4</code>
и реализацией <code>m4</code> в системе UNIX, в частности, System V,
Release 3.
</p>


<p>
Существуют также отличия от клонов <code>m4</code> для BSD.
Здесь не делается попытка обобщить эти отличия.
</p>



<h2><a name="SEC71" href="#TOC71">Расширения в GNU <code>m4</code></a></h2>

<p>
<a name="IDX176"></a>
Эта версия <code>m4</code> содержит несколько свойств,
которые отсутствуют в версии <code>m4</code> для System V.

Все эти дополнительные свойства могут быть подавлены
с помощью использования опции командной строки <samp>`-G'</samp>,
если она не будет отвергнута другими опциями командной строки.
</p>

<ul>
<li>
При использовании <code>$</code><var>n</var> нотации для макро-аргументов,
<var>n</var> может состоять из нескольки цифр,
в то время как версия <code>m4</code> для System V
допускает использование только одной цифры.

Это позволяет макросам в GNU <code>m4</code> принимать любое число аргументов,
а не только девять
(См. секцию <a href="#SEC20">Аргументы для макроса</a>).

</li><li>
Поиск файлов, включаемых с помощью использования <code>include</code> и <code>sinclude</code>,
осуществляется в путях поиска, определяемых пользователем,
если они отсутствуют в текущем рабочем каталоге.

Пути поиска определяются с помощью опции командной строки <samp>`-I'</samp>
и содержимым переменной окружения <samp>`M4PATH'</samp>
(См. секцию <a href="#SEC44">Поиск включаемых файлов</a>).

</li><li>
Аргументы макроса <code>undivert</code> могут быть не числовыми,
в таком случае, именованный файл будет включен в вывод без какой-либо интерпретации
(См. секцию <a href="#SEC47">Отмена перенаправления (undiverting) вывода</a>).

</li><li>
Поддержка форматированного вывода осуществляется с помощью встроенного макроса <code>format</code>,
работа которого спроектирована подобно функции <code>printf</code> библиотеки языка C
(См. секцию <a href="#SEC57">Форматирование вывода</a>).

</li><li>
Поиск и подстановка (замена) текста осуществляется с помощью встроенных макросов <code>regexp</code> 
(См. секцию <a href="#SEC53">Поиск регулярного выражения</a>) и <code>patsubst</code>
(См. секцию <a href="#SEC56">Подстановка текста с помощью регулярного выражения</a>).

</li><li>
Вывод команд командного интерпретатора shell может быть прочитан в<code>m4</code>
с помощью встроенного макроса <code>esyscmd</code>
(См. секцию <a href="#SEC63">Чтение вывода команд</a>).

</li><li>
С помощью использования встроенного макроса <code>builtin</code>,
существует косвенный доступ к любому встроенному макросу
(См. секцию <a href="#SEC26">Косвенные вызовы встроенных макросов</a>).

</li><li>
Макросы могут быть вызваны косвенно с помощью встроенного макроса <code>indir</code>
(См. секцию <a href="#SEC25">Косвенные вызовы макросов</a>).

</li><li>
Имя текущего файла ввода и текущий номер строки ввода может быть получен
с помощью встроенных макросов <code>__file__</code> и <code>__line__</code>
(См. секцию <a href="#SEC67">Печать сообщений об ошибках</a>).

</li><li>
С помощью встроенного макроса <code>dumpdef</code>,
можно управлять форматом вывода,
а с помощью встроенного макроса <code>debugmode</code>
можно управлять отладочной трассировкой макросов
(См. секцию <a href="#SEC34">Управление отладочным выводом</a>).

</li><li>
С помощью встроенного макроса <code>debugfile</code>,
можно управлять назначением вывода трассировки и отладки
(См. секцию <a href="#SEC35">Сохранение отладочного вывода</a>).
</li></ul>

<p>
В дополнение к перечисленным выше расширениям, GNU <code>m4</code>
реализовывает следующие опции командной строки:
<samp>`-F'</samp>, <samp>`-G'</samp>, <samp>`-I'</samp>,
<samp>`-L'</samp>, <samp>`-R'</samp>, <samp>`-V'</samp>, <samp>`-W'</samp>, <samp>`-d'</samp>,
<samp>`-l'</samp>, <samp>`-o'</samp> and <samp>`-t'</samp>.  

Действие этих опций описывается в секции
<a href="#SEC4">Запуск <code>m4</code></a>.
</p>


<p>
Кроме того, стоит заметить, что отладочные и трассировочные способности GNU <code>m4</code>
более обширны, по сравнению с другими версиями <code>m4</code>.
</p>


<h2><a name="SEC72" href="#TOC72">Возможности версии <code>m4</code> для System V, отсутствующие в GNU <code>m4</code></a></h2>

<p>
Версия <code>m4</code> для System V содержит некоторые особенности,
которые еще не реализованы в версии GNU <code>m4</code>.
</p>

<ul>
<li>
Версия <code>m4</code> для System V поддерживает множество аргументов для встроенного макроса
<code>defn</code>.

Это не реализовано в версии GNU <code>m4</code>.

Полезность такой особенности для меня не очень очевидна.
</li></ul>



<h2><a name="SEC73" href="#TOC73">Прочие несовместимости</a></h2>

<p>
Существует еще несколько несовместимостей между этой реализацией <code>m4</code>
и версией <code>m4</code> для System V.
</p>

<ul>
<li>
Версия GNU <code>m4</code>,
при перенаправлении (divertion) текста,
реализует синхронизацию строк отлично от версии <code>m4</code> для System V.

GNU <code>m4</code> выводит строки синхронизации в момент перенаправления (divert) текста,
в то время как версия <code>m4</code> для System V выводит строки синхронизации в момент
отмены перенаправления (undivert) текста.

Проблемой является то,
какие строки и имена файлов будут прикреплены к тексту
который был или будет перенаправлен (diverted).

Версия <code>m4</code> для System V полагает, что весь перенаправленный (diverted) текст
сгенерирован из исходной строки содержащей вызов <code>undivert</code>,
в то время как версия GNU <code>m4</code> полагает, что весь перенаправленный (diverted) текст
сгенерирован в момент перенаправления (divert).

Я ожидаю, что опция строки синхронизации должна, в основном, использоваться
когда <code>m4</code> используется как препроцессор какого-либо компилятора.

<!---
If a diverted line causes a compiler error,
the error messages should most probably refer to the place where the
diversion were made, 
and not where it was inserted again.
--->
Если перенаправленная (diverted) строка приводит к ошибке компилятора,
то сообщение об ошибке, в основном, будет относиться к тому месту где было выполнено перенаправление,
а не к месту где строка была вставлена.


</li><li>
<!---
GNU <CODE>m4</CODE> makes no attempt at prohiting autoreferential definitions like:
--->
Версия GNU <code>m4</code> не делает попытки запретить
автоссылающиеся определения вида:



<pre>define(`x', `x')
define(`x', `x ')
</pre>

По существу, нет ничего плохого в определении того, что <samp>`x'</samp> будет возвращать
<samp>`x'</samp>.

Плохой вещью является то, что <samp>`x'</samp> будет расширяться без кавычек.

В <code>m4</code>,
кто-то может использовать макросы для хранения строк,
также как это делается для переменных в других языках программирования,
для дальнейшей их проверки с помощью:


<pre>ifelse(defn(`<var>holder</var>'), `<var>value</var>', ...)
</pre>


В случаях подобных этому,
запрещение содержать собственное имя для макроса
будет бесполезным ограничением.

<!---
Of course, this leave more rope for the GNU <CODE>m4</CODE> user to hang himself!  
--->
Конечно, это предоставляет для пользователей GNU <code>m4</code>
веревку для "подвешивания" самих себя!

При более тщательном программировании, можно избежать пересканирование "зависаний",
несколько подобно тому как это делается для бесконечных циклов
при традиционном программировании.

</li><li>

<a name="IDX177"></a>
GNU <code>m4</code> без опции <samp>`-G'</samp> будет определять,
что макро <code>__gnu__</code> будет расширен в пустую строку.


<a name="IDX178"></a>
В системах UNIX,
GNU <code>m4</code> без опции <samp>`-G'</samp> будет определять макрос <code>__unix__</code>,
в другом случае - макрос <code>unix</code>.

Оба макроса расширяются в пустую строку.
</li></ul>


<!---
<H1><A NAME="SEC74" HREF="#TOC74">Concept index</A></H1>

<P>
Jump to:
<A HREF="#cindex_a">a</A>
-
<A HREF="#cindex_b">b</A>
-
<A HREF="#cindex_c">c</A>
-
<A HREF="#cindex_d">d</A>
-
<A HREF="#cindex_e">e</A>
-
<A HREF="#cindex_f">f</A>
-
<A HREF="#cindex_g">g</A>
-
<A HREF="#cindex_i">i</A>
-
<A HREF="#cindex_l">l</A>
-
<A HREF="#cindex_m">m</A>
-
<A HREF="#cindex_n">n</A>
-
<A HREF="#cindex_o">o</A>
-
<A HREF="#cindex_p">p</A>
-
<A HREF="#cindex_q">q</A>
-
<A HREF="#cindex_r">r</A>
-
<A HREF="#cindex_s">s</A>
-
<A HREF="#cindex_t">t</A>
-
<A HREF="#cindex_u">u</A>
-
<A HREF="#cindex_w">w</A>
<P>
<H2><A NAME="cindex_a">a</A></H2>
<DIR>
<LI><A HREF="#IDX24">Аргументы для макроса</A>
<LI><A HREF="#IDX14">arguments to macros</A>
<LI><A HREF="#IDX28">arguments to macros, special</A>
<LI><A HREF="#IDX17">arguments, quoted macro</A>
<LI><A HREF="#IDX137">arithmetic</A>
</DIR>
<H2><A NAME="cindex_b">b</A></H2>
<DIR>
<LI><A HREF="#IDX48">builtins, indirect call of</A>
</DIR>
<H2><A NAME="cindex_c">c</A></H2>
<DIR>
<LI><A HREF="#IDX47">call of builtins, indirect</A>
<LI><A HREF="#IDX42">call of macros, indirect</A>
<LI><A HREF="#IDX86">changing comment delimiters</A>
<LI><A HREF="#IDX83">changing the quote delimiters</A>
<LI><A HREF="#IDX126">characters, translating</A>
<LI><A HREF="#IDX5">command line, filenames on the</A>
<LI><A HREF="#IDX4">command line, macro definitions on the</A>
<LI><A HREF="#IDX1">command line, options</A>
<LI><A HREF="#IDX156">commands, exit code from UNIX</A>
<LI><A HREF="#IDX150">commands, running UNIX</A>
<LI><A HREF="#IDX87">comment delimiters, changing</A>
<LI><A HREF="#IDX11">comments</A>
<LI><A HREF="#IDX89">comments, copied to output</A>
<LI><A HREF="#IDX53">comparing strings</A>
<LI><A HREF="#IDX175">compatibility</A>
<LI><A HREF="#IDX51">conditionals</A>
<LI><A HREF="#IDX72">controlling debugging output</A>
<LI><A HREF="#IDX62">counting loops</A>
</DIR>
<H2><A NAME="cindex_d">d</A></H2>
<DIR>
<LI><A HREF="#IDX73">debugging output, controlling</A>
<LI><A HREF="#IDX77">debugging output, saving</A>
<LI><A HREF="#IDX139">decrement operator</A>
<LI><A HREF="#IDX21">defining new macros</A>
<LI><A HREF="#IDX65">definitions, displaying macro</A>
<LI><A HREF="#IDX30">deleting macros</A>
<LI><A HREF="#IDX81">deleting whitespace in input</A>
<LI><A HREF="#IDX113">discarding diverted text</A>
<LI><A HREF="#IDX63">displaying macro definitions</A>
<LI><A HREF="#IDX111">diversion numbers</A>
<LI><A HREF="#IDX114">diverted text, discarding</A>
<LI><A HREF="#IDX103">diverting output to files</A>
<LI><A HREF="#IDX172">dumping into frozen file</A>
</DIR>
<H2><A NAME="cindex_e">e</A></H2>
<DIR>
<LI><A HREF="#IDX162">error messages, printing</A>
<LI><A HREF="#IDX144">evaluation, of integer expressions</A>
<LI><A HREF="#IDX147">executing UNIX commands</A>
<LI><A HREF="#IDX154">exit code from UNIX commands</A>
<LI><A HREF="#IDX167">exiting from <CODE>m4</CODE></A>
<LI><A HREF="#IDX19">expansion of macros</A>
<LI><A HREF="#IDX69">expansion, tracing macro</A>
<LI><A HREF="#IDX145">expressions, evaluation of integer</A>
<LI><A HREF="#IDX122">extracting substrings</A>
</DIR>
<H2><A NAME="cindex_f">f</A></H2>
<DIR>
<LI><A HREF="#IDX169">fast loading of frozen files</A>
<LI><A HREF="#IDX96">file inclusion</A>, <A HREF="#IDX109">file inclusion</A>
<LI><A HREF="#IDX6">filenames, on the command line</A>
<LI><A HREF="#IDX105">files, diverting output to</A>
<LI><A HREF="#IDX159">files, names of temporary</A>
<LI><A HREF="#IDX60">forloops</A>
<LI><A HREF="#IDX133">formatted output</A>
<LI><A HREF="#IDX170">frozen files for fast loading</A>
</DIR>
<H2><A NAME="cindex_g">g</A></H2>
<DIR>
<LI><A HREF="#IDX25">GNU extensions</A>, <A HREF="#IDX44">GNU extensions</A>, <A HREF="#IDX49">GNU extensions</A>, <A HREF="#IDX74">GNU extensions</A>, <A HREF="#IDX79">GNU extensions</A>, <A HREF="#IDX102">GNU extensions</A>, <A HREF="#IDX108">GNU extensions</A>, <A HREF="#IDX120">GNU extensions</A>, <A HREF="#IDX131">GNU extensions</A>, <A HREF="#IDX135">GNU extensions</A>, <A HREF="#IDX153">GNU extensions</A>, <A HREF="#IDX174">GNU extensions</A>, <A HREF="#IDX176">GNU extensions</A>
</DIR>
<H2><A NAME="cindex_i">i</A></H2>
<DIR>
<LI><A HREF="#IDX101">included files, search path for</A>
<LI><A HREF="#IDX97">inclusion, of files</A>, <A HREF="#IDX110">inclusion, of files</A>
<LI><A HREF="#IDX140">increment operator</A>
<LI><A HREF="#IDX46">indirect call of builtins</A>
<LI><A HREF="#IDX41">indirect call of macros</A>
<LI><A HREF="#IDX171">initialization, frozen states</A>
<LI><A HREF="#IDX7">input tokens</A>
<LI><A HREF="#IDX94">input, saving</A>
<LI><A HREF="#IDX138">integer arithmetic</A>
<LI><A HREF="#IDX143">integer expression evaluation</A>
</DIR>
<H2><A NAME="cindex_l">l</A></H2>
<DIR>
<LI><A HREF="#IDX115">length of strings</A>
<LI><A HREF="#IDX90">lexical structure of words</A>
<LI><A HREF="#IDX58">loops</A>
<LI><A HREF="#IDX61">loops, counting</A>
</DIR>
<H2><A NAME="cindex_m">m</A></H2>
<DIR>
<LI><A HREF="#IDX3">macro definitions, on the command line</A>
<LI><A HREF="#IDX68">macro expansion, tracing</A>
<LI><A HREF="#IDX12">macro invocation</A>
<LI><A HREF="#IDX13">macros, arguments to</A>, <A HREF="#IDX23">macros, arguments to</A>
<LI><A HREF="#IDX64">macros, displaying definitions</A>
<LI><A HREF="#IDX18">macros, expansion of</A>
<LI><A HREF="#IDX20">macros, how to define new</A>
<LI><A HREF="#IDX29">macros, how to delete</A>
<LI><A HREF="#IDX33">macros, how to rename</A>
<LI><A HREF="#IDX43">macros, indirect call of</A>
<LI><A HREF="#IDX16">macros, quoted arguments to</A>
<LI><A HREF="#IDX57">macros, recursive</A>
<LI><A HREF="#IDX27">macros, special arguments to</A>
<LI><A HREF="#IDX36">macros, temporary redefinition of</A>
<LI><A HREF="#IDX163">messages, printing error</A>
<LI><A HREF="#IDX55">multibranches</A>
</DIR>
<H2><A NAME="cindex_n">n</A></H2>
<DIR>
<LI><A HREF="#IDX9">names</A>
</DIR>
<H2><A NAME="cindex_o">o</A></H2>
<DIR>
<LI><A HREF="#IDX2">options, command line</A>
<LI><A HREF="#IDX104">output, diverting to files</A>
<LI><A HREF="#IDX134">output, formatted</A>
<LI><A HREF="#IDX78">output, saving debugging</A>
</DIR>
<H2><A NAME="cindex_p">p</A></H2>
<DIR>
<LI><A HREF="#IDX129">pattern substitution</A>
<LI><A HREF="#IDX161">printing error messages</A>
</DIR>
<H2><A NAME="cindex_q">q</A></H2>
<DIR>
<LI><A HREF="#IDX84">quote delimiters, changing the</A>
<LI><A HREF="#IDX15">quoted macro arguments</A>
<LI><A HREF="#IDX10">quoted string</A>
</DIR>
<H2><A NAME="cindex_r">r</A></H2>
<DIR>
<LI><A HREF="#IDX56">recursive macros</A>
<LI><A HREF="#IDX38">redefinition of macros, temporary</A>
<LI><A HREF="#IDX119">regular expressions</A>, <A HREF="#IDX128">regular expressions</A>
<LI><A HREF="#IDX173">reloading a frozen file</A>
<LI><A HREF="#IDX34">renaming macros</A>
<LI><A HREF="#IDX148">running UNIX commands</A>
</DIR>
<H2><A NAME="cindex_s">s</A></H2>
<DIR>
<LI><A HREF="#IDX76">saving debugging output</A>
<LI><A HREF="#IDX93">saving input</A>
<LI><A HREF="#IDX100">search path for included files</A>
<LI><A HREF="#IDX26">special arguments to macros</A>
<LI><A HREF="#IDX116">strings, length of</A>
<LI><A HREF="#IDX130">substitution by regular expression</A>
<LI><A HREF="#IDX123">substrings, extracting</A>
</DIR>
<H2><A NAME="cindex_t">t</A></H2>
<DIR>
<LI><A HREF="#IDX158">temporary filenames</A>
<LI><A HREF="#IDX37">temporary redefinition of macros</A>
<LI><A HREF="#IDX8">tokens</A>
<LI><A HREF="#IDX67">tracing macro expansion</A>
<LI><A HREF="#IDX125">translating characters</A>
</DIR>
<H2><A NAME="cindex_u">u</A></H2>
<DIR>
<LI><A HREF="#IDX31">undefining macros</A>
<LI><A HREF="#IDX155">UNIX commands, exit code from</A>
<LI><A HREF="#IDX149">UNIX commands, running</A>
</DIR>
<H2><A NAME="cindex_w">w</A></H2>
<DIR>
<LI><A HREF="#IDX91">words, lexical structure of</A>
</DIR>

</P>


<H1><A NAME="SEC75" HREF="#TOC75">Macro index</A></H1>

<P>
References are exclusively to the places where a builtin is introduced
the first time.  Names starting and ending with <SAMP>`__'</SAMP> have these
characters removed in the index.

</P>
<P>

<P>
Jump to:
<A HREF="#findex_b">b</A>
-
<A HREF="#findex_c">c</A>
-
<A HREF="#findex_d">d</A>
-
<A HREF="#findex_e">e</A>
-
<A HREF="#findex_f">f</A>
-
<A HREF="#findex_g">g</A>
-
<A HREF="#findex_i">i</A>
-
<A HREF="#findex_l">l</A>
-
<A HREF="#findex_m">m</A>
-
<A HREF="#findex_p">p</A>
-
<A HREF="#findex_r">r</A>
-
<A HREF="#findex_s">s</A>
-
<A HREF="#findex_t">t</A>
-
<A HREF="#findex_u">u</A>
<P>
<H2><A NAME="findex_b">b</A></H2>
<DIR>
<LI><A HREF="#IDX50">builtin</A>
</DIR>
<H2><A NAME="findex_c">c</A></H2>
<DIR>
<LI><A HREF="#IDX88">changecom</A>
<LI><A HREF="#IDX85">changequote</A>
<LI><A HREF="#IDX92">changeword</A>
</DIR>
<H2><A NAME="findex_d">d</A></H2>
<DIR>
<LI><A HREF="#IDX80">debugfile</A>
<LI><A HREF="#IDX75">debugmode</A>
<LI><A HREF="#IDX142">decr</A>
<LI><A HREF="#IDX22">define</A>
<LI><A HREF="#IDX35">defn</A>
<LI><A HREF="#IDX106">divert</A>
<LI><A HREF="#IDX112">divnum</A>
<LI><A HREF="#IDX82">dnl</A>
<LI><A HREF="#IDX66">dumpdef</A>
</DIR>
<H2><A NAME="findex_e">e</A></H2>
<DIR>
<LI><A HREF="#IDX164">errprint</A>
<LI><A HREF="#IDX152">esyscmd</A>
<LI><A HREF="#IDX146">eval</A>
</DIR>
<H2><A NAME="findex_f">f</A></H2>
<DIR>
<LI><A HREF="#IDX165">file</A>
<LI><A HREF="#IDX136">format</A>
</DIR>
<H2><A NAME="findex_g">g</A></H2>
<DIR>
<LI><A HREF="#IDX177">gnu</A>
</DIR>
<H2><A NAME="findex_i">i</A></H2>
<DIR>
<LI><A HREF="#IDX52">ifdef</A>
<LI><A HREF="#IDX54">ifelse</A>
<LI><A HREF="#IDX98">include</A>
<LI><A HREF="#IDX141">incr</A>
<LI><A HREF="#IDX118">index</A>
<LI><A HREF="#IDX45">indir</A>
</DIR>
<H2><A NAME="findex_l">l</A></H2>
<DIR>
<LI><A HREF="#IDX117">len</A>
<LI><A HREF="#IDX166">line</A>
</DIR>
<H2><A NAME="findex_m">m</A></H2>
<DIR>
<LI><A HREF="#IDX168">m4exit</A>
<LI><A HREF="#IDX95">m4wrap</A>
<LI><A HREF="#IDX160">maketemp</A>
</DIR>
<H2><A NAME="findex_p">p</A></H2>
<DIR>
<LI><A HREF="#IDX132">patsubst</A>
<LI><A HREF="#IDX39">popdef</A>
<LI><A HREF="#IDX40">pushdef</A>
</DIR>
<H2><A NAME="findex_r">r</A></H2>
<DIR>
<LI><A HREF="#IDX121">regexp</A>
</DIR>
<H2><A NAME="findex_s">s</A></H2>
<DIR>
<LI><A HREF="#IDX59">shift</A>
<LI><A HREF="#IDX99">sinclude</A>
<LI><A HREF="#IDX124">substr</A>
<LI><A HREF="#IDX151">syscmd</A>
<LI><A HREF="#IDX157">sysval</A>
</DIR>
<H2><A NAME="findex_t">t</A></H2>
<DIR>
<LI><A HREF="#IDX71">traceoff</A>
<LI><A HREF="#IDX70">traceon</A>
<LI><A HREF="#IDX127">translit</A>
</DIR>
<H2><A NAME="findex_u">u</A></H2>
<DIR>
<LI><A HREF="#IDX32">undefine</A>
<LI><A HREF="#IDX107">undivert</A>
<LI><A HREF="#IDX178">unix</A>
</DIR>

</P>
<P><HR><P>
--->


<!---
</blockquote>
--->


</body></html>