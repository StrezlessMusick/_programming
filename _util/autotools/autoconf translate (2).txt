!!! стараться избегать абсолютных путей
установленное - доступно по имени, и ищется через PATH
то, что собираем - все пути - относительно текущего каталога
!!! даешь понятные make-файлы, т.к. это часть исходного кода, а мало кто любит, когда исходный код генерируется кодогенераторами

./configure для определения необходимых ДЛЯ СБОРКИ компиляторов, интерпретаторов и установленных библиотек
	и создания make-файла с целями all и clean, и всеми оставшимися целями, КОТОРЫЕ ВЫЗЫВАЮТ install (но ни как ни automake/autoconf)
		(а люди будут писать только makefile.in)
	а также запускает install ТОЛЬКО для проверки наличия необходимого ДЛЯ РАБОТЫ ПО (перед сборкой)
./install - скрипт, проверяющий (если не было проверено ранее) необходимые ДЛЯ РАБОТЫ интерпретаторы и библиотеки
	знающий, где лежат собранные файлы, и куда в систему их устанавливать (по умолчанию, или --prefix , ...)
	и при этом собственно устанавливающий или тестирующий программу на месте
	а также создающий файл с данными, что, куда было установлено
	а также, в зависимости от того, какой пакетный менеджер установлен в системе, регистрирующий им все установленное
	а также, способный удалить все собранное и все исходники и оставить только uninstall и файл с данными, что, куда было установлено, 
		и makefile в котором останется работающая цель make uninstall
./uninstall - скрипт, читающий файл с данными, что, куда было установлено, и удаляющий это
	если программа была установлена пекетным менджером - то им и удаляет
	иначе - зависимости НЕ проверяются

вообще лучше создать папку (checkconfig) с тестирующими скриптами (кодогенерируемыми по отдельности) и configure.ac, 
а все стартовые скрипты сделать постоянными а не кодогенерируемыми
и по хорошему, их лучше иметь как установленные в системе, а не копировать в каждый пакет, но это случиться не скоро, да и их размер не большой
=======================================
== стр2 ==
unix -> posix
=== 3й абзац ===
могу -> могут
=== перед пакетом metaconfig ===
>> condemn - осуждать, приговаривать
>> reinvent ~~ invent
>> poor - бедный, плохой
Те, кто на понимает autoconf - вынуждены изобрести его заного.
Главная цель autoconf - сделать жизнь пользователя проще; сделать жизнь разработчика проще - вторичная цель
>> put another way - иначе говоря
Иначе говоря, менее главная цель сделать генерацию configure для разработчика пакета 
(также заполнение этой ниши приветствуется, т.к. разработчики пакетов формируют пользовательскую базу autoconf);
по сравнению с целью сделать configure безболезненным, портабельным и предсказуемым для конечных пользователей для каждого ~автопроизвольного~ пакета
>> to this degree - до такой степени
Autoconf до такой степени успешен в этой цели, что
>> complaint - жалоба
большинство жалоб на autoconf приходятся на сложность написания входных файлов для него, а не на поведение созданного configure.
Даже пакеты, которые не используют autoconf, вынуждены предоставлять configure скрипт, и болььшинство жалоб на эти альтернативные самодельные скрипты
являются тем, что они не соответствуют одному или более GNU coding standards, которые пользователи ожидают получить от сгенерированного autoconf скрипта configure.
=== последний абзац заменить на: ===
Autoconf не решает все проблемы, возникающие при создании портабельных пакетов - 
для более полного решения он должен использоваться совместно с другими средствами сборки GNU,
такими как automake и libtool.
Эти средства берут на себя работу, такукю как создание портабельных рекурсивных make-файлов со всеми стандартными целями,
линковку разделяемых библиотек и т.д.
см. Главу 2 [GNU система сборки], стр.3
== стр.3 ==
=== 2й абзац ===
#ifdef -> #if
см. раздел B3 [индекс символов препроцессора]
=== абзац 3 ===
Autoconf требует GNU m4 версии 1,4,6 или более для создания скриптов.
Он использует возможности, которые некоторые версии m4 (включая 1,3) не используют.
Autoconf лучше всего работает с версией GNU m4 1,4,14 и более, так что они не требуются.(???)



См. раздел 18.5 [Autoconf 1], стр.318, где описано обновление с версии 1.
См. главу 21 [История], стр.351, Где описана история разработки autoconf.
См. главу 20 [FAQ], стр.341, где даются ответы не некоторые общие вопросы, касательно Autoconf.

См. [[веб страницу Autoconf]] где дается свежая информация, детали списков рассылки,
списки известных багов и т.д..

Присылайте предложения на [[список рассылки autoconf]]. Предыдущие предложения находятся в [[архиве]].

Присылайте bug report-ы на [[список рассылки Autoconf Bugs]]. Предыдущие баги можно найти в [[архиве]].

По возможности, сначала проверьте, что ваш баг не решен в современной версии, и что онем еще не сообщили.
Убедитесь, что включили всю необходиму информацию и короткий ‘configure.ac’ который демонстрирует проблему.

Исходники autoconf доступны через git; см. детали в [[Autoconf Summary]] или см. [[текущий репозиторий]].
Также доступен анонимный доступ через CVS, см. детали в ‘README’.
Патчи, соответствующие текущей версии на git могу быть посланы на просмотр в 
[[список рассылки Autoconf Patches]], где дискуссии о предыдущих патчах [[архивированы]];
и все коммиты постятся на [[списке рассылке (который только для чтения) Autoconf Commit]], который также имеет [[архив]].

Т.к. это его миссия, сам пакет autoconf содержит только набор часто используемых макросов, что уже демонстрирует его полезность.
Тем не менее, если вы хотите поделиться вашим макросом, или найти существующий, см. [[Autoconf Macro Archive]], который любезно содержиться [[Peter-ом Simons-ом]].

== стр.3 система сборки GNU ==
>> reliable - надежный
Autoconf решает важную задачу — надежно исследует системно-зависимую информацию для сборки и запуска — 
но это только одна часть паззла для разработки портабельного ПО.
В связи с этим, проект GNU разработал набор интегрированных утилит чтобы завершить работу, начатую autoconf:
систему сборки GNU, наиболее известными компонентами которой являются Autoconf, Automake, и Libtool.
Эта глава является введением в эти средства, указывает на источники дополнительной информации,
и попытается убедить вас использовать GNU build system для вашего ПО.
>> convince - убеждать

== 2.1 Automake ==
>> ubiquity - вездесущность
>> viable - жизнеспособный
Вездесущность make ознаяает, что только make-файл является жизнеспособюным способом распространять правила автоматической сборки для ПО,
но у него обнаруживается множество ограничений.
Its lack of support for automatic dependency tracking, recursive builds in subdirectories,
reliable timestamps (e.g., for network file systems), and so on,
mean that developers must painfully (and often incorrectly) reinvent the wheel for each project.
Portability is nontrivial, thanks to the quirks of make on many systems.
On top of all this is the manual labor required to implement the many standard targets
that users have come to expect (make install, make distclean, make uninstall, etc.).
Since you are, of course, using Autoconf, you also have to insert repetitive code in your ‘Makefile.in’ to recognize @CC@,
@CFLAGS@, and other substitutions provided by configure. Into this mess steps Automake.
