Содержание
1 About the GNU Coding Standards 		1
2 удержание свободног ПО свободным	.	1
2.1 Упоминание проприетарных программ		2
2.2 Принятие вкладов				2
2.3 Торговые марки				3
3 общий дизайн программ	.	.	.	3
3.1 Какие языки использовать			3
3.2 Совместимость с другими реализациями 	4
3.3 Использование нестандартных возможностей	4
3.4 Standard C and Pre-Standard C		5
3.5 условная компиляция 			6
4 Поведение программ для всех программ 		6
4.1 стандарты Non-GNU 	.	.	.	7
4.2 написание надежных программ			7
4.3 поведение билиотек 				9
4.4 форматирование сообщений об ошибках		9
4.5 общие стандарты для интерфейсов 		10
4.6 стандарты для графических интерфейсов	11
4.7 стандарты для интерфейсов командной строки 	11
4.7.1 --version 				11
4.7.2 --help					14
4.8 стандарты для динамически-подключаемых интерфейсов	14
4.9 таблица длинных опций 			14
4.10 OID Allocations 				30
4.11 использование памяти			31
4.12 использование файлов			32
5 Making The Best Use of C 	.	.	32
5.1 форматирование вашего исходного кода	32
5.2 комментирование вашей работы		34
5.3 чистое использвание конструкций си		35
5.4 именование переменных, функций и файлов	37
5.5 переносимость между системными типами	38
5.6 переносимость между процессорами		39
5.7 использование системных функций		40
5.8 интернационализация				40
5.9 набор символов				42
5.10 символы цитирования			42
5.11 Mmap 					43
6 Документирование программ	.	.	43
6.1 GNU мануалы					43
6.2 Doc Strings and Manuals			45
6.3 детали структуры мануалов			45
6.4 лицнзия для мануалов			45
6.5 Manual Credits 				46
6.6 печатаемые мануалы 				46
6.7 The NEWS File 				46
6.8 Change Logs 				46
6.8.1 Change Log Concepts 			46
6.8.2 Style of Change Logs 			47
6.8.3 Simple Changes 				48
6.8.4 Conditional Changes 			49
6.8.5 Indicating the Part Changed 		49
6.9 Man Pages 					50
6.10 чтение других мануалов			50
7 Процесс выпуска	.	.	.	50
7.1 как должно работать конфигурирование	51
7.2 соглашения Makefile				53
7.2.1 общие соглашения для Makefile-ов	 	53
7.2.2 Утилиты в Makefile-ах			55
7.2.3 переменные для специфицирования команд	55
7.2.4 DESTDIR: поддержка поэтапных установок	56
7.2.5 переменные для директорий инсталляции 	57
7.2.6 Стандартные цели для пользователей	62
7.2.7 категории команд установки		67
7.3 Создание релизов				68
8 справка для НЕ-свободного ПО и документации	70
Appendix A GNU Free Documentation License	71
Index 						79
==============================================================
== 7 процесс выпуска ==
Создание релиза - это нечто большее чем запаковка исходных файлов в tar-файл и выкладывание его на ftp.
Вы должны настроить ваше ПО так, что бы оно могло быть сконфигурировано для запуска на различных системах.
Ваш makefile должен соответствовать стандартам, описанным ниже,
и ваша модель директорий также должна соответствовать стандартам, описанным ниже.
Это делает более простым включение вашего пакета в более крупную структуру ПО GNU.

=== 7.1 Как должно работать конфигурирование ===
Каждый выпуск должен идти с shell-скриптом, называемым configure. 
Этот скрипт принимает аргументы, которые описывают тип машины и системы, для которой вы хотите скомпилировать программу.
Configure-скрипт должен записать конфигурационные опции так, чтобы они повлияли на компиляцию.

Это описание является спецификацией интерфейса скрипта configure в пакетах GNU.
Многие пакеты реализуют это с использованием GNU Autoconf и/или GNU Automake, но вы не обязаны ими пользоваться.
Вы можете реализовать это любым понравившимся способом; например чтобы после применения configure был враппер вокруг полностью различных конфигураций систем.

(?)Другой путь для работы скрипта configure это создание ссылки со стандартным именем, таким как config.h, на соответствующий конфигурационный файл для выбранной системы.
Если вы используете эту технику, дистрибутив не должен содержать файла с названием config.h.
Это так для того, что бы люди не смогли собрать программу без предварительного конфигурирования.

Другая вещь, которую может делать configure, это редактированиеи Makefile-а.
Если вы делаете так, ваш дистрибутив не должен содержать файла с именем Makefile.
Вместо этого он должен содержать файл Makefile.in, который содержит ввод для редактирования.
Опять же это значит, что люди не смогут собрать программу без предварительного конфигурирования.

Если configure создает Makefile, то Makefile должен содержать цель с названием Makefile, которая заставляет configure вернуться и установить соответствующую конфигурацию, которая была установлена в последнее время (?).
Файлы, которые confugure читает, должны быть перечислены в зависимостях целиMalefile.

Все файлы, которые создает скрипт configure, должны в своем начале иметь комиентарии, поясняющие что они были сгенерированы автоматически при помощи configure.
Это для того, чтобы пользователи не думали пытаться редактировать их вручную.

Скрипт configure должен создавать файл с именем config.status, который описывает, какие конфигурационные опции были определены, когда программа в последний раз конфигурировалась.
Это должен быть shell скрипт который, если его запустить, будет реализовывать эту конфигурацию.

Скрипт configure должен принимать опцию в форме '--srcdir=dirname' чтобы задать директорию, где находятся исходники (если это не текущая директория).
Это делает возможным собирать программу в отдельной директории, так что актуальная директория исходников остается неизмененной.

Если пользователь не указал '--srcdir', тогда configure проверяет обе директории: и . , и .. , в поиске исходников. (?как?)
Если он находит исходники в одном из этих мест, он использует их оттуда.
Иначе он должен сообщить, что не может найти исходники, и завершиться с ненулевым статусом.

Обычно простой путь поддержки '--srcdir' это редактирование определения VPATH в Makefile-е.
Некоторые цели могут нуждаться в явной ссылке на заданную директорию исходников.
Чтобы сделать это возможным, configure может добавлять переменную srcdir в Makefile, чье значение является в точности заданной директорией.

В дополнение, configure должен принимать опции, передающие большинство переменных стандартных директорий (см. раздел 7.2.5. [переменные директорий]).
Вот их список:
	--prefix
	--exec-prefix
	--bin		dir
	--sbin		dir
	--libexec	dir
	--sysconf	dir
	--sharedstate	dir
	--local	state	dir
	--run	state	dir
	--lib		dir
	--include	dir
	--oldinclude	dir
	--dataroot	dir
	--data		dir
	--info		dir
	--locale	dir
	--man		dir
	--doc		dir
	--html		dir
	--dvi		dir
	--pdf		dir
	--ps		dir

Скрипт Configure также должен брать аргумент, который задает тип системы, для которй собирается программа.
Этот аргумент должен выглядеть так: cpu-company-system
К примеру на машине, основанной на Athlon, с системой GNU/Linux должен быть 'i686-pc-linux-gnu'.

>> plausible - правдоподобный
Скрипт configure должен быть в состоянии декодировать все правдоподобные альтернативы описывающие машину.
Таким образом 'athlon-pc-gnu/linux' будет годным псевдонимом.
Существует шелл-скрипт под названием config.sub
(http://git.savannah.gnu.org/gitweb/ ?p=config.
git;a=blob_plain;f=config.sub;hb=HEAD)
который вы можете использовать как подпрограмму для определения типа системы и канонических алиасов.

Скрипт configure также должен принимать опцию --buid=buildtype, что эквивалентно передаче buildtype как простого аргумента.
К примеру 'configure --build=i686-pc-linux-gnu' эквивалентно 'confugure i686-pc-linux-gnu'.
Когда тип системы не задан как опция или аргумент, скрипт configure должен нормально разгадать его, используя шел-скрипт config.guess
(http://git.savannah.gnu.org/
gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD).

>> permitted - разрешение
Другие опции разрешены для задания больших деталей о ПО или железе, представленном на машине,
для включения или исключения дополнительных частей пакета
>> adjust - установка
или для установки имен некоторых средств или аргументов к ним:

--enable-фича[=parameter]
>> facility - средство
	Конфигурирует пакет для сборки и установки опционального средста пользовательского уровня под названием фича.
	Это позволяет пользователям выбирать, какие дополнительные фичи будут добавлены.
	Добавление дополнительного параметра 'no' должно отменить фичу, если она собирается по умолчанию.
>> omit - опускаться
	Опция '--enable' никогда не должна замещать одну фичу другой.
	Опция '--enable' никогда не должна подставлять одно полезное поведение вместо другого полезного поведения.
>> proper - соответствующий
	Использование '--enable' соответствует только вопросу, собирать ли часть программы или нет.

--with-<пакет>(???)
	Пакет <пакет> будет установлен, так что этот пакет  сконфигурируется на работу с этим <пакетом>.(?)
	Возможные значения <пакета> включают 'gnu-as' (или 'gas'), 'gnu-ld', 'gnu-libc', 'gdb', 'x' и 'x-toolkit'.
	Не используйте опцию --with для задания имени файла, который будет использоваться.
	Это выходит за пределы применимости опции --with.
variable=value
	Устанавливает значение переменной.
	Это используется, чтобы переопределить значение по умолчанию команды или аргумента в процессе сборки.
	К примеру пользователь может задать 'configure CFLAGS=-g CXXFLAGS=-g' чтобы собрать с отладочной информацией и без оптимизации, которая присутствует по умолчанию.
	Задание переменных как аргументов configure вот так:
		./configure CC=gcc
	более предпочтительно, чем установка переменных среды:
		CC=gcc ./configure
	т.к. это помогает пересоздать такую же конфигурацию позже при помощи config.status. Вообще, должны поддерживаться оба метода.

Все скрипты configure должны принимать все опции детализации и установки переменных, не зависимо от того, могут они произвести изменения в отдельном пакете или нет.
>> at hand - тут же
В частности, они должны принимать любые опции, начинающиеся с --with- или --enable-.
Это для того, чтобы пользователи были в состоянии сконфигурировать все дерево исходников GNU с одним набором опций.

>> arrow - стрелка
>> narrow - узкий
>> liberate - высвободить
>> deliberate - преднамеренный 
Вы должны помнить, что категории --with- и --enable- узки: они не предоставляют место любым сортам опций, о которых вы можете подумать.
Это преднамеренно.
Мы хотим ограничить возможные конфигурационные опции в ПО GNU.
Мы не хотим, чтобы программы GNU имели (?)идиосинкра

