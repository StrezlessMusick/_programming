<html lang="en">
<head>
<title>Buffer Overruns - Autoconf</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Autoconf">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Portable-C-and-C_002b_002b.html#Portable-C-and-C_002b_002b" title="Portable C and C++">
<link rel="prev" href="Null-Pointers.html#Null-Pointers" title="Null Pointers">
<link rel="next" href="Volatile-Objects.html#Volatile-Objects" title="Volatile Objects">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual (24 April 2012) is for GNU Autoconf
(version 2.69),
a package for creating scripts to configure source code packages using
templates and an M4 macro package.

Copyright (C) 1992-1996, 1998-2012 Free Software Foundation,
Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled ``GNU Free Documentation License.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Buffer-Overruns"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Volatile-Objects.html#Volatile-Objects">Volatile Objects</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Null-Pointers.html#Null-Pointers">Null Pointers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Portable-C-and-C_002b_002b.html#Portable-C-and-C_002b_002b">Portable C and C++</a>
<hr>
</div>

<h3 class="section">13.5 Buffer Overruns and Subscript Errors</h3>

<p><a name="index-buffer-overruns-1906"></a>
Buffer overruns and subscript errors are the most common dangerous
errors in C programs.  They result in undefined behavior because storing
outside an array typically modifies storage that is used by some other
object, and most modern systems lack runtime checks to catch these
errors.  Programs should not rely on buffer overruns being caught.

   <p>There is one exception to the usual rule that a portable program cannot
address outside an array.  In C, it is valid to compute the address just
past an object, e.g., <code>&amp;a[N]</code> where <code>a</code> has <code>N</code> elements,
so long as you do not dereference the resulting pointer.  But it is not
valid to compute the address just before an object, e.g., <code>&amp;a[-1]</code>;
nor is it valid to compute two past the end, e.g., <code>&amp;a[N+1]</code>.  On
most platforms <code>&amp;a[-1] &lt; &amp;a[0] &amp;&amp; &amp;a[N] &lt; &amp;a[N+1]</code>, but this is not
reliable in general, and it is usually easy enough to avoid the
potential portability problem, e.g., by allocating an extra unused array
element at the start or end.

   <p><a href="http://valgrind.org/">Valgrind</a> can catch many overruns. 
GCC
users might also consider using the <samp><span class="option">-fmudflap</span></samp> option to catch
overruns.

   <p>Buffer overruns are usually caused by off-by-one errors, but there are
more subtle ways to get them.

   <p>Using <code>int</code> values to index into an array or compute array sizes
causes problems on typical 64-bit hosts where an array index might
be 2^31 or larger.  Index values of type <code>size_t</code> avoid this
problem, but cannot be negative.  Index values of type <code>ptrdiff_t</code>
are signed, and are wide enough in practice.

   <p>If you add or multiply two numbers to calculate an array size, e.g.,
<code>malloc (x * sizeof y + z)</code>, havoc ensues if the addition or
multiplication overflows.

   <p>Many implementations of the <code>alloca</code> function silently misbehave
and can generate buffer overflows if given sizes that are too large. 
The size limits are implementation dependent, but are at least 4000
bytes on all platforms that we know about.

   <p>The standard functions <code>asctime</code>, <code>asctime_r</code>, <code>ctime</code>,
<code>ctime_r</code>, and <code>gets</code> are prone to buffer overflows, and
portable code should not use them unless the inputs are known to be
within certain limits.  The time-related functions can overflow their
buffers if given timestamps out of range (e.g., a year less than -999
or greater than 9999).  Time-related buffer overflows cannot happen with
recent-enough versions of the GNU C library, but are possible
with other
implementations.  The <code>gets</code> function is the worst, since it almost
invariably overflows its buffer when presented with an input line larger
than the buffer.

   </body></html>

