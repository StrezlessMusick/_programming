<html lang="en">
<head>
<title>Limitations of Builtins - Autoconf</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Autoconf">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Portable-Shell.html#Portable-Shell" title="Portable Shell">
<link rel="prev" href="Shell-Functions.html#Shell-Functions" title="Shell Functions">
<link rel="next" href="Limitations-of-Usual-Tools.html#Limitations-of-Usual-Tools" title="Limitations of Usual Tools">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual (24 April 2012) is for GNU Autoconf
(version 2.69),
a package for creating scripts to configure source code packages using
templates and an M4 macro package.

Copyright (C) 1992-1996, 1998-2012 Free Software Foundation,
Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled ``GNU Free Documentation License.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Limitations-of-Builtins"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Limitations-of-Usual-Tools.html#Limitations-of-Usual-Tools">Limitations of Usual Tools</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Shell-Functions.html#Shell-Functions">Shell Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Portable-Shell.html#Portable-Shell">Portable Shell</a>
<hr>
</div>

<h3 class="section">11.14 Limitations of Shell Builtins</h3>

<p><a name="index-Shell-builtins-1767"></a><a name="index-Limitations-of-shell-builtins-1768"></a>
No, no, we are serious: some shells do have limitations!  :)

   <p>You should always keep in mind that any builtin or command may support
options, and therefore differ in behavior with arguments
starting with a dash.  For instance, even the innocent &lsquo;<samp><span class="samp">echo "$word"</span></samp>&rsquo;
can give unexpected results when <code>word</code> starts with a dash.  It is
often possible to avoid this problem using &lsquo;<samp><span class="samp">echo "x$word"</span></samp>&rsquo;, taking
the &lsquo;<samp><span class="samp">x</span></samp>&rsquo; into account later in the pipe.  Many of these limitations
can be worked around using M4sh (see <a href="Programming-in-M4sh.html#Programming-in-M4sh">Programming in M4sh</a>).

<!-- This table includes things like `@command{test} (files)', so we can't -->
<!-- use @table @command. -->
     <dl>
<dt><samp><span class="command">.</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007b_002e_007d-1769"></a>Use <samp><span class="command">.</span></samp> only with regular files (use &lsquo;<samp><span class="samp">test -f</span></samp>&rsquo;).  Bash
2.03, for instance, chokes on &lsquo;<samp><span class="samp">. /dev/null</span></samp>&rsquo;.  Remember that
<samp><span class="command">.</span></samp> uses <samp><span class="env">PATH</span></samp> if its argument contains no slashes.  Also,
some shells, including bash 3.2, implicitly append the current directory
to this <samp><span class="env">PATH</span></samp> search, even though Posix forbids it.  So if you want
to use <samp><span class="command">.</span></samp> on a file <samp><span class="file">foo</span></samp> in the current directory, you
must use &lsquo;<samp><span class="samp">. ./foo</span></samp>&rsquo;.

     <p>Not all shells gracefully handle syntax errors within a sourced file. 
On one extreme, some non-interactive shells abort the entire script.  On
the other, <samp><span class="command">zsh</span></samp> 4.3.10 has a bug where it fails to react to the
syntax error.

     <pre class="example">          $ <kbd>echo 'fi' &gt; syntax</kbd>
          $ <kbd>bash -c '. ./syntax; echo $?'</kbd>
          ./syntax: line 1: syntax error near unexpected token `fi'
          ./syntax: line 1: `fi'
          1
          $ <kbd>ash -c '. ./syntax; echo $?'</kbd>
          ./syntax: 1: Syntax error: "fi" unexpected
          $ <kbd>zsh -c '. ./syntax; echo $?'</kbd>
          ./syntax:1: parse error near `fi'
          0
</pre>
     <br><dt><samp><span class="command">!</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007b_0021_007d-1770"></a>The Unix version 7 shell did not support
negating the exit status of commands with <samp><span class="command">!</span></samp>, and this feature
is still absent from some shells (e.g., Solaris <samp><span class="command">/bin/sh</span></samp>). 
Other shells, such as FreeBSD <samp><span class="command">/bin/sh</span></samp> or <samp><span class="command">ash</span></samp>, have
bugs when using <samp><span class="command">!</span></samp>:

     <pre class="example">          $ <kbd>sh -c '! : | :'; echo $?</kbd>
          1
          $ <kbd>ash -c '! : | :'; echo $?</kbd>
          0
          $ <kbd>sh -c '! { :; }'; echo $?</kbd>
          1
          $ <kbd>ash -c '! { :; }'; echo $?</kbd>
          {: not found
          Syntax error: "}" unexpected
          2
</pre>
     <p>Shell code like this:

     <pre class="example">          if ! cmp file1 file2 &gt;/dev/null 2&gt;&amp;1; then
            echo files differ or trouble
          fi
</pre>
     <p>is therefore not portable in practice.  Typically it is easy to rewrite
such code, e.g.:

     <pre class="example">          cmp file1 file2 &gt;/dev/null 2&gt;&amp;1 ||
            echo files differ or trouble
</pre>
     <p>More generally, one can always rewrite &lsquo;<samp><span class="samp">! </span><var>command</var></samp>&rsquo; as:

     <pre class="example">          if <var>command</var>; then (exit 1); else :; fi
</pre>
     <br><dt><samp><span class="command">{...}</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007b_0040_007b_002e_002e_002e_0040_007d_007d-1771"></a>Bash 3.2 (and earlier versions) sometimes does not properly set
&lsquo;<samp><span class="samp">$?</span></samp>&rsquo; when failing to write redirected output of a compound command. 
This problem is most commonly observed with &lsquo;<samp><span class="samp">{...}</span></samp>&rsquo;; it does
not occur with &lsquo;<samp><span class="samp">(...)</span></samp>&rsquo;.  For example:

     <pre class="example">          $ <kbd>bash -c '{ echo foo; } &gt;/bad; echo $?'</kbd>
          bash: line 1: /bad: Permission denied
          0
          $ <kbd>bash -c 'while :; do echo; done &gt;/bad; echo $?'</kbd>
          bash: line 1: /bad: Permission denied
          0
</pre>
     <p>To work around the bug, prepend &lsquo;<samp><span class="samp">:;</span></samp>&rsquo;:

     <pre class="example">          $ <kbd>bash -c ':;{ echo foo; } &gt;/bad; echo $?'</kbd>
          bash: line 1: /bad: Permission denied
          1
</pre>
     <p>Posix requires a syntax error if a brace list has no contents.  However,
not all shells obey this rule; and on shells where empty lists are
permitted, the effect on &lsquo;<samp><span class="samp">$?</span></samp>&rsquo; is inconsistent.  To avoid problems,
ensure that a brace list is never empty.

     <pre class="example">          $ <kbd>bash -c 'false; { }; echo $?' || echo $?</kbd>
          bash: line 1: syntax error near unexpected token `}'
          bash: line 1: `false; { }; echo $?'
          2
          $ <kbd>zsh -c 'false; { }; echo $?' || echo $?</kbd>
          1
          $ <kbd>pdksh -c 'false; { }; echo $?' || echo $?</kbd>
          0
</pre>
     <br><dt><samp><span class="command">break</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bbreak_007d-1772"></a>The use of &lsquo;<samp><span class="samp">break 2</span></samp>&rsquo; etc. is safe.

     <p><a name="case"></a><br><dt><samp><span class="command">case</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bcase_007d-1773"></a>You don't need to quote the argument; no splitting is performed.

     <p>You don't need the final &lsquo;<samp><span class="samp">;;</span></samp>&rsquo;, but you should use it.

     <p>Posix requires support for <code>case</code> patterns with opening
parentheses like this:

     <pre class="example">          case $file_name in
            (*.c) echo "C source code";;
          esac
</pre>
     <p class="noindent">but the <code>(</code> in this example is not portable to many Bourne
shell implementations, which is a pity for those of us using tools that
rely on balanced parentheses.  For instance, with Solaris
<samp><span class="command">/bin/sh</span></samp>:

     <pre class="example">          $ <kbd>case foo in (foo) echo foo;; esac</kbd>
          error--&gt;syntax error: `(' unexpected
</pre>
     <p class="noindent">The leading &lsquo;<samp><span class="samp">(</span></samp>&rsquo; can be omitted safely.  Unfortunately, there are
contexts where unbalanced parentheses cause other problems, such as when
using a syntax-highlighting editor that searches for the balancing
counterpart, or more importantly, when using a case statement as an
underquoted argument to an Autoconf macro.  See <a href="Balancing-Parentheses.html#Balancing-Parentheses">Balancing Parentheses</a>, for tradeoffs involved in various styles of dealing with
unbalanced &lsquo;<samp><span class="samp">)</span></samp>&rsquo;.

     <p>Zsh handles pattern fragments derived from parameter expansions or
command substitutions as though quoted:

     <pre class="example">          $ pat=\?; case aa in ?$pat) echo match;; esac
          $ pat=\?; case a? in ?$pat) echo match;; esac
          match
</pre>
     <p class="noindent">Because of a bug in its <code>fnmatch</code>, Bash fails to properly
handle backslashes in character classes:

     <pre class="example">          bash-2.02$ <kbd>case /tmp in [/\\]*) echo OK;; esac</kbd>
          bash-2.02$
</pre>
     <p class="noindent">This is extremely unfortunate, since you are likely to use this code to
handle Posix or MS-DOS absolute file names.  To work around this
bug, always put the backslash first:

     <pre class="example">          bash-2.02$ <kbd>case '\TMP' in [\\/]*) echo OK;; esac</kbd>
          OK
          bash-2.02$ <kbd>case /tmp in [\\/]*) echo OK;; esac</kbd>
          OK
</pre>
     <p>Many Bourne shells cannot handle closing brackets in character classes
correctly.

     <p>Some shells also have problems with backslash escaping in case you do not want
to match the backslash: both a backslash and the escaped character match this
pattern.  To work around this, specify the character class in a variable, so
that quote removal does not apply afterwards, and the special characters don't
have to be backslash-escaped:

     <pre class="example">          $ <kbd>case '\' in [\&lt;]) echo OK;; esac</kbd>
          OK
          $ <kbd>scanset='[&lt;]'; case '\' in $scanset) echo OK;; esac</kbd>
          $
</pre>
     <p>Even with this, Solaris <samp><span class="command">ksh</span></samp> matches a backslash if the set
contains any
of the characters &lsquo;<samp><span class="samp">|</span></samp>&rsquo;, &lsquo;<samp><span class="samp">&amp;</span></samp>&rsquo;, &lsquo;<samp><span class="samp">(</span></samp>&rsquo;, or &lsquo;<samp><span class="samp">)</span></samp>&rsquo;.

     <p>Conversely, Tru64 <samp><span class="command">ksh</span></samp> (circa 2003) erroneously always matches
a closing parenthesis if not specified in a character class:

     <pre class="example">          $ <kbd>case foo in *\)*) echo fail ;; esac</kbd>
          fail
          $ <kbd>case foo in *')'*) echo fail ;; esac</kbd>
          fail
</pre>
     <p>Some shells, such as Ash 0.3.8, are confused by an empty
<code>case</code>/<code>esac</code>:

     <pre class="example">          ash-0.3.8 $ <kbd>case foo in esac;</kbd>
          error--&gt;Syntax error: ";" unexpected (expecting ")")
</pre>
     <p>Posix requires <samp><span class="command">case</span></samp> to give an exit status of 0 if no cases
match.  However, <samp><span class="command">/bin/sh</span></samp> in Solaris 10 does not obey this
rule.  Meanwhile, it is unclear whether a case that matches, but
contains no statements, must also change the exit status to 0.  The M4sh
macro <code>AS_CASE</code> works around these inconsistencies.

     <pre class="example">          $ <kbd>bash -c 'case `false` in ?) ;; esac; echo $?'</kbd>
          0
          $ <kbd>/bin/sh -c 'case `false` in ?) ;; esac; echo $?'</kbd>
          255
</pre>
     <br><dt><samp><span class="command">cd</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bcd_007d-1774"></a>Posix 1003.1-2001 requires that <samp><span class="command">cd</span></samp> must support
the <samp><span class="option">-L</span></samp> (&ldquo;logical&rdquo;) and <samp><span class="option">-P</span></samp> (&ldquo;physical&rdquo;) options,
with <samp><span class="option">-L</span></samp> being the default.  However, traditional shells do
not support these options, and their <samp><span class="command">cd</span></samp> command has the
<samp><span class="option">-P</span></samp> behavior.

     <p>Portable scripts should assume neither option is supported, and should
assume neither behavior is the default.  This can be a bit tricky,
since the Posix default behavior means that, for example,
&lsquo;<samp><span class="samp">ls ..</span></samp>&rsquo; and &lsquo;<samp><span class="samp">cd ..</span></samp>&rsquo; may refer to different directories if
the current logical directory is a symbolic link.  It is safe to use
<code>cd </code><var>dir</var> if <var>dir</var> contains no <samp><span class="file">..</span></samp> components. 
Also, Autoconf-generated scripts check for this problem when computing
variables like <code>ac_top_srcdir</code> (see <a href="Configuration-Actions.html#Configuration-Actions">Configuration Actions</a>),
so it is safe to <samp><span class="command">cd</span></samp> to these variables.

     <p>Posix states that behavior is undefined if <samp><span class="command">cd</span></samp> is given an
explicit empty argument.  Some shells do nothing, some change to the
first entry in <samp><span class="env">CDPATH</span></samp>, some change to <samp><span class="env">HOME</span></samp>, and some exit
the shell rather than returning an error.  Unfortunately, this means
that if &lsquo;<samp><span class="samp">$var</span></samp>&rsquo; is empty, then &lsquo;<samp><span class="samp">cd "$var"</span></samp>&rsquo; is less predictable
than &lsquo;<samp><span class="samp">cd $var</span></samp>&rsquo; (at least the latter is well-behaved in all shells
at changing to <samp><span class="env">HOME</span></samp>, although this is probably not what you wanted
in a script).  You should check that a directory name was supplied
before trying to change locations.

     <p>See <a href="Special-Shell-Variables.html#Special-Shell-Variables">Special Shell Variables</a>, for portability problems involving
<samp><span class="command">cd</span></samp> and the <samp><span class="env">CDPATH</span></samp> environment variable. 
Also please see the discussion of the <samp><span class="command">pwd</span></samp> command.

     <p><a name="echo"></a><br><dt><samp><span class="command">echo</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007becho_007d-1775"></a>The simple <samp><span class="command">echo</span></samp> is probably the most surprising source of
portability troubles.  It is not possible to use &lsquo;<samp><span class="samp">echo</span></samp>&rsquo; portably
unless both options and escape sequences are omitted.  Don't expect any
option.

     <p>Do not use backslashes in the arguments, as there is no consensus on
their handling.  For &lsquo;<samp><span class="samp">echo '\n' | wc -l</span></samp>&rsquo;, the <samp><span class="command">sh</span></samp> of
Solaris outputs 2, but Bash and Zsh (in <samp><span class="command">sh</span></samp> emulation mode) output 1. 
The problem is truly <samp><span class="command">echo</span></samp>: all the shells
understand &lsquo;<samp><span class="samp">'\n'</span></samp>&rsquo; as the string composed of a backslash and an
&lsquo;<samp><span class="samp">n</span></samp>&rsquo;.  Within a command substitution, &lsquo;<samp><span class="samp">echo 'string\c'</span></samp>&rsquo; will
mess up the internal state of ksh88 on AIX 6.1 so that it will print
the first character &lsquo;<samp><span class="samp">s</span></samp>&rsquo; only, followed by a newline, and then
entirely drop the output of the next echo in a command substitution.

     <p>Because of these problems, do not pass a string containing arbitrary
characters to <samp><span class="command">echo</span></samp>.  For example, &lsquo;<samp><span class="samp">echo "$foo"</span></samp>&rsquo; is safe
only if you know that <var>foo</var>'s value cannot contain backslashes and
cannot start with &lsquo;<samp><span class="samp">-</span></samp>&rsquo;.

     <p>If this may not be true, <samp><span class="command">printf</span></samp> is in general safer and
easier to use than <samp><span class="command">echo</span></samp> and <samp><span class="command">echo -n</span></samp>.  Thus, scripts
where portability is not a major concern should use <samp><span class="command">printf
'%s\n'</span></samp> whenever <samp><span class="command">echo</span></samp> could fail, and similarly use
<samp><span class="command">printf %s</span></samp> instead of <samp><span class="command">echo -n</span></samp>. For portable shell
scripts, instead, it is suggested to use a here-document like this:

     <pre class="example">          cat &lt;&lt;EOF
          $foo
          EOF
</pre>
     <p>Alternatively, M4sh provides <code>AS_ECHO</code> and <code>AS_ECHO_N</code> macros
which choose between various portable implementations: &lsquo;<samp><span class="samp">echo</span></samp>&rsquo;
or &lsquo;<samp><span class="samp">print</span></samp>&rsquo; where they work, <samp><span class="command">printf</span></samp> if it is available,
or else other creative tricks in order to work around the above problems.

     <br><dt><samp><span class="command">eval</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007beval_007d-1776"></a>The <samp><span class="command">eval</span></samp> command is useful in limited circumstances, e.g.,
using commands like &lsquo;<samp><span class="samp">eval table_$key=\$value</span></samp>&rsquo; and &lsquo;<samp><span class="samp">eval
value=table_$key</span></samp>&rsquo; to simulate a hash table when the key is known to be
alphanumeric.

     <p>You should also be wary of common bugs in <samp><span class="command">eval</span></samp> implementations. 
In some shell implementations (e.g., older <samp><span class="command">ash</span></samp>, OpenBSD 3.8
<samp><span class="command">sh</span></samp>, <samp><span class="command">pdksh</span></samp> v5.2.14 99/07/13.2, and <samp><span class="command">zsh</span></samp>
4.2.5), the arguments of &lsquo;<samp><span class="samp">eval</span></samp>&rsquo; are evaluated in a context where
&lsquo;<samp><span class="samp">$?</span></samp>&rsquo; is 0, so they exhibit behavior like this:

     <pre class="example">          $ <kbd>false; eval 'echo $?'</kbd>
          0
</pre>
     <p>The correct behavior here is to output a nonzero value,
but portable scripts should not rely on this.

     <p>You should not rely on <code>LINENO</code> within <samp><span class="command">eval</span></samp>. 
See <a href="Special-Shell-Variables.html#Special-Shell-Variables">Special Shell Variables</a>.

     <p>Note that, even though these bugs are easily avoided,
<samp><span class="command">eval</span></samp> is tricky to use on arbitrary arguments. 
It is obviously unwise to use &lsquo;<samp><span class="samp">eval $cmd</span></samp>&rsquo; if the string value of
&lsquo;<samp><span class="samp">cmd</span></samp>&rsquo; was derived from an untrustworthy source.  But even if the
string value is valid, &lsquo;<samp><span class="samp">eval $cmd</span></samp>&rsquo; might not work as intended,
since it causes field splitting and file name expansion to occur twice,
once for the <samp><span class="command">eval</span></samp> and once for the command itself.  It is
therefore safer to use &lsquo;<samp><span class="samp">eval "$cmd"</span></samp>&rsquo;.  For example, if <var>cmd</var>
has the value &lsquo;<samp><span class="samp">cat test?.c</span></samp>&rsquo;, &lsquo;<samp><span class="samp">eval $cmd</span></samp>&rsquo; might expand to the
equivalent of &lsquo;<samp><span class="samp">cat test;.c</span></samp>&rsquo; if there happens to be a file named
<samp><span class="file">test;.c</span></samp> in the current directory; and this in turn
mistakenly attempts to invoke <samp><span class="command">cat</span></samp> on the file <samp><span class="file">test</span></samp> and
then execute the command <samp><span class="command">.c</span></samp>.  To avoid this problem, use
&lsquo;<samp><span class="samp">eval "$cmd"</span></samp>&rsquo; rather than &lsquo;<samp><span class="samp">eval $cmd</span></samp>&rsquo;.

     <p>However, suppose that you want to output the text of the evaluated
command just before executing it.  Assuming the previous example,
&lsquo;<samp><span class="samp">echo "Executing: $cmd"</span></samp>&rsquo; outputs &lsquo;<samp><span class="samp">Executing: cat test?.c</span></samp>&rsquo;, but
this output doesn't show the user that &lsquo;<samp><span class="samp">test;.c</span></samp>&rsquo; is the actual name
of the copied file.  Conversely, &lsquo;<samp><span class="samp">eval "echo Executing: $cmd"</span></samp>&rsquo;
works on this example, but it fails with &lsquo;<samp><span class="samp">cmd='cat foo &gt;bar'</span></samp>&rsquo;,
since it mistakenly replaces the contents of <samp><span class="file">bar</span></samp> by the
string &lsquo;<samp><span class="samp">cat foo</span></samp>&rsquo;.  No simple, general, and portable solution to
this problem is known.

     <br><dt><samp><span class="command">exec</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bexec_007d-1777"></a>Posix describes several categories of shell built-ins.  Special
built-ins (such as <samp><span class="command">exit</span></samp>) must impact the environment of the
current shell, and need not be available through <samp><span class="command">exec</span></samp>.  All
other built-ins are regular, and must not propagate variable assignments
to the environment of the current shell.  However, the group of regular
built-ins is further distinguished by commands that do not require a
<samp><span class="env">PATH</span></samp> search (such as <samp><span class="command">cd</span></samp>), in contrast to built-ins that
are offered as a more efficient version of something that must still be
found in a <samp><span class="env">PATH</span></samp> search (such as <samp><span class="command">echo</span></samp>).  Posix is not
clear on whether <samp><span class="command">exec</span></samp> must work with the list of 17 utilities
that are invoked without a <samp><span class="env">PATH</span></samp> search, and many platforms lack an
executable for some of those built-ins:

     <pre class="example">          $ <kbd>sh -c 'exec cd /tmp'</kbd>
          sh: line 0: exec: cd: not found
</pre>
     <p>All other built-ins that provide utilities specified by Posix must have
a counterpart executable that exists on <samp><span class="env">PATH</span></samp>, although Posix
allows <samp><span class="command">exec</span></samp> to use the built-in instead of the executable. 
For example, contrast <samp><span class="command">bash</span></samp> 3.2 and <samp><span class="command">pdksh</span></samp> 5.2.14:

     <pre class="example">          $ <kbd>bash -c 'pwd --version' | head -n1</kbd>
          bash: line 0: pwd: --: invalid option
          pwd: usage: pwd [-LP]
          $ <kbd>bash -c 'exec pwd --version' | head -n1</kbd>
          pwd (GNU coreutils) 6.10
          $ <kbd>pdksh -c 'exec pwd --version' | head -n1</kbd>
          pdksh: pwd: --: unknown option
</pre>
     <p>When it is desired to avoid a regular shell built-in, the workaround is
to use some other forwarding command, such as <samp><span class="command">env</span></samp> or
<samp><span class="command">nice</span></samp>, that will ensure a path search:

     <pre class="example">          $ <kbd>pdksh -c 'exec true --version' | head -n1</kbd>
          $ <kbd>pdksh -c 'nice true --version' | head -n1</kbd>
          true (GNU coreutils) 6.10
          $ <kbd>pdksh -c 'env true --version' | head -n1</kbd>
          true (GNU coreutils) 6.10
</pre>
     <br><dt><samp><span class="command">exit</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bexit_007d-1778"></a>The default value of <samp><span class="command">exit</span></samp> is supposed to be <code>$?</code>;
unfortunately, some shells, such as the DJGPP port of Bash 2.04, just
perform &lsquo;<samp><span class="samp">exit 0</span></samp>&rsquo;.

     <pre class="example">          bash-2.04$ <kbd>foo=`exit 1` || echo fail</kbd>
          fail
          bash-2.04$ <kbd>foo=`(exit 1)` || echo fail</kbd>
          fail
          bash-2.04$ <kbd>foo=`(exit 1); exit` || echo fail</kbd>
          bash-2.04$
</pre>
     <p>Using &lsquo;<samp><span class="samp">exit $?</span></samp>&rsquo; restores the expected behavior.

     <p>Some shell scripts, such as those generated by <samp><span class="command">autoconf</span></samp>, use a
trap to clean up before exiting.  If the last shell command exited with
nonzero status, the trap also exits with nonzero status so that the
invoker can tell that an error occurred.

     <p>Unfortunately, in some shells, such as Solaris <samp><span class="command">/bin/sh</span></samp>, an exit
trap ignores the <code>exit</code> command's argument.  In these shells, a trap
cannot determine whether it was invoked by plain <code>exit</code> or by
<code>exit 1</code>.  Instead of calling <code>exit</code> directly, use the
<code>AC_MSG_ERROR</code> macro that has a workaround for this problem.

     <p><a name="export"></a><br><dt><samp><span class="command">export</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bexport_007d-1779"></a>The builtin <samp><span class="command">export</span></samp> dubs a shell variable <dfn>environment
variable</dfn>.  Each update of exported variables corresponds to an update
of the environment variables.  Conversely, each environment variable
received by the shell when it is launched should be imported as a shell
variable marked as exported.

     <p>Alas, many shells, such as Solaris <samp><span class="command">/bin/sh</span></samp>,
IRIX 6.3, IRIX 5.2,
AIX 4.1.5, and Digital Unix 4.0, forget to
<samp><span class="command">export</span></samp> the environment variables they receive.  As a result,
two variables coexist: the environment variable and the shell
variable.  The following code demonstrates this failure:

     <pre class="example">          #!/bin/sh
          echo $FOO
          FOO=bar
          echo $FOO
          exec /bin/sh $0
</pre>
     <p class="noindent">when run with &lsquo;<samp><span class="samp">FOO=foo</span></samp>&rsquo; in the environment, these shells print
alternately &lsquo;<samp><span class="samp">foo</span></samp>&rsquo; and &lsquo;<samp><span class="samp">bar</span></samp>&rsquo;, although they should print only
&lsquo;<samp><span class="samp">foo</span></samp>&rsquo; and then a sequence of &lsquo;<samp><span class="samp">bar</span></samp>&rsquo;s.

     <p>Therefore you should <samp><span class="command">export</span></samp> again each environment variable
that you update; the export can occur before or after the assignment.

     <p>Posix is not clear on whether the <samp><span class="command">export</span></samp> of an undefined
variable causes the variable to be defined with the value of an empty
string, or merely marks any future definition of a variable by that name
for export.  Various shells behave differently in this regard:

     <pre class="example">          $ <kbd>sh -c 'export foo; env | grep foo'</kbd>
          $ <kbd>ash -c 'export foo; env | grep foo'</kbd>
          foo=
</pre>
     <p>Posix requires <samp><span class="command">export</span></samp> to honor assignments made as arguments,
but older shells do not support this, including <samp><span class="command">/bin/sh</span></samp> in
Solaris 10.  Portable scripts should separate assignments and exports
into different statements.

     <pre class="example">          $ <kbd>bash -c 'export foo=bar; echo $foo'</kbd>
          bar
          $ <kbd>/bin/sh -c 'export foo=bar; echo $foo'</kbd>
          /bin/sh: foo=bar: is not an identifier
          $ <kbd>/bin/sh -c 'export foo; foo=bar; echo $foo'</kbd>
          bar
</pre>
     <br><dt><samp><span class="command">false</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bfalse_007d-1780"></a>Don't expect <samp><span class="command">false</span></samp> to exit with status 1: in native
Solaris <samp><span class="file">/bin/false</span></samp> exits with status 255.

     <br><dt><samp><span class="command">for</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bfor_007d-1781"></a>To loop over positional arguments, use:

     <pre class="example">          for arg
          do
            echo "$arg"
          done
</pre>
     <p class="noindent">You may <em>not</em> leave the <code>do</code> on the same line as <code>for</code>,
since some shells improperly grok:

     <pre class="example">          for arg; do
            echo "$arg"
          done
</pre>
     <p>If you want to explicitly refer to the positional arguments, given the
&lsquo;<samp><span class="samp">$@</span></samp>&rsquo; bug (see <a href="Shell-Substitutions.html#Shell-Substitutions">Shell Substitutions</a>), use:

     <pre class="example">          for arg in ${1+"$@"}; do
            echo "$arg"
          done
</pre>
     <p class="noindent">But keep in mind that Zsh, even in Bourne shell emulation mode, performs
word splitting on &lsquo;<samp><span class="samp">${1+"$@"}</span></samp>&rsquo;; see <a href="Shell-Substitutions.html#Shell-Substitutions">Shell Substitutions</a>,
item &lsquo;<samp><span class="samp">$@</span></samp>&rsquo;, for more.

     <p>In Solaris <samp><span class="command">/bin/sh</span></samp>, when the list of arguments of a
<samp><span class="command">for</span></samp> loop starts with <em>unquoted</em> tokens looking like
variable assignments, the loop is not executed on those tokens:

     <pre class="example">          $ <kbd>/bin/sh -c 'for v in a=b c=d x e=f; do echo $v; done'</kbd>
          x
          e=f
</pre>
     <p class="noindent">Thankfully, quoting the assignment-like tokens, or starting the list
with other tokens (including unquoted variable expansion that results in
an assignment-like result), avoids the problem, so it is easy to work
around:

     <pre class="example">          $ <kbd>/bin/sh -c 'for v in "a=b"; do echo $v; done'</kbd>
          a=b
          $ <kbd>/bin/sh -c 'x=a=b; for v in $x c=d; do echo $v; done'</kbd>
          a=b
          c=d
</pre>
     <p><a name="if"></a><br><dt><samp><span class="command">if</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bif_007d-1782"></a>Using &lsquo;<samp><span class="samp">!</span></samp>&rsquo; is not portable.  Instead of:

     <pre class="example">          if ! cmp -s file file.new; then
            mv file.new file
          fi
</pre>
     <p class="noindent">use:

     <pre class="example">          if cmp -s file file.new; then :; else
            mv file.new file
          fi
</pre>
     <p class="noindent">Or, especially if the <dfn>else</dfn> branch is short, you can use <code>||</code>. 
In M4sh, the <code>AS_IF</code> macro provides an easy way to write these kinds
of conditionals:

     <pre class="example">          AS_IF([cmp -s file file.new], [], [mv file.new file])
</pre>
     <p>This is especially useful in other M4 macros, where the <dfn>then</dfn> and
<dfn>else</dfn> branches might be macro arguments.

     <p>Some very old shells did not reset the exit status from an <samp><span class="command">if</span></samp>
with no <samp><span class="command">else</span></samp>:

     <pre class="example">          $ <kbd>if (exit 42); then true; fi; echo $?</kbd>
          42
</pre>
     <p class="noindent">whereas a proper shell should have printed &lsquo;<samp><span class="samp">0</span></samp>&rsquo;.  But this is no
longer a portability problem; any shell that supports functions gets it
correct.  However, it explains why some makefiles have lengthy
constructs:

     <pre class="example">          if test -f "$file"; then
            install "$file" "$dest"
          else
            :
          fi
</pre>
     <br><dt><samp><span class="command">printf</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bprintf_007d-1783"></a>A format string starting with a &lsquo;<samp><span class="samp">-</span></samp>&rsquo; can cause problems. 
Bash interprets it as an option and
gives an error.  And &lsquo;<samp><span class="samp">--</span></samp>&rsquo; to mark the end of options is not good
in the NetBSD Almquist shell (e.g., 0.4.6) which takes that
literally as the format string.  Putting the &lsquo;<samp><span class="samp">-</span></samp>&rsquo; in a &lsquo;<samp><span class="samp">%c</span></samp>&rsquo;
or &lsquo;<samp><span class="samp">%s</span></samp>&rsquo; is probably easiest:

     <pre class="example">          printf %s -foo
</pre>
     <p>Bash 2.03 mishandles an escape sequence that happens to evaluate to &lsquo;<samp><span class="samp">%</span></samp>&rsquo;:

     <pre class="example">          $ <kbd>printf '\045'</kbd>
          bash: printf: `%': missing format character
</pre>
     <p>Large outputs may cause trouble.  On Solaris 2.5.1 through 10, for
example, <samp><span class="file">/usr/bin/printf</span></samp> is buggy, so when using
<samp><span class="command">/bin/sh</span></samp> the command &lsquo;<samp><span class="samp">printf %010000x 123</span></samp>&rsquo; normally dumps
core.

     <p>Since <samp><span class="command">printf</span></samp> is not always a shell builtin, there is a
potential speed penalty for using <code>printf '%s\n'</code> as a replacement
for an <samp><span class="command">echo</span></samp> that does not interpret &lsquo;<samp><span class="samp">\</span></samp>&rsquo; or leading
&lsquo;<samp><span class="samp">-</span></samp>&rsquo;. With Solaris <samp><span class="command">ksh</span></samp>, it is possible to use <code>print
-r --</code> for this role instead.

     <p>See <a href="echo.html#echo">Limitations of Shell Builtins</a>, for a discussion of
portable alternatives to both <samp><span class="command">printf</span></samp> and <samp><span class="command">echo</span></samp>.

     <br><dt><samp><span class="command">pwd</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bpwd_007d-1784"></a>With modern shells, plain <samp><span class="command">pwd</span></samp> outputs a &ldquo;logical&rdquo;
directory name, some of whose components may be symbolic links.  These
directory names are in contrast to &ldquo;physical&rdquo; directory names, whose
components are all directories.

     <p>Posix 1003.1-2001 requires that <samp><span class="command">pwd</span></samp> must support
the <samp><span class="option">-L</span></samp> (&ldquo;logical&rdquo;) and <samp><span class="option">-P</span></samp> (&ldquo;physical&rdquo;) options,
with <samp><span class="option">-L</span></samp> being the default.  However, traditional shells do
not support these options, and their <samp><span class="command">pwd</span></samp> command has the
<samp><span class="option">-P</span></samp> behavior.

     <p>Portable scripts should assume neither option is supported, and should
assume neither behavior is the default.  Also, on many hosts
&lsquo;<samp><span class="samp">/bin/pwd</span></samp>&rsquo; is equivalent to &lsquo;<samp><span class="samp">pwd -P</span></samp>&rsquo;, but Posix
does not require this behavior and portable scripts should not rely on
it.

     <p>Typically it's best to use plain <samp><span class="command">pwd</span></samp>.  On modern hosts this
outputs logical directory names, which have the following advantages:

          <ul>
<li>Logical names are what the user specified. 
<li>Physical names may not be portable from one installation
host to another due to network file system gymnastics. 
<li>On modern hosts &lsquo;<samp><span class="samp">pwd -P</span></samp>&rsquo; may fail due to lack of permissions to
some parent directory, but plain <samp><span class="command">pwd</span></samp> cannot fail for this
reason. 
</ul>

     <p>Also please see the discussion of the <samp><span class="command">cd</span></samp> command.

     <br><dt><samp><span class="command">read</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bread_007d-1785"></a>No options are portable, not even support <samp><span class="option">-r</span></samp> (Solaris
<samp><span class="command">/bin/sh</span></samp> for example).  Tru64/OSF 5.1 <samp><span class="command">sh</span></samp> treats
<samp><span class="command">read</span></samp> as a special built-in, so it may exit if input is
redirected from a non-existent or unreadable file.

     <p><a name="set"></a><br><dt><samp><span class="command">set</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bset_007d-1786"></a>With the FreeBSD 6.0 shell, the <samp><span class="command">set</span></samp> command (without
any options) does not sort its output.

     <p>The <samp><span class="command">set</span></samp> builtin faces the usual problem with arguments
starting with a
dash.  Modern shells such as Bash or Zsh understand <samp><span class="option">--</span></samp> to specify
the end of the options (any argument after <samp><span class="option">--</span></samp> is a parameter,
even &lsquo;<samp><span class="samp">-x</span></samp>&rsquo; for instance), but many traditional shells (e.g., Solaris
10 <samp><span class="command">/bin/sh</span></samp>) simply stop option
processing as soon as a non-option argument is found.  Therefore, use
&lsquo;<samp><span class="samp">dummy</span></samp>&rsquo; or simply &lsquo;<samp><span class="samp">x</span></samp>&rsquo; to end the option processing, and use
<samp><span class="command">shift</span></samp> to pop it out:

     <pre class="example">          set x $my_list; shift
</pre>
     <p>Avoid &lsquo;<samp><span class="samp">set -</span></samp>&rsquo;, e.g., &lsquo;<samp><span class="samp">set - $my_list</span></samp>&rsquo;.  Posix no
longer requires support for this command, and in traditional shells
&lsquo;<samp><span class="samp">set - $my_list</span></samp>&rsquo; resets the <samp><span class="option">-v</span></samp> and <samp><span class="option">-x</span></samp> options, which
makes scripts harder to debug.

     <p>Some nonstandard shells do not recognize more than one option
(e.g., &lsquo;<samp><span class="samp">set -e -x</span></samp>&rsquo; assigns &lsquo;<samp><span class="samp">-x</span></samp>&rsquo; to the command line).  It is
better to combine them:

     <pre class="example">          set -ex
</pre>
     <p><a name="index-g_t_0040command_007bset-_002de_007d-1787"></a>The option <samp><span class="option">-e</span></samp> has historically been underspecified, with enough
ambiguities to cause numerous differences across various shell
implementations; see for example
<a href="http://www.in-ulm.de/~mascheck/various/set-e/">this overview</a>,
or <a href="http://www.austingroupbugs.net/view.php?id=52">this link</a>,
documenting a change to Posix 2008 to match <samp><span class="command">ksh88</span></samp> behavior. 
Note that mixing <code>set -e</code> and shell functions is asking for surprises:

     <pre class="example">          set -e
          doit()
          {
            rm file
            echo one
          }
          doit || echo two
</pre>
     <p class="noindent">According to the recommendation, &lsquo;<samp><span class="samp">one</span></samp>&rsquo; should always be output
regardless of whether the <samp><span class="command">rm</span></samp> failed, because it occurs within
the body of the shell function &lsquo;<samp><span class="samp">doit</span></samp>&rsquo; invoked on the left side of
&lsquo;<samp><span class="samp">||</span></samp>&rsquo;, where the effects of &lsquo;<samp><span class="samp">set -e</span></samp>&rsquo; are not enforced. 
Likewise, &lsquo;<samp><span class="samp">two</span></samp>&rsquo; should never be printed, since the failure of
<samp><span class="command">rm</span></samp> does not abort the function, such that the status of
&lsquo;<samp><span class="samp">doit</span></samp>&rsquo; is 0.

     <p>The BSD shell has had several problems with the <samp><span class="option">-e</span></samp>
option.  Older versions of the BSD
shell (circa 1990) mishandled &lsquo;<samp><span class="samp">&amp;&amp;</span></samp>&rsquo;, &lsquo;<samp><span class="samp">||</span></samp>&rsquo;, &lsquo;<samp><span class="samp">if</span></samp>&rsquo;, and
&lsquo;<samp><span class="samp">case</span></samp>&rsquo; when <samp><span class="option">-e</span></samp> was in effect, causing the shell to exit
unexpectedly in some cases.  This was particularly a problem with
makefiles, and led to circumlocutions like &lsquo;<samp><span class="samp">sh -c 'test -f file ||
touch file'</span></samp>&rsquo;, where the seemingly-unnecessary &lsquo;<samp><span class="samp">sh -c '...'</span></samp>&rsquo;
wrapper works around the bug (see <a href="Failure-in-Make-Rules.html#Failure-in-Make-Rules">Failure in Make Rules</a>).

     <p>Even relatively-recent versions of the BSD shell (e.g., OpenBSD 3.4)
wrongly exit with <samp><span class="option">-e</span></samp> if the last command within a compound
statement fails and is guarded by an &lsquo;<samp><span class="samp">&amp;&amp;</span></samp>&rsquo; only.  For example:

     <pre class="example">          #! /bin/sh
          set -e
          foo=''
          test -n "$foo" &amp;&amp; exit 1
          echo one
          if :; then
            test -n "$foo" &amp;&amp; exit 1
            echo two
            test -n "$foo" &amp;&amp; exit 1
          fi
          echo three
</pre>
     <p class="noindent">does not print &lsquo;<samp><span class="samp">three</span></samp>&rsquo;.  One workaround is to change the last
instance of &lsquo;<samp><span class="samp">test -n "$foo" &amp;&amp; exit 1</span></samp>&rsquo; to be &lsquo;<samp><span class="samp">if test -n
"$foo"; then exit 1; fi</span></samp>&rsquo; instead.  Another possibility is to warn BSD
users not to use &lsquo;<samp><span class="samp">sh -e</span></samp>&rsquo;.

     <p>When &lsquo;<samp><span class="samp">set -e</span></samp>&rsquo; is in effect, a failed command substitution in
Solaris <samp><span class="command">/bin/sh</span></samp> cannot be ignored, even with &lsquo;<samp><span class="samp">||</span></samp>&rsquo;.

     <pre class="example">          $ <kbd>/bin/sh -c 'set -e; foo=`false` || echo foo; echo bar'</kbd>
          $ <kbd>bash -c 'set -e; foo=`false` || echo foo; echo bar'</kbd>
          foo
          bar
</pre>
     <p class="noindent">Moreover, a command substitution, successful or not, causes this shell to
exit from a failing outer command even in presence of an &lsquo;<samp><span class="samp">&amp;&amp;</span></samp>&rsquo; list:

     <pre class="example">          $ <kbd>bash -c 'set -e; false `true` &amp;&amp; echo notreached; echo ok'</kbd>
          ok
          $ <kbd>sh -c 'set -e; false `true` &amp;&amp; echo notreached; echo ok'</kbd>
          $
</pre>
     <p>Portable scripts should not use &lsquo;<samp><span class="samp">set -e</span></samp>&rsquo; if <samp><span class="command">trap</span></samp> is used
to install an exit handler.  This is because Tru64/OSF 5.1 <samp><span class="command">sh</span></samp>
sometimes enters the trap handler with the exit status of the command
prior to the one that triggered the errexit handler:

     <pre class="example">          $ <kbd>sh -ec 'trap '\''echo $?'\'' 0; false'</kbd>
          0
          $ <kbd>sh -c 'set -e; trap '\''echo $?'\'' 0; false'</kbd>
          1
</pre>
     <p class="noindent">Thus, when writing a script in M4sh, rather than trying to rely on
&lsquo;<samp><span class="samp">set -e</span></samp>&rsquo;, it is better to append &lsquo;<samp><span class="samp">|| AS_EXIT</span></samp>&rsquo; to any
statement where it is desirable to abort on failure.

     <p><a name="index-g_t_0040command_007bset-_002db_007d-1788"></a><a name="index-g_t_0040command_007bset-_002dm_007d-1789"></a>Job control is not provided by all shells, so the use of &lsquo;<samp><span class="samp">set -m</span></samp>&rsquo;
or &lsquo;<samp><span class="samp">set -b</span></samp>&rsquo; must be done with care.  When using <samp><span class="command">zsh</span></samp> in
native mode, asynchronous notification (&lsquo;<samp><span class="samp">set -b</span></samp>&rsquo;) is enabled by
default, and using &lsquo;<samp><span class="samp">emulate sh</span></samp>&rsquo; to switch to Posix mode does not
clear this setting (although asynchronous notification has no impact
unless job monitoring is also enabled).  Also, <samp><span class="command">zsh</span></samp> 4.3.10 and
earlier have a bug where job control can be manipulated in interactive
shells, but not in subshells or scripts.  Furthermore, some shells, like
<samp><span class="command">pdksh</span></samp>, fail to treat subshells as interactive, even though the
parent shell was.

     <pre class="example">          $ <kbd>echo $ZSH_VERSION</kbd>
          4.3.10
          $ <kbd>set -m; echo $?</kbd>
          0
          $ <kbd>zsh -c 'set -m; echo $?'</kbd>
          set: can't change option: -m
          $ <kbd>(set -m); echo $?</kbd>
          set: can't change option: -m
          1
          $ <kbd>pdksh -ci 'echo $-; (echo $-)'</kbd>
          cim
          c
</pre>
     <p><a name="index-g_t_0040command_007bset-_002dn_007d-1790"></a>Use of <samp><span class="command">set -n</span></samp> (typically via <samp><span class="command">sh -n script</span></samp>) to
validate a script is not foolproof.  Modern <samp><span class="command">ksh93</span></samp> tries to be
helpful by informing you about better syntax, but switching the script
to use the suggested syntax in order to silence the warnings would
render the script no longer portable to older shells:

     <pre class="example">          $ <kbd>ksh -nc '``'</kbd>
          ksh: warning: line 1: `...` obsolete, use $(...)
          0
</pre>
     <p>Furthermore, on ancient hosts, such as SunOS 4, <samp><span class="command">sh -n</span></samp> could go
into an infinite loop; even with that bug fixed, Solaris 8
<samp><span class="command">/bin/sh</span></samp> takes extremely long to parse large scripts.  Autoconf
itself uses <samp><span class="command">sh -n</span></samp> within its testsuite to check that correct
scripts were generated, but only after first probing for other shell
features (such as <code>test -n "${BASH_VERSION+set}"</code>) that indicate
a reasonably fast and working implementation.

     <br><dt><samp><span class="command">shift</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bshift_007d-1791"></a>Not only is <samp><span class="command">shift</span></samp>ing a bad idea when there is nothing left to
shift, but in addition it is not portable: the shell of MIPS
RISC/OS 4.52 refuses to do it.

     <p>Don't use &lsquo;<samp><span class="samp">shift 2</span></samp>&rsquo; etc.; while it in the SVR1 shell (1983),
it is also absent in many pre-Posix shells.

     <br><dt><samp><span class="command">source</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bsource_007d-1792"></a>This command is not portable, as Posix does not require it; use
<samp><span class="command">.</span></samp> instead.

     <br><dt><samp><span class="command">test</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007btest_007d-1793"></a>The <code>test</code> program is the way to perform many file and string
tests.  It is often invoked by the alternate name &lsquo;<samp><span class="samp">[</span></samp>&rsquo;, but using
that name in Autoconf code is asking for trouble since it is an M4 quote
character.

     <p>The <samp><span class="option">-a</span></samp>, <samp><span class="option">-o</span></samp>, &lsquo;<samp><span class="samp">(</span></samp>&rsquo;, and &lsquo;<samp><span class="samp">)</span></samp>&rsquo; operands are not
present in all implementations, and have been marked obsolete by Posix
2008.  This is because there are inherent ambiguities in using them. 
For example, &lsquo;<samp><span class="samp">test "$1" -a "$2"</span></samp>&rsquo; looks like a binary operator to
check whether two strings are both non-empty, but if &lsquo;<samp><span class="samp">$1</span></samp>&rsquo; is the
literal &lsquo;<samp><span class="samp">!</span></samp>&rsquo;, then some implementations of <samp><span class="command">test</span></samp> treat it
as a negation of the unary operator <samp><span class="option">-a</span></samp>.

     <p>Thus, portable uses of <samp><span class="command">test</span></samp> should never have more than four
arguments, and scripts should use shell constructs like &lsquo;<samp><span class="samp">&amp;&amp;</span></samp>&rsquo; and
&lsquo;<samp><span class="samp">||</span></samp>&rsquo; instead.  If you combine &lsquo;<samp><span class="samp">&amp;&amp;</span></samp>&rsquo; and &lsquo;<samp><span class="samp">||</span></samp>&rsquo; in the same
statement, keep in mind that they have equal precedence, so it is often
better to parenthesize even when this is redundant.  For example:

     <pre class="smallexample">          # Not portable:
          test "X$a" = "X$b" -a \
            '(' "X$c" != "X$d" -o "X$e" = "X$f" ')'
          
          # Portable:
          test "X$a" = "X$b" &amp;&amp;
            { test "X$c" != "X$d" || test "X$e" = "X$f"; }
</pre>
     <p><samp><span class="command">test</span></samp> does not process options like most other commands do; for
example, it does not recognize the <samp><span class="option">--</span></samp> argument as marking the
end of options.

     <p>It is safe to use &lsquo;<samp><span class="samp">!</span></samp>&rsquo; as a <samp><span class="command">test</span></samp> operator.  For example,
&lsquo;<samp><span class="samp">if test ! -d foo; ...</span></samp>&rsquo; is portable even though &lsquo;<samp><span class="samp">if ! test
-d foo; ...</span></samp>&rsquo; is not.

     <br><dt><samp><span class="command">test</span></samp> (files)<dd><!--  -->
To enable <samp><span class="command">configure</span></samp> scripts to support cross-compilation, they
shouldn't do anything that tests features of the build system instead of
the host system.  But occasionally you may find it necessary to check
whether some arbitrary file exists.  To do so, use &lsquo;<samp><span class="samp">test -f</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">test -r</span></samp>&rsquo;, or &lsquo;<samp><span class="samp">test -x</span></samp>&rsquo;.  Do not use &lsquo;<samp><span class="samp">test -e</span></samp>&rsquo;, because
Solaris 10 <samp><span class="command">/bin/sh</span></samp>
lacks it.  To test for symbolic links on systems that have them, use
&lsquo;<samp><span class="samp">test -h</span></samp>&rsquo; rather than &lsquo;<samp><span class="samp">test -L</span></samp>&rsquo;; either form conforms to
Posix 1003.1-2001, but older shells like Solaris 8
<code>/bin/sh</code> support only <samp><span class="option">-h</span></samp>.

     <p>For historical reasons, Posix reluctantly allows implementations of
&lsquo;<samp><span class="samp">test -x</span></samp>&rsquo; that will succeed for the root user, even if no execute
permissions are present.  Furthermore, shells do not all agree on
whether Access Control Lists should affect &lsquo;<samp><span class="samp">test -r</span></samp>&rsquo;, &lsquo;<samp><span class="samp">test
-w</span></samp>&rsquo;, and &lsquo;<samp><span class="samp">test -x</span></samp>&rsquo;; some shells base test results strictly on the
current user id compared to file owner and mode, as if by
<code>stat(2)</code>; while other shells base test results on whether the
current user has the given right, even if that right is only granted by
an ACL, as if by <code>faccessat(2)</code>.  Furthermore, there is a classic
time of check to time of use race between any use of <samp><span class="command">test</span></samp>
followed by operating on the just-checked file.  Therefore, it is a good
idea to write scripts that actually attempt an operation, and are
prepared for the resulting failure if permission is denied, rather than
trying to avoid an operation based solely on whether <samp><span class="command">test</span></samp>
guessed that it might not be permitted.

     <br><dt><samp><span class="command">test</span></samp> (strings)<dd><!--  -->
Posix says that &lsquo;<samp><span class="samp">test "</span><var>string</var><span class="samp">"</span></samp>&rsquo; succeeds if <var>string</var> is
not null, but this usage is not portable to traditional platforms like
Solaris 10 <samp><span class="command">/bin/sh</span></samp>, which mishandle strings like &lsquo;<samp><span class="samp">!</span></samp>&rsquo; and
&lsquo;<samp><span class="samp">-n</span></samp>&rsquo;.

     <p>Posix also says that &lsquo;<samp><span class="samp">test ! "</span><var>string</var><span class="samp">"</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">test -n "</span><var>string</var><span class="samp">"</span></samp>&rsquo; and
&lsquo;<samp><span class="samp">test -z "</span><var>string</var><span class="samp">"</span></samp>&rsquo; work with any string, but many
shells (such as Solaris, AIX 3.2, UNICOS 10.0.0.6,
Digital Unix 4, etc.) get confused if
<var>string</var> looks like an operator:

     <pre class="example">          $ <kbd>test -n =</kbd>
          test: argument expected
          $ <kbd>test ! -n</kbd>
          test: argument expected
          $ <kbd>test -z ")"; echo $?</kbd>
          0
</pre>
     <p>Similarly, Posix says that both &lsquo;<samp><span class="samp">test "</span><var>string1</var><span class="samp">" = "</span><var>string2"</var></samp>&rsquo;
and &lsquo;<samp><span class="samp">test "</span><var>string1</var><span class="samp">" != "</span><var>string2"</var></samp>&rsquo; work for any pairs of
strings, but in practice this is not true for troublesome strings that
look like operators or parentheses, or that begin with &lsquo;<samp><span class="samp">-</span></samp>&rsquo;.

     <p>It is best to protect such strings with a leading &lsquo;<samp><span class="samp">X</span></samp>&rsquo;, e.g.,
&lsquo;<samp><span class="samp">test "X</span><var>string</var><span class="samp">" != X</span></samp>&rsquo; rather than &lsquo;<samp><span class="samp">test -n
"</span><var>string</var><span class="samp">"</span></samp>&rsquo; or &lsquo;<samp><span class="samp">test ! "</span><var>string</var><span class="samp">"</span></samp>&rsquo;.

     <p>It is common to find variations of the following idiom:

     <pre class="example">          test -n "`echo $ac_feature | sed 's/[-a-zA-Z0-9_]//g'`" &amp;&amp;
            <var>action</var>
</pre>
     <p class="noindent">to take an action when a token matches a given pattern.  Such constructs
should be avoided by using:

     <pre class="example">          case $ac_feature in
            *[!-a-zA-Z0-9_]*) <var>action</var>;;
          esac
</pre>
     <p>If the pattern is a complicated regular expression that cannot be
expressed as a shell pattern, use something like this instead:

     <pre class="example">          expr "X$ac_feature" : 'X.*[^-a-zA-Z0-9_]' &gt;/dev/null &amp;&amp;
            <var>action</var>
</pre>
     <p>&lsquo;<samp><span class="samp">expr "X</span><var>foo</var><span class="samp">" : "X</span><var>bar</var><span class="samp">"</span></samp>&rsquo; is more robust than &lsquo;<samp><span class="samp">echo
"X</span><var>foo</var><span class="samp">" | grep "^X</span><var>bar</var><span class="samp">"</span></samp>&rsquo;, because it avoids problems when
&lsquo;<samp><var>foo</var></samp>&rsquo; contains backslashes.

     <p><a name="trap"></a><br><dt><samp><span class="command">trap</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007btrap_007d-1794"></a>It is safe to trap at least the signals 1, 2, 13, and 15.  You can also
trap 0, i.e., have the <samp><span class="command">trap</span></samp> run when the script ends (either via an
explicit <samp><span class="command">exit</span></samp>, or the end of the script).  The trap for 0 should be
installed outside of a shell function, or AIX 5.3 <samp><span class="command">/bin/sh</span></samp>
will invoke the trap at the end of this function.

     <p>Posix says that &lsquo;<samp><span class="samp">trap - 1 2 13 15</span></samp>&rsquo; resets the traps for the
specified signals to their default values, but many common shells (e.g.,
Solaris <samp><span class="command">/bin/sh</span></samp>) misinterpret this and attempt to execute a
&ldquo;command&rdquo; named <samp><span class="command">-</span></samp> when the specified conditions arise. 
Posix 2008 also added a requirement to support &lsquo;<samp><span class="samp">trap 1 2 13 15</span></samp>&rsquo; to
reset traps, as this is supported by a larger set of shells, but there
are still shells like <samp><span class="command">dash</span></samp> that mistakenly try to execute
<samp><span class="command">1</span></samp> instead of resetting the traps.  Therefore, there is no
portable workaround, except for &lsquo;<samp><span class="samp">trap - 0</span></samp>&rsquo;, for which
&lsquo;<samp><span class="samp">trap '' 0</span></samp>&rsquo; is a portable substitute.

     <p>Although Posix is not absolutely clear on this point, it is widely
admitted that when entering the trap &lsquo;<samp><span class="samp">$?</span></samp>&rsquo; should be set to the exit
status of the last command run before the trap.  The ambiguity can be
summarized as: &ldquo;when the trap is launched by an <samp><span class="command">exit</span></samp>, what is
the <em>last</em> command run: that before <samp><span class="command">exit</span></samp>, or
<samp><span class="command">exit</span></samp> itself?&rdquo;

     <p>Bash considers <samp><span class="command">exit</span></samp> to be the last command, while Zsh and
Solaris <samp><span class="command">/bin/sh</span></samp> consider that when the trap is run it is
<em>still</em> in the <samp><span class="command">exit</span></samp>, hence it is the previous exit status
that the trap receives:

     <pre class="example">          $ <kbd>cat trap.sh</kbd>
          trap 'echo $?' 0
          (exit 42); exit 0
          $ <kbd>zsh trap.sh</kbd>
          42
          $ <kbd>bash trap.sh</kbd>
          0
</pre>
     <p>The portable solution is then simple: when you want to &lsquo;<samp><span class="samp">exit 42</span></samp>&rsquo;,
run &lsquo;<samp><span class="samp">(exit 42); exit 42</span></samp>&rsquo;, the first <samp><span class="command">exit</span></samp> being used to
set the exit status to 42 for Zsh, and the second to trigger the trap
and pass 42 as exit status for Bash.  In M4sh, this is covered by using
<code>AS_EXIT</code>.

     <p>The shell in FreeBSD 4.0 has the following bug: &lsquo;<samp><span class="samp">$?</span></samp>&rsquo; is
reset to 0 by empty lines if the code is inside <samp><span class="command">trap</span></samp>.

     <pre class="example">          $ <kbd>trap 'false</kbd>
          
          echo $?' 0
          $ <kbd>exit</kbd>
          0
</pre>
     <p class="noindent">Fortunately, this bug only affects <samp><span class="command">trap</span></samp>.

     <p>Several shells fail to execute an exit trap that is defined inside a
subshell, when the last command of that subshell is not a builtin.  A
workaround is to use &lsquo;<samp><span class="samp">exit $?</span></samp>&rsquo; as the shell builtin.

     <pre class="example">          $ <kbd>bash -c '(trap "echo hi" 0; /bin/true)'</kbd>
          hi
          $ <kbd>/bin/sh -c '(trap "echo hi" 0; /bin/true)'</kbd>
          $ <kbd>/bin/sh -c '(trap "echo hi" 0; /bin/true; exit $?)'</kbd>
          hi
</pre>
     <p class="noindent">Likewise, older implementations of <samp><span class="command">bash</span></samp> failed to preserve
&lsquo;<samp><span class="samp">$?</span></samp>&rsquo; across an exit trap consisting of a single cleanup command.

     <pre class="example">          $ <kbd>bash -c 'trap "/bin/true" 0; exit 2'; echo $?</kbd>
          2
          $ <kbd>bash-2.05b -c 'trap "/bin/true" 0; exit 2'; echo $?</kbd>
          0
          $ <kbd>bash-2.05b -c 'trap ":; /bin/true" 0; exit 2'; echo $?</kbd>
          2
</pre>
     <br><dt><samp><span class="command">true</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007btrue_007d-1795"></a><!-- Info cannot handle `:' in index entries. -->
<!-- @prindex @command{:} -->
Don't worry: as far as we know <samp><span class="command">true</span></samp> is portable. 
Nevertheless, it's not always a builtin (e.g., Bash 1.x), and the
portable shell community tends to prefer using <samp><span class="command">:</span></samp>.  This has a
funny side effect: when asked whether <samp><span class="command">false</span></samp> is more portable
than <samp><span class="command">true</span></samp> Alexandre Oliva answered:

     <blockquote>
In a sense, yes, because if it doesn't exist, the shell will produce an
exit status of failure, which is correct for <samp><span class="command">false</span></samp>, but not
for <samp><span class="command">true</span></samp>. 
</blockquote>

     <p>Remember that even though &lsquo;<samp><span class="samp">:</span></samp>&rsquo; ignores its arguments, it still takes
time to compute those arguments.  It is a good idea to use double quotes
around any arguments to &lsquo;<samp><span class="samp">:</span></samp>&rsquo; to avoid time spent in field splitting
and file name expansion.

     <p><a name="unset"></a><br><dt><samp><span class="command">unset</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bunset_007d-1796"></a>In some nonconforming shells (e.g., Solaris 10 <samp><span class="command">/bin/ksh</span></samp> and
<samp><span class="command">/usr/xpg4/bin/sh</span></samp>, NetBSD 5.99.43 sh, or Bash 2.05a),
<code>unset FOO</code> fails when <code>FOO</code> is not set.  This can interfere
with <code>set -e</code> operation.  You can use

     <pre class="smallexample">          FOO=; unset FOO
</pre>
     <p class="noindent">if you are not sure that <code>FOO</code> is set.

     <p>A few ancient shells lack <samp><span class="command">unset</span></samp> entirely.  For some variables
such as <code>PS1</code>, you can use a neutralizing value instead:

     <pre class="smallexample">          PS1='$ '
</pre>
     <p>Usually, shells that do not support <samp><span class="command">unset</span></samp> need less effort to
make the environment sane, so for example is not a problem if you cannot
unset <samp><span class="command">CDPATH</span></samp> on those shells.  However, Bash 2.01 mishandles
<code>unset MAIL</code> and <code>unset MAILPATH</code> in some cases and dumps core. 
So, you should do something like

     <pre class="smallexample">          ( (unset MAIL) || exit 1) &gt;/dev/null 2&gt;&amp;1 &amp;&amp; unset MAIL || :
</pre>
     <p class="noindent">See <a href="Special-Shell-Variables.html#Special-Shell-Variables">Special Shell Variables</a>, for some neutralizing values.  Also, see
<a href="export.html#export">Limitations of Builtins</a>, for
the case of environment variables.

     <br><dt><samp><span class="command">wait</span></samp><dd><!--  -->
<a name="index-g_t_0040command_007bwait_007d-1797"></a>The exit status of <samp><span class="command">wait</span></samp> is not always reliable. 
</dl>

   </body></html>

