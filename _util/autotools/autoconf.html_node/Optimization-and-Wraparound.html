<html lang="en">
<head>
<title>Optimization and Wraparound - Autoconf</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Autoconf">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Integer-Overflow.html#Integer-Overflow" title="Integer Overflow">
<link rel="prev" href="Signed-Overflow-Examples.html#Signed-Overflow-Examples" title="Signed Overflow Examples">
<link rel="next" href="Signed-Overflow-Advice.html#Signed-Overflow-Advice" title="Signed Overflow Advice">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual (24 April 2012) is for GNU Autoconf
(version 2.69),
a package for creating scripts to configure source code packages using
templates and an M4 macro package.

Copyright (C) 1992-1996, 1998-2012 Free Software Foundation,
Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled ``GNU Free Documentation License.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Optimization-and-Wraparound"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Signed-Overflow-Advice.html#Signed-Overflow-Advice">Signed Overflow Advice</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Signed-Overflow-Examples.html#Signed-Overflow-Examples">Signed Overflow Examples</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Integer-Overflow.html#Integer-Overflow">Integer Overflow</a>
<hr>
</div>

<h4 class="subsection">13.2.3 Optimizations That Break Wraparound Arithmetic</h4>

<p><a name="index-loop-induction-1898"></a>
Compilers sometimes generate code that is incompatible with wraparound
integer arithmetic.  A simple example is an algebraic simplification: a
compiler might translate <code>(i * 2000) / 1000</code> to <code>i * 2</code>
because it assumes that <code>i * 2000</code> does not overflow.  The
translation is not equivalent to the original when overflow occurs:
e.g., in the typical case of 32-bit signed two's complement wraparound
<code>int</code>, if <code>i</code> has type <code>int</code> and value <code>1073742</code>,
the original expression returns &minus;2147483 but the optimized
version returns the mathematically correct value 2147484.

   <p>More subtly, loop induction optimizations often exploit the undefined
behavior of signed overflow.  Consider the following contrived function
<code>sumc</code>:

<pre class="example">     int
     sumc (int lo, int hi)
     {
       int sum = 0;
       int i;
       for (i = lo; i &lt;= hi; i++)
         sum ^= i * 53;
       return sum;
     }
</pre>
   <p class="noindent">To avoid multiplying by 53 each time through the loop, an optimizing
compiler might internally transform <code>sumc</code> to the equivalent of the
following:

<pre class="example">     int
     transformed_sumc (int lo, int hi)
     {
       int sum = 0;
       int hic = hi * 53;
       int ic;
       for (ic = lo * 53; ic &lt;= hic; ic += 53)
         sum ^= ic;
       return sum;
     }
</pre>
   <p class="noindent">This transformation is allowed by the C standard, but it is invalid for
wraparound arithmetic when <code>INT_MAX / 53 &lt; hi</code>, because then the
overflow in computing expressions like <code>hi * 53</code> can cause the
expression <code>i &lt;= hi</code> to yield a different value from the
transformed expression <code>ic &lt;= hic</code>.

   <p>For this reason, compilers that use loop induction and similar
techniques often do not support reliable wraparound arithmetic when a
loop induction variable like <code>ic</code> is involved.  Since loop
induction variables are generated by the compiler, and are not visible
in the source code, it is not always trivial to say whether the problem
affects your code.

   <p>Hardly any code actually depends on wraparound arithmetic in cases like
these, so in practice these loop induction optimizations are almost
always useful.  However, edge cases in this area can cause problems. 
For example:

<pre class="example">     int j;
     for (j = 1; 0 &lt; j; j *= 2)
       test (j);
</pre>
   <p class="noindent">Here, the loop attempts to iterate through all powers of 2 that
<code>int</code> can represent, but the C standard allows a compiler to
optimize away the comparison and generate an infinite loop,
under the argument that behavior is undefined on overflow.  As of this
writing this optimization is not done by any production version of
GCC with <samp><span class="option">-O2</span></samp>, but it might be performed by other
compilers, or by more aggressive GCC optimization options,
and the GCC developers have not decided whether it will
continue to work with GCC and <samp><span class="option">-O2</span></samp>.

   </body></html>

