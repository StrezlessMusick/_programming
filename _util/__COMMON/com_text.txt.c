{== просмотр текста ==
• more<fhs/bin> 			для просмотра содержимого текстовых файлов
• nl<cu>		выводящая указанный файл на стандартный вывод, добавляя номера строк
• od<cu>		для вывода дампа файла в восьмеричном формате. С разными параметрами, с помощью od можно увидеть содержимое файла в шестнадцатеричном, восьмеричном, десятичном и пр.(можно даже одновременно во всех форматах) виде с любого места любой длиной.
• paste<cu>		рассматривает файлы, как вертикальные колонки, соединяет их и выводит в стандартный поток вывода.
}
{== ручное редактирование текста ==
{• echo<ba><fhs/bin>	Выдает аргументы через пробел, дополняя в конце символом новой строки.
	echo [-neE] [аргумент ...]
Статус возврата - всегда 0.
Если указана опция -n, символ новой строки не выдается.
Если указана опция -e, включается интерпретация следующих управляющих комбинаций символов с обратной косой.
Опция -E отключает интерпретацию этих управляющих последовательностей даже в системах, где они интерпретируются по умолчанию.
Команда echo не интерпретирует -- как признак завершения опций.
Команда echo интерпретирует следующие управляющие последовательности:
\a		сигнал (звонок)
\b		забой
\c		не выводить завершающие символы новой строки
\e		управляющий символ
\f		прогон страницы
\n		новая строка
\r		возврат каретки
\t		горизонтальная табуляция
\v		вертикальная табуляция
\\		обратная косая
\nnn		символ, ASCII-код которого - восьмеричное значение nnn (от одной до трех цифр)
\xnnn		символ, ASCII-код которого - шестнадцатеричное значение nnn (от одной до трех цифр)
}
{• printf<ba>	Выдает аргументы в соответствии с форматом в стандартный выходной поток.
	printf формат [аргументы]
Формат - строка символов, содержащая три типа объектов:
	обычные символы, которые просто копируются в стандартный выходной поток,
	управляющие последовательности символов, преобразуемые и копируемые в стандартный выходной поток,
	и спецификации формата, каждая из которых вызывает выдачу последующего аргумента.
Помимо стандартных форматов printf(1),
спецификатор %b вызывает замену управляющих последовательностей,начинающихся с обратной косой,
а спецификатор %q требует выдать соответствующий аргумент в формате, который можно повторно использовать в качестве входных данных командного интерпретатора.

Формат при необходимости используется повторно, чтобы покрыть все аргументы.
Если формат требует больше аргументов, чем передано, дополнительные спецификации формата раскрываются
как если бы были переданы нулевые значения или пустые строки, соответственно.
}
{• read<ba>	Читает одну строку из стандартного входного потока и присваивает первое слово первому имени, второе слово - второму имени, и так далее,
	read [-er] [-a имя_массива] [-p приглашение] [имя ...]
 так что оставшиеся слова вместе с разделителями между ними присваиваются в качестве значения последнему имени.
Если из входного потока прочитано меньше слов, чем указано имен, остальные имена получают пустые значения.
Для разбиения строки на слова используются символы, указанные в значении переменной IFS.
Символ обратной косой (\) можно использовать для литеральной интерпретации следующего прочитанного символа и для продолжения ввода на следующей строке.
Опции имеют следующие значения:
-r	Обратная косая не обрабатывается как символ маскировки. Она считается частью строки.
	В частности, для продолжения на следующей строке нельзя использовать пару обратная косая/новая строка.
-p	Выдает приглашение, без завершающего перевода строки, перед чтением входного потока.
	Приглашение выдается только если входные данные идут с терминала.
-a	Слова присваиваются последовательным элементам массива имя_массива, начиная с 0.
	Имя_массива сбрасывается перед присваиванием новых значений. Другие имена в аргументах игнорируются.
-e	Если стандартный входной поток идет с терминала, для получения строки используется библиотека readline (см. раздел "БИБЛИОТЕКА READLINE" ранее).

Если имена не указаны, прочитанная строка присваивается переменной REPLY.
Статус выхода - 0, если только не встретился символ конца файла.
}
{=== текстовые редакторы ===
• ed 			первый стандартный текстовый редактор операционной системы UNIX, применялся в начале 1970-х. Расширенная его версия, известная как ex, послужила основой редактора vi.
• ex 			расширение редактора ed, наиболее значительным добавлением к которому является возможность экранного редактирования
• vi 			серия текстовых редакторов
emacs
vim
nano
}
. shred<cu>		Перезаписывает файлы чтобы скрыть содержимое (так называемое безопасное удаление), и опционально удаляет файлы
. truncate<cu>	Уменьшает или увеличивает размер файла до заданного размера
}
{== автоматическое редактирование и обработка текста ==
{=== для двоичных файлов ===
• nm 			печатающая информацию о бинарных файлах (объектных файлах, библиотеках, исполняемых файлах и т. д.), прежде всего таблицу имён. 
• strings 		применяемая для поиска печатаемых строк в двоичных файлах
• uudecode 		представление двоичных данных в текстовом формате
• uuencode 		представление двоичных данных в текстовом формате
}
• wc<cu>		выводящая число переводов строк, слов и байт для каждого указанного файла и итоговую строку, если было задано несколько файлов
• pr<cu>		Разбивает ФАЙЛЫ на страницы или колонки ДЛЯ ПЕЧАТИ
{=== для путей и мен файлов ===
• basename<cu> 	basename — встроенная утилита unix-систем, убирающая имена каталогов и суффикс из имени файла.
• dirname<cu>	предназначенная для преобразования абсолютного или относительного пути к файлу или директории в имя родительской директории.
}
{=== табуляции, кодировка, преобразования ===
• expand<cu>	преобразующая табуляции в пробелы, сохраняя форматированность текста.
• unexpand<cu> 	преобразовывающая пробелы в табуляции
• iconv 		для преобразования текста из одной кодировки в другую
• tr<cu> 		для преобразования символов
}
{=== простая общая обработка ===
• tee<cu>		выводит на экран, или же перенаправляет, выходной материал команды и копирует его в файл или в переменную
{==== объединение, разделение, голова, хвост ====
• split<cu>		копирующая файл и разбивающая его на отдельные файлы заданной длины
• csplit<cu>	разбивает файл на отдельные части, разделённые шаблоном
• cat<cu><fhs/bin>		утилита UNIX, выводящая последовательно указанные файлы (или устройства), таким образом, объединяя их в единый поток
. tac<cu>		=cat + вывод в обратном порядке
• head<cu>		выводящая первые n строк из файла, по умолчанию n равно 10
• tail<cu>		выводящая несколько (по умолчанию 10) последних строк из файла.
}
{==== алгоритмы со строками ====
• cmp<du>		Unix-утилита, сравнивает два файла, и если они различаются, сообщает о первом байте и строке, где было обнаружено различие.
• diff<du>		утилита сравнения файлов, выводящая разницу между двумя файлами
patch<*>		применят изменения к файлу
 diff3<du>		сравнивает построчно 3 файла
 sdiff<du>		построчно объединяет различия между файлом 1 и файлом 2
• sort<cu>		выводящая сортированное слияние указанных файлов на стандартный вывод с использованием установленной в среде локали.
• uniq<cu>		можно вывести или отфильтровать повторяющиеся строки в отсортированном файле
. shuf<cu>		случайная перестановка строк
}
{==== построчное разделение и объединение ====
• comm<cu>		утилита unix, читает файл1 и файл2, которые должны быть предварительно лексически отсортированы, и генерирует вывод, состоящий из трёх колонок текста: строки, найденные только в файле файл1; строки, найденные только в файле файл2; и строки, общие для обоих файлов. 
• join<cu>		объединяющая строки двух упорядоченных текстовых файлов на основе наличия общего поля
}
{==== ====
• dd<cu><fhs/bin>		программа UNIX, предназначенная как для копирования, так и для конвертации файлов
. fmt<cu>		форматирует текст
• fold<cu>		Разбивает длинные строки для устройств вывода с ограниченной шириной
}
}
{=== сложная общая обработка (рег. выражения, ~базы данных) ===
• cut<cu>		команда выборки отдельных полей из строк файла
updatedb<fu>	обновляет имена файлов в базе данных
locate<fu>		перечисляет файлы в базпх данных, которые соответствуют паттерну
• grep<*> 			находит на вводе строки, отвечающие заданному регулярному выражению, и выводит их
• awk 			интерпретируемый скриптовый C-подобный язык построчного разбора и обработки входного потока (например, текстового файла) по заданным шаблонам. Работает в bash (SH) скриптах.
• sed<fhs/bin> 			потоковый текстовый редактор (а также язык программирования), применяющий различные предопределённые текстовые преобразования к последовательному потоку текстовых данных.
}
}
