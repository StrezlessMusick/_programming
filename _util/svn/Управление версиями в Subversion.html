<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Управление версиями в Subversion</title><link rel="stylesheet" type="text/css" href="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/styles.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"></head><body><div xml:lang="ru" class="book" title="Управление версиями в Subversion"><div class="titlepage"><div><div><h1 class="title"><a id="svn"></a>Управление версиями в Subversion</h1></div><div><h2 class="subtitle">Для Subversion 1.4</h2></div><div><h2 class="subtitle">(Соответствует редакции 4956)</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Бен</span> <span class="surname">Коллинз-Сассман</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Брайан У.</span> <span class="surname">Фитцпатрик</span></h3></div><div class="author"><h3 class="author"><span class="firstname">К. Майкл</span> <span class="surname">Пилато</span></h3></div></div></div><div><p class="copyright">Авторские права © 2002, 2003, 2004, 2005, 2006, 2007 Ben Collins-Sussman, Brian W. Fitzpatrick, C. Michael Pilato</p></div><div><div class="legalnotice" title="Юридическое уведомление"><a id="idp4182656"></a><p>Этот труд выпущен на условиях Creative Commons
        Attribution License. С текстом данной лицензии можно
        ознакомиться в интернете по адресу
        <a class="ulink" href="http://creativecommons.org/licenses/by/2.0/" target="_top">http://creativecommons.org/licenses/by/2.0/</a>,
        или получить его по почте, отправив заявку по адресу
        Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305,
        USA.</p></div></div><div><p class="pubdate">[Дата выхода в свет будет объявлена дополнительно]</p></div></div><hr></div><div class="toc"><p><strong>Содержание</strong></p><dl><dt><span class="preface"><a href="#svn.foreword">Предисловие</a></span></dt><dt><span class="preface"><a href="#svn.preface">Об этой книге</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.preface.audience">Для кого написана эта книга?</a></span></dt><dt><span class="sect1"><a href="#svn.preface.howread">Как читать эту книгу?</a></span></dt><dt><span class="sect1"><a href="#svn.preface.conventions">Соглашения, принятые в книге</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.preface.conventions.typo">Типографские соглашения</a></span></dt><dt><span class="sect2"><a href="#svn.preface.conventions.icons">Пиктограммы</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.preface.organization">Структура книги</a></span></dt><dt><span class="sect1"><a href="#svn.preface.free">Эта книга распространяется свободно</a></span></dt><dt><span class="sect1"><a href="#svn.preface.acks">Благодарности</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.preface.acks.sussman">От Ben Collins-Sussman</a></span></dt><dt><span class="sect2"><a href="#svn.preface.acks.fitz">От Brian W. Fitzpatrick</a></span></dt><dt><span class="sect2"><a href="#svn.preface.acks.cmpilato">От C. Michael Pilato</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.intro.whatis">Что такое Subversion?</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.intro.history">История Subversion</a></span></dt><dt><span class="sect2"><a href="#svn.intro.features">Возможности Subversion</a></span></dt><dt><span class="sect2"><a href="#svn.intro.architecture">Архитектура Subversion</a></span></dt><dt><span class="sect2"><a href="#svn.intro.components">Компоненты Subversion</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#svn.basic">1. Фундаментальные понятия</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.basic.repository">Хранилище</a></span></dt><dt><span class="sect1"><a href="#svn.basic.vsn-models">Модели версионирования</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.basic.vsn-models.problem-sharing">Проблема разделения файлов</a></span></dt><dt><span class="sect2"><a href="#svn.basic.vsn-models.lock-unlock">Модель Блокирование-Изменение-Разблокирование</a></span></dt><dt><span class="sect2"><a href="#svn.basic.vsn-models.copy-merge">Модель Копирование-Изменение-Слияние</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.basic.in-action">Subversion в действии</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.reposurls">URL хранилища в Subversion</a></span></dt><dt><span class="sect2"><a href="#svn.basic.in-action.wc">Рабочие копии</a></span></dt><dt><span class="sect2"><a href="#svn.basic.in-action.revs">Правки</a></span></dt><dt><span class="sect2"><a href="#svn.basic.in-action.track-repos">Как рабочие копии отслеживают хранилище</a></span></dt><dt><span class="sect2"><a href="#svn.basic.in-action.mixedrevs">Смешивание правок в рабочих копиях</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.update-commit">Обновления и фиксации отделены друг от друга</a></span></dt><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.normal">Смешивание правок — это нормально</a></span></dt><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.useful">Смешивание правок — это полезно</a></span></dt><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.limits">Смешивание правок имеет ограничения</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.basic.summary">Подводя итоги</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn.tour">2. Экскурсия по Subversion</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.tour.help">Читайте справку!</a></span></dt><dt><span class="sect1"><a href="#svn.tour.import">Импорт</a></span></dt><dt><span class="sect1"><a href="#svn.tour.revs">Путешествие во времени вместе с Subversion</a></span></dt><dt><span class="sect1"><a href="#svn.tour.initial">Создание рабочей копии</a></span></dt><dt><span class="sect1"><a href="#svn.tour.cycle">Простейший рабочий цикл</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.cycle.update">Обновление рабочей копии</a></span></dt><dt><span class="sect2"><a href="#svn.tour.cycle.edit">Внесение изменений в рабочую копию</a></span></dt><dt><span class="sect2"><a href="#svn.tour.cycle.examine">Анализ изменений</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.tour.cycle.examine.status"><span class="command"><strong>svn status</strong></span></a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.examine.diff"><span class="command"><strong>svn diff</strong></span></a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.examine.revert"><span class="command"><strong>svn revert</strong></span></a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.tour.cycle.resolve">Разрешение конфликтов (при слиянии с чужими 
        изменениями)</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.tour.cycle.resolve.byhand">Слияние конфликтов вручную</a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.resolve.copyover">Копирование файла поверх вашего рабочего файла</a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.resolve.revert">Использование <span class="command"><strong>svn revert</strong></span></a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.tour.cycle.commit">Фиксация изменений</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.tour.history">Анализ истории</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.history.log"><span class="command"><strong>svn log</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.history.diff"><span class="command"><strong>svn diff</strong></span></a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.tour.history.diff.local">Анализ локальных изменений</a></span></dt><dt><span class="sect3"><a href="#svn.tour.history.diff.wcrepos">Сравнение рабочей копии с хранилищем</a></span></dt><dt><span class="sect3"><a href="#svn.tour.history.diff.reposrepos">Сравнение хранилища с хранилищем</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.tour.history.cat"><span class="command"><strong>svn cat</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.history.list"><span class="command"><strong>svn list</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.history.finalword">Заключительное слово об истории</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.tour.other">Другие полезные команды</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.other.cleanup"><span class="command"><strong>svn cleanup</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.other.import"><span class="command"><strong>svn import</strong></span></a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.tour.summary">Подводя итоги</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn.advanced">3. Профессиональное использование Subversion</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.tour.revs.specifiers">Способы обозначения правок</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.revs.keywords">Ключевые слова правок</a></span></dt><dt><span class="sect2"><a href="#svn.tour.revs.dates">Даты правок</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.props">Свойства</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.props.why">Зачем нужны свойства?</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.props.manip">Использование свойств</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.props.workflow">Свойства и рабочий цикл Subversion</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.props.auto">Автоматическая установка свойств</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.props.file-portability">Переносимость файлов</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.props.special.mime-type">Тип содержимого файла</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.props.special.executable">Исполнимость файла</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.props.special.eol-style">Символы конца строки</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.props.special.ignore">Пропуск неверсионированных элементов</a></span></dt><dt><span class="sect1"><a href="#svn.advanced.props.special.keywords">Подстановка ключевых слов</a></span></dt><dt><span class="sect1"><a href="#svn.advanced.locking">Locking</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.locking.creation">Creating locks</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.locking.discovery">Discovering locks</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.locking.break-steal">Breaking and stealing locks</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.locking.lock-communication">Lock Communication</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.externals">Внешние зависимости</a></span></dt><dt><span class="sect1"><a href="#svn.advanced.pegrevs">Стержневые и оперативные правки</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn.branchmerge">4. Ветвление и слияние</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.branchmerge.whatis">Что такое ветка?</a></span></dt><dt><span class="sect1"><a href="#svn.branchmerge.using">Использование веток</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.using.create">Создание ветки</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.using.work">Работа с веткой</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.using.concepts">Ключевые идеи, стоящие за ветками</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.copychanges">Копирование изменений между ветками</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.copychanges.specific">Копирование отдельных изменений</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.copychanges.keyconcept">Ключевые идеи, стоящие за слиянием</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.copychanges.bestprac">Как правильнее всего использовать слияние</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.track">Ручной контроль слияния</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.preview">Предварительный просмотр результатов слияния</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.merge">Конфликты при слиянии</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.ancestry">Учитывать или игнорировать происхождение</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.commonuses">Типовые примеры</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.wholebr">Полное объединение двух веток</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.undo">Отмена изменений</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.resurrect">Восстановление удаленных элементов</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.patterns">Типовые приемы использования веток</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.branchmerge.commonuses.patterns.release">Ветки релизов</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.commonuses.patterns.feature">Функциональные ветки</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.switchwc">Переключение рабочей копии</a></span></dt><dt><span class="sect1"><a href="#svn.branchmerge.tags">Метки</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.tags.mksimple">Создание простой метки</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.tags.mkcomplex">Создание комплексной метки</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.maint">Поддержка веток</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.maint.layout">Структура хранилища</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.maint.lifetime">Продолжительность жизни информации</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.vendorbr">Vendor branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.vendorbr.general">General Vendor Branch Management Procedure</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.vendorbr.svn_load_dirs"><span class="command"><strong>svn_load_dirs.pl</strong></span></a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.summary">Подводя итоги</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn.reposadmin">5. Администрирование хранилища</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.reposadmin.basics">Repository Basics</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.basics.txnsrevs">Understanding Transactions and Revisions</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.basics.revprops">Unversioned Properties</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.basics.backends">Repository Data Stores</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.reposadmin.basics.backends.bdb">Berkeley DB</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.basics.backends.fsfs">FSFS</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.create">Repository Creation and Configuration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.create.hooks">Hook Scripts</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.create.bdb">Berkeley DB Configuration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.maint">Repository Maintenance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.maint.tk">An Administrator's Toolkit</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.svnlook">svnlook</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.svnadmin">svnadmin</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.svndumpfilter">svndumpfilter</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.bdbutil">Berkeley DB Utilities</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.reposadmin.maint.cleanup">Repository Cleanup</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.diskspace">Managing Disk Space</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.recovery">Repository Recovery</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.migrate">Migrating a Repository</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.backup">Repository Backup</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.projects">Adding Projects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.projects.chooselayout">Choosing a Repository Layout</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.projects.import">Creating the Layout, and Importing Initial Data</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.summary">Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn.serverconfig">6. Настройка сервера</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.serverconfig.overview">Обзор</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.serverconfig.overview.apache">Http-сервер Apache</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.overview.svnserve">Сервер <span class="command"><strong>svnserve</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.overview.svn-ssh"><span class="command"><strong>svnserve</strong></span> через SSH</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.overview.choosing-a-server">Выбор лучшей конфигурации сервера</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.serverconfig.netmodel">Сетевая модель</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.serverconfig.netmodel.reqresp">Запросы и отклики</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.netmodel.credcache">Кэширование клиентской идентификационной информации</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.serverconfig.svnserve">Собственный сервер svnserve</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.invoking">Запуск Сервера</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.auth">Встроенная аутентификация и авторизация</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.auth.users">Создание файла пользователей и область хранилища </a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.auth.general">Установка контроля доступа</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.sshauth">SSH идентификация и авторизация</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.sshtricks">Трюки конфигурирования SSH</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.sshtricks.setup">Начальная настройка</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.sshtricks.fixedcmd">Controlling the invoked command</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.serverconfig.httpd">httpd, the Apache HTTP server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.serverconfig.httpd.prereqs">Prerequisites</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.httpd.basic">Basic Apache Configuration</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.httpd.authn">Authentication Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authn.basic">Basic HTTP Authentication</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authn.sslcerts">SSL Certificate Management</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.serverconfig.httpd.authz">Authorization Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authz.blanket">Blanket Access Control</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authz.perdir">Per-Directory Access Control</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authz.pathauthzoff">Disabling Path-based Checks</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.serverconfig.httpd.extra">Extra Goodies</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.httpd.extra.browsing">Repository Browsing</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.extra.other">Other Features</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.serverconfig.pathbasedauthz">Path-Based Authorization</a></span></dt><dt><span class="sect1"><a href="#svn.serverconfig.multimethod">Supporting Multiple Repository Access Methods</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn.customization">7. Профессиональная настройка Subversion</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.advanced.confarea">Параметры времени выполнения</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.confarea.layout">Структура области конфигурации</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.confarea.windows-registry">Конфигурация и реестр Windows</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.confarea.opts">Параметры конфигурации</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.advanced.confarea.opts.servers">Servers</a></span></dt><dt><span class="sect3"><a href="#svn.advanced.confarea.opts.config">Config</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.advanced.l10n">Localization</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.l10n.understanding">Understanding locales</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.l10n.svnuse">Subversion's use of locales</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.externaldifftools">Using External Differencing Tools</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.externaldifftools.diff">External diff</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.externaldifftools.diff3">External diff3</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#svn.developer">8. Информация для разработчиков</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.developer.layerlib">Layered Library Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.developer.layerlib.repos">Repository Layer</a></span></dt><dt><span class="sect2"><a href="#svn.developer.layerlib.ra">Repository Access Layer</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.dav">RA-DAV (Repository Access Using HTTP/DAV)</a></span></dt><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.svn">RA-SVN (Custom Protocol Repository Access)</a></span></dt><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.local">RA-Local (Direct Repository Access)</a></span></dt><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.yours">Your RA Library Here</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.developer.layerlib.client">Client Layer</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.developer.usingapi">Using the APIs</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.developer.usingapi.apr">The Apache Portable Runtime Library</a></span></dt><dt><span class="sect2"><a href="#svn.developer.usingapi.urlpath">URL and Path Requirements</a></span></dt><dt><span class="sect2"><a href="#svn.developer.usingapi.otherlangs">Using Languages Other than C and C++</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.developer.insidewc">Inside the Working Copy Administration Area</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.developer.insidewc.entries">The Entries File</a></span></dt><dt><span class="sect2"><a href="#svn.developer.insidewc.base-and-props">Pristine Copies and Property Files</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.developer.webdav">WebDAV</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn.ref">9. Полное справочное руководство по Subversion</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.ref.svn">Клиент командной строки Subversion:
      <span class="command"><strong>svn</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svn.sw">Параметры командной строки<span class="command"><strong>svn</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.ref.svn.c">Подкоманды <span class="command"><strong>svn</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.add">svn add</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.blame">svn blame</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.cat">svn cat</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.checkout">svn checkout</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.cleanup">svn cleanup</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.commit">svn commit</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.copy">svn copy</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.delete">svn delete</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.diff">svn diff</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.export">svn export</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.help">svn help</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.import">svn import</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.info">svn info</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.list">svn list</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.lock">svn lock</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.log">svn log</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.merge">svn merge</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.mkdir">svn mkdir</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.move">svn move</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propdel">svn propdel</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propedit">svn propedit</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propget">svn propget</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.proplist">svn proplist</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propset">svn propset</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.resolved">svn resolved</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.revert">svn revert</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.status">svn status</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.switch">svn switch</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.unlock">svn unlock</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.update">svn update</a></span><span class="refpurpose"></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnadmin"><span class="command"><strong>svnadmin</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svnadmin.sw"><span class="command"><strong>svnadmin</strong></span> Switches</a></span></dt><dt><span class="sect2"><a href="#svn.ref.svnadmin.c"><span class="command"><strong>svnadmin</strong></span> Subcommands</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.create">svnadmin create</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.deltify">svnadmin deltify</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.dump">svnadmin dump</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.help">svnadmin help</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.hotcopy">svnadmin hotcopy</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.list-dblogs">svnadmin list-dblogs</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.list-unused-dblogs">svnadmin list-unused-dblogs</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.load">svnadmin load</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.lslocks">svnadmin lslocks</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.lstxns">svnadmin lstxns</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.recover">svnadmin recover</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.rmlocks">svnadmin rmlocks</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.rmtxns">svnadmin rmtxns</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.setlog">svnadmin setlog</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.verify">svnadmin verify</a></span><span class="refpurpose"></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnlook"><span class="command"><strong>svnlook</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svnlook.sw"><span class="command"><strong>svnlook</strong></span> Switches</a></span></dt><dt><span class="sect2"><a href="#svn.ref.svnlook.c"><span class="command"><strong>svnlook</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.author">svnlook author</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.cat">svnlook cat</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.changed">svnlook changed</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.date">svnlook date</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.diff">svnlook diff</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.dirs-changed">svnlook dirs-changed</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.help">svnlook help</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.history">svnlook history</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.info">svnlook info</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.lock">svnlook lock</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.log">svnlook log</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.propget">svnlook propget</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.proplist">svnlook proplist</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.tree">svnlook tree</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.uuid">svnlook uuid</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.youngest">svnlook youngest</a></span><span class="refpurpose"></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnserve"><span class="command"><strong>svnserve</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svnserve.sw"><span class="command"><strong>svnserve</strong></span> Switches</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnversion"><span class="command"><strong>svnversion</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnversion.re">svnversion</a></span><span class="refpurpose"></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.ref.mod_dav_svn"><span class="command"><strong>mod_dav_svn</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.mod_dav_svn.conf"><code class="literal">mod_dav_svn</code> Configuration
        Directives</a></span><span class="refpurpose"></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.ref.properties">Свойства Subversion</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnprops">Свойства Subversion</a></span><span class="refpurpose"></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#svn.intro">A. Быстрый старт в Subversion</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.intro.install">Установка Subversion</a></span></dt><dt><span class="sect1"><a href="#svn.intro.quickstart">Быстрый старт в Subversion</a></span></dt></dl></dd><dt><span class="appendix"><a href="#svn.forcvs">B. Subversion для пользователей CVS</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.forcvs.revnums">Revision Numbers Are Different Now</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.directories">Directory Versions</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.disconnected">More Disconnected Operations</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.status-vs-update">Distinction Between Status and Update</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.forcvs.status-vs-update.status">Status</a></span></dt><dt><span class="sect2"><a href="#svn.forcvs.status-vs-update.update">Update</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.forcvs.branches-and-tags">Branches and Tags</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.properties">Metadata Properties</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.conflicts">Conflict Resolution</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.binary-and-trans">Binary Files and Translation</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.modules">Versioned Modules</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.auth">Authentication</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.convert">Converting a Repository from CVS to Subversion</a></span></dt></dl></dd><dt><span class="appendix"><a href="#svn.webdav">C. WebDAV и автоматическое управление версиями</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn.webdav.basic">Basic WebDAV Concepts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.webdav.basic.original">Original WebDAV</a></span></dt><dt><span class="sect2"><a href="#svn.webdav.basic.deltav">DeltaV Extensions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.webdav.svn-and-deltav">Subversion and DeltaV</a></span></dt><dt><span class="sect1"><a href="#svn.webdav.autoversioning">Autoversioning</a></span></dt><dt><span class="sect1"><a href="#svn.webdav.clients">Client Interoperability</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.webdav.clients.standalone">Standalone WebDAV applications</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.webdav.clients.standalone.windows">Microsoft Office, Dreamweaver, Photoshop</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.standalone.free">Cadaver, DAV Explorer</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.webdav.clients.file-explorer-extensions">File-explorer WebDAV extensions</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.webdav.clients.file-explorer-extensions.windows">Microsoft Web Folders</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.file-explorer-extensions.linux-de">Nautilus, Konqueror</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.webdav.clients.fs-impl">WebDAV filesystem implementation</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.webdav.clients.fs-impl.windows">WebDrive, NetDrive</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.fs-impl.macosx">Mac OS X</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.fs-impl.linux">Linux davfs2</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="appendix"><a href="#svn.3rdparty">D. Инструменты от сторонних разработчиков</a></span></dt><dt><span class="appendix"><a href="#svn.copyright">E. Copyright</a></span></dt><dt><span class="index"><a href="#svn.index">Предметный указатель</a></span></dt><dt><span class="glossary"><a href="#svn.glossary.ru">Русский глоссарий</a></span></dt></dl></div><div class="list-of-figures"><p><strong>Список иллюстраций</strong></p><dl><dt>1. <a href="#svn.intro.architecture.dia-1">Архитектура Subversion</a></dt><dt>1.1. <a href="#svn.basic.repository.dia-1">Типичная клиент/серверная система</a></dt><dt>1.2. <a href="#svn.basic.vsn-models.problem-sharing.dia-1">Проблема потери изменений</a></dt><dt>1.3. <a href="#svn.basic.vsn-models.lock-unlock.dia-1">Модель блокирование-изменение-разблокирование</a></dt><dt>1.4. <a href="#svn.basic.vsn-models.copy-merge.dia-1">Модель копирование-изменение-слияние</a></dt><dt>1.5. <a href="#svn.basic.vsn-models.copy-merge.dia-2">Модель копирование-изменение-слияние (продолжение)</a></dt><dt>1.6. <a href="#svn.basic.in-action.wc.dia-1">Файловая система хранилища</a></dt><dt>1.7. <a href="#svn.basic.in-action.revs.dia-1">Хранилище</a></dt><dt>4.1. <a href="#svn.branchmerge.whatis.dia-1">Ветки разработки</a></dt><dt>4.2. <a href="#svn.branchmerge.using.dia-1">Начальная структура хранилища</a></dt><dt>4.3. <a href="#svn.branchmerge.using.create.dia-1">Хранилище, содержащее новую копию</a></dt><dt>4.4. <a href="#svn.branchmerge.using.work.dia-1">История ветвления для одного файла</a></dt><dt>8.1. <a href="#svn.developer.layerlib.repos.dia-1">Files and directories in two dimensions</a></dt><dt>8.2. <a href="#svn.developer.layerlib.repos.dia-2">Versioning time—the third dimension!</a></dt></dl></div><div class="list-of-tables"><p><strong>Список таблиц</strong></p><dl><dt>1.1. <a href="#svn.basic.in-action.wc.tbl-1">URL для доступа к хранилищу.</a></dt><dt>5.1. <a href="#svn.reposadmin.basics.backends.tbl-1">Repository Data Store Comparison</a></dt><dt>6.1. <a href="#svn.serverconfig.overview.tbl-1">Сравнение серверов</a></dt><dt>8.1. <a href="#svn.developer.layerlib.tbl-1">A Brief Inventory of the Subversion Libraries</a></dt><dt>C.1. <a href="#svn.webdav.clients.tbl-1">Common WebDAV Clients</a></dt></dl></div><div class="list-of-examples"><p><strong>Список примеров</strong></p><dl><dt>5.1. <a href="#svn.reposadmin.maint.cleanup.ex-1">txn-info.sh (Reporting Outstanding Transactions)</a></dt><dt>6.1. <a href="#svn.serverconfig.httpd.authz.perdir.ex-1">A sample configuration for anonymous access.</a></dt><dt>6.2. <a href="#svn.serverconfig.httpd.authz.perdir.ex-2">A sample configuration for authenticated access.</a></dt><dt>6.3. <a href="#svn.serverconfig.httpd.authz.perdir.ex-3">A sample configuration for mixed
            authenticated/anonymous access.</a></dt><dt>6.4. <a href="#svn.serverconfig.httpd.authz.pathauthzoff.ex-1">Disabling path checks altogether</a></dt><dt>7.1. <a href="#svn.advanced.confarea.windows-registry.ex-1">Пример указания параметров в (.reg) файле реестра.</a></dt><dt>7.2. <a href="#svn.advanced.externaldifftools.diff.ex-1">diffwrap.sh</a></dt><dt>7.3. <a href="#svn.advanced.externaldifftools.diff.ex-2">diffwrap.bat</a></dt><dt>7.4. <a href="#svn.advanced.externaldifftools.diff3.ex-1">diff3wrap.sh</a></dt><dt>7.5. <a href="#svn.advanced.externaldifftools.diff3.ex-2">diff3wrap.bat</a></dt><dt>8.1. <a href="#svn.developer.layerlib.repos.ex-1">Using the Repository Layer</a></dt><dt>8.2. <a href="#svn.developer.usingapi.otherlangs.ex-1">Using the Repository Layer with Python</a></dt><dt>8.3. <a href="#svn.developer.usingapi.otherlangs.ex-2">A Python Status Crawler</a></dt><dt>8.4. <a href="#svn.developer.insidewc.entries.ex-1">Contents of a Typical <code class="filename">.svn/entries</code>
          File</a></dt></dl></div><div class="preface" title="Предисловие"><div class="titlepage"><div><div><h2 class="title"><a id="svn.foreword"></a>Предисловие</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Карл</span> <span class="surname">Фогель</span></h3></div></div><div><p class="pubdate">Чикаго, 14 марта 2004 г.</p></div></div></div><p>Скверный список ответов на часто задаваемые вопросы (ЧаВо)
    состоит не из тех вопросов, которые были заданы на самом деле,
    а из тех, на которые автору такого списка <span class="emphasis"><em>хотелось
      бы</em></span> дать ответ. Вы наверняка сталкивались с чем-то
    подобным:</p><div class="blockquote"><blockquote class="blockquote"><p>ВОПРОС: Как Glorbosoft XYZ поможет поднять
      производительность труда наших сотрудников?</p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>ОТВЕТ: Многие наши клиенты хотят знать, как поднять
      производительность труда при помощи наших патентованных офисных
      инноваций для коллективной работы. Ответ простой: выберите меню
      <span class="quote">«<span class="quote"><code class="literal">Файл</code></span>»</span> и перейдите к пункту
        <span class="quote">«<span class="quote"><code class="literal">Поднять&nbsp;производительность</code></span>»</span>,
      затем…</p></blockquote></div><p>Проблема подобных ЧаВо заключается в том, что они вовсе не
    являются ответами на <span class="emphasis"><em>часто задаваемые</em></span> вопросы
    в буквальном смысле. Какой нормальный человек будет звонить в
    службу технической поддержки и спрашивать: <span class="quote">«<span class="quote">как нам поднять
      производительность труда</span>»</span>? Вопросы, которые обычно звучат
    в таких случаях, узко специализированы, например: <span class="quote">«<span class="quote">Как
      настроить календарь для отправки напоминаний за два дня вместо
      одного?</span>»</span>. Однако, создать список якобы заданных вопросов
    намного проще, чем подобрать настоящие вопросы из реальной жизни.
    Такая работа требует упорства и организованности: вопросы,
    возникающие в процессе жизненного цикла программного продукта, и
    ответы на них должны бережно сохраняться и систематизироваться,
    пока на их основе не будет создано логически связанное и удобное
    для поиска единое целое, наилучшим образом отражающее опыт
    пользователей. Здесь требуется терпеливость и внимательность,
    присущие естествоиспытателю, а не великие гипотезы и провидческие
    заявления. Главное в этой работе — открытые глаза и
    аккуратное отношение к записям в блокноте.</p><p>В этой книге мне больше всего нравится то, что она именно так
    и была написана, и это заметно на каждой её странице. Она является
    непосредственным результатом общения авторов с пользователями.
    Книга началась с того, что Бен Коллинз-Сассман как-то раз заметил
    в рассылке Subversion, что пользователи всё время задают одни и те
    же вопросы: какого порядка действий следует придерживаться при
    работе с Subversion; есть ли отличия от других систем управления
    версиями при работе с ветками и метками; как узнать, кем было
    выполнено то или иное изменение?</p><p>Устав от ежедневного просмотра одних и тех же вопросов, Бен
    провёл месяц в напряжённой работе, и летом 2002 года появилось
    <em class="citetitle">Руководство по Subversion</em> — документ, в
    котором на 60 страницах описывались все основные приёмы работы с
    Subversion. Это руководство не претендовало на полноту, но оно
    было включено в поставку Subversion и помогало преодолеть
    начинающим пользователям первые трудности, с которыми они
    сталкивались. После того, как издательство O'Reilly and Associates
    решило выпустить полноценную книгу о Subversion, путь наименьшего
    сопротивления был очевиден: нужно было просто расширить
    <em class="citetitle">Руководство по Subversion</em>.</p><p>Таким образом, три соавтора новой книги получили необычную
    возможность. С одной стороны, перед ними была поставлена задача
    написать книгу в обычном смысле слова, от автора к читателю,
    начиная с содержания и первого черновика. Но, с другой стороны, у
    них также была возможность обращаться у устойчивому
    потоку — да что там говорить, к неуправляемому
    фонтану — материалу, поступающему от будущих читателей.
    Subversion уже был в то время в руках тысяч первых пользователей,
    которые давали множество отзывов не только о самом Subversion, но
    и о документации к нему.</p><p>Пока шла работа над книгой, Бен, Майк и Брайан постоянно
    отслеживали рассылки и чаты, скрупулёзно отмечая проблемы, с
    которыми пользователи сталкивались в реальных жизненных ситуациях.
    Мониторинг подобных отзывов входил в их служебные обязанности в
    CollabNet, но в данном случае эта работа оказалась неоценимой при
    подготовке документации к Subversion. В основу написанной ими
    книги положен твёрдый фундамент опыта, а не зыбучие пески принятия
    желаемого за действительное; в этой книге соединяются лучшие
    качества руководства пользователя и списка ЧаВо. Эта
    двойственность может быть незаметна при первом прочтении книги.
    При чтении книги по порядку, от корки до корки, создаётся
    ощущение, что перед нами прямолинейное описание программного
    продукта. Нам предлагают общий обзор, непременный в таких случаях
    вводный курс, главу по администрированию, несколько тем для
    продвинутых пользователей и, само собой, справочник по командам и
    способы устранения проблем.  Лишь возвращаясь к этой книге снова и
    снова, вы сможете оценить её самобытность: отличительные
    подробности, которые могут появиться лишь при встрече с
    неожиданными ситуациями, примеры, взятые из жизни и, самое
    главное, внимательность к нуждам пользователей и их точке
    зрения.</p><p>Конечно, никто не может пообещать, что эта книга ответит на
    все ваши вопросы о Subversion. Иногда точность, с которой книга
    предвосхищает ваши вопросы, может показаться телепатической, но
    вполне может случиться и так, что вы столкнётесь с пробелом в
    коллективном знании сообщества и уйдёте с пустыми руками. Лучшее,
    что можно сделать в такой ситуации — отправить письмо на адрес
    <code class="email">&lt;<a class="email" href="mailto:users@subversion.tigris.org">users@subversion.tigris.org</a>&gt;</code> с описанием вашей
    проблемы. Авторы по-прежнему читают эту рассылку, они внимательно
    наблюдают за вопросами, и, кроме того, сообщество пользователей не
    ограничивается тремя людьми, имена которых вынесены на обложку
    этой книги — многие подписчики рассылки также помогают вносить
    исправления и предлагают новый материал для книги. С точки зрения
    сообщества, решение вашей конкретной проблемы — это лишь
    приятный побочный эффект значительно более обширного проекта, а
    именно, постепенного исправления данной книги и самого Subversion
    с тем, чтобы как можно ближе соответствовать практике. Эти люди с
    удовольствием выслушают вас не только потому, что могут помочь, но
    и потому, что вы можете помочь им. При работе с Subversion, как и
    с любым другим бурно развивающимся свободным программным
    обеспечением, <span class="emphasis"><em>вы не будете чувствовать себя
      одиноким</em></span>.</p><p>Пусть эта книга будет вашим верным помощником.</p></div><div class="preface" title="Об этой книге"><div class="titlepage"><div><div><h2 class="title"><a id="svn.preface"></a>Об этой книге</h2></div></div></div><div class="toc"><p><strong>Содержание</strong></p><dl><dt><span class="sect1"><a href="#svn.preface.audience">Для кого написана эта книга?</a></span></dt><dt><span class="sect1"><a href="#svn.preface.howread">Как читать эту книгу?</a></span></dt><dt><span class="sect1"><a href="#svn.preface.conventions">Соглашения, принятые в книге</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.preface.conventions.typo">Типографские соглашения</a></span></dt><dt><span class="sect2"><a href="#svn.preface.conventions.icons">Пиктограммы</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.preface.organization">Структура книги</a></span></dt><dt><span class="sect1"><a href="#svn.preface.free">Эта книга распространяется свободно</a></span></dt><dt><span class="sect1"><a href="#svn.preface.acks">Благодарности</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.preface.acks.sussman">От Ben Collins-Sussman</a></span></dt><dt><span class="sect2"><a href="#svn.preface.acks.fitz">От Brian W. Fitzpatrick</a></span></dt><dt><span class="sect2"><a href="#svn.preface.acks.cmpilato">От C. Michael Pilato</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.intro.whatis">Что такое Subversion?</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.intro.history">История Subversion</a></span></dt><dt><span class="sect2"><a href="#svn.intro.features">Возможности Subversion</a></span></dt><dt><span class="sect2"><a href="#svn.intro.architecture">Архитектура Subversion</a></span></dt><dt><span class="sect2"><a href="#svn.intro.components">Компоненты Subversion</a></span></dt></dl></dd></dl></div><div class="blockquote"><table class="blockquote" summary="Block quote" width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="top" width="10%">&nbsp;</td><td valign="top" width="80%"><p><span class="quote">«<span class="quote">It is important not to let the perfect become the
      enemy of the good, even when you can agree on what perfect is.
      Doubly so when you can't.  As unpleasant as it is to be trapped by
      past mistakes, you can't make any progress by being afraid of your
      own shadow during design.</span>»</span></p></td><td valign="top" width="10%">&nbsp;</td></tr><tr><td valign="top" width="10%">&nbsp;</td><td colspan="2" valign="top" align="right">--<span class="attribution">Greg Hudson</span></td></tr></tbody></table></div><p>
    <a id="idp129200" class="indexterm"></a>
    <a id="idp130288" class="indexterm"></a>

  
    В мире программного обеспечения с открытым исходным кодом в
    качестве инструмента управления версиями долгое время
    использовалась Concurrent Versions System<sup>[<a id="idp6751936" href="#ftn.idp6751936" class="footnote">1</a>]</sup> (CVS). На
    это были свои причины. CVS сама по себе является свободным
    программным обеспечением, на работу с ней не накладывается
    ограничений, а поддержка сетевых возможностей позволяет десяткам
    географически разделённых программистов работать
    совместно — всё это отлично подходит для мира свободного
    программного обеспечения, отличающегося духом сотрудничества. CVS
    и её полубеспорядочная модель разработки стали краеугольными
    камнями культуры свободного программного обеспечения.</p><p>Но и у CVS есть свои недочеты, которые уже давно всем надоели.
    Здесь на сцене и появляется Subversion. Творцы Subversion
    стремятся завоевать сердца пользователей CVS сразу с двух сторон:
    во-первых, Subversion создаётся как система с открытым исходным
    кодом, которая по своему устройству и ощущениям от работы напоминает
    CVS, а во-вторых, она пытается исправить наиболее очевидные
    недостатки CVS. И хотя то, что получается в результате, не
    обязательно является новым витком в развитии технологий управления
    версиями, Subversion <span class="emphasis"><em>на самом деле</em></span> очень
    мощное, удобное и гибкое средство. Сегодня едва ли не все новые
    проекты с открытым исходным кодом вместо CVS выбирают Subversion.</p><p>Эта книга описывает систему управления версиями Subversion
    поколения 1.4. Мы стремились охватить материал как можно шире.
    В то же время следует иметь в виду, что разработкой Subversion
    занимается активное энергичное сообщество, так что уже сейчас идёт
    работа над рядом особенностей и улучшений, которые будут внесены в
    последующие версии Subversion. Эти нововведения могут привести к
    некоторым расхождениям между командами и соответствующими
    пояснениями в тексте книги.</p><div class="sect1" title="Для кого написана эта книга?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.preface.audience"></a>Для кого написана эта книга?</h2></div></div></div><p>Эта книга написана для людей, которые владеют знаниями о
      компьютерах и хотят использовать Subversion для управления
      данными. Subversion может работать на разных операционных
      системах, но основным интерфейсом для взаимодействия с ней
      является командная строка. Инструмент для командной строки
      (<span class="command"><strong>svn</strong></span>) и ряд вспомогательных программ, это
      именно то, чему посвящена эта книга.</p><p>Для линейности изложения примеры в книге подразумевают, что
      читатель пользуется Unix-подобной операционной системой и относительно
      свободно чувствует себя с Unix и интерфейсом командной строки.
      Однако, программа <span class="command"><strong>svn</strong></span> работает и на
      других платформах, например в Microsoft Windows. Ввод и вывод этой
      программы в Windows и Unix практически идентичны, за исключением
      незначительных различий, вроде использования символа обратной
      косой черты (<code class="literal">\</code>) вместо прямой косой
      (<code class="literal">/</code>) в качестве разделителя компонентов пути к
      файлу.</p><p>Многие наши читатели — программисты или системные
      администраторы, испытывающие потребность отслеживать изменения
      в исходном коде. Такое использование Subversion является самым
      распространённым и положено в основу всех примеров в этой книге.
      Однако, Subversion можно использовать для управления информацией
      самого разного рода: графика, музыка, базы данных, документация
      — этот список можно продолжать до бесконечности. Для Subversion
      любые данные — это просто данные.</p><p>С одной стороны, мы писали книгу для читателя, который никогда не
      пользовался системами управления версиями ранее, а с другой пытались
      облегчить переход на Subversion пользователям CVS (и других систем).
      По мере необходимости, в тексте книги встречаются специальные врезки,
      посвященные другим системам управления версиями, а обзор основных
      различий между CVS и Subversion вынесен в отдельное приложение.</p><p>Обратите внимание, что примеры исходного кода являются всего
      лишь примерами. Хотя они и могут быть собраны с помощью
      определённых заклинаний для компилятора, в тексте книги они
      приводятся для иллюстрации соответствующей проблемы и не
      обязательно служат примером хорошего стиля
      программирования.</p></div><div class="sect1" title="Как читать эту книгу?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.preface.howread"></a>Как читать эту книгу?</h2></div></div></div><p>Книга предназначена для людей с самым разным уровнем
      подготовки — от новичков, не имевших дела с управлением
      версиями ранее, до опытных системных администраторов. Важность
      той или иной главы для читателя будет зависеть от уровня его подготовки.
      Приведём наши рекомендации для разных групп читателей:</p><div class="variablelist"><dl><dt><span class="term">Опытные системные администраторы</span></dt><dd><p>Предполагается, что читатели этой группы раннее уже
            использовали систему управления версиями и теперь им не терпится
            поднять сервер Subversion как можно скорее.
            В <a class="xref" href="#svn.reposadmin" title="Глава 5. Администрирование хранилища">Глава&nbsp;5, <em>Администрирование хранилища</em></a>
            и <a class="xref" href="#svn.serverconfig" title="Глава 6. Настройка сервера">Глава&nbsp;6, <em>Настройка сервера</em></a> показано, как
            создать первое хранилище и сделать его доступным в сети.
            Далее можно перейти к изучению клиента Subversion, причём чтение
            <a class="xref" href="#svn.tour" title="Глава 2. Экскурсия по Subversion">Глава&nbsp;2, <em>Экскурсия по Subversion</em></a> и <a class="xref" href="#svn.forcvs" title="Приложение B. Subversion для пользователей CVS">Приложение&nbsp;B, <em>Subversion для пользователей CVS</em></a>
            будет наиболее быстрым путём к цели.</p></dd><dt><span class="term">Новички</span></dt><dd><p>По-видимому, администратор уже установил Subversion в
            сети и вам необходимо научиться пользоваться клиентом. Если
            вы раньше не пользовались системой управления версиями,
            то <a class="xref" href="#svn.basic" title="Глава 1. Фундаментальные понятия">Глава&nbsp;1, <em>Фундаментальные понятия</em></a> будет необходимым введением.
            А <a class="xref" href="#svn.tour" title="Глава 2. Экскурсия по Subversion">Глава&nbsp;2, <em>Экскурсия по Subversion</em></a> содержит основные сведения о клиенте
            Subversion.</p></dd><dt><span class="term">Продвинутые пользователи</span></dt><dd><p>Рано или поздно ваш проект будет разрастаться, и тогда,
            независимо от того, администратор вы или пользователь, вам
            потребуется узнать, как делать в Subversion более сложные
            вещи: использовать ветки и осуществлять слияния (<a class="xref" href="#svn.branchmerge" title="Глава 4. Ветвление и слияние">Глава&nbsp;4, <em>Ветвление и слияние</em></a>), работать со свойствами 
            (<a class="xref" href="#svn.advanced" title="Глава 3. Профессиональное использование Subversion">Глава&nbsp;3, <em>Профессиональное использование Subversion</em></a>), настраивать рабочую среду
            (<a class="xref" href="#svn.advanced" title="Глава 3. Профессиональное использование Subversion">Глава&nbsp;3, <em>Профессиональное использование Subversion</em></a>) и т.д. Эти главы не являются
            важными в самом начале работы, но их следует прочесть, когда
            вы разберётесь с основами.</p></dd><dt><span class="term">Разработчики</span></dt><dd><p>Предполагается, что вы уже знакомы с Subversion и хотите
            либо расширить её, либо создать новое программное
            обеспечение на основе её многочисленных
            API<sup>[<a id="idp6822224" href="#ftn.idp6822224" class="footnote">2</a>]</sup>. Что ж,
            <a class="xref" href="#svn.developer" title="Глава 8. Информация для разработчиков">Глава&nbsp;8, <em>Информация для разработчиков</em></a> написана именно для вас.</p></dd></dl></div><p>Книга завершается справочным материалом — <a class="xref" href="#svn.ref" title="Глава 9. Полное справочное руководство по Subversion">Глава&nbsp;9, <em>Полное справочное руководство по Subversion</em></a> представляет собой справочное руководство
      по всем командам Subversion, а несколько полезных тем раскрыто в
      приложениях. К этим разделам вы скорее всего будете обращаться
      уже после прочтения книги.</p></div><div class="sect1" title="Соглашения, принятые в книге"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.preface.conventions"></a>Соглашения, принятые в книге</h2></div></div></div><p>В этом разделе приводятся соглашения, принятые в книге.</p><div class="sect2" title="Типографские соглашения"><div class="titlepage"><div><div><h3 class="title"><a id="svn.preface.conventions.typo"></a>Типографские соглашения</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><span class="command"><strong>Моноширинный шрифт</strong></span></span></dt><dd><p>Используется для записи команд, результатов их
              выполнения и параметров командной строки.</p></dd><dt><span class="term"><em class="replaceable"><code>Моноширинный шрифт с курсивом</code></em></span></dt><dd><p>Используется в коде и тексте для обозначения
              подлежащих замене элементов.</p></dd><dt><span class="term"><code class="filename">Курсив</code></span></dt><dd><p>Используется для имён файлов и каталогов.</p></dd></dl></div></div><div class="sect2" title="Пиктограммы"><div class="titlepage"><div><div><h3 class="title"><a id="svn.preface.conventions.icons"></a>Пиктограммы</h3></div></div></div><div class="note" title="Примечание" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Примечание]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/note.png"></td><th align="left">Примечание</th></tr><tr><td valign="top" align="left"><p>Замечание, относящееся к окружающему тексту.</p></td></tr></tbody></table></div><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>Полезный совет, относящийся к окружающему тексту.</p></td></tr></tbody></table></div><div class="warning" title="Предупреждение" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Предупреждение]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/warning.png"></td><th align="left">Предупреждение</th></tr><tr><td valign="top" align="left"><p>Предупреждение, относящееся к окружающему тексту.</p></td></tr></tbody></table></div></div></div><div class="sect1" title="Структура книги"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.preface.organization"></a>Структура книги</h2></div></div></div><p>Приведём краткий обзор содержания отдельных глав книги.</p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="#svn.preface" title="Об этой книге">Об этой книге</a></span></dt><dd><p>В этой главе приводятся сведения об истории
              Subversion, обсуждаются её возможности, архитектура и
              компоненты.</p></dd><dt><span class="term"><a class="xref" href="#svn.basic" title="Глава 1. Фундаментальные понятия">Глава&nbsp;1, <em>Фундаментальные понятия</em></a></span></dt><dd><p>Глава объясняет основы управления версиями, в ней
              разбираются различные модели работы с версиями, а также
              рассказано о хранилищах, рабочих копиях и правках в
              Subversion.</p></dd><dt><span class="term"><a class="xref" href="#svn.tour" title="Глава 2. Экскурсия по Subversion">Глава&nbsp;2, <em>Экскурсия по Subversion</em></a></span></dt><dd><p>Один день из жизни пользователя Subversion. Глава
              поясняет, как использовать клиент Subversion для получения
              данных, внесения в них изменений и фиксации изменённых
              данных в хранилище.</p></dd><dt><span class="term"><a class="xref" href="#svn.advanced" title="Глава 3. Профессиональное использование Subversion">Глава&nbsp;3, <em>Профессиональное использование Subversion</em></a></span></dt><dd><p>Рассматриваются сложные вопросы, с которыми постоянные
              пользователи рано или поздно столкнутся. Например,
              версионирование метаданных, блокирование файлов и
              peg revisions.</p></dd><dt><span class="term"><a class="xref" href="#svn.branchmerge" title="Глава 4. Ветвление и слияние">Глава&nbsp;4, <em>Ветвление и слияние</em></a></span></dt><dd><p>В этой главе рассматриваются ветки, метки и слияния,
              показаны эффективные методы выполнения ветвлений и
              слияний, приводятся типичные примеры использования этих
              возможностей, а также даются сведения об отмене внесённых
              изменений. Глава также показывает, как легко переключиться
              с одной ветки на другую.</p></dd><dt><span class="term"><a class="xref" href="#svn.reposadmin" title="Глава 5. Администрирование хранилища">Глава&nbsp;5, <em>Администрирование хранилища</em></a></span></dt><dd><p>В главе рассматриваются основные особенности хранилища
              Subversion, включая использование инструментов для
              создания, настройки и поддержки хранилища.</p></dd><dt><span class="term"><a class="xref" href="#svn.serverconfig" title="Глава 6. Настройка сервера">Глава&nbsp;6, <em>Настройка сервера</em></a></span></dt><dd><p>В этой главе показано, как настроить сервер
              Subversion. Здесь же рассматриваются три способа
              организации доступа к хранилищу: <code class="literal">HTTP</code>,
              протокол <code class="literal">svn</code> и локальный доступ. Кроме
              того, в главе уделяется внимание вопросам установления
              личности, проверки прав доступа и организации анонимного
              доступа к хранилищу.</p></dd><dt><span class="term"><a class="xref" href="#svn.customization" title="Глава 7. Профессиональная настройка Subversion">Глава&nbsp;7, <em>Профессиональная настройка Subversion</em></a></span></dt><dd><p>В этой главе подробно рассмотрены файлы для настройки
              клиента Subversion, обработка текста на национальнных языках и
              совместная работа Subversion с программами сторонних
              разработчиков.</p></dd><dt><span class="term"><a class="xref" href="#svn.developer" title="Глава 8. Информация для разработчиков">Глава&nbsp;8, <em>Информация для разработчиков</em></a></span></dt><dd><p>В этой главе обсуждается внутреннее устройство
              Subversion, файловая система Subversion и служебные
              области рабочей копии с точки зрения программиста. Здесь
              же разбирается использование открытых API для написания
              программ, использующих Subversion, а также приводится
              информация о том, как вы можете внести вклад в разработку
              Subversion.</p></dd><dt><span class="term"><a class="xref" href="#svn.ref" title="Глава 9. Полное справочное руководство по Subversion">Глава&nbsp;9, <em>Полное справочное руководство по Subversion</em></a></span></dt><dd><p>Глава подробно объясняет использование всех подкоманд
              <span class="command"><strong>svn</strong></span>, <span class="command"><strong>svnadmin</strong></span> и
              <span class="command"><strong>svnlook</strong></span>. Все пояснения сопровождаются
              множеством примеров.</p></dd><dt><span class="term"><a class="xref" href="#svn.intro" title="Приложение A. Быстрый старт в Subversion">Приложение&nbsp;A, <em>Быстрый старт в Subversion</em></a></span></dt><dd><p>Для самых нетерпеливых, ураганное описание того, как
              установить и немедленно приступить к использованию
              Subversion. Мы вас предупредили.</p></dd><dt><span class="term"><a class="xref" href="#svn.forcvs" title="Приложение B. Subversion для пользователей CVS">Приложение&nbsp;B, <em>Subversion для пользователей CVS</em></a></span></dt><dd><p>В приложении рассматриваются сходства и различия между
              Subversion и CVS, приводится ряд рекомендаций, позволяющих
              избавиться от вредных привычек, приобретённых с годами
              работы с CVS. Здесь также приводится информация
              о нумерации правок в Subversion, рассказывается о возможности
              управления версиями для каталогов, приводятся сведения об
              автономных операциях, ветках, метках и метаданных,
              поясняется различие между подкомандами
              <span class="command"><strong>update</strong></span> и <span class="command"><strong>status</strong></span>,
              затронуты вопросы, связанные с разрешением конфликтов и
              установлением личности пользователя.</p></dd><dt><span class="term"><a class="xref" href="#svn.webdav" title="Приложение C. WebDAV и автоматическое управление версиями">Приложение&nbsp;C, <em>WebDAV и автоматическое управление версиями</em></a></span></dt><dd><p>Это приложение подробно рассматривает WebDAV и DeltaV
              и показывает, как настроить хранилище Subversion для
              подключения в виде совместно используемого ресурса
              DAV.</p></dd><dt><span class="term"><a class="xref" href="#svn.3rdparty" title="Приложение D. Инструменты от сторонних разработчиков">Приложение&nbsp;D, <em>Инструменты от сторонних разработчиков</em></a></span></dt><dd><p>Здесь представлены некоторые программы, которые
              используют Subversion в своей работе, включая
              клиенты от сторонних производителей, инструменты для
              просмотра содержимого хранилища и другие программы.</p></dd></dl></div></div><div class="sect1" title="Эта книга распространяется свободно"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.preface.free"></a>Эта книга распространяется свободно</h2></div></div></div><p>Эта книга начиналась с фрагментов документации, написанных
      разработчиками проекта Subversion, которые затем были собраны в
      единое целое и отредактированы. Поэтому, она всегда будет
      распространяться на условиях свободной лицензии (см. <a class="xref" href="#svn.copyright" title="Приложение E. Copyright">Приложение&nbsp;E, <em>Copyright</em></a>.) Фактически, книга писалась у всех на
      виду, как часть Subversion, что означает две вещи:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Вы всегда можете найти самую последнюю версию книги в
          хранилище Subversion, созданном специально для неё.</p></li><li class="listitem"><p>Вы можете распространять эту книгу и вносить в неё
          изменения по своему усмотрению — лицензия на
          использование книги является свободной. От вас требуется только
          ссылаться в качестве первоисточника на первоначальных авторов.
          Конечно, будет лучше всего, если вместо того, чтобы распространять
          собственную версию книги, вы поделитесь отзывами и исправлениями с
          сообществом разработчиков Subversion.</p></li></ul></div><p>Достаточно свежую версию этой книги можно взять в Интернете
      по адресу <a class="ulink" href="http://svnbook.red-bean.com/" target="_top">http://svnbook.red-bean.com</a>.</p></div><div class="sect1" title="Благодарности"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.preface.acks"></a>Благодарности</h2></div></div></div><p>Этой книги не было б (или была б не столь полезна), если б не
      было Subversion. Поэтому, авторы хотят поблагодарить Brian
      Behlendorf и CollabNet за их решение финансировать такой
      рискованный и амбициозный проект; Jim Blandy за оригинальное
      название и дизайн Subversion — мы любим тебя, Jim; Karl
      Fogel за то, что ты хороший друг и великолепный лидер нашего
      сообщества.<sup>[<a id="idp6906992" href="#ftn.idp6906992" class="footnote">3</a>]</sup></p><p>Благодарим издательство O'Reilly и наших редакторов, Linda
      Mui и Tatiana Diaz за их терпение и поддержку.</p><p>Наконец, мы благодарим всех тех людей, которые участвовали
      в создании этой книги своими обзорами, мнениями и исправлениями:
      Без сомнения, это далеко не полный список людей, без помощи
      которых эта книга была бы неполной и неточной: David Anderson,
      Jani Averbach, Ryan Barrett, Francois Beausoleil, Jennifer
      Bevan, Matt Blais, Zack Brown, Martin Buchholz, Brane Cibej,
      John R. Daily, Peter Davis, Olivier Davy, Robert P. J. Day, Mo
      DeJong, Brian Denny, Joe Drew, Nick Duffek, Ben Elliston, Justin
      Erenkrantz, Shlomi Fish, Julian Foad, Chris Foote, Martin
      Furter, Dave Gilbert, Eric Gillespie, David Glasser, Matthew
      Gregan, Art Haas, Eric Hanchrow, Greg Hudson, Alexis Huxley,
      Jens B. Jorgensen, Tez Kamihira, David Kimdon, Mark Benedetto
      King, Andreas J. Koenig, Nuutti Kotivuori, Matt Kraai, Scott
      Lamb, Vincent Lefevre, Morten Ludvigsen, Paul Lussier, Bruce
      A. Mah, Philip Martin, Feliciano Matias, Patrick Mayweg, Gareth
      McCaughan, Jon Middleton, Tim Moloney, Christopher Ness, Mats
      Nilsson, Joe Orton, Amy Lyn Pilato, Kevin Pilch-Bisson, Dmitriy
      Popkov, Michael Price, Mark Proctor, Steffen Prohaska, Daniel
      Rall, Jack Repenning, Tobias Ringstrom, Garrett Rooney, Joel
      Rosdahl, Christian Sauer, Larry Shatzer, Russell Steicke, Sander
      Striker, Erik Sjoelund, Johan Sundstroem, John Szakmeister,
      Mason Thomas, Eric Wadsworth, Colin Watson, Alex Waugh, Chad
      Whitacre, Josef Wolf, Blair Zajac,  а также всё сообщество 
      Subversion.</p><div class="sect2" title="От Ben Collins-Sussman"><div class="titlepage"><div><div><h3 class="title"><a id="svn.preface.acks.sussman"></a>От Ben Collins-Sussman</h3></div></div></div><p>Благодарю мою жену Frances, которая много месяцев вместо
        обычного <span class="quote">«<span class="quote">Дорогая, я ещё пишу e-mail</span>»</span> слышала
        <span class="quote">«<span class="quote">Дорогая, я ещё работаю над книгой</span>»</span>. Я представить
        не могу, откуда у неё столько терпения! Она — великолепный
        противовес моему трудоголизму.</p><p>Благодарю всю мою родню и друзей за их искреннюю поддержку,
        несмотря на отсутствие у них настоящего интереса к моему занятию.
        (Ну, вы знаете, они говорят <span class="quote">«<span class="quote">О, ты пишешь книгу?</span>»</span>,
        а когда ты говоришь, что это — компьютерная книга, они сразу
        теряют весь интерес).</p><p>Благодарю всех моих близких друзей, сделавших меня очень
        богатым человеком. Не смотрите на меня так, вы же знаете, кто
        вы.</p><p>Thanks to my parents for the perfect low-level formatting,
        and being unbelievable role models.  Thanks to my son for the
        opportunity to pass that on.</p></div><div class="sect2" title="От Brian W. Fitzpatrick"><div class="titlepage"><div><div><h3 class="title"><a id="svn.preface.acks.fitz"></a>От Brian W. Fitzpatrick</h3></div></div></div><p>Огромное спасибо моей жене Marie за её невероятные
        понимание, поддержку и, прежде всего, терпение. Спасибо моему
        брату Eric, который познакомил меня с программированием под
        UNIX. Огромная благодарность моим Маме и Бабушке за всю их
        поддержку, а так же за то, что не вспоминают, как я на Рождество
        пришёл домой и с головой залез в свой ноутбук и работал над
        книгой.</p><p>Mike и Ben: было очень приятно работать над книгой вместе
        с вами. Heck, было приятно работать с тобой на работе!</p><p>Всем членам сообщества Subversion и "Apache Software
        Foundation" — спасибо за то, что был с вами. Не было дня,
        чтоб я не научился чему-нибудь у кого-нибудь из вас.</p><p>Наконец, спасибо моему дедушке, который всегда говорил
        <span class="quote">«<span class="quote">свобода равна ответственности</span>»</span>. Я не могу не
        согласиться с этим.</p></div><div class="sect2" title="От C. Michael Pilato"><div class="titlepage"><div><div><h3 class="title"><a id="svn.preface.acks.cmpilato"></a>От C. Michael Pilato</h3></div></div></div><p>Отдельное спасибо моей жене, Amy, за её любовь, терпение,
        поддержку, за понимание поздними ночами, за то, что читала
        все разделы этой книги — ты всегда делала больше, чем
        требовалось, и делала это с невероятным изяществом. Gavin, когда
        ты дорастёшь до прочтения этой книги, я надеюсь, ты будешь
        гордиться своим отцом также, как он сейчас гордится тобой. Мама
        и папа (а также вся моя семья), спасибо вам за вашу постоянную
        поддержку и энтузиазм.</p><p>Снимаю шляпу перед Shep Kendall, который открыл для меня
        мир компьютеров; перед Ben Collins-Sussman, моим проводником
        по миру свободного программного обеспечения; перед Karl Fogel
        — <span class="emphasis"><em>вы</em></span> мой <code class="filename">.emacs</code>;
        перед Greg Stein, за помощь в программировании; перед Brian
        Fitzpatrick — за получение писательского опыта с тобой.
        Многим людям, от которых я постоянно узнаю что-то новое —
        будьте такими всегда!</p><p>Наконец, Тому, кто великолепно продемострировал венец
        творения — спасибо тебе.</p></div></div><div class="sect1" title="Что такое Subversion?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.intro.whatis"></a>Что такое Subversion?</h2></div></div></div><p>Subversion — это бесплатная система управления версиями с
      открытым исходным кодом. Subversion позволяет управлять файлами и
      каталогами, а так же сделанными в них изменениями во времени. Это 
      позволяет восстановить более ранние версии данных, даёт возможность
      изучить историю всех изменений. Благодаря этому многие считают систему
      управления версиями своего рода <span class="quote">«<span class="quote">машиной времени</span>»</span>.</p><p>Subversion может работать через сеть, что позволяет
      использовать её на разных компьютерах. В какой то степени, возможность
      большого количества людей не зависимо от их местоположения совместно
      работать над единым комплектом данных поощряет сотрудничество. Когда
      нет того ответственного звена цепи, того контролирующего элемента,
      который утверждает все изменения, работа становится более эффективной.
      При этом не нужно опасаться, что отказ от контролирующего элемента
      повлияет на качество, ведь благодаря сохранению истории изменений,
      даже если при изменении данных будут допущены ошибки, всегда можно
      сделать откат изменений к прежнему состоянию.</p><p>Некоторые системы управления версиями выступают также в
      качестве систем управления конфигурацией программного обеспечения
      (SCM<sup>[<a id="idp6954704" href="#ftn.idp6954704" class="footnote">4</a>]</sup>). Такие системы специально созданы для
      управления деревьями исходного кода и имеют множество особенностей,
      непосредственно относящихся к разработке программ: они понимают языки
      программирования и предоставляют инструменты для сборки программ.
      Subversion не является такой системой, она представляет собой систему
      общего назначения, которую можно использовать для управления
      <span class="emphasis"><em>любым</em></span> набором файлов. Для Вас это будут исходники
      Ваших программ, а для кого-то другого это будет список продуктов или
      сведённое цифровое видео.</p><div class="sect2" title="История Subversion"><div class="titlepage"><div><div><h3 class="title"><a id="svn.intro.history"></a>История Subversion</h3></div></div></div><p>
        <a id="idp6963120" class="indexterm"></a>

      
        В начале 2000 года компания CollabNet, Inc. (<a class="ulink" href="http://www.collab.net/" target="_top">http://www.collab.net</a>) начала поиск людей для написания
        системы, способной заменить CVS. CollabNet предлагает комплекс
        программных средств для совместной работы, известный под названием
        CollabNet Enterprise Edition (CEE) <sup>[<a id="idp6965328" href="#ftn.idp6965328" class="footnote">5</a>]</sup>, одним из
        составляющих которого является срество для управления версиями.
        В качестве такого средства в CEE использовалась CVS, хотя её недостатки
        были очевидны с самого начала, и для CollabNet было ясно, что рано или
        поздно придётся искать замену. К сожалению, CVS стала стандартом
        <span class="foreignphrase"><em class="foreignphrase">де-факто</em></span> в мире открытого программного
        обеспечения, причём по той лишь причине, что ничего лучшего в то время
        <span class="emphasis"><em>не существовало</em></span>, по крайней мере среди программ со
        свободной лицензией. И тогда CollabNet решила написать новую систему
        управления версиями с нуля, сохранив основные идеи CVS, но без ошибок и
        неудобств, присущих CVS.</p><p>В феврале 2000 года CollabNet связалась с автором книги
        <em class="citetitle">Open Source Development with CVS</em>
        <sup>[<a id="idp6971504" href="#ftn.idp6971504" class="footnote">6</a>]</sup> Карлом Фогелем [Karl Fogel] и
        предложила ему принять участие в этом новом проекте. Самое интересное
        то, что Карл как раз тогда уже обсуждал проект новой системы управления
        версиями со своим другом Джимом Блэнди [Jim Blandy]. Ещё в 1995 году
        они создали компанию Cyclic Software, которая занималась поддержкой
        пользователей CVS, и хотя позднее этот бизнес был продан, друзья
        продолжали использовать CVS в повседневной работе. Их разочарование в
        CVS привело Джима к обдумыванию улучшения принципов управления
        версиями. Впоследствии Джим не только придумал название
        <span class="quote">«<span class="quote">Subversion</span>»</span>, но и разработал основные принципы устройства
        хранилища Subversion. Карл сразу согласился на предложение CollabNet, а
        работодатель Джима, RedHat Software, пожертвовал своим сотрудником для
        этого проекта, предоставив ему возможность работать над Subversion в
        течение неограниченного времени. CollabNet взяла на работу Карла и Бена
        Коллинза-Сассмана [Ben Collins-Sussman], и в мае началась работа по
        проектированию системы. Благодаря нескольким интуитивно точным шагам,
        предпринятых Брайаном Белендорфом [Brian Behlendorf] и Джейсоном
        Роббинсом [Jason Robbins] из CollabNet и Грегом Стайном, на тот момент
        независимым разработчиком, активно участвующим в создании спецификации
        WebDAV/DeltaV, вокруг Subversion быстро образовалось сообщество
        активных разработчиков. Оказалось, что многие люди испытывали похожее
        чувство разочарования от CVS, и они  с радостью приветствовали
        появившуюся, наконец, возможность изменить положение вещей.</p><p>Стартовый коллектив разработчиков решил остановиться на достижении
        ряда простых целей. Они не собирались изобретать велосипед в подходах к
        управлению версиями, скорее им просто хотелось исправить CVS. Этот
        коллектив решил, что Subversion должна соответствовать CVS  по набору
        возможностей, сохранить ту же самую модель разработки и избежать
        недостатков CVS. Хотя перед ними не стояла задача сделать систему,
        полностью идентичную CVS, было ясно, что Subverion должна быть похожа
        на CVS, чтобы любой пользователь CVS мог перейти на новую систему без
        особых затруднений.</p><p>И вот, 31 августа 2001 года, спустя четырнадцать месяцев с начала
        работы, команда прекратила использовать CVS и перешла на Subversion для
        управления версиями собственного исходного кода — Subversion
        стала <span class="quote">«<span class="quote">самодостаточной</span>»</span>.</p><p>Хотя CollabNet стоит у истоков проекта и продолжает финансировать
        основную часть работы, оплачивая полный рабочий день нескольких ведущих
        разработчиков, Subversion развивается подобно большинству проектов с
        открытым исходным кодом, управляясь свободным и прозрачным набором
        правил, поощряющих меритократию. Лицензия CollabNet полностью
        соответствует принципам свободного программного обеспечения Debian
        — любой человек может устанавливать, изменять и распространять
        Subversion так, как ему заблагорассудится; для этого не требуется
        разрешения ни от CollabNet, ни от кого-либо ещё.</p></div><div class="sect2" title="Возможности Subversion"><div class="titlepage"><div><div><h3 class="title"><a id="svn.intro.features"></a>Возможности Subversion</h3></div></div></div><p>Обсуждать возможности Subversion удобнее всего в разрезе
        её улучшений по сравнению с CVS. Суть некоторых рассматриваемых
        здесь возможностей может быть не совсем понятна читателям, которые
        плохо знакомы с CVS. Если же вы совсем не имеете представления об
        управлении версиями, то вам лучше сначала прочитать <a class="xref" href="#svn.basic" title="Глава 1. Фундаментальные понятия">главу
      2, «Основные понятия»</a>, где
        даётся доступное введение в управление версиями.
      </p><p>Subversion предоставляет следующие возможности:</p><div class="variablelist"><dl><dt><span class="term">Контроль изменений каталогов</span></dt><dd><p>CVS следит только за историей отдельных файлов, тогда
                как Subversion использует <span class="quote">«<span class="quote">виртуальную</span>»</span>
                файловую систему с возможностями управления версиями,
                которая способна отслеживать изменения во времени целых
                структур каталогов. Под управление версиями попадают и файлы,
                <span class="emphasis"><em>и</em></span> каталоги.</p></dd><dt><span class="term">Настоящая история версий</span></dt><dd><p>CVS контролирует лишь изменения файлов, поэтому
              такие операции, как копирование и переименование, хотя и
              относящиеся к файлам, но по существу являющиеся изменениями
              каталогов, содержащих эти файлы, в CVS не поддерживаются.
              Кроме того, в CVS вы не можете заменить файл, помещённый под
              управление версиями, другим файлом с тем же именем, но
              совершенно иным содержанием, возможно никак не связанным со
              старым объектом, без наследования таким элементом всей
              истории изменений. Subversion делает возможным добавление,
              удаление, копирование и переименование как файлов, так и
              каталогов. При этом каждый вновь добавленный файл начинает
              жизнь с чистого листа, сохраняя собственную историю
              изменений.</p></dd><dt><span class="term">Атомарная фиксация изменений</span></dt><dd><p>Каждый набор изменений либо попадает в хранилище
              целиком, либо не попадает туда вовсе. Это позволяет
              разработчикам создавать и фиксировать изменения логически
              оправданными кусками, предотвращая тем самым проблемы,
              которые могут возникать в тех случаях, когда только часть
              необходимых изменений помещается в хранилище успешно.</p></dd><dt><span class="term">Метаданные с версиями</span></dt><dd><p>Каждый файл и каталог имеет собственный набор свойств,
              представленных в виде названия и значения. Вы можете
              создавать и сохранять любые необходимые пары названий
              свойств и их значений. Свойства файлов точно так же
              находятся под управлением версиями, как и их
              содержимое.</p></dd><dt><span class="term">Выбор средств доступа к хранилищу по сети</span></dt><dd><p>В Subversion используется абстракция доступа к
              хранилищу, что позволяет реализовывать самые разные сетевые
              механизмы доступа. Subversion может быть подключена к
              серверу HTTP Apache в виде модуля, что даёт ей огромное
              преимущество с точки зрения устойчивости работы и способности
              к взаимодействию, а также предоставляет прямой доступ к
              существующим возможностям этого сервера, включая
              установление личности, проверку прав доступа и сжатие
              информации при передаче. Кроме того, имеется лёгкий
              самостоятельный сервер Subversion, который использует
              собственный протокол взаимодействия с клиентами и может
              легко туннелировать данные через SSH.</p></dd><dt><span class="term">Единый способ работы с данными</span></dt><dd><p>Subversion обнаруживает различия между файлами с помощью
              специального бинарного алгоритма, который одинаково работает
              как с текстовыми, так и с бинарными файлами. Файлы
              записываются в хранилище в сжатом виде независимо от их
              типа, а различия между отдельными версиями могут
              передаваться по сети в обоих направлениях.</p></dd><dt><span class="term">Эффективные ветки и метки</span></dt><dd><p>Плата за использование веток и меток не должна быть
              пропорциональна размеру проекта. Subversion создаёт ветки и
              метки путём простого копирования проекта, используя
              механизм, похожий на жёсткие ссылки в файловых системах.
              Благодаря этому, операции по созданию веток и меток занимают
              немного времени.
            </p></dd><dt><span class="term">Дружелюбность по отношению к разработчикам</span></dt><dd><p>Subversion не имеет исторического багажа. Она
              реализована в виде набора динамических библиотек на языке C,
              API которых хорошо известен. Это делает Subversion
              чрезвычайно удобной для сопровождения системой, пригодной
              для взаимодействия с другими приложениями и языками
              программирования.</p></dd></dl></div></div><div class="sect2" title="Архитектура Subversion"><div class="titlepage"><div><div><h3 class="title"><a id="svn.intro.architecture"></a>Архитектура Subversion</h3></div></div></div><p>Общий взгляд на устройство Subversion показан на <a class="xref" href="#svn.intro.architecture.dia-1" title="Рисунок 1. Архитектура Subversion">рисунке 1.1, «Архитектура
        Subversion»</a>.</p><div class="figure"><a id="svn.intro.architecture.dia-1"></a><p class="title"><strong>Рисунок 1. Архитектура Subversion</strong></p><div class="figure-contents"><div><img src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/ch01dia1.png" alt="Архитектура Subversion"></div></div></div><br class="figure-break"><br><p>На одной стороне схемы изображено хранилище Subversion, в
        котором хранится информация с версиями. На противоположной стороне
        показана программа-клиент Subversion, которая управляет локальными
        отражениями различных фрагментов этих данных (также называемыми
        <span class="quote">«<span class="quote">рабочими копиями</span>»</span>). Между этими сторонами проложены
        различные маршруты, проходящие через разные слои доступа к
        хранилищу<sup>[<a id="idp7032832" href="#ftn.idp7032832" class="footnote">7</a>]</sup>. Некоторые из этих маршрутов
        используют компьютерные сети и сетевые сервера, чтобы достичь
        хранилища, в то время как другие маршруты в сети не нуждаются и
        ведут к хранилищу напрямую.</p></div><div class="sect2" title="Компоненты Subversion"><div class="titlepage"><div><div><h3 class="title"><a id="svn.intro.components"></a>Компоненты Subversion</h3></div></div></div><p>Установленная Subversion имеет несколько компонентов.
        Ниже приводится краткий обзор того, что вы получаете. Не тревожьтесь,
        если краткие описания заставляют вас чесать затылок, в этой книге есть
        еще <span class="emphasis"><em>много</em></span> страниц, посвященных облегчению
        вашего замешательства.
      </p><div class="variablelist"><dl><dt><span class="term">svn</span></dt><dd><p>Клиент с интерфейсом командной строки.</p></dd><dt><span class="term">svnversion</span></dt><dd><p>Программа, показывающая состояние (в пределах ревизий
              существующих элементов) рабочей копии.</p></dd><dt><span class="term">svnlook</span></dt><dd><p>Инструмент прямого управления хранилищем Subversion.</p></dd><dt><span class="term">svnadmin</span></dt><dd><p>Инструмент для создания, настройки или восстановления
              хранилища Subversion.</p></dd><dt><span class="term">svndumpfilter</span></dt><dd><p>Программа для фильтрации дамповых потоков
              хранилища Subversion.</p></dd><dt><span class="term">mod_dav_svn</span></dt><dd><p>Подключаемый модуль для HTTP-сервера Apache, использующийся
              для предоставления сетевого доступа к вашему хранилищу.</p></dd><dt><span class="term">svnserve</span></dt><dd><p>Собственный отдельный сервер, запускаемый как
              процесс-демон и доступный посредством SSH; еще один способ
              для предоставления сетевого доступа к хранилищу.</p></dd><dt><span class="term">svnsync</span></dt><dd><p>Программа для последовательного зеркалирования
              одного хранилища в другое через сеть.</p></dd></dl></div><p>При условии корректно установленной Subversion вы готовы к старту.
        Следующие две главы описывают использование <span class="command"><strong>svn</strong></span> — 
        CLI-клиента Subversion.</p></div></div><div class="footnotes"><br><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.idp6751936" href="#idp6751936" class="para">1</a>] </sup>Система
    параллельного управления версиями</p></div><div class="footnote"><p><sup>[<a id="ftn.idp6822224" href="#idp6822224" class="para">2</a>] </sup>Application Program
            Interface, интерфейс прикладного
            программирования</p></div><div class="footnote"><p><sup>[<a id="ftn.idp6906992" href="#idp6906992" class="para">3</a>] </sup>Да, и спасибо, Karl, за твой
      трудоголизм при написании этой книги.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp6954704" href="#idp6954704" class="para">4</a>] </sup>Software Configuration
          Management</p></div><div class="footnote"><p><sup>[<a id="ftn.idp6965328" href="#idp6965328" class="para">5</a>] </sup>Кроме того, еще
        существует CollabNet Team Edition (CTE), предназначенный в основном
        для небольших команд разработчиков.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp6971504" href="#idp6971504" class="para">6</a>] </sup><span class="quote">«<span class="quote">Разработка программн с открытым исходным кодом с
          помощью CVS</span>»</span></p></div><div class="footnote"><p><sup>[<a id="ftn.idp7032832" href="#idp7032832" class="para">7</a>] </sup>Repository Access (RA)
            layers</p></div></div></div><div class="chapter" title="Глава 1. Фундаментальные понятия"><div class="titlepage"><div><div><h2 class="title"><a id="svn.basic"></a>Глава 1. Фундаментальные понятия</h2></div></div></div><div class="toc"><p><strong>Содержание</strong></p><dl><dt><span class="sect1"><a href="#svn.basic.repository">Хранилище</a></span></dt><dt><span class="sect1"><a href="#svn.basic.vsn-models">Модели версионирования</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.basic.vsn-models.problem-sharing">Проблема разделения файлов</a></span></dt><dt><span class="sect2"><a href="#svn.basic.vsn-models.lock-unlock">Модель Блокирование-Изменение-Разблокирование</a></span></dt><dt><span class="sect2"><a href="#svn.basic.vsn-models.copy-merge">Модель Копирование-Изменение-Слияние</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.basic.in-action">Subversion в действии</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.reposurls">URL хранилища в Subversion</a></span></dt><dt><span class="sect2"><a href="#svn.basic.in-action.wc">Рабочие копии</a></span></dt><dt><span class="sect2"><a href="#svn.basic.in-action.revs">Правки</a></span></dt><dt><span class="sect2"><a href="#svn.basic.in-action.track-repos">Как рабочие копии отслеживают хранилище</a></span></dt><dt><span class="sect2"><a href="#svn.basic.in-action.mixedrevs">Смешивание правок в рабочих копиях</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.update-commit">Обновления и фиксации отделены друг от друга</a></span></dt><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.normal">Смешивание правок — это нормально</a></span></dt><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.useful">Смешивание правок — это полезно</a></span></dt><dt><span class="sect3"><a href="#svn.basic.in-action.mixedrevs.limits">Смешивание правок имеет ограничения</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.basic.summary">Подводя итоги</a></span></dt></dl></div><p>Эта глава представляет собой краткое, промежуточное введение
    в Subversion. Если управление версиями для вас в новинку, то эта глава
    специально для вас. Мы начнем с обсуждения основных понятий
    управления версиями, подойдем к основным идеям, лежащим в основе Subversion
    и покажем несколько простых примеров использования Subversion.</p><p>Несмотря на то, что примеры в этой главе показывают людей,
    разделяющих между собой набор исходных кодов программ, помните, что
    Subversion может управлять набором файлов любого типа — она не
    ограничивается помощью компьютерным программистам.</p><div class="sect1" title="Хранилище"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.basic.repository"></a>Хранилище</h2></div></div></div><p>Subversion является централизованной системой для совместного использования
      информации. В свой основе это хранилище, являющееся центром хранения
      данных. Хранилище содержит информацию в форме
      <em class="firstterm">дерева файлов</em> — типичном
      представлении файлов и каталогов. Любое количество
      <em class="firstterm">клиентов</em> подключается к хранилищу и
      читает или записывает эти файлы. Записывая данные, клиент
      делает информацию доступной для остальных; читая данные,
      клиент получает информацию от других. <a class="xref" href="#svn.basic.repository.dia-1" title="Рисунок 1.1. Типичная клиент/серверная система">Рисунок&nbsp;1.1, «Типичная клиент/серверная система»</a> иллюстрирует это.</p><div class="figure"><a id="svn.basic.repository.dia-1"></a><p class="title"><strong>Рисунок 1.1. Типичная клиент/серверная система</strong></p><div class="figure-contents"><div><img src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/ch02dia1.png" alt="Типичная клиент/серверная система"></div></div></div><br class="figure-break"><br><p>Почему мы заостряем на этом внимание? Пока это звучит как
      определение типичного файл-сервера. И действительно, хранилище
      <span class="emphasis"><em>является</em></span> разновидностью файл-сервера, однако не
      совсем обычного. Что делает хранилище Subversion особенным — это то,
      что он <span class="emphasis"><em>запоминает каждое внесенное изменение</em></span>:
      любое изменение любого файла, равно как изменения в самом дереве
      каталогов, такие как добавление, удаление и реорганизация файлов и
      каталогов.</p><p>При чтении данных из хранилища клиент обычно видит только
      последнюю версию дерева файлов. Но клиент также имеет возможность
      просмотреть <span class="emphasis"><em>предыдущие</em></span> состояния файловой системы.
      Например, клиент может запросить такие данные как, <span class="quote">«<span class="quote">Что
      содержал этот каталог в прошлую среду?</span>»</span> или <span class="quote">«<span class="quote">Кто
      был последним изменявшим этот файл и какие вносились изменения?</span>»</span>
      Вопросы подобного типа являются основополагающими для любой <em class="firstterm">системы
      управления версиями</em> — системы, разработанной для записи и
      отслеживания изменений информации во времени.
    </p></div><div class="sect1" title="Модели версионирования"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.basic.vsn-models"></a>Модели версионирования</h2></div></div></div><p>Основной задачей системы управления версиями является
      обеспечение совместного редактирования и использования информации.
      Однако разные системы используют разные способы для
      достижения этой цели. Очень важно понимать отличия между этими способами.
      Во-первых, это поможет сравнить и сопоставить существующие системы
      управления версиями, в случае, если вы столкнетесь с другими системами, 
      подобными Subversion. Кроме того, впоследствии это поспособствует и более
      эфективному использованию Subversion, так как эта система поддерживает
      несколько различных способов работы.
    </p><div class="sect2" title="Проблема разделения файлов"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.vsn-models.problem-sharing"></a>Проблема разделения файлов</h3></div></div></div><p>Всем системам управления версиями приходится решать одну и ту же
        основную проблему: как предоставить пользователям возможность
        совместного использования информации, при этом не позволяя им
        наступать друг другу на пятки? Дело в том, что пользователи запросто могут 
        случайно перезаписать в хранилище изменения, сделанные друг другом.</p><p>Рассматриваемую ситуацию иллюстрирует <a class="xref" href="#svn.basic.vsn-models.problem-sharing.dia-1" title="Рисунок 1.2. Проблема потери изменений">Рисунок&nbsp;1.2, «Проблема потери изменений»</a>.
        Допустим, у нас есть два
        соразработчика — Гарри и Салли. Каждый из них решил
        одновременно отредактировать один и тот же файл из хранилища.
        Если первым свои изменения в хранилище сохранит Гарри, то
        возможно, что (несколькими минутами позже) Салли может
        непреднамеренно перезаписать их своей новой версией файла.
        Несмотря на то, что версия файла Гарри не будет полностью потеряна
        (так как система помнит каждое изменение), внесенные Гарри изменения
        <span class="emphasis"><em>не будут </em></span>отражены в новой версии файла Салли,
        потому что, начиная, она не видела изменения Гарри. Работа Гарри
        фактически потеряна — или, по крайней мере, отсутствует в
        последней версии файла — по случайности. Как раз этой ситуации
        мы и хотим избежать!</p><div class="figure"><a id="svn.basic.vsn-models.problem-sharing.dia-1"></a><p class="title"><strong>Рисунок 1.2. Проблема потери изменений</strong></p><div class="figure-contents"><div><img src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/ch02dia2.png" alt="Проблема потери изменений"></div></div></div><br class="figure-break"><br></div><div class="sect2" title="Модель Блокирование-Изменение-Разблокирование"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.vsn-models.lock-unlock"></a>Модель Блокирование-Изменение-Разблокирование</h3></div></div></div><p>Для того, чтобы несколько авторов не мешало работать друг другу,
        многие системы управления версиями применяют модель
        <em class="firstterm">блокирование-изменение-разблокирование</em>.
        Эта модель запрещает одновременное редактирование файла несколькими
        пользователями. Эксклюзивность доступа гарантируется блокировками.
        Перед началом редактирования Гарри должен <span class="quote">«<span class="quote">заблокировать</span>»</span>
        файл. Если Гарри заблокирует файл, Салли уже не сможет
        его заблокировать и внести свои изменения.
        Ей остается только читать файл и ждать, пока Гарри закончит свои
        изменения и снимет блокировку. Лишь после того, как Гарри разблокирует
        файл, Салли сможет получить его, заблокировать и начать
        редактирование. <a class="xref" href="#svn.basic.vsn-models.lock-unlock.dia-1" title="Рисунок 1.3. Модель блокирование-изменение-разблокирование">Рисунок&nbsp;1.3, «Модель блокирование-изменение-разблокирование»</a>
        демонстрирует это простое решение.</p><div class="figure"><a id="svn.basic.vsn-models.lock-unlock.dia-1"></a><p class="title"><strong>Рисунок 1.3. Модель блокирование-изменение-разблокирование</strong></p><div class="figure-contents"><div><img src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/ch02dia3.png" alt="Модель блокирование-изменение-разблокирование"></div></div></div><br class="figure-break"><br><p>Проблемой модели блокирование-изменение-разблокирование
        является то, что она немного ограниченная и часто доставляет
        неудобства пользователям:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>Блокирование может вызвать проблемы
            администрирования.</em></span>

            Иногда Гарри может заблокировать файл, а затем забыть об этом.
            Между тем, ожидая редактирования файла, у Салли будут
            связаны руки. А Гарри тем временем уехал в отпуск. Теперь Салли,
            для снятия блокировки Гарри, нужно обращаться к администратору.
            Ситуация заканчивается не нужной задержкой и потерянным
            временем.</p></li><li class="listitem"><p><span class="emphasis"><em>Блокирование может вызвать излишнюю
            пошаговость.</em></span>

            Вполне вероятна ситуация, когда Гарри редактирует начало текстового файла, 
            а Салли нужно отредактировать концовку этого же файла? Эти изменения совсем не
            перекрываются. Они могли бы легко редактировать файл одновременно,
            и при условии корректного слияния изменений это не вызвало бы никаких
            особенных проблем. Нет никакой необходимости блокировать файл в такой ситуации.</p></li><li class="listitem"><p><span class="emphasis"><em>Блокирование может вызвать ложное чувство
            безопасности.</em></span>

            Предположим, что Гарри блокирует и редактирует файл А, в
            то время как Салли одновременно блокирует и редактирует
            файл В. Но допустим, что А и В зависят друг от друга и
            сделанные в каждом изменения семантически не совместимы.
            Неожиданно А и В больше не работают вместе. Блокирующая система
            бессильна в предотвращении проблемы — вместо этого она
            обеспечила ложное чувство безопасности. Для Гарри и Салли
            просто вообразить, что, блокируя файлы каждый начинает безопасную
            изолированную задачу и не беспокоиться об обсуждении их
            несовместимых изменений заранее. Зачастую, блокирование подменяет
            настоящее общение.</p></li></ul></div></div><div class="sect2" title="Модель Копирование-Изменение-Слияние"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.vsn-models.copy-merge"></a>Модель Копирование-Изменение-Слияние</h3></div></div></div><p>Subversion, CVS и ряд других систем управления версиями
        в качестве альтернативы блокированию пользуются моделью
        <em class="firstterm">копирование-изменение-слияние</em>. В этой модели 
        каждый пользовательский клиент 
        связывается с хранилищем проекта и создает персональную
        <em class="firstterm">рабочую копию</em> — локальное отражение
        файлов и каталогов хранилища. После этого пользователи работают
        одновременно и независимо друг от друга, изменяя свои личные
        копии. В конце концов, личные копии сливаются в новую, итоговую
        версию. Обычно система управления версиями помогает в слиянии, но, 
        разумеется, за его корректное выполнение отвечает человек.</p><p>В качестве примера предположим, что Гарри и Салли создали рабочие 
      	копии одного и того же проекта, скопировав их из хранилища. Они работают
        одновременно и в своих рабочих копиях вносят изменения в один и
        тот же файл А. Первой свои изменения в хранилище сохраняет
        Салли. Когда позже Гарри попытается сохранить свои изменения,
        хранилище проинформирует его о том, что его файл А
        <em class="firstterm">устарел</em>. Другими словами, файл А каким
        то образом изменился со времени, когда он его последний раз
        копировал. Поэтому Гарри просит свой клиент
        <em class="firstterm">слить</em> любые изменения из хранилища
        в его рабочую копию файла А. По счастливому совпадению,
        изменения Салли не перекрываются с его собственными; после
        объединения обоих наборов изменений он сохраняет свою рабочую копию
        обратно в хранилище. <a class="xref" href="#svn.basic.vsn-models.copy-merge.dia-1" title="Рисунок 1.4. Модель копирование-изменение-слияние">Рисунок&nbsp;1.4, «Модель копирование-изменение-слияние»</a> и
        <a class="xref" href="#svn.basic.vsn-models.copy-merge.dia-2" title="Рисунок 1.5. Модель копирование-изменение-слияние (продолжение)">Рисунок&nbsp;1.5, «Модель копирование-изменение-слияние (продолжение)»</a>
        показывают этот процесс.</p><div class="figure"><a id="svn.basic.vsn-models.copy-merge.dia-1"></a><p class="title"><strong>Рисунок 1.4. Модель копирование-изменение-слияние</strong></p><div class="figure-contents"><div><img src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/ch02dia4.png" alt="Модель копирование-изменение-слияние"></div></div></div><br class="figure-break"><br><div class="figure"><a id="svn.basic.vsn-models.copy-merge.dia-2"></a><p class="title"><strong>Рисунок 1.5. Модель копирование-изменение-слияние (продолжение)</strong></p><div class="figure-contents"><div><img src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/ch02dia5.png" alt="Модель копирование-изменение-слияние (продолжение)"></div></div></div><br class="figure-break"><br><p>А что будет, если изменения Салли перекрывают 
        <span class="emphasis"><em>изменения</em></span> Гарри? Что тогда? Эта ситуация
        называется <em class="firstterm">конфликтом</em> и, как правило, это не
        является большой проблемой. Когда Гарри просит свой клиент слить
        последние изменения из хранилища в рабочую копию, его копия файла А
        помечается некоторым образом как находящаяся в состоянии конфликта: у него будет
        возможность видеть оба набора конфликтующих изменений и вручную
        сделать между ними выбор. Помните, что ПО не может автоматически
        разрешать конфликты; только человек способен к пониманию и выполнению
        осмысленного выбора. Разрешив вручную перекрывающиеся изменения —
        возможно, после обсуждения с Салли — он может безопасно сохранить
        объединенный файл обратно в хранилище.</p><p>Модель копирование-изменение-слияние может выглядеть немного
        хаотично, однако, на практике она отлично работает. Пользователи могут
        работать параллельно, не тратя время на ожидание друг друга. При
        работе над одними и теми же файлами оказывается, что большинство
        параллельно вносимых изменений совсем не перекрываются; конфликты
        бывают редко. И время, которое было потрачено на разрешение
        конфликтов, как правило, значительно меньше времени, отнимаемого
        блокирующей системой.</p><p>Наконец, все сходится к такому критическому фактору как
        взаимодействие пользователей. При плохом взаимопонимании увеличивается
        количество как синтаксических, так и семантических конфликтов.
        Нет системы, которая может повысить уровень взаимопонимания, и нет
        системы, которая может определять семантические конфликты. Не стоит
        возлагать большие надежды на то, что блокирующая система лучше
        защищена от конфликтов; на практике блокирование снижает
        продуктивность как ничто другое.</p><div class="sidebar" title="Когда блокирование необходимо"><a id="svn.basic.vsn-models.copy-merge.sb-1"></a><div class="titlepage"><div><div><p class="title"><strong>Когда блокирование необходимо</strong></p></div></div></div><p>Несмотря на то, что модель
          блокирование-изменение-разблокирование названа, в целом, губительной
          для командной работы, все-таки есть моменты, когда блокирование
          уместно.</p><p>Модель копирование-изменение-слияние основывается на
          предположении о том, что файлы контекстно-объединяемы, и оно 
          справедливо, если большинство файлов в хранилище —
          текстовые файлы (например, исходные коды программ). Но для файлов
          бинарных форматов, таких как графические или звуковые, как правило
          невозможно объединить конфликтующие изменения. В таких ситуациях
          пользователям действительно необходимо быть внимательными при
          изменении файла. Без раздельного доступа кто-то может впустую
          потратить время на изменения, которые в конце концов
          будут потеряны.</p><p>Несмотря на то, что Subversion в первую очередь является
          системой типа копирование-изменение-слияние, в ней признается
          необходимость блокирования определенных файлов и предлагаются
          соответствующие механизмы. Подробнее эта возможность рассматривается
          далее в этой книге, см. <a class="xref" href="#svn.advanced.locking" title="Locking">«Locking»</a>.</p></div></div></div><div class="sect1" title="Subversion в действии"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.basic.in-action"></a>Subversion в действии</h2></div></div></div><p>Настало время перейти от абстракций к конкретике. В этом разделе мы покажем
      реальные примеры использования Subversion.</p><div class="sect2" title="URL хранилища в Subversion"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.reposurls"></a>URL хранилища в Subversion</h3></div></div></div><p>В книге для идентификации файлов и директорий в хранилище 
        Subversion применяются URL. В основном, в этих URL используются
        стандартные правила записи, позволяющие указывать имя сервера и
        номер порта как часть URL:</p><pre class="screen">$ svn checkout http://svn.example.com:9834/repos
…
</pre><p>Однако, в обработке URL системой Subversion есть некоторые нюансы, о 
        которых нужно помнить. Например, в соответствии с принятыми 
        соглашениями, URL, использующий метод доступа
        <code class="literal">file:</code> (этот метод доступа используется для 
        локальных хранилищ), должен либо включать имя сервера
        <code class="literal">localhost</code>, либо вообще не содержать имени 
        сервера:</p><pre class="screen">$ svn checkout file:///path/to/repos
…
$ svn checkout file://localhost/path/to/repos
…
</pre><p>Кроме того, тем, кто применяет схему <code class="literal">file:</code> на 
        платформе Windows, необходимо использовать неофициальные
        <span class="quote">«<span class="quote">стандартные</span>»</span> правила записи при обращении к 
        хранилищу, которое находится на одном компьютере, но на разных 
        дисках с клиентом. Обе приведенные ниже записи будут 
        работать; здесь <code class="literal">X</code> — это имя диска, на котором 
        находится хранилище:</p><pre class="screen">C:\&gt; svn checkout file:///X:/path/to/repos
…
C:\&gt; svn checkout "file:///X|/path/to/repos"
…
</pre><p>При второй форме записи для того, чтобы вертикальная черта 
        не расценивалась как канал, необходимо взять URL в кавычки. 
        Также обратите внимание на использование в URL прямого слеша,
        несмотря на то, что родная (не-URL) форма записи пути в 
        Windows использует обратный слеш.</p><p>Ну и наконец, нужно сказать о том, что клиент Subversion 
        при необходимости автоматически кодирует URL точно так же, как 
        это делает веб-браузер. Например, если URL будет содержать пробел или 
        ASCII-символы в верхнем регистре:</p><pre class="screen">$ svn checkout "http://host/path with space/project/españa"
</pre><p>…то Subversion скроет небезопасные символы и будет 
        вести себя так, как будто вы напечатали:</p><pre class="screen">$ svn checkout http://host/path%20with%20space/project/espa%C3%B1a
</pre><p>Если в URL есть пробелы, возьмите его в кавычки, и тогда 
        командная оболочка обработает это все как один аргумент 
        программы <span class="command"><strong>svn</strong></span>.</p></div><div class="sect2" title="Рабочие копии"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.in-action.wc"></a>Рабочие копии</h3></div></div></div><p>Вы уже читали о рабочих копиях; теперь мы покажем как
        клиент Subversion создает и использует их.</p><p>Рабочая копия Subversion представляет собой обычное дерево
        каталогов на вашем компьютере, содержащее набор файлов. Вы можете
        по своему усмотрению редактировать эти файлы и, если это исходные коды,
        вы можете обычным способом скомпилировать из них программу. Ваша рабочая
        копия — это ваше личное рабочее пространство. Subversion как не
        смешивает с вашими изменения, вносимые другими, так и не делает
        доступными для других изменения, сделанные вами, пока вы сами не
        прикажете сделать это. Вы даже можете иметь несколько рабочих копий
        одного и того же проекта.</p><p>После того, как вы внесли изменения в файлы вашей рабочей копии и
        убедились в том, что они корректно работают, Subversion предлагает вам
        команды <span class="quote">«<span class="quote">публикации</span>»</span> (записи в хранилище) ваших
        изменений, в результате чего они станут доступными для всех участников
        проекта. Если другие участники проекта опубликовали свои изменения,
        Subversion предлагает вам команды для объединения (путем чтения
        информации из хранилища) этих изменений с вашей рабочей
        копией.</p><p>Рабочая копия содержит несколько дополнительных файлов, созданных
        и обслуживаемых Subversion, которые помогают ей при выполнении этих
        команд. В частности, каждый каталог в вашей рабочей копии содержит
        подкаталог с именем <code class="filename">.svn</code> который называется
        <em class="firstterm">служебным каталогом</em> рабочей копии.
        Файлы в служебном каталоге помогают Subversion определить
        какие файлы рабочей копии содержат неопубликованные изменения, и какие
        файлы устарели по отношению к файлам других участников.</p><p>Как правило, хранилище Subversion содержит файлы (или исходный
        код) нескольких проектов; обычно каждый проект представляется в виде
        подкаталога файловой системы хранилища. При таком подходе,
        пользовательская рабочая копия обычно соответствует отдельному
        подкаталогу хранилища.</p><p>Например, предположим, что у вас есть хранилище, содержащее два
        программных проекта: <code class="literal">paint</code> и
        <code class="literal">calc</code>. Каждый проект располагается в своем
        собственном каталоге как показано на
        <a class="xref" href="#svn.basic.in-action.wc.dia-1" title="Рисунок 1.6. Файловая система хранилища">Рисунок&nbsp;1.6, «Файловая система хранилища»</a>.</p><div class="figure"><a id="svn.basic.in-action.wc.dia-1"></a><p class="title"><strong>Рисунок 1.6. Файловая система хранилища</strong></p><div class="figure-contents"><div><img src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/ch02dia6.png" alt="Файловая система хранилища"></div></div></div><br class="figure-break"><br><p>Для того, чтобы создать рабочую копию, вам нужно
        <em class="firstterm">получить</em> какой-либо из подкаталогов
        хранилища. (Возможно, термин <em class="firstterm">получить</em>
        звучит как что-то, связанное с блокированием или резервированием
        ресурсов, но это не так; данная команда просто создает для вас личную
        копию проекта.) Например, если вы получите
        <code class="filename">/calc</code>, у вас будет рабочая копия наподобие
        этой:</p><pre class="screen">$ svn checkout http://svn.example.com/repos/calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 56.

$ ls -A calc
Makefile  integer.c  button.c  .svn/
</pre><p>Буквы А говорят о том, что Subversion добавил этот элемент в
        вашу рабочую копию. Теперь у вас есть личная копия каталога
        <code class="filename">/calc</code> хранилища, с одним небольшим добавлением
        — каталогом <code class="filename">.svn</code>, содержащим, как было
        указано выше, дополнительную информацию, необходимую Subversion.</p><div class="sidebar" title="URL хранилища"><a id="svn.basic.in-action.wc.sb-1"></a><div class="titlepage"><div><div><p class="title"><strong>URL хранилища</strong></p></div></div></div><p>Получить доступ к хранилищу Subversion можно различными
          способами — на локальном диске или через ряд сетевых протоколов.
          Местоположение хранилища всегда определяется при помощи URL.
          <a class="xref" href="#svn.basic.in-action.wc.tbl-1" title="Таблица 1.1. URL для доступа к хранилищу.">Таблица&nbsp;1.1, «URL для доступа к хранилищу.»</a>
          показывает соответствие разных URL-схем возможным
          методам доступа.</p><div class="table"><a id="svn.basic.in-action.wc.tbl-1"></a><p class="title"><strong>Таблица 1.1. URL для доступа к хранилищу.</strong></p><div class="table-contents"><table summary="URL для доступа к хранилищу." border="1"><colgroup><col><col></colgroup><thead><tr><th>Схема</th><th>Метод доступа</th></tr></thead><tbody><tr><td><code class="literal">file:///</code></td><td>прямой доступ к хранилищу
                  (на локальном диске)</td></tr><tr><td><code class="literal">http://</code></td><td>доступ через протокол WebDAV (если Subversion-сервер
                работает через Apache)</td></tr><tr><td><code class="literal">https://</code></td><td>то же, что и <code class="literal">http://</code>, но с
                  SSL-шифрованием</td></tr><tr><td><code class="literal">svn://</code></td><td>доступ через собственный протокол к серверу
                  <code class="literal">svnserve</code></td></tr><tr><td><code class="literal">svn+ssh://</code></td><td>то же, что и <code class="literal">svn://</code>, но через
                  SSH-соединение</td></tr></tbody></table></div></div><br class="table-break"><br><p>Подробнее о том, как Subversion обрабатывает URL, см. в
          <a class="xref" href="#svn.advanced.reposurls" title="URL хранилища в Subversion">«URL хранилища в Subversion»</a>.  Подробнее о различных типах
          сетевых серверов, доступных для использования совместно с Subversion,
          см. <a class="xref" href="#svn.serverconfig" title="Глава 6. Настройка сервера">Глава&nbsp;6, <em>Настройка сервера</em></a>.
        </p></div><p>Предположим, вы внесли изменения в <code class="filename">button.c</code>.
        Так как каталог <code class="filename">.svn</code> помнит дату изменения
        файла и его оригинальное содержимое, Subversion может сказать о том,
        что вы изменили файл. Subversion не публикует ваших изменений, пока
        вы не прикажете это сделать. Публикация ваших изменений более известна
        как <em class="firstterm">фиксация</em> (или <em class="firstterm">checking
        in</em>) изменений в хранилище.</p><p>Для того, чтобы опубликовать ваши изменения, вы можете
        воспользоваться командой <span class="command"><strong>commit</strong></span>.</p><pre class="screen">$ svn commit button.c -m "Fixed a typo in button.c."
Sending        button.c
Transmitting file data .
Committed revision 57.
</pre><p>Теперь ваши изменения в <code class="filename">button.c</code>, вместе
        с примечанием, описывающим эти изменения (а именно: исправление
        опечатки), зафиксированы в хранилище; если другой пользователь
        создаст рабочую копию <code class="filename">/calc</code>, он увидит
        ваши изменения в последней версии файла.</p><p>Предположим, у вас есть партнер, Салли, которая
        создала рабочую копию <code class="filename">/calc</code> одновременно
        с вами. Когда вы зафиксировали изменения в
        <code class="filename">button.c</code>, рабочая копия Салли осталась 
        неизмененной, так как Subversion модифицирует рабочие копии только
        по запросу пользователей.</p><p>Для приведения рабочей копии в актуальное состояние Салли
        может попросить Subversion <em class="firstterm">обновить</em> её
        рабочую копию, используя команду Subversion
        <span class="command"><strong>update</strong></span>. Это включит ваши изменения в ее рабочую
        копию, так же как и все другие изменения, зафиксированные после того,
        как она создавала рабочую копию.</p><pre class="screen">$ pwd
/home/sally/calc

$ ls -A
.svn/ Makefile integer.c button.c

$ svn update
U    button.c
Updated to revision 57.
</pre><p>Вывод команды <span class="command"><strong>svn update</strong></span> говорит, что
        Subversion обновила содержимое <code class="filename">button.c</code>.
        Обратите внимание, что Салли не должна указывать, какой файл обновить;
        для определения файлов, которые необходимо привести в актуальное
        состояние, Subversion использует информацию в каталоге
        <code class="filename">.svn</code>, а также информацию из хранилища.</p></div><div class="sect2" title="Правки"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.in-action.revs"></a>Правки</h3></div></div></div><p>Операция <span class="command"><strong>svn commit</strong></span> публикует
        изменения любого количества файлов и каталогов за одну
        атомарную операцию. В своей рабочей копии вы можете менять
        содержимое файлов, создавать, удалять, переименовывать и
        копировать файлы и каталоги, а затем зафиксировать все
        изменения за одну атомарную транзакцию.</p><p>Под <span class="quote">«<span class="quote">атомарной транзакцией</span>»</span> понимается следующее:
        либо в хранилище вносятся все изменения полностью, либо они не вносятся
        вообще. Subversion ведёт себя так, принимая в расчет возможные
        программные сбои, системные сбои, проблемы с сетью, а также
        неверные действия пользователя.</p><p>Каждый раз, когда происходит фиксация, создаётся
        новое состояние файловой системы, которое называется
        <em class="firstterm">правкой</em>. Каждая правка получает
        уникальный номер, на единицу больший номера
        предыдущей правки. Начальная правка только что созданного
        хранилища получает номер 0 и не содержит ничего, кроме
        пустого корневого каталога.</p><p><a class="xref" href="#svn.basic.in-action.revs.dia-1" title="Рисунок 1.7. Хранилище">Рисунок&nbsp;1.7, «Хранилище»</a> отлично
        иллюстрирует хранилище. Представьте массив номеров правок,
        начинающийся с 0, с направлением слева направо. Каждый номер
        правки имеет соответствующее дерево файлов, а каждое дерево
        представляет собой <span class="quote">«<span class="quote">снимок</span>»</span> того, как хранилище
        выглядело после фиксации.</p><div class="figure"><a id="svn.basic.in-action.revs.dia-1"></a><p class="title"><strong>Рисунок 1.7. Хранилище</strong></p><div class="figure-contents"><div><img src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/ch02dia7.png" alt="Хранилище"></div></div></div><br class="figure-break"><br><div class="sidebar" title="Глобальные номера правок"><div class="titlepage"><div><div><p class="title"><strong>Глобальные номера правок</strong></p></div></div></div><p>В отличие от большинства систем управления версиями, номера
          правок в Subversion относятся <span class="emphasis"><em>ко всем</em></span>,
          а не только к отдельно взятым файлам. Каждый номер правки
          соответствует целому дереву, отдельному состоянию хранилища после
          зафиксированного изменения. Иначе говоря, правка N
          представляет состояние файловой системы хранилища после выполнения
          N-ой фиксации. Когда пользователи Subversion говорят о
          <span class="quote">«<span class="quote">правке 5 <code class="filename">foo.c</code></span>»</span>, на самом деле
          речь идет о <span class="quote">«<span class="quote"><code class="filename">foo.c</code> входящем в правку
          5</span>»</span>. Заметьте, что правки N и M файла
          <span class="emphasis"><em>не обязательно</em></span> будут отличаться! Многие
          системы управления версиями исполюзуют пофайловую нумерацию правок,
          так что этот подход на первых порах может показаться непривычным.
          (Бывшие пользователи CVS могут обратиться за более подробной
          информацией к <a class="xref" href="#svn.forcvs" title="Приложение B. Subversion для пользователей CVS">Приложение&nbsp;B, <em>Subversion для пользователей CVS</em></a>.)</p></div><p>Важно помнить, что рабочие копии не всегда соответствуют
        какой-то одной правке в хранилище; они могут содержать файлы из
        разных правок. Например, вы получили рабочую копию из хранилища,
        у которого самая последняя правка — 4:</p><pre class="screen">calc/Makefile:4
     integer.c:4
     button.c:4
</pre><p>На данный момент рабочий каталог полностью соответствует
        правке 4 в хранилище. Допустим, что вы внесли изменения в
        <code class="filename">button.c</code> и зафиксировали эти изменения.
        При отсутствии других фиксаций ваша фиксация создаст правку
        под номером 5, и теперь ваша рабочая копия выглядит следующим
        образом:</p><pre class="screen">calc/Makefile:4
     integer.c:4
     button.c:5
</pre><p>Предположим, что после этого Салли фиксирует изменения <code class="filename">
        integer.c</code>, создавая правку 6. Если вы воспользуетесь
        <span class="command"><strong>svn update</strong></span> для приведения своей рабочей копии
        в актуальное состояние, то она станет выглядеть так:</p><pre class="screen">calc/Makefile:6
     integer.c:6
     button.c:6
</pre><p>Изменения, внесенные Салли в <code class="filename">integer.c</code> будут
        отражены в вашей рабочей копии, и ваши изменения в
        <code class="filename">button.c</code> также будут присутствовать. В этом
        примере текст <code class="filename">Makefile</code> в правках 4, 5 и 6
        идентичен, однако Subversion проставляет номер правки 6 для вашей
        рабочей копии <code class="filename">Makefile</code>, чтобы показать что файл
        не устарел. Таким образом, после того как вы выполните полное
        обновление вашей рабочей копии, она будет полностью соответствовать
        текущему состоянию хранилища.</p></div><div class="sect2" title="Как рабочие копии отслеживают хранилище"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.in-action.track-repos"></a>Как рабочие копии отслеживают хранилище</h3></div></div></div><p>В служебном каталоге <code class="filename">.svn/</code> для каждого
      файла рабочего каталога Subversion записывает информацию о двух
        важнейших свойствах:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>на какой правке основан ваш рабочий файл (это
            называется <em class="firstterm">рабочая правка</em> файла),
            и</p></li><li class="listitem"><p>временной (ударение на последний слог) метке, определяющей,
          когда рабочая копия последний раз обновлялась из хранилища.</p></li></ul></div><p>Используя эту информацию при соединении с хранилищем, Subversion
        может сказать, в каком из следующих четырех состояний находится рабочий
        файл:</p><div class="variablelist"><dl><dt><span class="term">Не изменялся и не устарел</span></dt><dd><p>Файл не изменялся в рабочем каталоге, а в хранилище также не
              фиксировались изменения этого файла со времени создания его
              рабочей правки. Команды <span class="command"><strong>svn commit</strong></span> и
              <span class="command"><strong>svn update</strong></span> никаких операций делать не
              будут.</p></dd><dt><span class="term">Изменялся локально и не устарел</span></dt><dd><p>Файл был изменен в рабочей копии, но в хранилище не
              фиксировались изменения этого файла последнего обновления
              рабочей копии. Есть локальные изменения, которые не были
              зафиксированы в хранилище, поэтому <span class="command"><strong>svn commit</strong></span>
              выполнит фиксацию ваших изменений, а
              <span class="command"><strong>svn update</strong></span> не сделает ничего.</p></dd><dt><span class="term">Не изменялся и устарел</span></dt><dd><p>В рабочем каталоге файл не изменялся, но был изменен в
              хранилище. Необходимо выполнить обновление файла для того,
              чтобы он соответствовал текущей опубликованной правке.
              Команда <span class="command"><strong>svn commit</strong></span> не сделает ничего, а
              <span class="command"><strong>svn update</strong></span> обновит вашу рабочую копию файла в
              соответствии с последними изменениями.</p></dd><dt><span class="term">Изменялся локально и устарел</span></dt><dd><p>Файл был изменен как в рабочем каталоге, так и в
              хранилище. <span class="command"><strong>svn commit</strong></span> потерпит неудачу, выдав
              ошибку <span class="quote">«<span class="quote">out-of-date</span>»</span>. Файл необходимо сначала
              обновить; <span class="command"><strong>svn update</strong></span> попытается объединить
              локальные изменения с опубликованными. Если Subversion не сможет
              выполнить объединение самостоятельно, она предложит пользователю
              разрешить конфликт вручную.</p></dd></dl></div><p>Может показаться, что следить за актуальным состоянием рабочей
        копии сложно. Это не так. Для того, чтобы узнать состояние любого
        элемента в вашей рабочей копии, существует команда <span class="command"><strong>svn
        status</strong></span>. За более подробной информацией об этой команде
        обратитесь к <a class="xref" href="#svn.tour.cycle.examine.status" title="svn status">«<span class="command"><strong>svn status</strong></span>»</a>.</p></div><div class="sect2" title="Смешивание правок в рабочих копиях"><div class="titlepage"><div><div><h3 class="title"><a id="svn.basic.in-action.mixedrevs"></a>Смешивание правок в рабочих копиях</h3></div></div></div><p>Subversion старается быть гибкой настолько, насколько это возможно.
        Например, существует возможность иметь рабочую копию, содержащую
        файлы и каталоги, имеющие смешанные номера рабочих правок. Но, к
        сожалению, эта гибкость иногда смущает некоторых новых
        пользователей. Если раньше примеры, показывающие смешанные правки,
        вызывали у вас чувство растерянности, то это руководство, которое
        рассказывает, для чего такая возможность существует и как ее
        использовать, предназначена для вас.</p><div class="sect3" title="Обновления и фиксации отделены друг от друга"><div class="titlepage"><div><div><h4 class="title"><a id="svn.basic.in-action.mixedrevs.update-commit"></a>Обновления и фиксации отделены друг от друга</h4></div></div></div><p>Одно из фундаментальных правил Subversion заключается в том,
          что <span class="quote">«<span class="quote">передающее</span>»</span> действие не приводит к
          <span class="quote">«<span class="quote">принимаемому</span>»</span>, и наоборот. То, что вы готовы
          внести изменения в хранилище, не означает, что вы готовы принять
          изменения от других. А если вы все еще работаете над новыми изменениями,
          то <span class="command"><strong>svn update</strong></span> изящно объединит изменения из
          хранилища с вашими собственными, вместо того, чтобы заставлять вас
          опубликовать их.</p><p>Главным побочным эффектом этого правила является то, что
          рабочая копия должна вести дополнительный учет при смешивании
          правок и быть аккуратной при любом смешивании. И то, что каталоги
          попадают под контроль версий, делает это еще более сложным
          для понимания.</p><p>Допустим, у вас есть рабочая копия, полностью соответствующая
          правке 10. После изменения файла <code class="filename">foo.html</code>,
          вы выполняете команду <span class="command"><strong>svn commit</strong></span>,
          которая создает в хранилище правку 15. После выполнения
          фиксации большая часть новичков ожидают, что вся
          рабочая копия будет иметь правку 15, однако это не так.
          Между правками 10 и 15 в хранилище могло быть внесено любое
          количество изменений. Так как команда <span class="command"><strong>svn update</strong></span>
          не выполнялась, а <span class="command"><strong>svn commit</strong></span>
          не загружает изменений, клиент ничего не знает о находящихся в
          хранилище изменениях. С другой стороны, если бы команда <span class="command"><strong>svn
          commit</strong></span> автоматически загружала последние изменения,
          то всей рабочей копии можно было бы назначить соответствующий номер
          правки - 15. Однако это нарушило бы фундаментальное правило,
          согласно которому <span class="quote">«<span class="quote">передача</span>»</span> и
          <span class="quote">«<span class="quote">получение</span>»</span> являются независимыми операциями.
          Следовательно, все, что может сделать клиент Subversion, это
          пометить один файл — <code class="filename">foo.html</code> —
          как соответствующий правке 15. Остальная рабочая копия
          продолжает соответствовать правке 10. Только при выполнении
          <span class="command"><strong>svn update</strong></span> будут загружены последние
          изменения, и вся рабочая копия будет помечена как соответствующая
          правке 15.</p></div><div class="sect3" title="Смешивание правок — это нормально"><div class="titlepage"><div><div><h4 class="title"><a id="svn.basic.in-action.mixedrevs.normal"></a>Смешивание правок — это нормально</h4></div></div></div><p>Фактически, <span class="emphasis"><em>каждый раз</em></span> при
            выполнении <span class="command"><strong>svn commit</strong></span> правки рабочей
            копии смешиваются. Только что зафиксированные элементы
            отмечаются как имеющие больший номер рабочей правки, чем все
            остальные. После нескольких фиксаций (без выполнения
            обновлений между ними) правки рабочей копии будут полностью
            перемешаны. Даже если вы являетесь единственным пользователем
            хранилища, вы все равно с этим столкнетесь. Для просмотра
            этой смеси рабочих правок воспользуйтесь командой
            <span class="command"><strong>svn status --verbose</strong></span> (см.
            <a class="xref" href="#svn.tour.cycle.examine.status" title="svn status">«<span class="command"><strong>svn status</strong></span>»</a>).</p><p>Часто новые пользователи даже не подозревают о том,
            что их рабочая копия содержит смешанные правки. Это может
            сбить с толку, так как многие команды клиента чувствительны
            к рабочей правке элемента, с которым он работает. Например,
            команда <span class="command"><strong>svn log</strong></span> используется для вывода
            истории изменения файла или каталога (см. <a class="xref" href="#svn.tour.history.log" title="svn log">«<span class="command"><strong>svn log</strong></span>»</a>). Когда пользователь
            вызывает эту команду применительно к объекту рабочей копии,
            он ожидает увидеть полную историю этого объекта. Однако
            если рабочая правка объекта очень старая (из-за того, что
            команда <span class="command"><strong>svn update</strong></span> долго не выполнялась)
            будет показана история для <span class="emphasis"><em>более старой</em></span>
            версии этого объекта.</p></div><div class="sect3" title="Смешивание правок — это полезно"><div class="titlepage"><div><div><h4 class="title"><a id="svn.basic.in-action.mixedrevs.useful"></a>Смешивание правок — это полезно</h4></div></div></div><p>Если у вас очень большой проект, вы можете найти
            полезным время от времени принудительно
            <span class="quote">«<span class="quote">возвращать</span>»</span> части рабочей копии к более
            ранним правкам; как это делается, вы узнаете в <a class="xref" href="#svn.tour" title="Глава 2. Экскурсия по Subversion">Глава&nbsp;2, <em>Экскурсия по Subversion</em></a>. Возможно, вы захотите протестировать
            более раннюю версию модуля, находящегося в подкаталоге
            или точно узнать, когда в конкретном файле появилась
            ошибка. Это — <span class="quote">«<span class="quote">машина времени</span>»</span>,
            тот аспект системы управления версиями, который
            позволяет перемещать в истории любую часть рабочей копии
            вперед и назад.</p></div><div class="sect3" title="Смешивание правок имеет ограничения"><div class="titlepage"><div><div><h4 class="title"><a id="svn.basic.in-action.mixedrevs.limits"></a>Смешивание правок имеет ограничения</h4></div></div></div><p>Несмотря на то, что в рабочей копии можно использовать
            смешивание правок, у этой гибкости существуют
            ограничения.</p><p>Во-первых, нельзя зафиксировать удаление устаревшего
            файла или каталога. Если в хранилище существует более новая
            версия элемента, попытка удаления будет отклонена для
            предотвращения возможности непреднамеренного уничтожения
            изменений о которых вы не в курсе.</p><p>Во-вторых, нельзя зафиксировать изменение метаданных
            для необновленного каталога. О присвоении
            <span class="quote">«<span class="quote">свойств</span>»</span> элементам вы узнаете в <a class="xref" href="#svn.advanced" title="Глава 3. Профессиональное использование Subversion">Глава&nbsp;3, <em>Профессиональное использование Subversion</em></a>. Рабочая правка каталога
            определяет конкретный набор входящих в нее элементов и
            свойств, поэтому фиксация изменений свойств для устаревшего
            каталога может привести к уничтожению свойств, о которых
            вы не знаете.</p></div></div></div><div class="sect1" title="Подводя итоги"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.basic.summary"></a>Подводя итоги</h2></div></div></div><p>В этой главе мы рассмотрели ряд фундаментальных концепций 
      Subversion:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Мы ввели такие понятия как центральное хранилище, рабочая
          копия и массив правок хранилища.</p></li><li class="listitem"><p>Мы рассмотрели на нескольких простых примерах, как при помощи
          Subversion два партнера могут публиковать и получать
          изменения, сделанные друг другом, используя модель
          <span class="quote">«<span class="quote">копирование-изменение-слияние</span>»</span>.</p></li><li class="listitem"><p>Мы немного поговорили о том, как Subversion отслеживает и
          управляет информацией в рабочей копии.</p></li></ul></div><p>На данный момент у вас должно быть хорошее представление о том, как
      вообще работает Subversion. Теперь, вооруженные этими знаниями, вы
      готовы перейти к следующей главе, которая представляет собой подробный
      обзор команд и возможностей Subversion.</p></div></div><div class="chapter" title="Глава 2. Экскурсия по Subversion"><div class="titlepage"><div><div><h2 class="title"><a id="svn.tour"></a>Глава 2. Экскурсия по Subversion</h2></div></div></div><div class="toc"><p><strong>Содержание</strong></p><dl><dt><span class="sect1"><a href="#svn.tour.help">Читайте справку!</a></span></dt><dt><span class="sect1"><a href="#svn.tour.import">Импорт</a></span></dt><dt><span class="sect1"><a href="#svn.tour.revs">Путешествие во времени вместе с Subversion</a></span></dt><dt><span class="sect1"><a href="#svn.tour.initial">Создание рабочей копии</a></span></dt><dt><span class="sect1"><a href="#svn.tour.cycle">Простейший рабочий цикл</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.cycle.update">Обновление рабочей копии</a></span></dt><dt><span class="sect2"><a href="#svn.tour.cycle.edit">Внесение изменений в рабочую копию</a></span></dt><dt><span class="sect2"><a href="#svn.tour.cycle.examine">Анализ изменений</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.tour.cycle.examine.status"><span class="command"><strong>svn status</strong></span></a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.examine.diff"><span class="command"><strong>svn diff</strong></span></a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.examine.revert"><span class="command"><strong>svn revert</strong></span></a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.tour.cycle.resolve">Разрешение конфликтов (при слиянии с чужими 
        изменениями)</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.tour.cycle.resolve.byhand">Слияние конфликтов вручную</a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.resolve.copyover">Копирование файла поверх вашего рабочего файла</a></span></dt><dt><span class="sect3"><a href="#svn.tour.cycle.resolve.revert">Использование <span class="command"><strong>svn revert</strong></span></a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.tour.cycle.commit">Фиксация изменений</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.tour.history">Анализ истории</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.history.log"><span class="command"><strong>svn log</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.history.diff"><span class="command"><strong>svn diff</strong></span></a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.tour.history.diff.local">Анализ локальных изменений</a></span></dt><dt><span class="sect3"><a href="#svn.tour.history.diff.wcrepos">Сравнение рабочей копии с хранилищем</a></span></dt><dt><span class="sect3"><a href="#svn.tour.history.diff.reposrepos">Сравнение хранилища с хранилищем</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.tour.history.cat"><span class="command"><strong>svn cat</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.history.list"><span class="command"><strong>svn list</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.history.finalword">Заключительное слово об истории</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.tour.other">Другие полезные команды</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.other.cleanup"><span class="command"><strong>svn cleanup</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.tour.other.import"><span class="command"><strong>svn import</strong></span></a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.tour.summary">Подводя итоги</a></span></dt></dl></div><p>Перейдем к более тесной работе с Subversion. К тому
    моменту, когда вы дойдёте до конца этой главы, вы сможете
    выполнить практически все задачи, возникающие при повседневном
    использовании Subversion. Вы начнете с
    первоначального создания рабочей копии вашего кода и пройдете
    через внесение изменений и проверку этих изменений. Вы познакомитесь
    с тем, как внедрить изменения, сделанные другими, в вашу рабочую копию
    и проверить их, а также сможете решить возможные конфликты.</p><p>Обратите внимание на то, что эта глава не ставит цели быть
    всеобъемлющим описанием всех команд Subversion — скорее это
    неформальное введение в наиболее типичные задачи, решаемые с помощью
    Subversion. Эта глава предполагает, что вы прочитали и поняли <a class="xref" href="#svn.basic" title="Глава 1. Фундаментальные понятия">Глава&nbsp;1, <em>Фундаментальные понятия</em></a> и хорошо разобрались с общей моделью Subversion.
    За подробным описанием всех команд обратитесь в <a class="xref" href="#svn.ref" title="Глава 9. Полное справочное руководство по Subversion">Глава&nbsp;9, <em>Полное справочное руководство по Subversion</em></a>.</p><div class="sect1" title="Читайте справку!"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.help"></a>Читайте справку!</h2></div></div></div><p>Прежде чем продолжить чтение, запомните самую главную из всех команд
      Subversion: <span class="command"><strong>svn help</strong></span>. Клиент Subversion с интерфейсом 
      командной строки самодокументирован — команда <span class="command"><strong>svn help 
      &lt;subcommand&gt;</strong></span> в любой момент подскажет синтаксис, 
      описание параметров и поведения подкоманды <span class="command"><strong>subcommand</strong></span>.
      </p></div><div class="sect1" title="Импорт"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.import"></a>Импорт</h2></div></div></div><p>Чтобы импортировать новый проект в хранилище Subversion,
      воспользуйтесь командой <span class="command"><strong>svn import</strong></span>. Хотя,
      вероятно, это будет первым, что вы сделаете при установке сервера 
      Subversion, впоследствии вы будете заниматься этим нечасто. Подробное 
      описание команды <a class="xref" href="#svn.tour.other.import" title="svn import">«<span class="command"><strong>svn import</strong></span>»</a> приводится 
      далее в этой главе.</p></div><div class="sect1" title="Путешествие во времени вместе с Subversion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.revs"></a>Путешествие во времени вместе с Subversion</h2></div></div></div><p>Как уже было сказано в <a class="xref" href="#svn.basic.in-action.revs" title="Правки">«Правки»</a>,
      правка представляет собой <span class="quote">«<span class="quote">снимок</span>»</span> хранилища в конкретный
      момент времени. Однако по-настоящему полезной Subversion (как и любую 
      другую систему управления версиями) делает не то, что она просто хранит 
      все версии файлов и каталогов. Главное заключается в том, что вы 
      реально можете <span class="emphasis"><em>что-то делать</em></span> с этими старыми 
      версиями! А для того, чтобы совершать подобные путешествия во времени, 
      нужен механизм идентификации этих <span class="quote">«<span class="quote">снимков</span>»</span>.</p><p>Номера правок в Subversion — очень простая штука:
      обычные, монотонно увеличивающиеся целые числа. При создании хранилища 
      Subversion оно начинает свое существование с правки 0, и каждая 
      последующая фиксация увеличивает номер правки на единицу. Subversion не 
      прячет эти номера — они являются неотъемлемой частью истории 
      версионированной информации. К примеру, после выполнения фиксации клиент 
      Subversion информирует вас о новом номере правки:</p><pre class="screen">$ svn commit --message "Corrected number of cheese slices."
Sending        sandwich.txt
Transmitting file data .
Committed revision 3.
</pre><p>В будущем, в любой момент времени, если вам нужно будет сослаться
      на эту правку, вы сможете сделать это, обратившись к ней как к правке 
      <span class="quote">«<span class="quote">3</span>»</span>. Некоторые причины, по которым может возникнуть такая 
      необходимость, будут приведены далее в этой главе.</p><p>Клиент для командной строки <span class="command"><strong>svn</strong></span> предлагает на 
      выбор две опции для указания правок, которые вы хотите
      использовать. Более общей из них является <code class="option">--revision</code>
      (<code class="option">-r</code>), которая принимает в качестве параметра как 
      одиночный указатель правки (<code class="option">-r
      <em class="replaceable"><code>REV</code></em></code>), так и пару правок, разделенную 
      двоеточием (<code class="option">-r
      <em class="replaceable"><code>REV1</code></em>:<em class="replaceable"><code>REV2</code></em></code>).
      Второй вариант используется для указания <em class="firstterm">диапазона
      правок</em>, что в свою очередь полезно для команд, сравнивающих 
      два снимка или обрабатывающих включительно все правки между двумя
      указанными пределами.</p><p>В Subversion 1.4 была введена вторая опция для указания диапазона 
      правок <code class="option">--change</code> (<code class="option">-c</code>). Эта опция 
      является просто сокращением для указания диапазона правок, границами 
      которого являются соседние целые числа. Другими словами,
      <code class="option">-c<em class="replaceable"><code>REV</code></em></code> является тем же самым,
      что и 
      <code class="option">-r<em class="replaceable"><code>REV</code></em>-1:<em class="replaceable"><code>REV</code></em></code>.
      Кроме того, так же просто можно указать и обратный диапазон, поместив
      дефис перед номером правки, <code class="option">-c
      -<em class="replaceable"><code>REV</code></em></code>.</p></div><div class="sect1" title="Создание рабочей копии"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.initial"></a>Создание рабочей копии</h2></div></div></div><p>Как правило, работа с хранилищем Subversion начинается с
      <em class="firstterm">создания рабочей копии</em> проекта.
      При создании рабочей копии на локальной машине создается копия
      хранилища. Эта копия содержит <code class="literal">HEAD</code> (последнюю
      правку) хранилища, указанного вами в командной строке:</p><pre class="screen">$ svn checkout http://svn.collab.net/repos/svn/trunk
A  trunk/subversion.dsw
A  trunk/svn_check.dsp
A  trunk/COMMITTERS
A  trunk/configure.in
A  trunk/IDEAS
…
Checked out revision 2499.
</pre><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong></strong></p></div></div></div><p>Subversion очень старается не ограничивать количество типов данных,
        которые можно поместить под контроль системы. Содержимое файлов и
        значения свойств хранятся и передаются в бинарном формате.
        О том, как объяснить Subversion, что для отдельного файла
        <span class="quote">«<span class="quote">текстовые</span>»</span> операции не имеют смысла, вы узнаете в разделе
        <a class="xref" href="#svn.advanced.props.special.mime-type" title="Тип содержимого файла">«Тип содержимого файла»</a>. Однако есть
        ситуации, когда Subversion накладывает некоторые ограничения на хранимую
        информацию.</p><p>Внутри Subversion определенная информация — например,
        имена свойств, пути и лог-сообщения — обрабатывается как текст
        в кодировке UTF-8. Однако это вовсе не означает обязательного
        использования UTF-8 при работе с Subversion. В случае если
        преобразования между UTF-8 и локальной кодировкой на компьютере
        могут быть выполнены (что справедливо для большинства испульзуемых
        сегодня кодировок), как правило, Subversion-клиент выполняет эти
        преобразования легко и прозрачно для пользователя.
      </p><p>Кроме того, имена путей при WebDAV-транзакциях используются как
        значения XML-атрибутов, так же как и в некоторых собственных файлах
        Subversion. Это означает, что при указании путей могут
        использоваться только корректные для XML (1.0) символы. Также при 
        указании путей Subversion запрещает использовать символы TAB, CR 
        и LF, чтобы они не повреждали файлы различий и не искажали вывод 
        таких команд как <a class="xref" href="#svn.ref.svn.c.log" title="svn log">svn log</a> или <a class="xref" href="#svn.ref.svn.c.status" title="svn status">svn status</a>.</p><p>Вам может показаться, что нужно помнить очень много
        всего, однако на практике эти ограничения не вызывают 
        сложностей. Если ваши локальные установки совместимы с UTF-8 и 
        вы не используете специальных символов при указании путей, то
        проблем при работе с Subversion у вас не возникнет. Клиент для 
        командной строки немного в этом помогает — он автоматически 
        корректирует недопустимые символы, встречающиеся в набранных URL,
        <span class="quote">«<span class="quote">юридически правильными</span>»</span> версиями для внутреннего 
        использования.</p><p>Кроме этого, опытные пользователи Subversion разработали 
        набор правил хорошего тона для организации структуры хранилища.
        Хотя эти правила и не являются такими же строгими требованиями, как 
        описанный выше синтаксис, они помогают при выполнении типовых 
        задач. Используемая по тексту книги часть пути
        <code class="literal">/trunk</code> является одним из таких правил; 
        подробнее об этой и других подобных рекомендациях мы поговорим в
        <a class="xref" href="#svn.branchmerge" title="Глава 4. Ветвление и слияние">Глава&nbsp;4, <em>Ветвление и слияние</em></a>.</p></div><p>Хотя в приведенном примере рабочая копия создается на
      основе корневого каталога, вы можете легко создать рабочую копию на
      основе подкаталога любой степени вложенности, указав при
      создании рабочей копии подкаталог в URL:</p><pre class="screen">$ svn checkout http://svn.collab.net/repos/svn/trunk/doc/book/tools
A  tools/readme-dblite.html
A  tools/fo-stylesheet.xsl
A  tools/svnbook.el
A  tools/dtd
A  tools/dtd/dblite.dtd
…
Checked out revision 2499.
</pre><p>Так как Subversion использует модель
      <span class="quote">«<span class="quote">копирование-изменение-слияние</span>»</span> вместо модели
      <span class="quote">«<span class="quote">блокирование-изменение-разблокирование</span>»</span> (см.
      <a class="xref" href="#svn.basic" title="Глава 1. Фундаментальные понятия">Глава&nbsp;1, <em>Фундаментальные понятия</em></a>), вы уже можете начинать вносить
      изменения в файлы и каталоги своей рабочей копии. Ваша рабочая
      копия ничем не отличается от любого другого набора файлов в вашей
      системе. Вы можете редактировать и менять их, перемещать, вы даже
      можете полностью удалить рабочую копию и забыть о ней.</p><div class="note" title="Примечание" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Примечание]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/note.png"></td><th align="left">Примечание</th></tr><tr><td valign="top" align="left"><p>Несмотря на то, что рабочая копия выглядит <span class="quote">«<span class="quote">как и любой
          другой набор файлов в вашей системе</span>»</span>, необходимо ставить 
          Subversion в известность в том случае, если вы собираетесь что-либо 
          реорганизовывать в рабочей копии. Если вы хотите скопировать или 
          переместить элемент в рабочей копии, вы должны использовать команду 
          <span class="command"><strong>svn copy</strong></span> или <span class="command"><strong>svn move</strong></span> вместо 
          аналогичных команд операционной системы. Мы еще обсудим их в этой
          главе более подробно.</p></td></tr></tbody></table></div><p>Исключение составляют случаи, когда вы готовы зафиксировать новый
      файл или каталог, либо внести изменения в один из существующих файлов 
      или каталогов. Эти операции не требуют дополнительного уведомления
      сервера Subversion.</p><div class="sidebar" title="А как насчет каталога .svn?"><div class="titlepage"><div><div><p class="title"><strong>А как насчет каталога <code class="filename">.svn</code>?</strong></p></div></div></div><p>Каждый каталог в рабочей копии содержит служебную
        область — подкаталог с названием <code class="filename">.svn</code>.
        Обычно команды, используемые для вывода содержимого каталогов, не
        показывают этот подкаталог, но тем не менее, он играет очень важную 
        роль. Что бы вы ни делали, не удаляйте и не меняйте ничего в
        служебной области! Subversion использует ее при управлении
        рабочей копией.</p></div><p>Хотя вы, конечно, можете создать рабочую копию,
      указав в качестве единственного аргумента URL хранилища, вы можете
      также указать после него каталог. Тогда ваша рабочая копия
      будет находиться в новом каталоге с указанным вами именем.
      Например:</p><pre class="screen">$ svn checkout http://svn.collab.net/repos/svn/trunk subv
A  subv/subversion.dsw
A  subv/svn_check.dsp
A  subv/COMMITTERS
A  subv/configure.in
A  subv/IDEAS
…
Checked out revision 2499.
</pre><p>Эта команда создаст рабочую копию в каталоге с именем
      <code class="literal">subv</code>, вместо каталога <code class="literal">trunk</code>
      как мы делали раньше.</p></div><div class="sect1" title="Простейший рабочий цикл"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.cycle"></a>Простейший рабочий цикл</h2></div></div></div><p>Хотя Subversion имеет множество возможностей, опций и украшательств, 
      в каждодневной практике используются только некоторые из них. В этом
      разделе мы пройдемся по задачам, наиболее часто выполняемым в течение 
      рабочего дня.</p><p>Типичный рабочий цикл выглядит примерно так:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Обновление рабочей копии</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><span class="command"><strong>svn update</strong></span></p></li></ul></div></li><li class="listitem"><p>Внесение изменений</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><span class="command"><strong>svn add</strong></span></p></li><li class="listitem"><p><span class="command"><strong>svn delete</strong></span></p></li><li class="listitem"><p><span class="command"><strong>svn copy</strong></span></p></li><li class="listitem"><p><span class="command"><strong>svn move</strong></span></p></li></ul></div></li><li class="listitem"><p>Анализ изменений</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><span class="command"><strong>svn status</strong></span></p></li><li class="listitem"><p><span class="command"><strong>svn diff</strong></span></p></li><li class="listitem"><p><span class="command"><strong>svn revert</strong></span></p></li></ul></div></li><li class="listitem"><p>Слияние изменений, выполненных другими, с вашей рабочей
          копией</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><span class="command"><strong>svn update</strong></span></p></li><li class="listitem"><p><span class="command"><strong>svn resolved</strong></span></p></li></ul></div></li><li class="listitem"><p>Фиксация изменений</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><span class="command"><strong>svn commit</strong></span></p></li></ul></div></li></ul></div><div class="sect2" title="Обновление рабочей копии"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.cycle.update"></a>Обновление рабочей копии</h3></div></div></div><p>При командной работе над проектом обновление рабочей копии
        необходимо для получения любых изменений, внесенных другими 
        разработчиками проекта с момента вашего последнего обновления.
        Используйте <span class="command"><strong>svn update</strong></span> для синхронизации вашей
        рабочей копии с последней правкой в хранилище.</p><pre class="screen">$ svn update
U  foo.c
U  bar.c
Updated to revision 2.
</pre><p>В данном случае, кто-то другой зафиксировал изменения в файлах
        <code class="filename">foo.c</code> и <code class="filename">bar.c</code> после
        вашего последнего обновления, и Subversion обновила вашу рабочую 
        копию, включив эти изменения.</p><p>Рассмотрим поподробнее информацию, выводимую командой <span class="command"><strong>svn 
        update</strong></span>. Когда сервер отправляет изменения в вашу рабочую копию,
        для каждого элемента выводится латинская буква — код, определяющий
        действие, выполненное Subversion для приведения вашей рабочей копии в
        актуальное состояние:</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">U      foo</code></span></dt><dd><p>Файл <code class="filename">foo</code> был
              <code class="computeroutput">U</code>pdated — обновлен
              (получил изменения с сервера).</p></dd><dt><span class="term"><code class="computeroutput">A      foo</code></span></dt><dd><p>Файл или каталог <code class="filename">foo</code> был
              <code class="computeroutput">A</code>dded — добавлен в
              рабочую копию.</p></dd><dt><span class="term"><code class="computeroutput">D      foo</code></span></dt><dd><p>Файл или каталог <code class="filename">foo</code> был
              <code class="computeroutput">D</code>eleted — удален
              из рабочей копии.</p></dd><dt><span class="term"><code class="computeroutput">R      foo</code></span></dt><dd><p>Файл или каталог <code class="filename">foo</code> был
              <code class="computeroutput">R</code>eplaced — заменен
              в рабочей копии; это значит, что <code class="filename">foo</code>
              был удален, а новый элемент с таким же именем был добавлен.
              Несмотря на то, что они могут иметь одинаковое имя,
              хранилище рассматривает их как разные объекты с
              отдельной историей.</p></dd><dt><span class="term"><code class="computeroutput">G      foo</code></span></dt><dd><p>Файл <code class="filename">foo</code> получил новые изменения
              из хранилища, однако ваша локальная копия в то же время содержит 
              ваши собственные изменения. Изменения, полученные из хранилища,
              либо не пересекаются, либо они точно такие же как ваши локальные 
              изменения, поэтому Subversion успешно выполнила 
              mer<code class="computeroutput">G</code>ed — слияние 
              изменений хранилища с файлом.</p></dd><dt><span class="term"><code class="computeroutput">C      foo</code></span></dt><dd><p>Файл <code class="filename">foo</code> получил от сервера
              <code class="computeroutput">C</code>onflicting —
              конфликтующие изменения. Изменения с сервера пересекаются с
              вашими изменениями файла. Однако это не повод для паники. Такое
              перекрытие просто нуждается в разрешении человеком (вами); мы 
              обсудим эту ситуацию позднее в этой главе.</p></dd></dl></div></div><div class="sect2" title="Внесение изменений в рабочую копию"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.cycle.edit"></a>Внесение изменений в рабочую копию</h3></div></div></div><p>Теперь вы можете приступать к делу и вносить изменения 
        в рабочую копию. Как правило, целесообразнее всего работать 
        отдельно по каждому частному изменению (или набору изменений), 
        такому как реализация новой функциональной возможности, исправление 
        ошибки и т. п. Здесь вы будете пользоваться такими командами 
        Subversion как <span class="command"><strong>svn add</strong></span>, 
        <span class="command"><strong>svn delete</strong></span>,
        <span class="command"><strong>svn copy</strong></span> и <span class="command"><strong>svn move</strong></span>.
        Однако, если вы просто редактируете файлы, которые уже находятся 
        под контролем Subversion, ни одна из этих команд вам не нужна. 
        В своей рабочей копии вы можете делать следующие изменения:</p><div class="variablelist"><dl><dt><span class="term">Изменения файлов</span></dt><dd><p>Это самый простой вид изменений. Вам не нужно сообщать
              Subversion о своем намерении изменить файл; просто берите
              и вносите изменения. Subversion сможет автоматически
              определить измененные файлы.</p></dd><dt><span class="term">Изменения в структуре</span></dt><dd><p>Вы можете попросить Subversion <span class="quote">«<span class="quote">отметить</span>»</span>
              файлы и каталоги для удаления, добавления, копирования или
              перемещения. Хотя эти изменения сразу же отразятся в рабочей 
              копии, в хранилище не произойдет ни добавления, ни удаления
              до тех пор, пока вы не выполните фиксацию изменений.</p></dd></dl></div><p>Для внесения изменений в файлы используйте свой текстовый
        редактор, текстовый процессор, графическую программу или любой
        другой инструмент, который вы обычно используете. Subversion
        обрабатывает бинарные файлы так же легко как и текстовые —
        и настолько же эффективно.</p><p>Рассмотрим четыре подкоманды Subversion, которые вы чаще
        всего будете использовать при внесении изменений в структуру
        (команды <span class="command"><strong>svn import</strong></span> и <span class="command"><strong>svn
        mkdir</strong></span> мы рассмотрим позже).</p><div class="sidebar" title="Версионирование символьных ссылок"><div class="titlepage"><div><div><p class="title"><strong>Версионирование символьных ссылок</strong></p></div></div></div><p>Subversion способен версионировать файлы особого типа —
          <em class="firstterm">символьные ссылки</em> (или 
          <span class="quote">«<span class="quote">симлинки</span>»</span>) — на платформах, которые их 
          поддерживают.  Симлинк — это файл, действующий как
          своего рода прозрачная сылка на некоторый другой объект файловой
          системы, и позволяющий программам косвенно читать и записывать этот 
          объект посредством операций над самой символьной ссылкой.</p><p>Когда символическая ссылка фиксируется в хранилище, Subversion
          запоминает, что в действительности этот файл является симлинком,
          а также то, на какой объект он <span class="quote">«<span class="quote">указывает</span>»</span>.
          При сохранении этой символической ссылки в другую рабочую копию
          на системе с их поддержкой, Subversion реконструирует из 
          версионированной символической ссылки реальную символическую ссылку 
          уровня файловой системы. Однако, это ни в коей мере не ограничивает 
          использование рабочих копий на таких системах как Windows, которые
          не поддерживают символические ссылки. На таких системах Subversion
          просто создаст обычный текстовый файл, содержанием которого будет
          путь, на который указывал исходный симлинк. Хотя этот файл нельзя
          будет использовать в Windows как символическую ссылку, он также не
          будет и препятствовать пользователям Windows в работе с 
          Subversion.</p></div><div class="warning" title="Предупреждение" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Предупреждение]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/warning.png"></td><th align="left">Предупреждение</th></tr><tr><td valign="top" align="left"><p>Хотя вы можете редактировать файлы любыми программными 
          средствами, не следует менять структуру рабочей копии,
          не проинформировав о своих действиях Subversion. Для
          изменения структуры рабочей копии используйте команды
          <span class="command"><strong>svn copy</strong></span>, <span class="command"><strong>svn delete</strong></span>
          и <span class="command"><strong>svn move</strong></span>, а для добавления новых файлов
          и каталогов под контроль версий используйте
          <span class="command"><strong>svn add</strong></span>.</p></td></tr></tbody></table></div><div class="variablelist"><dl><dt><span class="term"><span class="command"><strong>svn add foo</strong></span></span></dt><dd><p>Запланировать файл, каталог или символьную ссылку
              <code class="filename">foo</code> для добавления в хранилище.
              При следующей фиксации <code class="filename">foo</code> станет
              компонентом своего родительского каталога. Обратите внимание
              на то, что если <code class="filename">foo</code> является каталогом,
              то все содержащееся в <code class="filename">foo</code> будет
              запланировано для добавления. Чтобы добавить отдельно только 
              сам каталог <code class="filename">foo</code>, воспользуйтесь параметром
              <code class="option">--non-recursive</code> (<code class="option">-N</code>).</p></dd><dt><span class="term"><span class="command"><strong>svn delete foo</strong></span></span></dt><dd><p>Запланировать удаление из хранилища файла, каталога
              или символьной ссылки <code class="filename">foo</code>. Если
              <code class="filename">foo</code> является файлом или ссылкой,
              он сразу же удаляется из вашей рабочей копии. Если
              <code class="filename">foo</code> является каталогом, он не
              удаляется, но Subversion запланирует его удаление.
              <code class="filename">foo</code> будет удален из рабочей копии и
              хранилища при фиксации изменений.<sup>[<a id="idp8129280" href="#ftn.idp8129280" class="footnote">8</a>]</sup></p></dd><dt><span class="term"><span class="command"><strong>svn copy foo bar</strong></span></span></dt><dd><p>Создать новый элемент <code class="filename">bar</code> как
              копию <code class="filename">foo</code>. <code class="filename">bar</code>
              будет автоматически запланирован для добавления.
              Когда при следующей фиксации <code class="filename">bar</code>
              будет добавлен в хранилище, в его истории будет отмечено
              копирование (то, что первоисточником является
              <code class="filename">foo</code>). <span class="command"><strong>svn copy</strong></span> не
              создает промежуточных каталогов.</p></dd><dt><span class="term"><span class="command"><strong>svn move foo bar</strong></span></span></dt><dd><p>Эта команда полностью аналогична выполнению
              <span class="command"><strong>svn copy foo bar; svn delete foo</strong></span>.
              Поэтому, <code class="filename">bar</code> будет запланирован для
              добавления как копия <code class="filename">foo</code>, а
              <code class="filename">foo</code> будет запланирован для удаления.
              <span class="command"><strong>svn move</strong></span> не создает промежуточных
              каталогов.</p></dd></dl></div><div class="sidebar" title="Изменение хранилища без участия рабочей копии"><div class="titlepage"><div><div><p class="title"><strong>Изменение хранилища без участия рабочей копии</strong></p></div></div></div><p>Ранее в этой главе было сказано, что вам необходимо
          зафиксировать любые изменения для того, чтобы они отразились в
          хранилище. Это не совсем так — <span class="emphasis"><em>существуют</em></span>
          некоторые случаи, когда изменения структуры сразу же фиксируются 
          в хранилище. Это происходит только тогда,
          когда подкоманда оперирует напрямую с URL вместо рабочей копии.
          В частности, отдельные применения <span class="command"><strong>svn mkdir</strong></span>,
          <span class="command"><strong>svn copy</strong></span>, <span class="command"><strong>svn move</strong></span> и
          <span class="command"><strong>svn delete</strong></span> могут работать с URL.</p><p>URL-операции ведут себя подобным образом из-за того, что
          команды, использующие рабочую копию, могут использовать ее
          как своего рода <span class="quote">«<span class="quote">стартовую площадку</span>»</span> для
          устаканивания изменений перед их фиксацией в хранилище. Команды,
          оперирующие URL, не могут себе позволить такой роскоши, поэтому,
          когда вы работаете напрямую с URL, любое из приведенных выше действий
          приводит к немедленной фиксации.</p></div></div><div class="sect2" title="Анализ изменений"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.cycle.examine"></a>Анализ изменений</h3></div></div></div><p>После внесения изменений вы должны зафиксировать их в
        хранилище, но перед этим было бы неплохо посмотреть,
        что же, собственно, вы изменили. Проанализировав перед фиксацией свои
        изменения, вы сможете составить более аккуратное лог-сообщение.
        Кроме того, вы можете обнаружить, что изменили файл непреднамеренно,
        что позволит еще до фиксации вернуть файл к предыдущему
        состоянию. К тому же, это хорошая возможность пересмотреть и проверить
        изменения перед их публикацией. Чтобы увидеть все сделанные изменения,
        вы можете воспользоваться <span class="command"><strong>svn status</strong></span>, <span class="command"><strong>svn
        diff</strong></span> и <span class="command"><strong>svn revert</strong></span>. Первые две команды вы
        можете использовать для того, чтобы найти измененные файлы рабочей
        копии, а затем, при помощи третьей, отменить некоторые (или все) 
        изменения.</p><div class="sidebar" title="Смотри-ка! Все это можно сделать без сети!"><div class="titlepage"><div><div><p class="title"><strong>Смотри-ка! Все это можно сделать без сети!</strong></p></div></div></div><p>Все эти три команды (<span class="command"><strong>svn
          status</strong></span>, <span class="command"><strong>svn diff</strong></span> и
          <span class="command"><strong>svn revert</strong></span>) могут использоваться
          при полном отсутствии сетевого доступа. Это позволяет
          легко управлять рабочими изменениями, когда вы находитесь там,
          где нет сетевого соединения. Например, вы  можете лететь в 
          самолете, ехать в пригородном поезде или заниматься хакерством 
          на пляже.</p><p>Для этого Subversion использует первоначальную версию каждого
          версионированного файла, кэшированную в административной области
          <code class="filename">.svn</code>. Это позволяет
          Subversion показывать — и отменять — локальные
          изменения таких файлов <span class="emphasis"><em>без необходимости сетевого
          доступа</em></span>. Этот кэш (называемый <span class="quote">«<span class="quote">текстовой
          базой</span>»</span>), кроме всего прочего, позволяет Subversion
          при фиксации отправлять локальные пользовательские изменения
          в виде сжатой <em class="firstterm">дельты</em> (или
          <span class="quote">«<span class="quote">различий</span>»</span>) первоначальной версии. Наличие такого
          кэша очень выгодно — даже если у вас высокоскоростное
          соединение, намного быстрее отправлять на сервер только изменения
          файла вместо отправки этого файла целиком.</p></div><p>Subversion была оптимизирована для решения такой задачи
        и способна выполнять множество действий без обращения к
        хранилищу. В частности, рабочая копия содержит в 
        <code class="filename">.svn</code>-области скрытую кэшированую 
        <span class="quote">«<span class="quote">нетронутую</span>»</span> копию каждого версионированного файла.
        За счет этого Subversion может быстро показать, как изменились 
        ваши рабочие файлы или даже предоставить, не связываясь с хранилищем, 
        возможность откатить изменения.</p><div class="sect3" title="svn status"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.cycle.examine.status"></a><span class="command"><strong>svn status</strong></span></h4></div></div></div><p>Наверное, команду <span class="command"><strong>svn status</strong></span>
          вы будете использовать чаще, чем любую другую команду
          Subversion.</p><div class="sidebar" title="Пользователям CVS: Не вызывайте обновление раньше времени!"><div class="titlepage"><div><div><p class="title"><strong>Пользователям CVS: Не вызывайте обновление раньше времени!</strong></p></div></div></div><p>Чтобы увидеть, какие изменения сделаны в рабочей копии, 
            вы, вероятно, использовали <span class="command"><strong>cvs update</strong></span>.
            <span class="command"><strong>svn status</strong></span> даст вам всю нужную информацию
            относительно того, что изменилось в рабочей копии —
            не обращаясь к хранилищу и не сливая новые изменения,
            опубликованные другими пользователями.</p><p><span class="command"><strong>Обновление</strong></span> в Subversion делает именно
            это — обновляет вашу рабочую копию, забирая все изменения,
            зафиксированные в хранилище с момента последнего обновления рабочей
            копии. Это нарушает традицию использования команды
            <span class="command"><strong>update</strong></span> для просмотра локально сделанных 
            изменений.</p></div><p>При запуске <span class="command"><strong>svn status</strong></span> без параметров из
          корневого каталога рабочей копии будут найдены все сделанные вами
          изменения файлов и структуры. Ниже приведены примеры различных
          буквенных кодов, возвращаемых <span class="command"><strong>svn status</strong></span>.
          (Обратите внимание, что текст, следующий за
          <code class="literal">#</code>, на самом деле <span class="command"><strong>svn status</strong></span> не
          печатает.)</p><pre class="screen">  L     some_dir            # svn оставила блокировку в .svn-области для some_dir
M       bar.c               # содержимое bar.c имеет локальные изменения
 M      baz.c               # в baz.c есть изменения в свойствах, а в содержимом нет
X       3rd_party           # каталог является частью внешней зависимости
?       foo.o               # svn не управляет foo.o
!       some_dir            # svn управляет этим элементом, но он отсутствует или поврежден
~       qux                 # элемент версионировался как файл/каталог/ссылка, но тип был изменен
I       .screenrc           # svn не управляет этим элементом и настроена на его игнорирование
A  +    moved_dir           # добавлен с историей своего происхождения
M  +    moved_dir/README    # добавлен с историей и имеет локальные изменения
D       stuff/fish.c        # файл запланирован для удаления
A       stuff/loot/bloo.h   # файл запланирован для добавления
C       stuff/loot/lump.c   # файл имеет текстовый конфликт с момента обновления
 C      stuff/loot/glub.c   # файл имеет конфликт в свойствах с момента обновления
R       xyz.c               # файл запланирован для замены
    S   stuff/squawk        # файл или каталог были переключены на ветку
     K  dog.jpg             # файл заблокирован локально; присутствует маркер блокирования
     O  cat.jpg             # файл заблокирован в хранилище другим пользователем
     B  bird.jpg            # файл заблокирован локально, но блокировка была нарушена
     T  fish.jpg            # файл заблокирован локально, но блокировка была снята

</pre><p><span class="command"><strong>svn status</strong></span>
          печатает пять колонок букв, затем несколько пробелов,
          затем имя файла или каталога. Первая колонка показывает
          статус файла или каталога и/или ее содержимого. При этом используются
          следующие коды:</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">A      item</code></span></dt><dd><p>Файл, каталог или символьная ссылка
                <code class="filename">item</code> был запланирован для
                добавления в хранилище.</p></dd><dt><span class="term"><code class="computeroutput">C      item</code></span></dt><dd><p>Файл <code class="filename">item</code> находится в
                состоянии конфликта. Это означает, что изменения,
                полученные от сервера, при обновлении пересекаются
                с локальными изменениями, имеющимися в рабочей копии.
                Перед фиксацией изменений вам необходимо разрешить
                этот конфликт.</p></dd><dt><span class="term"><code class="computeroutput">D      item</code></span></dt><dd><p>Файл, каталог или символьная ссылка
                <code class="filename">item</code> запланирован
                для удаления из хранилища.</p></dd><dt><span class="term"><code class="computeroutput">M      item</code></span></dt><dd><p>Содержимое файла <code class="filename">item</code> было
                изменено.</p></dd><dt><span class="term"><code class="computeroutput">R      item</code></span></dt><dd><p>Файл, каталог или символьная ссылка запланирован
                для замены <code class="filename">item</code> в хранилище.
                Это значит, что сначала объект был удален, а затем
                другой объект с таким же именем был добавлен, все в одной
                правке.</p></dd><dt><span class="term"><code class="computeroutput">X      item</code></span></dt><dd><p>Каталог <code class="filename">item</code> не версионирован,
                но относится к внешним зависимостям Subversion. Более подробно
                о внешних зависимостях см. в <a class="xref" href="#svn.advanced.externals" title="Внешние зависимости">«Внешние зависимости»</a>.</p></dd><dt><span class="term"><code class="computeroutput">?      item</code></span></dt><dd><p>Файл, каталог или символьная ссылка не находится под
                контролем версий. Вы можете убрать знаки вопроса либо
                воспользовавшись параметром <code class="option">--quiet</code>
                (<code class="option">-q</code>) команды <span class="command"><strong>svn status</strong></span>,
                либо установив свойство <code class="literal">svn:ignore</code>
                родительского каталога. Дополнительную информацию об 
                игнорировании файлов см. в <a class="xref" href="#svn.advanced.props.special.ignore" title="Пропуск неверсионированных элементов">«Пропуск неверсионированных элементов»</a>.</p></dd><dt><span class="term"><code class="computeroutput">!      item</code></span></dt><dd><p>Файл, каталог или символьная ссылка
                <code class="filename">item</code> находится под контролем версий,
                но отсутствует в рабочей копии или поврежден. Элемент
                может отсутствовать, если он был удален без использования
                команд Subversion. В частном случае, каталог может оказаться
                поврежденным, если вы прервали создание рабочей копии или
                обновление. Быстрый запуск <span class="command"><strong>svn update</strong></span>
                заново вытащит файл или каталог из хранилища, либо
                <span class="command"><strong>svn revert file</strong></span> восстановит отсутствующий
                файл.</p></dd><dt><span class="term"><code class="computeroutput">~      item</code></span></dt><dd><p>Файл, каталог или символьная ссылка
                <code class="filename">item</code> в хранилище является объектом
                одного типа, а то, что на самом деле находится в рабочей
                копии, является чем-то другим. Например, в хранилище
                Subversion может иметь файл, а вы удалили файл и создали
                на его месте каталог, не используя для этого команды
                <span class="command"><strong>svn delete</strong></span> или
                <span class="command"><strong>svn add</strong></span>.</p></dd><dt><span class="term"><code class="computeroutput">I      item</code></span></dt><dd><p>Файл, каталог или символьная ссылка
                <code class="filename">item</code> находится под контролем
                версий, и Subversion настроена на его игнорирование
                при операциях <span class="command"><strong>svn add</strong></span>, <span class="command"><strong>svn
                import</strong></span> и <span class="command"><strong>svn status</strong></span>.
                Дополнительную информацию об игнорированных файлах см. в
                <a class="xref" href="#svn.advanced.props.special.ignore" title="Пропуск неверсионированных элементов">«Пропуск неверсионированных элементов»</a>.
                Обратите внимание на то, что этот символ появляется
                при использовании опции <code class="option">--no-ignore</code>
                для <span class="command"><strong>svn status</strong></span> — иначе
                файл игнорируется и не показывается вообще!</p></dd></dl></div><p>Вторая колонка показывает статус свойств файлов и
          каталогов (подробнее о свойствах см. в <a class="xref" href="#svn.advanced.props" title="Свойства">«Свойства»</a>). Если во второй колонке
          показывается <code class="computeroutput">M</code>, свойства
          были изменены. Если в этой колонке показывается
          <code class="computeroutput">C</code>, то это означает, что свойства
          файла находятся в состоянии конфликта, который должен быть
          разрешен до фиксации изменений в хранилище. Во всех других случаях
          будет выведен пробел.
        </p><p>Третья колонка может содержать только пробел или
          <code class="computeroutput">L</code>, это значит, что у каталога
          заблокирована рабочая область <code class="filename">.svn</code>.
          Вы увидите <code class="computeroutput">L</code>, если запустите
          <span class="command"><strong>svn status</strong></span> в каталоге, в котором выполняется
          <span class="command"><strong>svn commit</strong></span> — например, когда вы
          редактируете лог-сообщение.</p><p>Четвертая колонка может содержать только пробел или
          <code class="computeroutput">+</code>, это означает, что
          элемент был запланирован для <span class="quote">«<span class="quote">добавления с историей</span>»</span>.
          Это может быть файл или корень скопированного каталога.
          <code class="computeroutput">+</code> означает, что элемент
          является частью поддерева, запланированного для
          <span class="quote">«<span class="quote">добавления с историей</span>»</span>, т. е. один из родительских
          каталогов был скопирован, и этот элемент просто его часть.
          <code class="computeroutput">M&nbsp;&nbsp;+</code> означает, что
          элемент является частью поддерева, запланированного для
          <span class="quote">«<span class="quote">добавления с историей</span>»</span>, <span class="emphasis"><em>и</em></span>
          имеет локальные изменения. При выполнении фиксации вначале
          будет <span class="quote">«<span class="quote">добавлен с историей</span>»</span> родительский каталог,
          что означает автоматическое наличие файла в копии.
          После этого в копию будут загружены локальные изменения.</p><p>Пятая колонка может содержать только пробел или
          <code class="computeroutput">S</code>. Это означает, 
          что файл или каталог был переключен с пути остальной
          рабочей копии на ветку (используя <span class="command"><strong>svn switch</strong></span>).
        </p><p>Шестая колонка показывает информацию о блокировках,
          которые подробно рассмотрены в <a class="xref" href="#svn.advanced.locking" title="Locking">«Locking»</a>. (Это не те блокировки, которые
        отмечаются <code class="computeroutput">L</code> в третьей колонке;
        см. <a class="xref" href="#svn.advanced.locking.meanings" title="Three meanings of «lock»">Three meanings of <span class="quote">«<span class="quote">lock</span>»</span></a>)</p><p>Если вы укажете конкретный путь для <span class="command"><strong>svn
          status</strong></span>, то получите информацию только об этом
          элементе:</p><pre class="screen">$ svn status stuff/fish.c
D      stuff/fish.c
</pre><p>Кроме того, <span class="command"><strong>svn status</strong></span> имеет
          параметр <code class="option">--verbose</code> (<code class="option">-v</code>),
          который покажет вам статус <span class="emphasis"><em>каждого</em></span>
          элемента в рабочей копии, даже если он не менялся:</p><pre class="screen">$ svn status --verbose
M               44        23    sally     README
                44        30    sally     INSTALL
M               44        20    harry     bar.c
                44        18    ira       stuff
                44        35    harry     stuff/trout.c
D               44        19    ira       stuff/fish.c
                44        21    sally     stuff/things
A                0         ?     ?        stuff/things/bloo.h
                44        36    harry     stuff/things/gloo.c
</pre><p>Это <span class="quote">«<span class="quote">длинная форма</span>»</span> представления вывода
          <span class="command"><strong>svn status</strong></span>. Первая колонка осталась та же самая,
          а вот вторая колонка показывает рабочую правку элемента.
          Третья и четвертая колонки показывают правку, в которой элемент
          последний раз изменялся и автора этих изменений.</p><p>Ни один из указанных выше вызовов <span class="command"><strong>svn
          status</strong></span> не обращается к хранилищу, они работают
          только локально, сравнивая метаданные каталога
          <code class="filename">.svn</code> с рабочей копией. Отметим, что есть
          параметр <code class="option">--show-updates</code> (<code class="option">-u</code>),
          указывающий на соединение с хранилищем и добавляющий
          информацию об устаревании элементов:</p><pre class="screen">$ svn status --show-updates --verbose
M      *        44        23    sally     README
M               44        20    harry     bar.c
       *        44        35    harry     stuff/trout.c
D               44        19    ira       stuff/fish.c
A                0         ?     ?        stuff/things/bloo.h
Status against revision:   46
</pre><p>Обратите внимание на две звездочки: если сейчас вы
          запустите <span class="command"><strong>svn update</strong></span> вы получите изменения
          для <code class="filename">README</code> и <code class="filename">trout.c</code>.
          Это очень полезная информация — перед фиксацией вам необходимо
          обновить и получить изменения с сервера для
          <code class="filename">README</code>, или же хранилище отклонит вашу фиксацию
          как не соответствующую актуальному состоянию. (Подробнее об этом
          чуть позже.)</p></div><div class="sect3" title="svn diff"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.cycle.examine.diff"></a><span class="command"><strong>svn diff</strong></span></h4></div></div></div><p>Еще один механизм для анализа изменений — это команда
          <span class="command"><strong>svn diff</strong></span>. Запустив <span class="command"><strong>svn diff</strong></span> 
          без аргументов, можно увидеть, <span class="emphasis"><em>какие именно</em></span> 
          изменения вы внесли, в результате будут выведены изменения файлов 
          в едином формате представления различий:<sup>[<a id="idp8313616" href="#ftn.idp8313616" class="footnote">9</a>]</sup></p><pre class="screen">$ svn diff
Index: bar.c
===================================================================
--- bar.c (revision 3)
+++ bar.c (working copy)
@@ -1,7 +1,12 @@
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+
+#include &lt;stdio.h&gt;

 int main(void) {
-  printf("Sixty-four slices of American Cheese...\n");
+  printf("Sixty-five slices of American Cheese...\n");
 return 0;
 }

Index: README
===================================================================
--- README  (revision 3)
+++ README  (working copy)
@@ -193,3 +193,4 @@
+Note to self:  pick up laundry.

Index: stuff/fish.c
===================================================================
--- stuff/fish.c  (revision 1)
+++ stuff/fish.c  (working copy)
-Welcome to the file known as 'fish'.
-Information on fish will be here soon.

Index: stuff/things/bloo.h
===================================================================
--- stuff/things/bloo.h (revision 8)
+++ stuff/things/bloo.h (working copy)
+Here is a new file to describe
+things about bloo.
</pre><p>Команда <span class="command"><strong>svn diff</strong></span> формирует
          свой вывод, сравнивая ваши рабочие файлы с кэшированными
          <span class="quote">«<span class="quote">нетронутыми</span>»</span> копиями из <code class="filename">.svn</code>.
          Весь текст запланированных для добавления файлов показывается
          как добавленный, а весь текст запланированных
          для удаления файлов показывается как удаленный.</p><p>Вывод происходит в <em class="firstterm">едином формате представления
          различий</em>. При этом удаленные строки предваряются
          знаком <code class="literal">-</code>, а добавленные — знаком 
          <code class="literal">+</code>. Кроме этого <span class="command"><strong>svn diff</strong></span>
          печатает имена файлов и информацию о сдвиге информации, которая
          необходима программе <span class="command"><strong>patch</strong></span>, и, следовательно,
          вы можете получать <span class="quote">«<span class="quote">патчи</span>»</span>, перенаправив вывод
          различий в файл:</p><pre class="screen">$ svn diff &gt; patchfile
</pre><p>Вы можете, например, отправить по электронной почте
          файл патча другому разработчику для ознакомления или
          тестирования перед фиксацией.</p></div><div class="sect3" title="svn revert"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.cycle.examine.revert"></a><span class="command"><strong>svn revert</strong></span></h4></div></div></div><p>Теперь предположим, что, просмотрев вывод команды diff,
          вы обнаружили, что изменения в <code class="filename">README</code>
          ошибочны — к примеру, потому, что в своем редакторе 
          вы случайно набрали текст, предназначавшийся для другого 
          файла.</p><p>В такой ситуации как нельзя кстати окажется команда
          <span class="command"><strong>svn revert</strong></span>.</p><pre class="screen">$ svn revert README
Reverted 'README'
</pre><p>Subversion возвращает файл в состояние, предшествующее
          модификации, путем замены файла его кэшированной
          <span class="quote">«<span class="quote">первоначальной</span>»</span> копией из
          <code class="filename">.svn</code>-области. Кроме того, обратите внимание,
          что <span class="command"><strong>svn revert</strong></span> может отменить
          <span class="emphasis"><em>любые</em></span> запланированные операции —
          например, вы можете прийти к решению всё-таки не добавлять новый
          файл:</p><pre class="screen">$ svn status foo
?      foo

$ svn add foo
A         foo

$ svn revert foo
Reverted 'foo'

$ svn status foo
?      foo
</pre><div class="note" title="Примечание" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Примечание]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/note.png"></td><th align="left">Примечание</th></tr><tr><td valign="top" align="left"><p><span class="command"><strong>svn revert</strong></span>
            <em class="replaceable"><code>ITEM</code></em> будет иметь точно такой же эффект,
            как и удаление <em class="replaceable"><code>ITEM</code></em> из вашей рабочей
            копии, а затем выполнение <span class="command"><strong>svn update -r BASE</strong></span>
            <em class="replaceable"><code>ITEM</code></em>. Однако, если вы отменяете
            изменения для файла, <span class="command"><strong>svn revert</strong></span> будет иметь
            одно значительное отличие — для восстановления файла
            не происходит соединения с хранилищем.</p></td></tr></tbody></table></div><p>Или, допустим, вы ошибочно удалили файл из-под контроля
          версий:</p><pre class="screen">$ svn status README
       README

$ svn delete README
D         README

$ svn revert README
Reverted 'README'

$ svn status README
       README
</pre></div></div><div class="sect2" title="Разрешение конфликтов (при слиянии с чужими изменениями)"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.cycle.resolve"></a>Разрешение конфликтов (при слиянии с чужими 
        изменениями)</h3></div></div></div><p>Мы уже видели, как <span class="command"><strong>svn status -u</strong></span>
        может предупредить о конфликтах. Предположим, вы запустили
        <span class="command"><strong>svn update</strong></span> и увидели кое-что
        интересное:</p><pre class="screen">$ svn update
U  INSTALL
G  README
C  bar.c
Updated to revision 46.
</pre><p>Коды <code class="computeroutput">U</code> и
        <code class="computeroutput">G</code> интереса не представляют;
        эти файлы без проблем поглотили изменения из хранилища.
        Файлы, отмеченные <code class="computeroutput">U</code>, локальных
        изменений не содержат и были <code class="computeroutput">U</code>pdated
        — обновлены изменениями из хранилища. Отмеченные
        <code class="computeroutput">G</code> были
        mer<code class="computeroutput">G</code>ed — слиты, это значит, что
        файл имел локальные изменения, но изменения, пришедшие из хранилища,
        не перекрываются с локальными изменениями.</p><p>А вот файлы, отмеченные <code class="computeroutput">C</code>, 
        имеют конфликт. Это значит, что изменения с сервера пересеклись 
        с вашими личными, и теперь вам нужно вручную сделать между ними 
        выбор.</p><p>Всякий раз, когда возникает конфликт, в его обнаружении и 
        разрешении вам, как правило, помогают три вещи:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Subversion печатает <code class="computeroutput">C</code>
            во время обновления и запоминает, что файл в состоянии
            конфликта.</p></li><li class="listitem"><p>Если Subversion считает, что тип файла допускает 
            слияние изменений, она включает в него
            <em class="firstterm">маркеры конфликта</em> —
            специальные текстовые строки, отделяющие
            <span class="quote">«<span class="quote">стороны</span>»</span> конфликта —
            чтобы визуально показать пересекающиеся области.
            (Subversion использует свойство <code class="literal">svn:mime-type</code>
            для определения возможности контекстного, построчного слияния.
            См. <a class="xref" href="#svn.advanced.props.special.mime-type" title="Тип содержимого файла">«Тип содержимого файла»</a>
            для более подробной информации.)</p></li><li class="listitem"><p>Для каждого конфликтного файла Subversion добавляет в
            рабочую копию до трех не версионированных дополнительных
            файлов:</p><div class="variablelist"><dl><dt><span class="term"><code class="filename">filename.mine</code></span></dt><dd><p>Это ваш файл в том виде, в каком он присутствовал в
                  рабочей копии до обновления — без маркеров
                  конфликта. Этот файл содержит в себе только ваши изменения
                  и ничего больше. (Если Subversion решает, что файл не
                  пригоден для слияния изменений, то файл <code class="filename">.mine</code>
                  не создается, так как он будет идентичным рабочему
                  файлу.)</p></dd><dt><span class="term"><code class="filename">filename.rOLDREV</code></span></dt><dd><p>Это файл правки <code class="literal">BASE</code>, где
                  <code class="literal">BASE</code> — правка, которая была до 
                  обновления рабочей копии. Иными словами, это файл, который 
                  был у вас до внесения изменений.</p></dd><dt><span class="term"><code class="filename">filename.rNEWREV</code></span></dt><dd><p>Это файл, который ваш Subversion-клиент
                  получил с сервера при обновлении 
                  рабочей копии. Этот файл соответствует правке
                  <code class="literal">HEAD</code> хранилища.</p></dd></dl></div><p>Здесь <code class="literal">OLDREV</code> — это номер правки 
            файла в каталоге <code class="filename">.svn</code>, а
            <code class="literal">NEWREV</code> — номер правки
            <code class="literal">HEAD</code> хранилища.</p></li></ul></div><p>Например, Салли внесла изменения в файл
        <code class="filename">sandwich.txt</code> из хранилища. Одновременно Гарри
        изменил файл в своей рабочей копии и зафиксировал
        его. Салли обновляет свою рабочую копию перед фиксацией и получает
        конфликт:</p><pre class="screen">$ svn update
C  sandwich.txt
Updated to revision 2.
$ ls -1
sandwich.txt
sandwich.txt.mine
sandwich.txt.r1
sandwich.txt.r2
</pre><p>Теперь Subversion <span class="emphasis"><em>не</em></span> позволит зафиксировать
        файл <code class="filename">sandwich.txt</code>, пока не будут удалены три
        временных файла.</p><pre class="screen">$ svn commit --message "Add a few more things"
svn: Commit failed (details follow):
svn: Aborting commit: '/home/sally/svn-work/sandwich.txt' remains in conflict
</pre><p>Для разрешения конфликта у вас есть три варианта:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Объединить конфликтующий текст <span class="quote">«<span class="quote">вручную</span>»</span>
              (путем анализа и редактирования маркеров конфликта в
              файле).</p></li><li class="listitem"><p>Скопировать один из временных файлов поверх
              своего рабочего файла.</p></li><li class="listitem"><p>Выполнить <span class="command"><strong>svn revert &lt;filename&gt;</strong></span>
              для отказа от всех ваших локальных изменений.</p></li></ul></div><p>После разрешения конфликта вам нужно известить об этом
        Subversion, выполнив <span class="command"><strong>svn resolved</strong></span>.
        Эта команда удалит три временных файла, и Subversion больше 
        не будет считать, что файл находится в состоянии конфликта.
        <sup>[<a id="idp8406448" href="#ftn.idp8406448" class="footnote">10</a>]</sup></p><pre class="screen">$ svn resolved sandwich.txt
Resolved conflicted state of 'sandwich.txt'
</pre><div class="sect3" title="Слияние конфликтов вручную"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.cycle.resolve.byhand"></a>Слияние конфликтов вручную</h4></div></div></div><p>Слияние конфликтов вручную может показаться пугающим,
          когда вы делаете это в первый раз, но после небольшой практики 
          станет для вас таким же простым, как езда на велосипеде.</p><p>Возьмем пример. По недоразумению вы и ваш соразработчик Салли
          одновременно редактируете файл <code class="filename">sandwich.txt</code>.  
          Салли зафиксировала свои изменения, и поэтому при обновлении
          своей рабочей копии вы получите конфликт, для разрешения которого 
          вам необходимо отредактировать <code class="filename">sandwich.txt</code>. 
          Для начала посмотрим на файл:</p><pre class="screen">$ cat sandwich.txt
Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
Creole Mustard
Bottom piece of bread
</pre><p>Строки, начинающиеся со знаком <span class="quote">«<span class="quote">меньше чем</span>»</span>, 
          <span class="quote">«<span class="quote">равно</span>»</span> и <span class="quote">«<span class="quote">больше чем</span>»</span>, являются 
          маркерами конфликта. Перед следующей фиксацией вам нужно будет 
          убедиться, что они удалены из файла. Текст между первыми двумя 
          маркерами состоит из ваших изменений в конфликтующей области:</p><pre class="screen">&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======
</pre><p>Текст между вторым и третьим маркером конфликта —
          это текст из фиксации Салли:</p><pre class="screen">=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
</pre><p>Скорее всего вы не захотите просто удалить маркеры конфликта
          и изменения, сделанные Салли, — она ужасно удивится, 
          когда дойдет до
          сандвича и не увидит того, что ожидала. Это как раз тот случай,
          когда вы снимаете трубку или пересекаете офис и объясняете Салли,
          что не можете получить из итальянского гастронома квашеную капусту.
          <sup>[<a id="idp8419744" href="#ftn.idp8419744" class="footnote">11</a>]</sup> После того, как
          вы согласуете изменения, нужно будет выполнить фиксацию. Для этого 
          отредактируйте ваш файл и удалите маркеры конфликта.</p><pre class="screen">Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
Salami
Mortadella
Prosciutto
Creole Mustard
Bottom piece of bread
</pre><p>Теперь выполните <span class="command"><strong>svn resolved</strong></span>, и вы
          готовы к фиксации изменений:</p><pre class="screen">$ svn resolved sandwich.txt
$ svn commit -m "Go ahead and use my sandwich, discarding Sally's edits."
</pre><p>Обратите внимание на то, что <span class="command"><strong>svn resolved</strong></span>,
          в отличие от большинства команд, с которыми мы имели дело в этой главе,
          требует аргумент. В любом случае будьте осторожны и выполняйте
          <span class="command"><strong>svn resolved</strong></span> тогда, когда вы убеждены, что исправили
          конфликт в файле. После того как временные файлы будут удалены,
          Subversion позволит вам зафиксировать файл, даже если он все еще
          содержит маркеры конфликта.</p><p>Если вы испытываете затруднения при редактировании
          конфликтующего файла, всегда можно обратиться к тем трем
          файлам, которые Subversion создает в рабочей копии —
          включая ваш файл в том виде, в каком он был до обновления.
          Для анализа этих трех файлов вы даже можете воспользоваться
          программами для слияния изменений от сторонних разработчиков.</p></div><div class="sect3" title="Копирование файла поверх вашего рабочего файла"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.cycle.resolve.copyover"></a>Копирование файла поверх вашего рабочего файла</h4></div></div></div><p>Если вы получили конфликт и решили отказаться от своих
          изменений, вы можете просто скопировать один из временных файлов,
          созданных Subversion, поверх файла в рабочей копии:</p><pre class="screen">$ svn update
C  sandwich.txt
Updated to revision 2.
$ ls sandwich.*
sandwich.txt  sandwich.txt.mine  sandwich.txt.r2  sandwich.txt.r1
$ cp sandwich.txt.r2 sandwich.txt
$ svn resolved sandwich.txt
</pre></div><div class="sect3" title="Использование svn revert"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.cycle.resolve.revert"></a>Использование <span class="command"><strong>svn revert</strong></span></h4></div></div></div><p>Если вы получили конфликт и, проанализировав, решили
          отбросить изменения и начать сначала, просто отмените ваши
          изменения:</p><pre class="screen">$ svn revert sandwich.txt
Reverted 'sandwich.txt'
$ ls sandwich.*
sandwich.txt
</pre><p>Обратите внимание, что при возврате конфликтующего файла 
        к исходному состоянию вам не нужно выполнять <span class="command"><strong>svn
        resolved</strong></span>.</p></div></div><div class="sect2" title="Фиксация изменений"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.cycle.commit"></a>Фиксация изменений</h3></div></div></div><p>Наконец-то! Вы закончили с редактированием, слили
        все изменения с сервера и готовы к тому, чтобы зафиксировать
        их в хранилище.</p><p>Команда <span class="command"><strong>svn commit</strong></span> отправляет все ваши
        изменения в хранилище. При фиксации изменений необходимо описать 
        ваши изменения в тексте <em class="firstterm">лог-сообщения</em>.
        Лог-сообщение будет присоединено к созданной правке. Если ваше
        лог-сообщение короткое, вы можете указать его в командной строке,
        используя опцию <code class="option">--message</code> (или
        <code class="option">-m</code>):</p><pre class="screen">$ svn commit --message "Corrected number of cheese slices."
Sending        sandwich.txt
Transmitting file data .
Committed revision 3.
</pre><p>Однако, если вы заранее составляли лог-сообщение в процессе 
        работы, можно попросить Subversion взять его из файла,
        передав имя этого файла в параметре <code class="option">--file</code>:</p><pre class="screen">$ svn commit --file logmsg
Sending        sandwich.txt
Transmitting file data .
Committed revision 4.
</pre><p>Если вы не укажете ни опции <code class="option">--message</code>, ни
        опции <code class="option">--file</code>, для составления лог сообщения
        Subversion автоматически запустит ваш любимый редактор (см.
        <code class="literal">editor-cmd</code> в разделе
        <a class="xref" href="#svn.advanced.confarea.opts.config" title="Config">«Config»</a>).</p><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>Если, набирая сообщение в редакторе, вы решите отменить 
          фиксацию, то можете просто выйти из редактора без сохранения 
          изменений. Если вы уже сохранили сообщение, просто удалите 
          текст и выполните сохранение еще раз.</p><pre class="screen">$ svn commit
Waiting for Emacs...Done

Log message unchanged or not specified
a)bort, c)ontinue, e)dit
a
$
</pre></td></tr></tbody></table></div><p>Хранилище, в общем-то, не знает ничего о смысле ваших
        изменений; оно только контролирует, чтобы никто не изменил
        те же файлы, что и вы. Если это все-таки
        <span class="emphasis"><em>случилось</em></span>, вся фиксация будет отклонена,
        и вы получите сообщение о том, что один или несколько файлов
        устарели:</p><pre class="screen">$ svn commit --message "Add another rule"
Sending        rules.txt
svn: Commit failed (details follow):
svn: Out of date: 'rules.txt' in transaction 'g'
</pre><p>В таком случае вам нужно выполнить <span class="command"><strong>svn update</strong></span>,
        разобраться со всеми слияниями и конфликтами и попытаться
        выполнить фиксацию снова.</p><p>Мы рассмотрели простейший рабочий цикл использования
        Subversion. В Subversion существует много других возможностей,
        которые вы можете применять для управления рабочей копией и
        хранилищем; но очень многое можно сделать, используя исключительно 
        команды, рассмотренные в этой главе.</p></div></div><div class="sect1" title="Анализ истории"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.history"></a>Анализ истории</h2></div></div></div><p>Как мы уже говорили, хранилище похоже на машину времени.
      Оно хранит запись о любом когда-либо зафиксированном изменении
      и позволяет вам просмотреть его хронологию путем анализа
      предыдущих версий файлов и каталогов, а также 
      присоединенных к ним метаданных. Одной командой Subversion
      вы можете создать рабочую копию (или восстановить существующую)
      точно в том виде, в каком она была в любой момент времени или 
      после фиксации правки с указанным номером. Однако, иногда вам 
      просто нужно <span class="emphasis"><em>заглянуть</em></span> в прошлое, но не 
      <span class="emphasis"><em>возвращаться</em></span> в него.</p><p>Существует несколько команд, которые могут предоставить вам 
      хронологическую информацию из хранилища:</p><div class="variablelist"><dl><dt><span class="term"><span class="command"><strong>svn log</strong></span></span></dt><dd><p>Показывает вам развернутую информацию: лог-сообщения,
            присоединенные к правкам, с указанием даты изменений и их
            авторов, а также изменения путей к файлам в каждой правке.</p></dd><dt><span class="term"><span class="command"><strong>svn diff</strong></span></span></dt><dd><p>Показывает подробности того, как изменился файл 
              с течением времени.</p></dd><dt><span class="term"><span class="command"><strong>svn cat</strong></span></span></dt><dd><p>Эта команда используется для получения отдельного файла
              в том виде, в каком он был в конкретной ревизии и вывода его
              на экран.</p></dd><dt><span class="term"><span class="command"><strong>svn list</strong></span></span></dt><dd><p>Показывает список файлов в каталоге для любой указанной
              правки.</p></dd></dl></div><div class="sect2" title="svn log"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.history.log"></a><span class="command"><strong>svn log</strong></span></h3></div></div></div><p>Для того, чтобы найти информацию о хронологии файла
        или каталога, воспользуйтесь командой <span class="command"><strong>svn log</strong></span>.
        <span class="command"><strong>svn log</strong></span> показывает информацию о том, кто изменял
        файл или каталог, в какой правке это произошло, дату и время правки
        и присоединенное к фиксации лог-сообщение, если оно доступно.</p><pre class="screen">$ svn log
------------------------------------------------------------------------
r3 | sally | Mon, 15 Jul 2002 18:03:46 -0500 | 1 line

Added include lines and corrected # of cheese slices.
------------------------------------------------------------------------
r2 | harry | Mon, 15 Jul 2002 17:47:57 -0500 | 1 line

Added main() methods.
------------------------------------------------------------------------
r1 | sally | Mon, 15 Jul 2002 17:40:08 -0500 | 1 line

Initial import
------------------------------------------------------------------------
</pre><p>Обратите внимание на то, что по умолчанию лог сообщения
        выводятся в <span class="emphasis"><em>обратном хронологическом порядке</em></span>.
        Если вам нужно увидеть другой диапазон правок в заранее определенном
        порядке или только одну правку, укажите параметр
        <code class="option">--revision</code> (<code class="option">-r</code>):</p><pre class="screen">$ svn log --revision 5:19    # shows logs 5 through 19 in chronological order

$ svn log -r 19:5            # shows logs 5 through 19 in reverse order

$ svn log -r 8               # shows log for revision 8
</pre><p>Кроме того, можно проанализировать историю лог-сообщений
        отдельного файла или каталога. Например:</p><pre class="screen">$ svn log foo.c
…
$ svn log http://foo.com/svn/trunk/code/foo.c
…
</pre><p>В результате будут показаны лог-сообщения
        <span class="emphasis"><em>только</em></span> для тех правок, в которых изменялся 
        рабочий файл (или URL).</p><p>Если вам нужно еще больше информации о файле или каталоге,
        то для <span class="command"><strong>svn log</strong></span> есть параметр
        <code class="option">--verbose</code> (<code class="option">-v</code>). Так как
        Subversion позволяет перемещать и копировать файлы и каталоги,
        важно отслеживать изменения путей в файловой системе. Поэтому 
        в режиме расширенного вывода <span class="command"><strong>svn log</strong></span> включает 
        перечень измененных в правке путей:</p><pre class="screen">$ svn log -r 8 -v
------------------------------------------------------------------------
r8 | sally | 2002-07-14 08:15:29 -0500 | 1 line
Changed paths:
M /trunk/code/foo.c
M /trunk/code/bar.h
A /trunk/code/doc/README

Frozzled the sub-space winch.

------------------------------------------------------------------------
</pre><p>Кроме того, <span class="command"><strong>svn log</strong></span> имеет параметр 
        <code class="option">--quiet</code> (<code class="option">-q</code>), сокращающий лог
        сообщение. При его объединении с <code class="option">--verbose</code>
        выдаются только имена измененных файлов.</p><div class="sidebar" title="Почему svn log ничего не выводит?"><div class="titlepage"><div><div><p class="title"><strong>Почему <span class="command"><strong>svn log</strong></span> ничего не выводит?</strong></p></div></div></div><p>Поработав немного с Subversion, многие пользователи
          сталкиваются с чем-то похожим:</p><pre class="screen">$ svn log -r 2
------------------------------------------------------------------------
$
</pre><p>На первый взгляд это выглядит как ошибка. Однако учтите, что,
          поскольку правки привязаны к хранилищу, <span class="command"><strong>svn log</strong></span>
          использует путь из хранилища. Если путь не указан,
          Subversion по умолчанию будет использовать в качестве целевого
          объекта текущий рабочий каталог. В результате, если вы
          будете находиться в подкаталоге рабочей копии и попытаетесь
          посмотреть лог правки, в которой ни этот каталог, ни его
          подкаталоги не менялись, Subversion покажет пустой лог.
          Если вы хотите знать, что менялось в этой правке, попробуйте
          направить <span class="command"><strong>svn log</strong></span> прямо на самый верхний URL
          вашего хранилища, примерно таким образом: <span class="command"><strong>svn log -r 2
          http://svn.collab.net/repos/svn</strong></span>.</p></div></div><div class="sect2" title="svn diff"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.history.diff"></a><span class="command"><strong>svn diff</strong></span></h3></div></div></div><p>Ранее мы уже познакомились с <span class="command"><strong>svn diff</strong></span>
        — эта команда показывает различия файла в едином формате
        представления различий; она используется для того, что бы показать
        локальные изменения, внесенные в рабочую копию, перед их фиксацией в
        хранилище.</p><p>Вообще, существует <span class="emphasis"><em>три</em></span> возможных варианта
        использования <span class="command"><strong>svn diff</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Анализ локальных изменений</p></li><li class="listitem"><p>Сравнение рабочей копии с хранилищем</p></li><li class="listitem"><p>Сравнение хранилища с хранилищем</p></li></ul></div><div class="sect3" title="Анализ локальных изменений"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.history.diff.local"></a>Анализ локальных изменений</h4></div></div></div><p>Как мы уже знаем, запуск <span class="command"><strong>svn diff</strong></span> без
          параметров сравнивает рабочие файлы с кэшированными
          в <code class="filename">.svn</code> <span class="quote">«<span class="quote">первоначальными</span>»</span>
          копиями:</p><pre class="screen">$ svn diff
Index: rules.txt
===================================================================
--- rules.txt (revision 3)
+++ rules.txt (working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$
</pre></div><div class="sect3" title="Сравнение рабочей копии с хранилищем"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.history.diff.wcrepos"></a>Сравнение рабочей копии с хранилищем</h4></div></div></div><p>Если в <code class="option">--revision</code> (<code class="option">-r</code>)
          указан один номер, то рабочая копия сравнивается
          с указанной правкой хранилища.</p><pre class="screen">$ svn diff --revision 3 rules.txt
Index: rules.txt
===================================================================
--- rules.txt (revision 3)
+++ rules.txt (working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$
</pre></div><div class="sect3" title="Сравнение хранилища с хранилищем"><div class="titlepage"><div><div><h4 class="title"><a id="svn.tour.history.diff.reposrepos"></a>Сравнение хранилища с хранилищем</h4></div></div></div><p>Если через <code class="option">--revision</code> (<code class="option">-r</code>)
          передаются две правки, разделенные двоеточием, то непосредственно
          сравниваются две правки.</p><pre class="screen">$ svn diff --revision 2:3 rules.txt
Index: rules.txt
===================================================================
--- rules.txt (revision 2)
+++ rules.txt (revision 3)
@@ -1,4 +1,4 @@
 Be kind to others
-Freedom = Chocolate Ice Cream
+Freedom = Responsibility
 Everything in moderation
 Chew with your mouth open
$
</pre><p><span class="command"><strong>svn diff</strong></span> можно использовать не только для 
          сравнения файлов, присутствующих в рабочей копии. Если вы укажете
          в качестве аргумента URL, то сможете анализировать различия между
          элементами, даже не имея рабочей копии. Это полезно в случае,
          если вы хотите проверить изменения файла тогда, когда у вас нет его
          рабочей копии на локальной машине:</p><pre class="screen">$ svn diff --revision 4:5 http://svn.red-bean.com/repos/example/trunk/text/rules.txt
…
$
</pre></div></div><div class="sect2" title="svn cat"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.history.cat"></a><span class="command"><strong>svn cat</strong></span></h3></div></div></div><p>Если вы хотите проанализировать ранние версии файла, а не
        различия между двумя файлами, можно воспользоваться
        <span class="command"><strong>svn cat</strong></span>:</p><pre class="screen">$ svn cat --revision 2 rules.txt
Be kind to others
Freedom = Chocolate Ice Cream
Everything in moderation
Chew with your mouth open
$
</pre><p>Или вы можете перенаправить вывод прямо в файл:</p><pre class="screen">$ svn cat --revision 2 rules.txt &gt; rules.txt.v2
$
</pre><p>Наверное, вам интересно, почему для замены файла старой правкой
        мы не воспользовались <span class="command"><strong>svn update --revision</strong></span>.
        Есть несколько причин, по которым нам оказалось
        предпочтительнее воспользоваться
        <span class="command"><strong>svn cat</strong></span>.</p><p>Во-первых, вы могли захотеть увидеть различия между
        двумя правками одного файла, используя внешнюю программу
        просмотра различий (возможно, с графическим интерфейсом
        или работающую с файлами таких форматов, для которых единый формат 
        представления различий не пригоден). В этом случае вам нужно вытащить
        копию старой правки, перенаправить ее в файл и передать
        этот файл вместе с файлом рабочей копии внешней программе
        просмотра различий.</p><p>Во-вторых, иногда проще посмотреть полную старую версию файла чем
        различия между ним и его другой правкой.</p></div><div class="sect2" title="svn list"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.history.list"></a><span class="command"><strong>svn list</strong></span></h3></div></div></div><p>Команда <span class="command"><strong>svn list</strong></span> показывает содержимое
        каталога в хранилище, при этом не закачивая его на локальную
        машину:</p><pre class="screen">$ svn list http://svn.collab.net/repos/svn
README
branches/
clients/
tags/
trunk/
</pre><p>Если вам нужна более подробная информация, воспользуйтесь
        флагом <code class="option">--verbose</code> (<code class="option">-v</code>), и вы увидете
        что-то подобное:</p><pre class="screen">$ svn list --verbose http://svn.collab.net/repos/svn
   2755 harry          1331 Jul 28 02:07 README
   2773 sally               Jul 29 15:07 branches/
   2769 sally               Jul 29 12:07 clients/
   2698 harry               Jul 24 18:07 tags/
   2785 sally               Jul 29 19:07 trunk/
</pre><p>Колонки показывают правку, в которой файл или каталог последний
        раз изменялись, имя пользователя, вносившего изменения, размер (если это
        файл), дату последнего изменения и имя элемента.</p></div><div class="sect2" title="Заключительное слово об истории"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.history.finalword"></a>Заключительное слово об истории</h3></div></div></div><p>В дополнение ко всем упомянутым выше командам, можно
        воспользоваться <span class="command"><strong>svn update</strong></span> и <span class="command"><strong>svn
        checkout</strong></span> с параметром <code class="option">--revision</code>,
        чтобы переместить рабочую копию <span class="quote">«<span class="quote">назад во
        времени</span>»</span><sup>[<a id="idp8565744" href="#ftn.idp8565744" class="footnote">12</a>]</sup>:</p><pre class="screen">$ svn checkout --revision 1729 # Checks out a new working copy at r1729
…
$ svn update --revision 1729 # Updates an existing working copy to r1729
…
</pre></div></div><div class="sect1" title="Другие полезные команды"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.other"></a>Другие полезные команды</h2></div></div></div><p>Хотя эти команды используются не так часто, как 
        рассмотренные ранее в этой главе, иногда они вам все-таки 
        пригодятся.</p><div class="sect2" title="svn cleanup"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.other.cleanup"></a><span class="command"><strong>svn cleanup</strong></span></h3></div></div></div><p>Когда Subversion изменяет рабочую копию (или любую информацию
        в области <code class="filename">.svn</code>), она пытается делать это
        как можно более осторожно. Перед изменением рабочей
        копии Subversion записывает свои намерения в лог-файл. Затем
        для выполнения запрошенных изменений она выполняет  команды из 
        лог-файла, устанавливая блокировку той части рабочей копии, с которой
        работает — это делается для предотвращения работы других
        Subversion-клиентов с той рабочей копией, которая находится в
        промежуточном состоянии. После выполнения запрошеных действий
        Subversion удаляет лог файл. Архитектурно это
        напоминает журналируемую файловую систему. Если работа Subversion
        была прервана (в результате того, что процесс был убит или, например,
        из-за машинного сбоя), лог файлы остаются на диске. Перезапустив
        выполнение лог файлов, Subversion может завершить предварительно
        начатые операции, и рабочая копия снова вернется в согласованное
        состояние.</p><p>Именно это, собственно, и делает <span class="command"><strong>svn cleanup</strong></span>:
        она ищет в рабочей копии и выполняет незавершенные лог-файлы,
        удаляя по ходу выполнения блокировки в рабочей копии. Если Subversion
        когда-нибудь говорила вам о том, что часть рабочей копии
        <span class="quote">«<span class="quote">заблокирована</span>»</span>, то вам нужно запустить эту команду.
        Кроме того, <span class="command"><strong>svn status</strong></span> покажет для заблокированных
        элементов букву <code class="literal">L</code>:</p><pre class="screen">$ svn status
  L    somedir
M      somedir/foo.c

$ svn cleanup
$ svn status
M      somedir/foo.c
</pre><p>Не путайте эти блокировки рабочей копии с обычными 
        блокировками, которые устанавливают пользователи Subversion,
        использующие модель конкурентного управления версиями
        <span class="quote">«<span class="quote">блокировка-изменение-разблокировка</span>»</span>; за более 
        подробным определением обратитесь к <a class="xref" href="#svn.advanced.locking.meanings" title="Three meanings of «lock»">Three meanings of <span class="quote">«<span class="quote">lock</span>»</span></a></p></div><div class="sect2" title="svn import"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.other.import"></a><span class="command"><strong>svn import</strong></span></h3></div></div></div><p>Команда <span class="command"><strong>svn import</strong></span> — это быстрый способ
        скопировать неверсионированное дерево файлов в хранилище,
        cоздавая при необходимости подкаталоги.</p><pre class="screen">$ svnadmin create /usr/local/svn/newrepos
$ svn import mytree file:///usr/local/svn/newrepos/some/project \
             -m "Initial import"
Adding         mytree/foo.c
Adding         mytree/bar.c
Adding         mytree/subdir
Adding         mytree/subdir/quux.h

Committed revision 1.
</pre><p>В предыдущем примере выполняется копирование содержимого
        каталога <code class="filename">mytree</code> в каталог
        <code class="filename">some/project</code> хранилища:</p><pre class="screen">$ svn list file:///usr/local/svn/newrepos/some/project
bar.c
foo.c
subdir/
</pre><p>Обратите внимание на то, что после завершения импорта
        оригинальное дерево файлов <span class="emphasis"><em>не</em></span>
        конвертируется в рабочую копию. Чтобы начать работать, вам
        необходимо создать новую рабочую копию (<span class="command"><strong>svn
        checkout</strong></span>) дерева файлов.</p></div></div><div class="sect1" title="Подводя итоги"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.summary"></a>Подводя итоги</h2></div></div></div><p>К настоящему моменту мы рассмотрели большинство команд клиента
        Subversion, за исключением тех, которые предназначены для работы с
        ветвлениями и слияниями (см. <a class="xref" href="#svn.branchmerge" title="Глава 4. Ветвление и слияние">Глава&nbsp;4, <em>Ветвление и слияние</em></a>) и
        свойствами (см. <a class="xref" href="#svn.advanced.props" title="Свойства">«Свойства»</a>). Кроме этого,
        найдите время просмотреть <a class="xref" href="#svn.ref" title="Глава 9. Полное справочное руководство по Subversion">Глава&nbsp;9, <em>Полное справочное руководство по Subversion</em></a>, чтобы
        получить представление обо всем многообразии имеющихся у Subversion
        команд — и о том, как с их помощью вы можете упростить свою
        работу.</p></div><div class="footnotes"><br><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.idp8129280" href="#idp8129280" class="para">8</a>] </sup>Конечно,
              ничего полностью из хранилища не удаляется — удаление
              касается только <code class="literal">HEAD</code> правки хранилища. Вы 
              можете восстановить все, что вы удалили, создав рабочую 
              копию (или обновив существующую) на основе более ранней 
              правки, чем та, в которой вы удалили элемент.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp8313616" href="#idp8313616" class="para">9</a>] </sup>Subversion 
          использует свой внутренний
          механизм обнаружения различий, который по умолчанию использует для
          вывода единый формат представления различий. Если вы хотите получить
          различия в другом формате, укажите внешнюю программу поиска различий,
          используя <code class="option">--diff-cmd</code> и передав любые аргументы,
          которые вы хотите использовать, в параметре
          <code class="option">--extensions</code>. Например, для того чтобы увидеть
          контекстные локальные изменения в файле <code class="filename">foo.c</code>,
          игнорируя изменения в числе пробелов, запустите <span class="command"><strong>svn diff
          --diff-cmd /usr/bin/diff --extensions '-bc' foo.c</strong></span>.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp8406448" href="#idp8406448" class="para">10</a>] </sup>Вы можете удалить временные файлы самостоятельно
        — но стоит ли это делать, если можно переложить эту работу 
        на Subversion? Нам так не кажется.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp8419744" href="#idp8419744" class="para">11</a>] </sup>А если вы их об этом попросите, они лишь 
          посмеются над вами.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp8565744" href="#idp8565744" class="para">12</a>] </sup>Видите? Мы же говорили вам,
        что Subversion — это машина времени.</p></div></div></div><div class="chapter" title="Глава 3. Профессиональное использование Subversion"><div class="titlepage"><div><div><h2 class="title"><a id="svn.advanced"></a>Глава 3. Профессиональное использование Subversion</h2></div></div></div><div class="toc"><p><strong>Содержание</strong></p><dl><dt><span class="sect1"><a href="#svn.tour.revs.specifiers">Способы обозначения правок</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.tour.revs.keywords">Ключевые слова правок</a></span></dt><dt><span class="sect2"><a href="#svn.tour.revs.dates">Даты правок</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.props">Свойства</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.props.why">Зачем нужны свойства?</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.props.manip">Использование свойств</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.props.workflow">Свойства и рабочий цикл Subversion</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.props.auto">Автоматическая установка свойств</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.props.file-portability">Переносимость файлов</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.props.special.mime-type">Тип содержимого файла</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.props.special.executable">Исполнимость файла</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.props.special.eol-style">Символы конца строки</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.props.special.ignore">Пропуск неверсионированных элементов</a></span></dt><dt><span class="sect1"><a href="#svn.advanced.props.special.keywords">Подстановка ключевых слов</a></span></dt><dt><span class="sect1"><a href="#svn.advanced.locking">Locking</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.locking.creation">Creating locks</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.locking.discovery">Discovering locks</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.locking.break-steal">Breaking and stealing locks</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.locking.lock-communication">Lock Communication</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.externals">Внешние зависимости</a></span></dt><dt><span class="sect1"><a href="#svn.advanced.pegrevs">Стержневые и оперативные правки</a></span></dt></dl></div><p>Если вы читали эту книгу последовательно, глава за главой, 
    то к настоящему моменту должны иметь достаточно знаний
    для выполнения с помощью Subversion-клиента типовых
    операций управления версиями. Вы умеете создавать
    рабочую копию, знаете, как с помощью команд <span class="command"><strong>svn
    commit</strong></span> и <span class="command"><strong>svn update</strong></span> отправлять и
    получать изменения. Возможно, у вас уже даже выработался рефлекс
    бессознательного запуска <span class="command"><strong>svn status</strong></span>. Вы готовы
    применять Subversion в большинстве типовых ситуаций.</p><p>Однако возможности Subversion не ограничиваются 
    <span class="quote">«<span class="quote">типовыми операциями управления версиями</span>»</span>.  
    В Subversion реализован функционал, выходящий за пределы
    простого обмена различиями с центральным хранилищем.
  </p><p>В этой главе рассказывается о тех возможностях Subversion, которые,
    несмотря на свою важность, не используются в типичном ежедневном рабочем
    цикле. Чтобы читать дальше эту главу, необходимо хорошо представлять себе
    механизмы версионированния файлов и каталогов в Subversion.
    Если вы этого не знаете, прочитайте сначала <a class="xref" href="#svn.basic" title="Глава 1. Фундаментальные понятия">Глава&nbsp;1, <em>Фундаментальные понятия</em></a> 
    и <a class="xref" href="#svn.tour" title="Глава 2. Экскурсия по Subversion">Глава&nbsp;2, <em>Экскурсия по Subversion</em></a>.
    Овладев основами и изучив приемы, рассмотренные в этой главе, 
    вы станете действительно продвинутым пользователем Subversion!</p><div class="sect1" title="Способы обозначения правок"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.tour.revs.specifiers"></a>Способы обозначения правок</h2></div></div></div><p>Как вы уже заметили в <a class="xref" href="#svn.tour.revs" title="Путешествие во времени вместе с Subversion">«Путешествие во времени вместе с Subversion»</a>, 
      номера правок в Subversion — это не более чем целые числа,
      монотонно возрастающие при каждой фиксации изменений 
      версионированных данных. Пройдет совсем немного времени, и вы уже
      не сможете точно вспомнить, что произошло в каждой из правок.
      К счастью, типовая практика работы с Subversion не часто 
      предполагает указание вами конкретных правок, к которым 
      следует применить ту или иную операцию. 
      Для операций, которые требуют <span class="emphasis"><em>обязательной</em></span> 
      ссылки на конкретную правку, чаще всего указывают номер правки,
      который известен из сообщения о фиксации, вывода некоторых других 
      операций Subversion или из каких-либо других обстоятельств,
      которые могли бы дать этот конкретный номер.</p><p>Однако, иногда у вас может возникнуть необходимость сослаться
      на момент времени, для которого у вас уже не осталось в памяти 
      или в записях точного номера правки. Поэтому, кроме целочисленных
      номеров правок, <span class="command"><strong>svn</strong></span> позволяет использовать
      дополнительные формы обозначения правок — ключевые 
      слова и даты правок.</p><div class="note" title="Примечание" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Примечание]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/note.png"></td><th align="left">Примечание</th></tr><tr><td valign="top" align="left"><p>При указании диапазонов правок можно смешивать различные 
        способы их обозначения, допустимые в Subversion.  Например, вы 
        можете использовать <code class="option">-r
        <em class="replaceable"><code>REV1</code></em>:<em class="replaceable"><code>REV2</code></em></code>,
        где <em class="replaceable"><code>REV1</code></em> — это ключевое слово, 
        а <em class="replaceable"><code>REV2</code></em> — обычный номер правки, или
        где <em class="replaceable"><code>REV1</code></em> — дата, а 
        <em class="replaceable"><code>REV2</code></em> — ключевое слово, и так далее.  
        Каждое обозначение правки будет интерпретироваться независимо друг 
        от друга, поэтому вы можете указать по другую сторону от двоеточия 
        что угодно.</p></td></tr></tbody></table></div><div class="sect2" title="Ключевые слова правок"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.revs.keywords"></a>Ключевые слова правок</h3></div></div></div><p>Клиент Subversion понимает ряд 
        <em class="firstterm">ключевых слов</em>.  Эти ключевые слова можно
        использовать вместо целочисленных аргументов опции 
        <code class="option">--revision</code>, при этом Subversion переведет их в 
        конкретные номера правок:</p><div class="variablelist"><dl><dt><span class="term">HEAD</span></dt><dd><p>Последняя (или <span class="quote">«<span class="quote">самая новая</span>»</span>) правка
              хранилища</p></dd><dt><span class="term">BASE</span></dt><dd><p>Номер правки элемента в рабочей копии. Если элемент
              редактировался, то <span class="quote">«<span class="quote">BASE версия</span>»</span> соответствует тому,
              как выглядел этот элемент до внесения локальных изменений.</p></dd><dt><span class="term">COMMITTED</span></dt><dd><p>Правка, в которой элемент последний раз изменялся
              (предшествующая либо равная <code class="literal">BASE</code>).</p></dd><dt><span class="term">PREV</span></dt><dd><p>Правка, непосредственно <span class="emphasis"><em>предшествующая</em></span> 
              той правке, в которой элемент был последний раз изменен. 
              (То есть, фактически, <code class="literal">COMMITTED</code> - 1.)</p></dd></dl></div><p>Из данного описания можно сделать очевидный вывод о том, что
        ключевые слова <code class="literal">PREV</code>, <code class="literal">BASE</code>, 
        и <code class="literal">COMMITTED</code> могут использоваться только при ссылках 
        на пути в рабочей копии; они не применимы к URL-адресам хранилища.
        Напротив, ключевое слово <code class="literal">HEAD</code> можно использовать
        совместно с обоими типами путей.</p><p>Ниже приведено несколько примеров использования ключевых слов
        правок:</p><pre class="screen">$ svn diff --revision PREV:COMMITTED foo.c

# показать последнее изменение, зафиксированное для foo.c

$ svn log --revision HEAD

# показать лог-сообщение для последней фиксации в хранилище

$ svn diff --revision HEAD

# сравнить ваш рабочий файл (с учетом локальных изменений)
# с последней правкой в хранилище

$ svn diff --revision BASE:HEAD foo.c

# сравнить ваш <span class="quote">«<span class="quote">исходный</span>»</span> foo.c (без учета локальных
# изменений) с последней версией в хранилище

$ svn log --revision BASE:HEAD

# показать все логи фиксаций со времени вашего последнего обновления

$ svn update --revision PREV foo.c

# отменить последние изменения в foo.c, понизив рабочую правку foo.c
      
$ svn diff -r BASE:14 foo.c

# сравнить неизмененную версию foo.c и версию foo.c в правке 14
</pre></div><div class="sect2" title="Даты правок"><div class="titlepage"><div><div><h3 class="title"><a id="svn.tour.revs.dates"></a>Даты правок</h3></div></div></div><p>Номера правок не несут никакой информации об окружающем мире
        за пределами системы управления версиями, тогда как вам иногда 
        требуется сопоставить момент времени в реальной жизни
        с моментом в истории версий. Чтобы помочь вам в этом, опция
        <code class="option">--revision</code> допускает указание даты, которую
        заключают в фигурные скобки (<code class="literal">{</code> и 
        <code class="literal">}</code>). Subversion принимает дату и время в формате,
        соответствующем стандарту ISO-8601, а также в некоторых других.
        Ниже приведено несколько примеров. (Не забывайте брать в кавычки
        любые даты, содержащие пробелы.)</p><pre class="screen">$ svn checkout -r {2006-02-17}
$ svn checkout -r {15:30}
$ svn checkout -r {15:30:00.200000}
$ svn checkout -r {"2006-02-17 15:30"}
$ svn checkout -r {"2006-02-17 15:30 +0230"}
$ svn checkout -r {2006-02-17T15:30}
$ svn checkout -r {2006-02-17T15:30Z}
$ svn checkout -r {2006-02-17T15:30-04:00}
$ svn checkout -r {20060217T1530}
$ svn checkout -r {20060217T1530Z}
$ svn checkout -r {20060217T1530-0500}
…
</pre><p>Когда вы указываете дату, Subversion находит в хранилище 
        наиболее близкую к ней правку, после чего продолжает работу с 
        вычисленным номером правки. </p><pre class="screen">$ svn log -r {2006-11-28}
------------------------------------------------------------------------
r12 | ira | 2006-11-27 12:31:51 -0600 (Mon, 27 Nov 2006) | 6 lines
…
</pre><div class="sidebar" title="Почему Subversion выдает правку за предыдущий день?"><div class="titlepage"><div><div><p class="title"><strong>Почему Subversion выдает правку за предыдущий день?</strong></p></div></div></div><p>Указав при обращении к правке только дату, без уточнения
          времени (например, <code class="literal">2006-11-27</code>), вы, 
          наверное, предположите, что Subversion должен выдать вам последнюю 
          правку за 27 ноября. 
          Однако, вместо этого вы можете получить правку за 26-е число или
          даже более раннюю. Помните, что Subversion будет искать в хранилище
          правку, <span class="emphasis"><em>наиболее отвечающую</em></span> указанной вами 
          дате. Если вы укажете дату без уточнения времени,
          например <code class="literal">2006-11-27</code>, Subversion примет за
          временную метку 00:00:00, и таким образом поиск ближайшей к 27-му
          числу правки не даст ничего, относящегося к 27 ноября.</p><p>Если вам необходимо найти именно 27-е число, вы можете либо
          указать это число с временной меткой (<code class="literal">{"2006-11-27
          23:59"}</code>), либо просто использовать в запросе следующий
          день (<code class="literal">{2006-11-28}</code>).</p></div><p>Также вы можете задавать диапазоны дат. Subversion
        найдет все правки между обеими датами включительно:</p><pre class="screen">$ svn log -r {2006-11-20}:{2006-11-29}
…
</pre><div class="warning" title="Предупреждение" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Предупреждение]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/warning.png"></td><th align="left">Предупреждение</th></tr><tr><td valign="top" align="left"><p>Временн<span class="emphasis"><em>ы</em></span>е метки правок 
          сохраняются как их неверсионированные изменяемые свойства 
          (см. <a class="xref" href="#svn.advanced.props" title="Свойства">«Свойства»</a> ). Исходя из этого, 
          изменением временн<span class="emphasis"><em>ы</em></span>х меток можно легко 
          исказить истинную хронологию, или даже удалить совсем информацию
          о времени правки.  Это может привести
          к неожиданным результатам при внутреннем преобразовании
          дат в номера правок, выполняемом Subversion.</p></td></tr></tbody></table></div></div></div><div class="sect1" title="Свойства"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.props"></a>Свойства</h2></div></div></div><p>Мы уже подробно рассмотрели, каким образом Subversion сохраняет 
      и извлекает различные версии файлов и каталогов из хранилища. 
      Несколько глав было посвящено этой самой фундаментальной  
      функциональной возможности данного инструмента. И даже если бы
      поддержка версионирования этим исчерпывалась, Subversion все равно 
      мог бы считаться полноценным средством управления версиями.</p><p>Однако Subversion этим не ограничивается.</p><p>Помимо версионированния каталогов и файлов,
      Subversion позволяет для каждого версионированного каталога или файла
      добавлять, изменять и удалять версионированные метаданные.
      Мы обращаемся к этим метаданным как
      к <em class="firstterm">свойствам</em>, которые можно представить
      в виде таблицы с двумя столбцами, присоединенной к каждому
      элементу рабочей копии и сопоставляющей имена свойств 
      соответствующим значениям. Вообще, имена и значения свойств могут быть 
      какими угодно; единственное ограничение — имена должны быть 
      читаемым текстом.
      Самое главное — то, что свойства версионированы точно
      так же, как и текстовое содержимое файлов. Изменять, фиксировать
      свойства или возвращать их в исходное состояние так же просто,
      как и делать то же самое с содержимым файлов.
      Отправка и получение измененных свойств происходит точно
      так же, как и обычные фиксации и обновления — для этого нет
      необходимости менять обычный порядок действий.</p><p>В Subversion существует еще одна разновидность свойств.
      Так же, как и файлы и каталоги, произвольные свойства и 
      соответствующие им значения может иметь каждая правка. 
      Ограничения здесь те же самые — свойство должно иметь 
      читаемое имя и может принимать любое бинарное значение. 
      Главное отличие заключается в том, что свойства правок 
      не версионируются.  Другими словами, если изменить
      значение свойства правки или удалить такое свойство, Subversion не
      сможет восстановить предыдущее значение.</p><p>В Subversion нет жестко определенных правил по использованию
      свойств.  Она требует только того, чтобы имена свойств не 
      начинались с префикса <code class="literal">svn:</code>, поскольку
      это пространство имен закреплено для служебного использования.  
      Subversion действительно использует свойства, как версионированные, 
      так и неверсионированные, для внутренних целей. Ряд версионированных
      свойств играет особую роль при поиске файлов и каталогов
      или хранит определенную информацию о правках, в которых они найдены.
      Ряд свойств автоматически присоединяется к правкам в процессе
      фиксации, и несет о них определенную информацию . Большинство таких 
      свойств упоминаются в этой или других главах при обсуждении более 
      обших тем, к которым они относятся. Исчерпывающий список 
      предопределенных свойств
      Subversion приводится в <a class="xref" href="#svn.ref.svnprops" title="Свойства Subversion">Свойства Subversion</a>.</p><p>В этом разделе мы рассмотрим полезность поддержки свойств как 
      для пользователя, так и для самой Subversion. Вы узнаете о 
      командах <span class="command"><strong>svn</strong></span>, относящихся к
      свойствам, и о том, как изменение свойств влияет на привычный рабочий
      цикл. Надеемся, вы убедитесь в том, что свойства в Subversion
      расширяют возможности управления версиями.</p><div class="sect2" title="Зачем нужны свойства?"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.props.why"></a>Зачем нужны свойства?</h3></div></div></div><p>Итак, Subversion использует свойства, чтобы хранить
        дополнительную информацию файлах, каталогах и правках.
        Вы можете найти свойствам аналогичное применение. 
        Наличие места рядом с версионированными данными, в котором 
        можно хранить пользовательские метаданные об этих данных,
        может пригодиться для поддержки ваших регламентов
        работы с кодом, или, возможно, для использования 
        какими-то дополнительными утилитами.</p><p>Допустим, вы разрабатываете веб-сайт, содержащий много
        цифровых фотографий и показывающий их с подписями и датой.
        Набор этих фотографий постоянно изменяется, поэтому сайт нужно
        по возможности максимально автоматизировать. Фотографии
        могут быть большого размера, поэтому, как обычно делают на таких
        сайтах, посетителям потребуется показывать миниатюры 
        изображений.</p><p>Эту задачу можно решить с помощью обычных файлов. 
        Рядом, в одном каталоге, вы можете иметь файлы
        <code class="filename">image123.jpg</code> и
        <code class="filename">image123-thumbnail.jpg</code>. Если важно
        сохранить оригинальное имя файла, миниатюры могут размещаться в
        отдельном каталоге (например, 
        <code class="filename">thumbnails/image123.jpg</code>). Таким же образом,
        отдельно от основного графического файла, можно хранить описание и
        дату. Проблема заключается в том, что файловая структура будет сильно
        разрастаться при каждом добавлении фотографии на сайт.</p><p>Теперь представим, как можно организовать работу того же веб-сайта,
        используя Subversion-свойства файлов. Допустим, имеется файл 
        <code class="filename">image123.jpg</code> и у этого файла установлены свойства
        <code class="literal">caption</code>, <code class="literal">datestamp</code> и даже
        <code class="literal">thumbnail</code>. В этом случае рабочая копия выглядит
        гораздо нагляднее. Фактически, она выглядит так, как будто содержит
        только сами графические файлы, и ничего больше.
        Однако ваши скрипты автоматизации знают, что с помощью 
        <span class="command"><strong>svn</strong></span> (а еще лучше языковой обвязки
        Subversion — см. <a class="xref" href="#svn.developer.usingapi.otherlangs" title="Using Languages Other than C and C++">«Using Languages Other than C and C++»</a>) можно получить
        дополнительную, необходимую для показа на сайте информацию,
        не занимаясь чтением индексного файла или манипуляциями с 
        путями.</p><p>Не менее часто используются пользовательские свойства правок.
        Одним из типичных примеров является свойство, хранящее ID
        записи в трекере, с которой сопоставлена данная правка — 
        например, потому что внесенные в правке изменения 
        исправляют ошибку, зафиксированную в трекере с данным ID.
        Другие варианты использования свойств правок — задание правке 
        более содержательного имени. Нелегко запомнить, что, к примеру, 
        правка 1935 полностью протестирована! Если же, скажем, задать свойству
        <code class="literal">результаты тестирования</code> в этой правке значение 
        <code class="literal">пройдены все тесты</code>, получится
        абсолютно четкая информация.</p><div class="sidebar" title="Эффективность поиска (или Что препятствует использованию свойств)"><div class="titlepage"><div><div><p class="title"><strong>Эффективность поиска (или Что <span class="emphasis"><em>препятствует</em></span>
          использованию свойств)</strong></p></div></div></div><p>Несмотря на всю пользу, свойства Subversion — или,
          точнее, доступные способы обращения к ним — обладают
          большим недостатком, снижающим их практическую ценность.
          Дело в том, что пользовательские свойства очень легко задать, 
          но их последующий <span class="emphasis"><em>поиск</em></span> 
          может оказаться серьезной проблемой.</p><p>Обращение к пользовательскому свойству правки
          обычно приводит к последовательному просмотру всех правок 
          хранилища. При этом каждая правка опрашивается: "Есть ли у тебя
          свойство, которое я ищу?" Поиск версионированного 
          пользовательского свойства также оказывается затратной, и часто
          приводит к рекурсивному вызову <span class="command"><strong>svn propget</strong></span> 
          по всей рабочей копии.  В вашей ситуации это, возможно, окажется
          не таким плохим вариантом, как последовательный просмотр всех правок.
          Но, в любом случае, такой подход оставляет желать лучшего 
          как с точки зрения производительности, так и с точки зрения 
          вероятности успеха, особенно если поиск потребует получения 
          рабочей копии корневой папки хранилища.</p><p>По этой причине стоит подумать над тем (в особенности,
          в случае со свойствами правок), чтобы просто добавить ваши 
          метаданные в лог-сообщение правки, придерживаясь при этом
          некоторого заранее оговоренного (и, возможно, программно 
          поддерживаемого) форматирования, допускающего впоследствии
          легкий разбор и анализ вывода команды <span class="command"><strong>svn log</strong></span>.
          В Subversion можно частенько увидеть такие характерные
          лог-сообщения:</p><pre class="programlisting">Issue(s): IZ2376, IZ1919
Reviewed by:  sally

This fixes a nasty segfault in the wort frabbing process
…
</pre><p>Но и здесь вас поджидает одна неприятность.  Subversion пока 
          еще не поддерживает механизма задания шаблонов для лог-сообщений,
          поэтому вам придется довольно долго разъяснять пользователям, 
          как им правильно форматировать сообщения, включая в них  
          метаданные правки.</p></div></div><div class="sect2" title="Использование свойств"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.props.manip"></a>Использование свойств</h3></div></div></div><p>Команда <span class="command"><strong>svn</strong></span> предоставляет несколько
        способов добавления или изменения свойств файлов и каталогов.
        Чтобы добавить свойство с коротким читаемым значением, наверное, 
        проще всего указать его имя и значение в командной строке
        подкоманды <span class="command"><strong>propset</strong></span>.</p><pre class="screen">$ svn propset copyright '(c) 2006 Red-Bean Software' calc/button.c
property 'copyright' set on 'calc/button.c'
$
</pre><p>Однако мы уже знаем о том, насколько гибкими могут быть 
        свойства Subversion. И если вам необходимо задать свойству
        многострочное текстовое или даже бинарное значение, передавать
        его через командную строку будет неудобно. Для
        таких случаев команда <span class="command"><strong>propset</strong></span> имеет
        параметр <code class="option">--file</code> (<code class="option">-F</code>), 
        позволяющий указать имя файла с новым значением свойства.</p><pre class="screen">$ svn propset license -F /path/to/LICENSE calc/button.c
property 'license' set on 'calc/button.c'
$
</pre><p>На имена свойств накладывается ряд ограничений. Имя должно
        начинаться с буквы, двоеточия (<code class="literal">:</code>) или подчеркивания
        (<code class="literal">_</code>); после них можно использовать цифры, тире
        (<code class="literal">-</code>) и точки (<code class="literal">.</code>).
          <sup>[<a id="idp9364816" href="#ftn.idp9364816" class="footnote">13</a>]</sup>
      </p><p>Кроме команды <span class="command"><strong>propset</strong></span>,
        <span class="command"><strong>svn</strong></span> предлагает команду <span class="command"><strong>propedit</strong></span>.
        Эта команда использует для добавления или изменения свойства заданную
        программу-редактор (см. <a class="xref" href="#svn.advanced.confarea.opts.config" title="Config">«Config»</a>). При выполнении
        команды <span class="command"><strong>svn</strong></span> вызывает редактор с временным файлом,
        содержащим текущее значение свойства (или с пустым файлом, если
        добавляется новое свойство). Затем вы просто изменяете в редакторе
        значение, пока оно не станет таким, каким вы хотели бы его видеть,
        сохраняете временный файл и выходите из редактора. Если Subversion
        обнаружит, что вы действительно изменили существующее значение
        свойства, будет записано новое значение. Если вы вышли из
        редактора, не внеся никаких изменений, модификации свойства не
        произойдет.</p><pre class="screen">$ svn propedit copyright calc/button.c  ### exit the editor without changes
No changes to property 'copyright' on 'calc/button.c'
$
</pre><p>Обращаем ваше внимание на то, что, подобно другим командам
        <span class="command"><strong>svn</strong></span>, команды, относящиеся к свойствам,
        могут применяться к нескольким путям за раз. Это дает возможность
        одной командой изменять свойства целого набора файлов. Например,
        можно сделать вот так:</p><pre class="screen">$ svn propset copyright '(c) 2006 Red-Bean Software' calc/*
property 'copyright' set on 'calc/Makefile'
property 'copyright' set on 'calc/button.c'
property 'copyright' set on 'calc/integer.c'
…
$
</pre><p>Все эти добавления и редактирования свойств были бы не слишком 
        полезны, если бы нельзя было просто узнать значение свойства. 
        Чтобы посмотреть имена и значения свойств, заданных для файлов и 
        каталогов, в <span class="command"><strong>svn</strong></span> есть две подкоманды.
        Команда <span class="command"><strong>svn proplist</strong></span> перечисляет существующие
        для указанного пути свойства. После того как вы узнаете имя свойства,
        с помощью <span class="command"><strong>svn propget</strong></span> можно запросить его
        значение. Эта команда выведет в стандартный поток ввода-вывода
        значение свойства для элемента по указанному пути (или путям) и с
        указанным именем.</p><pre class="screen">$ svn proplist calc/button.c
Properties on 'calc/button.c':
  copyright
  license
$ svn propget copyright calc/button.c
(c) 2006 Red-Bean Software
</pre><p>Существует даже вариант команды <span class="command"><strong>proplist</strong></span>,
        перечисляющий как имена, так и значения свойств. Нужно просто
        добавить параметр <code class="option">--verbose</code>
        (<code class="option">-v</code>).</p><pre class="screen">$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2006 Red-Bean Software
  license : ================================================================
Copyright (c) 2006 Red-Bean Software.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions, and the recipe for Fitz's famous
red-beans-and-rice.
…
</pre><p>Последняя команда, относящаяся к свойствам — 
        <span class="command"><strong>propdel</strong></span>. Несмотря на то, что Subversion
        позволяет сохранять свойства с пустыми значениями, полностью
        удалить свойство с помощью <span class="command"><strong>propedit</strong></span> или
        <span class="command"><strong>propset</strong></span> нельзя. Например, такая команда
        не даст желаемого эффекта:</p><pre class="screen">$ svn propset license '' calc/button.c
property 'license' set on 'calc/button.c'
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2006 Red-Bean Software
  license :
$
</pre><p>Для полного удаления свойств необходимо пользоваться
        подкомандой <span class="command"><strong>propdel</strong></span>. Ее синтаксис такой же,
        как и у других команд для работы со свойствами:</p><pre class="screen">$ svn propdel license calc/button.c
property 'license' deleted from 'calc/button.c'.
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2006 Red-Bean Software
$
</pre><p>Помните, мы говорили о неверсионированных свойствах
        правок? Их тоже можно изменять с помощью <span class="command"><strong>svn</strong></span>.
        Просто добавьте параметр командной строки <code class="option">--revprop</code>
        и укажите правку, свойство которой вы хотите изменить. Поскольку
        правки глобальны, указывать пути не требуется до тех пор, пока 
        вы находитесь в рабочей копии того хранилища, свойство правки в
        котором вам нужно изменить. В противном случае, нужно просто указать
        URL любого пути в интересующем вас хранилище (в том числе это может 
        быть и корневой URL хранилища). Например, вы можете заменить
        лог-сообщение фиксации в существующей правке. 
        <sup>[<a id="idp9400000" href="#ftn.idp9400000" class="footnote">14</a>]</sup>
        Если текущий рабочий каталог является частью рабочей копии хранилища, 
        можно просто выполнить команду <span class="command"><strong>svn propset</strong></span>, 
        не указывая целевой путь:</p><pre class="screen">$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop
property 'svn:log' set on repository revision '11'
$
</pre><p>Но даже если вы не выгружали из хранилища рабочую копию, 
        можно изменить свойство, указав корневой URL хранилища:</p><pre class="screen">$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop \
              http://svn.example.com/repos/project
property 'svn:log' set on repository revision '11'
$
</pre><p>Обратите внимание на то, что изменение этих
        неверсионированных свойств должно быть явно разрешено
        администратором (см. <a class="xref" href="#svn.reposadmin.create.hooks" title="Hook Scripts">«Hook Scripts»</a>). 
        Учитывая то, что свойства не версионируются, при неаккуратном 
        редактировании вы рискуете потерять информацию. Чтобы предотвратить 
        потерю информации,
        администратор хранилища может принять меры предосторожности, и
        по умолчанию изменение неверсионированных свойств
        запрещено.</p><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>Пользователям следует, по возможности, пользоваться <span class="command"><strong>svn
          propedit</strong></span> вместо <span class="command"><strong>svn
          propset</strong></span>.  Хотя конечный результат обеих команд будет 
          одинаков, первая позволит увидеть текущее значение свойства перед
          изменением, и таким образом удостовериться, что вносятся именно 
          те изменения, которые были задуманы. В особенности это справедливо
          для модификации неверсионированных свойств правок. Да и изменять
          свойства с многострочными значениями гораздо проще в текстовом 
          редакторе, а не в командной строке.</p></td></tr></tbody></table></div></div><div class="sect2" title="Свойства и рабочий цикл Subversion"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.props.workflow"></a>Свойства и рабочий цикл Subversion</h3></div></div></div><p>Теперь, когда вы познакомились со всеми командами 
        <span class="command"><strong>svn</strong></span>, имеющими отношение к свойствам, 
        давайте посмотрим,
        как изменения свойств влияют на привычный порядок работы с
        Subversion. Как мы уже говорили, свойства файлов и каталогов 
        версионированы аналогично содержимому файлов. Поэтому
        Subversion предоставляет те же возможности по слиянию
        — в случае конфликтных ситуаций — чужих изменений
        с вашими собственными.</p><p>Так же как и в случае с содержимым файлов, изменения свойств
        являются локальной модификацией и становятся постоянными только при их
        фиксации в хранилище с помощью <span class="command"><strong>svn commit</strong></span>.
        Изменение свойств можно легко отменить — команда
        <span class="command"><strong>svn revert</strong></span> восстановит файлы и каталоги
        в их первоначальное состояние, включая содержимое, свойства и
        все остальное. Кроме того, интересную информацию о состоянии
        свойств файлов и каталогов можно получить с помощью команд
        <span class="command"><strong>svn status</strong></span> и <span class="command"><strong>svn
        diff</strong></span>.</p><pre class="screen">$ svn status calc/button.c
 M     calc/button.c
$ svn diff calc/button.c
Property changes on: calc/button.c
___________________________________________________________________
Name: copyright
   + (c) 2006 Red-Bean Software

$
</pre><p>Обратите внимание на то, что подкоманда <span class="command"><strong>status</strong></span>
        показала <code class="literal">M</code> не в первой, а во второй колонке.
        Это произошло потому, что в <code class="filename">calc/button.c</code> 
        изменились свойства, а не текстовое содержимое. Если бы мы изменили 
        и то и другое, в первой колонке также стояла бы буква 
        <code class="literal">M</code> (см. 
        <a class="xref" href="#svn.tour.cycle.examine.status" title="svn status">«<span class="command"><strong>svn status</strong></span>»</a>).</p><div class="sidebar" title="Конфликты свойств"><div class="titlepage"><div><div><p class="title"><strong>Конфликты свойств</strong></p></div></div></div><p>Как и в случае с содержимым файлов, локальные
          модификации свойств могут конфликтовать с изменениями,
          зафиксированными кем-то другим. При обновлении каталога 
          рабочей копии и получении изменений свойств версионированного
          объекта, которые идут вразрез с вашими собственными, Subversion
          сообщит о конфликтном состоянии объекта.</p><pre class="screen">% svn update calc
M  calc/Makefile.in
 C calc/button.c
Updated to revision 143.
$
</pre><p>В каталоге с конфликтующим объектом Subversion
          создаст файл с расширением <code class="filename">.prej</code>,
          содержащий подробную информацию о конфликте. Для разрешения 
          конфликта необходимо посмотреть содержимое этого файла. Пока
          не будет решен конфликт, во второй колонке вывода
          команды <span class="command"><strong>svn status</strong></span> будет присутствовать
          буква <code class="literal">C</code>, а попытки фиксации локальных
          изменений будут отклоняться.</p><pre class="screen">$ svn status calc
 C     calc/button.c
?      calc/button.c.prej
$ cat calc/button.c.prej
prop 'linecount': user set to '1256', but update set to '1301'.
$
</pre><p>Для разрешения конфликтов свойств просто убедитесь,
          что свойства имеют нужные значения, после чего с помощью команды
          <span class="command"><strong>svn resolved</strong></span> уведомите Subversion о том, что
          вы решили проблему вручную.</p></div><p>Кроме того, нужно помнить о нестандартном подходе, используемом
        Subversion при выводе различий для свойств. Безусловно, можно
        запустить <span class="command"><strong>svn diff</strong></span> и перенаправить вывод для создания
        работоспособного патч-файла. Но программа <span class="command"><strong>patch</strong></span>
        будет просто игнорировать различия свойств — как правило,
        она игнорирует любой мусор, который не может обработать. К сожалению,
        это означает, что для полного применения патча, сгенерированного
        <span class="command"><strong>svn diff</strong></span>, изменения свойств придется вносить 
        вручную.</p></div><div class="sect2" title="Автоматическая установка свойств"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.props.auto"></a>Автоматическая установка свойств</h3></div></div></div><p>Поддержка свойств — мощная функциональная особенность
        Subversion. Свойства служат базовым механизмом для реализации многих 
        других функций Subversion, обсуждаемых в книге — 
        поддержки текстового поиска различий и слияния, 
        подстановки ключевых слов, трансляции символов перевода
        строки и т. д. Однако, чтобы получить реальную выгоду от свойств,
        их нужно задавать для соответствующих файлов и каталогов. К сожалению,
        среди повседневных забот об этом очень легко забыть, особенно 
        учитывая то, что неустановка значения свойства обычно не приводит
        к явно заметным ошибкам (по сравнению, скажем, с 
        недобавлением файла под версионный контроль). Чтобы помочь в
        установке свойств для нужных элементов, Subversion 
        обеспечивает пару простых, но полезных функций.</p><p>При каждом добавлении файла под версионный контроль с помощью
        команд <span class="command"><strong>svn add</strong></span> или <span class="command"><strong>svn import</strong></span>
        Subversion пытается автоматически установить несколько базовых 
        свойств файлов. Во-первых, в операционных системах, файловые
        системы которых поддерживают бит разрешения выполнения, Subversion
        автоматически задает свойство <code class="literal">svn:executable</code> 
        для вновь добавленных или импортированных файлов, у которых
        этот бит установлен. (Обратитесь к <a class="xref" href="#svn.advanced.props.special.executable" title="Исполнимость файла">«Исполнимость файла»</a> за 
        дополнительной информации об этом свойстве.)  Во-вторых, 
        Subversion выполняет очень простую эвристическую процедуру, 
        чтобы определить, имеет ли файл читаемое содержимое. Если это 
        не так, Subversion автоматически устанавливает 
        свойство <code class="literal">svn:mime-type</code> этого файла в значение 
        <code class="literal">application/octet-stream</code> (это базовый 
        MIME-тип, обозначающий <span class="quote">«<span class="quote">набор байтов</span>»</span>).  Конечно,
        если Subversion угадает тип файла неправильно, или если вы 
        пожелаете присвоить свойству <code class="literal">svn:mime-type</code> 
        более точное значение — например, <code class="literal">image/png</code>
        или <code class="literal">application/x-shockwave-flash</code> — 
        вы всегда можете удалить или отредактировать это свойство. 
        (За дополнительной информацией об использовании MIME-типов 
        в Subversion обратитесь к 
        <a class="xref" href="#svn.advanced.props.special.mime-type" title="Тип содержимого файла">«Тип содержимого файла»</a>.)</p><p>Через собственную систему конфигурирования среды исполнения 
        (см. <a class="xref" href="#svn.advanced.confarea" title="Параметры времени выполнения">«Параметры времени выполнения»</a>) Subversion
        также поддерживает более гибкую возможность автоматической 
        установки свойств, которая позволяет задавать соответствия
        между масками имен файлов и именами и значениями свойств.
        Еще раз: эти соответствия воздействуют на добавление и импорт,
        и могут не только переопределять решение о MIME-типе по 
        умолчанию, принимаемое Subversion в ходе этих операций,
        но и устанавливать другие стандартные или пользовательские
        свойства. Например, вы могли бы задать соответствие, чтобы 
        при каждом добавлении JPEG-файла — то есть
        элемента, соответствующего маске <code class="literal">*.jpg</code> —
        Subversion автоматически присваивал бы свойству
        <code class="literal">svn:mime-type</code> значение 
        <code class="literal">image/jpeg</code>. Или, к примеру, для всех файлов,
        соответствующих маске <code class="literal">*.cpp</code>, свойство 
        <code class="literal">svn:eol-style</code> устанавливалось бы в 
        <code class="literal">native</code>, а <code class="literal">svn:keywords</code>
        — в <code class="literal">Id</code>.  Поддержка автоматических свойств
        — это, пожалуй, наиболее удобный инструмент Subversion
        в части работы со свойствами среди всего набора доступных средств. 
        См. <a class="xref" href="#svn.advanced.confarea.opts.config" title="Config">«Config»</a> для
        дополнительной информации о настройке такой поддержки.</p></div></div><div class="sect1" title="Переносимость файлов"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.props.file-portability"></a>Переносимость файлов</h2></div></div></div><p>К радости пользователей Subversion, регулярно работающих
      с различными компьютерами и операционными системами,
      утилита командной строки Subversion везде работает практически 
      одинаково. Если вы знаете, как обращаться с <span class="command"><strong>svn</strong></span> 
      на одной платформе, вы справитесь с ней и на любой другой 
      платформе.</p><p>Однако, это не всегда справедливо для других классов  
      программного обеспечения, а также для конкретных файлов, хранящихся
      в Subversion. Например, на компьютере под управлением
      Windows <span class="quote">«<span class="quote">текстовые файлы</span>»</span> выглядят почти так же
      как и в Linux, но при этом есть одно существенное отличие — 
      последовательность символов, используемая для маркировки
      конца строки в таких файлах.  Имеются и другие различия. 
      Unix-платформы имеют символьные ссылки (и Subversion их 
      поддерживает), а Windows — не имеет. На Unix-платформах
      исполнимость файла определяется с помощью прав доступа на уровне
      файловой системы; Windows использует для этого
      расширения имен файлов.</p><p>Subversion не ставит цели подчинить весь мир 
      некоторым общим определениям и реализовать все на свете.
      Поэтому максимум, что она может сделать — попытаться 
      упростить жизнь при работе с версионированными файлами и каталогами 
      на различных компьютерах и операционных системах.
      Далее мы опишем, каким образом Subversion
      достигает этой цели.</p><div class="sect2" title="Тип содержимого файла"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.props.special.mime-type"></a>Тип содержимого файла</h3></div></div></div><p>Subversion принадлежит к многочисленному семейству
        приложений, распознающих и использующих для типизации содержимого
        многоцелевые расширения интернет-почты (Multipurpose Internet 
        Mail Extensions — MIME). Свойство
        <code class="literal">svn:mime-type</code> не только является универсальным
        местом хранения информации о типе содержимого файла,
        но и определяет некоторые особенности поведения Subversion.</p><div class="sidebar" title="Определение типа файла"><div class="titlepage"><div><div><p class="title"><strong>Определение типа файла</strong></p></div></div></div><p>Программы, работающие в современных операционных
          системах, делают предположение о типе и формате содержимого файла,
          исходя из имени файла, в частности, его расширения.
          Например, файлы, имена которых заканчиваются на 
          <code class="filename">.txt</code>, обычно рассматриваются как читаемые
          текстовые файлы; для понимания их достаточно внимательно
          прочитать, отсутствует необходимость в сложных процедурах
          расшифровывания. Файлы, имена которых заканчиваются на 
          <code class="filename">.png</code>, напротив, рассматриваются как файлы
          переносимой сетевой графики (Portable Network Graphics); они
          совершенно не читаемы человеком и воспринимаются только в 
          случае их интерпретации программой, понимающей формат PNG и 
          способной на основе информации в этом формате сформировать 
          растровое изображение.</p><p>К сожалению, смысл некоторых расширений изменился с 
          течением времени. Когда только появились первые персональные
          компьютеры, файл с именем <code class="filename">README.DOC</code> 
          совершенно однозначно означал неформатированный текстовый
          файл, подобно файлам <code class="filename">.txt</code> в наши дни.
          Однако, с середины 1990-х пользователи стали уверенными
          в том, что файл с таким именем является вовсе не текстом 
          без форматирования, а документом Microsoft Word с закрытым,
          нечитаемым форматом. Но ведь это изменение не свершилось
          за одну ночь — для компьютерных пользователей существовал
          достаточно долгий период путаницы, когда при встрече с 
          файлом <code class="filename">.DOC</code> было непонятно, с чем же мы,
          собственно, имеем дело.
          <sup>[<a id="idp9504656" href="#ftn.idp9504656" class="footnote">15</a>]</sup>
        </p><p>Популярность компьютерных сетей привела к еще большим
          трудностям в установлении соответствия между именами файлов 
          и их содержимым. Когда информация стала проходить по сети и 
          генерироваться динамически серверными скриптами, о физическом
          файле <span class="foreignphrase"><em class="foreignphrase">как таковом</em></span> часто 
          стало говорить просто невозможно, и, соответственно, не стало
          никакого имени файла. К примеру, Web-серверы нуждались в 
          некотором способе сообщить браузеру, что же он загружает, чтобы
          браузер мог правильно поступить с этой информацией (например,
          отобразить данные, используя программу, зарегистрированную
          в качестве обработчика файлов данного типа, либо спросить 
          у пользователя, где на клиентской машине сохранить загружаемые
          данные).</p><p>В конечном счете появился стандарт, среди прочего
          описывающий виды содержимого потоков данных. В 1996 году
          был опубликован RFC2045, первый из пяти RFC-документов,
          описывающих MIME. В нем описана концепция медиатипов и подтипов,
          и рекомендован синтаксис для представления этих типов.
          В настоящее время медиатипы MIME — или просто MIME-типы
          — используются практически во всех
          приложениях электронной почты, на Web-серверах и в других
          программах как механизм, <span class="foreignphrase"><em class="foreignphrase">де-факто</em></span>
          исключающий трудности при определении
          характера содержимого файлов.</p></div><p>Например, одной из полезных возможностей Subversion
        является контекстное, построчное слияние изменений,
        полученных от сервера во время обновления, с рабочей 
        копией. Однако, для файлов, не содержащих текстовых данных, как 
        правило, не существует понятия <span class="quote">«<span class="quote">строки</span>»</span>.
        Поэтому для версионированных файлов, чье свойство 
        <code class="literal">svn:mime-type</code> указывает на нетекстовый
        MIME-тип (как правило, это все, что не начинается с 
        <code class="literal">text/</code>, хотя есть несколько исключений), 
        Subversion не будет пытаться провести контекстное слияние 
        во время обновления. Вместо этого, каждый раз когда вы локально
        модифицируете рабочую копию бинарного файла, и выполняете после
        этого обновление, файл будет переименован с добавлением 
        расширения <code class="filename">.orig</code>, после чего Subversion
        запишет под оригинальным именем новый файл рабочей копии, 
        c изменениями, полученными в процессе обновления, но без
        ваших локальных исправлений. Такое поведение призвано
        защитить пользователя от неудачных попыток выполнить
        контекстное слияние для файлов, к которым его нельзя 
        применить.</p><p>Кроме того, если для файла определено свойство 
        <code class="literal">svn:mime-type</code>, Apache-модуль Subversion 
        будет использовать его значение при формировании HTTP-заголовка 
        <code class="literal">Content-type:</code> в ответ на GET-запросы.
        Благодаря этому ваш браузер (в том случае, если он будет 
        использоваться для просмотра содержимого Subversion-хранилища)
        будет знать, как правильно отобразить этот файл.</p></div><div class="sect2" title="Исполнимость файла"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.props.special.executable"></a>Исполнимость файла</h3></div></div></div><p>На многих операционных системах возможность выполнения файла
        как команды определяется битом разрешения выполнения. Обычно по
        умолчанию этот бит не задан; он должен быть явно установлен 
        пользователем для тех файлов, которым это необходимо.
        Однако, было бы слишком сложным запоминать, какие именно файлы 
        в только что созданной рабочей копии должны иметь установленный 
        бит выполнения, и устанавливать этот бит. Поэтому Subversion 
        поддерживает свойство <code class="literal">svn:executable</code>,
        позволяющее указать, для каких файлов должен быть установлен 
        бит исполнения. При создании рабочей копии Subversion самостоятельно 
        установит этот бит для таких файлов.</p><p>Это свойство не оказывает никакого эффекта на файловых
        системах, не использующих бита разрешения выполнения, таких
        как FAT32 и NTFS.
          <sup>[<a id="idp9533120" href="#ftn.idp9533120" class="footnote">16</a>]</sup>. 
        Кроме того, хотя значение этого свойства не задано, 
        Subversion принудительно устанавливает ему значение
        <code class="literal">*</code>. Наконец, это свойство действительно 
        только для файлов, но не для каталогов.</p></div><div class="sect2" title="Символы конца строки"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.props.special.eol-style"></a>Символы конца строки</h3></div></div></div><p>Subversion считает, что файл содержит читаемые данные,
        если на обратное не указывает версионированное свойство файла
        <code class="literal">svn:mime-type</code>.  В общем-то, Subversion 
        необходимо знать об этом только для того, чтобы определить
        возможность построения контекстного отчета о различиях. 
        В противном случае Subversion будет воспринимать 
        файл лишь как набор байтов.</p><p>Сказанное означает, что по умолчанию Subversion не уделяет
        никакого внимания используемой в файлах разновидности 
        <em class="firstterm">маркера конца строки (EOL)</em>.  К сожалению,
        различные операционные системы используют различные соглашения 
        о том, какая последовательность символов означает конец 
        текстовой строки в файле. Например, программы под
        Windows обычно используют в качестве признака конца 
        строки последовательность из двух управляющих символов ASCII 
        — возврата каретки (<code class="literal">CR</code>) и перевода строки
        (<code class="literal">LF</code>).  В то же время программы под Unix 
        для обозначения конца строки используют единственный
        символ <code class="literal">LF</code>.</p><p>Далеко не все програмы способны понимать файлы, в которых
        признак конца строки отличается по формату от
        <em class="firstterm">принятого стиля завершения строк</em> 
        в данной операционной системе. 
        Обычным делом является ситуация,
        когда программы под Unix рассматривают символ 
        <code class="literal">CR</code>, присутствующий в файлах Windows, 
        как обычный символ (часто представляя его как 
        <code class="literal">^M</code>), или когда программы под Windows 
        слепляют все строки файла Unix в одну гигантскую строку, 
        поскольку в нем отсутствуют комбинации символов возврата 
        каретки и перевода строки (или <code class="literal">CRLF</code>),
        обозначающие концы строк.</p><p>Такая чувствительность к чужеродным EOL-маркерам может
        стать серьезной проблемой для людей, совместно использующих
        одни и те же файлы в различных операционных системах.
        Возьмем для примера файл с исходным кодом программы и 
        разработчиков, редактирующих этот файл как под Windows, так 
        и под Unix. Если все разработчики будут всегда использовать
        инструменты, сохраняющие в файле прежний стиль завершения 
        строк, проблем не возникнет.</p><p>Но на практике многие распространенные утилиты либо 
        не умеют правильно считывать файлы с чужеродными EOL-маркерами,
        либо конвертируют концы строк в файле к родному стилю при
        сохранении файла. Если разработчик сталкивается с первым случаем, 
        он оказывается вынужденным пользоваться 
        внешними утилитами конвертации (такими как 
        <span class="command"><strong>dos2unix</strong></span> или ее аналоги,
        <span class="command"><strong>unix2dos</strong></span>), чтобы подготовить файл к 
        редактированию. Во втором случае дополнительная подготовка
        файлов не требуется. Однако, в обоих случаях получается 
        файл, каждая строка в котором отличается от исходной!
        Прежде чем фиксировать свои изменения, пользователь может сделать
        одно из двух. Он может либо использовать утилиту конвертации,
        чтобы восстановить в модифицированном файле прежний стиль 
        завершения строк; либо просто зафиксировать файл 
        с новыми EOL-маркерами.</p><p>Результатом такого сценария станут напрасная
        трата времени и нежелательные изменения в фиксируемых
        файлах. Напрасная трата времени сама по себе обходится довольно 
        дорого. А когда фиксация вносит изменения в каждую строку 
        файла, становится невозможным определить, какие строки
        файла действительно изменились по существу. Был ли 
        устранен тот самый баг? В какой строке имелась синтаксическая 
        ошибка?</p><p>Данную проблему решает свойство 
        <code class="literal">svn:eol-style</code>. Когда этому свойству 
        задано одно из допустимых значений, Subversion 
        использует его для того, чтобы определить вариант 
        специальной обработки файла, производимой для того,
        чтобы стиль завершения строки не изменялся туда-сюда
        при каждой фиксации, выполняемой из другой операционной
        системы. Допустимы следующие значения:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">native</code></span></dt><dd><p>Файл будет содержать EOL-маркеры, принятые в 
              той операционной системе, на которой работает
              Subversion. Иными словами, если пользователь
              на машине с Windows создает рабочую копию файла,
              у которого свойство <code class="literal">svn:eol-style</code> 
              установлено в <code class="literal">native</code>, этот 
              файл будет содержать EOL-маркеры 
              <code class="literal">CRLF</code>.  Пользователь Unix, создавая
              рабочую копию того же самого файла,
              увидит в нем EOL-маркер <code class="literal">LF</code>.</p><p>Учтите, что на самом деле Subvversion 
              будет записывать файл в хранилище, используя нормализованный
              EOL-маркер <code class="literal">LF</code>, вне зависимости от 
              операционной системы. Хотя обычно это прозрачно 
              для пользователя.</p></dd><dt><span class="term"><code class="literal">CRLF</code></span></dt><dd><p>Файл будет содержать в качестве EOL-маркеров
              последовательность <code class="literal">CRLF</code>,
              независимо от используемой операционной системы.</p></dd><dt><span class="term"><code class="literal">LF</code></span></dt><dd><p>Файл будет содержать в качестве EOL-маркера
              символ <code class="literal">LF</code>, независимо от 
              используемой операционной системы.</p></dd><dt><span class="term"><code class="literal">CR</code></span></dt><dd><p>Файл будет содержать в качестве EOL-маркера
              символ <code class="literal">CR</code>, независимо от используемой
              операционной системы. Данный стиль завершения строки
              не слишком распространен. Он использовался на
              устаревших платформах Macintosh (на которых Subversion 
              даже никогда не запускался).</p></dd></dl></div></div></div><div class="sect1" title="Пропуск неверсионированных элементов"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.props.special.ignore"></a>Пропуск неверсионированных элементов</h2></div></div></div><p>В любой реальной рабочей копии среди версионированных
      файлов и каталогов почти наверняка обнаружатся и другие файлы и
      каталоги, которые не версионированы и не должны быть 
      таковыми. Текстовые редакторы мусорят, создавая каталоги с 
      резервными копиями файлов. Компиляторы программного кода
      генерируют временные — или даже результирующие —
      файлы, которые обычно нет смысла версионировать. Сами 
      пользователи также бросают различные файлы и каталоги там,
      где им проще — в том числе нередко и в каталогах
      рабочей копии.</p><p>Было бы нелепо ожидать, что рабочие копии Subversion окажутся
      в стороне от такого рода мусора и беспорядка. При этом
      Subversion считает своей важной <span class="emphasis"><em>особенностью</em></span> то, 
      что ее рабочие копии являются самыми обычными каталогами, такими же
      как и неверсионированные структуры каталогов. Однако не подлежащие
      версионированию файлы и каталоги могут вызывать у пользователей
      Subversion некоторое раздражение. Например, поскольку команды 
      <span class="command"><strong>svn add</strong></span> и <span class="command"><strong>svn import</strong></span> 
      по умолчанию действуют рекурсивно и не знают, какие
      из вновь созданных файлов в данном каталоге вы не собираетесь
      версионировать, очень легко случайно добавить под версионный 
      контроль всякий хлам, о котором вы даже не думали. Кроме того, 
      много лишнего может выводить команда <span class="command"><strong>svn status</strong></span>,
      поскольку по умолчанию она выдает отчет по каждому
      элементу в рабочей копии, включая неверсионированные файлы
      и каталоги.</p><p>Исходя из этого, Subversion поддерживает два способа для того,
      чтобы указать, на какие файлы желательно просто не обращать
      внимание. Первый способ затрагивает систему настройки
      среды исполнения Subversion 
      (см. <a class="xref" href="#svn.advanced.confarea" title="Параметры времени выполнения">«Параметры времени выполнения»</a>), и,
      следовательно, применяется ко всем операциям Subversion,
      использующим эти настройки среды исполнения (которые, как правило,
      производятся на конкретном компьютере или конкретным пользователем
      компьютера). Другой способ использует поддерживаемые в Subversion
      свойства каталогов, он более тесно связан с 
      самим версионированным деревом каталогов и, следовательно,
      действует для всех, кто оперирует рабочей копией этого дерева. 
      Оба механизма используют маски файлов.</p><p>Система настройки среды исполнения Subversion 
      имеет параметр <code class="literal">global-ignores</code>, 
      значением которой служит разделенный пробелами набор масок 
      файлов. Эти маски применяются к файлам, являющимся кандидатами
      на добавление под версионный контроль, а также к неверсионированным
      файлам, попадающим в поле зрения команды <span class="command"><strong>svn status</strong></span>.
      Если имя файла соответствуют одной из масок, Subversion будет
      действовать так, как будто файла вовсе не существует.
      Это действительно полезно для масок файлов, которые вы однозначно
      не хотите версионировать — например, файлов резервных копий,
      создаваемых редакторами, таких как файлы <code class="literal">*~</code> 
      и <code class="literal">.*~</code> от Emacs.</p><p>Свойство <code class="literal">svn:ignore</code>, задаваемое для
      версионированного каталога, содержит список масок файлов
      (каждая маска записывается с новой строки), с помощью которого
      Subversion должна определять, какие объекты следует игнорировать
      в этом каталоге. Эти маски не переопределяют те, что заданы
      параметром среды исполнения <code class="literal">global-ignores</code>,
      а дополняют их. Стоит отметить, что в отличие от параметра 
      <code class="literal">global-ignores</code>, маски, перечисленные в свойстве
      <code class="literal">svn:ignore</code>, применяются только к тому каталогу, 
      в свойстве которого они заданы, не затрагивая любые его подкаталоги.
      Свойство <code class="literal">svn:ignore</code> — это хороший способ
      попросить Subversion пропускать файлы, которые, вероятно,
      присутствуют во всех пользовательских рабочих копиях —
      например, результаты компиляции или, если взять пример, более 
      подходящий этой книге, файлы HTML, PDF или PostScript,
      генерируемые в результате преобразования исходных файлов
      формата DocBook XML в более удобный для чтения выходной формат.</p><div class="warning" title="Предупреждение" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Предупреждение]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/warning.png"></td><th align="left">Предупреждение</th></tr><tr><td valign="top" align="left"><p>Реализованная в Subverion поддержка масок пропуска файлов
        действует только в момент добавления 
        неверсионированного файла или каталога под версионный контроль. 
        Если объект уже находится под управлением Subversion, 
        механизм масок пропуска больше к нему не применяется.
        Иными словами, не следует ожидать, что Subversion не будет
        фиксировать изменения, сделанные в версионированном файле,
        только на том основании, что его имя соответствует
        маске пропуска — Subversion <span class="emphasis"><em>всегда</em></span> 
        просматривает все версионированные объекты.</p></td></tr></tbody></table></div><div class="sidebar" title="Маски пропуска для пользователей CVS"><div class="titlepage"><div><div><p class="title"><strong>Маски пропуска для пользователей CVS</strong></p></div></div></div><p>Свойство <code class="literal">svn:ignore</code> в Subversion по 
        синтаксису и назначению очень похоже на файл 
        <code class="filename">.cvsignore</code> в CVS.  По сути, если
        вы переносите свою рабочую копию в Subversion, вы можете 
        перенести маски пропуска напрямую, используя файл 
        <code class="filename">.cvsignore</code> в качестве входного для команды
        <span class="command"><strong>svn propset</strong></span>:</p><pre class="screen">$ svn propset svn:ignore -F .cvsignore .
property 'svn:ignore' set on '.'
$
</pre><p>Тем не менее, в работе CVS и Subversion с масками пропуска имеются
        некоторые отличия. Системы используют маски пропуска в несколько 
        различные моменты времени, и есть небольшое различие
        в том, как эти маски применяются. Также Subversion не понимает
        использование маски <code class="literal">!</code> как способа
        полного отказа от масок пропуска.</p></div><p>Глобальный список масок пропуска в большей степени подходит
      для задания личных предпочтений, и завязан больше на
      конкретный набор пользовательских инструментов, чем на 
      специфику конкретной рабочей копии. Исходя из этого,
      остаток данной главы будет посвящен использованию свойства
      <code class="literal">svn:ignore</code>.</p><p>Допустим, что команда <span class="command"><strong>svn status</strong></span> выдает 
      нам следующее:</p><pre class="screen">$ svn status calc
 M     calc/button.c
?      calc/calculator
?      calc/data.c
?      calc/debug_log
?      calc/debug_log.1
?      calc/debug_log.2.gz
?      calc/debug_log.3.gz
</pre><p>В примере видно, что вы изменили некоторые свойства файла 
      <code class="filename">button.c</code>, и, кроме того, в рабочей копии
      есть несколько неверсионированных файлов: программа 
      <code class="filename">calculator</code>, скомпилированная из
      исходных кодов, файл исходного кода <code class="filename">data.c</code>
      и набор файлов с отладочными сообщениями. Вам известно, что 
      ваша система сборки всегда генерирует программу с именем
      <code class="filename">calculator</code>.
      <sup>[<a id="idp9642304" href="#ftn.idp9642304" class="footnote">17</a>]</sup>
      Также вам известно, что после тестового прогона всегда остаются
      те самые файлы с отладочными сообщениями. Это справедливо
      не только для вашей, но и для всех остальных рабочих копий 
      данного проекта.
      Вы точно знаете, что вам не хотелось бы видеть эти отладочные
      файлы при каждом запуске команды <span class="command"><strong>svn status</strong></span>, 
      и вы абсолютно уверены, что так же их не хотелось бы видеть и 
      остальным. Исходя из этого, можно добавить необходимые маски 
      пропуска для каталога <code class="filename">calc</code>, выполнив
      команду <span class="command"><strong>svn propedit svn:ignore calc</strong></span>.
      Например, вы могли бы добавить в значение свойства 
      <code class="literal">svn:ignore</code> такие строки:</p><pre class="programlisting">calculator
debug_log*
</pre><p>Результатом добавления этого свойства станет локальное 
      изменение свойств в каталоге <code class="filename">calc</code>.  
      Обратите внимание, чем еще отличается теперь вывод 
      команды <span class="command"><strong>svn status</strong></span>:</p><pre class="screen">$ svn status
 M     calc
 M     calc/button.c
?      calc/data.c
</pre><p>Заметьте, весь "мусор" исчез из вывода!  Конечно, скомпилированная
      программа <code class="filename">calculator</code> и упоминавшиеся файлы 
      отладочных сообщений никуда не делись из вашей рабочей копии.
      Просто Subversion больше не напоминает вам об их существовании. Теперь, 
      когда весь не представляющий интереса "мусор" исчез с экрана, вам 
      остается разобраться с более интересными элементами — в частности,
      с исходным файлом <code class="filename">data.c</code>, который вы, вероятно,
      забыли добавить под версионный контроль.</p><p>Конечно же, вам доступен не только этот короткий отчет 
      о статусе вашей рабочей копии. Если в какой-то момент времени вам
      действительно захочется увидеть в составе статусного отчета 
      проигнорированные файлы, вы можете воспользоваться опцией
      <code class="option">--no-ignore</code>:</p><pre class="screen">$ svn status --no-ignore
 M     calc
 M     calc/button.c
I      calc/calculator
?      calc/data.c
I      calc/debug_log
I      calc/debug_log.1
I      calc/debug_log.2.gz
I      calc/debug_log.3.gz
</pre><p>Как отмечалось выше, список файловых масок для пропуска 
      также учитывается командами <span class="command"><strong>svn add</strong></span> и <span class="command"><strong>svn
      import</strong></span>.  В результате обеих операций Subversion
      берет под управление некоторое множество файлов и каталогов.
      Прежде чем требовать у пользователя, чтобы он выбирал те файлы 
      в структуре каталогов, которые необходимо версионировать,
      Subversion применяет маски пропуска — как глобальные,
      так и назначенные отдельным каталогам — чтобы определить,
      какие файлы не должны подхватываться системой управления версиями
      в ходе рекурсивной операции добавления или импорта. И снова вы можете
      воспользоваться опцией <code class="option">--no-ignore</code>, чтобы предложить
      Subversion не учитывать списки пропуска и обрабатывать все имеющиеся
      файлы и каталоги.</p></div><div class="sect1" title="Подстановка ключевых слов"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.props.special.keywords"></a>Подстановка ключевых слов</h2></div></div></div><p>Subversion умеет выполнять подстановку 
      <em class="firstterm">ключевых слов</em> — элементов полезной 
      динамической информации о версионированном файле —
      в составе этого файла. Чаще всего ключевые слова 
      замещают информацию о времени последнего изменения файла.
      Поскольку эта информация меняется при каждом изменении файла,
      и, что особенно важно, сразу <span class="emphasis"><em>после</em></span> 
      того, как файл будет изменен, никакой другой процесс, кроме
      системы управления версиями, не в состоянии 
      поддерживать полную актуальность этих данных. Будучи
      отданной на откуп человеку, эта информация неизбежно 
      будет оказываться устаревшей.</p><p>Предположим, у вас есть файл, в тексте которого
      вы хотели бы всегда видеть дату его последнего изменения.
      Вы могли бы вменить в обязанность каждому автору
      этого документа, чтобы непосредственно перед фиксацией своих
      изменений он также исправлял в нем запись о времени
      последнего внесения изменений. Но рано или поздно 
      кто-нибудь забудет сделать это! Чтобы такого не случалось, 
      мы можем попросить Subversion производить
      подстановку на место ключевого слова <code class="literal">LastChangedDate</code>.  
      Позиция, куда должна производиться подстановка, определяется 
      местоположением <em class="firstterm">указателя ключевого слова</em> 
      в содержании файла.  Этот указатель представляет собой
      обычную текстовую строку, имеющую формат
      <code class="literal">$</code><em class="replaceable"><code>KeywordName</code></em>
      <code class="literal">$</code>.</p><p>Все ключевые слова чувствительны к регистру, когда идет речь
      об указателях на них в файлах: вы должны использовать правильный
      регистр символов в написании ключевого слова. Значение свойства
      <code class="literal">svn:keywords</code> также следует рассматривать как
      чувствительное к регистру — и хотя некоторые имена ключевых 
      слов распознаются независимо от регистра, рассчитывать на это 
      не стоит.</p><p>В Subversion определен список ключевых слов, доступных для 
      подстановки.  Он содержит следующие пять ключевых слов; 
      некоторые из них имеют псевдонимы, которые
      вы также можете использовать:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">Date</code></span></dt><dd><p>Это ключевое слово замещает время последнего
            изменения файла в хранилище и выглядит примерно так:
            <code class="literal">$Date: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006)
            $</code>.  Также его можно задать как 
            <code class="literal">LastChangedDate</code>.</p></dd><dt><span class="term"><code class="literal">Revision</code></span></dt><dd><p>Это ключевое слово замещает номер последней правки,
            в которой файл был изменен в хранилище, и выглядит
            примерно так: <code class="literal">$Revision: 144 $</code>.  
            Также его можно задать как 
            <code class="literal">LastChangedRevision</code> или
            <code class="literal">Rev</code>.</p></dd><dt><span class="term"><code class="literal">Author</code></span></dt><dd><p>Это ключевое слово замещает имя пользователя,
            который последним изменил этот файл в хранилище,
            и выглядит примерно так: <code class="literal">$Author: harry $</code>.  
            Также его можно задать как 
            <code class="literal">LastChangedBy</code>.</p></dd><dt><span class="term"><code class="literal">HeadURL</code></span></dt><dd><p>Это ключевое слово замещает полный URL
            к последней версии файла в хранилище, и 
            выглядит примерно так: <code class="literal">$HeadURL:
            http://svn.collab.net/repos/trunk/README $</code>.
            Оно может быть сокращено до
            <code class="literal">URL</code>.</p></dd><dt><span class="term"><code class="literal">Id</code></span></dt><dd><p>Это ключевое слово — компактная комбинация
            всех остальных. Его подстановка выглядит примерно так:
            <code class="literal">$Id: calc.c 148 2006-07-28 21:30:43Z sally
            $</code>, и означает, что файл 
            <code class="filename">calc.c</code> последний раз был изменен в правке
            148, зафиксированной вечером 28 июля 2006 года пользователем 
            <code class="literal">sally</code>.</p></dd></dl></div><p>Если просто разместить в тексте файла указатель ключевого слова,
      ничего не произойдет. Subversion никогда не пытается осуществить
      текстовую подстановку в содержании файла, пока вы явно его об 
      этом не попросите.  В конце концов, вы ведь могли бы написать
      документ 
      <sup>[<a id="idp9708096" href="#ftn.idp9708096" class="footnote">18</a>]</sup> 
      о том, как пользоваться ключевыми словами, и вы, очевидно, не захотите,
      чтобы Subversion заместил указатели на ключевые слова, приведенные 
      вами в качестве примера!</p><p>Чтобы указать Subversion, следует ли ему выполнять подстановку
      ключевых слов в конкретном файле, снова обратимся к подкомандам
      для работы со свойствами.  Свойство <code class="literal">svn:keywords</code>,
      устанавливаемое для версионированного файла, задает перечень ключевых
      слов, которые будут замещаться в этом файле. Его значение представляет
      собой список имен ключевых слов или псевдонимов из приведенной
      выше таблицы, разделенных пробелами.</p><p>В качестве примера допустим, что у вас есть версионированный
      файл с именем <code class="filename">weather.txt</code>, который выглядит
      следующим образом::</p><pre class="programlisting">Here is the latest report from the front lines.
$LastChangedDate$
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</pre><p>Если для этого файла не задать свойство 
      <code class="literal">svn:keywords</code>, Subversion не будет делать 
      ничего особенного. Давайте разрешим теперь подстановку ключевого 
      слова <code class="literal">LastChangedDate</code>.</p><pre class="screen">$ svn propset svn:keywords "Date Author" weather.txt
property 'svn:keywords' set on 'weather.txt'
$
</pre><p>Итак, вы произвели локальное изменение свойства файла 
      <code class="filename">weather.txt</code>.  Вы не увидите никаких
      изменений в содержании файла (если вы, конечно, не вносили
      своих изменений до того, как задать свойство).  Заметьте, что
      файл содержал также указатель на ключевое слово <code class="literal">Rev</code>,
      которое мы не стали включать в значение свойства. 
      Subversion без проблем проигнорирует подстановку тех 
      ключевых слов, которые не присутствуют в файле, а также не 
      будет замещать ключевые слова, не перечисленные в
      значении свойства <code class="literal">svn:keywords</code>.</p><p>Сразу же после того, как вы зафиксируете изменение свойства,
      Subversion обновит файл рабочей копии с новым текстом подстановки.
      Вместо указателя ключевого слова <code class="literal">$LastChangedDate$</code>
      вы увидите результат подстановки.  Этот результат так же
      будет содержать имя ключевого слова, и по-прежнему будет
      ограничен знаками доллара (<code class="literal">$</code>).  
      Как мы и предсказывали, подстановки ключевого слова 
      <code class="literal">Rev</code> не произошло, поскольку мы не просили 
      об этом Subversion.</p><p>Заметим также, что мы установили свойству 
      <code class="literal">svn:keywords</code> значение <span class="quote">«<span class="quote">Date Author</span>»</span>,
      в то время как указатель ключевого слова использовал псевдоним 
      <code class="literal">$LastChangedDate$</code>. Тем не менее, его замещение 
      прошло корректно.</p><pre class="screen">Here is the latest report from the front lines.
$LastChangedDate: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006) $
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</pre><p>Теперь, если кто-то другой зафиксирует изменения в 
      <code class="filename">weather.txt</code>, ваша копия этого файла
      продолжит показывать прежний результат подстановки —
      до тех пор, пока вы не обновите рабочую копию.
      При обновлении в вашем файле <code class="filename">weather.txt</code>
      будет произведена переподстановка ключевого слова 
      той информацией, которая отражает наиболее свежую
      фиксацию этого файла.</p><div class="sidebar" title="Где взять $GlobalRev$?"><div class="titlepage"><div><div><p class="title"><strong>Где взять $GlobalRev$?</strong></p></div></div></div><p>Новые пользователи часто не понимают, как работает ключевое
        слово <code class="literal">$Rev$</code>. Поскольку хранилище имеет единый,
        глобально возрастающий номер правки, многие предполагают,
        что именно этот номер отражается значением ключевого слова 
        <code class="literal">$Rev$</code>. На самом же деле 
        <code class="literal">$Rev$</code> показывает последнюю правку,
        в которой файл <span class="emphasis"><em>был изменен</em></span>, а не 
        правку, из которой обновлена рабочая копия. Осознание этого
        устраняет путаницу, но часто остается недоумение
        — как еще, если не через ключевые слова Subversion,
        автоматически получить в файлах глобальный номер 
        правки?</p><p>Чтобы добиться этого, потребуется внешняя обработка. 
        Subversion поставляется вместе с утилитой 
        <span class="command"><strong>svnversion</strong></span>, которая специально создана
        для этой цели. <span class="command"><strong>svnversion</strong></span> просматривает
        вашу рабочую копию и выдает номера найденных правок. 
        Вы можете пользоваться этой программой вместе с 
        дополнительными утилитами, чтобы записать эту информацию
        о правках в ваши файлы. За дополнительной информацией по
        <span class="command"><strong>svnversion</strong></span>, обращайтесь в раздел <a class="xref" href="#svn.ref.svnversion" title="svnversion">«<span class="command"><strong>svnversion</strong></span>»</a>.</p></div><p>Subversion 1.2 предлагает новый вариант синтаксиса для
      работы с ключевыми словами, который предоставляет дополнительные, 
      весьма полезные — хотя, вероятно, не совсем типичные
      — функциональные возможности.  Теперь вы можете
      попросить Subversion сохранять фиксированную длину для результата
      подстановки ключевого слова (имеется в виду число занимаемых
      байтов). Для этого используйте удвоенное двоеточие 
      (<code class="literal">::</code>) после имени ключевого слова, вслед за 
      которым поместите столько пробелов, сколько нужно для 
      задания фиксированной длины. Когда Subversion на место ключевого
      слова будет подставлять ключевое слово и его значение, 
      она заменит только эти пробельные символы, оставив неизменной 
      полную длину поля с ключевым словом. Если подставляемое
      значение окажется короче, чем заданная ширина поля, оно
      будет дополнено на конце символами-заполнителями
      (пробелами). Если подставляемое значение окажется слишком
      длинным, оно будет усечено, при этом непосредственно перед
      закрывающим знаком доллара (ограничителем) будет помещен
      специальный хэш-символ (<code class="literal">#</code>).</p><p>Допустим, к примеру, что в вашем документе имеется
      раздел табулированных данных, отражающих значение ключевых
      слов Subversion для этого документа.  При использовании 
      исходного синтаксиса подстановки ключевых слов Subversion
      ваш файл мог бы выглядеть примерно так:</p><pre class="screen">$Rev$:     Revision of last commit
$Author$:  Author of last commit
$Date$:    Date of last commit
</pre><p>Поначалу он выглядит красиво и похож на таблицу.
      Но когда вы выполните фиксацию этого файла (конечно же,
      при разрешенной подстановке ключевых слов), то увидите 
      следующее:</p><pre class="screen">$Rev: 12 $:     Revision of last commit
$Author: harry $:  Author of last commit
$Date: 2006-03-15 02:33:03 -0500 (Wed, 15 Mar 2006) $:    Date of last commit
</pre><p>Результат уже не столь красив. Возможно, вам даже захочется
      выровнять содержимое файла после подстановки, чтобы он снова
      выглядел как таблица. Но выравнивание будет держаться
      только до тех пор, пока значение ключевого слова будет 
      иметь неизменную длину. Если в номере последней зафиксированной
      правки добавится новый разряд  (скажем, при переходе от 99 к 100),
      или фиксацию выполнит другой человек с более длинным именем
      пользователя, ваши труды снова пойдут насмарку. 
      Однако, если вы используете Subversion версии 1.2 или выше, 
      вы можете пользоваться новым синтаксисом ключевых слов с 
      фиксированной длиной, задавая полям такую длину, чтобы 
      получить аккуратный внешний вид. Теперь ваш файл мог бы
      выглядеть примерно так:</p><pre class="screen">$Rev::               $:  Revision of last commit
$Author::            $:  Author of last commit
$Date::              $:  Date of last commit
</pre><p>Зафиксируем эти изменения в вашем файле. Теперь 
      Subversion заметит новый синтаксис ключевых слов с 
      фиксированной длиной и сохранит ширину полей такой,
      какой она была задана с помощью пробелов, помещенных вами
      между удвоенным двоеточием и замыкающим знаком доллара.
      После выполнения подстановки ширина поля совершенно не 
      изменится — короткие значения для 
      <code class="literal">Rev</code> и <code class="literal">Author</code> будут
      дополнены пробелами, а длинное поле <code class="literal">Date</code>
      будет обрезано хэш-символом:</p><pre class="screen">$Rev:: 13            $:  Revision of last commit
$Author:: harry      $:  Author of last commit
$Date:: 2006-03-15 0#$:  Date of last commit
</pre><p>Использование ключевых слов с фиксированной длиной 
      особенно удобно, когда подстановки производятся в сложных
      файловых форматах, которые сами используют поля фиксированной
      длины для своих данных, либо в которых достаточно трудно изменить 
      размер определенного поля данных, не прибегая к использованию
      родного для данного формата приложения (в качестве примера
      можно привести документы Microsoft Office).</p><div class="warning" title="Предупреждение" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Предупреждение]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/warning.png"></td><th align="left">Предупреждение</th></tr><tr><td valign="top" align="left"><p>Помните, что, поскольку ширина поля для 
        ключевого слова измеряется в байтах, существует опасность 
        повреждения многобайтовых символов. Например, имя пользователя,
        содержащее многобайтовые символы UTF-8, может подвергнуться
        усечению посреди строки байтов, отрезав часть байтов одного
        из символов. Результатом может стать не только усечение,
        видимое на байтовом уровне, но и строка с некорректным или
        искаженным последним символом при ее просмотре как текста 
        в формате UTF-8. Вполне возможно, что некоторые приложения 
        при загрузке такого файла обнаружат поврежденный текст UTF-8
        и посчитают поврежденным весь файл, отказавшись из-за этого
        с ним работать.</p></td></tr></tbody></table></div></div><div class="sect1" title="Locking"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.locking"></a>Locking</h2></div></div></div><p>Subversion's copy-modify-merge version control model lives
      and dies on its data merging algorithms, specifically on how
      well those algorithms perform when trying to resolve conflicts
      caused by multiple users modifying the same file concurrently.
      Subversion itself provides only one such algorithm, a three-way
      differencing algorithm which is smart enough to handle data at a
      granularity of a single line of text.  Subversion also allows
      you to supplement its content merge processing with external
      differencing utilities (as described in <a class="xref" href="#svn.advanced.externaldifftools.diff3" title="External diff3">«External diff3»</a>), some of
      which may do an even better job, perhaps providing granularity
      of a word or a single character of text.  But common among those
      algorithms is that they generally work only on text files.  The
      landscape starts to look pretty grim when you start talking
      about content merges of non-textual file formats.  And when you
      can't find a tool that can handle that type of merging, you
      begin to run into problems with the copy-modify-merge
      model.</p><p>Let's look at a real-life example of where this model runs
      aground.  Harry and Sally are both graphic designers working on
      the same project, a bit of marketing collateral for an
      automobile mechanic.  Central to the design of a particular
      poster is an image of a car in need of some body work, stored in
      a file using the PNG image format.  The poster's layout is
      almost finished, and both Harry and Sally are pleased with the
      particular photo they chose for their damaged car—a baby
      blue 1967 Ford Mustang with an unfortunate bit of crumpling on
      the left front fender.</p><p>Now, as is common in graphic design work, there's a change
      in plans which causes the car's color to be a concern.  So Sally
      updates her working copy to <code class="literal">HEAD</code>, fires up
      her photo editing software, and sets about tweaking the image so
      that the car is now cherry red.  Meanwhile, Harry, feeling
      particularly inspired that day, decides that the image would
      have greater impact if the car also appears to have suffered
      greater impact.  He, too, updates to <code class="literal">HEAD</code>,
      and then draws some cracks on the vehicle's windshield.  He
      manages to finish his work before Sally finishes hers, and after
      admiring the fruits of his undeniable talent, commits the
      modified image.  Shortly thereafter, Sally is finished with the
      car's new finish, and tries to commit her changes.  But, as
      expected, Subversion fails the commit, informing Sally that now
      her version of the image is out of date.</p><p>Here's where the difficulty sets in.  Were Harry and Sally
      making changes to a text file, Sally would simply update her
      working copy, receiving Harry's changes in the process.  In the
      worst possible case, they would have modified the same region of
      the file, and Sally would have to work out by hand the proper
      resolution to the conflict.  But these aren't text
      files—they are binary images.  And while it's a simple
      matter to describe what one would expect the results of this
      content merge to be, there is precious little chance that any
      software exists which is smart enough to examine the common
      baseline image that each of these graphic artists worked
      against, the changes that Harry made, and the changes that Sally
      made, and spit out an image of a busted-up red Mustang with a
      cracked windshield!</p><p>Clearly, things would have gone more smoothly if Harry and
      Sally had serialized their modifications to the image.  If, say,
      Harry had waited to draw his windshield cracks on Sally's
      now-red car, or if Sally had tweaked the color of a car whose
      windshield was already cracked.  As is discussed in <a class="xref" href="#svn.basic.vsn-models.copy-merge" title="Модель Копирование-Изменение-Слияние">«Модель Копирование-Изменение-Слияние»</a>, much of these
      types problems go away entirely where perfect communication
      between Harry and Sally exists.
      <sup>[<a id="idp9790816" href="#ftn.idp9790816" class="footnote">19</a>]</sup>
      But as one's version control system is, in fact, one form of
      communication, it follows that having that software facilitate
      the serialization of non-parallelizable energies is no bad
      thing.  And this where Subversion's implementation of the
      lock-modify-unlock model steps into the spotlight.  This is
      where we talk about Subversion's <em class="firstterm">locking</em>
      feature, which is similar to the <span class="quote">«<span class="quote">reserved
      checkouts</span>»</span> mechanisms of other version control
      systems.</p><p>Subversion's locking feature serves two main
      purposes:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>Serializing access to a versioned
          object</em></span>.  By allowing a user to
          programmatically claim the exclusive right to change to a
          file in the repository, that user can be reasonably
          confident that energy invested on unmergeable changes won't
          be wasted—his commit of those changes will succeed.</p></li><li class="listitem"><p><span class="emphasis"><em>Aiding communication</em></span>.  By alerting
          other users that serialization is in effect for particular
          versioned object, those other users can reasonably expect
          that the object is about to be changed by someone else,
          and they, too, can avoid wasting their time and energy on
          unmergeable changes that won't be committable due to eventual
          out-of-dateness.</p></li></ul></div><p>When referring to Subversion's locking feature, one is
      actually talking about a fairly diverse collection of behaviors
      which include the ability to lock a versioned file
      <sup>[<a id="idp9797264" href="#ftn.idp9797264" class="footnote">20</a>]</sup>
      (claiming the exclusive right to modify the file), to unlock
      that file (yielding that exclusive right to modify), to see
      reports about which files are locked and by whom, to annotate
      files for which locking before editing is strongly advised, and
      so on.  In this section, we'll cover all of these facets of the
      larger locking feature.</p><div class="sidebar" title="Three meanings of «lock»"><a id="svn.advanced.locking.meanings"></a><div class="titlepage"><div><div><p class="title"><strong>Three meanings of <span class="quote">«<span class="quote">lock</span>»</span></strong></p></div></div></div><p>In this section, and almost everywhere in this book, the
        words <span class="quote">«<span class="quote">lock</span>»</span> and <span class="quote">«<span class="quote">locking</span>»</span> describe
        a mechanism for mutual exclusion between users to avoid
        clashing commits. Unfortunately, there are two other sorts
        of <span class="quote">«<span class="quote">lock</span>»</span> with which Subversion, and therefore
        this book, sometimes needs to be concerned.</p><p>The first is <em class="firstterm">working copy locks</em>,
        used internally by Subversion to prevent clashes between
        multiple Subversion clients operating on the same working
        copy.  This is the sort of lock indicated by an
        <code class="computeroutput">L</code> in the third column of
        <span class="command"><strong>svn status</strong></span> output, and removed by the
        <span class="command"><strong>svn cleanup</strong></span> command, as described in <a class="xref" href="#svn.tour.other.cleanup" title="svn cleanup">«<span class="command"><strong>svn cleanup</strong></span>»</a>.</p><p>Secondly, there are <em class="firstterm">database locks</em>,
        used internally by the Berkeley DB backend to prevent clashes
        between multiple programs trying to access the database.  This
        is the sort of lock whose unwanted persistence after an error
        can cause a repository to be <span class="quote">«<span class="quote">wedged</span>»</span>, as
        described in <a class="xref" href="#svn.reposadmin.maint.recovery" title="Repository Recovery">«Repository Recovery»</a>.</p><p>You can generally forget about these other kinds of locks
        until something goes wrong that requires you to care about
        them.  In this book, <span class="quote">«<span class="quote">lock</span>»</span> means the first sort
        unless the contrary is either clear from context or explicitly
        stated.</p></div><div class="sect2" title="Creating locks"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.locking.creation"></a>Creating locks</h3></div></div></div><p>In the Subversion repository, a
        <em class="firstterm">lock</em> is a piece of metadata which
        grants exclusive access to one user to change a file.  This
        user is said to be the <em class="firstterm">lock owner</em>.
        Each lock also has a unique identifier, typically a long
        string of characters, known as the <em class="firstterm">lock
        token</em>.  The repository manages locks, ultimately
        handling their creation, enforcement, and removal.  If any
        commit transaction attempts to modify or delete a locked file
        (or delete one of the parent directories of the file), the
        repository will demand two pieces of information—that
        the client performing the commit be authenticated as the lock
        owner, and that the lock token has been provided as part of
        the commit process as a sort of proof that client knows which
        lock it is using.</p><p>To demonstrate lock creation, let's refer back to our
        example of multiple graphic designers working with on the same
        binary image files.  Harry has decided to change a JPEG image.
        To prevent other people from committing changes to the file
        while he is modifying it (as well as alerting them that he is
        about to change it), he locks the file in the repository using
        the <span class="command"><strong>svn lock</strong></span> command.</p><pre class="screen">$ svn lock banana.jpg --message "Editing file for tomorrow's release."
'banana.jpg' locked by user 'harry'.
$
</pre><p>There are a number of new things demonstrated in the
        previous example.  First, notice that Harry passed the
        <code class="option">--message</code> option to <span class="command"><strong>svn
        lock</strong></span>.  Similar to <span class="command"><strong>svn commit</strong></span>, the
        <span class="command"><strong>svn lock</strong></span> command can take comments (either
        via <code class="option">--message (-m)</code> or <code class="option">--file
        (-F)</code>) to describe the reason for locking the file.
        Unlike <span class="command"><strong>svn commit</strong></span>, however, <span class="command"><strong>svn
        lock</strong></span> will not demand a message by launching your
        preferred text editor.  Lock comments are optional, but still
        recommended to aid communication.</p><p>Secondly, the lock attempt succeeded.  This means that the
        file wasn't already locked, and that Harry had the latest
        version of the file.  If Harry's working copy of the file had
        been out-of-date, the repository would have rejected the
        request, forcing Harry to <span class="command"><strong>svn update</strong></span> and
        reattempt the locking command.  The locking command would also
        have failed if the file already been locked by someone
        else.</p><p>As you can see, the <span class="command"><strong>svn lock</strong></span> command
        prints confirmation of the successful lock.  At this point,
        the fact that the file is locked becomes apparent in the
        output of the <span class="command"><strong>svn status</strong></span> and <span class="command"><strong>svn
        info</strong></span> reporting subcommands.</p><pre class="screen">$ svn status
     K banana.jpg

$ svn info banana.jpg
Path: banana.jpg
Name: banana.jpg
URL: http://svn.example.com/repos/project/banana.jpg
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 2198
Node Kind: file
Schedule: normal
Last Changed Author: frank
Last Changed Rev: 1950
Last Changed Date: 2006-03-15 12:43:04 -0600 (Wed, 15 Mar 2006)
Text Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)
Properties Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)
Checksum: 3b110d3b10638f5d1f4fe0f436a5a2a5
Lock Token: opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e
Lock Owner: harry
Lock Created: 2006-06-14 17:20:31 -0500 (Wed, 14 Jun 2006)
Lock Comment (1 line):
Editing file for tomorrow's release.

$
</pre><p>That the <span class="command"><strong>svn info</strong></span> command, which does
        not contact the repository when run against working copy
        paths, can display the lock token reveals an important fact
        about lock tokens—that they are cached in the working
        copy.  The presence of the lock token is critical.  It gives
        the working copy authorization to make use of the lock later
        on.  Also, the <span class="command"><strong>svn status</strong></span> command shows a
        <code class="literal">K</code> next to the file (short for locKed),
        indicating that the lock token is present.</p><div class="sidebar" title="Regarding lock tokens"><div class="titlepage"><div><div><p class="title"><strong>Regarding lock tokens</strong></p></div></div></div><p>A lock token isn't an authentication token, so much as
          an <span class="emphasis"><em>authorization</em></span> token.  The token
          isn't a protected secret.  In fact, a lock's unique token is
          discoverable by anyone who runs <span class="command"><strong>svn info
          URL</strong></span>.  A lock token is special only when it lives
          inside a working copy.  It's proof that the lock was created
          in that particular working copy, and not somewhere else by
          some other client.  Merely authenticating as the lock owner
          isn't enough to prevent accidents.</p><p>For example, suppose you lock a file using a computer at
          your office, but leave work for the day before you finish
          your changes to that file.  It should not be possible to
          accidentally commit changes to that same file from your home
          computer later that evening simply because you've
          authenticated as the lock's owner.  In other words, the lock
          token prevents one piece of Subversion-related software from
          undermining the work of another.  (In our example, if you
          really need to change the file from an alternate working
          copy, you would need to break the lock and re-lock the
          file.)</p></div><p>Now that Harry has locked <code class="filename">banana.jpg</code>,
        Sally is unable to change or delete that file:</p><pre class="screen">$ svn delete banana.jpg
D         banana.jpg
$ svn commit -m "Delete useless file."
Deleting       banana.jpg
svn: Commit failed (details follow):
svn: DELETE of
'/repos/project/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc35d/banana.jpg':
423 Locked (http://svn.example.com)
$
</pre><p>But Harry, after touching up the banana's shade of yellow,
        is able to commit his changes to the file.  That's because he
        authenticates as the lock owner, and also because his working
        copy holds the correct lock token:</p><pre class="screen">$ svn status
M    K banana.jpg
$ svn commit -m "Make banana more yellow"
Sending        banana.jpg
Transmitting file data .
Committed revision 2201.
$ svn status
$
</pre><p>Notice that after the commit is finished, <span class="command"><strong>svn
        status</strong></span> shows that the lock token is no longer
        present in working copy.  This is the standard behavior of
        <span class="command"><strong>svn commit</strong></span>—it searches the working
        copy (or list of targets, if you provide such a list) for
        local modifications, and sends all the lock tokens it
        encounters during this walk to the server as part of the
        commit transaction.  After the commit completes successfully,
        all of the repository locks that were mentioned are
        released—<span class="emphasis"><em>even on files that weren't
        committed</em></span>.  This is meant to discourage users from
        being sloppy about locking, or from holding locks for too
        long.  If Harry haphazardly locks thirty files in a directory
        named <code class="filename">images</code> because he's unsure of which
        files he needs to change, yet only only changes four of those
        file, when he runs <span class="command"><strong>svn commit images</strong></span>, the
        process will still release all thirty locks.</p><p>This behavior of automatically releasing locks can be
        overridden with the <code class="option">--no-unlock</code> option to
        <span class="command"><strong>svn commit</strong></span>.  This is best used for those
        times when you want to commit changes, but still plan to make
        more changes and thus need to retain existing locks.  You can
        also make this your default behavior by setting the
        <code class="literal">no-unlock</code> runtime configuration option (see
        <a class="xref" href="#svn.advanced.confarea" title="Параметры времени выполнения">«Параметры времени выполнения»</a>).</p><p>Of course, locking a file doesn't oblige one to commit a
        change to it.  The lock can be released at any time with a
        simple <span class="command"><strong>svn unlock</strong></span> command:</p><pre class="screen">$ svn unlock banana.c
'banana.c' unlocked.
</pre></div><div class="sect2" title="Discovering locks"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.locking.discovery"></a>Discovering locks</h3></div></div></div><p>When a commit fails due to someone else's locks, it's
        fairly easy to learn about them.  The easiest of
        these is <span class="command"><strong>svn status --show-updates</strong></span>:</p><pre class="screen">$ svn status --show-updates
M              23   bar.c
M    O         32   raisin.jpg
       *       72   foo.h
Status against revision:     105
$
</pre><p>In this example, Sally can see not only that her copy of
        <code class="filename">foo.h</code> is out-of-date, but that one of the
        two modified files she plans to commit is locked in the
        repository.  The <code class="literal">O</code> symbol stands for
        <span class="quote">«<span class="quote">Other</span>»</span>, meaning that a lock exists on the file,
        and was created by somebody else.  If she were to attempt a
        commit, the lock on <code class="filename">raisin.jpg</code> would
        prevent it.  Sally is left wondering who made the lock, when,
        and why.  Once again, <span class="command"><strong>svn info</strong></span> has the
        answers:</p><pre class="screen">$ svn info http://svn.example.com/repos/project/raisin.jpg
Path: raisin.jpg
Name: raisin.jpg
URL: http://svn.example.com/repos/project/raisin.jpg
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 105
Node Kind: file
Last Changed Author: sally
Last Changed Rev: 32
Last Changed Date: 2006-01-25 12:43:04 -0600 (Sun, 25 Jan 2006)
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)
Lock Comment (1 line):
Need to make a quick tweak to this image.
$
</pre><p>Just as <span class="command"><strong>svn info</strong></span> can be used to examine
        objects in the working copy, it can also be used to examine
        objects in the repository.  If the main argument to
        <span class="command"><strong>svn info</strong></span> is a working copy path, then all
        of the working copy's cached information is displayed; any
        mention of a lock means that the working copy is holding a
        lock token (if a file is locked by another user or in another
        working copy, <span class="command"><strong>svn info</strong></span> on a working copy
        path will show no lock information at all).  If the main
        argument to <span class="command"><strong>svn info</strong></span> is a URL, then the
        information reflects the latest version of an object in the
        repository, and any mention of a lock describes the current
        lock on the object.</p><p>So in this particular example, Sally can see that Harry
        locked the file on February 16th to <span class="quote">«<span class="quote">make a quick
        tweak</span>»</span>.  It being June, she suspects that he probably
        forgot all about the lock.  She might phone Harry to complain
        and ask him to release the lock.  If he's unavailable, she
        might try to forcibly break the lock herself or ask an
        administrator to do so.</p></div><div class="sect2" title="Breaking and stealing locks"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.locking.break-steal"></a>Breaking and stealing locks</h3></div></div></div><p>A repository lock isn't sacred—in Subversion's
        default configuration state, locks can be released not only by
        the person who created them, but by anyone at all.  When
        somebody other than the original lock creator destroys a lock,
        we refer to this as <em class="firstterm">breaking</em> the
        lock.</p><p>From the administrator's chair, it's simple to break
        locks.  The <span class="command"><strong>svnlook</strong></span>
        and <span class="command"><strong>svnadmin</strong></span> programs have the ability to
        display and remove locks directly from the repository.  (For
        more information about these tools, see
        <a class="xref" href="#svn.reposadmin.maint.tk" title="An Administrator's Toolkit">«An Administrator's Toolkit»</a>.)</p><pre class="screen">$ svnadmin lslocks /usr/local/svn/repos
Path: /project2/images/banana.jpg
UUID Token: opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923
Owner: frank
Created: 2006-06-15 13:29:18 -0500 (Thu, 15 Jun 2006)
Expires:
Comment (1 line):
Still improving the yellow color.

Path: /project/raisin.jpg
UUID Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Owner: harry
Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)
Expires:
Comment (1 line):
Need to make a quick tweak to this image.

$ svnadmin rmlocks /usr/local/svn/repos /project/raisin.jpg
Removed lock on '/project/raisin.jpg'.
$
</pre><p>The more interesting option is allowing users to break
        each other's locks over the network.  To do this, Sally simply
        needs to pass the <code class="option">--force</code> to the unlock
        command:</p><pre class="screen">$ svn status --show-updates
M              23   bar.c
M    O         32   raisin.jpg
       *       72   foo.h
Status against revision:     105
$ svn unlock raisin.jpg
svn: 'raisin.jpg' is not locked in this working copy
$ svn info raisin.jpg | grep URL
URL: http://svn.example.com/repos/project/raisin.jpg
$ svn unlock http://svn.example.com/repos/project/raisin.jpg
svn: Unlock request failed: 403 Forbidden (http://svn.example.com)
$ svn unlock --force http://svn.example.com/repos/project/raisin.jpg
'raisin.jpg' unlocked.
$
</pre><p>Now, Sally's initial attempt to unlock failed because she
        ran <span class="command"><strong>svn unlock</strong></span> directly on her working copy
        of the file, and no lock token was present.  To remove the
        lock directly from the repository, she needs to pass a URL
        to <span class="command"><strong>svn unlock</strong></span>.  Her first attempt to unlock
        the URL fails, because she can't authenticate as the lock
        owner (nor does she have the lock token).  But when she
        passes <code class="option">--force</code>, the authentication and
        authorization requirements are ignored, and the remote lock is
        broken.</p><p>Of course, simply breaking a lock may not be enough.  In
        the running example, Sally may not only want to break Harry's
        long-forgotten lock, but re-lock the file for her own use.
        She can accomplish this by running <span class="command"><strong>svn unlock
        --force</strong></span> and then <span class="command"><strong>svn lock</strong></span>
        back-to-back, but there's a small chance that somebody else
        might lock the file between the two commands.  The simpler thing
        to is <em class="firstterm">steal</em> the lock, which involves
        breaking and re-locking the file all in one atomic step.  To
        do this, Sally passes the <code class="option">--force</code> option
        to <span class="command"><strong>svn lock</strong></span>:</p><pre class="screen">$ svn lock raisin.jpg
svn: Lock request failed: 423 Locked (http://svn.example.com)
$ svn lock --force raisin.jpg
'raisin.jpg' locked by user 'sally'.
$
</pre><p>In any case, whether the lock is broken or stolen, Harry
        may be in for a surprise.  Harry's working copy still contains
        the original lock token, but that lock no longer exists.  The
        lock token is said to be <em class="firstterm">defunct</em>.  The
        lock represented by the lock-token has either been broken (no
        longer in the repository), or stolen (replaced with a
        different lock).  Either way, Harry can see this by asking
        <span class="command"><strong>svn status</strong></span> to contact the
        repository:</p><pre class="screen">$ svn status
     K raisin.jpg
$ svn status --show-updates
     B         32   raisin.jpg
$ svn update
  B  raisin.jpg
$ svn status
$
</pre><p>If the repository lock was broken, then <span class="command"><strong>svn
        status --show-updates</strong></span> displays a
        <code class="literal">B</code> (Broken) symbol next to the file.  If a
        new lock exists in place of the old one, then a
        <code class="literal">T</code> (sTolen) symbol is shown.  Finally,
        <span class="command"><strong>svn update</strong></span> notices any defunct lock tokens
        and removes them from the working copy.</p><div class="sidebar" title="Locking Policies"><div class="titlepage"><div><div><p class="title"><strong>Locking Policies</strong></p></div></div></div><p>Different systems have different notions of how strict a
          lock should be.  Some folks argue that locks must be
          strictly enforced at all costs, releasable only by the
          original creator or administrator.  They argue that if
          anyone can break a lock, then chaos runs rampant and the
          whole point of locking is defeated.  The other side argues
          that locks are first and foremost a communication tool.  If
          users are constantly breaking each others' locks, then it
          represents a cultural failure within the team and the
          problem falls outside the scope of software enforcement.</p><p>Subversion defaults to the <span class="quote">«<span class="quote">softer</span>»</span>
          approach, but still allows administrators to create stricter
          enforcement policies through the use of hook scripts.  In
          particular, the <code class="filename">pre-lock</code> and
          <code class="filename">pre-unlock</code> hooks allow administrators
          to decide when lock creation and lock releases are allowed
          to happen.  Depending on whether or not a lock already
          exists, these two hooks can decide whether or not to allow a
          certain user to break or steal a lock.  The
          <code class="filename">post-lock</code> and
          <code class="filename">post-unlock</code> hooks are also available,
          and can be used to send email after locking actions.  To
          learn more about repository hooks, see <a class="xref" href="#svn.reposadmin.create.hooks" title="Hook Scripts">«Hook Scripts»</a>.</p></div></div><div class="sect2" title="Lock Communication"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.locking.lock-communication"></a>Lock Communication</h3></div></div></div><p>We've seen how <span class="command"><strong>svn lock</strong></span>
        and <span class="command"><strong>svn unlock</strong></span> can be used to create,
        release, break, and steal locks.  This satisfies the goal of
        serializing commit access to a file.  But what about the
        larger problem of preventing wasted time?</p><p>For example, suppose Harry locks an image file and then
        begins editing it.  Meanwhile, miles away, Sally wants to do
        the same thing.  She doesn't think to run <span class="command"><strong>svn status
        --show-updates</strong></span>, so she has no idea that Harry has
        already locked the file.  She spends hours editing the file,
        and when she tries to commit her change, she discovers that
        either the file is locked or that she's out-of-date.
        Regardless, her changes aren't mergeable with Harry's.  One of
        these two people has to throw away their work, and a lot of
        time has been wasted.</p><p>Subversion's solution to this problem is to provide a
        mechanism to remind users that a file ought to be locked
        <span class="emphasis"><em>before</em></span> the editing begins.  The mechanism
        is a special property, <code class="literal">svn:needs-lock</code>.  If
        that property is attached to a file (regardless of its value,
        which is irrelevant), then Subversion will try to use
        filesystem-level permissions to make the file read-only,
        unless, of course, the user has explicitly locked the file.
        When a lock-token is present (as a result of running
        <span class="command"><strong>svn lock</strong></span>), the file becomes read-write.
        When the lock is released, the file becomes read-only
        again.</p><p>The theory, then, is that if the image file has this
        property attached, then Sally would immediately notice
        something is strange when she opens the file for editing.
        Many applications alert users immediately when a read-only
        file is opened for editing.  And nearly all applications would
        at least prevent her from saving changes to the file.  This
        reminds her to lock the file before editing, whereby she
        discovers the pre-existing lock:</p><pre class="screen">$ /usr/local/bin/gimp raisin.jpg
gimp: error: file is read-only!
$ ls -l raisin.jpg
-r--r--r--   1 sally   sally   215589 Jun  8 19:23 raisin.jpg
$ svn lock raisin.jpg
svn: Lock request failed: 423 Locked (http://svn.example.com)
$ svn info http://svn.example.com/repos/project/raisin.jpg | grep Lock
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2006-06-08 07:29:18 -0500 (Thu, 08 June 2006)
Lock Comment (1 line):
Making some tweaks.  Locking for the next two hours.
$
</pre><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>Users and administrators alike are encouraged to attach
          the <code class="literal">svn:needs-lock</code> property to any file
          which cannot be contextually merged.  This is the primary
          technique for encouraging good locking habits and preventing
          wasted effort.</p></td></tr></tbody></table></div><p>Note that this property is a communication tool which
        works independently from the locking system.  In other words,
        any file can be locked, whether or not this property is
        present.  And conversely, the presence of this property
        doesn't make the repository require a lock when
        committing.</p><p>Unfortunately, the system isn't flawless.  It's possible
        that even when a file has the property, the read-only reminder
        won't always work.  Sometimes applications misbehave and
        <span class="quote">«<span class="quote">hijack</span>»</span> the read-only file, silently allowing
        users to edit and save the file anyway.  There's not much that
        Subversion can do in this situation—at the end of the
        day, there's simply no substitution for good interpersonal
        communication.
        <sup>[<a id="idp9863824" href="#ftn.idp9863824" class="footnote">21</a>]</sup>
      </p></div></div><div class="sect1" title="Внешние зависимости"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.externals"></a>Внешние зависимости</h2></div></div></div><p>Иногда полезно иметь рабочую копию, собранную из разных источников.
      К примеру, может понадобиться, чтобы различные рабочие подкаталоги
      выгружались из разных каталогов хранилища, или даже из разных хранилищ.
      Безусловно, всё это можно сделать вручную, с помощью вызовов команды
      <span class="command"><strong>svn checkout</strong></span> создав рабочую копию с нужной структурой.
      Но, ели подобная структура требуется всем пользователям хранилища, 
      каждому из них нужно будет повторить все те же операции по созданию
      рабочей копии, которые делали вы сами.</p><p>Чтобы этого избежать, Subversion обеспечивает поддержку
      <em class="firstterm">внешних зависимостей</em>. Внешняя зависимость 
      является сопоставлением локального каталога к URL  
      версионированного каталога (или к его конкретной правке). Групповое 
      объявление внешних зависимостей делается в Subversion при помощи 
      свойства <code class="literal">svn:externals</code>. Установка и редактирование 
      этого свойства выполняется с помощью команд
      <span class="command"><strong>svn propset</strong></span> и <span class="command"><strong>svn propedit</strong></span>
      (см. <a class="xref" href="#svn.advanced.props.manip" title="Использование свойств">«Использование свойств»</a>). Свойство может быть 
      установлено для любого версионированного каталога, значение свойства 
      представляет собой таблицу с путями к подкаталогам (относительно того 
      каталога, для которого это свойство устанавливается) и полными 
      абсолютными URL в Subversion-хранилище.</p><pre class="screen">$ svn propget svn:externals calc
third-party/sounds             http://sounds.red-bean.com/repos
third-party/skins              http://skins.red-bean.com/repositories/skinproj
third-party/skins/toolkit -r21 http://svn.red-bean.com/repos/skin-maker
</pre><p>Удобство свойства <code class="literal">svn:external</code> заключается в том,
      что после его задания для версионированного каталога все, кто будет
      создавать рабочую копию с этим каталогом, получат возможность пользоваться
      преимуществами внешней зависимости. Другими словами, после того как 
      кто-то из участников проекта обозначил необходимую структуру рабочей
      копии, больше никому не придется об этом беспокоиться — при 
      создании рабочей копии Subversion, кроме оригинальных данных, сделает 
      рабочие копии данных, определенных как внешние зависимости.</p><p>Посмотрите на предыдущий пример с внешними зависимостями. Когда 
      кто-нибудь будет создавать рабочую копию каталога
      <code class="filename">calc</code>, Subversion создаст, в том числе, и копии
      элементов, определенных как внешние зависимости.</p><pre class="screen">$ svn checkout http://svn.example.com/repos/calc
A  calc
A  calc/Makefile
A  calc/integer.c
A  calc/button.c
Checked out revision 148.

Fetching external item into calc/third-party/sounds
A  calc/third-party/sounds/ding.ogg
A  calc/third-party/sounds/dong.ogg
A  calc/third-party/sounds/clang.ogg
…
A  calc/third-party/sounds/bang.ogg
A  calc/third-party/sounds/twang.ogg
Checked out revision 14.

Fetching external item into calc/third-party/skins
…
</pre><p>Если необходимо изменить внешние зависимости, сделать это можно с 
      помощью обычных команд редактирования свойств. После того как вы 
      зафиксируете изменения свойства <code class="literal">svn:externals</code>, 
      при следующем запуске
      <span class="command"><strong>svn update</strong></span> Subversion синхронизирует 
      существующие копии элементов в соответствии с внесенными во внешние 
      зависимости изменениями. Тоже самое произойдет и когда другие 
      участники проекта обновят свои рабочие копии и получат изменения во
      внешних зависимостях.</p><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>Учитывая, что свойство <code class="literal">svn:externals</code> имеет 
        многострочное значение, крайне рекомендуется вместо команды
        <span class="command"><strong>svn propset</strong></span> использовать
        <span class="command"><strong>svn propedit</strong></span>.</p></td></tr></tbody></table></div><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>Вам стоит всерьез подумать про использование явно указанного
        номера правки для всех внешних зависимостей. Поступая таким образом, 
        вы сможете выбирать момент перехода на другой снимок внешней 
        информации и явно указывать какой это будет снимок. Кроме того что это 
        позволяет избежать получения неожиданных изменений из сторонних 
        хранилищ, которые вы, возможно, никак не контролируете, явное указание
        номера правки означает, что откат вашей рабочей копии к более ранней
        правке приведет к откату и для внешних зависимостей, к тому состоянию,
        в котором они были в той, предыдущей, правке, то есть это значит, что
        внешние рабочие копии будут выглядеть так, как <span class="emphasis"><em>они</em></span>
        выглядели на момент той правки вашего хранилища. Для программных
        проектов это может быть вопросом удачной или неудачной сборки старого
        снимка сложной и запутанной базы программного кода.</p></td></tr></tbody></table></div><p>Команда <span class="command"><strong>svn status</strong></span> умеет определять внешние 
      зависимости, показывая код статуса <code class="literal">X</code> для 
      подкаталогов, выгруженных из внешних зависимостей, и рекурсивно 
      проходя по этим подкаталогам для отображения статуса самих внешних
      элементов.</p><p>Вместе с тем, текущая реализация поддержки внешних зависимостей
      в Subversion может вводить в заблуждение. Во-первых, внешние зависимости
      могут указывать только на папки, но не на файлы. Во-вторых, внешние 
      зависимости не могут указывать на относительные пути (например, 
      такие как <code class="filename">../../skins/myskin</code>).  В-третьих, 
      рабочие копии, созданные через внешние зависимости, являются оторванными от 
      первичной рабочей копии (от того каталога, для которого установлено
      свойство <code class="literal">svn:externals</code>). А Subversion полноценно
      работает только на неотсоединенных рабочих копиях. Это означает, что
      если вы захотите зафиксировать изменения, сделанные в одной или
      нескольких таких рабочих копиях, вам придется принудительно выполнять
      команду <span class="command"><strong>svn commit</strong></span> для этих рабочих копий — 
      фиксация в первичной рабочей копии не распространяется на внешние 
      зависимости.</p><p>Кроме того, поскольку зависимости используют абсолютные URL,
      перемещение или копирование папки, к которой они присоединены, не
      будет влиять на то, что будет выгружаться из хранилища в виде
      внешней зависимости (при этом, локальные подкаталоги, назначенные
      как целевые для внешних зависимостей, при переименовании родительского
      каталога будут, естественно, перемещены вместе с ним).
      В определенных ситуациях это может сбивать с толку и запутывать.
      Например, у вас есть корневой каталог <code class="filename">my-project</code>
      и для одного из его подкаталогов (<code class="filename">my-project/some-dir</code>)
      вы назначаете внешнюю зависимость, отслеживающую изменения другого
      подкаталога (<code class="filename">my-project/external-dir</code>).</p><pre class="screen">$ svn co http://svn.example.com/projects .
A    my-project
A    my-project/some-dir
A    my-project/external-dir
…
Fetching external item into 'my-project/some-dir/subdir'
Checked out external at revision 11.

Checked out revision 11.
$ svn pget svn:externals my-project/some-dir
subdir http://svn.example.com/projects/my-project/external-dir

$
</pre><p>Переименуем с помощью команды <span class="command"><strong>svn move</strong></span> 
      каталог <code class="filename">my-project</code>. Теперь 
      внешние зависимости продолжают продолжают указывать на путь в каталоге
     <code class="filename">my-project</code>, а самого этого каталога уже не 
     существует.</p><pre class="screen">$ svn mv -q my-project renamed-project
$ svn ci -m "Rename my-project to renamed-project."
Deleting       my-project
Adding         my-renamed-project

Committed revision 12.
$ svn up

Fetching external item into 'renamed-project/some-dir/subdir'
svn: Target path does not exist
$
</pre><p>Тот факт, что внешние зависимости используют абсолютные URL, может 
      вызвать проблемы при работе с хранилищами, доступными через несколько
      URL-схем. Интересная проблема может возникнуть, если, например, сервер 
      Subversion позволяет любому пользователю создать рабочую копию, подключившись
      через <code class="literal">http://</code> или <code class="literal">https://</code>, а
      фиксации позволяет выполнять только через <code class="literal">https://</code>.
      Если внешние зависимости используют <code class="literal">http://</code> вариант 
      URL хранилища, то для рабочих копий, созданных для этих внешних 
      зависимостей, нельзя будет выполнить фиксацию изменений. С другой 
      стороны, если использовался <code class="literal">https://</code> вариант URL, то 
      пользователи, которые создают рабочую копию через
      <code class="literal">http://</code> потому, что их клиент не поддерживает
      <code class="literal">https://</code>, не смогут получить внешние элементы.
      Обратите внимание и на то, что при переопределении рабочей копии
      (с помощью команды <span class="command"><strong>svn --relocate</strong></span>) внешние 
      зависимости <span class="emphasis"><em>не</em></span> будут переопределены.</p><p>Наконец, могут быть ситуации, в которых предпочтительно, чтобы
      подкоманды <span class="command"><strong>svn</strong></span> не идентифицировали и не оперировали
      рабочими копиями, созданными как внешние зависимости. Для таких
      случаев при вызове подкоманды можно использовать параметр
      <code class="option">--ignore-externals</code>.</p></div><div class="sect1" title="Стержневые и оперативные правки"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.pegrevs"></a>Стержневые и оперативные правки</h2></div></div></div><p>Мы постоянно копируем, перемещаем, переименовываем и 
      полностью заменяем файлы и каталоги на наших компьютерах.
      И вашей системе управления версиями вовсе не обязательно знать,
      каким образом вы производите эти операции с файлами и каталогами,
      находящимися под версионным контролем. Поддержка управления файлами
      в Subversion очень либеральна, она допускает такую гибкость при 
      работе с версионированными файлами, какая доступна для
      неверсионированных файлов. Но такая гибкость означает, что
      на протяжении жизненного цикла вашего хранилища определенный
      версионированный объект может иметь различные пути, и, напротив, 
      определенный путь может указывать на различные, совершенно 
      не связанные версионированные объекты. Такое положение дел
      вносит определенные сложности в ваше взаимодействие с этими
      путями и объектами.</p><p>Subversion весьма сообразителен в отслеживании ситуаций,
      когда история версий объекта включает подобные <span class="quote">«<span class="quote">изменения 
      адреса</span>»</span>. Например, если вы запросите журнал истории 
      правок конкретного файла, который был переименован на прошлой 
      неделе, Subversion предоставит его вам без всяких проблем.
      В нем будут отмечены правка, в которой произошло переименование,
      а также журнал правок, имеющих отношение к объекту и произошедших
      как до, так и после переименования. Таким образом, чаще всего
      вам даже не придется задумываться о таких вещах. Но иногда
      Subversion все-таки потребуется ваша помощь, чтобы устранить
      неоднозначности.</p><p>Простейшим примером может служить ситуация, когда каталог или 
      файл сначала удаляют из версионного контроля, а затем создают
      новый элемент с тем же именем и добавляют его под версионный 
      контроль. Безусловно, то, что вы удалили и то, что вы
      впоследствии добавили — это разные вещи. Просто так 
      получилось, что они имеют одинаковый путь, например 
      <code class="filename">/trunk/object</code>.  Что должен выдать
      Subversion, когда вы запросите у него историю
      <code class="filename">/trunk/object</code>?  Имеете ли вы ввиду
      то, что находится по этому пути в текущий момент, или тот
      старый объект, который вы удалили? Спрашиваете ли вы об операциях,
      совершенных со <span class="emphasis"><em>всеми</em></span> объектами, которые
      когда-либо располагались по этому пути? Очевидно, Subversion
      требуется подсказка о том, что же вы действительно хотите 
      получить.</p><p>Благодаря перемещениям история версионированного объекта
      может получиться гораздо более извилистой, чем в только что
      рассмотренном примере. Допустим, что у вас есть каталог с 
      именем <code class="filename">concept</code>, содержащий недавно начатый
      проект разработки программы, с которым вы усиленно 
      экспериментируете. В один прекрасный момент этот проект 
      дорастет до того, что вы признаете идею действительно стоящей
      и ценой неимоверных усилий все-таки решите дать проекту имя.
      <sup>[<a id="idp9998320" href="#ftn.idp9998320" class="footnote">22</a>]</sup>
      Допустим, вы назвали вашу программу Frabnaggilywort. При этом
      не помешало бы переименовать каталог, чтобы он отражал новое
      имя проекта, поэтому <code class="filename">concept</code> переименовывается 
      в <code class="filename">frabnaggilywort</code>.  Жизнь идет дальше,
      выпускается версия Frabnaggilywort 1.0, она доступна для скачиванися
      и ежедневно используется кучей людей, жаждущих улучшить
      свою жизнь.</p><p>Это действительно хорошая история — но она на этом не 
      заканчивается. У такого предприимчивого человека как вы в голове
      уже родилась новая идея. Поэтому вы создаете новый каталог с 
      именем <code class="filename">concept</code>, и цикл начинается снова.
      На самом деле, этот цикл с годами повторяется многократно,
      каждый раз начинаясь со старого каталога 
      <code class="filename">concept</code>, который впоследствии иногда
      переименовывается (когда идея оказывается хороша), а иногда 
      удаляется (когда идея оказывается неудачной). Чтобы совсем
      запутаться, предположим, что вы сначала переименовали 
      <code class="filename">concept</code> во что-то еще, а впоследствии 
      по какой-то причине переименовали его обратно в 
      <code class="filename">concept</code>.</p><p>При возникновении подобных ситуаций пытаться объяснить
      Subversion, как работать с этими многократно используемыми
      путями — все равно что сказать автомобилисту в западных
      пригородах Чикаго, чтобы он ехал на восток вниз по 
      Roosevelt Road, а затем повернул налево на Main Street.
      Меньше чем за двадцать минут можно пересечь 
      <span class="quote">«<span class="quote">Main Street</span>»</span> в Уитоне, Глен Эллине и Ломбарде.  
      И это будут три разных улицы.  Нашему автомобилисту, как и 
      Subversion, нужно больше подробностей, чтобы поступить 
      правильно.</p><p>Начиная с версии 1.1, Subversion позволяет вам точно
      указать, какую именно Main Street вы имеете ввиду.  
      Для этого используется так называемая 
      <em class="firstterm">стержневая правка</em> (peg revision) — 
      то есть правка, указываемая Subversion исключительно для того, 
      чтобы однозначно идентифицировать отдельную линию в истории.
      Поскольку в любой конкретный момент времени (или, говоря точнее,
      в любой конкретной правке) определенному пути может 
      соответствовать не более одного версионированного 
      объекта, комбинации пути и стержневой правки достаточно для
      однозначной ссылки на определенную линию в истории.
      Для указания стержневых правок в клиенте Subversion с интерфейсом 
      командной строки используется <em class="firstterm">at-синтаксис</em>,
      который получил такое название, потому что включает добавление 
      <span class="quote">«<span class="quote">символа at</span>»</span> (<code class="literal">@</code>) и номера
      стержневой правки после пути, который связан с данной
      правкой.</p><p>Ну а как же параметр <code class="option">--revision (-r)</code>, о котором
      мы так много говорили в этой книге? Эта правка (или множество правок)
      называется <em class="firstterm">оперативной правкой</em> (или 
      <em class="firstterm">диапазоном оперативных правок</em>).  
      Идентифицировав конкретную линию в истории с помощью пути и 
      стержневой правки, Subversion выполняет требуемые операции,
      используя оперативную правку (или правки).
      Возвращаясь к нашей аналогии с улицами Чикаго, если нам объясняют,
      как проехать к дому 606 N. по Main Street в Уитоне,
      <sup>[<a id="idp10022784" href="#ftn.idp10022784" class="footnote">23</a>]</sup>
      мы можем рассматривать <span class="quote">«<span class="quote">Main Street</span>»</span> как путь
      и <span class="quote">«<span class="quote">Уитон</span>»</span> как стержневую правку. Эти два
      элемента информации однозначно идентифицируют путь, по которому
      нам следует ехать (на север или на юг Main Street), и позволяет
      нам избежать поездок верх и вниз по неправильным Main Street 
      в поиске точки назначения. Далее мы рассматриваем
      <span class="quote">«<span class="quote">606 N.</span>»</span> как своего рода оперативную правку, 
      и мы <span class="emphasis"><em>точно</em></span> знаем, куда нам ехать.</p><div class="sidebar" title="Алгоритм поиска по стержневой правке"><div class="titlepage"><div><div><p class="title"><strong>Алгоритм поиска по стержневой правке</strong></p></div></div></div><p>Командная строка Subversion выполняет алгоритм поиска по 
        стержневой правке всегда, когда требуется разрешить потенциальную
        неоднозначность в указанных пользователем путях и правках.
        Ниже, чтобы проиллюстрировать алгоритм, приведен пример 
        такого вызова.</p><pre class="screen">$ svn <em class="replaceable"><code>command</code></em> -r <em class="replaceable"><code>OPERATIVE-REV</code></em> item@<em class="replaceable"><code>PEG-REV</code></em>
</pre><p>Алгоритм состоит из трех простых шагов:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Найти <em class="replaceable"><code>элемент</code></em> в правке,
            указанной как <em class="replaceable"><code>PEG-REV</code></em>.  
            Такой объект может оказаться только один.</p></li><li class="listitem"><p>Проследить историю объекта (включая все возможные
            переименования) в направлении своего предка
            в правке <em class="replaceable"><code>OPERATIVE-REV</code></em>.</p></li><li class="listitem"><p>Произвести требуемые действия с этим предком,
            где бы он ни находился и как бы он ни назывался
            в этот момент.</p></li></ul></div><p>Отметим, что даже если вы не указали явным образом
        стержневую и оперативную правки, они все равно присутствуют.
        Для удобства стержневой правкой по умолчанию считается
        <code class="literal">BASE</code> для элементов рабочей копии и 
        <code class="literal">HEAD</code> для URL-адресов хранилища.  
        Если не указана оперативная правка, то по умолчанию
        она равна стержневой правке.</p></div><p>Допустим, что хранилище создано давным давно, и в правке 1 
      была добавлен наш первый каталог <code class="filename">concept</code>, 
      а также файл <code class="filename">IDEA</code> внутри этого каталога,
      содержащий описание концепции. После нескольких правок,
      в которых добавлялся и изменялся реальный программный код,
      в правке 20 мы переименовали этот каталог в 
      <code class="filename">frabnaggilywort</code>.  В правке 27 у нас появилась
      новая идея, для которой мы создали новый каталог 
      <code class="filename">concept</code> и новый файл 
      <code class="filename">IDEA</code> с описание наших мыслей.
      Спустя пять лет и двадцать тысяч правок они будут уже 
      частью одной древней истории.</p><p>Теперь, спустя годы, мы интересуемся, как же выглядел 
      файл <code class="filename">IDEA</code> в правке 1.
      Но Subversion нужно знать, спрашиваем ли мы о том, как
      выглядел в правке 1 <span class="emphasis"><em>текущий</em></span> файл,
      или интересуемся содержанием того файла, который когда-то,
      в правке 1 имел путь <code class="filename">concepts/IDEA</code>? 
      Эти вопросы, конечно же, будут иметь разные ответы, и 
      благодаря стержневым правкам мы можем задать оба из них.
      Чтобы найти, как выглядел в той старой правке текущий файл 
      <code class="filename">IDEA</code>, мы выполним такую команду:</p><pre class="screen">$ svn cat -r 1 concept/IDEA 
svn: Unable to find repository location for 'concept/IDEA' in revision 1
</pre><p>Конечно же, в данном примере, текущего файла
      <code class="filename">IDEA</code> в правке 1 еще не было и в помине,
      поэтому Subversion выдаст ошибку. Вышеприведенная команда
      — это сокращение более длинной записи, включающей
      явную ссылку на стержневую правку. Расширенная запись будет
      выглядеть так:</p><pre class="screen">$ svn cat -r 1 concept/IDEA@BASE
svn: Unable to find repository location for 'concept/IDEA' in revision 1
</pre><p>Ее выполнение приведет к тому же ожидаемому результату.
      Стержневой правкой по умолчанию считается <code class="literal">BASE</code> 
      (правка, представленная в текущий момент в вашей рабочей копии)
      при указании путей рабочей копии, и <code class="literal">HEAD</code> 
      при указании URL-адресов.</p><p>Проницательный читатель, вероятно, поинтересуется,
      как же быть с at-синтаксисом в случае, если пути рабочей
      копии или URL сами по себе содержат символ at. Откуда
      <span class="command"><strong>svn</strong></span> узнает, является ли 
      <code class="literal">news@11</code> именем каталога в моей файловой 
      структуре, или же синтаксисом для <span class="quote">«<span class="quote">правки 11 
      каталога <code class="filename">news</code></span>»</span>? К счастью,
      хотя <span class="command"><strong>svn</strong></span> предполагает последнее, 
      существует тривиальный обходной прием. Нужно всего лишь
      добавить символ at в конец пути, записав его как 
      <code class="literal">news@11@</code>. 
      <span class="command"><strong>svn</strong></span> обращает внимание только на последний
      символ at в аргументе и не считaет ошибкой, если вы
      опустите указание стержневой правки после символа at.
      Этот обходной прием применим даже к путям, которые оканчиваются
      символом at — укажите <code class="literal">filename@@</code>,
      чтобы сослаться на файл с именем 
      <code class="filename">filename@</code>.</p><p>Давайте зададимся теперь вторым вопросом —
      какого было в правке 1 содержание файла, располагавшегося 
      по адресу <code class="filename">concepts/IDEA</code>?  Получить
      ответ нам поможет явное указание стержневой правки.</p><pre class="screen">$ svn cat concept/IDEA@1
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</pre><p>Заметьте, что на этот раз мы не указали оперативную правку.
      Это возможно, поскольку при отсутствии указания на оперативную
      правку Subversion по умолчанию предполагает, что она такая же,
      как и стержневая правка.</p><p>Судя по выведенному тексту файла, это именно то, 
      что мы ожидали получить. 
      В тексте даже упоминается frabbing naggily worts, так что 
      почти наверняка этот файл описывает программу, называющуюся
      теперь Frabnaggilywort. Мы можем в этом удостовериться, явно 
      указав и стержневую, и оперативную правки. Нам известно, что
      в правке <code class="literal">HEAD</code> проект Frabnaggilywort 
      располагается в каталоге <code class="filename">frabnaggilywort</code>.  
      Поэтому мы укажем, что хотим увидеть, как выглядела в правке 1
      та линия истории,  которая идентифицируется в 
      <code class="literal">HEAD</code> как путь 
      <code class="filename">frabnaggilywort/IDEA</code>.</p><pre class="screen">$ svn cat -r 1 frabnaggilywort/IDEA@HEAD
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</pre><p>И стержневая, и оперативная правки не обязательно должны
      быть столь тривиальными. Предположим, что 
      <code class="filename">frabnaggilywort</code> удален из 
      <code class="literal">HEAD</code>, но при этом нам известно, что он 
      существовал в правке 20, и мы хотим увидеть различия для файла
      <code class="filename">IDEA</code> между правками 4 и 10.  Мы можем указать
      стержневую правку 20 вместе с URL, по которому располагался файл
      <code class="filename">IDEA</code> проекта Frabnaggilywort в правке 20,
      а затем использовать 4 и 10 как указатели диапазона оперативных
      правок.</p><pre class="screen">$ svn diff -r 4:10 http://svn.red-bean.com/projects/frabnaggilywort/IDEA@20
Index: frabnaggilywort/IDEA
===================================================================
--- frabnaggilywort/IDEA	(revision 4)
+++ frabnaggilywort/IDEA	(revision 10)
@@ -1,5 +1,5 @@
-The idea behind this project is to come up with a piece of software
-that can frab a naggily wort.  Frabbing naggily worts is tricky
-business, and doing it incorrectly can have serious ramifications, so
-we need to employ over-the-top input validation and data verification
-mechanisms.
+The idea behind this project is to come up with a piece of
+client-server software that can remotely frab a naggily wort.
+Frabbing naggily worts is tricky business, and doing it incorrectly
+can have serious ramifications, so we need to employ over-the-top
+input validation and data verification mechanisms.
</pre><p>К счастью, большинство людей не сталкивается со столь сложными
      ситуациями. Но если такое все-таки случится, помните, что стержневые
      правки — это дополнительная подсказка, которая нужна
      Subversion для устранения неоднозначности.</p></div><div class="footnotes"><br><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.idp9364816" href="#idp9364816" class="para">13</a>] </sup>Если вы знакомы с XML, то синтаксис XML "Name" допускает
            практически то же подмножество символов ASCII.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp9400000" href="#idp9400000" class="para">14</a>] </sup>Исправление в лог-сообщениях орфографических, грамматических
        ошибок, <span class="quote">«<span class="quote">просто ошибочных</span>»</span> записей — наверное,
        самый распространенный случай использования параметра
        <code class="option">--revprop</code>.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp9504656" href="#idp9504656" class="para">15</a>] </sup>Вы думаете, это всё?  В тот же самый период времени
              WordPerfect также предпочитал использовать расширение 
              <code class="filename">.DOC</code> для своего собственного 
              закрытого формата файлов!</p></div><div class="footnote"><p><sup>[<a id="ftn.idp9533120" href="#idp9533120" class="para">16</a>] </sup>Для указания исполняемых файлов файловая система Windows 
              использует расширения файлов (а именно 
              <code class="literal">.EXE</code>, <code class="literal">.BAT</code> и
              <code class="literal">.COM</code>).</p></div><div class="footnote"><p><sup>[<a id="ftn.idp9642304" href="#idp9642304" class="para">17</a>] </sup>Это все, что создает система сборки?</p></div><div class="footnote"><p><sup>[<a id="ftn.idp9708096" href="#idp9708096" class="para">18</a>] </sup>… или даже, возможно, параграф в книге …</p></div><div class="footnote"><p><sup>[<a id="ftn.idp9790816" href="#idp9790816" class="para">19</a>] </sup>Communication wouldn't have been such bad medicine for
          Harry and Sally's Hollywood namesakes, either, for that
          matter.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp9797264" href="#idp9797264" class="para">20</a>] </sup>Subversion does not currently allow locks on directories.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp9863824" href="#idp9863824" class="para">21</a>] </sup>Except, perhaps, a classic Vulcan mind-meld.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp9998320" href="#idp9998320" class="para">22</a>] </sup><span class="quote">«<span class="quote">You're not supposed to name it.  Once you name it,
          you start getting attached to it.</span>»</span> — Mike
          Wazowski</p></div><div class="footnote"><p><sup>[<a id="ftn.idp10022784" href="#idp10022784" class="para">23</a>] </sup>606 N. Main Street, Wheaton, Illinois, is the home of
          the Wheaton History Center.  Get it—<span class="quote">«<span class="quote">History
          Center</span>»</span>?  It seemed appropriate….</p></div></div></div><div class="chapter" title="Глава 4. Ветвление и слияние"><div class="titlepage"><div><div><h2 class="title"><a id="svn.branchmerge"></a>Глава 4. Ветвление и слияние</h2></div></div></div><div class="toc"><p><strong>Содержание</strong></p><dl><dt><span class="sect1"><a href="#svn.branchmerge.whatis">Что такое ветка?</a></span></dt><dt><span class="sect1"><a href="#svn.branchmerge.using">Использование веток</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.using.create">Создание ветки</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.using.work">Работа с веткой</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.using.concepts">Ключевые идеи, стоящие за ветками</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.copychanges">Копирование изменений между ветками</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.copychanges.specific">Копирование отдельных изменений</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.copychanges.keyconcept">Ключевые идеи, стоящие за слиянием</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.copychanges.bestprac">Как правильнее всего использовать слияние</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.track">Ручной контроль слияния</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.preview">Предварительный просмотр результатов слияния</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.merge">Конфликты при слиянии</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.copychanges.bestprac.ancestry">Учитывать или игнорировать происхождение</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.commonuses">Типовые примеры</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.wholebr">Полное объединение двух веток</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.undo">Отмена изменений</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.resurrect">Восстановление удаленных элементов</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.commonuses.patterns">Типовые приемы использования веток</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.branchmerge.commonuses.patterns.release">Ветки релизов</a></span></dt><dt><span class="sect3"><a href="#svn.branchmerge.commonuses.patterns.feature">Функциональные ветки</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.switchwc">Переключение рабочей копии</a></span></dt><dt><span class="sect1"><a href="#svn.branchmerge.tags">Метки</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.tags.mksimple">Создание простой метки</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.tags.mkcomplex">Создание комплексной метки</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.maint">Поддержка веток</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.branchmerge.maint.layout">Структура хранилища</a></span></dt><dt><span class="sect2"><a href="#svn.branchmerge.maint.lifetime">Продолжительность жизни информации</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.vendorbr">Vendor branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.vendorbr.general">General Vendor Branch Management Procedure</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.vendorbr.svn_load_dirs"><span class="command"><strong>svn_load_dirs.pl</strong></span></a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.branchmerge.summary">Подводя итоги</a></span></dt></dl></div><p>Ветвление, назначение меток и слияние — это понятия, 
    свойственные практически всем системам управления версиями. Если 
    вы плохо знакомы с этими понятиями, то в этой главе вы с ними 
    обстоятельно познакомитесь. Если эти понятия вам уже знакомы, 
    то мы надеемся, что вам будет интересно узнать, как эти идеи 
    реализованы в Subversion.</p><p>Ветвление — фундаментальное понятие управления версиями.
    Если вы собираетесь доверить Subversion управление своей информацией, 
    то это именно та функция, от которой вы впоследствии будете сильно 
    зависеть. Материал данной главы предполагает, что вы уже знакомы 
    с основными понятиями Subversion (<a class="xref" href="#svn.basic" title="Глава 1. Фундаментальные понятия">Глава&nbsp;1, <em>Фундаментальные понятия</em></a>).</p><div class="sect1" title="Что такое ветка?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.whatis"></a>Что такое ветка?</h2></div></div></div><p>Предположим, что ваша работа заключается в сопровождении
      документа (например, какого-то руководства) для подразделений
      вашей компании. Однажды различные подразделения запросят
      у вас одно и то же руководство, но при этом в несколько 
      <span class="quote">«<span class="quote">адаптированном</span>»</span> для них варианте, поскольку
      работа каждого подразделения имеет свою специфику.</p><p>Как быть в такой ситуации? Скорее всего, вы 
      создадите вторую копию документа и начнёте отдельно сопровождать 
      обе копии. Когда какое-то из подразделений попросит вас
      внести небольшие изменения, вы включите их либо в первую копию, 
      либо во вторую.</p><p>Чаще всего вам придется вносить изменения в обе копии.
      Например, если вы обнаружите опечатку в одной копии, скорее
      всего, эта же опечатка будет присутствовать и в другой.
      Два документа, в общем-то, почти одинаковы — их различия
      сводятся к отдельным специфичным моментам.</p><p>В этом заключается основная идея
      <em class="firstterm">ветки</em> — то есть направления разработки,
      которое существует независимо от другого направления, но
      имеет с ним общую историю, если заглянуть немного в прошлое.
      Ветка всегда берет начало как копия чего-либо и движется от
      этой точки, создавая свою собственную историю (см. <a class="xref" href="#svn.branchmerge.whatis.dia-1" title="Рисунок 4.1. Ветки разработки">Рисунок&nbsp;4.1, «Ветки разработки»</a>).</p><div class="figure"><a id="svn.branchmerge.whatis.dia-1"></a><p class="title"><strong>Рисунок 4.1. Ветки разработки</strong></p><div class="figure-contents"><div><img src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/ch04dia1.png" alt="Ветки разработки"></div></div></div><br class="figure-break"><br><p>В Subversion есть команды, которые помогают сопровождать
      параллельные ветки файлов и каталогов. Они позволяют создавать
      ветки, копируя данные и запоминая, что копии связаны
      друг с другом. Кроме того, эти команды помогают дублировать изменения
      из одной ветки в другую. Наконец, они могут сделать так, что отдельные 
      части рабочей копии будут отражать состояние различных веток, 
      что позволит вам <span class="quote">«<span class="quote">смешивать и согласовывать</span>»</span> различные 
      линии разработки в своей каждодневной работе.</p></div><div class="sect1" title="Использование веток"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.using"></a>Использование веток</h2></div></div></div><p>К этому моменту вы должны понимать, что в хранилище при каждой
      фиксации создается полностью новое дерево файлов (называемое
      <span class="quote">«<span class="quote">правка</span>»</span>). Если нет, то вернитесь назад и прочитайте
      о правках в разделе <a class="xref" href="#svn.basic.in-action.revs" title="Правки">«Правки»</a>.</p><p>В этой главе мы воспользуемся тем же примером, что и
      в <a class="xref" href="#svn.basic" title="Глава 1. Фундаментальные понятия">Глава&nbsp;1, <em>Фундаментальные понятия</em></a>. Как вы помните, вы и ваш соразработчик
      Салли совместно используете хранилище, содержащее два проекта,
      <code class="filename">paint</code> и <code class="filename">calc</code>. Как
      отмечалось в <a class="xref" href="#svn.branchmerge.using.dia-1" title="Рисунок 4.2. Начальная структура хранилища">Рисунок&nbsp;4.2, «Начальная структура хранилища»</a>, каждый
      каталог проекта содержит подкаталоги с именами
      <code class="filename">trunk</code> и <code class="filename">branches</code>.
      Назначение этих каталогов вскоре станет понятно.</p><div class="figure"><a id="svn.branchmerge.using.dia-1"></a><p class="title"><strong>Рисунок 4.2. Начальная структура хранилища</strong></p><div class="figure-contents"><div><img src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/ch04dia2.png" alt="Начальная структура хранилища"></div></div></div><br class="figure-break"><br><p>Как и раньше, предположим, что и Салли, и вы имеете
      рабочие копии проекта <span class="quote">«<span class="quote">calc</span>»</span>. Точнее, каждый
      из вас имеет рабочую копию <code class="filename">/calc/trunk</code>.
      Все файлы, относящиеся к проекту, находятся в этом подкаталоге,
      а не прямо в <code class="filename">/calc</code>, потому что ваша команда
      решила размещать <span class="quote">«<span class="quote">главную линию</span>»</span> разработки в
      <code class="filename">/calc/trunk</code>.</p><p>Допустим, перед вами была поставлена задача коренной реорганизации
      проекта. Это займет много времени и затронет все файлы проекта.
      Проблема заключается в том, что вы не хотите мешать Салли, которая
      прямо сейчас занимается исправлением небольших ошибок. Ее работа
      зависит от постоянной доступности последней версии проекта (каталога
      <code class="filename">/calc/trunk</code>). Если вы начнете пошагово фиксировать
      свои изменения, вы конечно же смешаете Салли все карты.</p><p>Одним из вариантов является временная изоляция:
      вы и Салли перестаете делиться информацией на неделю или две.
      В это время вы начинаете перелопачивать и реорганизовывать файлы
      рабочей копии, но не фиксируете и не обновляете ее до завершения 
      работы над задачей. Однако, в этом случае появляется несколько
      проблем. Во-первых, это не очень надежно. Большинство людей
      предпочитают часто сохранять свою работу в хранилище на случай, если
      с рабочей копией вдруг случится что-то плохое. Во-вторых, это не
      достаточно гибко. Если вы работаете на разных компьютерах
      (к примеру, если рабочая копия <code class="filename">/calc/trunk</code>
      есть у вас на двух разных машинах), вам придется вручную копировать
      изменения туда и обратно, либо делать всю работу на одном
      компьютере. С другой стороны, вам трудно делиться вносимыми
      изменениями с кем-то еще. А предоставление возможности 
      знакомиться с проделанной вами работой по мере ее продвижения
      считается <span class="quote">«<span class="quote">наилучшей практикой</span>»</span> при разработке 
      любого программного обеспечения. Если никто не будет видеть 
      ваших промежуточных фиксаций, вы теряете
      потенциал обратной связи. Наконец, когда вы закончите свои 
      изменения, может выясниться, что слить проделанную вами работу
      с остальным программным кодом компании чрезвычайно трудно.
      Салли (или кто-то другой) могла внести такие изменения в
      хранилище, которые трудно совместить с вашей рабочей копией
      — особенно, если вы выполните <span class="command"><strong>svn update</strong></span>
      впервые после нескольких недель изоляции.</p><p>Наилучшим решением будет создание в хранилище вашей собственной 
      ветки, или направления разработки. Это позволит вам сохранять
      наполовину поломанную работу сколь угодно часто, не пересекаясь 
      с другими, и кроме того, вы сможете выборочно делиться
      информацией с другими коллегами.
      Дальше вы увидите, как всё это работает.</p><div class="sect2" title="Создание ветки"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.using.create"></a>Создание ветки</h3></div></div></div><p>Создать ветку очень просто — при помощи команды
        <span class="command"><strong>svn copy</strong></span> в хранилище создается копия проекта.
        Subversion может копировать не только отдельные файлы, но и
        целые каталоги. Итак, вам нужно сделать копию каталога
        <code class="filename">/calc/trunk</code>. Где должна лежать эта
        новая копия? Где угодно — этот вопрос определяется
        правилами проекта. Допустим, что по правилам вашей команды 
        ветки создаются в каталоге <code class="filename">/calc/branches</code>
        хранилища, и вы хотите назвать свою ветку
        <code class="literal">my-calc-branch</code>. Тогда вам следует создать новый
        каталог <code class="filename">/calc/branches/my-calc-branch</code>,
        который будет копией <code class="filename">/calc/trunk</code>.</p><p>Копию можно создать двумя различными способами. Сперва мы покажем
        более длинный способ, просто для того, что бы пояснить суть идеи.
        Для начала создадим рабочую копию корневого каталога проекта
        <code class="filename">/calc</code>:</p><pre class="screen">$ svn checkout http://svn.example.com/repos/calc bigwc
A  bigwc/trunk/
A  bigwc/trunk/Makefile
A  bigwc/trunk/integer.c
A  bigwc/trunk/button.c
A  bigwc/branches/
Checked out revision 340.
</pre><p>Теперь, чтобы создать копию, достаточно просто передать
        два пути в пределах рабочей копии команде
        <span class="command"><strong>svn copy</strong></span>:</p><pre class="screen">$ cd bigwc
$ svn copy trunk branches/my-calc-branch
$ svn status
A  +   branches/my-calc-branch
</pre><p>В результате команда <span class="command"><strong>svn copy</strong></span>
        рекурсивно копирует рабочий каталог <code class="filename">trunk</code>
        в новый рабочий каталог
        <code class="filename">branches/my-calc-branch</code>. Теперь команда
        <span class="command"><strong>svn status</strong></span> покажет, что новый каталог
        запланирован для добавления в хранилище. Обратите внимание
        на знак <span class="quote">«<span class="quote">+</span>»</span> после буквы А. Он означает, что
        запланированное для добавления представляет собой какую-то
        <span class="emphasis"><em>копию</em></span>, а не что-то новое.
        При следующей фиксации Subversion создаст в хранилище 
        каталог <code class="filename">/calc/branches/my-calc-branch</code>,
        скопировав его из <code class="filename">/calc/trunk</code>
        вместо того, чтобы повторно отправлять по сети
        всю информацию рабочей копии:</p><pre class="screen">$ svn commit -m "Creating a private branch of /calc/trunk."
Adding         branches/my-calc-branch
Committed revision 341.
</pre><p>А теперь покажем простой способ создания ветки, о котором мы 
        упоминали раньше: команда <span class="command"><strong>svn copy</strong></span> может 
        оперировать двумя URL-адресами напрямую.</p><pre class="screen">$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/my-calc-branch \
      -m "Creating a private branch of /calc/trunk."

Committed revision 341.
</pre><p>В сущности, между этими двумя методами нет разницы. Оба варианта
        создают в правке 341 новый каталог, и этой новый каталог является
        копией <code class="filename">/calc/trunk</code>. Это показывает <a class="xref" href="#svn.branchmerge.using.create.dia-1" title="Рисунок 4.3. Хранилище, содержащее новую копию">Рисунок&nbsp;4.3, «Хранилище, содержащее новую копию»</a>. Обратите 
        внимание на то, что второй метод, кроме всего прочего, выполняет
        <span class="emphasis"><em>немедленную</em></span> фиксацию. <sup>[<a id="idp10996304" href="#ftn.idp10996304" class="footnote">24</a>]</sup>Эта процедура более проста в использовании, так как нет
        необходимости в выгрузке в рабочую копию значительного объема данных
        из хранилища. По сути, в этом случае можно вовсе не иметь рабочей
        копии.</p><div class="figure"><a id="svn.branchmerge.using.create.dia-1"></a><p class="title"><strong>Рисунок 4.3. Хранилище, содержащее новую копию</strong></p><div class="figure-contents"><div><img src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/ch04dia3.png" alt="Хранилище, содержащее новую копию"></div></div></div><br class="figure-break"><br><div class="sidebar" title="Легкие копии"><div class="titlepage"><div><div><p class="title"><strong>Легкие копии</strong></p></div></div></div><p>Хранилище Subversion устроено особым образом.
          При копировании каталога нет необходимости задумываться о
          большом увеличении размера хранилища — на самом деле
          Subversion никогда не дублирует информацию. Вместо этого
          создается новая точка входа в каталог, которая указывает на
          <span class="emphasis"><em>существующее</em></span> дерево файлов. Если вы
          пользователь Unix, это тот же подход, что используется
          для жестких ссылок. То есть копия, так сказать, стала
          <span class="quote">«<span class="quote">ленивой</span>»</span>. Если в скопированном каталоге
          вы измените только один файл, при фиксации изменится только
          он — остальные файлы продолжат существовать как 
          ссылки на исходные файлы в исходном каталоге.</p><p>Вот почему в разговорах пользователей Subversion часто можно
          услышать о <span class="quote">«<span class="quote">легких копиях</span>»</span>. Не имеет значения,
          насколько велик каталог — создание копии займет
          очень небольшой фиксированный промежуток времени. Фактически,
          на этом подходе основана работа фиксаций в Subversion: каждая
          правка является <span class="quote">«<span class="quote">легкой копией</span>»</span> предыдущей правки,
          с несколькими элементами, лениво измененными в ней. (Чтобы узнать
          подробности, посетите веб-сайт Subversion и прочитайте в
          документации по архитектуре Subversion о методе <span class="quote">«<span class="quote">всплывающих
          пузырьков</span>»</span>.)</p><p>Конечно, эти внутренние механизмы копирования и совместного 
          использования информации скрыты от пользователя, который видит 
          просто копии файлов. Главное здесь то, что копии — легкие
          как по времени, так и по размеру. Делайте ветки так часто, как
          вам необходимо.</p></div></div><div class="sect2" title="Работа с веткой"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.using.work"></a>Работа с веткой</h3></div></div></div><p>После создания ветки проекта можно загрузить новую рабочую копию
        и приступить к работе с ней:</p><pre class="screen">$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A  my-calc-branch/Makefile
A  my-calc-branch/integer.c
A  my-calc-branch/button.c
Checked out revision 341.
</pre><p>В этой рабочей копии нет ничего особенного; это 
        просто зеркало другого каталога хранилища. Однако, если Салли 
        обновит свою рабочую копию, она не увидит там ваших изменений.
        Рабочая копия Салли создана из каталога 
        <code class="filename">/calc/trunk</code>. (Смотрите далее в этой главе
        раздел <a class="xref" href="#svn.branchmerge.switchwc" title="Переключение рабочей копии">«Переключение рабочей копии»</a>: команда
        <span class="command"><strong>svn switch</strong></span> является альтернативным способом
        создания рабочей копии ветки.)</p><p>Предположим, что за неделю были сделаны следующие
        фиксации:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Вы внесли изменения в
          <code class="filename">/calc/branches/my-calc-branch/button.c</code>,
          создав таким образом правку 342.</p></li><li class="listitem"><p>Вы внесли изменения в
          <code class="filename">/calc/branches/my-calc-branch/integer.c</code>,
          создав правку 343.</p></li><li class="listitem"><p>Салли внесла изменения в
          <code class="filename">/calc/trunk/integer.c</code>, создав
          правку 344.</p></li></ul></div><p>Теперь у файла <code class="filename">integer.c</code>
        есть два независимых направления разработки, что демонстрирует 
        <a class="xref" href="#svn.branchmerge.using.work.dia-1" title="Рисунок 4.4. История ветвления для одного файла">Рисунок&nbsp;4.4, «История ветвления для одного файла»</a>.</p><div class="figure"><a id="svn.branchmerge.using.work.dia-1"></a><p class="title"><strong>Рисунок 4.4. История ветвления для одного файла</strong></p><div class="figure-contents"><div><img src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/ch04dia4.png" alt="История ветвления для одного файла"></div></div></div><br class="figure-break"><br><p>Если посмотреть историю изменений, сделанных в вашей копии
        <code class="filename">integer.c</code>, можно увидеть интересные
        вещи:</p><pre class="screen">$ pwd
/home/user/my-calc-branch

$ svn log --verbose integer.c
------------------------------------------------------------------------
r343 | user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/branches/my-calc-branch/integer.c

* integer.c:  frozzled the wazjub.

------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</pre><p>Обратите внимание на то, что Subversion полностью прослеживает
        всю историю ветки <code class="filename">integer.c</code> во времени,
        в том числе пересекая точку создания копии. Создание ветки
        показано как событие в истории, потому что файл
        <code class="filename">integer.c</code> был неявно скопирован при
        копировании всего каталога <code class="filename">/calc/trunk/</code>.
        Теперь давайте посмотрим, какой результат выдаст такая же
        команда для Салли:</p><pre class="screen">$ pwd
/home/sally/calc

$ svn log --verbose integer.c
------------------------------------------------------------------------
r344 | sally | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  fix a bunch of spelling errors.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</pre><p>Салли увидит свои собственные изменения в правке 344, 
        а ваши, сделанные в правке 343 — нет. Subversion 
        позаботилась о том, чтобы эти две фиксации затронули разные 
        файлы, имеющие разное расположение в хранилище. Тем не менее, 
        Subversion <span class="emphasis"><em>будет</em></span> показывать то, что два файла 
        имеют общую историю. До создания ветки-копии в правке 341 это был 
        один файл. Поэтому и вы, и Салли видите изменения, сделанные в 
        правках 303 и 98.</p></div><div class="sect2" title="Ключевые идеи, стоящие за ветками"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.using.concepts"></a>Ключевые идеи, стоящие за ветками</h3></div></div></div><p>Из этого раздела вы должны запомнить две вещи.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>В отличие от многих других систем управления версиями,
          в хранилище Subversion ветки существуют не в отдельном измерении,
          а как <span class="emphasis"><em>обычные каталоги файловой системы</em></span>. 
          Эти каталоги отличаются только тем, что несут дополнительную
          информацию о своей истории.</p></li><li class="listitem"><p>Subversion не имеет такого понятия как ветка —
            есть только копии. Копия каталога
            становится <span class="quote">«<span class="quote">веткой</span>»</span> только потому, что
            <span class="emphasis"><em>вы</em></span> рассматриваете ее таким образом.
            Вы можете по-разному думать о каталоге, по разному его 
            трактовать, но для Subversion это не более чем обычный каталог,
            созданный в результате копирования.</p></li></ol></div></div></div><div class="sect1" title="Копирование изменений между ветками"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.copychanges"></a>Копирование изменений между ветками</h2></div></div></div><p>Теперь вы и Салли работаете над параллельными ветками проекта:
      вы — над своей собственной веткой, а Салли — над
      главной линией разработки 
      (каталог <em class="firstterm">trunk</em>).</p><p>В проектах со значительным числом участников, как правило,
      большинство работает в главной линии разработки.
      Когда кому-то необходимо сделать изменения, которые займут
      много времени и могут нарушить главную линию, стандартной практикой
      является создание отдельной ветки и фиксация всех изменений в ней
      — до тех пор, пока работа не будет полностью завершена.</p><p>Положительным моментом здесь является то, что вы и Салли не
      пересекаетесь друг с другом. Но есть и минус — 
      вы можете разойтись <span class="emphasis"><em>слишком</em></span> далеко друг
      относительно друга. Помните, что одна из проблем такой
      стратегии <span class="quote">«<span class="quote">временной изоляции</span>»</span> заключается в том,
      что к моменту, когда вы завершите работу со своей веткой,
      может оказаться практически невозможным объединить ее 
      с главной линией без огромного количества конфликтов.</p><p>Вместо этого вы и Салли можете продолжать делиться изменениями
      по ходу работы. Вы можете решать вплоть до отдельного изменения,
      стоит ли им делиться — Subversion предоставляет возможность
      выборочного <span class="quote">«<span class="quote">копирования</span>»</span> изменений между ветками.
      А тогда, когда вы полностью закончите работу со своей веткой, 
      вы можете скопировать обратно в основную ветку все изменения 
      полностью.</p><div class="sect2" title="Копирование отдельных изменений"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.copychanges.specific"></a>Копирование отдельных изменений</h3></div></div></div><p>В предыдущем разделе мы отметили, что и вы, и Салли, 
        одновременно, в разных ветках вносите изменения в файл
        <code class="filename">integer.c</code>.
        Если посмотреть на лог-сообщение Салли для правки 344, вы увидите,
        что она исправила несколько орфографических ошибок. Конечно же,
        в вашей копии этого файла эти ошибки остались. Не исключено, что
        ваши будущие изменения этого файла коснутся областей, 
        содержащих эти орфографические ошибки, и таким образом вы получите 
        несколько потенциальных конфликтов при последующем объединении 
        вашей ветки. Поэтому лучше получить изменения от Салли сейчас,
        <span class="emphasis"><em>до</em></span> того, как вы начнете вплотную работать с
        этой частью файла.</p><p>Настал момент воспользоваться командой <span class="command"><strong>svn
        merge</strong></span>. Эта команда, оказывается, является очень близким
        родственником команды <span class="command"><strong>svn diff</strong></span> (о которой вы
        читали в <a class="xref" href="#svn.tour" title="Глава 2. Экскурсия по Subversion">Глава&nbsp;2, <em>Экскурсия по Subversion</em></a>). Обе команды способны
        сравнивать любые два объекта в хранилище и показывать различия.
        Например, вы можете попросить <span class="command"><strong>svn diff</strong></span> показать
        все изменения, сделанные Салли в правке 344:</p><pre class="screen">$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk

Index: integer.c
===================================================================
--- integer.c (revision 343)
+++ integer.c (revision 344)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info-&gt;operating_system, "HPFS (OS/2 or NT)"); break;
     case 7:  sprintf(info-&gt;operating_system, "Macintosh"); break;
     case 8:  sprintf(info-&gt;operating_system, "Z-System"); break;
-    case 9:  sprintf(info-&gt;operating_system, "CPM"); break;
+    case 9:  sprintf(info-&gt;operating_system, "CP/M"); break;
     case 10:  sprintf(info-&gt;operating_system, "TOPS-20"); break;
     case 11:  sprintf(info-&gt;operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info-&gt;operating_system, "QDOS"); break;
@@ -164,7 +164,7 @@
     low = (unsigned short) read_byte(gzfile);  /* read LSB */
     high = (unsigned short) read_byte(gzfile); /* read MSB */
     high = high &lt;&lt; 8;  /* interpret MSB correctly */
-    total = low + high; /* add them togethe for correct total */
+    total = low + high; /* add them together for correct total */

     info-&gt;extra_header = (unsigned char *) my_malloc(total);
     fread(info-&gt;extra_header, total, 1, gzfile);
@@ -241,7 +241,7 @@
      Store the offset with ftell() ! */

   if ((info-&gt;data_offset = ftell(gzfile))== -1) {
-    printf("error: ftell() retturned -1.\n");
+    printf("error: ftell() returned -1.\n");
     exit(1);
   }

@@ -249,7 +249,7 @@
   printf("I believe start of compressed data is %u\n", info-&gt;data_offset);
   #endif

-  /* Set postion eight bytes from the end of the file. */
+  /* Set position eight bytes from the end of the file. */

   if (fseek(gzfile, -8, SEEK_END)) {
     printf("error: fseek() returned non-zero\n");
</pre><p>Команда <span class="command"><strong>svn merge</strong></span> ведет себя 
        практически идентично. Но вместо вывода различий на терминал
        она применяет их к рабочей копии в виде <span class="emphasis"><em>локальных
        изменений</em></span>:</p><pre class="screen">$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c
</pre><p>Вывод команды <span class="command"><strong>svn merge</strong></span> показывает, что
        к вашей копии <code class="filename">integer.c</code> был применен патч.
        Теперь она содержит изменения Салли — они были
        <span class="quote">«<span class="quote">скопированы</span>»</span> из главной линии разработки в вашу
        рабочую копию, вашу собственную ветку, и теперь существуют в виде
        локальных изменений. С этого момента вы можете просмотреть локальные
        изменения и убедиться в том, что они корректны.</p><p>Возможна ситуация, когда не все будет так хорошо
        и <code class="filename">integer.c</code> окажется в состоянии
        конфликта. Тогда вам будет необходимо разрешить конфликт
        обычным путем (см. <a class="xref" href="#svn.tour" title="Глава 2. Экскурсия по Subversion">Глава&nbsp;2, <em>Экскурсия по Subversion</em></a>), либо, если вы
        придете к мнению, что объединение было плохой идеей, просто
        отказаться от него, отменив локальные изменения командой
        <span class="command"><strong>svn revert</strong></span>.</p><p>Просмотрев результат объединения исправлений, его можно
        зафиксировать как обычно (<span class="command"><strong>svn commit</strong></span>).
        После этого изменения будут внесены в вашу ветку хранилища.
        В терминологии управления версиями такую процедуру копирования
        изменений между ветками обычно называют
        <em class="firstterm">портированием</em> изменений.</p><p>При фиксации локальных изменений убедитесь, что в 
        лог-сообщении упоминается о портировании отдельных изменений
        из одной ветки в другую. Например:</p><pre class="screen">$ svn commit -m "integer.c: ported r344 (spelling fixes) from trunk."
Sending        integer.c
Transmitting file data .
Committed revision 360.
</pre><p>Как вы увидите в последующих разделах, очень важно следовать
        этой <span class="quote">«<span class="quote">хорошей практике</span>»</span>.</p><div class="sidebar" title="Почему бы не использовать вместо этого патчи?"><div class="titlepage"><div><div><p class="title"><strong>Почему бы не использовать вместо этого патчи?</strong></p></div></div></div><p>Зачем вообще связываться с <span class="command"><strong>svn merge</strong></span>? 
          Этот вопрос может крутиться у вас в голове, особенно
          если вы пользователь Unix:  Почему бы не использовать
          команду операционной системы <span class="command"><strong>patch</strong></span> для
          выполнения той же работы? Например:</p><pre class="screen">$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk &gt; patchfile
$ patch -p0  &lt; patchfile
Patching file integer.c using Plan A...
Hunk #1 succeeded at 147.
Hunk #2 succeeded at 164.
Hunk #3 succeeded at 241.
Hunk #4 succeeded at 249.
done
</pre><p>Для этого конкретного случая, действительно, разницы
          нет. Однако, <span class="command"><strong>svn merge</strong></span> имеет 
          специфические возможности, благодаря которым превосходит 
          программу <span class="command"><strong>patch</strong></span>.
          Формат файлов, используемый программой <span class="command"><strong>patch</strong></span>,
          является довольно ограниченным; он способен передавать только 
          изменения содержимого файлов. Он не позволяет описать изменения
          <span class="emphasis"><em>дерева</em></span> файлов, такие как добавление, 
          удаление или переименование файлов и каталогов. Если, скажем, 
          в результате исправлений Салли добавился новый каталог, в 
          выводе <span class="command"><strong>svn diff</strong></span> это упоминаться не будет.
          Вывод <span class="command"><strong>svn diff</strong></span> представляет собой только
          ограниченный патч-формат, он просто не может передать 
          некоторые вещи. <sup>[<a id="idp11112912" href="#ftn.idp11112912" class="footnote">25</a>]</sup> Команда
          <span class="command"><strong>svn merge</strong></span>, напротив, может передавать
          изменения в структуре файлов и свойств, непосредственно 
          применяя их к рабочей копии.</p></div><p>Небольшое предупреждение: несмотря на то, что <span class="command"><strong>svn
        diff</strong></span> и <span class="command"><strong>svn merge</strong></span> по сути очень 
        похожи, во многих случаях они используют разный синтаксис.
        Обязательно прочтите об этом в <a class="xref" href="#svn.ref" title="Глава 9. Полное справочное руководство по Subversion">Глава&nbsp;9, <em>Полное справочное руководство по Subversion</em></a>, или
        спросите у <span class="command"><strong>svn help</strong></span>. Например, <span class="command"><strong>svn
        merge</strong></span> требует в качестве целевого объекта путь в
        рабочей копии, то есть место, где ей нужно применить изменения
        структуры файлов. Если целевой объект не указан, предполагается,
        что делается попытка выполнить одну из следующих операций:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>объединение изменений каталога с вашим текущим
            рабочим каталогом;</p></li><li class="listitem"><p>объединение изменений в конкретном файле с
            файлом, имеющим то же имя в текущем рабочем каталоге.</p></li></ol></div><p>Если вы объединяете каталог и не указываете целевой путь,
        <span class="command"><strong>svn merge</strong></span> предполагает первый из приведенных выше
        вариантов и пытается применить изменения к текущему каталогу.
        Если вы объединяете файл, и при этом файл с таким именем
        есть в текущем рабочем каталоге, <span class="command"><strong>svn merge</strong></span>
        подразумевает второй случай и пытается применить изменения
        к локальному файлу с таким же именем.</p><p>Если вы хотите применить изменения к чему-то другому, вам
        нужно это указать. Например, если вы находитесь в родительском
        каталоге рабочей копии, то вам нужно указать целевой каталог,
        получающий изменения:</p><pre class="screen">$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk my-calc-branch
U   my-calc-branch/integer.c
</pre></div><div class="sect2" title="Ключевые идеи, стоящие за слиянием"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.copychanges.keyconcept"></a>Ключевые идеи, стоящие за слиянием</h3></div></div></div><p>Теперь, после знакомства с примерами использования <span class="command"><strong>svn
        merge</strong></span>, настала пора разобраться в них поглубже. 
        Если вы чувствуете неуверенность в том как, собственно, 
        работает слияние, то вы в этом
        вы не одиноки. Многие пользователи (особенно те, для которых
        управление версиями в новинку) поначалу путаются в правильности
        записи этой команды и в том, как и когда эту функцию следует
        использовать. Отбросьте страх — на самом деле эта команда 
        намного проще, чем вы думаете! Понять, как именно ведет себя 
        <span class="command"><strong>svn merge</strong></span>, очень просто.</p><p>В ступор вводит, главным образом,
        <span class="emphasis"><em>название</em></span> команды. Термин <span class="quote">«<span class="quote">слияние</span>»</span>
        как бы указывает на то, что ветки соединяются вместе, или
        происходит какое-то волшебное смешивание данных. На самом деле это
        не так. Пожалуй, этой команде лучше бы подощло название <span class="command"><strong>svn
        diff-and-apply</strong></span>, поскольку это всё, что в результате 
        происходит: сравниваются два файловых дерева хранилища, а 
        различия переносятся в рабочую копию.</p><p>Команда принимает три аргумента:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Начальное дерево хранилища (как правило,
          называемое <em class="firstterm">левой частью</em>
          при сравнении),</p></li><li class="listitem"><p>Конечное дерево хранилища (как правило
          называемое <em class="firstterm">правой частью</em> при
          сравнении),</p></li><li class="listitem"><p>Рабочую копию, к которой отличия применяются
          в виде локальных изменений (как правило, называемую
          <em class="firstterm">целью</em> слияния).</p></li></ol></div><p>Когда эти три аргумента указаны, производится сравнение 
        двух деревьев, а полученные различия применяются к целевой 
        рабочей копии в виде локальных изменений. После выполнения 
        этой команды результат будет так же, как в случае, если бы вы 
        вручную редактировали файлы или многократно выполняли команды
        <span class="command"><strong>svn add</strong></span> или <span class="command"><strong>svn delete</strong></span>. 
        Если результат вас устраивает, его можно
        зафиксировать. Если результат вас не устраивает, просто
        отмените (<span class="command"><strong>svn revert</strong></span>) все сделанные
        изменения.</p><p>Синтаксис <span class="command"><strong>svn merge</strong></span> позволяет
        указывать эти три аргумента довольно гибко. Вот
        несколько примеров:</p><pre class="screen">      
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk
</pre><p>В первом варианте все три аргумента указаны явно —
        каждое дерево задано в форме <span class="emphasis"><em>URL@REV</em></span> и
        указана целевая рабочая копия. Второй вариант может
        использоваться для краткости записи в ситуациях, когда
        сравниваются две разных правки по одному и тому же URL.
        Последний вариант демонстрирует возможность не указывать целевую
        рабочую копию, при этом по умолчанию используется текущий
        каталог.</p></div><div class="sect2" title="Как правильнее всего использовать слияние"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.copychanges.bestprac"></a>Как правильнее всего использовать слияние</h3></div></div></div><div class="sect3" title="Ручной контроль слияния"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.copychanges.bestprac.track"></a>Ручной контроль слияния</h4></div></div></div><p>На первый взгляд объединить изменения просто, однако
          на практике могут возникнуть трудности. Проблема заключается
          в том, что при многократном объединении изменений одной
          ветки с другой можно непреднамеренно сделать объединение одних
          и тех же изменений <span class="emphasis"><em>дважды</em></span>. Иногда
          это не вызывает проблем. При применении изменений к файлу 
          Subversion, как правило, предупреждает о том, что файл 
          уже содержит изменения и в этом случае не
          выполняет никаких действий. Однако, если уже присутствующие
          изменения были модифицированы, возникнет конфликт.</p><p>В идеале система управления версиями должна предотвращать
          повторное применение изменений к ветке. Она должна автоматически
          фиксировать, какие изменения уже были получены и иметь возможность
          перечислить их вам. Она должна использовать эту информацию 
          для того, чтобы, насколько возможно, помочь автоматизировать
          слияние.</p><p>К сожалению, Subversion не такая система. Как и
          CVS, Subversion пока не сохраняет никакой информации об
          операциях слияния. При фиксации локальных изменений хранилище
          понятия не имеет, являются ли эти изменения результатом
          выполнения команды <span class="command"><strong>svn merge</strong></span> или результатом
          обычного ручного редактирования файлов.</p><p>Что это означает для вас как пользователя? Это означает,
          что до того момента, пока у Subversion не появится этой функции,
          вам придется контролировать слияние информации самостоятельно.
          Лучшим местом для этого является лог-сообщение. Как было
          показано в предыдущих примерах, рекомендуется, чтобы в
          лог-сообщении был указан конкретный номер правки (или диапазон
          правок), которые были слиты в вашу ветку. В этом случае вы 
          сможете впоследствии просмотреть, какие изменения уже содержит
          ваша ветка, запусти команду <span class="command"><strong>svn log</strong></span>. Это
          позволит быть осторожнее при последующих запусках команды 
          <span class="command"><strong>svn merge</strong></span> и избежать пересечения с уже 
          портированными изменениями.</p><p>В следующем разделе мы на примерах рассмотрим эту методику
          в действии.</p></div><div class="sect3" title="Предварительный просмотр результатов слияния"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.copychanges.bestprac.preview"></a>Предварительный просмотр результатов слияния</h4></div></div></div><p>Поскольку результатом слияния являются локальные
          изменения, такая операция не является опасной. Допустив
          при слиянии ошибку, можно просто
          отменить изменения (<span class="command"><strong>svn revert</strong></span>) и
          попробовать еще раз.</p><p>Однако, возможна ситуация, когда рабочая копия уже
          содержит локальные изменения. Изменения, примененные при
          слиянии, будут смешаны с уже существующими, и запуск
          <span class="command"><strong>svn revert</strong></span> нас больше не устроит.
          Разделить два множества изменений будет невозможно.</p><p>В такой ситуации лучше попробовать спрогнозировать
          или проверить результат слияния до того, как оно произойдет.
          Проще всего запустить для этого <span class="command"><strong>svn diff</strong></span>
          с теми же аргументами, что и для <span class="command"><strong>svn merge</strong></span>.
          Мы уже показывали это в первом примере объединения. Другим 
          способом предварительного просмотра может служить вызов 
          команды слияния с опцией <code class="option">--dry-run</code>:</p><pre class="screen">$ svn merge --dry-run -r 343:344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
#  nothing printed, working copy is still unchanged.
</pre><p>Опция <code class="option">--dry-run</code> позволяет не применять 
          локальные изменения к рабочей копии. Она только показывает
          статусы, которые <span class="emphasis"><em>имели бы</em></span> файлы
          при реальном объединении. Это полезно для получения
          <span class="quote">«<span class="quote">сводной</span>»</span> информации о потенциальном слиянии
          в тех случаях, когда запуск <span class="command"><strong>svn diff</strong></span>
          выдает слишком много подробностей.</p></div><div class="sect3" title="Конфликты при слиянии"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.copychanges.bestprac.merge"></a>Конфликты при слиянии</h4></div></div></div><p>Так же как и <span class="command"><strong>svn update</strong></span>, команда
          <span class="command"><strong>svn merge</strong></span> внедряет изменения в
          рабочую копию. Следовательно, она тоже может создавать
          конфликты. Однако конфликты, порождаемые <span class="command"><strong>svn
          merge</strong></span>, имеют определенные отличия, и поэтому 
          мы их сейчас рассмотрим подробнее.</p><p>Вначале предположим, что рабочая копия не имеет
          локальных изменений. При обновлении (<span class="command"><strong>svn
          update</strong></span>) рабочей копии до конкретной правки 
          отправляемые сервером изменения будут всегда <span class="quote">«<span class="quote">без 
          проблем</span>»</span> внедряться
          в рабочую копию. Сервер создает дельту, сравнивая два дерева:
          виртуальный снимок рабочей копии и дерево файлов, которое
          вас интересует. Учитывая то, что левая часть сравнения
          полностью эквивалентна тому, что вы уже имеете, дельта
          гарантированно правильно конвертирует рабочую копию в правую
          часть сравнения.</p><p>Однако <span class="command"><strong>svn merge</strong></span> не дает такой
          гарантии, и может вести себя более непредсказуемо:
          пользователь может запросить сервер сравнить
          <span class="emphasis"><em>любые</em></span> два дерева файлов, даже такие,
          которые не имеют отношения к рабочей копии! Из этого
          следует множество потенциальных человеческих
          ошибок. Иногда пользователи будут сравнивать два
          ошибочных дерева, создавая дельту, которая не
          сможет правильно внедриться. <span class="command"><strong>svn
          merge</strong></span> будет пытаться внедрить различия
          по максимуму, но иногда это будет невозможно.
          Так же как команда <span class="command"><strong>patch</strong></span> в Unix
          иногда жалуется на <span class="quote">«<span class="quote">неудачные попытки</span>»</span>
          объединения, <span class="command"><strong>svn merge</strong></span> будет
          жаловаться на <span class="quote">«<span class="quote">пропущенные цели</span>»</span>:</p><pre class="screen">$ svn merge -r 1288:1351 http://svn.example.com/repos/branch
U  foo.c
U  bar.c
Skipped missing target: 'baz.c'
U  glub.c
C  glorb.h

$
</pre><p>Возможно, что в предыдущем примере файл
          <code class="filename">baz.c</code> существует в обоих сравниваемых
          снимках ветки и Subversion пытается применить результирующую
          дельту для того, чтобы изменить содержимое файла, однако в
          рабочей копии файл отсутствует. В любом случае сообщение
          <span class="quote">«<span class="quote">skipped</span>»</span> означает, что скорее всего пользователь
          ошибся при указании деревьев для сравнения — то есть это 
          классическая ошибка оператора. Если это так, проще 
          всего рекурсивно отменить все изменения, сделанные при слиянии 
          (<span class="command"><strong>svn revert --recursive</strong></span>), сразу же после 
          этого удалить все неверсионированные файлы и каталоги и 
          повторно запустить <span class="command"><strong>svn merge</strong></span> с 
          другими параметрами.</p><p>Обратите внимание на то, что в предыдущем примере
          в файле <code class="filename">glorb.h</code> возник конфликт.
          Откуда же он мог взяться, если ранее мы договорились, 
          что рабочая копия не имеет локальных изменений?
          Опять же, пользователь мог запустить <span class="command"><strong>svn
          merge</strong></span> для выделения и применения к рабочей копии
          какой то старой дельты. В результате такая дельта может
          содержать изменения, которые нельзя внедрить в рабочий
          файл без появления проблем, даже если он не имеет локальных
          изменений.</p><p>Еще одно небольшое отличие между <span class="command"><strong>svn
          update</strong></span> и <span class="command"><strong>svn merge</strong></span> заключается
          в названиях файлов, создаваемых при конфликтах.
          В разделе <a class="xref" href="#svn.tour.cycle.resolve" title="Разрешение конфликтов (при слиянии с чужими изменениями)">«Разрешение конфликтов (при слиянии с чужими 
        изменениями)»</a> мы
          говорили о том, что при обновлении создаются файлы с
          названиями <code class="filename">filename.mine</code>,
          <code class="filename">filename.rOLDREV</code> и
          <code class="filename">filename.rNEWREV</code>. А <span class="command"><strong>svn
          merge</strong></span> в конфликтной ситуации создает три файла
          с названиями <code class="filename">filename.working</code>,
          <code class="filename">filename.left</code> и
          <code class="filename">filename.right</code>. Термины 
          <span class="quote">«<span class="quote">left</span>»</span> и <span class="quote">«<span class="quote">right</span>»</span> указывают здесь
          на две стороны сравнения, то есть на используемые при
          сравнении деревья. Это разделение используемых названий
          поможет вам отличать конфликты, возникшие в результате
          обновления, от конфликтов, возникших в результате
          слияния.</p></div><div class="sect3" title="Учитывать или игнорировать происхождение"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.copychanges.bestprac.ancestry"></a>Учитывать или игнорировать происхождение</h4></div></div></div><p>Общаясь с разработчиками, использующими Subversion,
          очень часто можно услышать термин
          <em class="firstterm">происхождение</em>. Это слово используется
          для описания отношений между двумя объектами хранилища:
          если между ними есть связь, то говорят, что один объект
          происходит от другого.</p><p>Предположим, что фиксируется правка 100,
          в которой изменяется файл <code class="filename">foo.c</code>.
          В этом случае файл <code class="filename">foo.c@99</code> является предком
          файла <code class="filename">foo.c@100</code>. С другой стороны, можно
          допустить, что в правке 101 вы фиксируете удаление
          <code class="filename">foo.c</code>, а затем в правке 102 добавляете
          новый файл с таким же именем. В таком случае может показаться,
          что файлы <code class="filename">foo.c@99</code> и <code class="filename">foo.c@102</code>
          имеют отношение друг к другу (у них одинаковый путь), 
          однако на самом деле они являются
          полностью независимыми объектами хранилища. Они не имеют
          ни общей истории, ни общих <span class="quote">«<span class="quote">предков</span>»</span>.</p><p>Мы обращаем на это ваше внимание, чтобы
          указать на важные различия между <span class="command"><strong>svn diff</strong></span>
          и <span class="command"><strong>svn merge</strong></span>. Первая команда игнорирует
          происхождение, в то время как вторая его учитывает.
          Например, если попросить <span class="command"><strong>svn diff</strong></span> сравнить
          правки 99 и 102 файла <code class="filename">foo.c</code> вы увидите
          построчное сравнение; команда <code class="literal">diff</code> слепо сравнивает
          два пути. А вот если вы попросите <span class="command"><strong>svn merge</strong></span>
          сравнить те же объекты, то Subversion предупредит вас о том, что
          они не связаны друг с другом и сначала попытается удалить
          старый файл, а затем добавить новый; вывод команды покажет
          удаление с последующим добавлением:</p><pre class="screen">D  foo.c
A  foo.c
</pre><p>В большинстве случаев при слиянии сравниваются
          деревья, имеющие родственную связь и по умолчанию
          <span class="command"><strong>svn merge</strong></span> рассчитывает на это. Однако
          иногда вам будет нужно, чтобы команда <code class="literal">merge</code>
          сравнила два независимых дерева файлов. Например, вы могли 
          импортировать два дерева, содержащие исходный код
          релизов программных проектов сторонних поставщиков
          (см. <a class="xref" href="#svn.advanced.vendorbr" title="Vendor branches">«Vendor branches»</a>). Если попросить
          <span class="command"><strong>svn merge</strong></span> сравнить два эти дерева,
          вы увидите, что первое дерево будет полностью удалено,
          а затем будет полностью добавлено второе!</p><p>В подобных ситуациях нужно, чтобы команда
          <span class="command"><strong>svn merge</strong></span> выполняла сравнение, учитывая только 
          пути, и не обращала внимание на отношения между файлами
          и каталогами. Добавьте опцию <code class="option">--ignore-ancestry</code>
          при запуске команды слияния, после чего она будет
          вести себя аналогично <span class="command"><strong>svn diff</strong></span>. (И наоборот,
          опция <code class="option">--notice-ancestry</code> заставит
          <span class="command"><strong>svn diff</strong></span> работать подобно команде
          <code class="literal">merge</code>.)</p></div></div></div><div class="sect1" title="Типовые примеры"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.commonuses"></a>Типовые примеры</h2></div></div></div><p>Ветвлением и слиянием можно пользоваться по-разному. 
      В этом разделе описываются наиболее типичные примеры, 
      с которыми вам придется иметь дело.</p><div class="sect2" title="Полное объединение двух веток"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.wholebr"></a>Полное объединение двух веток</h3></div></div></div><p>Чтобы закончить с последним примером, заглянем немного
        вперед. Предположим, что прошло несколько дней. И в главную
        линию разработки, и вашу личную ветку за это время было внесено 
        множество изменений. Допустим, что работу над своей веткой вы 
        завершили. Новый функционал добавлен, ошибки исправлены, 
        и теперь вы хотите объединить все изменения из своей
        ветки с главной линией разработки.</p><p>Как применить в этом случае <span class="command"><strong>svn merge</strong></span>? 
        Помните о том, что эта команда сравнивает
        два дерева и применяет различия к рабочей копии. Следовательно,
        для того, чтобы было к чему применять изменения, необходимо
        иметь рабочую копию главной линии разработки. Будем считать,
        что такая, полностью обновленная копия у вас либо уже есть, 
        либо вы ее только что создали в каталоге
        <code class="filename">/calc/trunk</code>.</p><p>Но какие именно два дерева нужно сравнивать? На первый
        взгляд ответ очевиден: нужно сравнить последнее дерево главной
        линии разработки с последним деревом вашей ветки. Однако
        такое предположение будет <span class="emphasis"><em>ошибочным</em></span>.
        Это типичная ошибка большинства новичков! 
        Поскольку <span class="command"><strong>svn merge</strong></span> работает так же как и 
        <span class="command"><strong>svn diff</strong></span>,
        сравнение последней версии главной линии разработки и вашей ветки
        покажет изменения, сделанные <span class="emphasis"><em>не</em></span> только в вашей
        ветке. Такое сравнение покажет слишком много изменений. Оно выведет
        не только то, что добавлялось в вашей ветке,
        но и то, что <span class="emphasis"><em>удалялось</em></span> в главной линии
        разработки и не удалялось в вашей ветке.</p><p>Чтобы выделить только те изменения, которые были сделаны
        в вашей ветке, нужно сравнивать начальное и конечное состояния
        этой ветки. Посмотрев <span class="command"><strong>svn log</strong></span>,
        можно узнать, что ветка была создана в правке 341. В качестве
        конечного состояния ветки можно просто использовать правку
        <code class="literal">HEAD</code>. Это значит, что вам нужно сравнить
        правки 341 и <code class="literal">HEAD</code> каталога с веткой и применить
        различия к рабочей копии главной линии разработки.</p><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>Для определения правки, в которой была создана ветка
          (<span class="quote">«<span class="quote">базовой</span>»</span> правки ветки), удобно использовать 
          параметр <code class="option">--stop-on-copy</code> команды <span class="command"><strong>svn
          log</strong></span>. Обычно эта команда показывает все изменения,
          сделанные в ветке, включая те, которые были
          сделаны до создания ветки. Поэтому вы будете видеть и историю 
          главной линии разработки. Параметр
          <code class="option">--stop-on-copy</code> остановит вывод лог-сообщений,
          как только <span class="command"><strong>svn log</strong></span> обнаружит
          факт копирования или переименования целевого объекта.</p><pre class="screen">$ svn log --verbose --stop-on-copy \
          http://svn.example.com/repos/calc/branches/my-calc-branch
…
------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

$
</pre><p>Как и ожидалось, последней строчкой эта команда
          выведет ту правку, в которой в результате копирования был 
          создан каталог <code class="filename">my-calc-branch</code>.</p></td></tr></tbody></table></div><p>Теперь мы можем завершить объединение веток:</p><pre class="screen">$ cd calc/trunk
$ svn update
At revision 405.

$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn status
M   integer.c
M   button.c
M   Makefile

# ...examine the diffs, compile, test, etc...

$ svn commit -m "Merged my-calc-branch changes r341:405 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 406.
</pre><p>Еще раз обратите внимание на то, что в лог-сообщении
        фиксации очень точно указан диапазон правок, которые были
        объединены с главной линией разработки. Никогда не забывайте
        этого делать, потому что это очень важная информация, которая
        понадобиться вам позже.</p><p>Предположим, что на следующей неделе вы решили 
        продолжить работу над своей веткой, чтобы доработать новый 
        функционал или исправить еще несколько ошибок. Теперь правка
        <code class="literal">HEAD</code> хранилища имеет номер 480, и вы готовы
        еще раз объединить свою личную копию с главной линией
        разработки. Однако, как уже было сказано в разделе
        <a class="xref" href="#svn.branchmerge.copychanges.bestprac" title="Как правильнее всего использовать слияние">«Как правильнее всего использовать слияние»</a>, ранее
        объединенные изменения не стоит объединять повторно.
        Объединению подлежат только <span class="quote">«<span class="quote">новые</span>»</span> изменения,
        появившиеся с момента последнего объединения. Сложность заключается
        в том, чтобы выделить эти новые изменения.</p><p>Первым шагом будет запуск <span class="command"><strong>svn log</strong></span>
        для главной линии разработки, в результате чего мы узнаем
        время последнего объединения с веткой:</p><pre class="screen">$ cd calc/trunk
$ svn log
…
------------------------------------------------------------------------
r406 | user | 2004-02-08 11:17:26 -0600 (Sun, 08 Feb 2004) | 1 line

Merged my-calc-branch changes r341:405 into the trunk.
------------------------------------------------------------------------
…
</pre><p>Ага! Все изменения ветки, сделанные между
        правками 341 и 405, уже были объединены с главной линией разработки
        в правке 406. Поэтому сейчас нам нужно взять только 
        изменения, выполненные после этого. Для этого мы будем сравнивать
        правки 406 и <code class="literal">HEAD</code>.</p><pre class="screen">$ cd calc/trunk
$ svn update
At revision 480.

# We notice that HEAD is currently 480, so we use it to do the merge:

$ svn merge -r 406:480 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn commit -m "Merged my-calc-branch changes r406:480 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 481.
</pre><p>Теперь главная линия разработки полностью содержит вторую
        волну изменений, сделанных в ветке. Теперь можно
        либо удалить ветку (об этом мы поговорим позже), либо
        продолжить работу над ней, периодически повторяя при этом 
        процедуру объединения.</p></div><div class="sect2" title="Отмена изменений"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.undo"></a>Отмена изменений</h3></div></div></div><p>Еще одной типичной задачей для <span class="command"><strong>svn
        merge</strong></span> является откат ранее сделанных изменений. 
        Предположим, работая в копии <code class="filename">/calc/trunk</code>,
        вы вдруг выясняете, что изменения файла <code class="filename">integer.c</code>,
        сделанные в правке 303, были совершенно ошибочными. Вы можете
        воспользоваться командой <span class="command"><strong>svn merge</strong></span> для
        <span class="quote">«<span class="quote">отмены</span>»</span> изменений в своей рабочей копии,
        после чего зафиксировать локальные изменения в хранилище.
        Для этого нужно всего лишь указать различия в
        <span class="emphasis"><em>обратном порядке</em></span>:</p><pre class="screen">$ svn merge -r 303:302 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c

$ svn diff
…
# verify that the change is removed
…

$ svn commit -m "Undoing change committed in r303."
Sending        integer.c
Transmitting file data .
Committed revision 350.
</pre><p>Правку хранилища можно рассматривать как группу изменений 
        (некоторые системы управления версиями называют 
        это <em class="firstterm">набором изменений</em>).
        Используя параметр <code class="option">-r</code>, можно попросить
        <span class="command"><strong>svn merge</strong></span> применить к рабочей копии набор
        изменений или целый диапазон наборов изменений. В нашем примере
        с отменой изменений мы просим <span class="command"><strong>svn merge</strong></span>
        применить к рабочей копии набор изменений #303
        <span class="emphasis"><em>в обратном направлении</em></span>.</p><div class="sidebar" title="Subversion и наборы изменений"><div class="titlepage"><div><div><p class="title"><strong>Subversion и наборы изменений</strong></p></div></div></div><p>У каждого найдется свое собственное
          определение <span class="quote">«<span class="quote">набора изменений</span>»</span>, или по крайней 
          мере того, что должна уметь система
          управления версиями, <span class="quote">«<span class="quote">поддерживающая наборы
          изменений</span>»</span>. В нашем случае будем считать, что
          набор изменений — это просто изменения, объединенные неким
          уникальным именем. Изменения могут заключаться в редактировании
          текста файлов, модификации структуры файлов или корректировке
          метаданных. Проще говоря, набор изменений — это просто 
          патч, идентифицируемый некоторым именем.</p><p>В Subversion глобальный номер правки N относится к
          дереву в хранилище: так выглядит хранилище после
          фиксации N. Кроме того, это имя неявного набора
          изменений: если сравнить дерево N с деревом N-1 вы получите
          полный патч того, что было зафиксировано. В этом смысле,
          о <span class="quote">«<span class="quote">правке N</span>»</span> можно думать не как о дереве
          файлов, а как о наборе изменений. Если вы пользуетесь
          системой отслеживания релизов для управления ошибками,
          вы можете использовать номера правок для того, чтобы
          ссылаться на конкретные патчи, которые исправляют
          ошибку — например, <span class="quote">«<span class="quote">этот релиз был исправлен
          правкой 9238.</span>»</span>. Тогда, чтобы узнать набор изменений, 
          исправляющий заданную ошибку, можно выполнить
          <span class="command"><strong>svn log -r9238</strong></span>, а чтобы увидеть
          сам патч — запустить <span class="command"><strong>svn diff -r9237:9238</strong></span>.
          Команда <code class="literal">merge</code> тоже использует
          номера правок. Можно объединить набор изменений из одной ветки
          в другую, указав его в качестве аргумента:
          команда <span class="command"><strong>svn merge -r9237:9238</strong></span> внедрит
          набор изменений #9238 в вашу рабочую копию.</p></div><p>Обратите внимание, что подобный откат изменений 
        ничем не отличается от остальных операций, выполняемых  с
        помощью <span class="command"><strong>svn merge</strong></span>. Поэтому необходимо
        с помощью <span class="command"><strong>svn status</strong></span> и <span class="command"><strong>svn
        diff</strong></span> убедиться в том, что результат соответствует 
        ожиданиям, а затем, используя <span class="command"><strong>svn commit</strong></span>, 
        отправить финальную версию в хранилище. После фиксации 
        этот конкретный набор изменений больше не будет отражен 
        в правке <code class="literal">HEAD</code>.</p><p>Давайте, однако, подумаем: отменяется ли на самом деле 
        предыдущая фиксация? Изменения продолжают существовать
        в правке 303. И если кто-то создаст рабочую копию проекта
        <code class="filename">calc</code> между правками 303 и 349, он ведь 
        все равно получит ошибочные изменения?</p><p>Безусловно, это так. Говоря об <span class="quote">«<span class="quote">удалении</span>»</span>
        изменений, мы имеем в виду их удаление из правки <code class="literal">HEAD</code>.
        Исходные изменения по-прежнему останутся в истории
        хранилища. Чаще всего это можно рассматривать даже как 
        положительный момент. В любом случае, большинство пользователей 
        интересует только <code class="literal">HEAD</code>-правка проекта. 
        Однако, возможны ситуации, когда необходимо полностью удалить 
        последствия фиксации. (Например, если кто-то случайно зафиксировал
        конфиденциальный документ.) Сделать это будет непросто, так как
        архитектура Subversion намеренно исключает возможность потери 
        информации. Правки представляют собой не меняющиеся
        деревья файлов, основанные друг на друге. Удаление правки из
        хранилища может вызвать эффект домино, потащив за собой все
        последующие правки и повредив все рабочие копии.
        <sup>[<a id="idp11351408" href="#ftn.idp11351408" class="footnote">26</a>]</sup></p></div><div class="sect2" title="Восстановление удаленных элементов"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.resurrect"></a>Восстановление удаленных элементов</h3></div></div></div><p>Отличным свойством системы управления версиями является то,
        что информация никогда не теряется. При удалении файла
        или каталога элемент исключается из правки <code class="literal">HEAD</code>,
        но продолжает существовать в более ранних правках. Новые пользователи
        очень часто спрашивают: <span class="quote">«<span class="quote">Как мне вернуть назад свой файл или
        каталог?</span>»</span></p><p>Для начала было бы неплохо определиться, <span class="bold"><strong>какой именно</strong></span> элемент мы пытаемся
        восстановить. Для этого полезно представить все объекты 
        хранилища как точки в двумерной системе координат. 
        Первой координатой будет отдельное дерево правок,
        в второй — путь в этом дереве. Таким образом,
        каждая версия файла или каталога может быть задана
        парой координат.</p><p>В отличие от CVS, Subversion не имеет каталога
        <code class="filename">Attic</code><sup>[<a id="idp11363232" href="#ftn.idp11363232" class="footnote">27</a>]</sup>,
        поэтому для определения искомой пары координат восстанавливаемого
        объекта нужно вызвать <span class="command"><strong>svn log</strong></span>. 
        Лучше всего запустить <span class="command"><strong>svn log
        --verbose</strong></span> в каталоге, который содержал
        удаленный объект. Параметр <code class="option">--verbose</code>
        покажет для каждой правки список измененных элементов —
        в этом случае вам останется только найти ту правку, в которой
        файл или каталог были удалены. Это можно сделать
        визуально или обработав вывод команды каким-нибудь
        инструментом (например, утилитой <span class="command"><strong>grep</strong></span> или 
        просто запустив поиск в редакторе).</p><pre class="screen">$ cd parent-dir
$ svn log --verbose
…
------------------------------------------------------------------------
r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines
Changed paths:
   D /calc/trunk/real.c
   M /calc/trunk/integer.c

Added fast fourier transform functions to integer.c.
Removed real.c because code now in double.c.
…
</pre><p>В этом примере предполагается, что вы ищете удаленный файл
        <code class="filename">real.c</code>. Просмотрев логи родительского
        каталога, вы можете заметить, что этот файл был удален в правке
        808. Следовательно, самая последняя версия этого файла
        была в правке, предшествующей удалению. Вывод: необходимо из
        правки 807 восстановить путь
        <code class="filename">/calc/trunk/real.c</code>.</p><p>Поиск — непростая задача. Теперь, когда нам известно, 
        что именно нужно восстановить, есть две варианта действий.</p><p>Во-первых, мы можем посредством <span class="command"><strong>svn merge</strong></span> 
        применить правку 808 <span class="quote">«<span class="quote">в обратном
        направлении</span>»</span>. (Как отменять изменения, мы уже рассматривали,
        см. <a class="xref" href="#svn.branchmerge.commonuses.undo" title="Отмена изменений">«Отмена изменений»</a>.) Это
        приведет к повторному добавлению файла
        <code class="filename">real.c</code> в форме локального изменения.
        Файл будет запланирован для добавления, и после фиксации
        будет снова присутствовать в <code class="literal">HEAD</code>.</p><p>Однако, в данном примере это не самое лучшее
        решение. Повторное применение правки 808 не только добавит
        файл <code class="filename">real.c</code>. Лог-сообщение показывает, что также
        будут отменены некоторые изменения в <code class="filename">integer.c</code>,
        что весьма нежелательно. Конечно, можно выполнить обратное слияние 
        с правкой 808, а затем отменить (<span class="command"><strong>svn revert</strong></span>)
        локальные изменения в <code class="filename">integer.c</code>, но такой
        подход плохо масштабируется. Что, если в правке 808 изменилось
        90 файлов?</p><p>При другом, более аккуратном подходе <span class="command"><strong>svn merge</strong></span>
        вообще не используется, а вместо этого применяется команда
        <span class="command"><strong>svn copy</strong></span>. Просто скопируйте объект, заданный 
        <span class="quote">«<span class="quote">парой координат</span>»</span> (правка и путь), из хранилища в
        рабочую копию:</p><pre class="screen">$ svn copy --revision 807 \
           http://svn.example.com/repos/calc/trunk/real.c ./real.c

$ svn status
A  +   real.c

$ svn commit -m "Resurrected real.c from revision 807, /calc/trunk/real.c."
Adding         real.c
Transmitting file data .
Committed revision 1390.
</pre><p>Знак "плюс" в столбце статуса показывает, что 
        элемент не просто запланирован для добавления, а запланирован 
        для добавления <span class="quote">«<span class="quote">с историей</span>»</span>. Subversion запоминает, 
        откуда он был скопирован. В будущем вызов <span class="command"><strong>svn log</strong></span> 
        для этого файла будет пересекать точку восстановления файла и 
        прослеживать всю историю, предшествующую правке 807. Другими словами, 
        новый файл <code class="filename">real.c</code> на самом деле не является новым;
        он является прямым потомком исходного файла, который был удален.</p><p>Хотя наш пример демонстрирует только восстановление файла,
        отметим, что такой же подход будет работать и при 
        восстановлении удаленных каталогов.</p></div><div class="sect2" title="Типовые приемы использования веток"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.commonuses.patterns"></a>Типовые приемы использования веток</h3></div></div></div><p>Управление версиями чаще всего используется при
        разработке программного обеспечения, поэтому здесь мы
        вкратце рассмотрим два наиболее часто используемых командами
        программистов приема ветвления/слияния. Если вы не используете
        Subversion для разработки программного обеспечения, можете
        пропустить этот раздел. Если вы — разработчик программного
        обеспечения, впервые использующий контроль версий, уделите этому
        разделу пристальное внимание, поскольку опытные разработчики 
        считают использование данных приемов хорошим стилем. 
        Такие приемы не являются специфичными для Subversion; 
        они применимы к любой системе управления версиями. 
        Однако, здесь мы взглянем на них с позиций Subversion.</p><div class="sect3" title="Ветки релизов"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.commonuses.patterns.release"></a>Ветки релизов</h4></div></div></div><p>Большинство программного обеспечения имеет типовой
          жизненный цикл: написание кода, тестирование, выпуск,
          повторный цикл. При таком подходе возникают две проблемы.
          Во-первых, разработчикам необходимо продолжать расширять
          функциональность в то время, как группа проверки качества
          будет заниматься тестированием предположительно стабильных
          версий программы. Во время тестирования не должна останавливаться
          разработка. Во-вторых, как правило, требуется поддерживать старые,
          уже выпущенные версии программы; если найдена ошибка в
          последней версии кода, то скорее всего она присутствует и в уже
          выпущенных версиях, поэтому пользователи захотят, чтобы
          эта ошибка была исправлена не дожидаясь выхода новой версии
          программы.</p><p>Здесь-то и может помочь контроль версий. Типичная процедура
          выглядит примерно так:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>Разработчики фиксируют все новое в главную
                линию разработки.</em></span>

              Каждодневные изменения фиксируются в
              <code class="filename">/trunk</code>: новая функциональность,
              исправление ошибок и тому подобное.</p></li><li class="listitem"><p><span class="emphasis"><em>Главная линия разработки копируется в ветку
                <span class="quote">«<span class="quote">релиза</span>»</span>.</em></span>

              Когда команда разработчиков решает, что программа готова
              к выпуску (скажем, к релизу 1.0), тогда
              <code class="filename">/trunk</code> копируется, например, в
              <code class="filename">/branches/1.0</code>.</p></li><li class="listitem"><p><span class="emphasis"><em>Группы продолжают работать параллельно.</em></span>

              Одна группа начинает всестороннее тестирование ветки релиза,
              в то время как вторая группа продолжает работу (скажем, над
              версией 2.0) в <code class="filename">/trunk</code>. Если находятся
              ошибки в какой-либо из версий, исправления портируются по
              необходимости в одну или другую сторону. В какой-то момент этот
              процесс останавливается. Ветка <span class="quote">«<span class="quote">замораживается</span>»</span>
              для окончательной проверки перед релизом.</p></li><li class="listitem"><p><span class="emphasis"><em>На основе ветки создается метка и выпускается
            релиз.</em></span>

              Когда тестирование завершено,
              <code class="filename">/branches/1.0</code> копируется в
              <code class="filename">/tags/1.0.0</code> как справочный снимок.
              Метка запаковывается и отправляется пользователям.</p></li><li class="listitem"><p><span class="emphasis"><em>Ветка продолжает поддерживаться</em></span>.

              По мере продвижения работы над <code class="filename">/trunk</code>
              для версии 2.0, исправления ошибок продолжают портироваться
              из <code class="filename">/trunk</code> в
              <code class="filename">/branches/1.0</code>. Когда будет накоплено
              определенной количество исправлений, руководство может решить
              сделать релиз 1.0.1: <code class="filename">/branches/1.0</code>
              копируется  в <code class="filename">/tags/1.0.1</code>, метка
              пакуется и выпускается.</p></li></ul></div><p>По мере развития программы эти этапы повторяются:
          когда работа над 2.0 будет завершена, создается новая ветка
          релиза 2.0, тестируется, создается метка и в последствии
          выпускается релиз. После нескольких лет в хранилище будет
          находиться определенное количество веток релизов, находящихся
          в режиме <span class="quote">«<span class="quote">сопровождения</span>»</span> и определенное количество
          меток, отражающих последние выпущенные ветки.</p></div><div class="sect3" title="Функциональные ветки"><div class="titlepage"><div><div><h4 class="title"><a id="svn.branchmerge.commonuses.patterns.feature"></a>Функциональные ветки</h4></div></div></div><p><em class="firstterm">Функциональная ветка</em> является
          доминирующим примером в этой главе, над такой веткой вы работаете
          пока Салли работает над <code class="filename">/trunk</code>. Это временная
          ветка, которая создается для работы над комплексным изменением
          без пересечения со стабильной линией разработки
          <code class="filename">/trunk</code>. В отличие от веток релизов
          (которые могут поддерживаться вечно), функциональные ветки
          создаются, используются, внедряются обратно в главную линию
          разработки, после чего полностью удаляются. Они имеют ограниченный
          срок использования.</p><p>Опять же, правила проекта относительно определения момента,
          когда требуется создание функциональной ветки могут быть разными.
          Некоторые проекты вообще никогда не используют функциональные ветки:
          все фиксируется в <code class="filename">/trunk</code>. Преимущества такой
          системы в ее простоте — никому не нужно учиться делать
          ветки или объединения. Недостатком является то, что главная линия
          разработки часто не стабильна или не пригодна к использованию.
          В других проектах ветки используют по-другому:
          <span class="emphasis"><em>ни одного</em></span> изменения не фиксируют в главной
          линии разработки напрямую. Даже для самых простых изменений
          создается краткосрочная ветка, внимательно анализируется и
          объединяется с главной линией. После чего ветка удаляется. Ценой
          огромных накладных расходов, такая система гарантирует
          исключительную стабильность и пригодность к использованию главной
          линии разработки в любой момент времени.</p><p>Большинство проектов использует что-то среднее. Как правило,
          все время контролируя, что <code class="filename">/trunk</code>
          компилируется и проходит регрессивные тесты. Функциональная ветка
          требуется только тогда, когда изменение требует большого количества
          дестабилизирующих фиксаций. Хорошим способом проверки является
          постановка такого вопроса: если разработчик работал несколько
          дней изолировано, а затем за один раз зафиксировал большое
          изменение (притом, что <code class="filename">/trunk</code> не будет
          дестабилизирован) будет ли сложно отследить это изменение? Если
          ответ на этот вопрос <span class="quote">«<span class="quote">да</span>»</span>, то тогда изменение должно
          разрабатываться в функциональной ветке. По мере того, как
          разработчик последовательно фиксирует изменения в ветку, они могут
          легко отслеживаться другими участниками.</p><p>Напоследок, рекомендация, как по ходу работы лучше всего
          сохранять функциональную ветку <span class="quote">«<span class="quote">синхронизированной</span>»</span> с
          главной линией разработки. Как мы уже говорили, рискованно работать
          над веткой в течение недель или месяцев; изменения в главной линии
          будут продолжаться, и настанет момента, когда две линии разработки
          станут отличаться так сильно, что  попытка объединить ветку обратно
          с главной линией разработки может стать ночным кошмаром.</p><p>Этой ситуации не возникнет, если регулярно объединять ветку с
          изменениями в главной линии. Возьмите за правило один раз в неделю
          объединять с веткой значимые изменения в главной линии разработки за
          прошедшую неделю. Делайте это аккуратно; за объединением необходим
          ручной контроль для того, что бы исключить проблему повторных
          объединений (как это описано в разделе <a class="xref" href="#svn.branchmerge.copychanges.bestprac.track" title="Ручной контроль слияния">«Ручной контроль слияния»</a>). Необходимо
          внимательно записывать лог сообщение, указывая какой именно
          диапазон правок был объединен (как показано в разделе <a class="xref" href="#svn.branchmerge.commonuses.wholebr" title="Полное объединение двух веток">«Полное объединение двух веток»</a>). Возможно это
          звучит устрашающе, но на самом деле это сделать очень
          легко.</p><p>Начиная с какого-то момента вы будете готовы объединить
          <span class="quote">«<span class="quote">синхронизированную</span>»</span> функциональную ветку с главной
          линией разработки. Для этого начните с завершающего объединения
          последних изменений из главной линии разработки с веткой. После
          чего, последняя версия ветки и главной линии будут абсолютно
          идентичны, за исключением ваших изменений в ветке. Теперь
          объединение заключается в сравнении ветки с главной линией
          разработки:</p><pre class="screen">$ cd trunk-working-copy

$ svn update
At revision 1910.

$ svn merge http://svn.example.com/repos/calc/trunk@1910 \
            http://svn.example.com/repos/calc/branches/mybranch@1910
U  real.c
U  integer.c
A  newdirectory
A  newdirectory/newfile
…
</pre><p>Сравнивая правку <code class="literal">HEAD</code> главной линии
          разработки и правку <code class="literal">HEAD</code> ветки, определяется
          дельта, которая представляет собой только изменения сделанные в
          ветке; обе линии разработки уже содержат все изменения из
          главной линии.</p><p>Другим способом представления этого приема является то, что
          еженедельная синхронизация ветки аналогична запуску <span class="command"><strong>svn
          update</strong></span> в рабочей копии, в то время как окончательное
          объединение аналогично запуску из рабочей копии <span class="command"><strong>svn
          commit</strong></span>. В конце концов, <span class="emphasis"><em>что же
          такое</em></span> рабочая копия если не миниатюрная личная ветка?
          Это такая ветка, которая способна хранить одно изменение
          в каждый момент времени.</p></div></div></div><div class="sect1" title="Переключение рабочей копии"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.switchwc"></a>Переключение рабочей копии</h2></div></div></div><p>Команда <span class="command"><strong>svn switch</strong></span> трансформирует
      существующую рабочую копию в другую ветку. Несмотря на то, что
      при работе с ветками эта команда не является крайне необходимой,
      она значительно облегчает жизнь пользователям. В ранее приведенном
      примере, после создания личной ветки вы создавали новую рабочую
      копию созданной директории хранилища. Вместо этого, можно
      попросить Subversion изменить рабочую копию
      <code class="filename">/calc/trunk</code> так, что бы она отражала
      созданную ветку:</p><pre class="screen">$ cd calc

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/trunk

$ svn switch http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile
Updated to revision 341.

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/branches/my-calc-branch
</pre><p>После <span class="quote">«<span class="quote">переключения</span>»</span> на ветку, рабочая копия
      не будет отличаться от той которая получилась бы при создании
      новой рабочей копии директории хранилища. Как правило, более
      эффективно использовать эту команду, так как обычно у ветки
      немного отличий. Сервер отправляет минимально необходимый для
      того, что бы рабочая копия отражала директорию ветки, набор
      изменений.</p><p>Команда <span class="command"><strong>svn switch</strong></span> принимает параметр
      <code class="option">--revision</code> (<code class="option">-r</code>), по-этому
      необязательно помещать рабочую копию на самую
      <span class="quote">«<span class="quote">верхушку</span>»</span> ветки.</p><p>Конечно, большинство проектов, по сравнению с нашим примером
      <code class="filename">calc</code> более сложны, содержат множество
      поддиректорий. Обычно пользователи Subversion используют
      специальный алгоритм для работы с ветками:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Скопировать всю директорию <span class="quote">«<span class="quote">trunk</span>»</span> в
            директорию новой ветки.</p></li><li class="listitem"><p>Переключить <span class="emphasis"><em>часть</em></span> главной линии
            разработки на ветку.</p></li></ol></div><p>Другими словами, если пользователь знает, что работа над веткой
      будет проходить в конкретной директории, он может, с помощью,
      <span class="command"><strong>svn switch</strong></span> переключить на ветку только эту
      поддиректорию. (А иногда на ветку переключается только один
      рабочий файл!) В этом случае пользователи могут продолжать
      обычным образом получать обновления <span class="quote">«<span class="quote">trunk</span>»</span> для
      большей части рабочей копии, а переключенные части будут оставаться
      нетронутыми (до тех пор, пока кто-то не изменит этой ветки).
      Эта возможность добавляет совершенно новое измерение в понятие
      <span class="quote">«<span class="quote">смешанная рабочая копия</span>»</span> — рабочая копия может
      содержать не только смесь рабочих правок но и смесь местоположений
      в хранилище.</p><p>Если рабочая копия содержит какое-то количество переключенных
      на разные местоположения в хранилище поддиректорий, она будет
      продолжать нормально функционировать. При обновлении, патчи
      соответственно будут приниматься для каждой поддиректории.
      При фиксации, локальные модификации будут приниматься в хранилище
      в виде единого, атомарного изменения.</p><p>Обратите внимание, на то, что хотя и иметь в рабочей копии
      смесь местоположений в хранилище является нормальным, все эти
      местоположения должны быть из <span class="emphasis"><em>одного</em></span>
      хранилища. Хранилища Subversion пока не могут сообщаться друг с
      другом; реализация этой возможности запланирована после Subversion
      1.0.<sup>[<a id="idp11497472" href="#ftn.idp11497472" class="footnote">28</a>]</sup></p><div class="sidebar" title="Переключения и обновления"><div class="titlepage"><div><div><p class="title"><strong>Переключения и обновления</strong></p></div></div></div><p>Вы не обратили внимания на то, что вывод <span class="command"><strong>svn
        switch</strong></span> и <span class="command"><strong>svn update</strong></span> выглядит
        одинаково? На самом деле команда <code class="literal">switch</code>
	является расширенным вариантом команды обновления.</p><p>При запуске <span class="command"><strong>svn update</strong></span> вы просите
        хранилище сравнить два дерева. Хранилище выполняет это
        и отправляет описания изменений обратно клиенту. Отличие
        между <span class="command"><strong>svn switch</strong></span> и <span class="command"><strong>svn
        update</strong></span> только в том, что команда <code class="literal">update</code>
        всегда сравнивает два одинаковых пути.</p><p>То есть, рабочая копия отражает <code class="filename">/calc/trunk</code>,
        то <span class="command"><strong>svn update</strong></span> будет автоматически сравнивать
        рабочую копию <code class="filename">/calc/trunk</code> с правкой
         <code class="literal">HEAD</code> <code class="filename">/calc/trunk</code>.
         Если вы переключаете рабочую копию на ветку, то <span class="command"><strong>svn
         switch</strong></span> будет сравнивать рабочую копию
         <code class="filename">/calc/trunk</code> с какой-то
         <span class="emphasis"><em>другой</em></span> директорией в правке
         <code class="literal">HEAD</code>.</p><p>Другими словами, обновление переносит рабочую копию сквозь
        время. А переключение переносит рабочую копию сквозь время
        <span class="emphasis"><em>и</em></span> пространство.</p></div><p>Учитывая то, что <span class="command"><strong>svn switch</strong></span> в сущности
      является разновидностью <span class="command"><strong>svn update</strong></span> их поведение
      схоже; при получении новой информации из хранилища, все локальные
      изменения сохраняются. Это позволяет использовать разнообразные
      трюки.</p><p>Предположим вы внесли некоторые изменения в имеющуюся у вас
      рабочую копию <code class="filename">/calc/trunk</code>. После чего неожиданно
      обнаружили, что вместо этого вам необходимо внести изменения в ветку.
      Нет проблем! Когда вы переключите (<span class="command"><strong>svn switch</strong></span>)
      рабочую копию на ветку, локальные изменения сохраняться. После чего
      их можно проверить и зафиксировать в ветке.</p></div><div class="sect1" title="Метки"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.tags"></a>Метки</h2></div></div></div><p>Еще одним понятием, свойственным управлению версиями является
      <em class="firstterm">метка</em>. Метка является просто
      <span class="quote">«<span class="quote">снимком</span>»</span> проекта в определенный момент времени.
      В Subversion эта идея уже, кажется, повсюду. Каждая правка хранилища
      является именно этим — снимком файловой системы после каждой
      фиксации.</p><p>Как правило, люди предпочитают давать меткам удобочитаемые имена,
      наподобие <code class="literal">release-1.0</code>. И делать снимки небольших
      поддиректорий файловой системы. Проще говоря, не просто запомнить, что
      версия 1.0 программы соответствует поддиректории в правке 4822.</p><div class="sect2" title="Создание простой метки"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.tags.mksimple"></a>Создание простой метки</h3></div></div></div><p>И снова приходит на помощь <span class="command"><strong>svn copy</strong></span>.
        Если вам нужно сделать снимок <code class="filename">/calc/trunk</code>
        в точно таком виде как в правке <code class="literal">HEAD</code>,
        сделайте копию этой директории:</p><pre class="screen">$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/tags/release-1.0 \
      -m "Tagging the 1.0 release of the 'calc' project."

Committed revision 351.
</pre><p>В этом примере предполагается, что директория
        <code class="filename">/calc/tags</code> существует. (Если нет,
        обратитесь к <a class="xref" href="#svn.ref.svn.c.mkdir" title="svn mkdir">svn mkdir</a>).
        После того как сделана копия, новая директория
        <code class="filename">release-1.0</code> навсегда сохранит состояние
        проекта в таком виде в каком он существовал в правке
        <code class="literal">HEAD</code> на момент создания копии. Конечно,
        можно более точно указать какую именно правку копировать,
        возможна ситуация, когда кто-то другой зафиксировал изменения в
        проекте с которыми вы еще не успели познакомиться. Поэтому,
        если вы знаете, что правка 350 <code class="filename">/calc/trunk</code>
        это именно тот снимок который вам нужен, можете указать ее
        передав <code class="option">-r 350</code> команде <span class="command"><strong>svn
        copy</strong></span>.</p><p>Постойте: ведь процедура создания метки такая же как процедура
        использованная нами при создании ветки? Да, фактически, это так.
        Subversion не разделяет ветки и метки. И то и другое является
        обычными директориями, созданными копированием. Как и в случае с
        ветками, скопированная директория становиться <span class="quote">«<span class="quote">меткой</span>»</span>
        только потому, что <span class="emphasis"><em>человек</em></span> считает
        ее таковой: если никто не делает фиксаций в эту директорию она
        будет оставаться снимком. Если в эту директорию начнут делать
        фиксации она превратится в ветку.</p><p>Если вы администрируете хранилище, есть два возможных подхода
        управления метками. Первый подход <span class="quote">«<span class="quote">ручной</span>»</span>: в
        соответствии с правилами проекта решите, где будут находиться
        метки и убедитесь в том, что все пользователи знают как рассматривать
        директории скопированные сюда. (То есть убедитесь, что они знают о
        том что в них нельзя выполнять фиксации.) Второй подход более
        параноидальный: вы можете воспользоваться одним из скриптов для
        контроля доступа, поставляемым с Subversion для того, что бы никто
        ничего другого кроме создания копий в области для создания меток
        сделать не мог. (См. <a class="xref" href="#svn.serverconfig" title="Глава 6. Настройка сервера">Глава&nbsp;6, <em>Настройка сервера</em></a>.) Однако
        обычно в параноидальном подходе необходимости нет. Если пользователь
        непреднамеренно зафиксирует изменения в директорию с меткой,
        вы можете просто отменить изменения, как это было рассмотрено в
        предыдущем разделе. Как ни как, это управление версиями.</p></div><div class="sect2" title="Создание комплексной метки"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.tags.mkcomplex"></a>Создание комплексной метки</h3></div></div></div><p>Иногда вам будет необходим более сложный <span class="quote">«<span class="quote">снимок</span>»</span>,
        чем одна единственная директория в одной правке.</p><p>Например, представим, что ваш проект гораздо больше, чем
        наш пример <code class="filename">calc</code>: допустим он содержит
        несколько поддиректорий и намного больше файлов. В процессе
        работы вам может понадобиться создать рабочую копию, содержащую
        конкретную функциональность и исправленные ошибки. Добиться этого
        вы можете выборочно возвращая файлы или директории к конкретной
        правке (используя <span class="command"><strong>svn update -r</strong></span> по мере
        необходимости) или переключая файлы или директории на отдельные
        ветки (применяя <span class="command"><strong>svn switch</strong></span>). По завершении
        рабочаяя копия будет представлять собой мешанину различных
        директорий и правок хранилища. После проверки вы поймете, что
        вам нужна именно такая комбинация.</p><p>Время создавать снимок. Копирование одного URL в другой
        здесь не пройдет. Здесь нужно сделать и сохранить в хранилище снимок
        именно такой структуры которую имеет рабочая копия. К счастью,
        <span class="command"><strong>svn copy</strong></span> имеет четыре способа использования
        (о которых вы можете прочитать в <a class="xref" href="#svn.ref" title="Глава 9. Полное справочное руководство по Subversion">Глава&nbsp;9, <em>Полное справочное руководство по Subversion</em></a>),
        включая возможность копировать в хранилище дерево рабочей копии:</p><pre class="screen">$ ls
my-working-copy/

$ svn copy my-working-copy http://svn.example.com/repos/calc/tags/mytag

Committed revision 352.
</pre><p>Теперь в хранилище есть новая директория
      <code class="filename">/calc/tags/mytag</code> которая является полным отражением
        рабочей копии — смешанные правки, URL, и тому подобное.</p><p>Некоторые пользователи находят интересное применение этой
        возможности. Иногда возникают ситуации, когда в вашей рабочей копии
        содержится некоторый набор локальных изменений, которые вы хотели бы
        показать соразработчику. Вместо запуска <span class="command"><strong>svn diff</strong></span>
        и отправки патч-файла (который не сможет отразить изменения в
        структуре файлов, измененные символьные ссылки или свойства),
        можно воспользоваться <span class="command"><strong>svn copy</strong></span> для
        <span class="quote">«<span class="quote">загрузки</span>»</span> рабочей копии в отдельную область хранилища.
        После чего ваш соразработчик сможет либо воссоздать у себя вашу
        рабочую копию, либо, воспользовавшись <span class="command"><strong>svn
        merge</strong></span>, получить только внесенные вами изменения.</p></div></div><div class="sect1" title="Поддержка веток"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.maint"></a>Поддержка веток</h2></div></div></div><p>Сейчас вы уже понимаете, что Subversion очень гибкая система.
      Учитывая то, что ветки и метки имеют одну и ту же основу (копии
      директорий), а также то, что ветки и метки являются обычными элементами
      файловой системы, Subversion многих пугает. Она
      <span class="emphasis"><em>слишком</em></span> гибкая. В этом разделе мы предложим
      несколько советов по компоновке и поддержке информации с течением
      времени.</p><div class="sect2" title="Структура хранилища"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.maint.layout"></a>Структура хранилища</h3></div></div></div><p>Существует несколько стандартных, рекомендуемых способов
        организации хранилища. Как правило, создается директория
        <code class="filename">trunk</code>, в которой находится
        <span class="quote">«<span class="quote">главная линия</span>»</span> разработки, директория
        <code class="filename">branches</code> для хранения веток и директория
        <code class="filename">tags</code> для хранения меток. Если хранилище
        содержит только один проект, обычно создают три директории
        верхнего уровня:</p><pre class="screen">/trunk
/branches
/tags
</pre><p>Если хранилище содержит несколько проектов, администратор,
        обычно создает такую структуру для каждого проекта отдельно
        (за более подробной информацией о <span class="quote">«<span class="quote">корне проекта</span>»</span>
        обратитесь в раздел <a class="xref" href="#svn.reposadmin.projects.chooselayout" title="Choosing a Repository Layout">«Choosing a Repository Layout»</a>):</p><pre class="screen">/paint/trunk
/paint/branches
/paint/tags
/calc/trunk
/calc/branches
/calc/tags
</pre><p>Конечно, вы можете не использовать такие типовые структуры.
        Вы можете сделать любую разновидность, которая будет удобна для вас
        или вашей команды. Помните о том, какой бы вы выбор не сделали,
        он может быть не окончательным. Хранилище можно реорганизовать в
        любое время. Учитывая то, что ветки и метки являются обычными
        директориями, команда <span class="command"><strong>svn move</strong></span> может переместить
        или переименовать их по вашему усмотрению. Переход от одной структуры
        к другой означает просто несколько последовательных передвижек
        на сервере; если организация хранилища вам не нравится, просто
        поменяйте местами директории.</p><p>Однако не забывайте о том, что несмотря на легкость перемещения
        директорий, нужно помнить и о других пользователях. Ваши перестановки
        могут дезориентировать пользователей с существующими рабочими копиями.
        Если у пользователя есть рабочая копия отдельной директории хранилища,
        то ваше использование <span class="command"><strong>svn move</strong></span> может удалить этот
        путь из последней правки. Когда в очередной раз пользователь запустит
        <span class="command"><strong>svn update</strong></span>, он будет проинформирован о том, что
        его рабочая копия отражает путь, который больше не существует,
        и пользователь будет вынужден переключиться (<span class="command"><strong>svn
        switch</strong></span>) на новое местоположение.</p></div><div class="sect2" title="Продолжительность жизни информации"><div class="titlepage"><div><div><h3 class="title"><a id="svn.branchmerge.maint.lifetime"></a>Продолжительность жизни информации</h3></div></div></div><p>Еще одним замечательным свойством модели Subversion
        является то, что ветки и метки могут иметь конечную
        продолжительность жизни, так же как и все другие версионированные
        элементы. Например, предположим вы наконец закончили все работы
        в ваше личной ветке проекта <code class="filename">calc</code>. После
        объединения изменений с  <code class="filename">/calc/trunk</code>,
        нет причин продолжать хранить эту ветку:</p><pre class="screen">$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
             -m "Removing obsolete branch of calc project."

Committed revision 375.
</pre><p>Больше вашей ветки не существует. Конечно, на самом деле она
        не исчезла: просто ее больше нет в правке <code class="literal">HEAD</code>,
        она больше никого не отвлекает. Если воспользоваться командами
        <span class="command"><strong>svn checkout</strong></span>, <span class="command"><strong>svn switch</strong></span>
        или <span class="command"><strong>svn list</strong></span> для обращения к ранним правкам,
        свою старую ветку вы увидите.</p><p>Если просмотра удаленной директории не достаточно, вы всегда
        можете восстановить эту директорию. Восстановление информации в
        Subversion выполнить очень просто. Если есть директория или файл,
        который вы хотите вернуть обратно в <code class="literal">HEAD</code>,
        просто воспользуйтесь <span class="command"><strong>svn copy -r</strong></span> для того,
        что бы скопировать его из старой правки:</p><pre class="screen">$ svn copy -r 374 http://svn.example.com/repos/calc/branches/my-calc-branch \
                  http://svn.example.com/repos/calc/branches/my-calc-branch

Committed revision 376.
</pre><p>В нашем примере ваша личная ветка имеет относительно
        короткую продолжительность жизни: возможно она создавалась
        для того, что бы исправить ошибку или реализовать новую функцию.
        После того, как работа завершена, завершена и ветка. При разработке
        программного обеспечения, тем не менее, часто имеют две
        <span class="quote">«<span class="quote">главных</span>»</span> ветки, существующих рядом довольно долгое
        время. Допустим, пришло время выпустить релиз стабильной версии
        проекта <code class="filename">calc</code>, а вы знаете, что нужна будет пара
        месяцев для того, что бы вытрясти из программы последние ошибки.
        Разработчики не должны добавлять в проект новых функции, но при этом
        и работа не должна останавливаться. В подобной ситуации создается
        <span class="quote">«<span class="quote">стабильная</span>»</span> ветка программы, которая существенно
        изменяться уже не будет:</p><pre class="screen">$ svn copy http://svn.example.com/repos/calc/trunk \
         http://svn.example.com/repos/calc/branches/stable-1.0 \
         -m "Creating stable branch of calc project."

Committed revision 377.
</pre><p>После этого, разработчикам ничего не мешает продолжать добавлять
        в <code class="filename">/calc/trunk</code> новые передовые (или экспериментальные)
        функции, а в правилах проекта можно указать, что в
        <code class="filename">/calc/branches/stable-1.0</code> должны фиксироваться
        только исправления ошибок. По мере того, как будет продвигаться
        работа над главной линией разработки, исправленные ошибки будут
        выборочно портироваться в стабильную ветку. Даже после выхода релиза
        стабильной ветки, она может продолжать поддерживаться долгое время
        — столько, сколько этот релиз будет продолжать поддерживаться
        для пользователей.</p></div></div><div class="sect1" title="Vendor branches"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.vendorbr"></a>Vendor branches</h2></div></div></div><p>As is especially the case when developing software, the data
      that you maintain under version control is often closely related
      to, or perhaps dependent upon, someone else's data.  Generally,
      the needs of your project will dictate that you stay as
      up-to-date as possible with the data provided by that external
      entity without sacrificing the stability of your own project.
      This scenario plays itself out all the time—anywhere that
      the information generated by one group of people has a direct
      effect on that which is generated by another group.</p><p>For example, software developers might be working on an
      application which makes use of a third-party library.
      Subversion has just such a relationship with the Apache Portable
      Runtime library (see <a class="xref" href="#svn.developer.usingapi.apr" title="The Apache Portable Runtime Library">«The Apache Portable Runtime Library»</a>).  The
      Subversion source code depends on the APR library for all its
      portability needs.  In earlier stages of Subversion's
      development, the project closely tracked APR's changing API,
      always sticking to the <span class="quote">«<span class="quote">bleeding edge</span>»</span> of the
      library's code churn.  Now that both APR and Subversion have
      matured, Subversion attempts to synchronize with APR's library
      API only at well-tested, stable release points.</p><p>Now, if your project depends on someone else's information,
      there are several ways that you could attempt to synchronize that
      information with your own.  Most painfully, you could issue oral
      or written instructions to all the contributors of your project,
      telling them to make sure that they have the specific versions
      of that third-party information that your project needs.  If the
      third-party information is maintained in a Subversion
      repository, you could also use Subversion's externals
      definitions to effectively <span class="quote">«<span class="quote">pin down</span>»</span> specific
      versions of that information to some location in your own
      working copy directory (see <a class="xref" href="#svn.advanced.externals" title="Внешние зависимости">«Внешние зависимости»</a>).</p><p>But sometimes you want to maintain custom modifications to
      third-party data in your own version control system.  Returning
      to the software development example, programmers might need to
      make modifications to that third-party library for their own
      purposes.  These modifications might include new functionality
      or bug fixes, maintained internally only until they become part
      of an official release of the third-party library.  Or the
      changes might never be relayed back to the library maintainers,
      existing solely as custom tweaks to make the library further
      suit the needs of the software developers.</p><p>Now you face an interesting situation.  Your project could
      house its custom modifications to the third-party data in some
      disjointed fashion, such as using patch files or full-fledged
      alternate versions of files and directories.  But these quickly
      become maintenance headaches, requiring some mechanism by which
      to apply your custom changes to the third-party data, and
      necessitating regeneration of those changes with each successive
      version of the third-party data that you track.</p><p>The solution to this problem is to use <em class="firstterm">vendor
      branches</em>.  A vendor branch is a directory tree in
      your own version control system that contains information
      provided by a third-party entity, or vendor.  Each version of
      the vendor's data that you decide to absorb into your project is
      called a <em class="firstterm">vendor drop</em>.</p><p>Vendor branches provide two key benefits.  First, by storing
      the currently supported vendor drop in your own version control
      system, the members of your project never need to question
      whether they have the right version of the vendor's data.  They
      simply receive that correct version as part of their regular
      working copy updates.  Secondly, because the data lives in your
      own Subversion repository, you can store your custom changes to
      it in-place—you have no more need of an automated (or
      worse, manual) method for swapping in your customizations.</p><div class="sect2" title="General Vendor Branch Management Procedure"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.vendorbr.general"></a>General Vendor Branch Management Procedure</h3></div></div></div><p>Managing vendor branches generally works like this.  You
        create a top-level directory (such as
        <code class="filename">/vendor</code>) to hold the vendor branches.
        Then you import the third party code into a subdirectory of
        that top-level directory.  You then copy that subdirectory
        into your main development branch (for example,
        <code class="filename">/trunk</code>) at the appropriate location.  You
        always make your local changes in the main development branch.
        With each new release of the code you are tracking you bring
        it into the vendor branch and merge the changes into
        <code class="filename">/trunk</code>, resolving whatever conflicts
        occur between your local changes and the upstream
        changes.</p><p>Perhaps an example will help to clarify this algorithm.
        We'll use a scenario where your development team is creating a
        calculator program that links against a third-party complex
        number arithmetic library, libcomplex.  We'll begin with the
        initial creation of the vendor branch, and the import of the
        first vendor drop.  We'll call our vendor branch directory
        <code class="filename">libcomplex</code>, and our code drops will go
        into a subdirectory of our vendor branch called
        <code class="filename">current</code>.  And since <span class="command"><strong>svn
        import</strong></span> creates all the intermediate parent
        directories it needs, we can actually accomplish both of these
        steps with a single command.</p><pre class="screen">$ svn import /path/to/libcomplex-1.0 \
             http://svn.example.com/repos/vendor/libcomplex/current \
             -m 'importing initial 1.0 vendor drop'
…
</pre><p>We now have the current version of the libcomplex source
        code in <code class="filename">/vendor/libcomplex/current</code>.  Now,
        we tag that version (see <a class="xref" href="#svn.branchmerge.tags" title="Метки">«Метки»</a>)
        and then copy it into the main development branch.  Our copy
        will create a new directory called
        <code class="filename">libcomplex</code> in our existing
        <code class="filename">calc</code> project directory.  It is in this
        copied version of the vendor data that we will make our
        customizations.</p><pre class="screen">$ svn copy http://svn.example.com/repos/vendor/libcomplex/current  \
           http://svn.example.com/repos/vendor/libcomplex/1.0      \
           -m 'tagging libcomplex-1.0'
…
$ svn copy http://svn.example.com/repos/vendor/libcomplex/1.0  \
           http://svn.example.com/repos/calc/libcomplex        \
           -m 'bringing libcomplex-1.0 into the main branch'
…
</pre><p>We check out our project's main branch—which now
        includes a copy of the first vendor drop—and we get to
        work customizing the libcomplex code.  Before we know it, our
        modified version of libcomplex is now completely integrated
        into our calculator program.
        <sup>[<a id="idp11658176" href="#ftn.idp11658176" class="footnote">29</a>]</sup>
      </p><p>A few weeks later, the developers of libcomplex release a
        new version of their library—version 1.1—which
        contains some features and functionality that we really want.
        We'd like to upgrade to this new version, but without losing
        the customizations we made to the existing version.  What we
        essentially would like to do is to replace our current
        baseline version of libcomplex 1.0 with a copy of libcomplex
        1.1, and then re-apply the custom modifications we previously
        made to that library to the new version.  But we actually
        approach the problem from the other direction, applying the
        changes made to libcomplex between versions 1.0 and 1.1 to our
        modified copy of it.</p><p>To perform this upgrade, we checkout a copy of our vendor
        branch, and replace the code in the
        <code class="filename">current</code> directory with the new libcomplex
        1.1 source code.  We quite literally copy new files on top of
        existing files, perhaps exploding the libcomplex 1.1 release
        tarball atop our existing files and directories.  The goal
        here is to make our <code class="filename">current</code> directory
        contain only the libcomplex 1.1 code, and to ensure that all
        that code is under version control.  Oh, and we want to do
        this with as little version control history disturbance as
        possible.</p><p>After replacing the 1.0 code with 1.1 code, <span class="command"><strong>svn
        status</strong></span> will show files with local modifications as
        well as, perhaps, some unversioned or missing files.  If we
        did what we were supposed to do, the unversioned files are
        only those new files introduced in the 1.1 release of
        libcomplex—we run <span class="command"><strong>svn add</strong></span> on those to
        get them under version control.  The missing files are files
        that were in 1.0 but not in 1.1, and on those paths we run
        <span class="command"><strong>svn delete</strong></span>.  Finally, once our
        <code class="filename">current</code> working copy contains only the
        libcomplex 1.1 code, we commit the changes we made to get it
        looking that way.</p><p>Our <code class="filename">current</code> branch now contains the
        new vendor drop.  We tag the new version (in the same way we
        previously tagged the version 1.0 vendor drop), and then merge
        the differences between the tag of the previous version and
        the new current version into our main development
        branch.</p><pre class="screen">$ cd working-copies/calc
$ svn merge http://svn.example.com/repos/vendor/libcomplex/1.0      \
            http://svn.example.com/repos/vendor/libcomplex/current  \
            libcomplex
… # resolve all the conflicts between their changes and our changes
$ svn commit -m 'merging libcomplex-1.1 into the main branch'
…
</pre><p>In the trivial use case, the new version of our
        third-party tool would look, from a files-and-directories
        point of view, just like the previous version.  None of the
        libcomplex source files would have been deleted, renamed or
        moved to different locations—the new version would
        contain only textual modifications against the previous one.
        In a perfect world, our modifications would apply cleanly to
        the new version of the library, with absolutely no
        complications or conflicts.</p><p>But things aren't always that simple, and in fact it is
        quite common for source files to get moved around between
        releases of software.  This complicates the process of
        ensuring that our modifications are still valid for the new
        version of code, and can quickly degrade into a situation
        where we have to manually recreate our customizations in the
        new version.  Once Subversion knows about the history of a
        given source file—including all its previous
        locations—the process of merging in the new version of
        the library is pretty simple.  But we are responsible for
        telling Subversion how the source file layout changed from
        vendor drop to vendor drop.</p></div><div class="sect2" title="svn_load_dirs.pl"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.vendorbr.svn_load_dirs"></a><span class="command"><strong>svn_load_dirs.pl</strong></span></h3></div></div></div><p>Vendor drops that contain more than a few deletes,
        additions and moves complicate the process of upgrading to
        each successive version of the third-party data.  So
        Subversion supplies the <span class="command"><strong>svn_load_dirs.pl</strong></span>
        script to assist with this process.  This script automates the
        importing steps we mentioned in the general vendor branch
        management procedure to make sure that mistakes are minimized.
        You will still be responsible for using the merge commands to
        merge the new versions of the third-party data into your main
        development branch, but <span class="command"><strong>svn_load_dirs.pl</strong></span>
        can help you more quickly and easily arrive at that
        stage.</p><p>In short, <span class="command"><strong>svn_load_dirs.pl</strong></span> is an
        enhancement to <span class="command"><strong>svn import</strong></span> that has several
        important characteristics:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>It can be run at any point in time to bring an existing
            directory in the repository to exactly match an external
            directory, performing all the necessary adds and deletes,
            and optionally performing moves, too.</p></li><li class="listitem"><p>It takes care of complicated series of operations between
            which Subversion requires an intermediate commit—such
            as before renaming a file or directory twice.</p></li><li class="listitem"><p>It will optionally tag the newly imported directory.</p></li><li class="listitem"><p>It will optionally add arbitrary properties to files and
            directories that match a regular expression.</p></li></ul></div><p><span class="command"><strong>svn_load_dirs.pl</strong></span> takes three mandatory
        arguments.  The first argument is the URL to the base
        Subversion directory to work in.  This argument is followed by
        the URL—relative to the first argument—into which the
        current vendor drop will be imported.  Finally, the third
        argument is the local directory to import.  Using our previous
        example, a typical run of <span class="command"><strong>svn_load_dirs.pl</strong></span>
        might look like:</p><pre class="screen">$ svn_load_dirs.pl http://svn.example.com/repos/vendor/libcomplex \
                   current                                        \
                   /path/to/libcomplex-1.1
…
</pre><p>You can indicate that you'd like
        <span class="command"><strong>svn_load_dirs.pl</strong></span> to tag the new vendor drop
        by passing the <code class="option">-t</code> command-line option and
        specifying a tag name.  This tag is another URL relative to
        the first program argument.</p><pre class="screen">$ svn_load_dirs.pl -t libcomplex-1.1                              \
                   http://svn.example.com/repos/vendor/libcomplex \
                   current                                        \
                   /path/to/libcomplex-1.1
…
</pre><p>When you run <span class="command"><strong>svn_load_dirs.pl</strong></span>, it
        examines the contents of your existing <span class="quote">«<span class="quote">current</span>»</span>
        vendor drop, and compares them with the proposed new vendor
        drop.  In the trivial case, there will be no files that are in
        one version and not the other, and the script will perform the
        new import without incident.  If, however, there are
        discrepancies in the file layouts between versions,
        <span class="command"><strong>svn_load_dirs.pl</strong></span> will prompt you for how
        you would like to resolve those differences.  For example, you
        will have the opportunity to tell the script that you know
        that the file <code class="filename">math.c</code> in version 1.0 of
        libcomplex was renamed to <code class="filename">arithmetic.c</code> in
        libcomplex 1.1.  Any discrepancies not explained by moves
        are treated as regular additions and deletions.</p><p>The script also accepts a separate configuration file for
        setting properties on files and directories matching a regular
        expression that are <span class="emphasis"><em>added</em></span> to the
        repository.  This configuration file is specified to
        <span class="command"><strong>svn_load_dirs.pl</strong></span> using the
        <code class="option">-p</code> command-line option.  Each line of the
        configuration file is a whitespace-delimited set of two or
        four values: a Perl-style regular expression to match the
        added path against, a control keyword (either
        <code class="literal">break</code> or <code class="literal">cont</code>), and then
        optionally a property name and value.</p><pre class="screen">\.png$              break   svn:mime-type   image/png
\.jpe?g$            break   svn:mime-type   image/jpeg
\.m3u$              cont    svn:mime-type   audio/x-mpegurl
\.m3u$              break   svn:eol-style   LF
.*                  break   svn:eol-style   native
</pre><p>For each added path, the configured property changes whose
        regular expression matches the path are applied in order,
        unless the control specification is <code class="literal">break</code>
        (which means that no more property changes should be applied
        to that path).  If the control specification is
        <code class="literal">cont</code>—an abbreviation for
        <code class="literal">continue</code>—then matching will continue
        with the next line of the configuration file.</p><p>Any whitespace in the regular expression, property name,
        or property value must be surrounded by either single or
        double quote characters.  You can escape quote characters that
        are not used for wrapping whitespace by preceding them with a
        backslash (<code class="literal">\</code>) character.  The backslash
        escapes only quotes when parsing the configuration file, so do
        not protect any other characters beyond what is necessary for
        the regular expression.</p></div></div><div class="sect1" title="Подводя итоги"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.branchmerge.summary"></a>Подводя итоги</h2></div></div></div><p>В этой главе было рассмотрено очень многое. Мы обсудили
      концепцию меток и веток, показали как Subversion реализует эти понятия
      используя команду <span class="command"><strong>svn copy</strong></span>. Показали, как
      <span class="command"><strong>svn merge</strong></span> копирует изменения из одной ветки в другую,
      как с помощью этой команды отменить ошибочные изменения. Мы рассмотрели
      использование <span class="command"><strong>svn switch</strong></span> для создания рабочих копий,
      собранных из разных директорий хранилища. Обсудили, как управлять
      организацией и временем жизни веток в хранилище.</p><p>Не забывайте о мантре Subversion: ветки и метки легковесны. Поэтому
      пользуйтесь ими свободно!</p></div><div class="footnotes"><br><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.idp10996304" href="#idp10996304" class="para">24</a>] </sup>Subversion не поддерживает возможность копирования между 
        хранилищами. При использовании  в командах <span class="command"><strong>svn copy</strong></span> 
        или <span class="command"><strong>svn move</strong></span> URL-адресов можно копировать только 
        элементы из одного и того же хранилища.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp11112912" href="#idp11112912" class="para">25</a>] </sup>В будущем проект Subversion
          планирует использовать (или изобрести) расширенный формат
          представления различий, который будет передавать изменения в
          структуре дерева файлов и свойств.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp11351408" href="#idp11351408" class="para">26</a>] </sup>Однако, разработчики Subversion в будущем планируют
        реализовать команду <span class="command"><strong>svnadmin obliterate</strong></span>,
        которая позволит полностью удалять информацию.
        А пока за возможным решением проблемы обратитесь к разделу <a class="xref" href="#svn.reposadmin.maint.tk.svndumpfilter" title="svndumpfilter">«svndumpfilter»</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp11363232" href="#idp11363232" class="para">27</a>] </sup>Из-за того, что
        CVS не версионирует деревья, она создает область
        <code class="filename">Attic</code> для каждого каталога хранилища
        как способ сохранения информации об удаленных 
        файлах.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp11497472" href="#idp11497472" class="para">28</a>] </sup>Однако, <span class="emphasis"><em>можно</em></span>
      воспользоваться <span class="command"><strong>svn switch</strong></span> с параметром
      <code class="option">--relocate</code> если URL сервера изменился
      и вы не хотите бросать существующую рабочую копию. За более
      подробной информацией и примерами смотрите раздел, посвященный
      <span class="command"><strong>svn switch</strong></span> в <a class="xref" href="#svn.ref" title="Глава 9. Полное справочное руководство по Subversion">Глава&nbsp;9, <em>Полное справочное руководство по Subversion</em></a></p></div><div class="footnote"><p><sup>[<a id="ftn.idp11658176" href="#idp11658176" class="para">29</a>] </sup>And entirely bug-free, of course!</p></div></div></div><div class="chapter" title="Глава 5. Администрирование хранилища"><div class="titlepage"><div><div><h2 class="title"><a id="svn.reposadmin"></a>Глава 5. Администрирование хранилища</h2></div></div></div><div class="toc"><p><strong>Содержание</strong></p><dl><dt><span class="sect1"><a href="#svn.reposadmin.basics">Repository Basics</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.basics.txnsrevs">Understanding Transactions and Revisions</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.basics.revprops">Unversioned Properties</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.basics.backends">Repository Data Stores</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.reposadmin.basics.backends.bdb">Berkeley DB</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.basics.backends.fsfs">FSFS</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.create">Repository Creation and Configuration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.create.hooks">Hook Scripts</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.create.bdb">Berkeley DB Configuration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.maint">Repository Maintenance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.maint.tk">An Administrator's Toolkit</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.svnlook">svnlook</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.svnadmin">svnadmin</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.svndumpfilter">svndumpfilter</a></span></dt><dt><span class="sect3"><a href="#svn.reposadmin.maint.tk.bdbutil">Berkeley DB Utilities</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.reposadmin.maint.cleanup">Repository Cleanup</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.diskspace">Managing Disk Space</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.recovery">Repository Recovery</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.migrate">Migrating a Repository</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.maint.backup">Repository Backup</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.projects">Adding Projects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.reposadmin.projects.chooselayout">Choosing a Repository Layout</a></span></dt><dt><span class="sect2"><a href="#svn.reposadmin.projects.import">Creating the Layout, and Importing Initial Data</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.reposadmin.summary">Summary</a></span></dt></dl></div><p>### TODO:  Heavy (re-)construction will be happenin' here! ###</p><p>The Subversion repository is the central storehouse of
    versioned data for any number of projects.  As such, it becomes
    an obvious candidate for all the love and attention an
    administrator can offer.  While the repository is generally a
    low-maintenance item, it is important to understand how to
    properly configure and care for it so that potential problems
    are avoided, and actual problems are safely resolved.</p><p>In this chapter, we'll discuss how to create and configure
    a Subversion repository.  We'll also talk about repository
    maintenance, including the use of the <span class="command"><strong>svnlook</strong></span>
    and <span class="command"><strong>svnadmin</strong></span> tools (which are provided with
    Subversion).  We'll address some common questions and mistakes,
    and give some suggestions on how to arrange the data in the
    repository.</p><p>If you plan to access a Subversion repository only in the
    role of a user whose data is under version control (that is, via
    a Subversion client), you can skip this chapter altogether.
    However, if you are, or wish to become, a Subversion repository
    administrator,
    <sup>[<a id="idp12427408" href="#ftn.idp12427408" class="footnote">30</a>]</sup>
    you should definitely pay attention to this chapter.</p><div class="sect1" title="Repository Basics"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.reposadmin.basics"></a>Repository Basics</h2></div></div></div><p>Before jumping into the broader topic of repository
      administration, let's further define what a repository is.  How
      does it look?  How does it feel?  Does it take its tea hot or
      iced, sweetened, and with lemon?  As an administrator, you'll be
      expected to understand the composition of a repository both from
      a logical perspective—dealing with how data is represented
      inside the repository—and from a physical nuts-and-bolts
      perspective—how a repository looks and acts with respect
      to non-Subversion tools.  The following section covers some of
      these basic concepts at a very high level.</p><div class="sect2" title="Understanding Transactions and Revisions"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.basics.txnsrevs"></a>Understanding Transactions and Revisions</h3></div></div></div><p>Conceptually speaking, a Subversion repository is a
        sequence of directory trees.  Each tree is a snapshot of how
        the files and directories versioned in your repository looked
        at some point in time.  These snapshots are created as a
        result of client operations, and are called revisions.</p><p>Every revision begins life as a transaction tree.  When
        doing a commit, a client builds a Subversion transaction that
        mirrors their local changes (plus any additional changes that
        might have been made to the repository since the beginning of
        the client's commit process), and then instructs the
        repository to store that tree as the next snapshot in the
        sequence.  If the commit succeeds, the transaction is
        effectively promoted into a new revision tree, and is assigned
        a new revision number.  If the commit fails for some reason,
        the transaction is destroyed and the client is informed of the
        failure.</p><p>Updates work in a similar way.  The client builds a
        temporary transaction tree that mirrors the state of the
        working copy.  The repository then compares that transaction
        tree with the revision tree at the requested revision (usually
        the most recent, or <span class="quote">«<span class="quote">youngest</span>»</span> tree), and sends
        back information that informs the client about what changes
        are needed to transform their working copy into a replica of
        that revision tree.  After the update completes, the temporary
        transaction is deleted.</p><p>The use of transaction trees is the only way to make
        permanent changes to a repository's versioned filesystem.
        However, it's important to understand that the lifetime of a
        transaction is completely flexible.  In the case of updates,
        transactions are temporary trees that are immediately
        destroyed.  In the case of commits, transactions are
        transformed into permanent revisions (or removed if the commit
        fails).  In the case of an error or bug, it's possible that a
        transaction can be accidentally left lying around in the
        repository (not really affecting anything, but still taking up
        space).</p><p>In theory, someday whole workflow applications might
        revolve around more fine-grained control of transaction
        lifetime.  It is feasible to imagine a system whereby each
        transaction slated to become a revision is left in stasis well
        after the client finishes describing its changes to
        repository.  This would enable each new commit to be reviewed
        by someone else, perhaps a manager or engineering QA team, who
        can choose to promote the transaction into a revision, or
        abort it.</p></div><div class="sect2" title="Unversioned Properties"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.basics.revprops"></a>Unversioned Properties</h3></div></div></div><p>Transactions and revisions in the Subversion repository
        can have properties attached to them.  These properties are
        generic key-to-value mappings, and are generally used to store
        information about the tree to which they are attached.  The
        names and values of these properties are stored in the
        repository's filesystem, along with the rest of your tree
        data.</p><p>Revision and transaction properties are useful for
        associating information with a tree that is not strictly
        related to the files and directories in that tree—the
        kind of information that isn't managed by client working
        copies.  For example, when a new commit transaction is created
        in the repository, Subversion adds a property to that
        transaction named <code class="literal">svn:date</code>—a
        datestamp representing the time that the transaction was
        created.  By the time the commit process is finished, and the
        transaction is promoted to a permanent revision, the tree has
        also been given a property to store the username of the
        revision's author (<code class="literal">svn:author</code>) and a
        property to store the log message attached to that revision
        (<code class="literal">svn:log</code>).</p><p>Revision and transaction properties are
        <em class="firstterm">unversioned properties</em>—as they
        are modified, their previous values are permanently discarded.
        Also, while revision trees themselves are immutable, the
        properties attached to those trees are not.  You can add,
        remove, and modify revision properties at any time in the
        future.  If you commit a new revision and later realize that
        you had some misinformation or spelling error in your log
        message, you can simply replace the value of the
        <code class="literal">svn:log</code> property with a new, corrected log
        message.</p></div><div class="sect2" title="Repository Data Stores"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.basics.backends"></a>Repository Data Stores</h3></div></div></div><p>As of Subversion 1.1, there are two options for storing
        data in a Subversion repository.  One type of repository
        stores everything in a Berkeley DB database; the other kind
        stores data in ordinary flat files, using a custom
        format.  Because Subversion developers often refer to a
        repository as <span class="quote">«<span class="quote">the (versioned) filesystem</span>»</span>, they have
        adopted the habit of referring to the latter type of repository as
        <em class="firstterm">FSFS</em>
        <sup>[<a id="idp12450256" href="#ftn.idp12450256" class="footnote">31</a>]</sup>
        —a versioned
        filesystem implementation that uses the native OS filesystem
        to store data.</p><p>When a repository is created, an administrator must decide
        whether it will use Berkeley DB or FSFS.  There are advantages
        and disadvantages to each, which we'll describe in a bit.
        Neither back-end is more <span class="quote">«<span class="quote">official</span>»</span> than another,
        and programs which access the repository are insulated from
        this implementation detail.  Programs have no idea how a
        repository is storing data; they only see revision and
        transaction trees through the repository API.</p><p><a class="xref" href="#svn.reposadmin.basics.backends.tbl-1" title="Таблица 5.1. Repository Data Store Comparison">Таблица&nbsp;5.1, «Repository Data Store Comparison»</a>
        gives a comparative overview of Berkeley DB and FSFS
        repositories.  The next sections go into detail.</p><div class="table"><a id="svn.reposadmin.basics.backends.tbl-1"></a><p class="title"><strong>Таблица 5.1. Repository Data Store Comparison</strong></p><div class="table-contents"><table summary="Repository Data Store Comparison" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Feature</th><th>Berkeley DB</th><th>FSFS</th></tr></thead><tbody><tr><td>Sensitivity to interruptions</td><td>very;  crashes and permission problems can leave the
                database <span class="quote">«<span class="quote">wedged</span>»</span>, requiring journaled
                recovery procedures.</td><td>quite insensitive.</td></tr><tr><td>Usable from a read-only mount</td><td>no</td><td>yes</td></tr><tr><td>Platform-independent storage</td><td>no</td><td>yes</td></tr><tr><td>Usable over network filesystems</td><td>no</td><td>yes</td></tr><tr><td>Repository size</td><td>slightly larger</td><td>slightly smaller</td></tr><tr><td>Scalability: number of revision trees</td><td>database;  no problems</td><td>some older native filesystems don't scale well with
                thousands of entries in a single directory.</td></tr><tr><td>Scalability: directories with many files</td><td>slower</td><td>faster</td></tr><tr><td>Speed:  checking out latest code</td><td>faster</td><td>slower</td></tr><tr><td>Speed:  large commits</td><td>slower, but work is spread throughout commit</td><td>faster, but finalization delay may cause client
                timeouts</td></tr><tr><td>Group permissions handling</td><td>sensitive to user umask problems;  best if accessed
                by only one user.</td><td>works around umask problems</td></tr><tr><td>Code maturity</td><td>in use since 2001</td><td>in use since 2004</td></tr></tbody></table></div></div><br class="table-break"><br><div class="sect3" title="Berkeley DB"><div class="titlepage"><div><div><h4 class="title"><a id="svn.reposadmin.basics.backends.bdb"></a>Berkeley DB</h4></div></div></div><p>When the initial design phase of Subversion was in
          progress, the developers decided to use Berkeley DB for a
          variety of reasons, including its open-source license,
          transaction support, reliability, performance, API
          simplicity, thread-safety, support for cursors, and so
          on.</p><p>Berkeley DB provides real transaction
          support—perhaps its most powerful feature.  Multiple
          processes accessing your Subversion repositories don't have
          to worry about accidentally clobbering each other's data.
          The isolation provided by the transaction system is such
          that for any given operation, the Subversion repository code
          sees a static view of the database—not a database that
          is constantly changing at the hand of some other
          process—and can make decisions based on that view.  If
          the decision made happens to conflict with what another
          process is doing, the entire operation is rolled back as if
          it never happened, and Subversion gracefully retries the
          operation against a new, updated (and yet still static) view
          of the database.</p><p>Another great feature of Berkeley DB is <em class="firstterm">hot
          backups</em>—the ability to backup the database
          environment without taking it <span class="quote">«<span class="quote">offline</span>»</span>.  We'll
          discuss how to backup your repository in <a class="xref" href="#svn.reposadmin.maint.backup" title="Repository Backup">«Repository Backup»</a>, but the benefits of being
          able to make fully functional copies of your repositories
          without any downtime should be obvious.</p><p>Berkeley DB is also a very reliable database system.
          Subversion uses Berkeley DB's logging facilities, which
          means that the database first writes to on-disk log files a
          description of any modifications it is about to make, and
          then makes the modification itself.  This is to ensure that
          if anything goes wrong, the database system can back up to
          a previous <em class="firstterm">checkpoint</em>—a
          location in the log files known not to be corrupt—and
          replay transactions until the data is restored to a usable
          state.  See <a class="xref" href="#svn.reposadmin.maint.diskspace" title="Managing Disk Space">«Managing Disk Space»</a> for more
          about Berkeley DB log files.</p><p>But every rose has its thorn, and so we must note some
          known limitations of Berkeley DB.  First, Berkeley DB
          environments are not portable.  You cannot simply copy a
          Subversion repository that was created on a Unix system onto
          a Windows system and expect it to work.  While much of the
          Berkeley DB database format is architecture independent,
          there are other aspects of the environment that are not.
          Secondly, Subversion uses Berkeley DB in a way that will not
          operate on Windows 95/98 systems—if you need to house
          a repository on a Windows machine, stick with Windows 2000
          or Windows XP.  Also, you should never keep a Berkeley DB
          repository on a network share.  While Berkeley DB promises
          to behave correctly on network shares that meet a particular
          set of specifications, almost no known shares actually meet
          all those specifications.</p><p>Finally, because Berkeley DB is a library linked
          directly into Subversion, it's more sensitive to
          interruptions than a typical relational database system.
          Most SQL systems, for example, have a dedicated server
          process that mediates all access to tables.  If a program
          accessing the database crashes for some reason, the database
          daemon notices the lost connection and cleans up any mess
          left behind.  And because the database daemon is the only
          process accessing the tables, applications don't need to
          worry about permission conflicts.  These things are not the
          case with Berkeley DB, however.  Subversion (and programs
          using Subversion libraries) access the database tables
          directly, which means that a program crash can leave the
          database in a temporarily inconsistent, inaccessible state.
          When this happens, an administrator needs to ask Berkeley DB
          to restore to a checkpoint, which is a bit of an annoyance.
          Other things can cause a repository to <span class="quote">«<span class="quote">wedge</span>»</span>
          besides crashed processes, such as programs conflicting over
          ownership and permissions on the database files.  So while a
          Berkeley DB repository is quite fast and scalable, it's best
          used by a single server process running as one
          user—such as Apache's <span class="command"><strong>httpd</strong></span> or
          <span class="command"><strong>svnserve</strong></span> (see <a class="xref" href="#svn.serverconfig" title="Глава 6. Настройка сервера">Глава&nbsp;6, <em>Настройка сервера</em></a>)—rather than accessing it as
          many different users via <code class="literal">file:///</code> or
          <code class="literal">svn+ssh://</code> URLs.  If using a Berkeley DB
          repository directly as multiple users, be sure to read <a class="xref" href="#svn.serverconfig.multimethod" title="Supporting Multiple Repository Access Methods">«Supporting Multiple Repository Access Methods»</a>.</p></div><div class="sect3" title="FSFS"><div class="titlepage"><div><div><h4 class="title"><a id="svn.reposadmin.basics.backends.fsfs"></a>FSFS</h4></div></div></div><p>In mid-2004, a second type of repository storage system
          came into being: one which doesn't use a database at all.
          An FSFS repository stores a revision tree in a single file,
          and so all of a repository's revisions can be found in a
          single subdirectory full of numbered files.  Transactions
          are created in separate subdirectories.  When complete, a
          single transaction file is created and moved to the
          revisions directory, thus guaranteeing that commits are
          atomic.  And because a revision file is permanent and
          unchanging, the repository also can be backed up while
          <span class="quote">«<span class="quote">hot</span>»</span>, just like a Berkeley DB repository.</p><p>The revision-file format represents a revision's
          directory structure, file contents, and deltas against files
          in other revision trees.  Unlike a Berkeley DB database,
          this storage format is portable across different operating
          systems and isn't sensitive to CPU architecture.  Because
          there's no journaling or shared-memory files being used, the
          repository can be safely accessed over a network filesystem
          and examined in a read-only environment.  The lack of
          database overhead also means that the overall repository
          size is a bit smaller.</p><p>FSFS has different performance characteristics too.
          When committing a directory with a huge number of files, FSFS
          uses an O(N) algorithm to append entries, while Berkeley DB
          uses an O(N^2) algorithm to rewrite the whole directory.  On
          the other hand, FSFS writes the latest version of a file as
          a delta against an earlier version, which means that
          checking out the latest tree is a bit slower than fetching
          the fulltexts stored in a Berkeley DB HEAD revision.  FSFS
          also has a longer delay when finalizing a commit, which
          could in extreme cases cause clients to time out when
          waiting for a response.</p><p>The most important distinction, however, is FSFS's
          inability to be <span class="quote">«<span class="quote">wedged</span>»</span> when something goes
          wrong.  If a process using a Berkeley DB database runs into
          a permissions problem or suddenly crashes, the database is
          left unusable until an administrator recovers it.  If the
          same scenarios happen to a process using an FSFS repository,
          the repository isn't affected at all.  At worst, some
          transaction data is left behind.</p><p>The only real argument against FSFS is its relative
          immaturity compared to Berkeley DB.  It hasn't been used or
          stress-tested nearly as much, and so a lot of these
          assertions about speed and scalability are just that:
          assertions, based on good guesses.  In theory, it promises a
          lower barrier to entry for new administrators and is less
          susceptible to problems.  In practice, only time will
          tell.</p></div></div></div><div class="sect1" title="Repository Creation and Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.reposadmin.create"></a>Repository Creation and Configuration</h2></div></div></div><p>Creating a Subversion repository is an incredibly simple
      task.  The <span class="command"><strong>svnadmin</strong></span> utility, provided with
      Subversion, has a subcommand for doing just that.  To create a
      new repository, just run:</p><pre class="screen">$ svnadmin create /path/to/repos
</pre><p>This creates a new repository in the directory
      <code class="filename">/path/to/repos</code>.  This new repository begins
      life at revision 0, which is defined to consist of nothing but
      the top-level root (<code class="filename">/</code>) filesystem
      directory.  Initially, revision 0 also has a single revision
      property, <code class="literal">svn:date</code>, set to the time at which
      the repository was created.</p><p>In Subversion 1.2, a repository is created with an FSFS
      back-end by default (see <a class="xref" href="#svn.reposadmin.basics.backends" title="Repository Data Stores">«Repository Data Stores»</a>).  The back-end can
      be explicitly chosen with the <code class="option">--fs-type</code>
      argument:</p><pre class="screen">$ svnadmin create --fs-type fsfs /path/to/repos
$ svnadmin create --fs-type bdb /path/to/other/repos
</pre><div class="warning" title="Предупреждение" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Предупреждение]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/warning.png"></td><th align="left">Предупреждение</th></tr><tr><td valign="top" align="left"><p>Do not create a Berkeley DB repository on a network
        share—it <span class="emphasis"><em>cannot</em></span> exist on a remote
        filesystem such as NFS, AFS, or Windows SMB.  Berkeley DB
        requires that the underlying filesystem implement strict POSIX
        locking semantics, and more importantly, the ability to map
        files directly into process memory.  Almost no network
        filesystems provide these features.  If you attempt to use
        Berkeley DB on a network share, the results are
        unpredictable—you may see mysterious errors right away,
        or it may be months before you discover that your repository
        database is subtly corrupted.</p><p>If you need multiple computers to access the repository,
        you create an FSFS repository on the network share, not a
        Berkeley DB repository.  Or better yet, set up a real server
        process (such as Apache or <span class="command"><strong>svnserve</strong></span>), store
        the repository on a local filesystem which the server can
        access, and make the repository available over a network.
        <a class="xref" href="#svn.serverconfig" title="Глава 6. Настройка сервера">Глава&nbsp;6, <em>Настройка сервера</em></a> covers this process in
        detail.</p></td></tr></tbody></table></div><p>You may have noticed that the path argument to
      <span class="command"><strong>svnadmin</strong></span> was just a regular filesystem path
      and not a URL like the <span class="command"><strong>svn</strong></span> client program
      uses when referring to repositories.  Both
      <span class="command"><strong>svnadmin</strong></span> and <span class="command"><strong>svnlook</strong></span> are
      considered server-side utilities—they are used on the
      machine where the repository resides to examine or modify
      aspects of the repository, and are in fact unable to perform
      tasks across a network.  A common mistake made by Subversion
      newcomers is trying to pass URLs (even <span class="quote">«<span class="quote">local</span>»</span>
      <code class="literal">file:</code> ones) to these two programs.</p><p>So, after you've run the <span class="command"><strong>svnadmin create</strong></span>
      command, you have a shiny new Subversion repository in its own
      directory.  Let's take a peek at what is actually created inside
      that subdirectory.</p><pre class="screen">$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</pre><p>With the exception of the <code class="filename">README.txt</code> and
      <code class="filename">format</code> files,
      the repository directory is a collection of subdirectories.  As
      in other areas of the Subversion design, modularity is given
      high regard, and hierarchical organization is preferred to
      cluttered chaos.  Here is a brief description of all of
      the items you see in your new repository directory:</p><div class="variablelist"><dl><dt><span class="term">conf</span></dt><dd><p>A directory containing repository configuration files.</p></dd><dt><span class="term">dav</span></dt><dd><p>A directory provided to Apache and mod_dav_svn for
            their private housekeeping data.</p></dd><dt><span class="term">db</span></dt><dd><p>Where all of your versioned data resides.  This
            directory is either a Berkeley DB environment (full of DB
            tables and other things), or is an FSFS environment
            containing revision files.</p></dd><dt><span class="term">format</span></dt><dd><p>A file whose contents are a single integer value that
            dictates the version number of the repository layout.</p></dd><dt><span class="term">hooks</span></dt><dd><p>A directory full of hook script templates (and hook
            scripts themselves, once you've installed some).</p></dd><dt><span class="term">locks</span></dt><dd><p>A directory for Subversion's repository locking
            data, used for tracking accessors to the repository.</p></dd><dt><span class="term">README.txt</span></dt><dd><p>A file which merely informs its readers that they
            are looking at a Subversion repository.</p></dd></dl></div><p>In general, you shouldn't tamper with your repository
      <span class="quote">«<span class="quote">by hand</span>»</span>.  The <span class="command"><strong>svnadmin</strong></span> tool
      should be sufficient for any changes necessary to your
      repository, or you can look to third-party tools (such as
      Berkeley DB's tool suite) for tweaking relevant subsections of
      the repository.  Some exceptions exist, though, and we'll cover
      those here.</p><div class="sect2" title="Hook Scripts"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.create.hooks"></a>Hook Scripts</h3></div></div></div><p>A <em class="firstterm">hook</em> is a program triggered by
        some repository event, such as the creation of a new revision
        or the modification of an unversioned property.  Each hook is
        handed enough information to tell what that event is, what
        target(s) it's operating on, and the username of the person
        who triggered the event.  Depending on the hook's output or
        return status, the hook program may continue the action, stop
        it, or suspend it in some way.</p><p>The <code class="filename">hooks</code> subdirectory is, by
        default, filled with templates for various repository
        hooks.</p><pre class="screen">$ ls repos/hooks/
post-commit.tmpl          post-unlock.tmpl          pre-revprop-change.tmpl
post-lock.tmpl            pre-commit.tmpl           pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl             start-commit.tmpl
</pre><p>There is one template for each hook that the Subversion
        repository implements, and by examining the contents of those
        template scripts, you can see what triggers each such script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <code class="filename">repos/hooks</code> directory
        which can be executed as the name (like
        <span class="command"><strong>start-commit</strong></span> or
        <span class="command"><strong>post-commit</strong></span>) of the hook.</p><p>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes—the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <code class="literal">.tmpl</code> extension,
        customize the hook's contents, and ensure that the script is
        executable.  Windows, however, uses file extensions to
        determine whether or not a program is executable, so you would
        need to supply a program whose basename is the name of the
        hook, and whose extension is one of the special extensions
        recognized by Windows for executable programs, such as
        <code class="filename">.exe</code> or <code class="filename">.com</code> for
        programs, and <code class="filename">.bat</code> for batch
        files.</p><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>For security reasons, the Subversion repository executes
        hook scripts with an empty environment—that is, no
        environment variables are set at all, not even
        <code class="literal">$PATH</code> or <code class="literal">%PATH%</code>.
        Because of this, a lot of administrators are baffled when
        their hook script runs fine by hand, but doesn't work when run
        by Subversion.  Be sure to explicitly set environment
        variables in your hook and/or use absolute paths to
        programs.</p></td></tr></tbody></table></div><p>There are nine hooks implemented by the Subversion
        repository:</p><div class="variablelist"><dl><dt><span class="term"><code class="filename">start-commit</code></span></dt><dd><p>This is run before the commit transaction is even
              created.  It is typically used to decide if the user has
              commit privileges at all.  The repository passes two
              arguments to this program: the path to the repository,
              and username which is attempting the commit.  If the
              program returns a non-zero exit value, the commit is
              stopped before the transaction is even created.  If the
              hook program writes data to stderr, it will be
              marshalled back to the client.</p></dd><dt><span class="term"><code class="filename">pre-commit</code></span></dt><dd><p>This is run when the transaction is complete, but
              before it is committed.  Typically, this hook is used to
              protect against commits that are disallowed due to
              content or location (for example, your site might
              require that all commits to a certain branch include a
              ticket number from the bug tracker, or that the incoming
              log message is non-empty).  The repository passes two
              arguments to this program: the path to the repository,
              and the name of the transaction being committed.  If the
              program returns a non-zero exit value, the commit is
              aborted and the transaction is removed.  If the hook
              program writes data to stderr, it will be marshalled
              back to the client.</p><p>The Subversion distribution includes some access
              control scripts (located in the
              <code class="filename">tools/hook-scripts</code> directory of the
              Subversion source tree) that can be called from
              <span class="command"><strong>pre-commit</strong></span> to implement fine-grained
              write-access control.  Another option is to use the
              <span class="command"><strong>mod_authz_svn</strong></span> Apache httpd module,
              which provides both read and write access control on
              individual directories (see <a class="xref" href="#svn.serverconfig.httpd.authz.perdir" title="Per-Directory Access Control">«Per-Directory Access Control»</a>).  In a future version
              of Subversion, we plan to implement access control lists
              (ACLs) directly in the filesystem.</p></dd><dt><span class="term"><code class="filename">post-commit</code></span></dt><dd><p>This is run after the transaction is committed, and
              a new revision is created.  Most people use this hook to
              send out descriptive emails about the commit or to make
              a backup of the repository.  The repository passes two
              arguments to this program: the path to the repository,
              and the new revision number that was created.  The exit
              code of the program is ignored.</p><p>The Subversion distribution includes
              <span class="command"><strong>mailer.py</strong></span> and
              <span class="command"><strong>commit-email.pl</strong></span> scripts (located in
              the <code class="filename">tools/hook-scripts/</code> directory
              of the Subversion source tree) that can be used to send
              email with (and/or append to a log file) a description
              of a given commit.  This mail contains a list of the
              paths that were changed, the log message attached to the
              commit, the author and date of the commit, as well as a
              GNU diff-style display of the changes made to the
              various versioned files as part of the commit.</p><p>Another useful tool provided by Subversion is the
              <span class="command"><strong>hot-backup.py</strong></span> script (located in the
              <code class="filename">tools/backup/</code> directory of the
              Subversion source tree).  This script performs hot
              backups of your Subversion repository (a feature
              supported by the Berkeley DB database back-end), and can
              be used to make a per-commit snapshot of your repository
              for archival or emergency recovery purposes.</p></dd><dt><span class="term"><code class="filename">pre-revprop-change</code></span></dt><dd><p>Because Subversion's revision properties are not
              versioned, making modifications to such a property (for
              example, the <code class="literal">svn:log</code> commit message
              property) will overwrite the previous value of that
              property forever.  Since data can be potentially lost
              here, Subversion supplies this hook (and its
              counterpart, <code class="filename">post-revprop-change</code>)
              so that repository administrators can keep records of
              changes to these items using some external means if
              they so desire.  As a precaution against losing
              unversioned property data, Subversion clients will not
              be allowed to remotely modify revision properties at all
              unless this hook is implemented for your repository.</p><p>This hook runs just before such a modification is
              made to the repository.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the to-be-modified property exists, the
              authenticated username of the person making the change,
              and the name of the property itself.</p></dd><dt><span class="term"><code class="filename">post-revprop-change</code></span></dt><dd><p>As mentioned earlier, this hook is the counterpart
              of the <code class="filename">pre-revprop-change</code> hook.  In
              fact, for the sake of paranoia this script will not run
              unless the <code class="filename">pre-revprop-change</code> hook
              exists.  When both of these hooks are present, the
              <code class="filename">post-revprop-change</code> hook runs just
              after a revision property has been changed, and is
              typically used to send an email containing the new value
              of the changed property.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the property exists, the authenticated
              username of the person making the change, and the name of
              the property itself.</p><p>The Subversion distribution includes a
              <span class="command"><strong>propchange-email.pl</strong></span> script (located
              in the <code class="filename">tools/hook-scripts/</code>
              directory of the Subversion source tree) that can be
              used to send email with (and/or append to a log file)
              the details of a revision property change.  This mail
              contains the revision and name of the changed property,
              the user who made the change, and the new property
              value.</p></dd><dt><span class="term"><code class="filename">pre-lock</code></span></dt><dd><p>This hook runs whenever someone attempts to lock a
              file.  It can be used to prevent locks altogether, or to
              create a more complex policy specifying exactly which
              users are allowed to lock particular paths.  If the hook
              notices a pre-existing lock, then it can also decide
              whether a user is allowed to <span class="quote">«<span class="quote">steal</span>»</span> the
              existing lock.  The repository passes three arguments to
              the hook: the path to the repository, the path being
              locked, and the user attempting to perform the lock.  If
              the program returns a non-zero exit value, the lock
              action is aborted and anything printed to stderr is
              marshalled back to the client.</p></dd><dt><span class="term"><code class="filename">post-lock</code></span></dt><dd><p>This hook runs after a path is locked.  The locked
              path is passed to the hook's stdin, and the hook also
              receives two arguments:  the path to the repository, and
              the user who performed the lock.  The hook is then free
              to send email notification or record the event in any
              way it chooses.  Because the lock already happened, the
              output of the hook is ignored.</p></dd><dt><span class="term"><code class="filename">pre-unlock</code></span></dt><dd><p>This hook runs whenever someone attempts to remove a
              lock on a file.  It can be used to create policies that
              specify which users are allowed to unlock particular
              paths.  It's particularly important for determining
              policies about lock breakage.  If user A locks a file,
              is user B allowed to break the lock?  What if the lock
              is more than a week old?  These sorts of things can be
              decided and enforced by the hook.  The repository passes
              three arguments to the hook: the path to the repository,
              the path being unlocked, and the user attempting to
              remove the lock.  If the program returns a non-zero exit
              value, the unlock action is aborted and anything printed
              to stderr is marshalled back to the client.</p></dd><dt><span class="term"><code class="filename">post-unlock</code></span></dt><dd><p>This hook runs after a path is unlocked.  The
              unlocked path is passed to the hook's stdin, and the
              hook also receives two arguments: the path to the
              repository, and the user who removed the lock.  The hook
              is then free to send email notification or record the
              event in any way it chooses.  Because the lock removal
              already happened, the output of the hook is
              ignored.</p></dd></dl></div><div class="warning" title="Предупреждение" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Предупреждение]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/warning.png"></td><th align="left">Предупреждение</th></tr><tr><td valign="top" align="left"><p>Do not attempt to modify the transaction using hook
          scripts.  A common example of this would be to automatically
          set properties such as <code class="literal">svn:eol-style</code> or
          <code class="literal">svn:mime-type</code> during the commit.  While
          this might seem like a good idea, it causes problems.  The
          main problem is that the client does not know about the
          change made by the hook script, and there is no way to
          inform the client that it is out-of-date.  This
          inconsistency can lead to surprising and unexpected
          behavior.</p><p>Instead of attempting to modify the transaction, it is
          much better to <span class="emphasis"><em>check</em></span> the transaction in
          the <code class="filename">pre-commit</code> hook and reject the
          commit if it does not meet the desired requirements.</p></td></tr></tbody></table></div><p>Subversion will attempt to execute hooks as the same user
        who owns the process which is accessing the Subversion
        repository.  In most cases, the repository is being accessed
        via Apache HTTP server and mod_dav_svn, so this user is the
        same user that Apache runs as.  The hooks themselves will need
        to be configured with OS-level permissions that allow that
        user to execute them.  Also, this means that any file or
        programs (including the Subversion repository itself) accessed
        directly or indirectly by the hook will be accessed as the
        same user.  In other words, be alert to potential
        permission-related problems that could prevent the hook from
        performing the tasks you've written it to perform.</p></div><div class="sect2" title="Berkeley DB Configuration"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.create.bdb"></a>Berkeley DB Configuration</h3></div></div></div><p>A Berkeley DB environment is an encapsulation of one or
        more databases, log files, region files and configuration
        files.  The Berkeley DB environment has its own set of default
        configuration values for things like the number of database locks
        allowed to be taken out at any given time, or the maximum size
        of the journaling log files, etc.  Subversion's filesystem
        code additionally chooses default values for some of the
        Berkeley DB configuration options.  However, sometimes your
        particular repository, with its unique collection of data and
        access patterns, might require a different set of
        configuration option values.</p><p>The folks at Sleepycat (the producers of Berkeley DB)
        understand that different databases have different
        requirements, and so they have provided a mechanism for
        overriding at runtime many of the configuration values for the
        Berkeley DB environment.  Berkeley checks for the presence of
        a file named <code class="filename">DB_CONFIG</code> in each
        environment directory, and parses the options found in that
        file for use with that particular Berkeley environment.</p><p>The Berkeley configuration file for your repository is
        located in the <code class="filename">db</code> environment directory,
        at <code class="filename">repos/db/DB_CONFIG</code>.  Subversion itself
        creates this file when it creates the rest of the repository.
        The file initially contains some default options, as well as
        pointers to the Berkeley DB online documentation so you can
        read about what those options do.  Of course, you are free to
        add any of the supported Berkeley DB options to your
        <code class="filename">DB_CONFIG</code> file.  Just be aware that while
        Subversion never attempts to read or interpret the contents of
        the file, and makes no use of the option settings in it,
        you'll want to avoid any configuration changes that may cause
        Berkeley DB to behave in a fashion that is unexpected by the
        rest of the Subversion code.  Also, changes made to
        <code class="filename">DB_CONFIG</code> won't take effect until you
        recover the database environment (using <span class="command"><strong>svnadmin
        recover</strong></span>).</p></div></div><div class="sect1" title="Repository Maintenance"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.reposadmin.maint"></a>Repository Maintenance</h2></div></div></div><p>Maintaining a Subversion repository can be a daunting task,
      mostly due to the complexities inherent in systems which have a
      database backend.  Doing the task well is all about knowing the
      tools—what they are, when to use them, and how to use
      them.  This section will introduce you to the repository
      administration tools provided by Subversion, and how to wield
      them to accomplish tasks such as repository migrations,
      upgrades, backups and cleanups.</p><div class="sect2" title="An Administrator's Toolkit"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.maint.tk"></a>An Administrator's Toolkit</h3></div></div></div><p>Subversion provides a handful of utilities useful for
        creating, inspecting, modifying and repairing your repository.
        Let's look more closely at each of those tools.  Afterward,
        we'll briefly examine some of the utilities included in the
        Berkeley DB distribution that provide functionality specific
        to your repository's database backend not otherwise provided
        by Subversion's own tools.</p><div class="sect3" title="svnlook"><div class="titlepage"><div><div><h4 class="title"><a id="svn.reposadmin.maint.tk.svnlook"></a>svnlook</h4></div></div></div><p><span class="command"><strong>svnlook</strong></span> is a tool provided by
          Subversion for examining the various revisions and
          transactions in a repository.  No part of this program
          attempts to change the repository—it's a
          <span class="quote">«<span class="quote">read-only</span>»</span> tool.  <span class="command"><strong>svnlook</strong></span>
          is typically used by the repository hooks for reporting the
          changes that are about to be committed (in the case of the
          <span class="command"><strong>pre-commit</strong></span> hook) or that were just
          committed (in the case of the <span class="command"><strong>post-commit</strong></span>
          hook) to the repository.  A repository administrator may use
          this tool for diagnostic purposes.</p><p><span class="command"><strong>svnlook</strong></span> has a straightforward
          syntax:</p><pre class="screen">$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type "svnlook help &lt;subcommand&gt;" for help on a specific subcommand.
…
</pre><p>Nearly every one of <span class="command"><strong>svnlook</strong></span>'s
          subcommands can operate on either a revision or a
          transaction tree, printing information about the tree
          itself, or how it differs from the previous revision of the
          repository.  You use the <code class="option">--revision</code> and
          <code class="option">--transaction</code> options to specify which
          revision or transaction, respectively, to examine.  Note
          that while revision numbers appear as natural numbers,
          transaction names are alphanumeric strings.  Keep in mind
          that the filesystem only allows browsing of uncommitted
          transactions (transactions that have not resulted in a new
          revision).  Most repositories will have no such
          transactions, because transactions are usually either
          committed (which disqualifies them from viewing) or aborted
          and removed.</p><p>In the absence of both the <code class="option">--revision</code>
          and <code class="option">--transaction</code> options,
          <span class="command"><strong>svnlook</strong></span> will examine the youngest (or
          <span class="quote">«<span class="quote">HEAD</span>»</span>) revision in the repository.  So the
          following two commands do exactly the same thing when 19 is
          the youngest revision in the repository located at
          <code class="filename">/path/to/repos</code>:</p><pre class="screen">$ svnlook info /path/to/repos
$ svnlook info /path/to/repos --revision 19
</pre><p>The only exception to these rules about subcommands is
          the <span class="command"><strong>svnlook youngest</strong></span> subcommand, which
          takes no options, and simply prints out the
          <code class="literal">HEAD</code> revision number.</p><pre class="screen">$ svnlook youngest /path/to/repos
19
</pre><p>Output from <span class="command"><strong>svnlook</strong></span> is designed to be
          both human- and machine-parsable.  Take as an example the output
          of the <code class="literal">info</code> subcommand:</p><pre class="screen">$ svnlook info /path/to/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
</pre><p>The output of the <code class="literal">info</code> subcommand is
          defined as:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The author, followed by a newline.</p></li><li class="listitem"><p>The date, followed by a newline.</p></li><li class="listitem"><p>The number of characters in the log message,
              followed by a newline.</p></li><li class="listitem"><p>The log message itself, followed by a newline.</p></li></ol></div><p>This output is human-readable, meaning items like the
          datestamp are displayed using a textual representation
          instead of something more obscure (such as the number of
          nanoseconds since the Tasty Freeze guy drove by).  But this
          output is also machine-parsable—because the log
          message can contain multiple lines and be unbounded in
          length, <span class="command"><strong>svnlook</strong></span> provides the length of
          that message before the message itself.  This allows scripts
          and other wrappers around this command to make intelligent
          decisions about the log message, such as how much memory to
          allocate for the message, or at least how many bytes to skip
          in the event that this output is not the last bit of data in
          the stream.</p><p>Another common use of <span class="command"><strong>svnlook</strong></span> is to
          actually view the contents of a revision or transaction
          tree.  The <span class="command"><strong>svnlook tree</strong></span> command displays
          the directories and files in the requested tree.  If you
          supply the <code class="option">--show-ids</code> option, it will also
          show the filesystem node revision IDs for each of those
          paths (which is generally of more use to developers than to
          users).</p><pre class="screen">$ svnlook tree /path/to/repos --show-ids
/ &lt;0.0.1&gt;
 A/ &lt;2.0.1&gt;
  B/ &lt;4.0.1&gt;
   lambda &lt;5.0.1&gt;
   E/ &lt;6.0.1&gt;
    alpha &lt;7.0.1&gt;
    beta &lt;8.0.1&gt;
   F/ &lt;9.0.1&gt;
  mu &lt;3.0.1&gt;
  C/ &lt;a.0.1&gt;
  D/ &lt;b.0.1&gt;
   gamma &lt;c.0.1&gt;
   G/ &lt;d.0.1&gt;
    pi &lt;e.0.1&gt;
    rho &lt;f.0.1&gt;
    tau &lt;g.0.1&gt;
   H/ &lt;h.0.1&gt;
    chi &lt;i.0.1&gt;
    omega &lt;k.0.1&gt;
    psi &lt;j.0.1&gt;
 iota &lt;1.0.1&gt;
</pre><p>Once you've seen the layout of directories and files in
          your tree, you can use commands like <span class="command"><strong>svnlook
          cat</strong></span>, <span class="command"><strong>svnlook propget</strong></span>, and
          <span class="command"><strong>svnlook proplist</strong></span> to dig into the details
          of those files and directories.</p><p><span class="command"><strong>svnlook</strong></span> can perform a variety of
          other queries, displaying subsets of bits of information
          we've mentioned previously, reporting which paths were
          modified in a given revision or transaction, showing textual
          and property differences made to files and directories, and
          so on.  The following is a brief description of the current
          list of subcommands accepted by <span class="command"><strong>svnlook</strong></span>,
          and the output of those subcommands:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">author</code></span></dt><dd><p>Print the tree's author.</p></dd><dt><span class="term"><code class="literal">cat</code></span></dt><dd><p>Print the contents of a file in the tree.</p></dd><dt><span class="term"><code class="literal">changed</code></span></dt><dd><p>List all files and directories that changed in the
                tree.</p></dd><dt><span class="term"><code class="literal">date</code></span></dt><dd><p>Print the tree's datestamp.</p></dd><dt><span class="term"><code class="literal">diff</code></span></dt><dd><p>Print unified diffs of changed files.</p></dd><dt><span class="term"><code class="literal">dirs-changed</code></span></dt><dd><p>List the directories in the tree that were
                themselves changed, or whose file children were
                changed.</p></dd><dt><span class="term"><code class="literal">history</code></span></dt><dd><p>Display interesting points in the history of a
                versioned path (places where modifications or copies
                occurred).</p></dd><dt><span class="term"><code class="literal">info</code></span></dt><dd><p>Print the tree's author, datestamp, log message
                character count, and log message.</p></dd><dt><span class="term"><code class="literal">lock</code></span></dt><dd><p>If a path is locked, describe the lock attributes.</p></dd><dt><span class="term"><code class="literal">log</code></span></dt><dd><p>Print the tree's log message.</p></dd><dt><span class="term"><code class="literal">propget</code></span></dt><dd><p>Print the value of a property on a path in the
                tree.</p></dd><dt><span class="term"><code class="literal">proplist</code></span></dt><dd><p>Print the names and values of properties set on paths
                in the tree.</p></dd><dt><span class="term"><code class="literal">tree</code></span></dt><dd><p>Print the tree listing, optionally revealing the
                filesystem node revision IDs associated with each
                path.</p></dd><dt><span class="term"><code class="literal">uuid</code></span></dt><dd><p>Print the repository's UUID—
                <span class="emphasis"><em>U</em></span>niversal <span class="emphasis"><em>U</em></span>nique
                <span class="emphasis"><em>ID</em></span>entifier.</p></dd><dt><span class="term"><code class="literal">youngest</code></span></dt><dd><p>Print the youngest revision number.</p></dd></dl></div></div><div class="sect3" title="svnadmin"><div class="titlepage"><div><div><h4 class="title"><a id="svn.reposadmin.maint.tk.svnadmin"></a>svnadmin</h4></div></div></div><p>The <span class="command"><strong>svnadmin</strong></span> program is the
          repository administrator's best friend.  Besides providing
          the ability to create Subversion repositories, this program
          allows you to perform several maintenance operations on
          those repositories.  The syntax of
          <span class="command"><strong>svnadmin</strong></span> is similar to that of
          <span class="command"><strong>svnlook</strong></span>:</p><pre class="screen">$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type "svnadmin help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   create
   deltify
   dump
   help (?, h)
…
</pre><p>We've already mentioned <span class="command"><strong>svnadmin</strong></span>'s
          <code class="literal">create</code> subcommand (see <a class="xref" href="#svn.reposadmin.create" title="Repository Creation and Configuration">«Repository Creation and Configuration»</a>).  Most of the others we will
          cover in more detail later in this chapter.  For now, let's
          just take a quick glance at what each of the available
          subcommands offers.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">create</code></span></dt><dd><p>Create a new Subversion repository.</p></dd><dt><span class="term"><code class="literal">deltify</code></span></dt><dd><p>Run over a specified revision range, performing
                predecessor deltification on the paths changed in
                those revisions.  If no revisions are specified, this
                command will simply deltify the
                <code class="literal">HEAD</code> revision.</p></dd><dt><span class="term"><code class="literal">dump</code></span></dt><dd><p>Dump the contents of the repository, bounded by a
                given set of revisions, using a portable dump format.</p></dd><dt><span class="term"><code class="literal">hotcopy</code></span></dt><dd><p>Make a hot copy of a repository.  You can run
                this command at any time and make a safe copy of the
                repository, regardless if other processes are using
                the repository.</p></dd><dt><span class="term"><code class="literal">list-dblogs</code></span></dt><dd><p>(Berkeley DB repositories only.)  List the paths
                of Berkeley DB log files associated with the
                repository.  This list includes all log
                files—those still in use by Subversion, as well
                as those no longer in use.</p></dd><dt><span class="term"><code class="literal">list-unused-dblogs</code></span></dt><dd><p>(Berkeley DB repositories only.)  List the paths
                of Berkeley DB log files associated with, but no
                longer used by, the repository.  You may safely remove
                these log files from the repository layout, possibly
                archiving them for use in the event that you ever need
                to perform a catastrophic recovery of the
                repository.</p></dd><dt><span class="term"><code class="literal">load</code></span></dt><dd><p>Load a set of revisions into a repository from a
                stream of data that uses the same portable dump format
                generated by the <code class="literal">dump</code> subcommand.</p></dd><dt><span class="term"><code class="literal">lslocks</code></span></dt><dd><p>List and describe any locks that exist in the
                repository.</p></dd><dt><span class="term"><code class="literal">lstxns</code></span></dt><dd><p>List the names of uncommitted Subversion
                transactions that currently exist in the repository.</p></dd><dt><span class="term"><code class="literal">recover</code></span></dt><dd><p>Perform recovery steps on a repository that is in
                need of such, generally after a fatal error has
                occurred that prevented a process from cleanly
                shutting down its communication with the repository.</p></dd><dt><span class="term"><code class="literal">rmlocks</code></span></dt><dd><p>Unconditionally remove locks from listed
                paths.</p></dd><dt><span class="term"><code class="literal">rmtxns</code></span></dt><dd><p>Cleanly remove Subversion transactions from the
                repository (conveniently fed by output from the
                <code class="literal">lstxns</code> subcommand).</p></dd><dt><span class="term"><code class="literal">setlog</code></span></dt><dd><p>Replace the current value of the
                <code class="literal">svn:log</code> (commit log message)
                property on a given revision in the repository with a
                new value.</p></dd><dt><span class="term"><code class="literal">verify</code></span></dt><dd><p>Verify the contents of the repository.  This includes,
                among other things, checksum comparisons of the
                versioned data stored in the repository.</p></dd></dl></div></div><div class="sect3" title="svndumpfilter"><div class="titlepage"><div><div><h4 class="title"><a id="svn.reposadmin.maint.tk.svndumpfilter"></a>svndumpfilter</h4></div></div></div><p>Since Subversion stores everything in an opaque database
          system, attempting manual tweaks is unwise, if not quite
          difficult.  And once data has been stored in your
          repository, Subversion generally doesn't provide an
          easy way to remove that data.
          <sup>[<a id="idp12734544" href="#ftn.idp12734544" class="footnote">32</a>]</sup>
          But inevitably, there will be times when you would like to
          manipulate the history of your repository.  You might need
          to strip out all instances of a file that was accidentally
          added to the repository (and shouldn't be there for whatever
          reason).  Or, perhaps you have multiple projects sharing a
          single repository, and you decide to split them up into
          their own repositories.  To accomplish tasks like this,
          administrators need a more manageable and malleable
          representation of the data in their repositories—the
          Subversion repository dump format.</p><p>The Subversion repository dump format is a
          human-readable representation of the changes that you've
          made to your versioned data over time.  You use the
          <span class="command"><strong>svnadmin dump</strong></span> command to generate the
          dump data, and <span class="command"><strong>svnadmin load</strong></span> to populate
          a new repository with it (see <a class="xref" href="#svn.reposadmin.maint.migrate" title="Migrating a Repository">«Migrating a Repository»</a>).  The great thing about the
          human-readability aspect of the dump format is that, if you
          aren't careless about it, you can manually inspect and
          modify it.  Of course, the downside is that if you have two
          years' worth of repository activity encapsulated in what is
          likely to be a very large dump file, it could take you a
          long, long time to manually inspect and modify it.</p><p>While it won't be the most commonly used tool at the
          administrator's disposal, <span class="command"><strong>svndumpfilter</strong></span>
          provides a very particular brand of useful
          functionality—the ability to quickly and easily modify
          that dump data by acting as a path-based filter.  Simply
          give it either a list of paths you wish to keep, or a list
          of paths you wish to not keep, then pipe your repository
          dump data through this filter.  The result will be a
          modified stream of dump data that contains only the
          versioned paths you (explicitly or implicitly) requested.</p><p>The syntax of <span class="command"><strong>svndumpfilter</strong></span> is as
          follows:</p><pre class="screen">$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type "svndumpfilter help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   exclude
   include
   help (?, h)
</pre><p>There are only two interesting subcommands.  They allow
          you to make the choice between explicit or implicit
          inclusion of paths in the stream:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">exclude</code></span></dt><dd><p>Filter out a set of paths from the dump data
                stream.</p></dd><dt><span class="term"><code class="literal">include</code></span></dt><dd><p>Allow only the requested set of paths to pass
                through the dump data stream.</p></dd></dl></div><p>Let's look a realistic example of how you might use this
          program.  We discuss elsewhere (see <a class="xref" href="#svn.reposadmin.projects.chooselayout" title="Choosing a Repository Layout">«Choosing a Repository Layout»</a>) the process of deciding how to
          choose a layout for the data in your
          repositories—using one repository per project or
          combining them, arranging stuff within your repository, and
          so on.  But sometimes after new revisions start flying in,
          you rethink your layout and would like to make some changes.
          A common change is the decision to move multiple projects
          which are sharing a single repository into separate
          repositories for each project.</p><p>Our imaginary repository contains three projects:
          <code class="literal">calc</code>, <code class="literal">calendar</code>, and
          <code class="literal">spreadsheet</code>.  They have been living
          side-by-side in a layout like this:</p><pre class="screen">/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</pre><p>To get these three projects into their own repositories,
          we first dump the whole repository:</p><pre class="screen">$ svnadmin dump /path/to/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
…
$
</pre><p>Next, run that dump file through the filter, each time
          including only one of our top-level directories, and
          resulting in three new dump files:</p><pre class="screen">$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile
…
$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile
…
$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile
…
$
</pre><p>At this point, you have to make a decision.  Each of
          your dump files will create a valid repository,
          but will preserve the paths exactly as they were in the
          original repository.  This means that even though you would
          have a repository solely for your <code class="literal">calc</code>
          project, that repository would still have a top-level
          directory named <code class="filename">calc</code>.  If you want
          your <code class="filename">trunk</code>, <code class="filename">tags</code>,
          and <code class="filename">branches</code> directories to live in the
          root of your repository, you might wish to edit your
          dump files, tweaking the <code class="literal">Node-path</code> and
          <code class="literal">Node-copyfrom-path</code> headers to no longer have
          that first <code class="filename">calc/</code> path component.  Also,
          you'll want to remove the section of dump data that creates
          the <code class="filename">calc</code> directory.  It will look
          something like:</p><pre class="screen">Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0

</pre><div class="warning" title="Предупреждение" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Предупреждение]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/warning.png"></td><th align="left">Предупреждение</th></tr><tr><td valign="top" align="left"><p>If you do plan on manually editing the dump file to
            remove a top-level directory, make sure that your editor is
            not set to automatically convert end-lines to the native
            format (e.g. \r\n to \n) as the content will then not agree
            with the metadata and this will render the dump file
            useless.</p></td></tr></tbody></table></div><p>All that remains now is to create your three new
          repositories, and load each dump file into the right
          repository:</p><pre class="screen">$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
…
$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
…
$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
…
$
</pre><p>Both of <span class="command"><strong>svndumpfilter</strong></span>'s subcommands
          accept options for deciding how to deal with
          <span class="quote">«<span class="quote">empty</span>»</span> revisions.  If a given revision
          contained only changes to paths that were filtered out, that
          now-empty revision could be considered uninteresting or even
          unwanted.  So to give the user control over what to do with
          those revisions, <span class="command"><strong>svndumpfilter</strong></span> provides
          the following command-line options:</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--drop-empty-revs</code></span></dt><dd><p>Do not generate empty revisions at all—just
                omit them.</p></dd><dt><span class="term"><code class="option">--renumber-revs</code></span></dt><dd><p>If empty revisions are dropped (using the
                <code class="option">--drop-empty-revs</code> option), change the
                revision numbers of the remaining revisions so that
                there are no gaps in the numeric sequence.</p></dd><dt><span class="term"><code class="option">--preserve-revprops</code></span></dt><dd><p>If empty revisions are not dropped, preserve the
                revision properties (log message, author, date, custom
                properties, etc.) for those empty revisions.
                Otherwise, empty revisions will only contain the
                original datestamp, and a generated log message that
                indicates that this revision was emptied by
                <span class="command"><strong>svndumpfilter</strong></span>.</p></dd></dl></div><p>While <span class="command"><strong>svndumpfilter</strong></span> can be very
          useful, and a huge timesaver, there are unfortunately a
          couple of gotchas.  First, this utility is overly sensitive
          to path semantics.  Pay attention to whether paths in your
          dump file are specified with or without leading slashes.
          You'll want to look at the <code class="literal">Node-path</code> and
          <code class="literal">Node-copyfrom-path</code> headers.</p><pre class="screen">…
Node-path: spreadsheet/Makefile
…
</pre><p>If the paths have leading slashes, you should
          include leading slashes in the paths you pass to
          <span class="command"><strong>svndumpfilter include</strong></span> and
          <span class="command"><strong>svndumpfilter exclude</strong></span> (and if they don't,
          you shouldn't).  Further, if your dump file has an inconsistent
          usage of leading slashes for some reason,
          <sup>[<a id="idp12783792" href="#ftn.idp12783792" class="footnote">33</a>]</sup>
          you should probably normalize those paths so they all
          have, or lack, leading slashes.</p><p>Also, copied paths can give you some trouble.
          Subversion supports copy operations in the repository, where
          a new path is created by copying some already existing path.
          It is possible that at some point in the lifetime of your
          repository, you might have copied a file or directory from
          some location that <span class="command"><strong>svndumpfilter</strong></span> is
          excluding, to a location that it is including.  In order to
          make the dump data self-sufficient,
          <span class="command"><strong>svndumpfilter</strong></span> needs to still show the
          addition of the new path—including the contents of any
          files created by the copy—and not represent that
          addition as a copy from a source that won't exist in your
          filtered dump data stream.  But because the Subversion
          repository dump format only shows what was changed in each
          revision, the contents of the copy source might not be
          readily available.  If you suspect that you have any copies
          of this sort in your repository, you might want to rethink
          your set of included/excluded paths.</p></div><div class="sect3" title="Berkeley DB Utilities"><div class="titlepage"><div><div><h4 class="title"><a id="svn.reposadmin.maint.tk.bdbutil"></a>Berkeley DB Utilities</h4></div></div></div><p>If you're using a Berkeley DB repository, then all of
          your versioned filesystem's structure and data live in a set
          of database tables within the <code class="filename">db</code>
          subdirectory of your repository.  This subdirectory is a
          regular Berkeley DB environment directory, and can therefore
          be used in conjunction with any of the Berkeley database
          tools (you can see the documentation for these tools at
          Sleepycat's website,
          <a class="ulink" href="http://www.sleepycat.com/" target="_top">http://www.sleepycat.com/</a>).</p><p>For day-to-day Subversion use, these tools are
          unnecessary.  Most of the functionality typically needed for
          Subversion repositories has been duplicated in the
          <span class="command"><strong>svnadmin</strong></span> tool.  For example,
          <span class="command"><strong>svnadmin list-unused-dblogs</strong></span> and
          <span class="command"><strong>svnadmin list-dblogs</strong></span> perform a
          subset of what is provided by the Berkeley
          <span class="command"><strong>db_archive</strong></span> command, and <span class="command"><strong>svnadmin
          recover</strong></span> reflects the common use cases of the
          <span class="command"><strong>db_recover</strong></span> utility.</p><p>There are still a few Berkeley DB utilities that you
          might find useful.  The <span class="command"><strong>db_dump</strong></span> and
          <span class="command"><strong>db_load</strong></span> programs write and read,
          respectively, a custom file format which describes the keys
          and values in a Berkeley DB database.  Since Berkeley
          databases are not portable across machine architectures,
          this format is a useful way to transfer those databases from
          machine to machine, irrespective of architecture or
          operating system.  Also, the <span class="command"><strong>db_stat</strong></span>
          utility can provide useful information about the status of
          your Berkeley DB environment, including detailed statistics
          about the locking and storage subsystems.</p></div></div><div class="sect2" title="Repository Cleanup"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.maint.cleanup"></a>Repository Cleanup</h3></div></div></div><p>Your Subversion repository will generally require very
        little attention once it is configured to your liking.
        However, there are times when some manual assistance from an
        administrator might be in order.  The
        <span class="command"><strong>svnadmin</strong></span> utility provides some helpful
        functionality to assist you in performing such tasks as:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>modifying commit log messages,</p></li><li class="listitem"><p>removing dead transactions,</p></li><li class="listitem"><p>recovering <span class="quote">«<span class="quote">wedged</span>»</span> repositories, and</p></li><li class="listitem"><p>migrating repository contents to a different
            repository.</p></li></ul></div><p>Perhaps the most commonly used of
        <span class="command"><strong>svnadmin</strong></span>'s subcommands is
        <code class="literal">setlog</code>.  When a transaction is committed to
        the repository and promoted to a revision, the descriptive log
        message associated with that new revision (and provided by the
        user) is stored as an unversioned property attached to the
        revision itself.  In other words, the repository remembers
        only the latest value of the property, and discards previous
        ones.</p><p>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        <code class="literal">pre-revprop-change</code> and
        <code class="literal">post-revprop-change</code> hooks; see <a class="xref" href="#svn.reposadmin.create.hooks" title="Hook Scripts">«Hook Scripts»</a>) to accept changes to this log
        message after the commit is finished, then the user can
        <span class="quote">«<span class="quote">fix</span>»</span> her log message remotely using the
        <span class="command"><strong>svn</strong></span> program's <code class="literal">propset</code>
        command (see <a class="xref" href="#svn.ref" title="Глава 9. Полное справочное руководство по Subversion">Глава&nbsp;9, <em>Полное справочное руководство по Subversion</em></a>).  However, because of
        the potential to lose information forever, Subversion
        repositories are not, by default, configured to allow changes
        to unversioned properties—except by an administrator.</p><p>If a log message needs to be changed by an administrator,
        this can be done using <span class="command"><strong>svnadmin setlog</strong></span>.
        This command changes the log message (the
        <code class="literal">svn:log</code> property) on a given revision of a
        repository, reading the new value from a provided file.</p><pre class="screen">$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</pre><p>The <span class="command"><strong>svnadmin setlog</strong></span> command alone is
        still bound by the same protections against modifying
        unversioned properties as a remote client is—the
        <code class="literal">pre-</code> and
        <code class="literal">post-revprop-change</code> hooks are still
        triggered, and therefore must be setup to accept changes of
        this nature.  But an administrator can get around these
        protections by passing the <code class="option">--bypass-hooks</code>
        option to the <span class="command"><strong>svnadmin setlog</strong></span> command.</p><div class="warning" title="Предупреждение" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Предупреждение]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/warning.png"></td><th align="left">Предупреждение</th></tr><tr><td valign="top" align="left"><p>Remember, though, that by bypassing the hooks, you are
          likely avoiding such things as email notifications of
          property changes, backup systems which track unversioned
          property changes, and so on.  In other words, be very
          careful about what you are changing, and how you change
          it.</p></td></tr></tbody></table></div><p>Another common use of <span class="command"><strong>svnadmin</strong></span> is to
        query the repository for outstanding—possibly
        dead—Subversion transactions.  In the event that a
        commit should fail, the transaction is usually cleaned up.
        That is, the transaction itself is removed from the
        repository, and any data associated with (and only with) that
        transaction is removed as well.  Occasionally, though, a
        failure occurs in such a way that the cleanup of the
        transaction never happens.  This could happen for several
        reasons: perhaps the client operation was inelegantly
        terminated by the user, or a network failure might have
        occurred in the middle of an operation, etc.  Regardless of
        the reason, dead transactions can happen.  They don't do any
        real harm, other than consuming a small bit of disk space.  A
        fastidious administrator may nonetheless want to remove
        them.</p><p>You can use <span class="command"><strong>svnadmin</strong></span>'s
        <code class="literal">lstxns</code> command to list the names of the
        currently outstanding transactions.</p><pre class="screen">$ svnadmin lstxns myrepos
19
3a1
a45
$
</pre><p>Each item in the resultant output can then be used with
        <span class="command"><strong>svnlook</strong></span> (and its
        <code class="option">--transaction</code> option) to determine who
        created the transaction, when it was created, what types of
        changes were made in the transaction—in other words,
        whether or not the transaction is a safe candidate for
        removal!  If so, the transaction's name can be passed to
        <span class="command"><strong>svnadmin rmtxns</strong></span>, which will perform the
        cleanup of the transaction.  In fact, the
        <code class="literal">rmtxns</code> subcommand can take its input
        directly from the output of <code class="literal">lstxns</code>!</p><pre class="screen">$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</pre><p>If you use these two subcommands like this, you should
        consider making your repository temporarily inaccessible to
        clients.  That way, no one can begin a legitimate transaction
        before you start your cleanup.  The following is a little bit
        of shell-scripting that can quickly generate information about
        each outstanding transaction in your repository:</p><div class="example"><a id="svn.reposadmin.maint.cleanup.ex-1"></a><p class="title"><strong>Пример 5.1. txn-info.sh (Reporting Outstanding Transactions)</strong></p><div class="example-contents"><pre class="programlisting">#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" --transaction "${TXN}"
done
</pre></div></div><br class="example-break"><br><p>You can run the previous script using
        <span class="command"><strong>/path/to/txn-info.sh /path/to/repos</strong></span>.  The
        output is basically a concatenation of several chunks of
        <span class="command"><strong>svnlook info</strong></span> output (see <a class="xref" href="#svn.reposadmin.maint.tk.svnlook" title="svnlook">«svnlook»</a>), and will look something
        like:</p><pre class="screen">$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</pre><p>A long-abandoned transaction usually represents some sort
        of failed or interrupted commit.  A transaction's datestamp
        can provide interesting information—for example, how
        likely is it that an operation begun nine months ago is still
        active?</p><p>In short, transaction cleanup decisions need not be made
        unwisely.  Various sources of information—including
        Apache's error and access logs, the logs of successful
        Subversion commits, and so on—can be employed in the
        decision-making process.  Finally, an administrator can often
        simply communicate with a seemingly dead transaction's owner
        (via email, for example) to verify that the transaction is, in
        fact, in a zombie state.</p></div><div class="sect2" title="Managing Disk Space"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.maint.diskspace"></a>Managing Disk Space</h3></div></div></div><p>While the cost of storage has dropped incredibly in the
          past few years, disk usage is still a valid concern for
          administrators seeking to version large amounts of data.
          Every additional byte consumed by the live repository is a
          byte that needs to be backed up offsite, perhaps multiple
          times as part of rotating backup schedules.  If using a
          Berkeley DB repository, the primary storage mechanism is a
          complex database system, it is useful to know what pieces of
          data need to remain on the live site, which need to be
          backed up, and which can be safely removed.  This section is
          specific to Berkeley DB;  FSFS repositories have no extra
          data to be cleaned up or reclaimed.</p><p>Until recently, the largest offender of disk space usage
          with respect to Subversion repositories was the log files to
          which Berkeley DB performs its pre-writes before modifying
          the actual database files.  These files capture all the
          actions taken along the route of changing the database from
          one state to another—while the database files reflect
          at any given time some state, the log files contain all the
          many changes along the way between states.  As such, they
          can start to accumulate quite rapidly.</p><p>Fortunately, beginning with the 4.2 release of Berkeley
          DB, the database environment has the ability to remove its
          own unused log files without any external procedures.  Any
          repositories created using an <span class="command"><strong>svnadmin</strong></span>
          which is compiled against Berkeley DB version 4.2 or greater
          will be configured for this automatic log file removal.  If
          you don't want this feature enabled, simply pass the
          <code class="option">--bdb-log-keep</code> option to the
          <span class="command"><strong>svnadmin create</strong></span> command.  If you forget
          to do this, or change your mind at a later time, simple edit
          the <code class="filename">DB_CONFIG</code> file found in your
          repository's <code class="filename">db</code> directory, comment out
          the line which contains the <code class="literal">set_flags
          DB_LOG_AUTOREMOVE</code> directive, and then run
          <span class="command"><strong>svnadmin recover</strong></span> on your repository to
          force the configuration changes to take effect.  See <a class="xref" href="#svn.reposadmin.create.bdb" title="Berkeley DB Configuration">«Berkeley DB Configuration»</a> for more information about
          database configuration.</p><p>Without some sort of automatic log file removal in
          place, log files will accumulate as you use your repository.
          This is actually somewhat of a feature of the database
          system—you should be able to recreate your entire
          database using nothing but the log files, so these files can
          be useful for catastrophic database recovery.  But
          typically, you'll want to archive the log files that are no
          longer in use by Berkeley DB, and then remove them from disk
          to conserve space.  Use the <span class="command"><strong>svnadmin
          list-unused-dblogs</strong></span> command to list the unused
          log files:</p><pre class="screen">$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033

$ svnadmin list-unused-dblogs /path/to/repos | xargs rm
## disk space reclaimed!
</pre><p>To keep the size of the repository as small as possible,
          Subversion uses <em class="firstterm">deltification</em> (or,
          <span class="quote">«<span class="quote">deltified storage</span>»</span>) within the repository
          itself.  Deltification involves encoding the representation
          of a chunk of data as a collection of differences against
          some other chunk of data.  If the two pieces of data are
          very similar, this deltification results in storage savings
          for the deltified chunk—rather than taking up space
          equal to the size of the original data, it only takes up
          enough space to say, <span class="quote">«<span class="quote">I look just like this other
          piece of data over here, except for the following couple of
          changes</span>»</span>.  Specifically, each time a new version of a
          file is committed to the repository, Subversion encodes the
          previous version (actually, several previous versions) as a
          delta against the new version.  The result is that most of
          the repository data that tends to be sizable—namely,
          the contents of versioned files—is stored at a much
          smaller size than the original <span class="quote">«<span class="quote">fulltext</span>»</span>
          representation of that data.</p><div class="note" title="Примечание" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Примечание]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/note.png"></td><th align="left">Примечание</th></tr><tr><td valign="top" align="left"><p>Because all of the Subversion repository data that is
            subject to deltification is stored in a single Berkeley DB
            database file, reducing the size of the stored values will
            not necessarily reduce the size of the database file
            itself.  Berkeley DB will, however, keep internal records
            of unused areas of the database file, and use those areas
            first before growing the size of the database file.  So
            while deltification doesn't produce immediate space
            savings, it can drastically slow future growth of the
            database.</p></td></tr></tbody></table></div></div><div class="sect2" title="Repository Recovery"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.maint.recovery"></a>Repository Recovery</h3></div></div></div><p>As mentioned in <a class="xref" href="#svn.reposadmin.basics.backends.bdb" title="Berkeley DB">«Berkeley DB»</a>, a
        Berkeley DB repository can sometimes be left in frozen state
        if not closed properly.  When this happens, an administrator
        needs to rewind the database back into a consistent
        state.</p><p>In order to protect the data in your repository, Berkeley
        DB uses a locking mechanism.  This mechanism ensures that
        portions of the database are not simultaneously modified by
        multiple database accessors, and that each process sees the
        data in the correct state when that data is being read from
        the database.  When a process needs to change something in the
        database, it first checks for the existence of a lock on the
        target data.  If the data is not locked, the process locks the
        data, makes the change it wants to make, and then unlocks the
        data.  Other processes are forced to wait until that lock is
        removed before they are permitted to continue accessing that
        section of the database. (This has nothing to do with the
        locks that you, as a user, can apply to versioned files within
        the repository; see
        <a class="xref" href="#svn.advanced.locking.meanings" title="Three meanings of «lock»">Three meanings of <span class="quote">«<span class="quote">lock</span>»</span></a> for more
        information.)</p><p>In the course of using your Subversion repository, fatal
        errors (such as running out of disk space or available memory)
        or interruptions can prevent a process from having the chance to
        remove the locks it has placed in the database.  The result is
        that the back-end database system gets <span class="quote">«<span class="quote">wedged</span>»</span>.
        When this happens, any attempts to access the repository hang
        indefinitely (since each new accessor is waiting for a lock to
        go away—which isn't going to happen).</p><p>First, if this happens to your repository, don't panic.
        The Berkeley DB filesystem takes advantage of database
        transactions and checkpoints and pre-write journaling to
        ensure that only the most catastrophic of events
        <sup>[<a id="idp12866672" href="#ftn.idp12866672" class="footnote">34</a>]</sup>
        can permanently destroy a database environment.  A
        sufficiently paranoid repository administrator will be making
        off-site backups of the repository data in some fashion, but
        don't call your system administrator to restore a backup tape
        just yet.</p><p>Secondly, use the following recipe to attempt to
        <span class="quote">«<span class="quote">unwedge</span>»</span> your repository:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Make sure that there are no processes accessing (or
            attempting to access) the repository.  For networked
            repositories, this means shutting down the Apache HTTP
            Server, too.</p></li><li class="listitem"><p>Become the user who owns and manages the repository.
            This is important, as recovering a repository while
            running as the wrong user can tweak the permissions of the
            repository's files in such a way that your repository will
            still be inaccessible even after it is
            <span class="quote">«<span class="quote">unwedged</span>»</span>.</p></li><li class="listitem"><p>Run the command <span class="command"><strong>svnadmin recover
            /path/to/repos</strong></span>.  You should see output like
            this:</p><pre class="screen">Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</pre><p>This command may take many minutes to complete.</p></li><li class="listitem"><p>Restart the Subversion server.</p></li></ol></div><p>This procedure fixes almost every case of repository
        lock-up.  Make sure that you run this command as the user that
        owns and manages the database, not just as
        <code class="literal">root</code>.  Part of the recovery process might
        involve recreating from scratch various database files (shared
        memory regions, for example).  Recovering as
        <code class="literal">root</code> will create those files such that they
        are owned by <code class="literal">root</code>, which means that even
        after you restore connectivity to your repository, regular
        users will be unable to access it.</p><p>If the previous procedure, for some reason, does not
        successfully unwedge your repository, you should do two
        things.  First, move your broken repository out of the way and
        restore your latest backup of it.  Then, send an email to the
        Subversion user list (at
        <code class="email">&lt;<a class="email" href="mailto:users@subversion.tigris.org">users@subversion.tigris.org</a>&gt;</code>) describing your
        problem in detail.  Data integrity is an extremely high
        priority to the Subversion developers.</p></div><div class="sect2" title="Migrating a Repository"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.maint.migrate"></a>Migrating a Repository</h3></div></div></div><p>A Subversion filesystem has its data spread throughout
        various database tables in a fashion generally understood by
        (and of interest to) only the Subversion developers
        themselves.  However, circumstances may arise that call for
        all, or some subset, of that data to be collected into a
        single, portable, flat file format.  Subversion provides such
        a mechanism, implemented in a pair of
        <span class="command"><strong>svnadmin</strong></span> subcommands:
        <code class="literal">dump</code> and <code class="literal">load</code>.</p><p>The most common reason to dump and load a Subversion
        repository is due to changes in Subversion itself.  As
        Subversion matures, there are times when certain changes made
        to the back-end database schema cause Subversion to be
        incompatible with previous versions of the repository.  Other
        reasons for dumping and loading might be to migrate a Berkeley
        DB repository to a new OS or CPU architecture, or to switch
        between Berkeley DB and FSFS back-ends.  The recommended
        course of action is relatively simple:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Using your <span class="emphasis"><em>current</em></span> version of
            <span class="command"><strong>svnadmin</strong></span>, dump your repositories to
            dump files.</p></li><li class="listitem"><p>Upgrade to the new version of Subversion.</p></li><li class="listitem"><p>Move your old repositories out of the way, and create
            new empty ones in their place using your
            <span class="emphasis"><em>new</em></span> <span class="command"><strong>svnadmin</strong></span>.</p></li><li class="listitem"><p>Again using your <span class="emphasis"><em>new</em></span>
            <span class="command"><strong>svnadmin</strong></span>, load your dump files into
            their respective, just-created repositories.</p></li><li class="listitem"><p>Be sure to copy any customizations from your old
            repositories to the new ones, including
            <code class="filename">DB_CONFIG</code> files and hook scripts.
            You'll want to pay attention to the release notes for the
            new release of Subversion to see if any changes since your
            last upgrade affect those hooks or configuration
            options.</p></li><li class="listitem"><p>If the migration process made your repository
            accessible at a different URL (e.g. moved to a different
            computer, or is being accessed via a different schema),
            then you'll probably want to tell your users to run
            <span class="command"><strong>svn switch --relocate</strong></span> on their existing
            working copies.  See <a class="xref" href="#svn.ref.svn.c.switch" title="svn switch">svn switch</a>.</p></li></ol></div><p><span class="command"><strong>svnadmin dump</strong></span> will output a range of
        repository revisions that are formatted using Subversion's
        custom filesystem dump format.  The dump format is printed to
        the standard output stream, while informative messages are
        printed to the standard error stream.  This allows you to
        redirect the output stream to a file while watching the status
        output in your terminal window.  For example:</p><pre class="screen">$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
…
* Dumped revision 25.
* Dumped revision 26.
</pre><p>At the end of the process, you will have a single file
        (<code class="filename">dumpfile</code> in the previous example) that
        contains all the data stored in your repository in the
        requested range of revisions.  Note that <span class="command"><strong>svnadmin
        dump</strong></span> is reading revision trees from the repository
        just like any other <span class="quote">«<span class="quote">reader</span>»</span> process would
        (<span class="command"><strong>svn checkout</strong></span>, for example).  So it's safe
        to run this command at any time.</p><p>The other subcommand in the pair, <span class="command"><strong>svnadmin
        load</strong></span>, parses the standard input stream as a
        Subversion repository dump file, and effectively replays those
        dumped revisions into the target repository for that
        operation.  It also gives informative feedback, this time
        using the standard output stream:</p><pre class="screen">$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     …
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

…

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</pre><p>The result of a load is new revisions added to a
        repository—the same thing you get by making commits
        against that repository from a regular Subversion client.  And
        just as in a commit, you can use hook scripts to perform
        actions before and after each of the commits made during a load
        process.  By passing the <code class="option">--use-pre-commit-hook</code>
        and <code class="option">--use-post-commit-hook</code> options to
        <span class="command"><strong>svnadmin load</strong></span>, you can instruct Subversion
        to execute the pre-commit and post-commit hook scripts,
        respectively, for each loaded revision.  You might use these,
        for example, to ensure that loaded revisions pass through the
        same validation steps that regular commits pass through.  Of
        course, you should use these options with care—if your
        post-commit hook sends emails to a mailing list for each new
        commit, you might not want to spew hundreds or thousands of
        commit emails in rapid succession at that list for each of the
        loaded revisions!  You can read more about the use of hook
        scripts in <a class="xref" href="#svn.reposadmin.create.hooks" title="Hook Scripts">«Hook Scripts»</a>.</p><p>Note that because <span class="command"><strong>svnadmin</strong></span> uses
        standard input and output streams for the repository dump and
        load process, people who are feeling especially saucy can try
        things like this (perhaps even using different versions of
        <span class="command"><strong>svnadmin</strong></span> on each side of the pipe):</p><pre class="screen">$ svnadmin create newrepos
$ svnadmin dump myrepos | svnadmin load newrepos
</pre><p>By default, the dump file will be quite large—much
        larger than the repository itself.  That's because every
        version of every file is expressed as a full text in the
        dump file.  This is the fastest and simplest behavior, and nice
        if you're piping the dump data directly into some other
        process (such as a compression program, filtering program, or
        into a loading process).  But if you're creating a dump file for
        longer-term storage, you'll likely want to save disk space by
        using the <code class="option">--deltas</code> switch.  With this option,
        successive revisions of files will be output as compressed,
        binary differences—just as file revisions are stored in
        a repository.  This option is slower, but results in a
        dump file much closer in size to the original
        repository.</p><p>We mentioned previously that <span class="command"><strong>svnadmin
        dump</strong></span> outputs a range of revisions.  Use the
        <code class="option">--revision</code> option to specify a single
        revision to dump, or a range of revisions.  If you omit this
        option, all the existing repository revisions will be
        dumped.</p><pre class="screen">$ svnadmin dump myrepos --revision 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos --revision 100:200 &gt; revs-100-200.dumpfile
</pre><p>As Subversion dumps each new revision, it outputs only
        enough information to allow a future loader to re-create that
        revision based on the previous one.  In other words, for any
        given revision in the dump file, only the items that were
        changed in that revision will appear in the dump.  The only
        exception to this rule is the first revision that is dumped
        with the current <span class="command"><strong>svnadmin dump</strong></span>
        command.</p><p>By default, Subversion will not express the first dumped
        revision as merely differences to be applied to the previous
        revision.  For one thing, there is no previous revision in the
        dump file!  And secondly, Subversion cannot know the state of
        the repository into which the dump data will be loaded (if it
        ever, in fact, occurs).  To ensure that the output of each
        execution of <span class="command"><strong>svnadmin dump</strong></span> is
        self-sufficient, the first dumped revision is by default a
        full representation of every directory, file, and property in
        that revision of the repository.</p><p>However, you can change this default behavior.  If you add
        the <code class="option">--incremental</code> option when you dump your
        repository, <span class="command"><strong>svnadmin</strong></span> will compare the first
        dumped revision against the previous revision in the
        repository, the same way it treats every other revision that
        gets dumped.  It will then output the first revision exactly
        as it does the rest of the revisions in the dump
        range—mentioning only the changes that occurred in that
        revision.  The benefit of this is that you can create several
        small dump files that can be loaded in succession, instead of
        one large one, like so:</p><pre class="screen">$ svnadmin dump myrepos --revision 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos --revision 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos --revision 2001:3000 --incremental &gt; dumpfile3
</pre><p>These dump files could be loaded into a new repository with
        the following command sequence:</p><pre class="screen">$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</pre><p>Another neat trick you can perform with this
        <code class="option">--incremental</code> option involves appending to an
        existing dump file a new range of dumped revisions.  For
        example, you might have a <code class="literal">post-commit</code> hook
        that simply appends the repository dump of the single revision
        that triggered the hook.  Or you might have a script that runs
        nightly to append dump file data for all the revisions that
        were added to the repository since the last time the script
        ran.  Used like this, <span class="command"><strong>svnadmin</strong></span>'s
        <code class="literal">dump</code> and <code class="literal">load</code> commands
        can be a valuable means by which to backup changes to your
        repository over time in case of a system crash or some other
        catastrophic event.</p><p>The dump format can also be used to merge the contents of
        several different repositories into a single repository.  By
        using the <code class="option">--parent-dir</code> option of <span class="command"><strong>svnadmin
        load</strong></span>, you can specify a new virtual root directory
        for the load process.  That means if you have dump files for
        three repositories, say <code class="filename">calc-dumpfile</code>,
        <code class="filename">cal-dumpfile</code>, and
        <code class="filename">ss-dumpfile</code>, you can first create a new
        repository to hold them all:</p><pre class="screen">$ svnadmin create /path/to/projects
$
</pre><p>Then, make new directories in the repository which will
        encapsulate the contents of each of the three previous
        repositories:</p><pre class="screen">$ svn mkdir -m "Initial project roots" \
      file:///path/to/projects/calc \
      file:///path/to/projects/calendar \
      file:///path/to/projects/spreadsheet
Committed revision 1.
$
</pre><p>Lastly, load the individual dump files into their
        respective locations in the new repository:</p><pre class="screen">$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile
…
$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile
…
$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile
…
$
</pre><p>We'll mention one final way to use the Subversion
        repository dump format—conversion from a different
        storage mechanism or version control system altogether.
        Because the dump file format is, for the most part,
        human-readable,
        <sup>[<a id="idp12922336" href="#ftn.idp12922336" class="footnote">35</a>]</sup>
        it should be relatively easy to describe generic sets of
        changes—each of which should be treated as a new
        revision—using this file format.  In fact, the
        <span class="command"><strong>cvs2svn</strong></span> utility (see <a class="xref" href="#svn.forcvs.convert" title="Converting a Repository from CVS to Subversion">«Converting a Repository from CVS to Subversion»</a>) uses the dump format to represent the
        contents of a CVS repository so that those contents can be
        copied into a Subversion repository.</p></div><div class="sect2" title="Repository Backup"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.maint.backup"></a>Repository Backup</h3></div></div></div><p>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity—sometimes, things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic—how to make backup copies of your repository
        data.</p><p>There are generally two types of backup methods available
        for Subversion repository administrators—incremental and
        full.  We discussed in an earlier section of this chapter how
        to use <span class="command"><strong>svnadmin dump --incremental</strong></span> to
        perform an incremental backup (see <a class="xref" href="#svn.reposadmin.maint.migrate" title="Migrating a Repository">«Migrating a Repository»</a>).  Essentially, the idea is to
        only backup at a given time the changes to the repository
        since the last time you made a backup.</p><p>A full backup of the repository is quite literally a
        duplication of the entire repository directory (which includes
        either Berkeley database or FSFS environment).  Now, unless
        you temporarily disable all other access to your repository,
        simply doing a recursive directory copy runs the risk of
        generating a faulty backup, since someone might be currently
        writing to the database.</p><p>In the case of Berkeley DB, Sleepycat documents describe a
        certain order in which database files can be copied that will
        guarantee a valid backup copy.  And a similar ordering exists
        for FSFS data.  Better still, you don't have to implement
        these algorithms yourself, because the Subversion development
        team has already done so.  The
        <span class="command"><strong>hot-backup.py</strong></span> script is found in the
        <code class="filename">tools/backup/</code> directory of the Subversion
        source distribution.  Given a repository path and a backup
        location, <span class="command"><strong>hot-backup.py</strong></span>—which is
        really just a more intelligent wrapper around the
        <span class="command"><strong>svnadmin hotcopy</strong></span> command—will perform
        the necessary steps for backing up your live
        repository—without requiring that you bar public
        repository access at all—and then will clean out the
        dead Berkeley log files from your live repository.</p><p>Even if you also have an incremental backup, you might
        want to run this program on a regular basis.  For example, you
        might consider adding <span class="command"><strong>hot-backup.py</strong></span> to a
        program scheduler (such as <span class="command"><strong>cron</strong></span> on Unix
        systems).  Or, if you prefer fine-grained backup solutions,
        you could have your post-commit hook script call
        <span class="command"><strong>hot-backup.py</strong></span> (see <a class="xref" href="#svn.reposadmin.create.hooks" title="Hook Scripts">«Hook Scripts»</a>), which will then cause a new
        backup of your repository to occur with every new revision
        created.  Simply add the following to the
        <code class="filename">hooks/post-commit</code> script in your live
        repository directory:</p><pre class="programlisting">(cd /path/to/hook/scripts; ./hot-backup.py ${REPOS} /path/to/backups &amp;)
</pre><p>The resulting backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</p><p>There are benefits to both types of backup methods.  The
        easiest is by far the full backup, which will always result in
        a perfect working replica of your repository.  This again
        means that should something bad happen to your live
        repository, you can restore from the backup with a simple
        recursive directory copy.  Unfortunately, if you are
        maintaining multiple backups of your repository, these full
        copies will each eat up just as much disk space as your live
        repository.</p><p>Incremental backups using the repository dump format are
        excellent to have on hand if the database schema changes
        between successive versions of Subversion itself.  Since a
        complete repository dump and load are generally required to
        upgrade your repository to the new schema, it's very
        convenient to already have half of that process (the dump
        part) finished.  Unfortunately, the creation of—and
        restoration from—incremental backups takes longer, as
        each commit is effectively replayed into either the dump file
        or the repository.</p><p>In either backup scenario, repository administrators need
        to be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change hooks.
        <sup>[<a id="idp12957440" href="#ftn.idp12957440" class="footnote">36</a>]</sup>
        And since you can change revision properties without respect
        to chronological order—you can change any revision's
        properties at any time—an incremental backup of the
        latest few revisions might not catch a property modification
        to a revision that was included as part of a previous
        backup.</p><p>Generally speaking, only the truly paranoid would need to
        backup their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (like per-commit emails), a hot backup of the
        database might be something that a repository administrator
        would want to include as part of a system-wide nightly backup.
        For most repositories, archived commit emails alone provide
        sufficient redundancy as restoration sources, at least for the
        most recent few commits.  But it's your data—protect it
        as much as you'd like.</p><p>Often, the best approach to repository backups is a
        diversified one.  You can leverage combinations of full and
        incremental backups, plus archives of commit emails.  The
        Subversion developers, for example, back up the Subversion
        source code repository after every new revision is created,
        and keep an archive of all the commit and property change
        notification emails.  Your solution might be similar, but
        should be catered to your needs and that delicate balance of
        convenience with paranoia.  And while all of this might not
        save your hardware from the iron fist of Fate,
        <sup>[<a id="idp12961152" href="#ftn.idp12961152" class="footnote">37</a>]</sup>
        it should certainly help you recover from those trying
        times.</p></div></div><div class="sect1" title="Adding Projects"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.reposadmin.projects"></a>Adding Projects</h2></div></div></div><p>Once your repository is created and configured, all that
      remains is to begin using it.  If you have a collection of
      existing data that is ready to be placed under version control,
      you will more than likely want to use the <span class="command"><strong>svn</strong></span>
      client program's <code class="literal">import</code> subcommand to
      accomplish that.  Before doing this, though, you should
      carefully consider your long-term plans for the repository.  In
      this section, we will offer some advice on how to plan the
      layout of your repository, and how to get your data arranged in
      that layout.</p><div class="sect2" title="Choosing a Repository Layout"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.projects.chooselayout"></a>Choosing a Repository Layout</h3></div></div></div><p>While Subversion allows you to move around versioned files
        and directories without any loss of information, doing so can
        still disrupt the workflow of those who access the repository
        often and come to expect things to be at certain locations.
        Try to peer into the future a bit; plan ahead before placing
        your data under version control.  By <span class="quote">«<span class="quote">laying out</span>»</span>
        the contents of your repositories in an effective manner the
        first time, you can prevent a load of future headaches.</p><p>There are a few things to consider when setting up
        Subversion repositories.  Let's assume that as repository
        administrator, you will be responsible for supporting the
        version control system for several projects.  The first
        decision is whether to use a single repository for multiple
        projects, or to give each project its own repository, or some
        compromise of these two.</p><p>There are benefits to using a single repository for
        multiple projects, most obviously the lack of duplicated
        maintenance.  A single repository means that there is one set
        of hook scripts, one thing to routinely backup, one thing to
        dump and load if Subversion releases an incompatible new
        version, and so on.  Also, you can move data between projects
        easily, and without losing any historical versioning
        information.</p><p>The downside of using a single repository is that
        different projects may have different commit mailing lists or
        different authentication and authorization requirements.
        Also, remember that Subversion uses repository-global revision
        numbers.  Some folks don't like the fact that even though no
        changes have been made to their project lately, the youngest
        revision number for the repository keeps climbing because
        other projects are actively adding new revisions.</p><p>A middle-ground approach can be taken, too.  For example,
        projects can be grouped by how well they relate to each other.
        You might have a few repositories with a handful of projects
        in each repository.  That way, projects that are likely to
        want to share data can do so easily, and as new revisions are
        added to the repository, at least the developers know that
        those new revisions are at least remotely related to everyone
        who uses that repository.</p><p>After deciding how to organize your projects with respect
        to repositories, you'll probably want to think about directory
        hierarchies in the repositories themselves.  Because
        Subversion uses regular directory copies for branching and
        tagging (see <a class="xref" href="#svn.branchmerge" title="Глава 4. Ветвление и слияние">Глава&nbsp;4, <em>Ветвление и слияние</em></a>), the Subversion
        community recommends that you choose a repository location for
        each <em class="firstterm">project root</em>—the
        <span class="quote">«<span class="quote">top-most</span>»</span> directory which contains data related
        to that project—and then create three subdirectories
        beneath that root: <code class="filename">trunk</code>, meaning the
        directory under which the main project development occurs;
        <code class="filename">branches</code>, which is a directory in which
        to create various named branches of the main development line;
        <code class="filename">tags</code>, which is a directory of branches
        that are created, and perhaps destroyed, but never
        changed.
        <sup>[<a id="idp12979888" href="#ftn.idp12979888" class="footnote">38</a>]</sup>
        </p><p>For example, your repository might look like:</p><pre class="screen">/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   …
</pre><p>Note that it doesn't matter where in your repository each
        project root is.  If you have only one project per repository,
        the logical place to put each project root is at the root of
        that project's respective repository.  If you have multiple
        projects, you might want to arrange them in groups inside the
        repository, perhaps putting projects with similar goals or
        shared code in the same subdirectory, or maybe just grouping
        them alphabetically.  Such an arrangement might look
        like:</p><pre class="screen">/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      …
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      …
</pre><p>Lay out your repository in whatever way you see fit.
        Subversion does not expect or enforce a layout schema—in
        its eyes, a directory is a directory is a directory.
        Ultimately, you should choose the repository arrangement that
        meets the needs of the people who work on the projects that
        live there.</p></div><div class="sect2" title="Creating the Layout, and Importing Initial Data"><div class="titlepage"><div><div><h3 class="title"><a id="svn.reposadmin.projects.import"></a>Creating the Layout, and Importing Initial Data</h3></div></div></div><p>After deciding how to arrange the projects in your
        repository, you'll probably want to actually populate the
        repository with that layout and with initial project data.
        There are a couple of ways to do this in Subversion.  You
        could use the <span class="command"><strong>svn mkdir</strong></span> command (see <a class="xref" href="#svn.ref" title="Глава 9. Полное справочное руководство по Subversion">Глава&nbsp;9, <em>Полное справочное руководство по Subversion</em></a>) to create each directory in your
        skeletal repository layout, one-by-one.  A quicker way to
        accomplish the same task is to use the <span class="command"><strong>svn
        import</strong></span> command (see <a class="xref" href="#svn.tour.other.import" title="svn import">«<span class="command"><strong>svn import</strong></span>»</a>).  By first creating the layout
        in a temporary location on your drive, you can import the
        whole layout tree into the repository in a single
        commit:</p><pre class="screen">$ mkdir tmpdir
$ cd tmpdir
$ mkdir projectA
$ mkdir projectA/trunk
$ mkdir projectA/branches
$ mkdir projectA/tags
$ mkdir projectB
$ mkdir projectB/trunk
$ mkdir projectB/branches
$ mkdir projectB/tags
…
$ svn import . file:///path/to/repos --message "Initial repository layout"
Adding         projectA
Adding         projectA/trunk
Adding         projectA/branches
Adding         projectA/tags
Adding         projectB
Adding         projectB/trunk
Adding         projectB/branches
Adding         projectB/tags
…
Committed revision 1.
$ cd ..
$ rm -rf tmpdir
$
</pre><p>You can verify the results of the import by running the
        <span class="command"><strong>svn list</strong></span> command:</p><pre class="screen">$ svn list --verbose file:///path/to/repos
      1 harry               May 08 21:48 projectA/
      1 harry               May 08 21:48 projectB/
…
$
</pre><p>Once you have your skeletal layout in place, you can begin
        importing actual project data into your repository, if any
        such data exists yet.  Once again, there are several ways to
        do this.  You could use the <span class="command"><strong>svn import</strong></span>
        command.  You could checkout a working copy from your new
        repository, move and arrange project data inside the working
        copy, and use the <span class="command"><strong>svn add</strong></span> and <span class="command"><strong>svn
        commit</strong></span> commands.  But once we start talking about
        such things, we're no longer discussing repository
        administration.  If you aren't already familiar with the
        <span class="command"><strong>svn</strong></span> client program, see <a class="xref" href="#svn.tour" title="Глава 2. Экскурсия по Subversion">Глава&nbsp;2, <em>Экскурсия по Subversion</em></a>.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.reposadmin.summary"></a>Summary</h2></div></div></div><p>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We've
      introduced you to the various tools that will assist you with
      this task.  Throughout the chapter, we've noted common
      administration pitfalls, and suggestions for avoiding
      them.</p><p>All that remains is for you to decide what exciting data to
      store in your repository, and finally, how to make it available
      over a network.  The next chapter is all about networking.</p></div><div class="footnotes"><br><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.idp12427408" href="#idp12427408" class="para">30</a>] </sup>This may sound really prestigious and lofty, but we're
        just talking about anyone who is interested in that
        mysterious realm beyond the working copy where everyone's
        data hangs out.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp12450256" href="#idp12450256" class="para">31</a>] </sup>Pronounced <span class="quote">«<span class="quote">fuzz-fuzz</span>»</span>, if Jack
            Repenning has anything to say about it.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp12734544" href="#idp12734544" class="para">32</a>] </sup>That, by the way, is a <span class="emphasis"><em>feature</em></span>,
              not a bug.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp12783792" href="#idp12783792" class="para">33</a>] </sup>While <span class="command"><strong>svnadmin dump</strong></span> has a
              consistent leading slash policy—to not include
              them—other programs which generate dump data might
              not be so consistent.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp12866672" href="#idp12866672" class="para">34</a>] </sup>E.g.: hard drive + huge electromagnet = disaster.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp12922336" href="#idp12922336" class="para">35</a>] </sup>The Subversion repository dump format resembles
            an RFC-822 format, the same type of format used for most
            email.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp12957440" href="#idp12957440" class="para">36</a>] </sup><span class="command"><strong>svnadmin setlog</strong></span> can be called in a
            way that bypasses the hook interface altogether.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp12961152" href="#idp12961152" class="para">37</a>] </sup>You know—the collective term for all of her
            <span class="quote">«<span class="quote">fickle fingers</span>»</span>.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp12979888" href="#idp12979888" class="para">38</a>] </sup>The <code class="filename">trunk</code>, <code class="filename">tags</code>, 
            and <code class="filename">branches</code> trio are sometimes referred
            to as <span class="quote">«<span class="quote">the TTB directories</span>»</span>.</p></div></div></div><div class="chapter" title="Глава 6. Настройка сервера"><div class="titlepage"><div><div><h2 class="title"><a id="svn.serverconfig"></a>Глава 6. Настройка сервера</h2></div></div></div><div class="toc"><p><strong>Содержание</strong></p><dl><dt><span class="sect1"><a href="#svn.serverconfig.overview">Обзор</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.serverconfig.overview.apache">Http-сервер Apache</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.overview.svnserve">Сервер <span class="command"><strong>svnserve</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.overview.svn-ssh"><span class="command"><strong>svnserve</strong></span> через SSH</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.overview.choosing-a-server">Выбор лучшей конфигурации сервера</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.serverconfig.netmodel">Сетевая модель</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.serverconfig.netmodel.reqresp">Запросы и отклики</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.netmodel.credcache">Кэширование клиентской идентификационной информации</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.serverconfig.svnserve">Собственный сервер svnserve</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.invoking">Запуск Сервера</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.auth">Встроенная аутентификация и авторизация</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.auth.users">Создание файла пользователей и область хранилища </a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.auth.general">Установка контроля доступа</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.sshauth">SSH идентификация и авторизация</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.svnserve.sshtricks">Трюки конфигурирования SSH</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.sshtricks.setup">Начальная настройка</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.svnserve.sshtricks.fixedcmd">Controlling the invoked command</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.serverconfig.httpd">httpd, the Apache HTTP server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.serverconfig.httpd.prereqs">Prerequisites</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.httpd.basic">Basic Apache Configuration</a></span></dt><dt><span class="sect2"><a href="#svn.serverconfig.httpd.authn">Authentication Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authn.basic">Basic HTTP Authentication</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authn.sslcerts">SSL Certificate Management</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.serverconfig.httpd.authz">Authorization Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authz.blanket">Blanket Access Control</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authz.perdir">Per-Directory Access Control</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.authz.pathauthzoff">Disabling Path-based Checks</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.serverconfig.httpd.extra">Extra Goodies</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.serverconfig.httpd.extra.browsing">Repository Browsing</a></span></dt><dt><span class="sect3"><a href="#svn.serverconfig.httpd.extra.other">Other Features</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.serverconfig.pathbasedauthz">Path-Based Authorization</a></span></dt><dt><span class="sect1"><a href="#svn.serverconfig.multimethod">Supporting Multiple Repository Access Methods</a></span></dt></dl></div><p>Одновременный доступ к хранилищу Subversion клиентами,
    запущенными на том же компьютере, где расположено и хранилище,
    возможен при использовании метода <code class="literal">file:///</code>.
    Но, обычно, сервер Subversion устанавливается на отдельный
    компьютер, к которому имеют доступ клиенты с компьютеров всего
    офиса — или, возможно, всего мира.</p><p>Этот раздел расскажет, как предоставить доступ к хранилищу
    Subversion удаленным клиентам. Мы опишем доступные на сегодняшний
    день механизмы серверов Subversion, а так же обсудим вопросы
    конфигурации и использования каждого из них. После прочтения этого
    раздела вы сможете решить, какой тип сервера подходит вам, как его
    установить и настроить на вашем компьютере.</p><div class="sect1" title="Обзор"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.serverconfig.overview"></a>Обзор</h2></div></div></div><p>Subversion был разработан с использованием абстрактного
      сетевого уровня. Это означает, что на программном уровне для
      доступа к хранилищу может быть использован любой тип сервера,
      а <span class="quote">«<span class="quote">клиентский API для доступа к хранилищу</span>»</span> дает
      программистам возможность создавать плагины, которые будут
      взаимодействовать с соответствующим сетевым протоколом.
      Теоретически, Subversion может использовать неограниченное
      количество сетевых реализаций. Практически же, на данный момент
      есть только два сервера.</p><p>Apache — наиболее популярный web-сервер; при использовании
      модуля <span class="command"><strong>mod_dav_svn</strong></span> Apache получает возможность
      доступа к хранилищу, а так же делает его доступным для клиентов,
      используя протокол WebDAV/DeltaV, который является расширением
      HTTP. В другом углу ринга — <span class="command"><strong>svnserve</strong></span>
      — небольшой, самостоятельный сервер, использующий для связи
      с клиентами собственный протокол.
      В <a class="xref" href="#svn.serverconfig.overview.tbl-1" title="Таблица 6.1. Сравнение серверов">Таблица&nbsp;6.1, «Сравнение серверов»</a> дано сравнение этих
      двух серверов.</p><div class="table"><a id="svn.serverconfig.overview.tbl-1"></a><p class="title"><strong>Таблица 6.1. Сравнение серверов</strong></p><div class="table-contents"><table summary="Сравнение серверов" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Возможность</th><th>Apache + mod_dav_svn</th><th>svnserve</th></tr></thead><tbody><tr><td>Настройки установления личности</td><td>стандартное установление личности средствами HTTP(S),
              сертификаты X.509, LDAP, NTLM, а также другие механизмы,
              доступные для использования в Apache</td><td>CRAM-MD5 или SSH</td></tr><tr><td>Настройки пользовательских учетных записей</td><td>внутренний файл 'users'</td><td>внутренний файл 'users' или использование существующих
              системных (SSH) учетных записей</td></tr><tr><td>Настройки прав доступа</td><td>доступ на чтение/запись устанавливается сразу на всё
              хранилище, или настраивается по-каталогово</td><td>доступ на чтение/запись устанавливается сразу на всё
              хранилище, или настраивается по-каталогово</td></tr><tr><td>Шифрование</td><td>через SSL (опционально)</td><td>через SSH-туннель (опционально)</td></tr><tr><td>Ведение журнала</td><td>полноценный журнал Apache с записями о каждом HTTP запросе,
	      с возможностью <span class="quote">«<span class="quote">высокоуровневого</span>»</span> учета любых
              операций клиента</td><td>нет журнала</td></tr><tr><td>Интероперабельность</td><td>частично, используя другие WevDAV-клиенты</td><td>только для svn клиентов</td></tr><tr><td>Просмотр через веб</td><td>ограниченная встроенная поддержка, или использование
              программ сторонних разработчиков, таких, как ViewVS</td><td>только при помощи программ сторонних разработчиков, таких,
              как ViewVS</td></tr><tr><td>Скорость</td><td>более низкая</td><td>более высокая</td></tr><tr><td>Начальная установка</td><td>несколько сложная</td><td>достаточно простая</td></tr></tbody></table></div></div><br class="table-break"><br><div class="sect2" title="Http-сервер Apache"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.overview.apache"></a>Http-сервер Apache</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">Как это работает:</span></dt><dd><p>Установите и настройте сервер Apache 2.0, затем
	      активируйте модуль сервера subversion. Клиенты будут
	      обращаться к серверу через HTTP или HTTPS, используя
	      протокол WebDAV.</p></dd><dt><span class="term">Преимущества данного варианта:</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Subversion может использовать любой из
		механизмов аутентификации, интегрированный в Apache.
		</p></li><li class="listitem"><p>Нет нужды создавать учётные записи на
		сервере.</p></li><li class="listitem"><p>Ведение логов средствами Apache.
		</p></li><li class="listitem"><p>Возможность шифровать трафик с помощью
		SSL.</p></li><li class="listitem"><p>Если компьютер или сеть защищены
		брандмауэром, порты HTTP(S) обычно
		открыты.</p></li><li class="listitem"><p>Встроенный просмотр хранилища через
		веб-обозреватель.</p></li><li class="listitem"><p>Хранилище может быть смонтировано как
		сетевой диск. (Смотрите <a class="xref" href="#svn.webdav.autoversioning" title="Autoversioning">«Autoversioning»</a>.)</p></li></ul></div></dd><dt><span class="term">Недостатки данного варианта:</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Скорость заметно ниже, чем при использовании
		svnserve.</p></li><li class="listitem"><p>Первичная настройка более
		 комплексная.</p></li></ul></div></dd></dl></div></div><div class="sect2" title="Сервер svnserve"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.overview.svnserve"></a>Сервер <span class="command"><strong>svnserve</strong></span></h3></div></div></div><div class="variablelist"><dl><dt><span class="term">Как он работает:</span></dt><dd><p>"Лёгкий" процесс, который может работать как
	      самостоятельно, так и "по вызову" inetd. Аутентификация
              происходит по алгоритму CRAM-MD5. Используется свой
              протокол.</p></dd><dt><span class="term">Преимущества данного варианта:</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Быстрая и лёгкая установка.</p></li><li class="listitem"><p>Сетевой протокол более продвинутый и
              работает ощутимо быстрее, чем WebDAV.</p></li><li class="listitem"><p>Нет необходимости создавать на сервере
              дополнительные учётные записи.</p></li><li class="listitem"><p>Пароль не передаётся по сети.</p></li></ul></div></dd><dt><span class="term">Недостатки данного варианта:</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Протокол не поддерживает
              шифрование.</p></li><li class="listitem"><p>Доступен только один метод
              аутентификации.</p></li><li class="listitem"><p>Пароль хранится на сервере открытым
              текстом.</p></li><li class="listitem"><p>Логи не ведутся, даже лог
              ошибок.</p></li></ul></div></dd></dl></div></div><div class="sect2" title="svnserve через SSH"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.overview.svn-ssh"></a><span class="command"><strong>svnserve</strong></span> через SSH</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">Как он работает:</span></dt><dd><p>Клиент подключается к серверу с помощью SSH, используя
              системную учётную запись. При этом на сервере запускается
              временный процесс <span class="command"><strong>svnserve</strong></span>. Он работает
              с хранилищем, обменивается данными с клиентом через
              SSH-туннель, после чего, при закрытии SSH-сессии,
              завершается. (При этом методе в системе не будет постоянно
              запущенных процессов <span class="command"><strong>svnserve</strong></span>).</p></dd><dt><span class="term">Преимущества данного варианта:</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Используемый stateful-протокол значительно
              быстрее, чем WebDAV.</p></li><li class="listitem"><p>Удобство использования существующих учётных
              записей и пользовательской инфраструктуры.</p></li><li class="listitem"><p>Весь сетевой траффик
              шифруется.</p></li></ul></div></dd><dt><span class="term">Недостатки данного варианта:</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Выбор одного метода идентификации</p></li><li class="listitem"><p>Журнал не ведется вообще, даже
		записи об ошибках.</p></li><li class="listitem"><p>Требует от пользователей принадлежности
		к одной группе или использования общего
		ключа ssh.</p></li><li class="listitem"><p>Может привести к проблемам с
		правами.</p></li></ul></div></dd></dl></div></div><div class="sect2" title="Выбор лучшей конфигурации сервера"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.overview.choosing-a-server"></a>Выбор лучшей конфигурации сервера</h3></div></div></div><p>Итак, какой сервер лучше использовать? Какой из них лучше?</p><p>Конечно, на этот вопрос нет точного ответа. Каждая команда
	имеет свои потребности, и каждый сервер предоставляет свой набор
	возможностей. Сам проект Subversion не предпочитает какой-то один
	сервер и не представляет один из них как более
	<span class="quote">«<span class="quote">официальный</span>»</span>.</p><p>Для небольшой команды, которая хочет начать использовать
	сервер Subversion, авторы этой книги рекомендуют простую установку
	<span class="command"><strong>svnserve</strong></span>; он прост в настройке и требует
	минимальных усилий на поддержку. Помните, что вы всегда можете
	перейти на более комплексное решение, когда ваши потребности
	вырастут.</p><p>Вот несколько общих рекомендаций, основанных на многолетнем
	опыте поддержки пользователей:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If you're trying to set up the simplest possible
            server for your group, then a
            vanilla <span class="command"><strong>svnserve</strong></span> installation is the
            easiest, fastest route.  Note, however, that your
            repository data will be transmitted in the clear over the
            network.  If your deployment is entirely within your
            company's LAN or VPN, this isn't an issue.  If the
            repository is exposed to the wide-open internet, then you
            might want to make sure the repository's contents aren't
            sensitive (e.g. it contains only open-source code.)</p></li><li class="listitem"><p>If you need to integrate with existing identity
            systems (LDAP, Active Directory, NTLM, X.509, etc.), then
            an Apache-based server is your only real option.
            Similarly, if you absolutely need server-side logs of
            either server errors or client activities, then an
            Apache-based server is required.</p></li><li class="listitem"><p>If you've decided to use either Apache or stock
             <span class="command"><strong>svnserve</strong></span>, create a
             single <code class="literal">svn</code> user on your system, and
             run either Apache or svnserve as that user.  Be sure to
             make the repository directory wholly owned by
             the <code class="literal">svn</code> user as well.  These keeps the
             repository data nicely siloed and protected by operating
             system filesystem permissions, changeable by only the
             Subverion server process itself.</p></li><li class="listitem"><p>If you have an existing infrastructure heavily based
            on SSH accounts, and if your users already have system
            accounts on your server machine, then it makes sense to
            deploy an svnserve-over-ssh solution.  Otherwise, we don't
            recommend this option to the general public.  It's
            generally considered safer to have your users access the
            repository via (imaginary) accounts managed
            by <span class="command"><strong>svnserve</strong></span> or Apache, rather than by
            full-blown system accounts.  If your deep desire for
            encrypted communication still draws you to this option, we
            recommend using Apache with SSL instead.</p></li><li class="listitem"><p>Do <span class="emphasis"><em>not</em></span> be seduced by the simple
            idea of having all of your users access a repository
            directly via <code class="literal">file:///</code> URLs.  Even if
            the repository is readily available to everyone via
            network share, this is a bad idea.  It removes any layers
            of protection between the users and the repository: users
            can accidentally (or intentionally) corrupt the repository
            database, it becomes hard to take the repository 'offline'
            for inspection or upgrade, and it can lead to a mess of
            file-permissions problems (see
            <a class="xref" href="#svn.serverconfig.multimethod" title="Supporting Multiple Repository Access Methods">«Supporting Multiple Repository Access Methods»</a>.)  Note
            that this is also one of the reasons we warn against
            accessing repositories via <code class="literal">svn+ssh://</code>
            URLs — from a security standpoint, it's effectively
            the same as local users accessing
            via <code class="literal">file:///</code>, and can entail all the
            same problems if the administrator isn't careful.)</p></li></ul></div></div></div><div class="sect1" title="Сетевая модель"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.serverconfig.netmodel"></a>Сетевая модель</h2></div></div></div><p>Этот раздел является обсуждением того, как клиент и сервер
      Subversion взаимодействуют друг с другом, вне зависимости от
      используемого вами сетевого решения. После прочтения вы будете
      понимать, как работает сервер, а также знать различные способы
      конфигурации клиента.</p><div class="sect2" title="Запросы и отклики"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.netmodel.reqresp"></a>Запросы и отклики</h3></div></div></div><p>Основная часть работы клиента Subversion относится к управлению
        рабочими копиями. Однако, когда возникает необходимость получить
        информацию из хранилища, он посылает запрос серверу, а сервер
        посылает соответствующий ответ. Подробности сетевого протокола
        невидимы пользователю; клиент пытается установить связь с URL,
        и, в зависимости от схемы URL, использует соответствующий
        протокол связи с сервером (смотрите <a class="xref" href="#svn.basic.in-action.wc.sb-1" title="URL хранилища">URL хранилища</a>). Пользователи могут
        использовать команду <span class="command"><strong>svn --version</strong></span> для
        получения информации о том, с какими схемами URL и протоколами
        клиент умеет работать.</p><p>Когда сервер получает запрос от клиента, он требует, чтобы
        клиент идентифицировал себя. Он отсылает запрос об установлении
        личности клиента, на что клиент реагирует предоставлением
        <em class="firstterm">идентификационной информации</em> серверу.
        После окончания процедуры установления личности сервер отсылает
        клиенту информацию, которую тот запрашивал. Заметьте, что эта
        система отличается от таких, как в CVS, где клиент вначале
        отсылает идентификационную информацию, а потом уже посылает
        запрос. В Subversion сервер сам получает идентификационную
        информацию, запрашивая её у клиента тогда, когда ему нужно.
        Такой способ делает определенные операции более изящными.
        К примеру, в случае, когда конфигурация сервера открывает доступ
        для чтения всем без ограничений, и клиент выполняет команду
        <span class="command"><strong>svn checkout</strong></span>, сервер не будет запрашивать
        идентификационную информацию для установления личности.</p><p>Когда клиентский запрос пишет в хранилище новые данные
        (например <span class="command"><strong>svn commit</strong></span>), создается новое
        дерево правок. Если клиентский запрос успешно прошел процедуру
        установления личности, имя пользователя сохраняется как значение
        свойства <code class="literal">svn:author</code> новой правки (смотрите
        <a class="xref" href="#svn.reposadmin.basics.revprops" title="Unversioned Properties">«Unversioned Properties»</a>). Если клиент
        не был опознан (другими словами, сервер ни разу не послал
        запрос об установлении личности), то свойство
        <code class="literal">svn:author</code> остается пустым.
        <sup>[<a id="idp13722016" href="#ftn.idp13722016" class="footnote">39</a>]</sup></p></div><div class="sect2" title="Кэширование клиентской идентификационной информации"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.netmodel.credcache"></a>Кэширование клиентской идентификационной информации</h3></div></div></div><p>Многие серверы сконфигурированы таким образом, что они
        требуют установить личность при каждом запросе. Это может сильно
        раздражать пользователей, требуя от них ввода пароля еще и еще
        раз.</p><p>К счастью, клиент Subversion спасает пользователя от этого:
        он имеет встроенную систему кэширования идентификационной
        информации на диск. По умолчанию, каждый раз, когда клиент
        успешно проходит процедуру установления личности
        на сервере, он сохраняет идентификационную информацию в области
        конфигурации — в <code class="filename">~/.subversion/auth/</code>
        на UNIX-системах и в
        <code class="filename">%APPDATA%/Subversion/auth/</code> в Windows.
        (Подробно про область конфигурации смотрите
        <a class="xref" href="#svn.advanced.confarea" title="Параметры времени выполнения">«Параметры времени выполнения»</a>). При успешном
        определении личности идентификационная информация сохраняется на
        диск с ключом, состоящим из имени хоста, порта и области
        установления личности.</p><p>Когда клиент получает запрос об установлении личности,
        он в первую очередь ищет соответствующую идентификационную
        информацию в дисковом кеше пользователя; если ее нет в кеше или
        она не проходит процедуру опознания, клиент просит пользователя
        ввести необходимую информацию.</p><p>Люди, помешанные на безопасности, могут подумать: <span class="quote">«<span class="quote">
        Сохранять пароли на диск? Это ужасно! Вы никогда не должны так
        делать.</span>»</span> Пожалуйста, успокойтесь, это не так опасно, как
        кажется.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Каталог <code class="filename">auth/</code> защищен системой прав
            доступа, которая позволяет чтение данных из каталога только
            его владельцу, и больше никому в мире. Права доступа на уровне
            операционной системы защищены паролем.</p></li><li class="listitem"><p>На операционных системах Windows 2000 и старше Subversion
            использует стандартные средства шифрования Windows при сохранении
            пароля на диск. Поскольку ключ шифрования управляется Windows
            и привязывается к учетной записи пользователя, то только владелец
            учетной записи может расшифровать сохраненный пароль. (Обратите 
            внимание: если администратор сменит пароль для учетной записи
            пользователя все сохраненные на диск пароли станут 
            недействительными. Клиент Subversion будет вести себя так, словно
            их не существует, запрашивая пароль, когда он потребуется.)</p></li><li class="listitem"><p>Для тех параноиков, которые готовы жертвовать всеми
            удобствами, предусмотрена возможность отключения механизма
            кеширования.</p></li></ul></div><p>Чтобы отключить кеширование для текущей команды, используйте
        ключ <code class="option">--no-auth-cache</code>.</p><pre class="screen">$ svn commit -F log_msg.txt --no-auth-cache
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
Password for 'joe':

Adding         newfile
Transmitting file data .
Committed revision 2324.

# password was not cached, so a second commit still prompts us

$ svn delete newfile
$ svn commit -F new_msg.txt
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
…
</pre><p>Однако, если вы хотите навсегда отключить механизм
        кеширования идентификационной информации, вам надо 
        отредактировать файл <code class="filename">config</code> (находится в
        каталоге <code class="filename">auth/</code>). Просто установите параметр
        <code class="literal">store-auth-creds</code> в <code class="literal">no</code>. Всё!
        Кешироание идентификационной информации на диск отключено!</p><pre class="screen">[auth]
store-auth-creds = no
</pre><p>Иногда требуется удалить идентификационную информацию из
        кеша. Для этого необходимо вручную удалить соответствующий файл
        из каталога <code class="filename">auth/</code>. Идентификационная
        информация хранится в отдельных файлах; если вы просмотрите эти
        файлы, вы увидите список ключей и их значений. Ключ
        <code class="literal">svn:realmstring</code> описывает конкретную realm
        сервера, с которой связан данный файл.</p><pre class="screen">$ ls ~/.subversion/auth/svn.simple/
5671adf2865e267db74f09ba6f872c28
3893ed123b39500bca8a0b382839198e
5c3c22968347b390f349ff340196ed39

$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28

K 8
username
V 3
joe
K 8
password
V 4
blah
K 15
svn:realmstring
V 45
&lt;https://svn.domain.com:443&gt; Joe's repository
END
</pre><p>Вы нашли требуемый файл? Теперь просто удалите его.</p><p>И последнее о некоторых особенностях идентификации клиента,
        а именно небольшое разъяснение ключей <code class="option">--username</code>
        и <code class="option">--password</code>. Многие подкоманды клиента
        используют эти ключи, однако следует понимать, что использование
        этих ключей <span class="emphasis"><em>не подразумевает</em></span> автоматическую
        отсылку идентификационной информации на сервер. Как объяснялось
        раньше, сервер получает идентификационную информацию от клиента
        только тогда, когда считает, что это необходимо; клиент не может
        передать её серверу по своей инициативе. Когда имя пользователя
        и пароль передаются в ключах, они будут отосланы серверу
        <span class="emphasis"><em>только</em></span> в том случае, если сервер запросит
        их.


         <sup>[<a id="idp13763712" href="#ftn.idp13763712" class="footnote">40</a>]</sup>


        Обычно эти ключи используются в следующих случаях:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>пользователь не хочет использовать текущую учетную
            запись, или</p></li><li class="listitem"><p>скрипт хочет пройти опознание личности, не используя
            сохранённые идентификационные данные.</p></li></ul></div><p>Вот итоговое описание, как клиент Subversion ведет себя 
        когда он получает запрос на авторизацию: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Проверяет указал ли пользователь любую авторизационную 
            информацию как параметры командной строки, через 
            <code class="option">--username</code> и/или <code class="option">--password</code>.  
            Если нет или если эти параметры не прошли авторизацию, тогда
            </p></li><li class="listitem"><p>Просматривает область сервера в разделе 
           <code class="filename">auth/</code>
            на предмет были ли закешированы данные пользователя.  Если 
            нет, или если закешированные данные пользователя не прошли 
            авторизацию, тогда</p></li><li class="listitem"><p>Обращается с запросом к пользователю.</p></li></ol></div><p>Если клиент успешно идентифицирован через любой из методов, 
        перечисленных выше, он будет пытаться закешировать данные 
        пользователя на диск (за исключением случав, когда пользователь 
        запретил это поведение, как описывалось ранее).</p></div></div><div class="sect1" title="Собственный сервер svnserve"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.serverconfig.svnserve"></a>Собственный сервер svnserve</h2></div></div></div><p> Программа <span class="command"><strong>svnserve</strong></span> легкий сервер, способный 
      общаться с клиентами через TCP/IP, используя собственный простой
      протокол. Клиенты обращаются к серверу, <span class="command"><strong>svnserve</strong></span>
      используя URL, который начинается с <code class="literal">svn://</code> или
      <code class="literal">svn+ssh://</code>. В этом разделе рсказывается о различных
      способах запуска <span class="command"><strong>svnserve</strong></span>, о том как клиенты
      аутентифицируются на сервере и о настройке соответствующих правил доступа
      к хранилищу.</p><div class="sect2" title="Запуск Сервера"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.svnserve.invoking"></a>Запуск Сервера</h3></div></div></div><p>Существует несколько различных способов запустить программу
        <span class="command"><strong>svnserve</strong></span>. При запуске без параметров, ничего
        кроме справочного сообщения вы не увидите. Если вы
        планируете запускать процесс через <span class="command"><strong>inetd</strong></span>,
        необходимо указывать параметр <code class="option">-i</code>
        (<code class="option">--inetd</code>):</p><pre class="screen">$ svnserve -i
( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )
</pre><p>При запуске с параметром <code class="option">--inetd</code>,
        <span class="command"><strong>svnserve</strong></span> будет пытаться общаться с клиентом
        Subversion через <span class="emphasis"><em>stdin</em></span> и
        <span class="emphasis"><em>stdout</em></span> используя собственный протокол.
        Это стандартное поведение для программ, запускаемых через
        <span class="command"><strong>inetd</strong></span>.  IANA зарезервировал порт  3690 для протокола
        Subversion, поэтому на unix-подобных системах вы можете добавить в
        <code class="filename">/etc/services</code> строки подобные этим (возможно, они
        там уже есть):</p><pre class="screen">svn           3690/tcp   # Subversion
svn           3690/udp   # Subversion
</pre><p>Если система использует классический Unix-подобный
      демон <span class="command"><strong>inetd</strong></span>, в <code class="filename">/etc/inetd.conf</code>
      можно добавить такую строку:</p><pre class="screen">svn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i
</pre><p> Убедитесь, что пользователь <span class="quote">«<span class="quote">svnowner</span>»</span> имеет
        необходимые права для доступа к хранилищу. После этого, когда
       	от клиента к серверу на порт 3690 придет запрос на соединение,
        <span class="command"><strong>inetd</strong></span> запустит процесс <span class="command"><strong>svnserve</strong></span>
        для обслуживания этого запроса.
      </p><p>На Windows системах, существуют средства от сторонних
        производителей, которые запускают <span class="command"><strong>svnserve</strong></span>
        как сервис. Список этих инструментов можно посмотреть на веб-сайте
        Subversion. </p><p>Второй параметр запускает <span class="command"><strong>svnserve</strong></span> как
        автономный процесс—<span class="quote">«<span class="quote">демон</span>»</span>. Для этого используется
        параметр <code class="option">-d</code>:</p><pre class="screen">$ svnserve -d
$               # svnserve is now running, listening on port 3690
</pre><p>Если <span class="command"><strong>svnserve</strong></span> запускается в режиме демона,
        можно использовать опции <code class="option">--listen-port=</code> и
        <code class="option">--listen-host=</code>, чтобы назначить нужное значение порта
        и имени хоста, к которому <span class="quote">«<span class="quote">привязан</span>»</span>
        <span class="command"><strong>svnserve</strong></span>.</p><p>Существует еще один, третий способ запуска
        <span class="command"><strong>svnserve</strong></span>, с параметром <code class="option">-t</code> —
        это так называемый <span class="quote">«<span class="quote">туннельный режим</span>»</span>. Этот режим
      	предполагает, что программы удаленного доступа такие как
      	<span class="command"><strong>RSH</strong></span> или <span class="command"><strong>SSH</strong></span> уже успешно
      	аутентифицировали пользователя и запускают частный процесс
      	<span class="command"><strong>svnserve</strong></span> от имени <span class="emphasis"><em>этого
       	пользователя</em></span>. Программа <span class="command"><strong>svnserve</strong></span>
      	работает в обычном режиме (работая через <span class="emphasis"><em>stdin</em></span>
      	и <span class="emphasis"><em>stdout</em></span>) и предполагает, что трафик автоматически
      	перенаправится по некоторому тунелю к клиенту. Когда
      	<span class="command"><strong>svnserve</strong></span> запущен подобным туннельным агентом
      	убедитесь в том что аутентифицированый пользователь имеет полный
       	доступ на чтение и запись к файлам базы данных хранилища.
        По сути, это соответствует обращению к хранилищу локального
        пользователя через URL вида <code class="literal">file:///</code>.</p><p>После запуска <span class="command"><strong>svnserve</strong></span> все хранилища
        на вашей системе будут доступны через сеть. Клиент должен указывать
        <span class="emphasis"><em>абсолютный</em></span> путь в URL хранилища. Например, если
        хранилище расположено в
        <code class="filename">/usr/local/repositories/project1</code>, обращаться к
        нему клиент сможет по адресу
        <code class="uri">svn://host.example.com/usr/local/repositories/project1</code>.
        Чтобы увеличить безопасность, можно передать 
        <span class="command"><strong>svnserve</strong></span> параметр <code class="option">-r</code>, который
        разрешит обращаться только к тем хранилищам, которые расположены ниже
        указанного пути:</p><pre class="screen">$ svnserve -d -r /usr/local/repositories
…
</pre><p>Применение параметра <code class="option">-r</code> эффективно изменяет
        местоположение рассматриваемое программой как корень файловой
        системы. Клиенты используют URL, из которого удален этот
        путь, в результате чего URL получается более коротким
        (и менее разоблачительным):</p><pre class="screen">$ svn checkout svn://host.example.com/project1
…
</pre></div><div class="sect2" title="Встроенная аутентификация и авторизация"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.svnserve.auth"></a>Встроенная аутентификация и авторизация</h3></div></div></div><p>Когда клиент подключается к <span class="command"><strong>svnserve</strong></span>,
        происходит следующее:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Клиент указывает требуемое
        хранилище.</p></li><li class="listitem"><p>Сервер обрабатывает файл
        <code class="filename">conf/svnserve.conf</code> хранилища, и начинает выполнять
        правила аутентификации и авторизации, указанные в нем.</p></li><li class="listitem"><p>В зависимости от ситуации и правил авторизации,</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>клиенту может быть разрешено делать анонимные
               обращения, без запроса на идентификацию, ИЛИ</p></li><li class="listitem"><p>клиенту может быть сделан запрос на идентификацию
               в любой момент, ИЛИ</p></li><li class="listitem"><p>при работе в <span class="quote">«<span class="quote">туннельном режиме</span>»</span>,
               клиент объявит себя уже идентифицированным.</p></li></ul></div></li></ul></div><p>Во время написания данного материала сервер знал только об вызове
       авторизации через CRAM-MD5 <sup>[<a id="idp13854128" href="#ftn.idp13854128" class="footnote">41</a>]</sup>. В сущности, сервер отправляет некоторые
        данные клиенту. Клиент, используя хэш алгоритма MD5, создает отпечаток
        (fingerprint) из совмещенных вместе этих данных и своего пароля,
        после чего отправляет этот отпечаток серверу как ответ.
        Сервер производит подобные вычисления со своей версией
        пользовательского пароля и проверяет идентичность результатов.
        <span class="emphasis"><em>Таким образом пароль никогда не передается в открытую по
        сети.</em></span></p><p> Также возможно, что клиент уже был идентифицирован через внешнего
        туннельного агента, такого как <span class="command"><strong>SSH</strong></span>. В таком
        случае, сервер просто проверяет запустившего его пользователя и
        в дальнейшем использует идентифицированное имя пользователя.
        Более подробно об этом смотри в <a class="xref" href="#svn.serverconfig.svnserve.sshauth" title="SSH идентификация и авторизация">«SSH идентификация и авторизация»</a>.</p><p>Как вы уже догадались, файл хранилища
        <code class="filename">svnserve.conf</code> — центральный механизм
        контроля правил идентификации и авторизации. Этот файл имеет такой же
        формат, как и другие конфигурационные файлы
        (см. <a class="xref" href="#svn.advanced.confarea" title="Параметры времени выполнения">«Параметры времени выполнения»</a>): имена секций помечены
        квадратными скобками ((<code class="literal">[</code> и <code class="literal">]</code>),
        комментарии начинаются с <code class="literal">#</code>, а каждая секция содержит
        определенные переменные, которые могут быть использованы для
        конфигурирования (<code class="literal">переменная = значение</code>). Давайте
        посмотрим на этот файл и изучим как им пользоваться.</p><div class="sect3" title="Создание файла пользователей и область хранилища"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.svnserve.auth.users"></a>Создание файла пользователей и область хранилища </h4></div></div></div><p>Сейчас, секция <code class="literal">[general]</code>
          в<code class="filename">svnserve.conf</code> имеет все необходимые вам
          переменные. Начнем с определения файла, содержащего имена
          пользователей и пароли, а также с области хранилища: </p><pre class="screen">[general]
password-db = userfile
realm = example realm
</pre><p><code class="literal">realm</code> — это определяемое вами имя.
          Оно сообщает клиентам, к какой <span class="quote">«<span class="quote">области идентификации</span>»</span>
          они подсоединяются; клиенту Subversion она выводится в приглашении к
          аутентификации, и используется как ключ (вместе с именем сервера и
          портом) для кэширования клиентской идентификационной информации
          на диск (см. <a class="xref" href="#svn.serverconfig.netmodel.credcache" title="Кэширование клиентской идентификационной информации">«Кэширование клиентской идентификационной информации»</a>).
          Переменная <code class="literal">password-db</code> указывает на отдельный
          файл, который содержит список пользователей и пароли в таком же
          простом формате. Например:</p><pre class="screen">[users]
harry = foopassword
sally = barpassword
</pre><p>Значение <code class="literal">password-db</code> может быть абсолютным или
          относительным путем к файлу пользователей. Для большинства
          администраторов, его легче держать в <code class="filename">conf/</code>
          области хранилища, рядом с <code class="filename">svnserve.conf</code>.
          С другой стороны, возможно, вы захотите разделять один и тот же файл
          пользователей для двух или более хранилищ, в этом случае этот файл
          стоит поместить в более доступное место. Хранилища разделяющие файл
          пользователей, должны быть также сконфигурированы с одинаковыми
          областями, так как список пользователей по существу определяет
          область аутентификации. Где бы в итоге файл не находился, убедитесь,
          что у него выставлены соответствующие права на чтение/запись. Если вы
          знаете от имени какого пользователя(-ей) будет запускаться
          <span class="command"><strong>svnserve</strong></span>, то ограничьте доступ на чтение только
          тем пользователем, которым это нужно.</p></div><div class="sect3" title="Установка контроля доступа"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.svnserve.auth.general"></a>Установка контроля доступа</h4></div></div></div><p>Есть еще две дополнительных переменные в
          <code class="filename">svnserve.conf</code>: они определяют,
          что будут допущены делать не идентифицированные (анонимные) и
          идентифицированные пользователи. Переменные
          <code class="literal">anon-access</code> и <code class="literal">auth-access</code>
          могут иметь значения: <code class="literal">none</code>,
          <code class="literal">read</code>, или <code class="literal">write</code>.
          Установка значения в <code class="literal">none</code> запрещает доступ любого
          рода; <code class="literal">read</code> — доступ к хранилищу только на
          чтение, а <code class="literal">write</code> — позволяет полный доступ
          к хранилищу на чтение/запись. Например:</p><pre class="screen">[general]
password-db = userfile
realm = example realm

# anonymous users can only read the repository
anon-access = read

# authenticated users can both read and write
auth-access = write
</pre><p>Значения установленные в примере — фактически значения
          по умолчанию, они будут установлены если вы не захотите определить
          их. Если вы хотите быть более консервативным, то можете заблокировать
          полностью анонимный доступ:</p><pre class="screen">[general]
password-db = userfile
realm = example realm

# anonymous users aren't allowed
anon-access = none

# authenticated users can both read and write
auth-access = write
</pre><p>Сервер понимает не только такие <span class="quote">«<span class="quote">поверхностные</span>»</span>
	  ограничения доступа к хранилищу, но также и более детальные,
	  связанные с конкретными файлами и каталогами в хранилище. Чтобы
	  использовать эту возможность, вам необходимо создать файл,
	  содержащий эти специальные правила и указать к нему путь с
	  помощью переменной <code class="literal">authz-db</code>:</p><pre class="screen">[general]
password-db = userfile
realm = example realm

# Specific access rules for specific locations
authz-db = authzfile
</pre><p>Формат файла <code class="filename">authzfile</code> детально описан
	  в <a class="xref" href="#svn.serverconfig.pathbasedauthz" title="Path-Based Authorization">«Path-Based Authorization»</a>. Заметьте,
	  что переменная <code class="literal">authz-db</code> и пара
	  <code class="literal">anon-access</code>, <code class="literal">auth-access</code>
	  допускают совместное использование; если все переменные
	  определены одновременно, то для получения доступа должны быть
	  удовлетворены <span class="emphasis"><em>все</em></span> правила.</p></div></div><div class="sect2" title="SSH идентификация и авторизация"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.svnserve.sshauth"></a>SSH идентификация и авторизация</h3></div></div></div><p>Встроенная в <span class="command"><strong>svnserve</strong></span> идентификация может
        быть более удобной, так как избегает необходимости создавать
        реальные системные учетные записи. С другой стороны, некоторые
        администраторы уже имеют хорошо настроенные SSH оболочки в своих
        системах. В этой ситуации все пользователи проектов уже имеют
        системные учетные записи и способность к <span class="quote">«<span class="quote">SSH
        into</span>»</span> на серверную машину. </p><p>Проще всего использовать SSH в связке с <span class="command"><strong>svnserve</strong></span>.
        Клиенты просто используют для коннекта схему
        <code class="literal">svn+ssh://</code>:</p><pre class="screen">$ whoami
harry

$ svn list svn+ssh://host.example.com/repos/project
harry@host.example.com's password:  *****

foo
bar
baz
…
</pre><p>В этом примере клиент Subversion вовлекает локальный процесс
        <span class="command"><strong>ssh</strong></span>, соединяется с
        <code class="literal">host.example.com</code>, идентифицируется как пользователь
        <code class="literal">harry</code>, затем порождает личный процесс
        <span class="command"><strong>svnserve</strong></span> на удаленной машине запускаемый от имени
        пользователя <code class="literal">harry</code>.  Команда
        <span class="command"><strong>svnserve</strong></span> была вовлечена в режим тунелирования
        (<code class="option">-t</code>) и ее сетевой протокол был
        <span class="quote">«<span class="quote">тунелирован</span>»</span> через зашифрованное соединение через
        тунельного-агента <span class="command"><strong>ssh</strong></span>. <span class="command"><strong>svnserve</strong></span>
        знает что он запущен пользователем <code class="literal">harry</code>,
        и если клиент выполняет фиксацию, идентификационное имя пользователя
        будет использовано как имя автора новой ревизии.</p><p>Важная вещь для понимания здесь, это то что клиент
        Subversion <span class="emphasis"><em>не</em></span> соединяется с запущенным демоном
        <span class="command"><strong>svnserve</strong></span>. Этот метод доступа не требует демона, ни
        делает уведомления даже если он присутствует. Он использует в целом
        способность <span class="command"><strong>ssh</strong></span> запускать временный процесс
        <span class="command"><strong>svnserve</strong></span>, которые завершается когда сетевое
        соединение закроется.</p><p>Когда для доступа к хранилищу используется URL вида
        <code class="literal">svn+ssh://</code>, помните что это программа
        <span class="command"><strong>ssh</strong></span> запрашивает идентификацию,
        а <span class="emphasis"><em>не</em></span> клиентская программа <span class="command"><strong>svn</strong></span>.
        Это означает что нет автоматического кеширования паролей
        (см. <a class="xref" href="#svn.serverconfig.netmodel.credcache" title="Кэширование клиентской идентификационной информации">«Кэширование клиентской идентификационной информации»</a>).
        Клиенты Subversion часто делают несколько соединений к хранилищу, хотя
        пользователи обычно не знают об этом из-за возможности кеширования
        паролей. Однако когда используют URL вида
        <code class="literal">svn+ssh://</code> URLs, пользователи могут быть раздражены
        <span class="command"><strong>ssh</strong></span> из-за повторяющихся запросов пароля для каждого
        исходящего соединения. Решение этой проблемы заключается в
        использовании отдельного инструмента для кеширования паролей SSH,
        подобных <span class="command"><strong>ssh-agent</strong></span> на Unix-подобных системах, или
        <span class="command"><strong>pageant</strong></span> в Windows.</p><p>Когда выполняется через тунелирование, идентификация первоначально
        управляется правами операционной системы на файлы базы данных
        хранилища; это очень похоже на то как если бы Harry получала доступ к
        хранилищу напрямую через URL <code class="literal">file:///</code>.  Если
        несколько пользователей системы получают доступ к хранилищу напрямую,
        вы можете захотеть поместить их в общую группу, и вы должны будете
        быть очень осторожным при разрешении (umasks). (Прочитайте <a class="xref" href="#svn.serverconfig.multimethod" title="Supporting Multiple Repository Access Methods">«Supporting Multiple Repository Access Methods»</a>.)  Но в каждом случае
        тунелирования файл <code class="filename">svnserve.conf</code> может продолжать
        использоваться для блокирования доступа, простой установкой
        <code class="literal">auth-access = read</code> или <code class="literal">auth-access
        = none</code>.

        <sup>[<a id="idp13952496" href="#ftn.idp13952496" class="footnote">42</a>]</sup>
      </p><p>Вы не должны думать что рассказ о SSH тунелирование будет
        закончен здесь. Subversion позволяет вам создавать заказное
        поведение тунеля в файле <code class="filename">config</code>
        (смотри <a class="xref" href="#svn.advanced.confarea" title="Параметры времени выполнения">«Параметры времени выполнения»</a>).  Например,
        предположим что вы хотите использовать RSH вместо SSH. В разделе
        <code class="literal">[tunnels]</code> файла <code class="literal">[tunnels]</code>
        просто укажите подобно этому:</p><pre class="screen">[tunnels]
rsh = rsh
</pre><p>И сейчас вы можете использовать новое определение туннеля
        используя схему URL которая соответствует имени вашей новой переменной:
        <code class="literal">svn+rsh://host/path</code>. Затем используя новую схему URL,
        клиент Subversion будет выполнять команду <span class="command"><strong>rsh host
        svnserve -t</strong></span>
        за кулисами. Если вы включите имя пользователя в URL (например,
        <code class="literal">svn+rsh://username@host/path</code>) клиент также будет
        включать его в эту команду (<span class="command"><strong>rsh
        username@host svnserve -t</strong></span>). Но вы может определить новую
        схему
        туннелирования которая будет более умная чем эта:</p><pre class="screen">[tunnels]
joessh = $JOESSH /opt/alternate/ssh -p 29934
</pre><p>Этот пример демонстрирует связанные вещи. С начала он
       показывает как можно сделать чтобы клиент Subversion запускал очень
       специфическую программу тунелирования (она расположена в
       <code class="filename">/opt/alternate/ssh</code>) с некоторым параметром.
       В данном случае, доступ к <code class="literal">svn+joessh://</code> будет
       вовлекать особую программу SSH с аргументами <code class="option">-p 29934</code>
       — полезно если вы хотите соединить программу тунелирования на
       нестандартный порт.</p><p>Затем он показывает как определить пользовательскую переменную
        окружения, которая может перекрыть имя программы тунелирования.
        Установка переменной окружения <code class="literal">SVN_SSH</code> это
        удобный путь для перекрытия агента тунелирования SSH по умолчанию.
        Но если вы нуждаетесь в нескольких различных перекрытиях, для разных
        серверов, каждый возможно взаимодействует с разными портами или
        передача различных наборов параметров в SSH, вы можете использовать
        механизм показанный в этом примере.
        Сейчас, если вы установите переменную окружения <code class="literal">JOESSH</code>, ее
        значение будет перекрывать содержимое переменной тунелирования
        —<span class="command"><strong>$JOESSH</strong></span> будет выполняться вместо
        <span class="command"><strong>/opt/alternate/ssh -p 29934</strong></span>.</p></div><div class="sect2" title="Трюки конфигурирования SSH"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.svnserve.sshtricks"></a>Трюки конфигурирования SSH</h3></div></div></div><p>Возможно не только управлять как клиент выполняет
        <span class="command"><strong>ssh</strong></span>, но также управлять поведением
        <span class="command"><strong>sshd</strong></span> на машине вашего сервера. В этом разделе,
        мы покажем как управлять тем, какие именно команды
        <span class="command"><strong>svnserve</strong></span> вызываются <span class="command"><strong>sshd</strong></span>,
        а также о том, как несколько пользователей могут использовать
        одну системную учетную запись.</p><div class="sect3" title="Начальная настройка"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.svnserve.sshtricks.setup"></a>Начальная настройка</h4></div></div></div><p>Для начала, перейдите в домашнюю папку учетной записи которую вы
          используете для запуска <span class="command"><strong>svnserve</strong></span>. Убедитесь что
          учетная запись имеет установленную пару ключей SSH
          (публичную/приватную), и что пользователь может зайти через
          идентификацию с использованием публичного ключа. Парольная
          идентификация не работает, так как все следующие SSH трюки вращаются
          вокруг использования файла SSH <code class="filename">authorized_keys</code>.
        </p><p>Если он не существует, создайте файл
          <code class="filename">authorized_keys</code> (на Unix, обычно
          <code class="filename">~/.ssh/authorized_keys</code>). Каждая
          строка этого файла описывает публичный ключ, который разрешен
          для соединения. Строки обычно в следующей форме:</p><pre class="screen">  ssh-dsa AAAABtce9euch… user@example.com
</pre><p>Первое поле описывает тип ключа, второе поле uu-кодированный
          (uuencoded) ключ и третье поле это комментарий. Однако, менее
          известный факт что всей строке может предшествовать поле
          <code class="literal">command</code>:</p><pre class="screen">  command="program" ssh-dsa AAAABtce9euch… user@example.com
</pre><p>Когда поле <code class="literal">command</code> установлено, демон
          SSH будет выполнять указанную программу, вместо обычной
          <span class="command"><strong>svnserve -t</strong></span> моля что клиент знает об этом.
          Это открывает двери для многих трюков на стороне сервера.
          В следующем примерах мы сокращаем строки в файле так :</p><pre class="screen">  command="program" TYPE KEY COMMENT
</pre></div><div class="sect3" title="Controlling the invoked command"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.svnserve.sshtricks.fixedcmd"></a>Controlling the invoked command</h4></div></div></div><p>Так как мы можем указать выполняемую на сервере команду, проще
          назвать специфическую программу <span class="command"><strong>svnserve</strong></span> и
          передать дополнительные параметры:</p><pre class="screen">  command="/path/to/svnserve -t -r /virtual/root" TYPE KEY COMMENT
</pre><p>В этом примере, <code class="filename">/path/to/svnserve</code> может быть
          пользовательским скриптом, оберткой вокруг
          <span class="command"><strong>svnserve</strong></span> которая устанавливает umask (смотри
          <a class="xref" href="#svn.serverconfig.multimethod" title="Supporting Multiple Repository Access Methods">«Supporting Multiple Repository Access Methods»</a>).  Также показано
          как привязать <span class="command"><strong>svnserve</strong></span> к виртуальному корневому
          каталогу, который часто делается когда запускается
          <span class="command"><strong>svnserve</strong></span> как процесс-демон. Это может быть
          сделано либо ограничением доступа к части системы,
          или просто заставляя пользователя указывать абсолютный путь в
          <code class="literal">svn+ssh://</code> URL.</p><p>Так же возможно иметь нескольких пользовательских разделяемых
          ресурсов под одной учетной записью. Вместо создания различных учетных
          записей для каждого пользователя, сгенерируйте пару публичный/частный
          ключ для каждого человека. Затем поместите каждый публичный ключ
          в файл <code class="filename">authorized_users</code>, по одному ключу в
          строке, и используйте параметр <code class="option">--tunnel-user</code>:</p><pre class="screen">  command="svnserve -t --tunnel-user=harry" TYPE1 KEY1 harry@example.com
  command="svnserve -t --tunnel-user=sally" TYPE2 KEY2 sally@example.com
</pre><p>Этот пример позволяет обоим, Гарии и Салли подключаться к одной
          учетной записи через идентификацию через публичный ключ. Каждый из
          них имеет собственную команду, которая будет выполняться, параметр
          <code class="option">--tunnel-user</code> говорит <span class="command"><strong>svnserve -t</strong></span>
          какой из названных аргументов идентифицирует пользователя. Без
          <code class="option">--tunnel-user</code> они будут появляться не смотря на все
          фиксации которые сделаны из одной разделяемой учетной записи.</p><p>В заключение предостережение: предоставление доступа
          пользователям к серверу через публичные ключи в разделяемой учетной
          записи может оставлять доступным другие формы доступа через SSH, даже
          если вы установили значение <code class="literal">command</code> в
          <code class="filename">authorized_keys</code>. Например, пользователи могут
          получить доступ через SSH, или иметь возможность выполнять X11 или
          общий форвардинг портов через ваш сервер. Для предоставления
          пользователям как можно меньше привилегий, можно указать несколько
          ограничивающих опций сразу же после <code class="literal">command</code>:</p><pre class="screen">  command="svnserve -t --tunnel-user=harry",no-port-forwarding,\
           no-agent-forwarding,no-X11-forwarding,no-pty \
           TYPE1 KEY1 harry@example.com
</pre></div></div></div><div class="sect1" title="httpd, the Apache HTTP server"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.serverconfig.httpd"></a>httpd, the Apache HTTP server</h2></div></div></div><p>The Apache HTTP Server is a <span class="quote">«<span class="quote">heavy duty</span>»</span>
      network server that Subversion can leverage.  Via a custom
      module, <span class="command"><strong>httpd</strong></span> makes Subversion repositories
      available to clients via the WebDAV/DeltaV protocol, which is an
      extension to HTTP 1.1 (see <a class="ulink" href="http://www.webdav.org/" target="_top">http://www.webdav.org/</a>
      for more information).  This protocol takes the ubiquitous HTTP
      protocol that is the core of the World Wide Web, and adds
      writing—specifically, versioned
      writing—capabilities.  The result is a standardized,
      robust system that is conveniently packaged as part of the
      Apache 2.0 software, is supported by numerous operating systems
      and third-party products, and doesn't require network
      administrators to open up yet another custom port.
      <sup>[<a id="idp14031712" href="#ftn.idp14031712" class="footnote">43</a>]</sup>
      While an Apache-Subversion server has more features than
      <span class="command"><strong>svnserve</strong></span>, it's also a bit more difficult
      to set up.  With flexibility often comes more complexity.</p><p>Much of the following discussion includes references to
      Apache configuration directives.  While some examples are given
      of the use of these directives, describing them in full is
      outside the scope of this chapter.  The Apache team maintains
      excellent documentation, publicly available on their website at
      <a class="ulink" href="http://httpd.apache.org/" target="_top">http://httpd.apache.org</a>.  For example, a general
      reference for the configuration directives is located at <a class="ulink" href="http://httpd.apache.org/docs-2.0/mod/directives.html" target="_top">       http://httpd.apache.org/docs-2.0/mod/directives.html</a>.</p><p>Also, as you make changes to your Apache setup, it is likely
      that somewhere along the way a mistake will be made.  If you are
      not already familiar with Apache's logging subsystem, you should
      become aware of it.  In your <code class="filename">httpd.conf</code>
      file are directives that specify the on-disk locations of the
      access and error logs generated by Apache (the
      <code class="literal">CustomLog</code> and <code class="literal">ErrorLog</code>
      directives, respectively).  Subversion's mod_dav_svn uses
      Apache's error logging interface as well.  You can always browse
      the contents of those files for information that might reveal
      the source of a problem that is not clearly noticeable
      otherwise.</p><div class="sidebar" title="Why Apache 2?"><div class="titlepage"><div><div><p class="title"><strong>Why Apache 2?</strong></p></div></div></div><p>If you're a system administrator, it's very likely that
        you're already running the Apache web server and have some
        prior experience with it.  At the time of writing, Apache 1.3
        is by far the most popular version of Apache.  The world has
        been somewhat slow to upgrade to the Apache 2.X series for
        various reasons: some people fear change, especially changing
        something as critical as a web server.  Other people depend on
        plug-in modules that only work against the Apache 1.3 API, and
        are waiting for a 2.X port.  Whatever the reason, many people
        begin to worry when they first discover that Subversion's
        Apache module is written specifically for the Apache 2 API.</p><p>The proper response to this problem is: don't worry about
        it.  It's easy to run Apache 1.3 and Apache 2 side-by-side;
        simply install them to separate places, and use Apache 2 as a
        dedicated Subversion server that runs on a port other than 80.
        Clients can access the repository by placing the port number
        into the URL:</p><pre class="screen">$ svn checkout http://host.example.com:7382/repos/project
…
</pre></div><div class="sect2" title="Prerequisites"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.httpd.prereqs"></a>Prerequisites</h3></div></div></div><p>To network your repository over HTTP, you basically need
        four components, available in two packages.  You'll need
        Apache <span class="command"><strong>httpd</strong></span> 2.0, the
        <span class="command"><strong>mod_dav</strong></span> DAV module that comes with it,
        Subversion, and the <span class="command"><strong>mod_dav_svn</strong></span>
        filesystem provider module distributed with Subversion.
        Once you have all of those components, the process of
        networking your repository is as simple as:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>getting httpd 2.0 up and running with the mod_dav
            module,</p></li><li class="listitem"><p>installing the mod_dav_svn plugin to mod_dav, which
            uses Subversion's libraries to access the repository,
            and</p></li><li class="listitem"><p>configuring your <code class="filename">httpd.conf</code>
            file to export (or expose) the repository.</p></li></ul></div><p>You can accomplish the first two items either by
        compiling <span class="command"><strong>httpd</strong></span> and Subversion from
        source code, or by installing pre-built binary packages of
        them on your system.  For the most up-to-date information on
        how to compile Subversion for use with the Apache HTTP Server,
        as well as how to compile and configure Apache itself for
        this purpose, see the <code class="filename">INSTALL</code> file in
        the top level of the Subversion source code tree.</p></div><div class="sect2" title="Basic Apache Configuration"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.httpd.basic"></a>Basic Apache Configuration</h3></div></div></div><p>Once you have all the necessary components installed on
        your system, all that remains is the configuration of Apache
        via its <code class="filename">httpd.conf</code> file.  Instruct Apache
        to load the mod_dav_svn module using the
        <code class="literal">LoadModule</code> directive.  This directive must
        precede any other Subversion-related configuration items.  If
        your Apache was installed using the default layout, your
        <span class="command"><strong>mod_dav_svn</strong></span> module should have been
        installed in the <code class="filename">modules</code> subdirectory of
        the Apache install location (often
        <code class="filename">/usr/local/apache2</code>).  The
        <code class="literal">LoadModule</code> directive has a simple syntax,
        mapping a named module to the location of a shared library on
        disk:</p><pre class="screen">LoadModule dav_svn_module     modules/mod_dav_svn.so
</pre><p>Note that if <span class="command"><strong>mod_dav</strong></span> was compiled as a
        shared object (instead of statically linked directly to the
        <span class="command"><strong>httpd</strong></span> binary), you'll need a similar
        <code class="literal">LoadModule</code> statement for it, too.  Be sure
        that it comes before the <span class="command"><strong>mod_dav_svn</strong></span> line:</p><pre class="screen">LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
</pre><p>At a later location in your configuration file, you now
        need to tell Apache where you keep your Subversion repository
        (or repositories).  The <code class="literal">Location</code> directive
        has an XML-like notation, starting with an opening tag, and
        ending with a closing tag, with various other configuration
        directives in the middle.  The purpose of the
        <code class="literal">Location</code> directive is to instruct Apache to
        do something special when handling requests that are directed
        at a given URL or one of its children.  In the case of
        Subversion, you want Apache to simply hand off support for
        URLs that point at versioned resources to the DAV layer.  You
        can instruct Apache to delegate the handling of all URLs whose
        path portions (the part of the URL that follows the server's
        name and the optional port number) begin with
        <code class="filename">/repos/</code> to a DAV provider whose
        repository is located at
        <code class="filename">/absolute/path/to/repository</code> using the
        following <code class="filename">httpd.conf</code> syntax:</p><pre class="screen">&lt;Location /repos&gt;
  DAV svn
  SVNPath /absolute/path/to/repository
&lt;/Location&gt;
</pre><p>If you plan to support multiple Subversion repositories
        that will reside in the same parent directory on your local
        disk, you can use an alternative directive, the
        <code class="literal">SVNParentPath</code> directive, to indicate that
        common parent directory.  For example, if you know you will be
        creating multiple Subversion repositories in a directory
        <code class="filename">/usr/local/svn</code> that would be accessed via
        URLs like <code class="uri">http://my.server.com/svn/repos1</code>,
        <code class="uri">http://my.server.com/svn/repos2</code>, and
        so on, you could use the <code class="filename">httpd.conf</code>
        configuration syntax in the following example:</p><pre class="screen">&lt;Location /svn&gt;
  DAV svn

  # any "/svn/foo" URL will map to a repository /usr/local/svn/foo
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</pre><p>Using the previous syntax, Apache will delegate the
        handling of all URLs whose path portions begin with
        <code class="filename">/svn/</code> to the Subversion DAV provider,
        which will then assume that any items in the directory
        specified by the <code class="literal">SVNParentPath</code> directive
        are actually Subversion repositories.  This is a particularly
        convenient syntax in that, unlike the use of the
        <code class="literal">SVNPath</code> directive, you don't have to
        restart Apache in order to create and network new
        repositories.</p><p>Be sure that when you define your new
        <code class="literal">Location</code>, it doesn't overlap with other
        exported Locations.  For example, if your main
        <code class="literal">DocumentRoot</code> is exported to
        <code class="filename">/www</code>, do not export a Subversion
        repository in <code class="literal">&lt;Location /www/repos&gt;</code>.
        If a request comes in for the URI
        <code class="filename">/www/repos/foo.c</code>, Apache won't know
        whether to look for a file <code class="filename">repos/foo.c</code> in
        the <code class="literal">DocumentRoot</code>, or whether to delegate
        <span class="command"><strong>mod_dav_svn</strong></span> to return
        <code class="filename">foo.c</code> from the Subversion
        repository.</p><div class="sidebar" title="Server Names and the COPY Request"><div class="titlepage"><div><div><p class="title"><strong>Server Names and the COPY Request</strong></p></div></div></div><p>Subversion makes use of the <code class="literal">COPY</code>
          request type to perform server-side copies of files and
          directories.  As part of the sanity checking done by the
          Apache modules, the source of the copy is expected to be
          located on the same machine as the destination of the copy.
          To satisfy this requirement, you might need to tell mod_dav
          the name you use as the hostname of your server.  Generally,
          you can use the <code class="literal">ServerName</code> directive in
          <code class="filename">httpd.conf</code> to accomplish this.</p><pre class="screen">ServerName svn.example.com
</pre><p>If you are using Apache's virtual hosting support via
          the <code class="literal">NameVirtualHost</code> directive, you may
          need to use the <code class="literal">ServerAlias</code> directive to
          specify additional names that your server is known by.
          Again, refer to the Apache documentation for full
          details.</p></div><p>At this stage, you should strongly consider the question
        of permissions.  If you've been running Apache for some time
        now as your regular web server, you probably already have a
        collection of content—web pages, scripts and such.
        These items have already been configured with a set of
        permissions that allows them to work with Apache, or more
        appropriately, that allows Apache to work with those files.
        Apache, when used as a Subversion server, will also need the
        correct permissions to read and write to your Subversion
        repository.</p><p>You will need to determine a permission system setup that
        satisfies Subversion's requirements without messing up any
        previously existing web page or script installations.  This
        might mean changing the permissions on your Subversion
        repository to match those in use by other things that Apache
        serves for you, or it could mean using the
        <code class="literal">User</code> and <code class="literal">Group</code>
        directives in <code class="filename">httpd.conf</code> to specify that
        Apache should run as the user and group that owns your
        Subversion repository.  There is no single correct way to set
        up your permissions, and each administrator will have
        different reasons for doing things a certain way.  Just be
        aware that permission-related problems are perhaps the most
        common oversight when configuring a Subversion repository for
        use with Apache.</p></div><div class="sect2" title="Authentication Options"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.httpd.authn"></a>Authentication Options</h3></div></div></div><p>At this point, if you configured
        <code class="filename">httpd.conf</code> to contain something like</p><pre class="screen">&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</pre><p>…then your repository is <span class="quote">«<span class="quote">anonymously</span>»</span>
        accessible to the world.  Until you configure some
        authentication and authorization policies, the Subversion
        repositories you make available via the
        <code class="literal">Location</code> directive will be generally
        accessible to everyone.  In other words,</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>anyone can use their Subversion client to checkout a
            working copy of a repository URL (or any of its
            subdirectories),</p></li><li class="listitem"><p>anyone can interactively browse the repository's
            latest revision simply by pointing their web browser to
            the repository URL, and</p></li><li class="listitem"><p>anyone can commit to the repository.</p></li></ul></div><div class="sect3" title="Basic HTTP Authentication"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.httpd.authn.basic"></a>Basic HTTP Authentication</h4></div></div></div><p>The easiest way to authenticate a client is via the
          HTTP Basic authentication mechanism, which simply uses a
          username and password to verify that a user is who she says
          she is.  Apache provides an <span class="command"><strong>htpasswd</strong></span>
          utility for managing the list of acceptable usernames and
          passwords, those to whom you wish to grant special access to
          your Subversion repository.  Let's grant commit access to
          Sally and Harry.  First, we need to add them to the password
          file.</p><pre class="screen">$ ### First time: use -c to create the file
$ ### Use -m to use MD5 encryption of the password, which is more secure
$ htpasswd -cm /etc/svn-auth-file harry
New password: *****
Re-type new password: *****
Adding password for user harry
$ htpasswd -m /etc/svn-auth-file sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
</pre><p>Next, you need to add some more
          <code class="filename">httpd.conf</code> directives inside your
          <code class="literal">Location</code> block to tell Apache what to do
          with your new password file.  The
          <code class="literal">AuthType</code> directive specifies the type of
          authentication system to use.  In this case, we want to
          specify the <code class="literal">Basic</code> authentication system.
          <code class="literal">AuthName</code> is an arbitrary name that you
          give for the authentication domain.  Most browsers will
          display this name in the pop-up dialog box when the browser
          is querying the user for his name and password.  Finally,
          use the <code class="literal">AuthUserFile</code> directive to specify
          the location of the password file you created using
          <span class="command"><strong>htpasswd</strong></span>.</p><p>After adding these three directives, your
          <code class="literal">&lt;Location&gt;</code> block should look
          something like this:</p><pre class="screen">&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
&lt;/Location&gt;
</pre><p>This <code class="literal">&lt;Location&gt;</code> block is not
          yet complete, and will not do anything useful.  It's merely
          telling Apache that whenever authorization is required,
          Apache should harvest a username and password from the
          Subversion client.  What's missing here, however, are
          directives that tell Apache <span class="emphasis"><em>which</em></span> sorts
          of client requests require authorization.  Wherever
          authorization is required, Apache will demand
          authentication as well.  The simplest thing to do is protect
          all requests.  Adding <code class="literal">Require valid-user</code>
          tells Apache that all requests require an authenticated
          user:</p><pre class="screen">&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
  Require valid-user
&lt;/Location&gt;
</pre><p>Be sure to read the next section (<a class="xref" href="#svn.serverconfig.httpd.authz" title="Authorization Options">«Authorization Options»</a>) for more detail on the
          <code class="literal">Require</code> directive and other ways to set
          authorization policies.</p><p>One word of warning: HTTP Basic Auth passwords pass in
          very nearly plain-text over the network, and thus are
          extremely insecure.  If you're worried about password
          snooping, it may be best to use some sort of SSL encryption,
          so that clients authenticate via <code class="literal">https://</code>
          instead of <code class="literal">http://</code>; at a bare minimum,
          you can configure Apache to use a self-signed server
          certificate.
          <sup>[<a id="idp14125184" href="#ftn.idp14125184" class="footnote">44</a>]</sup>
          Consult Apache's documentation (and OpenSSL documentation)
          about how to do that.</p></div><div class="sect3" title="SSL Certificate Management"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.httpd.authn.sslcerts"></a>SSL Certificate Management</h4></div></div></div><p>Businesses that need to expose their repositories for access
          outside the company firewall should be conscious of the
          possibility that unauthorized parties could be
          <span class="quote">«<span class="quote">sniffing</span>»</span> their network traffic.  SSL makes
          that kind of unwanted attention less likely to result in
          sensitive data leaks.</p><p>If a Subversion client is compiled to use OpenSSL, then
          it gains the ability to speak to an Apache server via
          <code class="literal">https://</code> URLs.  The Neon library used by
          the Subversion client is not only able to verify server
          certificates, but can also supply client certificates when
          challenged.  When the client and server have exchanged SSL
          certificates and successfully authenticated one another, all
          further communication is encrypted via a session key.</p><p>It's beyond the scope of this book to describe how to
          generate client and server certificates, and how to
          configure Apache to use them.  Many other books, including
          Apache's own documentation, describe this task.  But what
          <span class="emphasis"><em>can</em></span> be covered here is how to manage
          server and client certificates from an ordinary Subversion
          client.</p><p>When speaking to Apache via <code class="literal">https://</code>,
          a Subversion client can receive two different types of
          information:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>a server certificate</p></li><li class="listitem"><p>a demand for a client certificate</p></li></ul></div><p>If the client receives a server certificate, it needs to
          verify that it trusts the certificate: is the server really
          who it claims to be?  The OpenSSL library does this by
          examining the signer of the server certificate, or
          <em class="firstterm">certifying authority</em> (CA).  If
          OpenSSL is unable to automatically trust the CA, or if some
          other problem occurs (such as an expired certificate or
          hostname mismatch), the Subversion command-line client will
          ask you whether you want to trust the server certificate
          anyway:</p><pre class="screen">$ svn list https://host.example.com/repos/project

Error validating server certificate for 'https://host.example.com:443':
 - The certificate is not issued by a trusted authority. Use the
   fingerprint to validate the certificate manually!
Certificate information:
 - Hostname: host.example.com
 - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT
 - Issuer: CA, example.com, Sometown, California, US
 - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b

(R)eject, accept (t)emporarily or accept (p)ermanently?
</pre><p>This dialogue should look familiar; it's essentially the
          same question you've probably seen coming from your web
          browser (which is just another HTTP client like Subversion!).
          If you choose the (p)ermanent option, the server certificate
          will be cached in your private run-time
          <code class="filename">auth/</code> area in just the same way your
          username and password are cached (see <a class="xref" href="#svn.serverconfig.netmodel.credcache" title="Кэширование клиентской идентификационной информации">«Кэширование клиентской идентификационной информации»</a>).  If cached,
          Subversion will automatically remember to trust this certificate
          in future negotiations.</p><p>Your run-time <code class="filename">servers</code> file also gives
          you the ability to make your Subversion client automatically
          trust specific CAs, either globally or on a per-host basis.
          Simply set the <code class="literal">ssl-authority-files</code>
          variable to a semicolon-separated list of PEM-encoded CA
          certificates:</p><pre class="screen">[global]
ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem
</pre><p>Many OpenSSL installations also have a pre-defined set
          of <span class="quote">«<span class="quote">default</span>»</span> CAs that are nearly universally
          trusted.  To make the Subversion client automatically trust
          these standard authorities, set the
          <code class="literal">ssl-trust-default-ca</code> variable to
          <code class="literal">true</code>.</p><p>When talking to Apache, a Subversion client might also
          receive a challenge for a client certificate.  Apache is
          asking the client to identify itself: is the client really
          who it says it is?  If all goes correctly, the Subversion
          client sends back a private certificate signed by a CA that
          Apache trusts.  A client certificate is usually stored on
          disk in encrypted format, protected by a local password.
          When Subversion receives this challenge, it will ask you for
          both a path to the certificate and the password which
          protects it:</p><pre class="screen">$ svn list https://host.example.com/repos/project

Authentication realm: https://host.example.com:443
Client certificate filename: /path/to/my/cert.p12
Passphrase for '/path/to/my/cert.p12':  ********
…
</pre><p>Notice that the client certificate is a
          <span class="quote">«<span class="quote">p12</span>»</span> file.  To use a client certificate with
          Subversion, it must be in PKCS#12 format, which is a
          portable standard.  Most web browsers are already able to
          import and export certificates in that format.   Another
          option is to use the OpenSSL command-line tools to convert
          existing certificates into PKCS#12.</p><p>Again, the runtime <code class="filename">servers</code> file
          allows you to automate this challenge on a per-host basis.
          Either or both pieces of information can be described in
          runtime variables:</p><pre class="screen">[groups]
examplehost = host.example.com

[examplehost]
ssl-client-cert-file = /path/to/my/cert.p12
ssl-client-cert-password = somepassword
</pre><p>Once you've set the
          <code class="literal">ssl-client-cert-file</code> and
          <code class="literal">ssl-client-cert-password</code> variables, the
          Subversion client can automatically respond to a client
          certificate challenge without prompting you.
          <sup>[<a id="idp14152528" href="#ftn.idp14152528" class="footnote">45</a>]</sup>
        </p></div></div><div class="sect2" title="Authorization Options"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.httpd.authz"></a>Authorization Options</h3></div></div></div><p>At this point, you've configured authentication, but not
        authorization.  Apache is able to challenge clients and
        confirm identities, but it has not been told how to allow or
        restrict access to the clients bearing those identities.  This
        section describes two strategies for controlling access to
        your repositories.</p><div class="sect3" title="Blanket Access Control"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.httpd.authz.blanket"></a>Blanket Access Control</h4></div></div></div><p>The simplest form of access control is to authorize
          certain users for either read-only access to a repository,
          or read/write access to a repository.</p><p>You can restrict access on all repository operations by
          adding the <code class="literal">Require valid-user</code> directive
          to your <code class="literal">&lt;Location&gt;</code> block.  Using
          our previous example, this would mean that only clients that
          claimed to be either <code class="literal">harry</code> or
          <code class="literal">sally</code>, and provided the correct
          password for their respective username, would be allowed to
          do anything with the Subversion repository:</p><pre class="screen">&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file

  # only authenticated users may access the repository
  Require valid-user
&lt;/Location&gt;
</pre><p>Sometimes you don't need to run such a tight ship.  For
          example, Subversion's own source code repository at
          <a class="ulink" href="http://svn.collab.net/repos/svn" target="_top">http://svn.collab.net/repos/svn</a> allows anyone
          in the world to perform read-only repository tasks (like
          checking out working copies and browsing the repository with
          a web browser), but restricts all write operations to
          authenticated users.  To do this type of selective
          restriction, you can use the <code class="literal">Limit</code> and
          <code class="literal">LimitExcept</code> configuration directives.
          Like the <code class="literal">Location</code> directive, these blocks
          have starting and ending tags, and you would nest them
          inside your <code class="literal">&lt;Location&gt;</code>
          block.</p><p>The parameters present on the <code class="literal">Limit</code>
          and <code class="literal">LimitExcept</code> directives are HTTP
          request types that are affected by that block.  For example,
          if you wanted to disallow all access to your repository
          except the currently supported read-only operations, you
          would use the <code class="literal">LimitExcept</code> directive,
          passing the <code class="literal">GET</code>,
          <code class="literal">PROPFIND</code>, <code class="literal">OPTIONS</code>, and
          <code class="literal">REPORT</code> request type parameters.  Then the
          previously mentioned <code class="literal">Require valid-user</code>
          directive would be placed inside the
          <code class="literal">&lt;LimitExcept&gt;</code> block instead of just
          inside the <code class="literal">&lt;Location&gt;</code> block.</p><pre class="screen">&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file

  # For any operations other than these, require an authenticated user.
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</pre><p>These are only a few simple examples.  For more in-depth
          information about Apache access control and the
          <code class="literal">Require</code> directive, take a look at the
          <code class="literal">Security</code> section of the Apache
          documentation's tutorials collection at <a class="ulink" href="http://httpd.apache.org/docs-2.0/misc/tutorials.html" target="_top">http://httpd.apache.org/docs-2.0/misc/tutorials.html</a>.</p></div><div class="sect3" title="Per-Directory Access Control"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.httpd.authz.perdir"></a>Per-Directory Access Control</h4></div></div></div><p>It's possible to set up finer-grained permissions using
          a second Apache httpd module,
          <span class="command"><strong>mod_authz_svn</strong></span>.  This module grabs the
          various opaque URLs passing from client to server, asks
          <span class="command"><strong>mod_dav_svn</strong></span> to decode them, and then
          possibly vetoes requests based on access policies defined in
          a configuration file.</p><p>If you've built Subversion from source code,
          <span class="command"><strong>mod_authz_svn</strong></span> is automatically built
          and installed alongside <span class="command"><strong>mod_dav_svn</strong></span>.
          Many binary distributions install it automatically as well.
          To verify that it's installed correctly, make sure it comes
          right after <span class="command"><strong>mod_dav_svn</strong></span>'s
          <code class="literal">LoadModule</code> directive in
          <code class="filename">httpd.conf</code>:</p><pre class="screen">LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so
</pre><p>To activate this module, you need to configure your
          <code class="literal">Location</code> block to use the
          <code class="literal">AuthzSVNAccessFile</code> directive, which
          specifies a file containing the permissions policy for paths
          within your repositories.  (In a moment, we'll discuss the
          format of that file.)</p><p>Apache is flexible, so you have the option to configure
          your block in one of three general patterns.  To begin,
          choose one of these basic configuration patterns.  (The
          examples below are very simple; look at Apache's own
          documentation for much more detail on Apache authentication
          and authorization options.)</p><p>The simplest block is to allow open access to everyone.
          In this scenario, Apache never sends authentication
          challenges, so all users are treated as
          <span class="quote">«<span class="quote">anonymous</span>»</span>.</p><div class="example"><a id="svn.serverconfig.httpd.authz.perdir.ex-1"></a><p class="title"><strong>Пример 6.1. A sample configuration for anonymous access.</strong></p><div class="example-contents"><pre class="programlisting">&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # our access control policy
  AuthzSVNAccessFile /path/to/access/file
&lt;/Location&gt;
          </pre></div></div><br class="example-break"><br><p>On the opposite end of the paranoia scale, you can
          configure your block to demand authentication from everyone.
          All clients must supply credentials to identify themselves.
          Your block unconditionally requires authentication via the
          <code class="literal">Require valid-user</code> directive, and defines
          a means to authenticate.</p><div class="example"><a id="svn.serverconfig.httpd.authz.perdir.ex-2"></a><p class="title"><strong>Пример 6.2. A sample configuration for authenticated access.</strong></p><div class="example-contents"><pre class="programlisting">&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # our access control policy
  AuthzSVNAccessFile /path/to/access/file

  # only authenticated users may access the repository
  Require valid-user

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
&lt;/Location&gt;
          </pre></div></div><br class="example-break"><br><p>A third very popular pattern is to allow a combination
          of authenticated and anonymous access.  For example, many
          administrators want to allow anonymous users to read certain
          repository directories, but want only authenticated users to
          read (or write) more sensitive areas.  In this setup, all
          users start out accessing the repository anonymously.  If
          your access control policy demands a real username at any
          point, Apache will demand authentication from the client.
          To do this, you use both the <code class="literal">Satisfy Any</code>
          and <code class="literal">Require valid-user</code> directives
          together.</p><div class="example"><a id="svn.serverconfig.httpd.authz.perdir.ex-3"></a><p class="title"><strong>Пример 6.3. A sample configuration for mixed
            authenticated/anonymous access.</strong></p><div class="example-contents"><pre class="programlisting">&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # our access control policy
  AuthzSVNAccessFile /path/to/access/file

  # try anonymous access first, resort to real
  # authentication if necessary.
  Satisfy Any
  Require valid-user

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
&lt;/Location&gt;
          </pre></div></div><br class="example-break"><br><p>Once you've settled on one of these three
          basic <code class="filename">httpd.conf</code> templates, you need to
          create your file containing access rules for particular
          paths within the repository.  This is described in
          <a class="xref" href="#svn.serverconfig.pathbasedauthz" title="Path-Based Authorization">«Path-Based Authorization»</a>.</p></div><div class="sect3" title="Disabling Path-based Checks"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.httpd.authz.pathauthzoff"></a>Disabling Path-based Checks</h4></div></div></div><p>The <span class="command"><strong>mod_dav_svn</strong></span> module goes through a
          lot of work to make sure that data you've marked
          <span class="quote">«<span class="quote">unreadable</span>»</span> doesn't get accidentally leaked.
          This means that it needs to closely monitor all of the paths
          and file-contents returned by commands like <span class="command"><strong>svn
          checkout</strong></span> or <span class="command"><strong>svn update</strong></span>
          commands.  If these commands encounter a path that isn't
          readable according to some authorization policy, then the
          path is typically omitted altogether.  In the case of
          history or rename tracing—e.g. running a command like
          <span class="command"><strong>svn cat -r OLD foo.c</strong></span> on a file that was
          renamed long ago—the rename tracking will simply halt
          if one of the object's former names is determined to be
          read-restricted.</p><p>All of this path-checking can sometimes be quite
          expensive, especially in the case of <span class="command"><strong>svn
          log</strong></span>.  When retrieving a list of revisions, the server
          looks at every changed path in each revision and checks it
          for readability.  If an unreadable path is discovered, then
          it's omitted from the list of the revision's changed paths
          (normally seen with the <code class="option">--verbose</code> option),
          and the whole log message is suppressed.  Needless to say,
          this can be time-consuming on revisions that affect a large
          number of files.  This is the cost of security: even if you
          haven't configured a module like
          <span class="command"><strong>mod_authz_svn</strong></span> at all, the
          <span class="command"><strong>mod_dav_svn</strong></span> module is still asking Apache
          <span class="command"><strong>httpd</strong></span> to run authorization checks on
          every path.  The <span class="command"><strong>mod_dav_svn</strong></span> module has
          no idea what authorization modules have been installed, so
          all it can do is ask Apache to invoke whatever might be
          present.</p><p>On the other hand, there's also an escape-hatch of
          sorts, one which allows you to trade security features for
          speed.  If you're not enforcing any sort of per-directory
          authorization (i.e. not using
          <span class="command"><strong>mod_authz_svn</strong></span> or similar module), then
          you can disable all of this path-checking.  In your
          <code class="filename">httpd.conf</code> file, use the
          <code class="literal">SVNPathAuthz</code> directive:</p><div class="example"><a id="svn.serverconfig.httpd.authz.pathauthzoff.ex-1"></a><p class="title"><strong>Пример 6.4. Disabling path checks altogether</strong></p><div class="example-contents"><pre class="programlisting">&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  SVNPathAuthz off
&lt;/Location&gt;
          </pre></div></div><br class="example-break"><br><p>The <code class="literal">SVNPathAuthz</code> directive is <span class="quote">«<span class="quote">on</span>»</span> by
          default.  When set <span class="quote">«<span class="quote">off</span>»</span>, all path-based
          authorization checking is disabled;
          <span class="command"><strong>mod_dav_svn</strong></span> stops invoking authorization
          checks on every path it discovers.</p></div></div><div class="sect2" title="Extra Goodies"><div class="titlepage"><div><div><h3 class="title"><a id="svn.serverconfig.httpd.extra"></a>Extra Goodies</h3></div></div></div><p>We've covered most of the authentication and authorization
        options for Apache and mod_dav_svn.  But there are a few other
        nice features that Apache provides.</p><div class="sect3" title="Repository Browsing"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.httpd.extra.browsing"></a>Repository Browsing</h4></div></div></div><p>One of the most useful benefits of an Apache/WebDAV
          configuration for your Subversion repository is that the
          youngest revisions of your versioned files and directories
          are immediately available for viewing via a regular web
          browser.  Since Subversion uses URLs to identify versioned
          resources, those URLs used for HTTP-based repository access
          can be typed directly into a Web browser.  Your browser will
          issue a <code class="literal">GET</code> request for that URL, and
          based on whether that URL represents a versioned directory
          or file, mod_dav_svn will respond with a directory listing
          or with file contents.</p><p>Since the URLs do not contain any information about
          which version of the resource you wish to see, mod_dav_svn
          will always answer with the youngest version.  This
          functionality has the wonderful side-effect that you can
          pass around Subversion URLs to your peers as references to
          documents, and those URLs will always point at the latest
          manifestation of that document.  Of course, you can even use
          the URLs as hyperlinks from other web sites, too.</p><p>You generally will get more use out of URLs to versioned
          files—after all, that's where the interesting content
          tends to lie.  But you might have occasion to browse a
          Subversion directory listing, where you'll quickly note that
          the generated HTML used to display that listing is very
          basic, and certainly not intended to be aesthetically
          pleasing (or even interesting).  To enable customization of
          these directory displays, Subversion provides an XML index
          feature.  A single <code class="literal">SVNIndexXSLT</code> directive
          in your repository's <code class="literal">Location</code> block of
          <code class="filename">httpd.conf</code> will instruct mod_dav_svn to
          generate XML output when displaying a directory listing, and
          to reference the XSLT stylesheet of your choice:</p><pre class="screen">&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  SVNIndexXSLT "/svnindex.xsl"
  …
&lt;/Location&gt;
</pre><p>Using the <code class="literal">SVNIndexXSLT</code> directive and
          a creative XSLT stylesheet, you can make your directory
          listings match the color schemes and imagery used in other
          parts of your website.  Or, if you'd prefer, you can use the
          sample stylesheets provided in the Subversion source
          distribution's <code class="filename">tools/xslt/</code> directory.
          Keep in mind that the path provided to the
          <code class="literal">SVNIndexXSLT</code> directory is actually a URL
          path—browsers need to be able to read your stylesheets
          in order to make use of them!</p><div class="sidebar" title="Can I view older revisions?"><div class="titlepage"><div><div><p class="title"><strong>Can I view older revisions?</strong></p></div></div></div><p>With an ordinary web browser?  In one word: nope.  At
            least, not with <span class="command"><strong>mod_dav_svn</strong></span> as your
            only tool.</p><p>Your web browser only speaks ordinary HTTP.  That
            means it only knows how to GET public URLs, which
            represent the latest versions of files and directories.
            According to the WebDAV/DeltaV spec, each server defines a
            private URL syntax for older versions of resources, and
            that syntax is opaque to clients.  To find an older
            version of a file, a client must follow a specific
            procedure to <span class="quote">«<span class="quote">discover</span>»</span> the proper URL; the
            procedure involves issuing a series of WebDAV PROPFIND
            requests and understanding DeltaV concepts.  This is
            something your web browser simply can't do.</p><p>So to answer the question, one obvious way to see
            older revisions of files and directories is by passing the
            <code class="option">--revision</code> argument to the <span class="command"><strong>svn
            list</strong></span> and <span class="command"><strong>svn cat</strong></span> commands.
            To browse old revisions with your web browser, however,
            you can use third-party software.  A good example of this
            is ViewVC (<a class="ulink" href="http://viewvc.tigris.org/" target="_top">http://viewvc.tigris.org/</a>).
            ViewVC was originally written to display CVS repositories
            through the web,
            <sup>[<a id="idp14244880" href="#ftn.idp14244880" class="footnote">46</a>]</sup>
            and the latest bleeding-edge versions (at
            the time of writing) are able to understand Subversion
            repositories as well.</p></div></div><div class="sect3" title="Other Features"><div class="titlepage"><div><div><h4 class="title"><a id="svn.serverconfig.httpd.extra.other"></a>Other Features</h4></div></div></div><p>Several of the features already provided by Apache in
          its role as a robust Web server can be leveraged for
          increased functionality or security in Subversion as well.
          Subversion communicates with Apache using Neon, which is a
          generic HTTP/WebDAV library with support for such mechanisms
          as SSL (the Secure Socket Layer, discussed earlier) and
          Deflate compression (the same algorithm used by the
          <span class="command"><strong>gzip</strong></span> and <span class="command"><strong>PKZIP</strong></span>
          programs to <span class="quote">«<span class="quote">shrink</span>»</span> files into smaller chunks
          of data).  You need only to compile support for the features
          you desire into Subversion and Apache, and properly
          configure the programs to use those features.</p><p>Deflate compression places a small burden on the client
          and server to compress and decompress network transmissions
          as a way to minimize the size of the actual transmission.
          In cases where network bandwidth is in short supply, this
          kind of compression can greatly increase the speed at which
          communications between server and client can be sent.  In
          extreme cases, this minimized network transmission could be
          the difference between an operation timing out or completing
          successfully.</p><p>Less interesting, but equally useful, are other features
          of the Apache and Subversion relationship, such as the
          ability to specify a custom port (instead of the default
          HTTP port 80) or a virtual domain name by which the
          Subversion repository should be accessed, or the ability to
          access the repository through a proxy.  These things are all
          supported by Neon, so Subversion gets that support for
          free.</p><p>Finally, because <span class="command"><strong>mod_dav_svn</strong></span> is
          speaking a semi-complete dialect of WebDAV/DeltaV, it's
          possible to access the repository via third-party DAV
          clients.  Most modern operating systems (Win32, OS X, and
          Linux) have the built-in ability to mount a DAV server as a
          standard network <span class="quote">«<span class="quote">share</span>»</span>.  This is a
          complicated topic; for details, read <a class="xref" href="#svn.webdav" title="Приложение C. WebDAV и автоматическое управление версиями">Приложение&nbsp;C, <em>WebDAV и автоматическое управление версиями</em></a>.</p></div></div></div><div class="sect1" title="Path-Based Authorization"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.serverconfig.pathbasedauthz"></a>Path-Based Authorization</h2></div></div></div><p>Both Apache and <span class="command"><strong>svnserve</strong></span> are capable of
      granting (or denying) permissions to users.  Typically this is
      done over the entire repository: a user can read the repository
      (or not), and she can write to the repository (or not).  It's
      also possible, however, to define finer-grained access rules.
      One set of users may have permssion to write to a certain
      directory in the repository, but not others; another directory
      might not even be readable by all but a few special
      people.</p><p>Both servers use a common file format to describe these
      path-based access rules.  In the case of Apache, one needs to
      load the <span class="command"><strong>mod_authz_svn</strong></span> module and then add
      the <code class="literal">AuthzSVNAccessFile</code> directive (within
      the <code class="filename">httpd.conf</code> file) pointing to your own
      rules-file.  (For a full explanation, see
      <a class="xref" href="#svn.serverconfig.httpd.authz.perdir" title="Per-Directory Access Control">«Per-Directory Access Control»</a>.)  If
      you're using <span class="command"><strong>svnserve</strong></span>, then you need to make
      the <code class="literal">authz-db</code> variable
      (within <code class="filename">svnserve.conf</code>) point to your
      rules-file.</p><div class="sidebar" title="Best practice: do you really need path-based access control?"><div class="titlepage"><div><div><p class="title"><strong>Best practice: do you really need path-based access
        control?</strong></p></div></div></div><p>A lot of administrators setting up Subversion for the
        first time tend to jump into path-based access control without
        giving it a lot of thought.  The administrator usually knows
        which teams of people are working on which projects, so it's
        easy to jump in and grant certain teams access to certain
        directories and not others.  It seems like a natural thing,
        and it appeases the administrator's desire to maintain tight
        control of the repository.</p><p>Note, though, that there are often invisible costs
        associated with this feature.  Most of the time, while certain
        users <span class="emphasis"><em>shouldn't</em></span> be committing changes to
        certain parts of the repository, that social contract doesn't
        need to be technologically enforced.  Teams can sometimes
        spontaneously collaborate with each other; someone may want to
        help someone else out by committing to an area she doesn't
        normally work on.  By preventing this sort of thing at the
        server level, you're setting up barriers to unexpected
        collaboration.  You're also creating a bunch of rules that
        need to be maintained as projects develop, new users are
        added, and so on.  It's a bunch of extra work to maintain.</p><p>Remember that this is a version control system!  Even if
        somebody accidentally commits a change to something they
        shouldn't, it's easy to undo the change.  And if a user
        commits to the wrong place with deliberate malice, then it's a
        social problem anyway, and that the problem needs to be dealt
        with outside of Subversion.</p><p>So before you begin restricting users' access rights, ask
        yourself if there's a real, honest need for this, or if it's
        just something that <span class="quote">«<span class="quote">sounds good</span>»</span> to an
        administrator.  Remember that there's very little risk
        involved, and that it's bad to become dependent on technology
        as a crutch for social problems.<sup>[<a id="idp14278160" href="#ftn.idp14278160" class="footnote">47</a>]</sup>.</p><p>As an example to ponder, consider that the Subversion
        project itself has always a notion of who is allowed to commit
        where, but it's always been enforced socially.  This is a good
        model of community trust, especially for open-source projects.
        Of course, sometimes there <span class="emphasis"><em>are</em></span> truly
        legitimate needs for path-based access control; within
        corporations, for example, certain types of data really can be
        sensitive, and access needs to be genuinely restricted to
        small groups of people.</p></div><p>Once your server knows where to find your rules-file, it's
      time to define the rules.</p><p>The syntax of the file is the same familiar one used
      by <span class="command"><strong>svnserve.conf</strong></span> and the runtime
      configuration files.  Lines that start with a hash
      (<code class="literal">#</code>) are ignored.  In its simplest form, each
      section names a repository and path within it, and the
      authenticated usernames are the option names within each
      section.  The value of each option describes the user's level of
      access to the repository path: either
      <code class="literal">r</code> (read-only) or <code class="literal">rw</code>
      (read-write).  If the user is not mentioned at all, no access is
      allowed.</p><p>To be more specific: the value of the section-names are
      either of the form <code class="literal">[repos-name:path]</code> or the
      form <code class="literal">[path]</code>.  If you're using the
      <code class="literal">SVNParentPath</code> directive, then it's important
      to specify the repository names in your sections.  If you omit
      them, then a section like
      <code class="literal">[/some/dir]</code> will match the path
      <code class="filename">/some/dir</code> in <span class="emphasis"><em>every</em></span>
      repository.  If you're using the <code class="literal">SVNPath</code>
      directive, however, then it's fine to only define paths in your
      sections—after all, there's only one repository.</p><pre class="screen">[calc:/branches/calc/bug-142]
harry = rw
sally = r
</pre><p>In this first example, the user <code class="literal">harry</code> has
      full read and write access on the
      <code class="filename">/branches/calc/bug-142</code> directory in the
      <code class="literal">calc</code> repository, but the user
      <code class="literal">sally</code> has read-only access.  Any other users
      are blocked from accessing this directory.</p><p>Of course, permissions are inherited from parent to child
      directory.  That means that we can specify a subdirectory with a
      different access policy for Sally:</p><pre class="screen">[calc:/branches/calc/bug-142]
harry = rw
sally = r

# give sally write access only to the 'testing' subdir
[calc:/branches/calc/bug-142/testing]
sally = rw
</pre><p>Now Sally can write to the <code class="filename">testing</code>
      subdirectory of the branch, but can still only read other parts.
      Harry, meanwhile, continues to have complete read-write access
      to the whole branch.</p><p>It's also possible to explicitly deny permission to someone
      via inheritance rules, by setting the username variable to
      nothing:</p><pre class="screen">[calc:/branches/calc/bug-142]
harry = rw
sally = r

[calc:/branches/calc/bug-142/secret]
harry =
</pre><p>In this example, Harry has read-write access to the
      entire <code class="filename">bug-142</code> tree, but has absolutely no
      access at all to the <code class="filename">secret</code> subdirectory
      within it.</p><p>The thing to remember is that the most specific path always
      matches first.  The <span class="command"><strong>mod_authz_svn</strong></span> module
      tries to match the path itself, and then the parent of the path,
      then the parent of that, and so on.  The net effect is that
      mentioning a specific path in the accessfile will always
      override any permissions inherited from parent
      directories.</p><p>By default, nobody has any access to the repository at all.
      That means that if you're starting with an empty file, you'll
      probably want to give at least read permission to all users at
      the root of the repository.  You can do this by using the
      asterisk variable (<code class="literal">*</code>), which means <span class="quote">«<span class="quote">all
      users</span>»</span>:</p><pre class="screen">[/]
* = r
</pre><p>This is a common setup; notice that there's no repository
      name mentioned in the section name.  This makes all repositories
      world readable to all users, whether you're
      using <code class="literal">SVNPath</code> or
      <code class="literal">SVNParentPath</code>.  Once all users have
      read-access to the repositories, you can give explicit
      <code class="literal">rw</code> permission to certain users on specific
      subdirectories within specific repositories.</p><p>The asterisk variable (<code class="literal">*</code>) is also worth
      special mention here: it's the
      <span class="emphasis"><em>only</em></span> pattern which matches an anonymous
      user.  If you've configured your <code class="literal">Location</code>
      block to allow a mixture of anonymous and authenticated access,
      all users start out accessing Apache anonymously.
      <span class="command"><strong>mod_authz_svn</strong></span> looks for a
      <code class="literal">*</code> value defined for the path being accessed;
      if it can't find one, then Apache demands real authentication
      from the client.</p><p>The access file also allows you to define whole groups of
      users, much like the Unix <code class="filename">/etc/group</code>
      file:</p><pre class="screen">[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = harry, sally, joe, frank, sally, jane
</pre><p>Groups can be granted access control just like users.
      Distinguish them with an <span class="quote">«<span class="quote">at</span>»</span>
      (<code class="literal">@</code>) prefix:</p><pre class="screen">[calc:/projects/calc]
@calc-developers = rw

[paint:/projects/paint]
@paint-developers = rw
jane = r
</pre><p>Groups can also be defined to contain other groups:</p><pre class="screen">[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = @calc-developers, @paint-developers
</pre><p>…and that's pretty much all there is to it.</p></div><div class="sect1" title="Supporting Multiple Repository Access Methods"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.serverconfig.multimethod"></a>Supporting Multiple Repository Access Methods</h2></div></div></div><p>You've seen how a repository can be accessed in many
      different ways.  But is it possible—or safe—for your
      repository to be accessed by multiple methods simultaneously?
      The answer is yes, provided you use a bit of foresight.</p><p>At any given time, these processes may require read and
      write access to your repository:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>regular system users using a Subversion client (as
          themselves) to access the repository directly via
          <code class="literal">file:///</code> URLs;</p></li><li class="listitem"><p>regular system users connecting to SSH-spawned private
          <span class="command"><strong>svnserve</strong></span> processes (running as
          themselves) which access the repository;</p></li><li class="listitem"><p>an <span class="command"><strong>svnserve</strong></span> process—either a
          daemon or one launched by
          <span class="command"><strong>inetd</strong></span>—running as a particular fixed
          user;</p></li><li class="listitem"><p>an Apache <span class="command"><strong>httpd</strong></span> process, running as a
          particular fixed user.</p></li></ul></div><p>The most common problem administrators run into is repository
      ownership and permissions.  Does every process (or user) in the
      previous list have the rights to read and write the Berkeley DB
      files?  Assuming you have a Unix-like operating system, a
      straightforward approach might be to place every potential
      repository user into a new <code class="literal">svn</code> group, and
      make the repository wholly owned by that group.  But even that's
      not enough, because a process may write to the database files
      using an unfriendly umask—one that prevents access by
      other users.</p><p>So the next step beyond setting up a common group for
      repository users is to force every repository-accessing process
      to use a sane umask.  For users accessing the repository
      directly, you can make the <span class="command"><strong>svn</strong></span> program into a
      wrapper script that first sets <span class="command"><strong>umask 002</strong></span> and
      then runs the real <span class="command"><strong>svn</strong></span> client program.  You
      can write a similar wrapper script for the
      <span class="command"><strong>svnserve</strong></span> program, and add a <span class="command"><strong>umask
      002</strong></span> command to Apache's own startup script,
      <code class="filename">apachectl</code>.  For example:</p><pre class="screen">$ cat /usr/bin/svn

#!/bin/sh

umask 002
/usr/bin/svn-real "$@"

</pre><p>Another common problem is often encountered on Unix-like
      systems.  As a repository is used, Berkeley DB occasionally
      creates new log files to journal its actions.  Even if the
      repository is wholly owned by the <span class="command"><strong>svn</strong></span> group,
      these newly created files won't necessarily be owned by that
      same group, which then creates more permissions problems for
      your users.  A good workaround is to set the group SUID bit on
      the repository's <code class="filename">db</code> directory.  This causes
      all newly-created log files to have the same group owner as the
      parent directory.</p><p>Once you've jumped through these hoops, your repository
      should be accessible by all the necessary processes.  It may
      seem a bit messy and complicated, but the problems of having
      multiple users sharing write-access to common files are classic
      ones that are not often elegantly solved.</p><p>Fortunately, most repository administrators will never
      <span class="emphasis"><em>need</em></span> to have such a complex configuration.
      Users who wish to access repositories that live on the same
      machine are not limited to using <code class="literal">file://</code>
      access URLs—they can typically contact the Apache HTTP
      server or <span class="command"><strong>svnserve</strong></span> using
      <code class="literal">localhost</code> for the server name in their
      <code class="literal">http://</code> or <code class="literal">svn://</code> URLs.
      And to maintain multiple server processes for your Subversion
      repositories is likely to be more of a headache than necessary.
      We recommend you choose the server that best meets your needs
      and stick with it!</p><div class="sidebar" title="The svn+ssh:// server checklist"><div class="titlepage"><div><div><p class="title"><strong>The svn+ssh:// server checklist</strong></p></div></div></div><p>It can be quite tricky to get a bunch of users with
        existing SSH accounts to share a repository without
        permissions problems.  If you're confused about all the things
        that you (as an administrator) need to do on a Unix-like
        system, here's a quick checklist that resummarizes some of
        things discussed in this section:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>All of your SSH users need to be able to read and
            write to the repository.  Put all the SSH users into a
            single group.  Make the repository wholly owned by that
            group, and set the group permissions to read/write.</p></li><li class="listitem"><p>Your users need to use a sane umask when accessing the
            repository.  Make sure that <span class="command"><strong>svnserve</strong></span>
            (<code class="filename">/usr/bin/svnserve</code>, or wherever
            it lives in <code class="literal">$PATH</code>) is actually a
            wrapper script which sets <span class="command"><strong>umask 002</strong></span> and
            executes the real <span class="command"><strong>svnserve</strong></span>
            binary.  Take similar measures when using
            <span class="command"><strong>svnlook</strong></span> and
            <span class="command"><strong>svnadmin</strong></span>.  Either run them with a sane
            umask, or wrap them as described above.</p></li></ul></div></div></div><div class="footnotes"><br><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.idp13722016" href="#idp13722016" class="para">39</a>] </sup>Эта проблема описана в FAQ, она является результатом
        плохой конфигурации сервера.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp13763712" href="#idp13763712" class="para">40</a>] </sup>И опять-таки, частой ошибкой является 
           неправильная конфигурация сервера, при которой сервер никогда
           не посылает запрос об установлении личности. Когда
           пользователи используют ключи <code class="option">--username</code>
           и <code class="option">--password</code>, они могут быть неприятно
           удивлены, увидев, что ключи не используются, что новые правки
           зафиксированы анонимными пользователями.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp13854128" href="#idp13854128" class="para">41</a>] </sup>Смотри
        RFC 2195.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp13952496" href="#idp13952496" class="para">42</a>] </sup>Note that using any sort
            of <span class="command"><strong>svnserve</strong></span>-enforced access control at
            all is a bit pointless;  the user already has direct access to
            the repository database.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp14031712" href="#idp14031712" class="para">43</a>] </sup>They really hate doing that.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp14125184" href="#idp14125184" class="para">44</a>] </sup>While self-signed server certificates are still
              vulnerable to a <span class="quote">«<span class="quote">man in the middle</span>»</span> attack,
              such an attack is still much more difficult for a casual
              observer to pull off, compared to sniffing unprotected
              passwords.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp14152528" href="#idp14152528" class="para">45</a>] </sup>More security-conscious folk might not want to store
              the client certificate password in the runtime
              <code class="filename">servers</code> file.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp14244880" href="#idp14244880" class="para">46</a>] </sup>Back then, it was called <span class="quote">«<span class="quote">ViewCVS</span>»</span>.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp14278160" href="#idp14278160" class="para">47</a>] </sup>A common theme
        in this book!</p></div></div></div><div class="chapter" title="Глава 7. Профессиональная настройка Subversion"><div class="titlepage"><div><div><h2 class="title"><a id="svn.customization"></a>Глава 7. Профессиональная настройка Subversion</h2></div></div></div><div class="toc"><p><strong>Содержание</strong></p><dl><dt><span class="sect1"><a href="#svn.advanced.confarea">Параметры времени выполнения</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.confarea.layout">Структура области конфигурации</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.confarea.windows-registry">Конфигурация и реестр Windows</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.confarea.opts">Параметры конфигурации</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.advanced.confarea.opts.servers">Servers</a></span></dt><dt><span class="sect3"><a href="#svn.advanced.confarea.opts.config">Config</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.advanced.l10n">Localization</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.l10n.understanding">Understanding locales</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.l10n.svnuse">Subversion's use of locales</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.advanced.externaldifftools">Using External Differencing Tools</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.advanced.externaldifftools.diff">External diff</a></span></dt><dt><span class="sect2"><a href="#svn.advanced.externaldifftools.diff3">External diff3</a></span></dt></dl></dd></dl></div><p>### TODO: Chapter opening ###</p><p>### TODO: Gut the runtime config stuff like I did the property
            stuff, making larger topical sections to which the runtime
            config stuff generally refers.  Like already exists for
            external diff/diff3, add, for example, a section on
            external editors. ###</p><div class="sect1" title="Параметры времени выполнения"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.confarea"></a>Параметры времени выполнения</h2></div></div></div><p>Subversion имеет множество контролируемых пользователем
      опциональных параметров поведения. Возможно пользователь
      хотел бы применять некоторые из этих параметров во всех
      операциях Subversion. Поэтому для того, что бы не заставлять
      пользователей помнить ключи командной строки используемые для
      указания этих параметров и не указывать их при всех выполняемых
      операциях, Subversion использует конфигурационные файлы, выделенные
      в область конфигурации Subversion.</p><p><em class="firstterm">Область конфигурации</em> Subversion
      имеет двухуровневую иерархию имен параметров и их значений.
      Как правило, она сводится к отдельной директории, содержащей
      <em class="firstterm">конфигурационные файлы</em> (первый уровень)
      являющиеся простыми текстовыми файлами в стандартном INI формате
      (с <span class="quote">«<span class="quote">разделами</span>»</span>, обеспечивающими второй уровень).
      Эти файлы содержат директивы используемые клиентом для определения
      поведения клиента предпочитаемого пользователем, и могут быть легко
      отредактированы используя ваш любимый редактор (например, Emacs
      или vi).</p><div class="sect2" title="Структура области конфигурации"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.confarea.layout"></a>Структура области конфигурации</h3></div></div></div><p>Во время первого запуска клиент для командной строки
        <span class="command"><strong>svn</strong></span> создает отдельную для каждого пользователя
        область конфигурации. На Unix-подобных системах эта директория
        называется <code class="filename">.subversion</code> и находиться в домашней
        директории пользователя. На Win32 системах Subversion создает
        папку с именем <code class="filename">Subversion</code> в области
        <code class="filename">Application Data</code> директории с профилем
        пользователя (которая, кстати говоря, обычно является скрытой
        директорией). Однако на этой платформе точное местоположение
        отличается от системы к системе и указывается в реестре
        Windows. <sup>[<a id="idp15098384" href="#ftn.idp15098384" class="footnote">48</a>]</sup>
        При обращении к пользовательской области конфигурации мы будем
        использовать ее Unix-название.</p><p>В дополнение к пользовательской области конфигурации,
        Subversion использует общесистемную область конфигурации. Это
        дает возможность системным администраторам устанавливать
        параметры по умолчанию для всех пользователей отдельно взятой
        машины. Помните, что системная область конфигурации не
        устанавливает безоговорочные правила — параметры, заданные
        пользовательской конфигурацией переопределяют системные параметры,
        а аргументы командной строки, передаваемые программе
        <span class="command"><strong>svn</strong></span>, имеют последнее слово. На Unix-подобных
        платформах ожидаемым местоположением системной области конфигурации
        является директория <code class="filename">/etc/subversion</code>; на
        Windows машинах ищется директория <code class="filename">Subversion</code>
        внутри общесистемной области <code class="filename">Application Data</code>
        (также определяемой реестром). В отличие от пользовательской,
        системную область конфигурации <span class="command"><strong>svn</strong></span> не
        создает.</p><p>На сегодняшний момент пользовательская область конфигурации
        содержит три файла — два файла конфигурации
        (<code class="filename">config</code> и <code class="filename">servers</code>) и
        <code class="filename">README.txt</code>, который содержит описание INI формата.
        После их создания, эти файлы содержат значения по умолчанию для всех,
        поддерживаемых Subversion параметров, обычно закомментированных и
        объединенных с текстовым описанием значений ключей, влияющих на
        поведение Subversion. Для того, что бы изменить отдельный параметр все,
        что нужно, просто загрузить соответствующий файл в текстовый редактор
        и изменить значение нужного параметра. Если в какой-то момент вы
        захотите восстановить параметры по умолчанию, необходимо просто
        удалить (или переименовать) директорию с конфигурацией, после чего
        выполнить какую-то безобидную команду <span class="command"><strong>svn</strong></span>,
        например, <span class="command"><strong>svn --version</strong></span>. В результате будет
        создана новая директория с конфигурацией и содержимым по
        умолчанию.</p><p>Кроме того, пользовательская область конфигурации содержит
        кеш идентификационной информации. Директория <code class="filename">auth</code>
        объединяет набор поддиректорий, содержащих кешированну информацию,
        используемую в различных, поддерживаемых Subversion методах
        авторизации. Эта директория создается так, что бы только сам
        пользователь имел право просматривать ее содержимое.</p></div><div class="sect2" title="Конфигурация и реестр Windows"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.confarea.windows-registry"></a>Конфигурация и реестр Windows</h3></div></div></div><p>В дополнение к обычным INI-настройкам, Subversion-клиент,
        работающий на платформе Windows, может использовать для
        хранения настроек Windows-реестр. Имена параметров и их значения
        точно такие же, как и в INI-файлах. Иерархия <span class="quote">«<span class="quote">файлов</span>»</span>
        сохраняется, только немного меняется способ адресации —
        файлы и разделы просто заменяются уровнями в дереве ключей
        реестра.</p><p>За общесистемными настройками Subversion обращается к ключу
        <code class="literal">HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion</code>
        Например, параметр <code class="literal">global-ignores</code>, находящийся в
        разделе <code class="literal">miscellany</code> файла
        <code class="filename">config</code> будет находиться в <code class="literal">HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Config\Miscellany\global-ignores</code>. Пользовательские настройки хранятся в ключе
        <code class="literal">HKEY_CURRENT_USER\Software\Tigris.org\Subversion</code>.
      </p><p>Параметры конфигурации, указанные в реестре обрабатываются
        <span class="emphasis"><em>до</em></span> эквивалентных параметров в файлах
        конфигурации, поэтому они заменяются значениями, найденными,
        в файлах конфигурации. Другими словами, на Windows-системе
        приоритеты расположены в следующем порядке:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Параметры командной строки</p></li><li class="listitem"><p>Пользовательские INI-файлы</p></li><li class="listitem"><p>Параметры в реестре</p></li><li class="listitem"><p>Системные INI-файлы</p></li><li class="listitem"><p>Общесистемные параметры в реестре</p></li></ol></div><p>Кроме того, реестр Windows не поддерживает механизма
        <span class="quote">«<span class="quote">комментирования</span>»</span>. Тем не менее, Subversion
        игнорирует параметры, у которых имена начинаются с
        символа <span class="quote">«<span class="quote">решетка</span>»</span> (<code class="literal">#</code>).
        Это позволяет закомментировать параметр, не удаляя ключ из
        реестра, что значительно упрощает процесс восстановления этого
        параметра.</p><p>Клиент для командной строки <span class="command"><strong>svn</strong></span>
        никогда ничего не записывает и не создает первоначальные
        <span class="quote">«<span class="quote">умолчательные</span>»</span> параметры в реестре Windows.
        Нужные вам ключи вы можете создать используя программу
        <span class="command"><strong>REGEDIT</strong></span>. Либо, можно создать
        <code class="filename">.reg</code>-файл и двойным щелчком на этом файле
        в Explorer добавить информацию в реестр.</p><div class="example"><a id="svn.advanced.confarea.windows-registry.ex-1"></a><p class="title"><strong>Пример 7.1. Пример указания параметров в (.reg) файле реестра.</strong></p><div class="example-contents"><pre class="programlisting">REGEDIT4

[HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Servers\groups]

[HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Servers\global]
"#http-proxy-host"=""
"#http-proxy-port"=""
"#http-proxy-username"=""
"#http-proxy-password"=""
"#http-proxy-exceptions"=""
"#http-timeout"="0"
"#http-compression"="yes"
"#neon-debug-mask"=""
"#ssl-authority-files"=""
"#ssl-trust-default-ca"=""
"#ssl-client-cert-file"=""
"#ssl-client-cert-password"=""

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\auth]
"#store-auth-creds"="no"

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\helpers]
"#editor-cmd"="notepad"
"#diff-cmd"=""
"#diff3-cmd"=""
"#diff3-has-program-arg"=""

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\miscellany]
"#global-ignores"="*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#* .DS_Store"
"#log-encoding"=""
"#use-commit-times"=""
"#template-root"=""
"#enable-auto-props"=""

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\tunnels]

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\auto-props]
</pre></div></div><br class="example-break"><br><p>В предыдущем примере показано содержимое
        <code class="filename">.reg</code>-файла, содержащего часто используемые
        параметры и их значения по умолчанию. Обратите внимание, что
        приведены как общесистемные (сетевые настройки, относящиеся к
        прокси-серверу) и пользовательские параметры (программы-редакторы
        и сохранение паролей, среди прочего). Так же обратите внимание,
        что все параметры закомментированы. Необходимо будет просто удалить
        символ <span class="quote">«<span class="quote">решетка</span>»</span> (<code class="literal">#</code>) и установить
        нужное значение.</p></div><div class="sect2" title="Параметры конфигурации"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.confarea.opts"></a>Параметры конфигурации</h3></div></div></div><p>В этом разделе рассматриваются поддерживаемые
        Subversion параметры времени выполнения.</p><div class="sect3" title="Servers"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.confarea.opts.servers"></a>Servers</h4></div></div></div><p>В файле <code class="filename">servers</code> находятся настройки,
          относящиеся к работе Subversion через сеть. Он содержит
          два специальных раздела — <code class="literal">groups</code> и
          <code class="literal">global</code>. Раздел <code class="literal">groups</code>
          представляет собой просто перекрестную таблицу. Ключи этого
          раздела являются именами последующих разделов файла; значения
          ключей представляют собой <em class="firstterm">обобщения</em> —
          текстовые блоки, которые могут содержать подстановочные символы
          — сравниваемые с именами машин, к которым Subversion
          направляет запросы.</p><pre class="programlisting">[groups]
beanie-babies = *.red-bean.com
collabnet = svn.collab.net

[beanie-babies]
…

[collabnet]
…
</pre><p>При работе через сеть, Subversion ищет совпадения между
          именем сервера, с которым устанавливается связь и именем группы
          в разделе <code class="literal">groups</code>. Если найдено совпадение,
          Subversion обращается к файлу <code class="filename">servers</code>,
          к разделу с именем, совпадающим с именем группы. Из этого раздела
          берутся необходимые сетевые настройки.</p><p>Раздел <code class="literal">global</code> содержит настройки,
          используемые для всех серверов, не подпадающих ни под одно
          обобщение раздела <code class="literal">groups</code>. Здесь указываются
          те-же, что и для остальных серверных разделов файла параметры
          (конечно, за исключением специального раздела
          <code class="literal">groups</code>), используемые параметры приведены
          ниже:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">http-proxy-host</code></span></dt><dd><p>Указывает имя компьютера-посредника, через который
                Subversion должна отправлять HTTP-запросы. По умолчанию,
                этот параметр имеет пустое значение, которое говорит
                Subversion о том, что она должна направлять HTTP-запросы
                не через компьютер-посредник, а связываться с целевой машиной
                напрямую.</p></dd><dt><span class="term"><code class="literal">http-proxy-port</code></span></dt><dd><p>Указывает номер используемого порта на промежуточном
                компьютере. По умолчанию имеет пустое значение.</p></dd><dt><span class="term"><code class="literal">http-proxy-username</code></span></dt><dd><p>Указывает имя пользователя, передаваемого
                компьютеру-посреднику. По умолчанию имеет пустое
                значение.</p></dd><dt><span class="term"><code class="literal">http-proxy-password</code></span></dt><dd><p>Указывает пароль, передаваемый
                компьютеру-посреднику. По умолчанию имеет пустое
                значение.</p></dd><dt><span class="term"><code class="literal">http-timeout</code></span></dt><dd><p>Указывает, в секундах, промежуток времени ожидания
                ответа сервера. Если при низкоскоростном сетевом соединении
                у вас возникает проблема превышения времени ожидания,
                следует увеличить это значение. Значение по умолчанию
                <code class="literal">0</code> означает для низлежащей HTTP библиотеки,
                Neon, использовать свое собственное значение времени
                ожидания.</p></dd><dt><span class="term"><code class="literal">http-compression</code></span></dt><dd><p>Указывает, должна или нет Subversion использовать
                сжатие сетевых запросов, выполняющихся к DAV-серверам.
                Значением по умолчанию является <code class="literal">yes</code>
                (однако выполняться сжатие будет только если такая
                возможность поддерживается сетевым слоем). Установите
                этот параметр в <code class="literal">no</code>, для отключения
                сжатия, например при отладке сетевых транзакций.</p></dd><dt><span class="term"><code class="literal">neon-debug-mask</code></span></dt><dd><p>Целочисленная маска, которая используется низлежащей
                HTTP-библиотекой, Neon, для определения типа выводимой
                отладочной информации. По умолчанию установлено значение
                <code class="literal">0</code>, скрывающие весь отладочный вывод.
                Подробнее о том как Subversion использует Neon читайте в
                разделе <a class="xref" href="#svn.developer" title="Глава 8. Информация для разработчиков">Глава&nbsp;8, <em>Информация для разработчиков</em></a>.</p></dd><dt><span class="term"><code class="literal">ssl-authority-files</code></span></dt><dd><p>Разделенный точкой с запятой перечень путей к файлам,
                содержащим сертификаты авторизации (или CAs), используемые
                Subversion-клиентом при обращении к хранилищу через
                HTTPS.</p></dd><dt><span class="term"><code class="literal">ssl-trust-default-ca</code></span></dt><dd><p>Установите значение этой переменной в
                <code class="literal">yes</code>, если хотите чтобы Subversion
                автоматически доверяла набору поставляемых вместе
                с OpenSSL сертификатов (CAs).</p></dd><dt><span class="term"><code class="literal">ssl-client-cert-file</code></span></dt><dd><p>Если хост (или хосты) требуют SSL сертификат клиента,
                у вас будет запрошен путь к вашему сертификату. Установите
                значение этой переменной и Subversion сможет автоматически
                находить ваш сертификат, без запроса. Нет стандартного места
                для хранения сертификата на диске; Subversion будет
                использовать тот, который располагается по указанному вами
                пути.</p></dd><dt><span class="term"><code class="literal">ssl-client-cert-password</code></span></dt><dd><p>Если ваш клиентский SSL сертификат защищен паролем,
                при обращении к нему Subversion запросит у вас пароль.
                Если это вам надоедает (и вас не пугает хранить пароль
                в файле <code class="filename">servers</code>), можно присвоить
                значению этой переменной пароль сертификата. После этого
                пароль больше запрашиваться не будет.</p></dd></dl></div></div><div class="sect3" title="Config"><div class="titlepage"><div><div><h4 class="title"><a id="svn.advanced.confarea.opts.config"></a>Config</h4></div></div></div><p>Остальные доступные параметры времени выполнения Subversion,
          не относящиеся к сетевой работе, находятся в файле
          <code class="filename">config</code>. В данный момент существует всего
          несколько параметров, но они тоже сгруппированы в разделы,
          в расчете на их увеличение в будущем.</p><p>Раздел <code class="literal">auth</code> содержит параметры, относящиеся
          к аутентификации и авторизации в хранилище. Он содержит:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">store-passwords</code></span></dt><dd><p>Устанавливает, используется или не используется
                кеширование паролей, введенных пользователем в ответ на
                запрос при аутентификации на сервере. Значением по умолчанию
                является <code class="literal">да</code>. Для запрета кеширования
                паролей на диск установите этот параметр в
                <code class="literal">нет</code>. Для отдельного запуска
                <span class="command"><strong>svn</strong></span> этот параметр можно переопределить,
                используя параметр командной строки
                <code class="option">--no-auth-cache</code> (для тех команд, которые его
                поддерживают). За более подробной информацией обратитесь к
                разделу <a class="xref" href="#svn.serverconfig.netmodel.credcache" title="Кэширование клиентской идентификационной информации">«Кэширование клиентской идентификационной информации»</a>.
              </p></dd><dt><span class="term"><code class="literal">store-auth-creds</code></span></dt><dd><p>Этот параметр такой же как и
                <code class="literal">store-passwords</code>, за исключением того,
                что он разрешает или запрещает дисковое кеширование
                <span class="emphasis"><em>всей</em></span> информации для аутентификации:
                имен пользователей, паролей, серверных сертификатов и всей
                другой кешируемой информации.</p></dd></dl></div><p>Раздел <code class="literal">helpers</code> определяет, какие внешние
          приложения, при выполнении своих задач, будет использовать
          Subversion. Доступные параметры:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">editor-cmd</code></span></dt><dd><p>Определяет программу, которую будет использовать
                Subversion для ввода лог сообщений, в тех случаях, когда
                <span class="command"><strong>svn commit</strong></span> используется без параметров
                <code class="option">--message</code> (<code class="option">-m</code>) или
                <code class="option">--file</code> (<code class="option">-F</code>). Эта же
                программа используется с командой <span class="command"><strong>svn
                propedit</strong></span> — вызывается временный файл,
                содержащий текущее значение редактируемого пользователем
                свойства и редактирование выполняется прямо в
                программе-редакторе (см. <a class="xref" href="#svn.advanced.props" title="Свойства">«Свойства»</a>). По умолчанию значение
                этого свойства не установлено. Порядок определения
                используемого редактора следующий:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Command-line option <code class="literal">--editor-cmd</code></p></li><li class="listitem"><p>Environment variable <code class="literal">SVN_EDITOR</code></p></li><li class="listitem"><p>Configuration option <code class="literal">editor-cmd</code></p></li><li class="listitem"><p>Environment variable <code class="literal">VISUAL</code></p></li><li class="listitem"><p>Environment variable <code class="literal">EDITOR</code></p></li><li class="listitem"><p>Possibly, a default value built in to Subversion
                    (not present in the official builds)</p></li></ol></div><p>The value of any of these options or variables is
                (unlike <code class="literal">diff-cmd</code>) the beginning of a
                command line to be executed by the shell.  Subversion
                appends a space and the pathname of the temporary file to be
                edited.  The editor should modify the temporary file and
                return a zero exit code to indicate success.</p></dd><dt><span class="term"><code class="literal">diff-cmd</code></span></dt><dd><p>Здесь указывается абсолютный путь к программе
                определения отличий, используемой, Subversion для
                <span class="quote">«<span class="quote">diff</span>»</span>-вывода (такого как при использовании
                команды <span class="command"><strong>svn diff</strong></span>). По умолчанию для
                определения отличий Subversion использует внутреннюю
                библиотеку — установка этого параметра
                заставит ее использовать внешнюю программу. Подробнее
                об использовании таких программ читайте в разделе
                <a class="xref" href="#svn.advanced.externaldifftools" title="Using External Differencing Tools">«Using External Differencing Tools»</a>.</p></dd><dt><span class="term"><code class="literal">diff3-cmd</code></span></dt><dd><p>Здесь указывается абсолютный путь к программе
                трехстороннего сравнения. Subversion использует эту
                программу при объединении изменений, сделанных
                пользователем, с теми, которые были получены из
                хранилища. По умолчанию для определения отличий Subversion
                использует внутреннюю библиотеку — установка этого
                параметра заставит ее использовать внешнюю программу.
                Подробнее об использовании таких программ читайте в разделе
                <a class="xref" href="#svn.advanced.externaldifftools" title="Using External Differencing Tools">«Using External Differencing Tools»</a>.</p></dd><dt><span class="term"><code class="literal">diff3-has-program-arg</code></span></dt><dd><p>Этот флаг должен быть установлен в
                <code class="literal">true</code> если программа, указанная в
                параметре <code class="literal">diff3-cmd</code> использует
                параметр командной строки
                <code class="option">--diff-program</code>.</p></dd></dl></div><p>Раздел <code class="literal">tunnels</code> позволяет определить
          новые схемы туннелирования при использовании
          <span class="command"><strong>svnserve</strong></span> и клиентских подключений через
          <code class="literal">svn://</code>. За более подробной информацией
          обращайтесь в раздел <a class="xref" href="#svn.serverconfig.svnserve.sshauth" title="SSH идентификация и авторизация">«SSH идентификация и авторизация»</a>.</p><p>Все что не попало в другие разделы собирается в разделе
          <code class="literal">miscellany</code><sup>[<a id="idp15289344" href="#ftn.idp15289344" class="footnote">49</a>]</sup>. В этом разделе можно найти:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">global-ignores</code></span></dt><dd><p>Про выполнении команды <span class="command"><strong>svn status</strong></span>,
                Subversion перечисляет не версионированные файлы и
                директории вместе с версионированными, отмечая их
                символом <code class="literal">?</code> (см. <a class="xref" href="#svn.tour.cycle.examine.status" title="svn status">«<span class="command"><strong>svn status</strong></span>»</a>). Просмотр
                не интересных, не версионированных элементов при просмотре
                может раздражать — например объектные файлы, полученные
                в результате компиляции программы. Параметр
                <code class="literal">global-ignores</code> является перечислением
                разделннных пробелом обобщений, представляющих имена файлов и
                директорий которые Subversion не должна показывать, если они
                не версионированны. Значением, присвоенным по умолчанию,
                является <code class="literal">*.o *.lo *.la #*# .*.rej *.rej .*~ *~
                .#* .DS_Store</code>.</p><p>Также как и <span class="command"><strong>svn status</strong></span>, команды
                <span class="command"><strong>svn add</strong></span> и <span class="command"><strong>svn import</strong></span>
                при просмотре директорий тоже игнорируют файлы, подходящие
                к этому списку. Можно переопределить этот параметр, используя
                флаг командной строки <code class="option">--no-ignore</code>. Более
                подробнее о контроле игнорирования см. <a class="xref" href="#svn.advanced.props.special.ignore" title="Пропуск неверсионированных элементов">«Пропуск неверсионированных элементов»</a>.</p></dd><dt><span class="term"><code class="literal">enable-auto-props</code></span></dt><dd><p>Определяет автоматическую установку свойств
                для вновь добавляемых или импортированных файлов.
                Значением по умолчанию является <code class="literal">no</code>,
                поэтому для разрешения авто-свойств установите
                <code class="literal">yes</code>. Раздел <code class="literal">auto-props</code>
                этого файла определяет, какие свойства и для каких файлов
                должны устанавливаться.</p></dd><dt><span class="term"><code class="literal">log-encoding</code></span></dt><dd><p>Эта переменная задает набор символов кодировки для
                лог-сообщений фиксаций. Это перманентная форма параметра
                <code class="option">--encoding</code> (см. <a class="xref" href="#svn.ref.svn.sw" title="Параметры командной строкиsvn">«Параметры командной строки<span class="command"><strong>svn</strong></span>»</a>). Хранилище Subversion
                хранит лог-сообщения в UTF8, и предполагает, что ваше
                лог-сообщение написано используя родную локаль операционной
                ситемы. Кодировку необходимо указывать, если
                используется любая другая кодировка.</p></dd><dt><span class="term"><code class="literal">use-commit-times</code></span></dt><dd><p>Как правило, файлы рабочей копии имеют отметки
                времени, отражающие время последнего обращения к
                ним какого-либо процесса, был ли это ваш редактор,
                или подкоманды <span class="command"><strong>svn</strong></span>. Это должно
                быть близко людям, разрабатывающим программное
                обеспечение, потому, что как правило, системы
                сборки определяют по метке времени какие файлы
                требуют перекомпиляции.</p><p>С другой стороны, иногда бывает выгодно, что бы
                рабочие файлы имели метки времени отражающие время их
                последнего изменения в хранилище. Команда <span class="command"><strong>svn
                export</strong></span> всегда устанавливает <span class="quote">«<span class="quote">метку времени
                последней фиксации</span>»</span> для создаваемого ею дерева
                файлов. При установке значения этой переменной в
                <code class="literal">yes</code> команды <span class="command"><strong>svn
                checkout</strong></span>, <span class="command"><strong>svn update</strong></span>,
                <span class="command"><strong>svn switch</strong></span> и <span class="command"><strong>svn
                revert</strong></span> для используемых ими файлов,
                так же будут устанавливать метку времени последней
                фиксации.</p></dd></dl></div><p>Раздел <code class="literal">auto-props</code> определяет возможность
          Subversion-клиента автоматически устанавливать свойства файлов,
          когда они добавлялись или импортировались. Он содержит любое
          количество пар ключ-значение, в формате
          <code class="literal">PATTERN = PROPNAME=PROPVALUE</code>, где
          <code class="literal">PATTERN</code> является файловым шаблоном,
          соответствующих набору имен файлов, а остальная часть строки
          является свойством и его значением. Множественные совпадения
          для одного файла приведут к множественной установке свойств для
          этого файла; однако не гарантируется, что порядок установки
          авто-свойств будет таким же в каком они указаны в файле
          конфигурации, поэтому нельзя будет одним правилом
          <span class="quote">«<span class="quote">перекрыть</span>»</span> другое. Несколько примеров использования
          авто-свойств можно найти в файле <code class="filename">config</code>.
          Наконец, если хотите использовать авто-свойства, не забудьте в
          разделе <code class="literal">miscellany</code> установить
          <code class="literal">enable-auto-props</code> в
          <code class="literal">yes</code>.</p></div></div></div><div class="sect1" title="Localization"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.l10n"></a>Localization</h2></div></div></div><p><em class="firstterm">Localization</em> is the act of making
      programs behave in a region-specific way.  When a program
      formats numbers or dates in a way specific to your part of the
      world, or prints messages (or accepts input) in your native
      language, the program is said to
      be <em class="firstterm">localized</em>.  This section describes
      steps Subversion has made towards localization.</p><div class="sect2" title="Understanding locales"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.l10n.understanding"></a>Understanding locales</h3></div></div></div><p>Most modern operating systems have a notion of the
        <span class="quote">«<span class="quote">current locale</span>»</span>—that is, the region or
        country whose localization conventions are honored.  These
        conventions—typically chosen by some runtime
        configuration mechanism on the computer—affect the way
        in which programs present data to the user, as well as the way
        in which they accept user input.</p><p>On Unix-like systems, you can check the values of the
        locale-related runtime configuration options by running the
        <span class="command"><strong>locale</strong></span> command:</p><pre class="screen">$ locale
LANG=
LC_COLLATE="C"
LC_CTYPE="C"
LC_MESSAGES="C"
LC_MONETARY="C"
LC_NUMERIC="C"
LC_TIME="C"
LC_ALL="C"
</pre><p>The output is a list of locale-related environment
        variables and their current values.  In this example, the
        variables are all set to the default <code class="literal">C</code>
        locale, but users can set these variables to specific
        country/language code combinations.  For example, if one were
        to set the <code class="literal">LC_TIME</code> variable to
        <code class="literal">fr_CA</code>, then programs would know to present
        time and date information formatted according a
        French-speaking Canadian's expectations.  And if one were to
        set the <code class="literal">LC_MESSAGES</code> variable to
        <code class="literal">zh_TW</code>, then programs would know to present
        human-readable messages in Traditional Chinese.  Setting the
        <code class="literal">LC_ALL</code> variable has the effect of changing
        every locale variable to the same value.  The value of
        <code class="literal">LANG</code> is used as a default value for any
        locale variable that is unset.  To see the list of available
        locales on a Unix system, run the command <span class="command"><strong>locale
        -a</strong></span>.</p><p>On Windows, locale configuration is done via the
        <span class="quote">«<span class="quote">Regional and Language Options</span>»</span> control panel
        item.  There you can view and select the values of individual
        settings from the available locales, and even customize (at a
        sickening level of detail) several of the display formatting
        conventions.</p></div><div class="sect2" title="Subversion's use of locales"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.l10n.svnuse"></a>Subversion's use of locales</h3></div></div></div><p>The Subversion client, <span class="command"><strong>svn</strong></span>, honors the
        current locale configuration in two ways.  First, it notices
        the value of the <code class="literal">LC_MESSAGES</code> variable and
        attempts to print all messages in the specified language.  For
        example:</p><pre class="screen">$ export LC_MESSAGES=de_DE
$ svn help cat
cat: Gibt den Inhalt der angegebenen Dateien oder URLs aus.
Aufruf: cat ZIEL[@REV]...
…
</pre><p>This behavior works identically on both Unix and Windows
        systems.  Note, though, that while your operating system might
        have support for a certain locale, the Subversion client still
        may not be able to speak the particular language.  In order to
        produce localized messages, human volunteers must provide
        translations for each language.  The translations are written
        using the GNU gettext package, which results in translation
        modules that end with the <code class="filename">.mo</code> filename
        extension.  For example, the German translation file is named
        <code class="filename">de.mo</code>.  These translation files are
        installed somewhere on your system.  On Unix, they typically
        live in <code class="filename">/usr/share/locale/</code>, while
        on Windows they're often found in the
        <code class="filename">\share\locale\</code> folder in Subversion's
        installation area.  Once installed, a module is named after
        the program it provides translations for.  For example, the
        <code class="filename">de.mo</code> file may ultimately end up
        installed as
        <code class="filename">/usr/share/locale/de/LC_MESSAGES/subversion.mo</code>.
        By browsing the installed <code class="filename">.mo</code> files, you
        can see which languages the Subversion client is able to
        speak.</p><p>The second way in which the locale is honored involves how
        <span class="command"><strong>svn</strong></span> interprets your input.  The repository
        stores all paths, filenames, and log messages in Unicode,
        encoded as UTF-8.  In that sense, the repository is
        <em class="firstterm">internationalized</em>—that is, the
        repository is ready to accept input in any human language.
        This means, however, that the Subversion client is responsible
        for sending only UTF-8 filenames and log messages into the
        repository.  In order to do this, it must convert the data
        from the native locale into UTF-8.</p><p>For example, suppose you create a file named
        <code class="filename">caffè.txt</code>, and then when committing the
        file, you write the log message as <span class="quote">«<span class="quote">Adesso il caffè è
        più forte</span>»</span>.  Both the filename and log message contain
        non-ASCII characters, but because your locale is set to
        <code class="literal">it_IT</code>, the Subversion client knows to
        interpret them as Italian.  It uses an Italian character set
        to convert the data to UTF-8 before sending them off to the
        repository.</p><p>Note that while the repository demands UTF-8 filenames and
        log messages, it <span class="emphasis"><em>does not</em></span> pay attention
        to file contents.  Subversion treats file contents as opaque
        strings of bytes, and neither client nor server makes an
        attempt to understand the character set or encoding of the
        contents.</p><div class="sidebar" title="Character set conversion errors"><div class="titlepage"><div><div><p class="title"><strong>Character set conversion errors</strong></p></div></div></div><p>While using Subversion, you might get hit with an error
          related to character set conversions:</p><pre class="screen">svn: Can't convert string from native encoding to 'UTF-8':
…
svn: Can't convert string from 'UTF-8' to native encoding:
…
</pre><p>Errors like this typically occur when the Subversion
          client has received a UTF-8 string from the repository, but
          not all of the characters in that string can be represented
          using the encoding of the current locale.  For example, if
          your locale is <code class="literal">en_US</code> but a collaborator
          has committed a Japanese filename, you're likely to see this
          error when you receive the file during an <span class="command"><strong>svn
          update</strong></span>.</p><p>The solution is either to set your locale to something
          which <span class="emphasis"><em>can</em></span> represent the incoming UTF-8
          data, or to change the filename or log message in the
          repository.  (And don't forget to slap your collaborator's
          hand—projects should decide on common languages ahead of
          time, so that all participants are using the same
          locale.)</p></div></div></div><div class="sect1" title="Using External Differencing Tools"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.advanced.externaldifftools"></a>Using External Differencing Tools</h2></div></div></div><p>The presence of <code class="option">--diff-cmd</code> and
      <code class="option">--diff3-cmd</code> options, and similarly named
      runtime configuration parameters (see <a class="xref" href="#svn.advanced.confarea.opts.config" title="Config">«Config»</a>), can lead to a
      false notion of how easy it is to use external differencing (or
      <span class="quote">«<span class="quote">diff</span>»</span>) and merge tools with Subversion.  While
      Subversion can use most of popular such tools available, the
      effort invested in setting this up often turns out to be
      non-trivial.</p><p>The interface between Subversion and external diff and merge
      tools harkens back to a time when Subversion's only contextual
      differencing capabilities were built around invocations of the
      GNU diffutils toolchain, specifically the
      <span class="command"><strong>diff</strong></span> and <span class="command"><strong>diff3</strong></span> utilities.
      To get the kind of behavior Subversion needed, it called these
      utilities with more than a handful of options and parameters,
      most of which were quite specific to the utilities.  Some time
      later, Subversion grew its own internal differencing library,
      and as a failover mechanism,
      <sup>[<a id="idp15384784" href="#ftn.idp15384784" class="footnote">50</a>]</sup>
      the <code class="option">--diff-cmd</code> and <code class="option">--diff3-cmd</code>
      options were added to the Subversion command-line client so
      users could more easily indicate that they preferred to use the
      GNU diff and diff3 utilities instead of the newfangled internal
      diff library.  If those options were used, Subversion would
      simply ignore the internal diff library, and fall back to
      running those external programs, lengthy argument lists and all.
      And that's where things remain today.</p><p>It didn't take long for folks to realize that having such
      easy configuration mechanisms for specifying that Subversion
      should use the external GNU diff and diff3 utilities located at
      a particular place on the system could be applied toward the use
      of other diff and merge tools, too.  After all, Subversion
      didn't actually verify that the things it was being told to run
      were members of the GNU diffutils toolchain.  But the only
      configurable aspect of using those external tools is their
      location on the system—not the option set, parameter
      order, etc.  Subversion continues throwing all those GNU utility
      options at your external diff tool regardless of whether or not
      that program can understand those options.  And that's where
      things get unintuitive for most users.</p><p>The key to using external diff and merge tools (other than
      GNU diff and diff3, of course) with Subversion is to use wrapper
      scripts which convert the input from Subversion into something
      that your differencing tool can understand, and then to convert
      the output of your tool back into a format which Subversion
      expects—the format that the GNU tools would have used.
      The following sections cover the specifics of those
      expectations.</p><div class="note" title="Примечание" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Примечание]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/note.png"></td><th align="left">Примечание</th></tr><tr><td valign="top" align="left"><p>The decision on when to fire off a contextual diff or
        merge as part of a larger Subversion operation is made
        entirely by Subversion, and is affected by, among other
        things, whether or not the files being operated on are
        human-readable as determined by their
        <code class="literal">svn:mime-type</code> property.  This means, for
        example, that even if you had the niftiest Microsoft
        Word-aware differencing or merging tool in the Universe, it
        would never be invoked by Subversion so long as your versioned
        Word documents had a configured MIME type that denoted that
        they were not human-readable (such as
        <code class="literal">application/msword</code>).  For more about MIME
        type settings, see <a class="xref" href="#svn.advanced.props.special.mime-type" title="Тип содержимого файла">«Тип содержимого файла»</a></p></td></tr></tbody></table></div><div class="sect2" title="External diff"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.externaldifftools.diff"></a>External diff</h3></div></div></div><p>Subversion calls external diff programs with parameters
        suitable for the GNU diff utility, and expects only that the
        external program return with a successful error code.  For
        most alternative diff program, only the sixth and seventh
        arguments, the paths of the files which represent the left and
        right sides of the diff, respectively, are of interest.  Note
        that Subversion runs the diff program once per modified file
        covered by the Subversion operation, so if your program runs
        in an asynchronous fashion (or <span class="quote">«<span class="quote">backgrounded</span>»</span>),
        you might have several instances of it all running
        simultaneously.  Finally, Subversion expects that your program
        return an errorcode of 1 if your program detected differences,
        or 0 if it did not—any other errorcode is considered a
        fatal error.
        <sup>[<a id="idp15387648" href="#ftn.idp15387648" class="footnote">51</a>]</sup>
      </p><p><a class="xref" href="#svn.advanced.externaldifftools.diff.ex-1" title="Пример 7.2. diffwrap.sh">Пример&nbsp;7.2, «diffwrap.sh»</a>
        and <a class="xref" href="#svn.advanced.externaldifftools.diff.ex-2" title="Пример 7.3. diffwrap.bat">Пример&nbsp;7.3, «diffwrap.bat»</a>
        are templates for external diff tool wrappers in the Bourne
        shell and Windows batch scripting languages,
        respectively.</p><div class="example"><a id="svn.advanced.externaldifftools.diff.ex-1"></a><p class="title"><strong>Пример 7.2. diffwrap.sh</strong></p><div class="example-contents"><pre class="programlisting">#!/bin/sh

# Configure your favorite diff program here.
DIFF="/usr/local/bin/my-diff-tool"

# Subversion provides the paths we need as the sixth and seventh
# parameters.
LEFT=${6}
RIGHT=${7}

# Call the diff command (change the following line to make sense for
# your merge program).
$DIFF --left $LEFT --right $RIGHT

# Return an errorcode of 0 if no differences were detected, 1 if some were.
# Any other errorcode will be treated as fatal.
</pre></div></div><br class="example-break"><br><div class="example"><a id="svn.advanced.externaldifftools.diff.ex-2"></a><p class="title"><strong>Пример 7.3. diffwrap.bat</strong></p><div class="example-contents"><pre class="programlisting">@ECHO OFF

REM Configure your favorite diff program here.
SET DIFF="C:\Program Files\Funky Stuff\My Diff Tool.exe"

REM Subversion provides the paths we need as the sixth and seventh
REM parameters.
SET LEFT=%6
SET RIGHT=%7

REM Call the diff command (change the following line to make sense for
REM your merge program).
%DIFF% --left %LEFT% --right %RIGHT%

REM Return an errorcode of 0 if no differences were detected, 1 if some were.
REM Any other errorcode will be treated as fatal.
</pre></div></div><br class="example-break"><br></div><div class="sect2" title="External diff3"><div class="titlepage"><div><div><h3 class="title"><a id="svn.advanced.externaldifftools.diff3"></a>External diff3</h3></div></div></div><p>Subversion calls external merge programs with parameters
        suitable for the GNU diff3 utility, expecting that the
        external program return with a successful error code and that
        the full file contents which result from the completed merge
        operation are printed on the standard output stream (so that
        Subversion can redirect them into the appropriate version
        controlled file).  For most alternative merge programs, only
        the ninth, tenth, and eleventh arguments, the paths of the
        files which represent the <span class="quote">«<span class="quote">mine</span>»</span>,
        <span class="quote">«<span class="quote">older</span>»</span>, and <span class="quote">«<span class="quote">yours</span>»</span> inputs,
        respectively, are of interest.  Note that because Subversion
        depends on the output of your merge program, you wrapper
        script must not exit before that output has been delivered to
        Subversion.  When it finally does exit, it should return an
        errorcode of 0 if the merge was successful, or 1 if unresolved
        conflicts remain in the output—any other errorcode is
        considered a fatal error.</p><p><a class="xref" href="#svn.advanced.externaldifftools.diff3.ex-1" title="Пример 7.4. diff3wrap.sh">Пример&nbsp;7.4, «diff3wrap.sh»</a>
        and <a class="xref" href="#svn.advanced.externaldifftools.diff3.ex-2" title="Пример 7.5. diff3wrap.bat">Пример&nbsp;7.5, «diff3wrap.bat»</a> are
        templates for external merge tool wrappers in the Bourne shell
        and Windows batch scripting languages, respectively.</p><div class="example"><a id="svn.advanced.externaldifftools.diff3.ex-1"></a><p class="title"><strong>Пример 7.4. diff3wrap.sh</strong></p><div class="example-contents"><pre class="programlisting">#!/bin/sh

# Configure your favorite diff3/merge program here.
DIFF3="/usr/local/bin/my-merge-tool"

# Subversion provides the paths we need as the ninth, tenth, and eleventh
# parameters.
MINE=${9}
OLDER=${10}
YOURS=${11}

# Call the merge command (change the following line to make sense for
# your merge program).
$DIFF3 --older $OLDER --mine $MINE --yours $YOURS

# After performing the merge, this script needs to print the contents
# of the merged file to stdout.  Do that in whatever way you see fit.
# Return an errorcode of 0 on successful merge, 1 if unresolved conflicts
# remain in the result.  Any other errorcode will be treated as fatal.
</pre></div></div><br class="example-break"><br><div class="example"><a id="svn.advanced.externaldifftools.diff3.ex-2"></a><p class="title"><strong>Пример 7.5. diff3wrap.bat</strong></p><div class="example-contents"><pre class="programlisting">@ECHO OFF

REM Configure your favorite diff3/merge program here.
SET DIFF3="C:\Program Files\Funky Stuff\My Merge Tool.exe"

REM Subversion provides the paths we need as the ninth, tenth, and eleventh
REM parameters.  But we only have access to nine parameters at a time, so we
REM shift our nine-parameter window twice to let us get to what we need.
SHIFT
SHIFT
SET MINE=%7
SET OLDER=%8
SET YOURS=%9

REM Call the merge command (change the following line to make sense for
REM your merge program).
%DIFF3% --older %OLDER% --mine %MINE% --yours %YOURS%

REM After performing the merge, this script needs to print the contents
REM of the merged file to stdout.  Do that in whatever way you see fit.
REM Return an errorcode of 0 on successful merge, 1 if unresolved conflicts
REM remain in the result.  Any other errorcode will be treated as fatal.
</pre></div></div><br class="example-break"><br></div></div><div class="footnotes"><br><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.idp15098384" href="#idp15098384" class="para">48</a>] </sup>Переменная среды окружения
        <code class="literal">APPDATA</code> указывает на папку <code class="filename">Application
        Data</code> поэтому к этой директории можно всегда обращаться
        как к <code class="filename">%APPDATA%\Subversion</code>.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp15289344" href="#idp15289344" class="para">49</a>] </sup>Anyone for potluck
          dinner?</p></div><div class="footnote"><p><sup>[<a id="ftn.idp15384784" href="#idp15384784" class="para">50</a>] </sup>Subversion developers are good, but even the best make
          mistakes.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp15387648" href="#idp15387648" class="para">51</a>] </sup>The GNU diff manual page puts it this way: <span class="quote">«<span class="quote">An
            exit status of 0 means no differences were found, 1 means some
            differences were found, and 2 means trouble.</span>»</span></p></div></div></div><div class="chapter" title="Глава 8. Информация для разработчиков"><div class="titlepage"><div><div><h2 class="title"><a id="svn.developer"></a>Глава 8. Информация для разработчиков</h2></div></div></div><div class="toc"><p><strong>Содержание</strong></p><dl><dt><span class="sect1"><a href="#svn.developer.layerlib">Layered Library Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.developer.layerlib.repos">Repository Layer</a></span></dt><dt><span class="sect2"><a href="#svn.developer.layerlib.ra">Repository Access Layer</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.dav">RA-DAV (Repository Access Using HTTP/DAV)</a></span></dt><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.svn">RA-SVN (Custom Protocol Repository Access)</a></span></dt><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.local">RA-Local (Direct Repository Access)</a></span></dt><dt><span class="sect3"><a href="#svn.developer.layerlib.ra.yours">Your RA Library Here</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.developer.layerlib.client">Client Layer</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.developer.usingapi">Using the APIs</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.developer.usingapi.apr">The Apache Portable Runtime Library</a></span></dt><dt><span class="sect2"><a href="#svn.developer.usingapi.urlpath">URL and Path Requirements</a></span></dt><dt><span class="sect2"><a href="#svn.developer.usingapi.otherlangs">Using Languages Other than C and C++</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.developer.insidewc">Inside the Working Copy Administration Area</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.developer.insidewc.entries">The Entries File</a></span></dt><dt><span class="sect2"><a href="#svn.developer.insidewc.base-and-props">Pristine Copies and Property Files</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.developer.webdav">WebDAV</a></span></dt></dl></div><p>Subversion has a modular design, implemented as a collection
    of C libraries.  Each library has a well-defined purpose and
    interface, and those interfaces are available not only for
    Subversion itself to use, but for any software that wishes to
    embed or otherwise programmatically control Subversion.  Most of
    those interfaces are available not only in C, but also in
    higher-level languages such as Python or Java.</p><p>This chapter is for those who wish to interact with
    Subversion through its public Application Programming Interface
    (API) or various language bindings.  If you wish to write robust
    wrapper scripts around Subversion functionality to simplify your
    own life, are trying to develop more complex integrations
    between Subversion and other pieces of software, or just have an
    interest in Subversion's various library modules and what they
    offer, this chapter is for you.  If, however, you don't foresee
    yourself participating with Subversion at such a level, feel
    free to skip this chapter with the confidence that your
    experience as a Subversion user will not be affected.</p><div class="sect1" title="Layered Library Design"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.developer.layerlib"></a>Layered Library Design</h2></div></div></div><p>Each of Subversion's core libraries can be said to exist in
      one of three main layers—the Repository Layer, the
      Repository Access (RA) Layer, or the Client Layer.  We will
      examine these layers shortly, but first, see our brief inventory
      of Subversion's libraries in <a class="xref" href="#svn.developer.layerlib.tbl-1" title="Таблица 8.1. A Brief Inventory of the Subversion Libraries">Таблица&nbsp;8.1, «A Brief Inventory of the Subversion Libraries»</a>.  For the sake of
      consistency, we will refer to the libraries by their
      extensionless Unix library names (e.g.: libsvn_fs, libsvn_wc,
      mod_dav_svn).</p><div class="table"><a id="svn.developer.layerlib.tbl-1"></a><p class="title"><strong>Таблица 8.1. A Brief Inventory of the Subversion Libraries</strong></p><div class="table-contents"><table summary="A Brief Inventory of the Subversion Libraries" border="1"><colgroup><col><col></colgroup><thead><tr><th>Library</th><th>Description</th></tr></thead><tbody><tr><td>libsvn_client</td><td>Primary interface for client programs</td></tr><tr><td>libsvn_delta</td><td>Tree and byte-stream differencing routines</td></tr><tr><td>libsvn_diff</td><td>Contextual differencing and merging routines</td></tr><tr><td>libsvn_fs</td><td>Filesystem commons and module loader</td></tr><tr><td>libsvn_fs_base</td><td>The Berkeley DB filesystem back-end</td></tr><tr><td>libsvn_fs_fs</td><td>The native filesystem (FSFS) back-end</td></tr><tr><td>libsvn_ra</td><td>Repository Access commons and module loader</td></tr><tr><td>libsvn_ra_dav</td><td>The WebDAV Repository Access module</td></tr><tr><td>libsvn_ra_local</td><td>The local Repository Access module</td></tr><tr><td>libsvn_ra_svn</td><td>The custom protocol Repository Access module</td></tr><tr><td>libsvn_repos</td><td>Repository interface</td></tr><tr><td>libsvn_subr</td><td>Miscellaneous helpful subroutines</td></tr><tr><td>libsvn_wc</td><td>The working copy management library</td></tr><tr><td>mod_authz_svn</td><td>Apache authorization module for Subversion
            repositories access via WebDAV</td></tr><tr><td>mod_dav_svn</td><td>Apache module for mapping WebDAV operations to
            Subversion ones</td></tr></tbody></table></div></div><br class="table-break"><br><p>The fact that the word <span class="quote">«<span class="quote">miscellaneous</span>»</span> only
      appears once in <a class="xref" href="#svn.developer.layerlib.tbl-1" title="Таблица 8.1. A Brief Inventory of the Subversion Libraries">Таблица&nbsp;8.1, «A Brief Inventory of the Subversion Libraries»</a> is a good
      sign.  The Subversion development team is serious about making
      sure that functionality lives in the right layer and libraries.
      Perhaps the greatest advantage of the modular design is its lack
      of complexity from a developer's point of view.  As a developer,
      you can quickly formulate that kind of <span class="quote">«<span class="quote">big
      picture</span>»</span> that allows you to pinpoint the location of
      certain pieces of functionality with relative ease.</p><p>Another benefit of modularity is the ability to replace a
      given module with a whole new library that implements the same
      API without affecting the rest of the code base.  In some sense,
      this happens within Subversion already.  The libsvn_ra_dav,
      libsvn_ra_local, and libsvn_ra_svn all implement the same
      interface.  And all three communicate with the Repository
      Layer—libsvn_ra_dav and libsvn_ra_svn do so across a
      network, and libsvn_ra_local connects to it directly.  The
      libsvn_fs_base and libsvn_fs_fs libraries are another example of
      this.</p><p>The client itself also highlights modularity in the
      Subversion design.  While Subversion itself comes with only a
      command-line client program, there are several third party
      programs which provide various forms of client GUI.  These GUIs
      use the same APIs that the stock command-line client does.
      Subversion's libsvn_client library is the one-stop shop for most
      of the functionality necessary for designing a working
      Subversion client (see <a class="xref" href="#svn.developer.layerlib.client" title="Client Layer">«Client Layer»</a>).</p><div class="sect2" title="Repository Layer"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.layerlib.repos"></a>Repository Layer</h3></div></div></div><p>When referring to Subversion's Repository Layer, we're
        generally talking about two libraries—the repository
        library, and the filesystem library.  These libraries provide
        the storage and reporting mechanisms for the various revisions
        of your version-controlled data.  This layer is connected to
        the Client Layer via the Repository Access Layer, and is, from
        the perspective of the Subversion user, the stuff at the
        <span class="quote">«<span class="quote">other end of the line.</span>»</span></p><p>The Subversion Filesystem is accessed via the libsvn_fs
        API, and is not a kernel-level filesystem that one would
        install in an operating system (like the Linux ext2 or NTFS),
        but a virtual filesystem.  Rather than storing
        <span class="quote">«<span class="quote">files</span>»</span> and <span class="quote">«<span class="quote">directories</span>»</span> as real
        files and directories (as in, the kind you can navigate
        through using your favorite shell program), it uses one of two
        available abstract storage backends—either a Berkeley DB
        database environment, or a flat-file representation.  (To
        learn more about the two repository back-ends, see <a class="xref" href="#svn.reposadmin.basics.backends" title="Repository Data Stores">«Repository Data Stores»</a>.)  However, there has been
        considerable interest by the development community in giving
        future releases of Subversion the ability to use other
        back-end database systems, perhaps through a mechanism such as
        Open Database Connectivity (ODBC).</p><p>The filesystem API exported by libsvn_fs contains the
        kinds of functionality you would expect from any other
        filesystem API: you can create and remove files and
        directories, copy and move them around, modify file contents,
        and so on.  It also has features that are not quite as common,
        such as the ability to add, modify, and remove metadata
        (<span class="quote">«<span class="quote">properties</span>»</span>) on each file or directory.
        Furthermore, the Subversion Filesystem is a versioning
        filesystem, which means that as you make changes to your
        directory tree, Subversion remembers what your tree looked
        like before those changes.  And before the previous changes.
        And the previous ones.  And so on, all the way back through
        versioning time to (and just beyond) the moment you first
        started adding things to the filesystem.</p><p>All the modifications you make to your tree are done
        within the context of a Subversion transaction.  The following
        is a simplified general routine for modifying your
        filesystem:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Begin a Subversion transaction.</p></li><li class="listitem"><p>Make your changes (adds, deletes, property
            modifications, etc.).</p></li><li class="listitem"><p>Commit your transaction.</p></li></ol></div><p>Once you have committed your transaction, your filesystem
        modifications are permanently stored as historical artifacts.
        Each of these cycles generates a single new revision of your
        tree, and each revision is forever accessible as an immutable
        snapshot of <span class="quote">«<span class="quote">the way things were.</span>»</span></p><div class="sidebar" title="The Transaction Distraction"><div class="titlepage"><div><div><p class="title"><strong>The Transaction Distraction</strong></p></div></div></div><p>The notion of a Subversion transaction, especially given
          its close proximity to the database code in libsvn_fs, can
          become easily confused with the transaction support provided
          by the underlying database itself.  Both types of
          transaction exist to provide atomicity and isolation.  In
          other words, transactions give you the ability to perform a
          set of actions in an <span class="quote">«<span class="quote">all or nothing</span>»</span>
          fashion—either all the actions in the set complete
          with success, or they all get treated as if
          <span class="emphasis"><em>none</em></span> of them ever happened—and in
          a way that does not interfere with other processes acting on
          the data.</p><p>Database transactions generally encompass small
          operations related specifically to the modification of data
          in the database itself (such as changing the contents of a
          table row).  Subversion transactions are larger in scope,
          encompassing higher-level operations like making
          modifications to a set of files and directories which are
          intended to be stored as the next revision of the filesystem
          tree.  If that isn't confusing enough, consider this:
          Subversion uses a database transaction during the creation
          of a Subversion transaction (so that if the creation of
          Subversion transaction fails, the database will look as if
          we had never attempted that creation in the first
          place)!</p><p>Fortunately for users of the filesystem API, the
          transaction support provided by the database system itself
          is hidden almost entirely from view (as should be expected
          from a properly modularized library scheme).  It is only
          when you start digging into the implementation of the
          filesystem itself that such things become visible (or
          interesting).</p></div><p>Most of the functionality provided by the filesystem
        interface comes as an action that occurs on a filesystem path.
        That is, from outside of the filesystem, the primary mechanism
        for describing and accessing the individual revisions of files
        and directories comes through the use of path strings like
        <code class="filename">/foo/bar</code>, just as if you were addressing
        files and directories through your favorite shell program.
        You add new files and directories by passing their paths-to-be
        to the right API functions.  You query for information about
        them by the same mechanism.</p><p>Unlike most filesystems, though, a path alone is not
        enough information to identify a file or directory in
        Subversion.  Think of a directory tree as a two-dimensional
        system, where a node's siblings represent a sort of
        left-and-right motion, and descending into subdirectories a
        downward motion.  <a class="xref" href="#svn.developer.layerlib.repos.dia-1" title="Рисунок 8.1. Files and directories in two dimensions">Рисунок&nbsp;8.1, «Files and directories in two dimensions»</a> shows
        a typical representation of a tree as exactly that.</p><div class="figure"><a id="svn.developer.layerlib.repos.dia-1"></a><p class="title"><strong>Рисунок 8.1. Files and directories in two dimensions</strong></p><div class="figure-contents"><div><img src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/ch08dia1.png" alt="Files and directories in two dimensions"></div></div></div><br class="figure-break"><br><p>Of course, the Subversion filesystem has a nifty third
        dimension that most filesystems do not have—Time!
        <sup>[<a id="idp15777072" href="#ftn.idp15777072" class="footnote">52</a>]</sup>
        In the filesystem interface, nearly every function that has a
        <em class="parameter"><code>path</code></em> argument also expects a
        <em class="parameter"><code>root</code></em> argument.  This
        <span class="structname">svn_fs_root_t</span> argument describes
        either a revision or a Subversion transaction (which is
        usually just a revision-to-be), and provides that
        third-dimensional context needed to understand the difference
        between <code class="filename">/foo/bar</code> in revision 32, and the
        same path as it exists in revision 98.  <a class="xref" href="#svn.developer.layerlib.repos.dia-2" title="Рисунок 8.2. Versioning time—the third dimension!">Рисунок&nbsp;8.2, «Versioning time—the third dimension!»</a> shows revision history as an
        added dimension to the Subversion filesystem universe.</p><div class="figure"><a id="svn.developer.layerlib.repos.dia-2"></a><p class="title"><strong>Рисунок 8.2. Versioning time—the third dimension!</strong></p><div class="figure-contents"><div><img src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/ch08dia2.png" alt="Versioning time—the third dimension!"></div></div></div><br class="figure-break"><br><p>As we mentioned earlier, the libsvn_fs API looks and feels
        like any other filesystem, except that it has this wonderful
        versioning capability.  It was designed to be usable by any
        program interested in a versioning filesystem.  Not
        coincidentally, Subversion itself is interested in that
        functionality.  But while the filesystem API should be
        sufficient for basic file and directory versioning support,
        Subversion wants more—and that is where libsvn_repos
        comes in.</p><p>The Subversion repository library (libsvn_repos) is
        basically a wrapper library around the filesystem
        functionality.  This library is responsible for creating the
        repository layout, making sure that the underlying filesystem
        is initialized, and so on.  Libsvn_repos also implements a set
        of hooks—scripts that are executed by the repository
        code when certain actions take place.  These scripts are
        useful for notification, authorization, or whatever purposes
        the repository administrator desires.  This type of
        functionality, and other utilities provided by the repository
        library, are not strictly related to implementing a versioning
        filesystem, which is why it was placed into its own
        library.</p><p>Developers who wish to use the libsvn_repos API will find
        that it is not a complete wrapper around the filesystem
        interface.  That is, only certain major events in the general
        cycle of filesystem activity are wrapped by the repository
        interface.  Some of these include the creation and commit of
        Subversion transactions, and the modification of revision
        properties.  These particular events are wrapped by the
        repository layer because they have hooks associated with them.
        In the future, other events may be wrapped by the repository
        API.  All of the remaining filesystem interaction will
        continue to occur directly via the libsvn_fs API, though.</p><p>For example, here is a code segment that illustrates the
        use of both the repository and filesystem interfaces to create
        a new revision of the filesystem in which a directory is
        added.  Note that in this example, the
        <code class="function">SVN_ERR()</code> macro simply checks for a
        non-successful error return from the function it wraps, and
        returns that error if it exists.</p><div class="example"><a id="svn.developer.layerlib.repos.ex-1"></a><p class="title"><strong>Пример 8.1. Using the Repository Layer</strong></p><div class="example-contents"><pre class="programlisting">/* Create a new directory at the path NEW_DIRECTORY in the Subversion
   repository located at REPOS_PATH.  Perform all memory allocation in
   POOL.  This function will create a new revision for the addition of
   NEW_DIRECTORY.  */
static svn_error_t *
make_new_directory (const char *repos_path,
                    const char *new_directory,
                    apr_pool_t *pool)
{
  svn_error_t *err;
  svn_repos_t *repos;
  svn_fs_t *fs;
  svn_revnum_t youngest_rev;
  svn_fs_txn_t *txn;
  svn_fs_root_t *txn_root;
  const char *conflict_str;

  /* Open the repository located at REPOS_PATH.  */
  SVN_ERR (svn_repos_open (&amp;repos, repos_path, pool));

  /* Get a pointer to the filesystem object that is stored in
     REPOS.  */
  fs = svn_repos_fs (repos);

  /* Ask the filesystem to tell us the youngest revision that
     currently exists.  */
  SVN_ERR (svn_fs_youngest_rev (&amp;youngest_rev, fs, pool));

  /* Begin a new transaction that is based on YOUNGEST_REV.  We are
     less likely to have our later commit rejected as conflicting if we
     always try to make our changes against a copy of the latest snapshot
     of the filesystem tree.  */
  SVN_ERR (svn_fs_begin_txn (&amp;txn, fs, youngest_rev, pool));

  /* Now that we have started a new Subversion transaction, get a root
     object that represents that transaction.  */
  SVN_ERR (svn_fs_txn_root (&amp;txn_root, txn, pool));

  /* Create our new directory under the transaction root, at the path
     NEW_DIRECTORY.  */
  SVN_ERR (svn_fs_make_dir (txn_root, new_directory, pool));

  /* Commit the transaction, creating a new revision of the filesystem
     which includes our added directory path.  */
  err = svn_repos_fs_commit_txn (&amp;conflict_str, repos,
                                 &amp;youngest_rev, txn, pool);
  if (! err)
    {
      /* No error?  Excellent!  Print a brief report of our success.  */
      printf ("Directory '%s' was successfully added as new revision "
              "'%ld'.\n", new_directory, youngest_rev);
    }
  else if (err-&gt;apr_err == SVN_ERR_FS_CONFLICT)
    {
      /* Uh-oh.  Our commit failed as the result of a conflict
         (someone else seems to have made changes to the same area
         of the filesystem that we tried to modify).  Print an error
         message.  */
      printf ("A conflict occurred at path '%s' while attempting "
              "to add directory '%s' to the repository at '%s'.\n",
              conflict_str, new_directory, repos_path);
    }
  else
    {
      /* Some other error has occurred.  Print an error message.  */
      printf ("An error occurred while attempting to add directory '%s' "
              "to the repository at '%s'.\n",
              new_directory, repos_path);
    }

  /* Return the result of the attempted commit to our caller.  */
  return err;
}
</pre></div></div><br class="example-break"><br><p>In the previous code segment, calls were made to both the
        repository and filesystem interfaces.  We could just as easily
        have committed the transaction using
        <code class="function">svn_fs_commit_txn()</code>.  But the filesystem
        API knows nothing about the repository library's hook
        mechanism.  If you want your Subversion repository to
        automatically perform some set of non-Subversion tasks every
        time you commit a transaction (like, for example, sending an
        email that describes all the changes made in that transaction
        to your developer mailing list), you need to use the
        libsvn_repos-wrapped version of that
        function—<code class="function">svn_repos_fs_commit_txn()</code>.
        This function will actually first run the
        <code class="literal">pre-commit</code> hook script if one exists, then
        commit the transaction, and finally will run a
        <code class="literal">post-commit</code> hook script.  The hooks provide
        a special kind of reporting mechanism that does not really
        belong in the core filesystem library itself.  (For more
        information regarding Subversion's repository hooks, see <a class="xref" href="#svn.reposadmin.create.hooks" title="Hook Scripts">«Hook Scripts»</a>.)</p><p>The hook mechanism requirement is but one of the reasons
        for the abstraction of a separate repository library from the
        rest of the filesystem code.  The libsvn_repos API provides
        several other important utilities to Subversion.  These
        include the abilities to:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>create, open, destroy, and perform recovery steps on a
            Subversion repository and the filesystem included in that
            repository.</p></li><li class="listitem"><p>describe the differences between two filesystem
            trees.</p></li><li class="listitem"><p>query for the commit log messages
            associated with all (or some) of the revisions in which a
            set of files was modified in the filesystem.</p></li><li class="listitem"><p>generate a human-readable <span class="quote">«<span class="quote">dump</span>»</span> of the
            filesystem, a complete representation of the revisions in
            the filesystem.</p></li><li class="listitem"><p>parse that dump format, loading the dumped revisions
            into a different Subversion repository.</p></li></ol></div><p>As Subversion continues to evolve, the repository library
        will grow with the filesystem library to offer increased
        functionality and configurable option support.</p></div><div class="sect2" title="Repository Access Layer"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.layerlib.ra"></a>Repository Access Layer</h3></div></div></div><p>If the Subversion Repository Layer is at <span class="quote">«<span class="quote">the other
        end of the line</span>»</span>, the Repository Access Layer is the
        line itself.  Charged with marshalling data between the client
        libraries and the repository, this layer includes the
        libsvn_ra module loader library, the RA modules themselves
        (which currently includes libsvn_ra_dav, libsvn_ra_local, and
        libsvn_ra_svn), and any additional libraries needed by one or
        more of those RA modules, such as the mod_dav_svn Apache
        module with which libsvn_ra_dav communicates or
        libsvn_ra_svn's server, <span class="command"><strong>svnserve</strong></span>.</p><p>Since Subversion uses URLs to identify its repository
        resources, the protocol portion of the URL schema (usually
        <code class="literal">file:</code>, <code class="literal">http:</code>,
        <code class="literal">https:</code>, or <code class="literal">svn:</code>) is used
        to determine which RA module will handle the communications.
        Each module registers a list of the protocols it knows how to
        <span class="quote">«<span class="quote">speak</span>»</span> so that the RA loader can, at runtime,
        determine which module to use for the task at hand.  You can
        determine which RA modules are available to the Subversion
        command-line client, and what protocols they claim to support,
        by running <span class="command"><strong>svn --version</strong></span>:</p><pre class="screen">$ svn --version
svn, version 1.2.3 (r15833)
   compiled Sep 13 2005, 22:45:22

Copyright (C) 2000-2005 CollabNet.
Subversion is open source software, see http://subversion.tigris.org/
This product includes software developed by CollabNet (http://www.Collab.Net/).

The following repository access (RA) modules are available:

* ra_dav : Module for accessing a repository via WebDAV (DeltaV) protocol.
  - handles 'http' scheme
  - handles 'https' scheme
* ra_svn : Module for accessing a repository using the svn network protocol.
  - handles 'svn' scheme
* ra_local : Module for accessing a repository on local disk.
  - handles 'file' scheme

</pre><div class="sect3" title="RA-DAV (Repository Access Using HTTP/DAV)"><div class="titlepage"><div><div><h4 class="title"><a id="svn.developer.layerlib.ra.dav"></a>RA-DAV (Repository Access Using HTTP/DAV)</h4></div></div></div><p>The libsvn_ra_dav library is designed for use by clients
          that are being run on different machines than the servers
          with which they communicating, specifically servers reached
          using URLs that contain the <code class="literal">http:</code> or
          <code class="literal">https:</code> protocol portions.  To understand
          how this module works, we should first mention a couple of
          other key components in this particular configuration of the
          Repository Access Layer—the powerful Apache HTTP
          Server, and the Neon HTTP/WebDAV client library.</p><p>Subversion's primary network server is the Apache HTTP
          Server.  Apache is a time-tested, extensible open-source
          server process that is ready for serious use.  It can
          sustain a high network load and runs on many platforms.  The
          Apache server supports a number of different standard
          authentication protocols, and can be extended through the
          use of modules to support many others.  It also supports
          optimizations like network pipelining and caching.  By using
          Apache as a server, Subversion gets all of these features
          for free.  And since most firewalls already allow HTTP
          traffic to pass through, system administrators typically
          don't even have to change their firewall configurations to
          allow Subversion to work.</p><p>Subversion uses HTTP and WebDAV (with DeltaV) to
          communicate with an Apache server.  You can read more about
          this in the WebDAV section of this chapter, but in short,
          WebDAV and DeltaV are extensions to the standard HTTP 1.1
          protocol that enable sharing and versioning of files over
          the web.  Apache 2.0 and later versions come with mod_dav,
          an Apache module that understands the DAV extensions to
          HTTP.  Subversion itself supplies mod_dav_svn, though, which
          is another Apache module that works in conjunction with
          (really, as a back-end to) mod_dav to provide Subversion's
          specific implementations of WebDAV and DeltaV.</p><p>When communicating with a repository over HTTP, the RA
          loader library chooses libsvn_ra_dav as the proper access
          module.  The Subversion client makes calls into the generic
          RA interface, and libsvn_ra_dav maps those calls (which
          embody rather large-scale Subversion actions) to a set of
          HTTP/WebDAV requests.  Using the Neon library, libsvn_ra_dav
          transmits those requests to the Apache server.  Apache
          receives these requests (exactly as it does generic HTTP
          requests that your web browser might make), notices that the
          requests are directed at a URL that is configured as a DAV
          location (using the <code class="literal">&lt;Location&gt;</code>
          directive in <code class="filename">httpd.conf</code>), and hands the
          request off to its own mod_dav module.  When properly
          configured, mod_dav knows to use Subversion's mod_dav_svn for
          any filesystem-related needs, as opposed to the generic
          mod_dav_fs that comes with Apache.  So ultimately, the client
          is communicating with mod_dav_svn, which binds directly to the
          Subversion Repository Layer.</p><p>That was a simplified description of the actual
          exchanges taking place, though.  For example, the Subversion
          repository might be protected by Apache's authorization
          directives.  This could result in initial attempts to
          communicate with the repository being rejected by Apache on
          authorization grounds.  At this point, libsvn_ra_dav gets
          back the notice from Apache that insufficient identification
          was supplied, and calls back into the Client Layer to get
          some updated authentication data.  If the data is supplied
          correctly, and the user has the permissions that Apache
          seeks, libsvn_ra_dav's next automatic attempt at performing
          the original operation will be granted, and all will be
          well.  If sufficient authentication information cannot be
          supplied, the request will ultimately fail, and the client
          will report the failure to the user.</p><p>By using Neon and Apache, Subversion gets free
          functionality in several other complex areas, too.  For
          example, if Neon finds the OpenSSL libraries, it allows the
          Subversion client to attempt to use SSL-encrypted
          communications with the Apache server (whose own mod_ssl can
          <span class="quote">«<span class="quote">speak the language</span>»</span>).  Also, both Neon itself
          and Apache's mod_deflate can understand the
          <span class="quote">«<span class="quote">deflate</span>»</span> algorithm (the same one used by the
          PKZIP and gzip programs), so requests can be sent in smaller,
          compressed chunks across the wire.  Other complex features
          that Subversion hopes to support in the future include the
          ability to automatically handle server-specified redirects
          (for example, when a repository has been moved to a new
          canonical URL) and taking advantage of HTTP
          pipelining.</p></div><div class="sect3" title="RA-SVN (Custom Protocol Repository Access)"><div class="titlepage"><div><div><h4 class="title"><a id="svn.developer.layerlib.ra.svn"></a>RA-SVN (Custom Protocol Repository Access)</h4></div></div></div><p>In addition to the standard HTTP/WebDAV protocol,
          Subversion also provides an RA implementation that uses a
          custom protocol.  The libsvn_ra_svn module implements
          its own network socket connectivity, and communicates with a
          stand-alone server—the <code class="filename">svnserve</code>
          program—on the machine that hosts the
          repository.  Clients access the repository using the
          <code class="literal">svn://</code> schema.</p><p>This RA implementation lacks most of the advantages of
          Apache mentioned in the previous section; however, it may be
          appealing to some system administrators nonetheless.  It is
          dramatically easier to configure and run; setting up an
          <code class="filename">svnserve</code> process is nearly
          instantaneous.  It is also much smaller (in terms of lines
          of code) than Apache, making it much easier to audit, for
          security reasons or otherwise.  Furthermore, some system
          administrators may already have an SSH security
          infrastructure in place, and want Subversion to use it.
          Clients using ra_svn can easily tunnel the protocol over
          SSH.</p></div><div class="sect3" title="RA-Local (Direct Repository Access)"><div class="titlepage"><div><div><h4 class="title"><a id="svn.developer.layerlib.ra.local"></a>RA-Local (Direct Repository Access)</h4></div></div></div><p>Not all communications with a Subversion repository
          require a powerhouse server process and a network layer.
          For users who simply wish to access the repositories on
          their local disk, they may do so using
          <code class="literal">file:</code> URLs and the functionality provided
          by libsvn_ra_local.  This RA module binds directly with the
          repository and filesystem libraries, so no network
          communication is required at all.</p><p>Subversion requires that the server name included as part
          of the <code class="literal">file:</code> URL be either
          <code class="literal">localhost</code> or empty, and that there be no
          port specification.  In other words, your URLs should look
          like either
          <code class="literal">file://localhost/path/to/repos</code> or
          <code class="literal">file:///path/to/repos</code>.</p><p>Also, be aware that Subversion's
          <code class="literal">file:</code> URLs cannot be used in a regular
          web browser the way typical <code class="literal">file:</code> URLs
          can.  When you attempt to view a <code class="literal">file:</code>
          URL in a regular web browser, it reads and displays the
          contents of the file at that location by examining the
          filesystem directly.  However, Subversion's resources exist
          in a virtual filesystem (see <a class="xref" href="#svn.developer.layerlib.repos" title="Repository Layer">«Repository Layer»</a>), and your browser will not
          understand how to read that filesystem.</p></div><div class="sect3" title="Your RA Library Here"><div class="titlepage"><div><div><h4 class="title"><a id="svn.developer.layerlib.ra.yours"></a>Your RA Library Here</h4></div></div></div><p>For those who wish to access a Subversion repository
          using still another protocol, that is precisely why the
          Repository Access Layer is modularized!  Developers can
          simply write a new library that implements the RA interface
          on one side and communicates with the repository on the
          other.  Your new library can use existing network protocols,
          or you can invent your own.  You could use inter-process
          communication (IPC) calls, or—let's get crazy, shall
          we?—you could even implement an email-based protocol.
          Subversion supplies the APIs; you supply the creativity.</p></div></div><div class="sect2" title="Client Layer"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.layerlib.client"></a>Client Layer</h3></div></div></div><p>On the client side, the Subversion working copy is where
        all the action takes place.  The bulk of functionality
        implemented by the client-side libraries exists for the sole
        purpose of managing working copies—directories full of
        files and other subdirectories which serve as a sort of local,
        editable <span class="quote">«<span class="quote">reflection</span>»</span> of one or more repository
        locations—and propagating changes to and from the
        Repository Access layer.</p><p>Subversion's working copy library, libsvn_wc, is directly
        responsible for managing the data in the working copies.  To
        accomplish this, the library stores administrative information
        about each working copy directory within a special
        subdirectory.  This subdirectory, named
        <code class="filename">.svn</code>, is present in each working copy
        directory and contains various other files and directories
        which record state and provide a private workspace for
        administrative action.  For those familiar with CVS, this
        <code class="filename">.svn</code> subdirectory is similar in purpose
        to the <code class="filename">CVS</code> administrative directories
        found in CVS working copies.  For more information about the
        <code class="filename">.svn</code> administrative area, see <a class="xref" href="#svn.developer.insidewc" title="Inside the Working Copy Administration Area">«Inside the Working Copy Administration Area»</a>in this chapter.</p><p>The Subversion client library, libsvn_client, has the
        broadest responsibility; its job is to mingle the
        functionality of the working copy library with that of the
        Repository Access Layer, and then to provide the highest-level
        API to any application that wishes to perform general revision
        control actions.  For example, the function
        <code class="function">svn_client_checkout()</code> takes a URL as an
        argument.  It passes this URL to the RA layer and opens an
        authenticated session with a particular repository.  It then
        asks the repository for a certain tree, and sends this tree
        into the working copy library, which then writes a full
        working copy to disk (<code class="filename">.svn</code> directories
        and all).</p><p>The client library is designed to be used by any
        application.  While the Subversion source code includes a
        standard command-line client, it should be very easy to write
        any number of GUI clients on top of the client library.  New
        GUIs (or any new client, really) for Subversion need not be
        clunky wrappers around the included command-line
        client—they have full access via the libsvn_client API
        to same functionality, data, and callback mechanisms that the
        command-line client uses.</p><div class="sidebar" title="Binding Directly—A Word About Correctness"><div class="titlepage"><div><div><p class="title"><strong>Binding Directly—A Word About Correctness</strong></p></div></div></div><p>Why should your GUI program bind directly with a
          libsvn_client instead of acting as a wrapper around a
          command-line program?  Besides simply being more efficient,
          this can address potential correctness issues as well.  A
          command-line program (like the one supplied with Subversion)
          that binds to the client library needs to effectively
          translate feedback and requested data bits from C types to
          some form of human-readable output.  This type of
          translation can be lossy.  That is, the program may not
          display all of the information harvested from the API, or
          may combine bits of information for compact representation.</p><p>If you wrap such a command-line program with yet another
          program, the second program has access only to
          already-interpreted (and as we mentioned, likely incomplete)
          information, which it must <span class="emphasis"><em>again</em></span>
          translate into <span class="emphasis"><em>its</em></span> representation
          format.  With each layer of wrapping, the integrity of the
          original data is potentially tainted more and more, much
          like the result of making a copy of a copy (of a copy …)
          of a favorite audio or video cassette.</p></div></div></div><div class="sect1" title="Using the APIs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.developer.usingapi"></a>Using the APIs</h2></div></div></div><p>Developing applications against the Subversion library APIs
      is fairly straightforward.  All of the public header files live
      in the <code class="filename">subversion/include</code> directory of the
      source tree.  These headers are copied into your system
      locations when you build and install Subversion itself from
      source.  These headers represent the entirety of the functions
      and types meant to be accessible by users of the Subversion
      libraries.</p><p>The first thing you might notice is that Subversion's
      datatypes and functions are namespace protected.  Every public
      Subversion symbol name begins with <code class="literal">svn_</code>,
      followed by a short code for the library in which the symbol is
      defined (such as <code class="literal">wc</code>,
      <code class="literal">client</code>, <code class="literal">fs</code>, etc.),
      followed by a single underscore (<code class="literal">_</code>) and
      then the rest of the symbol name.  Semi-public functions (used
      among source files of a given library but not by code outside
      that library, and found inside the library directories
      themselves) differ from this naming scheme in that instead of a
      single underscore after the library code, they use a double
      underscore (<code class="literal">__</code>).  Functions that are private
      to a given source file have no special prefixing, and are declared
      <code class="literal">static</code>.  Of course, a compiler isn't
      interested in these naming conventions, but they help to clarify
      the scope of a given function or datatype.</p><div class="sect2" title="The Apache Portable Runtime Library"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.usingapi.apr"></a>The Apache Portable Runtime Library</h3></div></div></div><p>Along with Subversion's own datatypes, you will see many
        references to datatypes that begin with
        <code class="literal">apr_</code>—symbols from the Apache
        Portable Runtime (APR) library.  APR is Apache's portability
        library, originally carved out of its server code as an
        attempt to separate the OS-specific bits from the
        OS-independent portions of the code.  The result was a library
        that provides a generic API for performing operations that
        differ mildly—or wildly—from OS to OS.  While the
        Apache HTTP Server was obviously the first user of the APR
        library, the Subversion developers immediately recognized the
        value of using APR as well.  This means that there are
        practically no OS-specific code portions in Subversion itself.
        Also, it means that the Subversion client compiles and runs
        anywhere that the server does.  Currently this list includes
        all flavors of Unix, Win32, BeOS, OS/2, and Mac OS X.</p><p>In addition to providing consistent implementations of
        system calls that differ across operating systems,
        <sup>[<a id="idp15878320" href="#ftn.idp15878320" class="footnote">53</a>]</sup>
        APR gives Subversion immediate access to many custom
        datatypes, such as dynamic arrays and hash tables.  Subversion
        uses these types extensively throughout the codebase.  But
        perhaps the most pervasive APR datatype, found in nearly every
        Subversion API prototype, is the
        <span class="structname">apr_pool_t</span>—the APR memory pool.
        Subversion uses pools internally for all its memory allocation
        needs (unless an external library requires a different memory
        management schema for data passed through its API),
        <sup>[<a id="idp15880192" href="#ftn.idp15880192" class="footnote">54</a>]</sup>
        and while a person coding against the Subversion APIs is
        not required to do the same, they are required to provide
        pools to the API functions that need them.  This means that
        users of the Subversion API must also link against APR, must
        call <code class="function">apr_initialize()</code> to initialize the
        APR subsystem, and then must create and manage pools for use with
        Subversion API calls, typically by using
        <code class="function">svn_pool_create()</code>,
        <code class="function">svn_pool_clear()</code>, and 
        <code class="function">svn_pool_destroy()</code>.</p></div><div class="sect2" title="URL and Path Requirements"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.usingapi.urlpath"></a>URL and Path Requirements</h3></div></div></div><p>With remote version control operation as the whole point
        of Subversion's existence, it makes sense that some attention
        has been paid to internationalization (i18n) support.  After
        all, while <span class="quote">«<span class="quote">remote</span>»</span> might mean <span class="quote">«<span class="quote">across the
        office</span>»</span>, it could just as well mean <span class="quote">«<span class="quote">across the
        globe.</span>»</span> To facilitate this, all of Subversion's public
        interfaces that accept path arguments expect those paths to be
        canonicalized, and encoded in UTF-8.  This means, for example,
        that any new client binary that drives the libsvn_client
        interface needs to first convert paths from the
        locale-specific encoding to UTF-8 before passing those paths
        to the Subversion libraries, and then re-convert any resultant
        output paths from Subversion back into the locale's encoding
        before using those paths for non-Subversion purposes.
        Fortunately, Subversion provides a suite of functions (see
        <code class="filename">subversion/include/svn_utf.h</code>) that can be
        used by any program to do these conversions.</p><p>Also, Subversion APIs require all URL parameters to be
        properly URI-encoded.  So, instead of passing
        <code class="uri">file:///home/username/My File.txt</code> as the URL of a
        file named <code class="literal">My File.txt</code>, you need to pass
        <code class="uri">file:///home/username/My%20File.txt</code>.  Again,
        Subversion supplies helper functions that your application can
        use—<code class="function">svn_path_uri_encode()</code> and
        <code class="function">svn_path_uri_decode()</code>, for URI encoding
        and decoding, respectively.</p></div><div class="sect2" title="Using Languages Other than C and C++"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.usingapi.otherlangs"></a>Using Languages Other than C and C++</h3></div></div></div><p>If you are interested in using the Subversion libraries in
        conjunction with something other than a C program—say a
        Python or Perl script—Subversion has some support for this
        via the Simplified Wrapper and Interface Generator (SWIG).  The
        SWIG bindings for Subversion are located in
        <code class="filename">subversion/bindings/swig</code> and whilst still
        maturing, they are in a usable state.  These bindings allow you
        to call Subversion API functions indirectly, using wrappers that
        translate the datatypes native to your scripting language into
        the datatypes needed by Subversion's C libraries.</p><p>There is an obvious benefit to accessing the Subversion
        APIs via a language binding—simplicity.  Generally
        speaking, languages such as Python and Perl are much more
        flexible and easy to use than C or C++.  The sort of
        high-level datatypes and context-driven type checking provided
        by these languages are often better at handling information
        that comes from users.  As you know, humans are proficient at
        botching up input to a program, and scripting languages tend
        to handle that misinformation more gracefully.  Of course,
        often that flexibility comes at the cost of performance.  That
        is why using a tightly-optimized, C-based interface and
        library suite, combined with a powerful, flexible binding
        language, is so appealing.</p><p>Let's look at a sample program that uses Subversion's
        Python SWIG bindings to recursively crawl the youngest
        repository revision, and print the various paths reached
        during the crawl.</p><div class="example"><a id="svn.developer.usingapi.otherlangs.ex-1"></a><p class="title"><strong>Пример 8.2. Using the Repository Layer with Python</strong></p><div class="example-contents"><pre class="programlisting">#!/usr/bin/python

"""Crawl a repository, printing versioned object path names."""

import sys
import os.path
import svn.fs, svn.core, svn.repos

def crawl_filesystem_dir(root, directory, pool):
    """Recursively crawl DIRECTORY under ROOT in the filesystem, and return
    a list of all the paths at or below DIRECTORY.  Use POOL for all
    allocations."""

    # Print the name of this path.
    print directory + "/"

    # Get the directory entries for DIRECTORY.
    entries = svn.fs.svn_fs_dir_entries(root, directory, pool)

    # Use an iteration subpool.
    subpool = svn.core.svn_pool_create(pool)

    # Loop over the entries.
    names = entries.keys()
    for name in names:
        # Clear the iteration subpool.
        svn.core.svn_pool_clear(subpool)

        # Calculate the entry's full path.
        full_path = directory + '/' + name

        # If the entry is a directory, recurse.  The recursion will return
        # a list with the entry and all its children, which we will add to
        # our running list of paths.
        if svn.fs.svn_fs_is_dir(root, full_path, subpool):
            crawl_filesystem_dir(root, full_path, subpool)
        else:
            # Else it's a file, so print its path here.
            print full_path

    # Destroy the iteration subpool.
    svn.core.svn_pool_destroy(subpool)

def crawl_youngest(pool, repos_path):
    """Open the repository at REPOS_PATH, and recursively crawl its
    youngest revision."""

    # Open the repository at REPOS_PATH, and get a reference to its
    # versioning filesystem.
    repos_obj = svn.repos.svn_repos_open(repos_path, pool)
    fs_obj = svn.repos.svn_repos_fs(repos_obj)

    # Query the current youngest revision.
    youngest_rev = svn.fs.svn_fs_youngest_rev(fs_obj, pool)

    # Open a root object representing the youngest (HEAD) revision.
    root_obj = svn.fs.svn_fs_revision_root(fs_obj, youngest_rev, pool)

    # Do the recursive crawl.
    crawl_filesystem_dir(root_obj, "", pool)

if __name__ == "__main__":
    # Check for sane usage.
    if len(sys.argv) != 2:
        sys.stderr.write("Usage: %s REPOS_PATH\n"
                         % (os.path.basename(sys.argv[0])))
        sys.exit(1)

    # Canonicalize (enough for Subversion, at least) the repository path.
    repos_path = os.path.normpath(sys.argv[1])
    if repos_path == '.': 
        repos_path = ''

    # Call the app-wrapper, which takes care of APR initialization/shutdown
    # and the creation and cleanup of our top-level memory pool.
    svn.core.run_app(crawl_youngest, repos_path)
</pre></div></div><br class="example-break"><br><p>This same program in C would need to deal with custom
        datatypes (such as those provided by the APR library) for
        representing the hash of entries and the list of paths, but
        Python has hashes (called <span class="quote">«<span class="quote">dictionaries</span>»</span>) and
        lists as built-in datatypes, and provides a rich collection of
        functions for operating on those types.  So SWIG (with the
        help of some customizations in Subversion's language bindings
        layer) takes care of mapping those custom datatypes into the
        native datatypes of the target language.  This provides a more
        intuitive interface for users of that language.</p><p>The Subversion Python bindings can be used for working
        copy operations, too.  In the previous section of this
        chapter, we mentioned the <code class="filename">libsvn_client</code>
        interface, and how it exists for the sole purpose of
        simplifying the process of writing a Subversion client.  The
        following is a brief example of how that library can be
        accessed via the SWIG bindings to recreate a scaled-down
        version of the <span class="command"><strong>svn status</strong></span> command.</p><div class="example"><a id="svn.developer.usingapi.otherlangs.ex-2"></a><p class="title"><strong>Пример 8.3. A Python Status Crawler</strong></p><div class="example-contents"><pre class="programlisting">#!/usr/bin/env python

"""Crawl a working copy directory, printing status information."""

import sys
import os.path
import getopt
import svn.core, svn.client, svn.wc

def generate_status_code(status):
    """Translate a status value into a single-character status code,
    using the same logic as the Subversion command-line client."""

    if status == svn.wc.svn_wc_status_none:
        return ' '
    if status == svn.wc.svn_wc_status_normal:
        return ' '
    if status == svn.wc.svn_wc_status_added:
        return 'A'
    if status == svn.wc.svn_wc_status_missing:
        return '!'
    if status == svn.wc.svn_wc_status_incomplete:
        return '!'
    if status == svn.wc.svn_wc_status_deleted:
        return 'D'
    if status == svn.wc.svn_wc_status_replaced:
        return 'R'
    if status == svn.wc.svn_wc_status_modified:
        return 'M'
    if status == svn.wc.svn_wc_status_merged:
        return 'G'
    if status == svn.wc.svn_wc_status_conflicted:
        return 'C'
    if status == svn.wc.svn_wc_status_obstructed:
        return '~'
    if status == svn.wc.svn_wc_status_ignored:
        return 'I'
    if status == svn.wc.svn_wc_status_external:
        return 'X'
    if status == svn.wc.svn_wc_status_unversioned:
        return '?'
    return '?'

def do_status(pool, wc_path, verbose):
    # Calculate the length of the input working copy path.
    wc_path_len = len(wc_path)

    # Build a client context baton.
    ctx = svn.client.svn_client_ctx_t()

    def _status_callback(path, status, root_path_len=wc_path_len):
        """A callback function for svn_client_status."""

        # Print the path, minus the bit that overlaps with the root of
        # the status crawl
        text_status = generate_status_code(status.text_status)
        prop_status = generate_status_code(status.prop_status)
        print '%s%s  %s' % (text_status, prop_status, path[wc_path_len + 1:])

    # Do the status crawl, using _status_callback() as our callback function.
    svn.client.svn_client_status(wc_path, None, _status_callback,
                                 1, verbose, 0, 0, ctx, pool)

def usage_and_exit(errorcode):
    """Print usage message, and exit with ERRORCODE."""
    stream = errorcode and sys.stderr or sys.stdout
    stream.write("""Usage: %s OPTIONS WC-PATH
Options:
  --help, -h    : Show this usage message
  --verbose, -v : Show all statuses, even uninteresting ones
""" % (os.path.basename(sys.argv[0])))
    sys.exit(errorcode)

if __name__ == '__main__':
    # Parse command-line options.
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hv", ["help", "verbose"])
    except getopt.GetoptError:
        usage_and_exit(1)
    verbose = 0
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage_and_exit(0)
        if opt in ("-v", "--verbose"):
            verbose = 1
    if len(args) != 1:
        usage_and_exit(2)

    # Canonicalize (enough for Subversion, at least) the working copy path.
    wc_path = os.path.normpath(args[0])
    if wc_path == '.': 
        wc_path = ''

    # Call the app-wrapper, which takes care of APR initialization/shutdown
    # and the creation and cleanup of our top-level memory pool.
    svn.core.run_app(do_status, wc_path, verbose)
</pre></div></div><br class="example-break"><br><p>Subversion's language bindings unfortunately tend to lack
        the level of attention given to the core Subversion modules.
        However, there have been significant efforts towards creating
        functional bindings for Python, Perl, and Ruby.  To some extent,
        the work done preparing the SWIG interface files for these
        languages is reusable in efforts to generate bindings for other
        languages supported by SWIG (which includes versions of C#,
        Guile, Java, MzScheme, OCaml, PHP, Tcl, and others).
        However, some extra programming is required to compensate for
        complex APIs that SWIG needs some help interfacing with.  For
        more information on SWIG itself, see the project's website at
        <a class="ulink" href="http://www.swig.org/" target="_top">http://www.swig.org/</a>.</p></div></div><div class="sect1" title="Inside the Working Copy Administration Area"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.developer.insidewc"></a>Inside the Working Copy Administration Area</h2></div></div></div><p>As we mentioned earlier, each directory of a Subversion
      working copy contains a special subdirectory called
      <code class="filename">.svn</code> which houses administrative data about
      that working copy directory.  Subversion uses the information in
      <code class="filename">.svn</code> to keep track of things like:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Which repository location(s) are represented by the
          files and subdirectories in the working copy
          directory.</p></li><li class="listitem"><p>What revision of each of those files and directories are
          currently present in the working copy.</p></li><li class="listitem"><p>Any user-defined properties that might be attached
          to those files and directories.</p></li><li class="listitem"><p>Pristine (un-edited) copies of the working copy
          files.</p></li></ul></div><p>While there are several other bits of data stored in the
      <code class="filename">.svn</code> directory, we will examine only a
      couple of the most important items.</p><div class="sect2" title="The Entries File"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.insidewc.entries"></a>The Entries File</h3></div></div></div><p>Perhaps the single most important file in the
        <code class="filename">.svn</code> directory is the
        <code class="filename">entries</code> file.  The entries file is an XML
        document which contains the bulk of the administrative
        information about a versioned resource in a working copy
        directory.  It is this one file which tracks the repository
        URLs, pristine revision, file checksums, pristine text and
        property timestamps, scheduling and conflict state
        information, last-known commit information (author, revision,
        timestamp), local copy history—practically everything
        that a Subversion client is interested in knowing about a
        versioned (or to-be-versioned) resource!</p><div class="sidebar" title="Comparing the Administrative Areas of Subversion and CVS"><div class="titlepage"><div><div><p class="title"><strong>Comparing the Administrative Areas of Subversion and
          CVS</strong></p></div></div></div><p>A glance inside the typical <code class="filename">.svn</code>
          directory turns up a bit more than what CVS maintains in its
          <code class="filename">CVS</code> administrative directories.  The
          <code class="filename">entries</code> file contains XML which
          describes the current state of the working copy directory,
          and basically serves the purposes of CVS's
          <code class="filename">Entries</code>, <code class="filename">Root</code>, and
          <code class="filename">Repository</code> files combined.</p></div><p>The following is an example of an actual entries
        file:</p><div class="example"><a id="svn.developer.insidewc.entries.ex-1"></a><p class="title"><strong>Пример 8.4. Contents of a Typical <code class="filename">.svn/entries</code>
          File</strong></p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;wc-entries
   xmlns="svn:"&gt;
&lt;entry
   committed-rev="1"
   name=""
   committed-date="2005-04-04T13:32:28.526873Z"
   url="http://svn.red-bean.com/repos/greek-tree/A/D"
   last-author="jrandom"
   kind="dir"
   uuid="4e820d15-a807-0410-81d5-aa59edf69161"
   revision="1"/&gt;
&lt;entry
   name="lambda"
   copied="true"
   kind="file"
   copyfrom-rev="1"
   schedule="add"
   copyfrom-url="http://svn.red-bean.com/repos/greek-tree/A/B/lambda"/&gt;
&lt;entry
   committed-rev="1"
   name="gamma"
   text-time="2005-12-11T16:32:46.000000Z"
   committed-date="2005-04-04T13:32:28.526873Z"
   checksum="ada10d942b1964d359e048dbacff3460"
   last-author="jrandom"
   kind="file"
   prop-time="2005-12-11T16:32:45.000000Z"/&gt;
&lt;entry
   name="zeta"
   kind="file"
   schedule="add"
   revision="0"/&gt;
&lt;entry
   name="G"
   kind="dir"/&gt;
&lt;entry
   name="H"
   kind="dir"
   schedule="delete"/&gt;
&lt;/wc-entries&gt;
</pre></div></div><br class="example-break"><br><p>As you can see, the entries file is essentially a list of
        entries.  Each <code class="sgmltag-element">entry</code> tag represents one of
        three things: the working copy directory itself (called the
        <span class="quote">«<span class="quote">this directory</span>»</span> entry, and noted as having an
        empty value for its <em class="structfield"><code>name</code></em>
        attribute), a file in that working copy directory (noted by
        having its <em class="structfield"><code>kind</code></em> attribute set to
        <code class="literal">"file"</code>), or a subdirectory in that working
        copy (<em class="structfield"><code>kind</code></em> here is set to
        <code class="literal">"dir"</code>).  The files and subdirectories whose
        entries are stored in this file are either already under
        version control, or (as in the case of the file named
        <code class="filename">zeta</code> above) are scheduled to be added to
        version control when the user next commits this working copy
        directory's changes.  Each entry has a unique name, and each
        entry has a node kind.</p><p>Developers should be aware of some special rules that
        Subversion uses when reading and writing its
        <code class="filename">entries</code> files.  While each entry has a
        revision and URL associated with it, note that not every
        <code class="sgmltag-element">entry</code> tag in the sample file has explicit
        <em class="structfield"><code>revision</code></em> or
        <em class="structfield"><code>url</code></em> attributes attached to it.
        Subversion allows entries to not explicitly store those two
        attributes when their values are the same as (in the
        <em class="structfield"><code>revision</code></em> case) or trivially
        calculable from
        <sup>[<a id="idp15949904" href="#ftn.idp15949904" class="footnote">55</a>]</sup>
        (in the <em class="structfield"><code>url</code></em> case) the data stored
        in the <span class="quote">«<span class="quote">this directory</span>»</span> entry.  Note also that
        for subdirectory entries, Subversion stores only the crucial
        attributes—name, kind, url, revision, and schedule.  In
        an effort to reduce duplicated information, Subversion
        dictates that the method for determining the full set of
        information about a subdirectory is to traverse down into that
        subdirectory, and read the <span class="quote">«<span class="quote">this directory</span>»</span> entry
        from its own <code class="filename">.svn/entries</code> file.  However,
        a reference to the subdirectory is kept in its parent's
        <code class="filename">entries</code> file, with enough information to
        permit basic versioning operations in the event that the
        subdirectory itself is actually missing from disk.</p></div><div class="sect2" title="Pristine Copies and Property Files"><div class="titlepage"><div><div><h3 class="title"><a id="svn.developer.insidewc.base-and-props"></a>Pristine Copies and Property Files</h3></div></div></div><p>As mentioned before, the <code class="filename">.svn</code>
        directory also holds the pristine <span class="quote">«<span class="quote">text-base</span>»</span>
        versions of files.  Those can be found in
        <code class="filename">.svn/text-base</code>.  The benefits of these
        pristine copies are multiple—network-free checks for
        local modifications and difference reporting, network-free
        reversion of modified or missing files, smaller transmission
        of changes to the server—but comes at the cost of having
        each versioned file stored at least twice on disk.  These
        days, this seems to be a negligible penalty for most files.
        However, the situation gets uglier as the size of your
        versioned files grows.  Some attention is being given to
        making the presence of the <span class="quote">«<span class="quote">text-base</span>»</span> an option.
        Ironically though, it is as your versioned files' sizes get
        larger that the existence of the <span class="quote">«<span class="quote">text-base</span>»</span>
        becomes more crucial—who wants to transmit a huge file
        across a network just because they want to commit a tiny
        change to it?</p><p>Similar in purpose to the <span class="quote">«<span class="quote">text-base</span>»</span> files
        are the property files and their pristine
        <span class="quote">«<span class="quote">prop-base</span>»</span> copies, located in
        <code class="filename">.svn/props</code> and
        <code class="filename">.svn/prop-base</code> respectively.  Since
        directories can have properties, too, there are also
        <code class="filename">.svn/dir-props</code> and
        <code class="filename">.svn/dir-prop-base</code> files.  Each of these
        property files (<span class="quote">«<span class="quote">working</span>»</span> and <span class="quote">«<span class="quote">base</span>»</span>
        versions) uses a simple <span class="quote">«<span class="quote">hash-on-disk</span>»</span> file
        format for storing the property names and values.</p></div></div><div class="sect1" title="WebDAV"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.developer.webdav"></a>WebDAV</h2></div></div></div><p>WebDAV (shorthand for <span class="quote">«<span class="quote">Web-based Distributed Authoring
      and Versioning</span>»</span>) is an extension of the standard HTTP
      protocol designed to make the web into a read/write medium,
      instead of the basically read-only medium that exists today.
      The theory is that directories and files can be shared—as
      both readable and writable objects—over the web.  RFCs
      2518 and 3253 describe the WebDAV/DeltaV extensions to HTTP, and
      are available (along with a lot of other useful information) at
      <a class="ulink" href="http://www.webdav.org/" target="_top">http://www.webdav.org/</a>.</p><p>A number of operating system file browsers are already able
      to mount networked directories using WebDAV.  On Win32, the
      Windows Explorer can browse what it calls Web Folders (which are
      just WebDAV-ready network locations) as if they were regular
      shared folders.  Mac OS X also has this capability, as do the
      Nautilus and Konqueror browsers (under GNOME and KDE,
      respectively).</p><p>How does all of this apply to Subversion?  The mod_dav_svn
      Apache module uses HTTP, extended by WebDAV and DeltaV, as one
      of its network protocols.  Subversion uses mod_dav_svn to map
      between Subversion's versioning concepts and those of RFCs 2518
      and 3253.
    </p><p>For a more thorough discussion of WebDAV, how it works, and
      how Subversion uses it, see <a class="xref" href="#svn.webdav" title="Приложение C. WebDAV и автоматическое управление версиями">Приложение&nbsp;C, <em>WebDAV и автоматическое управление версиями</em></a>.  Among
      other things, that appendix discusses the degree to which
      Subversion adheres to the generic WebDAV specification, and how
      that affects interoperability with generic WebDAV
      clients.</p></div><div class="footnotes"><br><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.idp15777072" href="#idp15777072" class="para">52</a>] </sup>We understand that this may come as a shock to sci-fi
            fans who have long been under the impression that Time was
            actually the <span class="emphasis"><em>fourth</em></span> dimension, and we
            apologize for any emotional trauma induced by our
            assertion of a different theory.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp15878320" href="#idp15878320" class="para">53</a>] </sup>Subversion uses ANSI system calls and datatypes as much
            as possible.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp15880192" href="#idp15880192" class="para">54</a>] </sup>Neon and Berkeley DB are examples of such libraries.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp15949904" href="#idp15949904" class="para">55</a>] </sup>That is, the URL for the entry is the same as the
            concatenation of the parent directory's URL and the
            entry's name.</p></div></div></div><div class="chapter" title="Глава 9. Полное справочное руководство по Subversion"><div class="titlepage"><div><div><h2 class="title"><a id="svn.ref"></a>Глава 9. Полное справочное руководство по Subversion</h2></div></div></div><div class="toc"><p><strong>Содержание</strong></p><dl><dt><span class="sect1"><a href="#svn.ref.svn">Клиент командной строки Subversion:
      <span class="command"><strong>svn</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svn.sw">Параметры командной строки<span class="command"><strong>svn</strong></span></a></span></dt><dt><span class="sect2"><a href="#svn.ref.svn.c">Подкоманды <span class="command"><strong>svn</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.add">svn add</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.blame">svn blame</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.cat">svn cat</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.checkout">svn checkout</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.cleanup">svn cleanup</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.commit">svn commit</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.copy">svn copy</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.delete">svn delete</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.diff">svn diff</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.export">svn export</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.help">svn help</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.import">svn import</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.info">svn info</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.list">svn list</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.lock">svn lock</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.log">svn log</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.merge">svn merge</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.mkdir">svn mkdir</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.move">svn move</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propdel">svn propdel</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propedit">svn propedit</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propget">svn propget</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.proplist">svn proplist</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.propset">svn propset</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.resolved">svn resolved</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.revert">svn revert</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.status">svn status</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.switch">svn switch</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.unlock">svn unlock</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svn.c.update">svn update</a></span><span class="refpurpose"></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnadmin"><span class="command"><strong>svnadmin</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svnadmin.sw"><span class="command"><strong>svnadmin</strong></span> Switches</a></span></dt><dt><span class="sect2"><a href="#svn.ref.svnadmin.c"><span class="command"><strong>svnadmin</strong></span> Subcommands</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.create">svnadmin create</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.deltify">svnadmin deltify</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.dump">svnadmin dump</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.help">svnadmin help</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.hotcopy">svnadmin hotcopy</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.list-dblogs">svnadmin list-dblogs</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.list-unused-dblogs">svnadmin list-unused-dblogs</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.load">svnadmin load</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.lslocks">svnadmin lslocks</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.lstxns">svnadmin lstxns</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.recover">svnadmin recover</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.rmlocks">svnadmin rmlocks</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.rmtxns">svnadmin rmtxns</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.setlog">svnadmin setlog</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnadmin.c.verify">svnadmin verify</a></span><span class="refpurpose"></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnlook"><span class="command"><strong>svnlook</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svnlook.sw"><span class="command"><strong>svnlook</strong></span> Switches</a></span></dt><dt><span class="sect2"><a href="#svn.ref.svnlook.c"><span class="command"><strong>svnlook</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.author">svnlook author</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.cat">svnlook cat</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.changed">svnlook changed</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.date">svnlook date</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.diff">svnlook diff</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.dirs-changed">svnlook dirs-changed</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.help">svnlook help</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.history">svnlook history</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.info">svnlook info</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.lock">svnlook lock</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.log">svnlook log</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.propget">svnlook propget</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.proplist">svnlook proplist</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.tree">svnlook tree</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.uuid">svnlook uuid</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="#svn.ref.svnlook.c.youngest">svnlook youngest</a></span><span class="refpurpose"></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnserve"><span class="command"><strong>svnserve</strong></span></a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.ref.svnserve.sw"><span class="command"><strong>svnserve</strong></span> Switches</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.ref.svnversion"><span class="command"><strong>svnversion</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnversion.re">svnversion</a></span><span class="refpurpose"></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.ref.mod_dav_svn"><span class="command"><strong>mod_dav_svn</strong></span></a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.mod_dav_svn.conf"><code class="literal">mod_dav_svn</code> Configuration
        Directives</a></span><span class="refpurpose"></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.ref.properties">Свойства Subversion</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#svn.ref.svnprops">Свойства Subversion</a></span><span class="refpurpose"></span></dt></dl></dd></dl></div><p>Эта глава является исчерпывающим справочным руководством
    по использованию Subversion. Она описывает работу программы-клиента
    командной строки (<span class="command"><strong>svn</strong></span>) и всех его подкоманд,
    а так же программы администрирования хранилища
    (<span class="command"><strong>svnadmin</strong></span> и <span class="command"><strong>svnlook</strong></span>) и
    соответствующие им подкоманды.</p><div class="sect1" title="Клиент командной строки Subversion: svn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.ref.svn"></a>Клиент командной строки Subversion:
      <span class="command"><strong>svn</strong></span></h2></div></div></div><p>Для того что бы воспользоваться клиентом командной строки, введите
      <span class="command"><strong>svn</strong></span>, и желаемую подкоманду
      <sup>[<a id="idp16237920" href="#ftn.idp16237920" class="footnote">56</a>]</sup>, а так же любые другие
      параметры командной строки, которые хотите задействовать. Порядок, в
      котором подкоманды и параметры командной строки должны быть
      использованы, не играет существенной роли. Например, всё нижеприведённое
      есть правильное использование <span class="command"><strong>svn status</strong></span>:
    </p><pre class="screen">$ svn -v status
$ svn status -v
$ svn status -v myfile
</pre><p>Множество примеров использования большинства клиентских команд
      может быть найдено в главе <a class="xref" href="#svn.tour" title="Глава 2. Экскурсия по Subversion">Глава&nbsp;2, <em>Экскурсия по Subversion</em></a>. Команды
      для управления свойствами описаны в главе
      <a class="xref" href="#svn.advanced.props" title="Свойства">«Свойства»</a>.</p><div class="sect2" title="Параметры командной строкиsvn"><div class="titlepage"><div><div><h3 class="title"><a id="svn.ref.svn.sw"></a>Параметры командной строки<span class="command"><strong>svn</strong></span></h3></div></div></div><p>Хотя Subversion имеет множество параметров командной строки для
        своих подкоманд, в каждый из них вкладывается один и тот же смысл в
        независимости от подкоманды с которой он используется.
        Например, <code class="option">--verbose</code> (<code class="option">-v</code>) всегда
        означает <span class="quote">«<span class="quote">детальный вывод</span>»</span>, в независимости от того, с
        какой подкомандой вы его используете.
      </p><div class="variablelist"><dl><dt><span class="term"><code class="option">--auto-props</code></span></dt><dd><p>Включает auto-props, переопределяя значение директивы
              <code class="literal">enable-auto-props</code> из файла
              <code class="filename">config</code>.</p></dd><dt><span class="term"><code class="option">--config-dir</code>
            <em class="replaceable"><code>DIR</code></em></span></dt><dd><p>Заставляет Subversion использовать настройки
              из указанного каталога вместо используемого по умолчанию
              (<code class="filename">.subversion</code> в
              домашнем каталоге пользователя).</p></dd><dt><span class="term"><code class="option">--diff-cmd</code>
            <em class="replaceable"><code>CMD</code></em></span></dt><dd><p>Позволяет указать внешнюю программу построения различий
              между файлами. По умолчанию, подкоманда <span class="command"><strong>svn
              diff</strong></span> использует внутренний механизм сравнения
              Subversion, выдающий результат в едином формате записи
              различий (unified diffs). Воспользоваться внешней
              программой diff можно указав ее имя в качестве
              аргумента <code class="option">--diff-cmd</code>. Необходимые аргументы
              могут быть переданы программе diff
              через параметр <code class="option">--extensions</code>
              (будет описан ниже в этой главе).
            </p></dd><dt><span class="term"><code class="option">--diff3-cmd</code>
            <em class="replaceable"><code>CMD</code></em></span></dt><dd><p>Позволяет указать внешнюю программу для слияния файлов.
            </p></dd><dt><span class="term"><code class="option">--dry-run</code></span></dt><dd><p>Выполняет все действия команды без внесения изменений на
              диск или в хранилище.
            </p></dd><dt><span class="term"><code class="option">--editor-cmd</code>
            <em class="replaceable"><code>CMD</code></em></span></dt><dd><p>Определяет внешнюю программу для редактирования
            комментария или свойства. Подробнее о том, как указать
            используемый по умолчанию редактор, смотрите раздел, посвященный
            <code class="literal">editor-cmd</code> в
            <a class="xref" href="#svn.advanced.confarea.opts.config" title="Config">«Config»</a>.</p></dd><dt><span class="term"><code class="option">--encoding</code> <em class="replaceable"><code>ENC</code></em></span></dt><dd><p>Указывает Subversion кодировку комментариев. По умолчанию
              используется кодировка, установленная вашей операционной
              системе. Если ваш комментарий в другой кодировке - укажите ее
              явно.
            </p></dd><dt><span class="term"><code class="option">--extensions</code> (<code class="option">-x</code>)
          <em class="replaceable"><code>ARGS</code></em></span></dt><dd><p>Определяет параметр который Subversion должна передать
              внешней программе diff, когда выясняется различие между
              файлами. Для передачи нескольких параметров, их нужно заключить
              их в кавычки (например,
              <span class="command"><strong>svn diff --diff-cmd /usr/bin/diff -x
              "-b -E"</strong></span>). Этот параметр командной строки может
              использоваться <span class="emphasis"><em>только</em></span> совместно с
              параметром <code class="option">--diff-cmd</code>.</p></dd><dt><span class="term"><code class="option">--file</code> (<code class="option">-F</code>)
            <em class="replaceable"><code>FILENAME</code></em>
          </span></dt><dd><p>Указывает что следует использовать содержимое указанного
              файла в качестве входных данных, запрашиваемых вызываемой
              подкомандой.
            </p></dd><dt><span class="term"><code class="option">--force</code></span></dt><dd><p>Принуждает выполнить некоторые команды или операции. Есть
              рад операций, которые Subversion откажется выполнить в
              определенных условиях. Задавая этот параметр вы явно говорите
              Subversion <span class="quote">«<span class="quote">Я осознаю все возможные последствия моих
              действий, так что <span class="emphasis"><em>делай что тебе велят</em></span>
              </span>»</span>. Этот параметр эквивалентен выполнению электромонтажных
              работ "под напряжением"—не зная что делаешь, рискуешь
              "попасть под фазу".
            </p></dd><dt><span class="term"><code class="option">--force-log</code></span></dt><dd><p>Принуждает параметры <code class="option">--message</code>
              (<code class="option">-m</code>) или <code class="option">--file</code>
              (<code class="option">-F</code>) использовать следующий аргумент,
              каким бы подозрительным он не был. По умолчанию, Subversion
              будет выдавать ошибку, если значения этих параметров
              выглядят так, как если бы они были объектами, обрабатываемыми
              подкомандой. Например, когда в качестве значения параметра
              <code class="option">--file</code> (<code class="option">-F</code>) используется
              имя файла находящегося под контролем версий, Subversion
              предполагает что была допущена ошибка. Ей кажется, что вместо
              положенного в таком случае
              обычного файла, не находящегося под контролем версий, по ошибке был
              указан целевой файл вызываемой операции. Чтобы подтвердить
              свои намерения и обходить ошибки подобного рода,
              нужно явно указывать параметр <code class="option">--force-log</code> для
              подкоманд, предполагающих ввод сообщений истории изменений.
            </p></dd><dt><span class="term"><code class="option">--help</code> (<code class="option">-h</code> or
                <code class="option">-?</code>)
          </span></dt><dd><p>Если используется с одной или более подкоманд—выводит
              внутреннюю подсказку каждой подкоманды. Если без подкоманд, то
              отображает общую подсказку.</p></dd><dt><span class="term"><code class="option">--ignore-ancestry</code></span></dt><dd><p>Сообщает Subversion о необходимости игнорировать историю
              изменений при вычислении различий. То есть, полагаться только на
              текущее содержимое.
            </p></dd><dt><span class="term"><code class="option">--ignore-externals</code></span></dt><dd><p>Сообщает Subversion о необходимости игнорировать
              внешние определения и соответствующие рабочие копии.</p></dd><dt><span class="term"><code class="option">--incremental</code></span></dt><dd><p>Выводит результаты в удобном для конкатенации виде.</p></dd><dt><span class="term"><code class="option">--limit</code>
            <em class="replaceable"><code>NUM</code></em></span></dt><dd><p>Выводит только первые <em class="replaceable"><code>NUM</code></em>
              сообщений истории изменений.
            </p></dd><dt><span class="term"><code class="option">--message</code> (<code class="option">-m</code>)
            <em class="replaceable"><code>MESSAGE</code></em>
          </span></dt><dd><p>Указывает на то, что следующим параметром является пояснение
              фиксируемых изменений. Например:
            </p><pre class="screen">$ svn commit -m "They don't make Sunday."
</pre></dd><dt><span class="term"><code class="option">--new</code> <em class="replaceable"><code>ARG</code></em></span></dt><dd><p>Определяет <em class="replaceable"><code>ARG</code></em> как более новый
              целевой объект.</p></dd><dt><span class="term"><code class="option">--no-auth-cache</code></span></dt><dd><p>Препятствует хешированию идентификационной информации
              (например имя и пароль) в административном каталоге Subversion.
            </p></dd><dt><span class="term"><code class="option">--no-auto-props</code></span></dt><dd><p>Отключает auto-props, переопределяя параметр
              <code class="literal">enable-auto-props</code> из файла
              <code class="filename">config</code>.
            </p></dd><dt><span class="term"><code class="option">--no-diff-added</code></span></dt><dd><p>Препятствует отображению Subversion различий для добавленных
            под контроль версий файлов. По умолчанию, для добавленного файла
            <span class="command"><strong>svn diff</strong></span> выводит различия так, как если бы
            вы добавили содержимое для уже существующего, но пустого
            файла.</p></dd><dt><span class="term"><code class="option">--no-diff-deleted</code></span></dt><dd><p>Препятствует отображению Subversion различий для удаленных
              из под контроля версий файлов. По умолчанию, для удаленного
              файла
              <span class="command"><strong>svn diff</strong></span> выводит различия так, как если файл
              существует, но с пустым содержимым.
            </p></dd><dt><span class="term"><code class="option">--no-ignore</code></span></dt><dd><p>Показывает все файлы в списке состояния файлов, которые были
              бы пропущены как подпадающие под шаблон настройки конфигурации
              <code class="literal">global-ignores</code> или свойства
              <code class="literal">svn:ignore</code>. Смотри
              <a class="xref" href="#svn.advanced.confarea.opts.config" title="Config">«Config»</a> и
              <a class="xref" href="#svn.advanced.props.special.ignore" title="Пропуск неверсионированных элементов">«Пропуск неверсионированных элементов»</a> для
              дополнительной информации.
            </p></dd><dt><span class="term"><code class="option">--no-unlock</code></span></dt><dd><p>Не снимает блокировку с файлов автоматически. По умолчанию
              блокировка снимается для всех фалов, участвующих в фиксации
              изменений. Смотри <a class="xref" href="#svn.advanced.locking" title="Locking">«Locking»</a> для
              для дополнительной информации.</p></dd><dt><span class="term"><code class="option">--non-interactive</code></span></dt><dd><p>В случае ошибки идентификации или неполноты параметров
              идентификации, препятствует их запрашиванию (например, запросу
              имени или пароля). Это полезно при вызове Subversion из
              автоматизированных скриптов, в этом случае ошибка выполнения
              скрипта лучше, чем его останов интерактивными запросами
              Subversion о дополнительной информации.
            </p></dd><dt><span class="term"><code class="option">--non-recursive</code> (<code class="option">-N</code>)</span></dt><dd><p>Запрещает рекурсивное выполнение подкоманды для вложенных
              каталогов. Большинство подкоманд выполняются рекурсивно по
              умолчанию, но некоторые—обычно те, что могут удалять или
              отменять ваши локальные изменения—таковыми не являются.
            </p></dd><dt><span class="term"><code class="option">--notice-ancestry</code></span></dt><dd><p>Предлагает учитывать историю изменений при вычислении
              различий.
            </p></dd><dt><span class="term"><code class="option">--old</code> <em class="replaceable"><code>ARG</code></em></span></dt><dd><p>Определяет <em class="replaceable"><code>ARG</code></em> как более поздний
              целевой объект.</p></dd><dt><span class="term"><code class="option">--password</code>
            <em class="replaceable"><code>PASS</code></em></span></dt><dd><p>Указывает на ваше желание явно задать пароль для
              аутентификации—как бы то ни было, если пароль
              потребуется, Subversion его у вас спросит.</p></dd><dt><span class="term"><code class="option">--quiet</code> (<code class="option">-q</code>)</span></dt><dd><p>Требует сообщать только существенную информацию.</p></dd><dt><span class="term"><code class="option">--recursive</code> (<code class="option">-R</code>)</span></dt><dd><p>Выполняет подкоманды рекурсивно для всех вложенных каталогов.
              Большинство подкоманд выполняются рекурсивно по умолчанию.
            </p></dd><dt><span class="term"><code class="option">--relocate</code> <em class="replaceable"><code>FROM TO
          [PATH...]</code></em></span></dt><dd><p>Используется совместно с подкомандой
              <span class="command"><strong>svn switch</strong></span>, предписывая вашей рабочей копии
              ссылаться на другое хранилище. Это полезно при изменении адреса
              вашего хранилища, когда вы уже имеете существующую рабочую
              копию, которую бы желали продолжать использовать. Обратитесь к
              руководству <span class="command"><strong>svn switch</strong></span> для получения примера
              использования.
            </p></dd><dt><span class="term"><code class="option">--revision</code> (<code class="option">-r</code>)
            <em class="replaceable"><code>REV</code></em>
          </span></dt><dd><p>Отражает ваше намерение выполнить операцию для указанной
              <a class="link" href="#revision" title="revision">версии</a> (или диапазона
              <a class="link" href="#revision" title="revision">версий</a>). В качестве значений
              параметра вы можете указывать номер версии, их ключевые
              слова или дату (в фигурных скобках). Если вы желаете указать
              диапазон <a class="link" href="#revision" title="revision">версий</a>, вы должны
              использовать двоеточие в качестве разделителя. Например:
            </p><pre class="screen">$ svn log -r 1729
$ svn log -r 1729:HEAD
$ svn log -r 1729:1744
$ svn log -r {2001-12-04}:{2002-02-17}
$ svn log -r 1729:{2002-02-17}
</pre><p>Используйте <a class="xref" href="#svn.tour.revs.keywords" title="Ключевые слова правок">«Ключевые слова правок»</a> для
              дополнительной информации.</p></dd><dt><span class="term"><code class="option">--revprop</code></span></dt><dd><p>Оперирует со свойствами
              <a class="link" href="#revision" title="revision">правки</a>, a не свойствами файла
              или каталога. Этот параметр требует указания
              <a class="link" href="#revision" title="revision">версии</a>
              посредством <code class="option">--revision</code> (<code class="option">-r</code>).
              Обратитесь к <a class="xref" href="#svn.reposadmin.basics.revprops" title="Unversioned Properties">«Unversioned Properties»</a>
              для более глубокого понимания неверсионных свойств.
            </p></dd><dt><span class="term"><code class="option">--show-updates</code> (<code class="option">-u</code>)</span></dt><dd><p>Принуждает программу-клиента вывести информацию о
              нуждающихся в обновлении файлах вашей рабочей копии. При
              этом самого обновления не происходит—вы только видите
              список файлов, которые будут обновлены если вы запустите
              <span class="command"><strong>svn update</strong></span>.
            </p></dd><dt><span class="term"><code class="option">--stop-on-copy</code></span></dt><dd><p>Говорит Subversion прекратить обработку истории изменений
              объекта, хранимого под контролем версий, как только встретится
              упоминание в истории о том что объект был скопирован из другого
              места в хранилище.
            </p></dd><dt><span class="term"><code class="option">--strict</code></span></dt><dd><p>Требует от Subversion использовать строгую семантику.
              Описать изменение поведения подкоманды довольно трудно
              без учета специфики самой подкоманды.</p></dd><dt><span class="term"><code class="option">--targets</code>
            <em class="replaceable"><code>FILENAME</code></em></span></dt><dd><p>Используя этот параметр вы можете указать Subversion на
              файл, содержащий список файлов, которыми вы хотите оперировать,
              вместо того чтобы перечислять их в командной строке.
            </p></dd><dt><span class="term"><code class="option">--username</code>
            <em class="replaceable"><code>NAME</code></em></span></dt><dd><p>Указывает на имя пользователя для аутентификации. Как бы то
              ни было, если имя пользователя потребуется, Subversion его у вас
              спросит.
            </p></dd><dt><span class="term"><code class="option">--verbose</code> (<code class="option">-v</code>)</span></dt><dd><p>Выражает просьбу комментировать процесс выполнения
              операции как можно более детально. Это может привести к
              выводу дополнительных полей, подробной информации по
              каждому файлу или более полной информации о выполняемой
              операции.</p></dd><dt><span class="term"><code class="option">--version</code></span></dt><dd><p>Выводит информацию о версии программы-клиента. В дополнение
              к номеру версии выводится список всех способов доступа к
              хранилищу, которыми может оперировать этот клиент. С
              параметром <code class="option">--quiet</code> (<code class="option">-q</code>) в
              компактной форме выводится только информация о версии клиента.
            </p></dd><dt><span class="term"><code class="option">--xml</code></span></dt><dd><p>Печатает вывод в XML-формате.</p></dd></dl></div></div><div class="sect2" title="Подкоманды svn"><div class="titlepage"><div><div><h3 class="title"><a id="svn.ref.svn.c"></a>Подкоманды <span class="command"><strong>svn</strong></span></h3></div></div></div><div class="refentry" title="svn add"><a id="svn.ref.svn.c.add"></a><div class="titlepage"></div><a id="idp16420992" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn add — Добавляет файлы, директории и символические
            связи.</p></div><div class="refsect1" title="Формат"><a id="idp16427152"></a><h2>Формат</h2><pre class="programlisting">svn add PATH...</pre></div><div class="refsect1" title="Описание"><a id="idp16428608"></a><h2>Описание</h2><p>Добавляет файлы, директории и символические связи в вашу
            рабочею копию, помечая их для последующего добавления в хранилище.
            При фиксации изменений они добавляются в хранилище . Если вы
            что-то добавили, но потом передумали фиксировать добавление
            изменений, то снять метку добавления можно подкомандой
            <span class="command"><strong>svn revert</strong></span>.
          </p></div><div class="refsect1" title="Альтернативные имена"><a id="idp16431600"></a><h2>Альтернативные имена</h2><p>None</p></div><div class="refsect1" title="Изменяет"><a id="idp16432832"></a><h2>Изменяет</h2><p>Рабочую копию</p></div><div class="refsect1" title="Требует доступа к хранилищу"><a id="idp16434064"></a><h2>Требует доступа к хранилищу</h2><p>Нет</p></div><div class="refsect1" title="Параметры"><a id="idp16435312"></a><h2>Параметры</h2><pre class="screen">--targets FILENAME
--non-recursive (-N)
--quiet (-q)
--config-dir DIR
--auto-props
--no-auto-props
--force
</pre></div><div class="refsect1" title="Пример"><a id="idp16436896"></a><h2>Пример</h2><p>Для добавления файла под контроль версий вашей рабочей
            копии:
          </p><pre class="screen">$ svn add foo.c
A         foo.c
</pre><p>Если добавляется каталог, то по умолчанию
            <span class="command"><strong>svn add</strong></span> действует рекурсивно:</p><pre class="screen">$ svn add testdir
A         testdir
A         testdir/a
A         testdir/b
A         testdir/c
A         testdir/d
</pre><p>Вы можете добавить каталог без добавления его
            содержимого:</p><pre class="screen">$ svn add --non-recursive otherdir
A         otherdir
</pre><p>Обычно команда <span class="command"><strong>svn add *</strong></span> игнорирует
            каталоги, уже находящиеся под контролем версий. Иногда бывает
            нужно добавить все неверсионные объекты из вашей рабочей копии,
            включая те, что находятся внутри каталогов. Указав
            параметр <code class="option">--force</code>, вы принудите
            <span class="command"><strong>svn add</strong></span> рекурсивно пройти по
            каталогам уже находящимся под контролем версий:
          </p><pre class="screen">$ svn add * --force
A         foo.c
A         somedir/bar.c
A         otherdir/docs/baz.doc
…
</pre></div></div><div class="refentry" title="svn blame"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.blame"></a><div class="titlepage"></div><a id="idp16447952" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn blame — Построчно показывает автора и <a class="link" href="#revision" title="revision">версию</a> для указанных файлов
            или URL-ов.</p></div><div class="refsect1" title="Формат"><a id="idp16452480"></a><h2>Формат</h2><pre class="programlisting">svn blame TARGET[@REV]...</pre></div><div class="refsect1" title="Описание"><a id="idp16454432"></a><h2>Описание</h2><p>Построчно показывает автора и <a class="link" href="#revision" title="revision">версию</a> для указанных файлов
            или URL-ов. Каждая строка текста начинается с имени
            автора (имени пользователя) и номера
            <a class="link" href="#revision" title="revision">правки</a>. Таким
            образом указывается кто и когда изменял эту строку
            последний раз.</p></div><div class="refsect1" title="Альтернативные имена"><a id="idp16459008"></a><h2>Альтернативные имена</h2><p>praise, annotate, ann</p></div><div class="refsect1" title="Изменяет"><a id="idp16460688"></a><h2>Изменяет</h2><p>Ничего не меняет</p></div><div class="refsect1" title="Требует доступа к хранилищу"><a id="idp16462432"></a><h2>Требует доступа к хранилищу</h2><p>Да</p></div><div class="refsect1" title="Параметры"><a id="idp16464080"></a><h2>Параметры</h2><pre class="screen">--revision (-r) REV
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
--verbose (-v)
</pre></div><div class="refsect1" title="Примеры"><a id="idp16465920"></a><h2>Примеры</h2><p>Если вы хотите просмотреть аннотацию для файла
            <code class="filename">readme.txt</code> в тестовом хранилище:</p><pre class="screen">$ svn blame http://svn.red-bean.com/repos/test/readme.txt
     3      sally This is a README file.
     5      harry You should read this.
</pre></div></div><div class="refentry" title="svn cat"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.cat"></a><div class="titlepage"></div><a id="idp16470448" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn cat — Выводит содержимое указанных файлов или
            URL-ов.</p></div><div class="refsect1" title="Формат"><a id="idp16474000"></a><h2>Формат</h2><pre class="programlisting">svn cat TARGET[@REV]...</pre></div><div class="refsect1" title="Описание"><a id="idp16475856"></a><h2>Описание</h2><p>Выводит содержимое указанных файлов или URL-ов. Для
            перечисления содержимого каталогов используйте <span class="command"><strong>svn
            list</strong></span>.</p></div><div class="refsect1" title="Альтернативные имена"><a id="idp16478848"></a><h2>Альтернативные имена</h2><p>Нет</p></div><div class="refsect1" title="Изменяет"><a id="idp16480560"></a><h2>Изменяет</h2><p>Ничего не меняет</p></div><div class="refsect1" title="Требует доступа к хранилищу"><a id="idp16482192"></a><h2>Требует доступа к хранилищу</h2><p>Да</p></div><div class="refsect1" title="Параметры"><a id="idp16483840"></a><h2>Параметры</h2><pre class="screen">--revision (-r) REV
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" title="Примеры"><a id="idp16485680"></a><h2>Примеры</h2><p>Если вы хотите просмотреть содержимое readme.txt из хранилища
            не создавая его рабочей копии, выполните:</p><pre class="screen">$ svn cat http://svn.red-bean.com/repos/test/readme.txt
This is a README file.
You should read this.
</pre><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>Если ваша рабочая копия устарела (или вы что-то в ней
              локально изменили), но хотите посмотреть
              <code class="literal">HEAD</code> <a class="link" href="#revision" title="revision">версию</a> файла, имеющегося в вашей
              рабочей копии, подкоманда <span class="command"><strong>svn cat</strong></span>
              автоматически извлечет <code class="literal">HEAD</code>
              <a class="link" href="#revision" title="revision">версию</a>,
              ей нужно только указать путь к этому файлу:</p></td></tr></tbody></table></div><pre class="screen">$ cat foo.c
This file is in my local working copy
and has changes that I've made.

$ svn cat foo.c
Latest revision fresh from the repository!
</pre></div></div><div class="refentry" title="svn checkout"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.checkout"></a><div class="titlepage"></div><a id="idp16496288" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn checkout — Создает рабочую копию на основе данных из
            хранилища.</p></div><div class="refsect1" title="Формат"><a id="idp16499856"></a><h2>Формат</h2><pre class="programlisting">svn checkout URL[@REV]... [PATH]</pre></div><div class="refsect1" title="Описание"><a id="idp16501728"></a><h2>Описание</h2><p>Создает рабочую копию на основе данных из хранилища.
            Если <em class="replaceable"><code>PATH</code></em> пропущен, базовое имя
            URL будет использоваться в качестве имени для каталога рабочей
            копии. Если задано несколько URL, соответствующие копии будут
            создаваться в подкаталоге <em class="replaceable"><code>PATH</code></em>, каждая
            в своем каталоге образованном из базового имени URL.</p></div><div class="refsect1" title="Альтернативные имена"><a id="idp16505920"></a><h2>Альтернативные имена</h2><p>co</p></div><div class="refsect1" title="Изменяет"><a id="idp16507584"></a><h2>Изменяет</h2><p>Создает рабочую копию.</p></div><div class="refsect1" title="Требует доступа к хранилищу"><a id="idp16509248"></a><h2>Требует доступа к хранилищу</h2><p>Да</p></div><div class="refsect1" title="Параметры"><a id="idp16510896"></a><h2>Параметры</h2><pre class="screen">--revision (-r) REV
--quiet (-q)
--non-recursive (-N)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--ignore-externals
--config-dir DIR
</pre></div><div class="refsect1" title="Примеры"><a id="idp16512784"></a><h2>Примеры</h2><p>Создать рабочую копию в директории с именем
            <code class="filename">mine</code>:</p><pre class="screen">$ svn checkout file:///tmp/repos/test mine
A  mine/a
A  mine/b
Checked out revision 2.
$ ls
mine
</pre><p>Создать рабочие копии двух разных каталогов:</p><pre class="screen">$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz
A  test/a
A  test/b
Checked out revision 2.
A  quiz/l
A  quiz/m
Checked out revision 2.
$ ls
quiz  test
</pre><p>Создать рабочие копии двух разных каталогов в каталоге
            с именем <code class="filename">working-copies</code>:</p><pre class="screen">$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz working-copies
A  working-copies/test/a
A  working-copies/test/b
Checked out revision 2.
A  working-copies/quiz/l
A  working-copies/quiz/m
Checked out revision 2.
$ ls
working-copies
</pre><p>Если вы прервете создание копии (или что-то другое прервет,
            например, разрыв связи и т.п.), вы можете повторить процесс задав
            команду повторно или запросив обновить рабочую копию:
          </p><pre class="screen">$ svn checkout file:///tmp/repos/test test
A  test/a
A  test/b
^C
svn: The operation was interrupted
svn: caught SIGINT

$ svn checkout file:///tmp/repos/test test
A  test/c
A  test/d
^C
svn: The operation was interrupted
svn: caught SIGINT

$ cd test
$ svn update
A  test/e
A  test/f
Updated to revision 3.
</pre></div></div><div class="refentry" title="svn cleanup"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.cleanup"></a><div class="titlepage"></div><a id="idp16524400" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn cleanup — Рекурсивно чистит рабочую копию.</p></div><div class="refsect1" title="Формат"><a id="idp16527936"></a><h2>Формат</h2><pre class="programlisting">svn cleanup [PATH...]</pre></div><div class="refsect1" title="Описание"><a id="idp16529760"></a><h2>Описание</h2><p>Рекурсивно чистит рабочую копию, удаляя блокировки
            и выполняет незавершенные операции. Как только столкнетесь
            с ошибкой <span class="quote">«<span class="quote">рабочая копия заблокирована</span>»</span>, запустите
            эту подкоманду для удаления старых блокировок и приведения
            рабочей копии в работоспособное состояние.</p><p>Если по некоторым причинам команда
            <span class="command"><strong>svn update</strong></span> завершилась с ошибкой из-за проблем
            с запущенным внешней программой различий (например, из-за
            пользовательского ввода или сбоя в сети), нужно задать
            параметр <code class="option">--diff3-cmd</code> чтобы дать возможность при
            чистке копии завершить слияние используя внешнюю программу diff.
            Вы также можете указать конфигурационный каталог посредством
            параметра <code class="option">--config-dir</code>, но постарайтесь не
            злоупотреблять этими параметрами.</p></div><div class="refsect1" title="Альтернативные имена"><a id="idp16537920"></a><h2>Альтернативные имена</h2><p>Нет</p></div><div class="refsect1" title="Изменяет"><a id="idp16539616"></a><h2>Изменяет</h2><p>Рабочую копию.</p></div><div class="refsect1" title="Требует доступа к хранилищу"><a id="idp16541248"></a><h2>Требует доступа к хранилищу</h2><p>Нет</p></div><div class="refsect1" title="Параметры"><a id="idp16542896"></a><h2>Параметры</h2><pre class="screen">--diff3-cmd CMD
--config-dir DIR
</pre></div><div class="refsect1" title="Примеры"><a id="idp16544576"></a><h2>Примеры</h2><p>Не много примеров использования подкоманды <span class="command"><strong>svn
            cleanup</strong></span> можно привести, так как она работает молча. Если
            вы не указали <em class="replaceable"><code>PATH</code></em>, будет
            использовано <span class="quote">«<span class="quote"><code class="filename">.</code></span>»</span> .</p><pre class="screen">$ svn cleanup

$ svn cleanup /path/to/working-copy
</pre></div></div><div class="refentry" title="svn commit"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.commit"></a><div class="titlepage"></div><a id="idp16550720" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn commit — Фиксирует сделанные вами изменения рабочей копии в
            хранилище.</p></div><div class="refsect1" title="Формат"><a id="idp16554304"></a><h2>Формат</h2><pre class="programlisting">svn commit [PATH...]</pre></div><div class="refsect1" title="Описание"><a id="idp16556160"></a><h2>Описание</h2><p>Фиксирует сделанные вами изменения рабочей копии в
            хранилище. Если вы не 
            воспользовались ни <code class="option">--file</code>, ни
            <code class="option">--message</code> параметром, <span class="command"><strong>svn</strong></span>
            запустит внешний редактор для составления комментария. Обращайтесь
            за подробностями к описанию
            параметра <code class="literal">editor-cmd</code> в
            <a class="xref" href="#svn.advanced.confarea.opts.config" title="Config">«Config»</a>.</p><p><span class="command"><strong>svn commit</strong></span> отправит хранилищу все рекурсивно
            найденные метки блокировок и разблокирует соответствующие этим
            меткам ресурсы, если не был указан параметр
            <code class="option">--no-unlock</code>. Место поиска задается указанием
            <em class="replaceable"><code>PATH</code></em>.</p><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>Если вы начали фиксацию изменений и Subversion запустила ваш
              внешний редактор для составления комментария, вы все еще можете
              прервать операцию фиксации изменений. Если вы хотите отменить
              фиксации, просто выйдете из редактора без сохранения изменений.
              Subversion заинтересуется - хотите ли вы прервать операцию,
              продолжить без описания изменений или же редактировать описания
              изменений снова.
            </p></td></tr></tbody></table></div></div><div class="refsect1" title="Альтернативные имена"><a id="idp16568720"></a><h2>Альтернативные имена</h2><p>ci (сокращение от <span class="quote">«<span class="quote">check in</span>»</span>; a не
            <span class="quote">«<span class="quote">co</span>»</span>, что есть сокращение для
            <span class="quote">«<span class="quote">checkout</span>»</span>)</p></div><div class="refsect1" title="Изменяет"><a id="idp16571792"></a><h2>Изменяет</h2><p>Как рабочую копию, так и хранилище</p></div><div class="refsect1" title="Требует доступа к хранилищу"><a id="idp16573392"></a><h2>Требует доступа к хранилищу</h2><p>Да</p></div><div class="refsect1" title="Параметры"><a id="idp16575152"></a><h2>Параметры</h2><pre class="screen">--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--no-unlock
--non-recursive (-N)
--targets FILENAME
--force-log
--username USER
--password PASS
--no-auth-cache
--non-interactive
--encoding ENC
--config-dir DIR
</pre></div><div class="refsect1" title="Примеры"><a id="idp16577168"></a><h2>Примеры</h2><p>Зафиксировать изменения файлов в хранилище из текущего
            каталога (<span class="quote">«<span class="quote"><code class="filename">.</code></span>»</span>) и его
            подкаталогов, задав пояснение изменений в командной строке:
          </p><pre class="screen">$ svn commit -m "added howto section."
Sending        a
Transmitting file data .
Committed revision 3.
</pre><p>Зафиксировать изменения файла <code class="filename">foo.c</code>
            (явно заданного в командной строке)задав пояснение изменений
            содержимым файла <code class="literal">msg</code>:</p><pre class="screen">$ svn commit -F msg foo.c
Sending        foo.c
Transmitting file data .
Committed revision 5.
</pre><p>Если вы хотите использовать содержимое файла находящегося
            под контролем версий в качестве комментария
            (используя параметр <code class="option">--file</code>), вы должны задать
            параметр <code class="option">--force-log</code> для явного выражения своих
            намерений:</p><pre class="screen">$ svn commit --file file_under_vc.txt foo.c
svn: The log message file is under version control
svn: Log message file is a versioned file; use '--force-log' to override

$ svn commit --force-log --file file_under_vc.txt foo.c
Sending        foo.c
Transmitting file data .
Committed revision 6.
</pre><p>Зафиксировать факт удаления файла:</p><pre class="screen">$ svn commit -m "removed file 'c'."
Deleting       c

Committed revision 7.
</pre></div></div><div class="refentry" title="svn copy"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.copy"></a><div class="titlepage"></div><a id="idp16590864" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn copy — Копирует файл или каталог в рабочей копии или
            хранилище.</p></div><div class="refsect1" title="Формат"><a id="idp16594496"></a><h2>Формат</h2><pre class="programlisting">svn copy SRC DST</pre></div><div class="refsect1" title="Описание"><a id="idp16596400"></a><h2>Описание</h2><p>Копирует файл в рабочей копии или в хранилище.
            <em class="replaceable"><code>SRC</code></em> и
            <em class="replaceable"><code>DST</code></em> могут быть путями как внутри
            рабочей копии, так и URL внутри хранилища:</p><div class="variablelist"><dl><dt><span class="term">WC  -&gt; WC</span></dt><dd><p>Планирует копирование объекта
                    (вместе с историей).</p></dd><dt><span class="term">WC  -&gt; URL</span></dt><dd><p>Создает копию объекта из рабочей копии
                    непосредственно в хранилище.</p></dd><dt><span class="term">URL -&gt; WC</span></dt><dd><p>Выгружает копию объекта из хранилища в рабочую копию
                    и планирует ее добавление.</p></dd><dt><span class="term">URL -&gt; URL</span></dt><dd><p>Выполняет копирование объектов непосредственно в
                    хранилище. Обычно используется для создания ветки.
                  </p></dd></dl></div><div class="note" title="Примечание" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Примечание]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/note.png"></td><th align="left">Примечание</th></tr><tr><td valign="top" align="left"><p>Вы можете копировать файлы только внутри одного хранилища.
              Subversion не поддерживает межхранилищного копирования.</p></td></tr></tbody></table></div></div><div class="refsect1" title="Альтернативные имена"><a id="idp16610624"></a><h2>Альтернативные имена</h2><p>cp</p></div><div class="refsect1" title="Изменяет"><a id="idp16612080"></a><h2>Изменяет</h2><p>Хранилище, если копия задается через URL</p><p>Рабочая копия, если копия создается внутри неё.</p></div><div class="refsect1" title="Требует доступа к хранилищу"><a id="idp16614288"></a><h2>Требует доступа к хранилищу</h2><p>Да, если копируемый объект или место назначения расположены в
            хранилище, а так же если необходимо найти номер
            <a class="link" href="#revision" title="revision">правки</a>.
          </p></div><div class="refsect1" title="Параметры"><a id="idp16616944"></a><h2>Параметры</h2><pre class="screen">--message (-m) TEXT
--file (-F) FILE
--revision (-r) REV
--quiet (-q)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--force-log
--editor-cmd EDITOR
--encoding ENC
--config-dir DIR
</pre></div><div class="refsect1" title="Примеры"><a id="idp16619072"></a><h2>Примеры</h2><p>Создание копии объекта внутри рабочей копии (физическое
            копирование происходит после выполнения команды фиксации
            изменений):
          </p><pre class="screen">$ svn copy foo.txt bar.txt
A         bar.txt
$ svn status
A  +   bar.txt
</pre><p>Создание копии объекта из рабочей копии в хранилище по
            заданному URL (изменения в хранилище вносятся незамедлительно, так
            что требуется задать пояснения изменений):
          </p><pre class="screen">$ svn copy near.txt file:///tmp/repos/test/far-away.txt -m "Remote copy."

Committed revision 8.
</pre><p>Создание копии объекта из хранилища в рабочую копию
            (полученная копия планируется на добавление и в хранилище появится
            только после команды фиксации изменений:
          </p><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>Это рекомендованный способ воскрешать случайно удаленные
              из хранилища файлы!</p></td></tr></tbody></table></div><pre class="screen">$ svn copy file:///tmp/repos/test/far-away near-here
A         near-here
</pre><p>И наконец, копирование внутри хранилища:</p><pre class="screen">$ svn copy file:///tmp/repos/test/far-away file:///tmp/repos/test/over-there -m "remote copy."

Committed revision 9.
</pre><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>Это простейший способ <span class="quote">«<span class="quote">установить метку</span>»</span> на
              версию в хранилище—просто выполните <span class="command"><strong>svn
              copy</strong></span> желаемой <a class="link" href="#revision" title="revision">версии</a>
              (хотя обычно это <code class="literal">HEAD</code>) в желаемый каталог.
            </p></td></tr></tbody></table></div><pre class="screen">$ svn copy file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0.6.32-prerelease -m "tag tree"

Committed revision 12.
</pre><p>Да, и не волнуйтесь, если забыли вовремя пометить
            <a class="link" href="#revision" title="revision">версию</a>—вы всегда можете
            сделать это сославшись на старую версию:</p><pre class="screen">$ svn copy -r 11 file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0.6.32-prerelease -m "Forgot to tag at rev 11"

Committed revision 13.
</pre></div></div><div class="refentry" title="svn delete"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.delete"></a><div class="titlepage"></div><a id="idp16638832" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn delete — Удаляет объект из рабочей копии
            или хранилища.</p></div><div class="refsect1" title="Формат"><a id="idp16642416"></a><h2>Формат</h2><pre class="programlisting">svn delete PATH...</pre><pre class="programlisting">svn delete URL...</pre></div><div class="refsect1" title="Описание"><a id="idp16644880"></a><h2>Описание</h2><p>Объекты определенные через <em class="replaceable"><code>PATH</code></em>
            вносятся в план удаления следующей фиксацией изменений.
            При этом файлы под контролем версий удаляются из рабочей копии
            немедленно. Команда не удаляет версионированные или модифицированные
            объекты. Если вы этого необходимо—используйте параметр
            <code class="option">--force</code>.</p><p>Объекты определенные через <em class="replaceable"><code>URL</code></em>
            сразу же фиксируются как удаленные. При использовании в
            команде нескольких URL - удаление фиксируется атомарно.</p></div><div class="refsect1" title="Альтернативные имена"><a id="idp16650544"></a><h2>Альтернативные имена</h2><p>del, remove, rm</p></div><div class="refsect1" title="Изменяет"><a id="idp16652752"></a><h2>Изменяет</h2><p>Рабочую копию в случае работы с файлами и хранилище при
            использовании URL</p></div><div class="refsect1" title="Требует доступа к хранилищу"><a id="idp16654544"></a><h2>Требует доступа к хранилищу</h2><p>Только в случае работы с URL</p></div><div class="refsect1" title="Параметры"><a id="idp16655824"></a><h2>Параметры</h2><pre class="screen">--force
--force-log
--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--targets FILENAME
--username USER
--password PASS
--no-auth-cache
--non-interactive
--editor-cmd EDITOR
--encoding ENC
--config-dir DIR
</pre></div><div class="refsect1" title="Примеры"><a id="idp16657696"></a><h2>Примеры</h2><p>Использование <span class="command"><strong>svn</strong></span> для удаления файла
            из вашей рабочей копии на самом деле только планирует
            его на удаление. Только фиксируя изменения вы удаляете
            файл из хранилища.</p><pre class="screen">$ svn delete myfile
D         myfile

$ svn commit -m "Deleted file 'myfile'."
Deleting       myfile
Transmitting file data .
Committed revision 14.
</pre><p>Так как удаление по URL отражается в хранилище сразу,
            вам необходимо задать комментарий:</p><pre class="screen">$ svn delete -m "Deleting file 'yourfile'" file:///tmp/repos/test/yourfile

Committed revision 15.
</pre><p>Это пример принудительного удаления версионированного
            файла который был локально изменен:</p><pre class="screen">$ svn delete over-there
svn: Attempting restricted operation for modified resource
svn: Use --force to override this restriction
svn: 'over-there' has local modifications

$ svn delete --force over-there
D         over-there
</pre></div></div><div class="refentry" title="svn diff"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.diff"></a><div class="titlepage"></div><a id="idp16666480" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn diff — Display the differences between two paths.</p></div><div class="refsect1" title="Synopsis"><a id="idp16669568"></a><h2>Synopsis</h2><pre class="programlisting">diff [-r N[:M]] [TARGET[@REV]...]</pre><pre class="programlisting">diff [-r N[:M]] --old OLD-TGT[@OLDREV] [--new NEW-TGT[@NEWREV]] [PATH...]</pre><pre class="programlisting">diff OLD-URL[@OLDREV] NEW-URL[@NEWREV]</pre></div><div class="refsect1" title="Description"><a id="idp16672528"></a><h2>Description</h2><p>Display the differences between two paths.  The three
            different ways you can use <span class="command"><strong>svn diff</strong></span>
            are:</p><p><span class="command"><strong>svn diff [-r N[:M]] [--old OLD-TGT] [--new
            NEW-TGT] [PATH...]</strong></span> displays the differences
            between <em class="replaceable"><code>OLD-TGT</code></em> and
            <em class="replaceable"><code>NEW-TGT</code></em>.  If
            <em class="replaceable"><code>PATH</code></em>s are given, they are
            treated as relative to <em class="replaceable"><code>OLD-TGT</code></em>
            and <em class="replaceable"><code>NEW-TGT</code></em> and the output is
            restricted to differences in only those paths.
            <em class="replaceable"><code>OLD-TGT</code></em> and
            <em class="replaceable"><code>NEW-TGT</code></em> may be working copy
            paths or
            <em class="replaceable"><code>URL</code></em><code class="literal">[@</code><em class="replaceable"><code>REV</code></em><code class="literal">]</code>.
            <em class="replaceable"><code>OLD-TGT</code></em> defaults to the current
            working directory and <em class="replaceable"><code>NEW-TGT</code></em>
            defaults to <em class="replaceable"><code>OLD-TGT</code></em>.
            <em class="replaceable"><code>N</code></em> defaults to
            <code class="literal">BASE</code> or, if
            <em class="replaceable"><code>OLD-TGT</code></em> is a URL, to
            <code class="literal">HEAD</code>.  <em class="replaceable"><code>M</code></em>
            defaults to the current working version or, if
            <em class="replaceable"><code>NEW-TGT</code></em> is a URL, to
            <code class="literal">HEAD</code>.  <span class="command"><strong>svn diff -r N</strong></span>
            sets the revision of <em class="replaceable"><code>OLD-TGT</code></em> to
            <em class="replaceable"><code>N</code></em>, <span class="command"><strong>svn diff -r
            N:M</strong></span> also sets the revision of
            <em class="replaceable"><code>NEW-TGT</code></em> to
            <em class="replaceable"><code>M</code></em>.</p><p><span class="command"><strong>svn diff -r N:M URL</strong></span> is shorthand
            for <span class="command"><strong>svn diff -r N:M --old=URL
            --new=URL</strong></span>.</p><p><span class="command"><strong>svn diff [-r N[:M]] URL1[@N]
            URL2[@M]</strong></span> is shorthand for <span class="command"><strong>svn diff [-r
            N[:M]] --old=URL1 --new=URL2</strong></span>.</p><p>If <em class="replaceable"><code>TARGET</code></em> is a URL, then
            revs N and M can be given either via the
            <code class="option">--revision</code> or by using
            <span class="quote">«<span class="quote">@</span>»</span> notation as described earlier.</p><p>If <em class="replaceable"><code>TARGET</code></em> is a working copy
            path, then the <code class="option">--revision</code> switch
            means:</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--revision N:M</code></span></dt><dd><p>The server compares
                  <em class="replaceable"><code>TARGET</code></em>@<em class="replaceable"><code>N</code></em>
                  and
                  <em class="replaceable"><code>TARGET</code></em>@<em class="replaceable"><code>M</code></em>.</p></dd><dt><span class="term"><code class="option">--revision N</code></span></dt><dd><p>The client compares
                  <em class="replaceable"><code>TARGET</code></em>@<em class="replaceable"><code>N</code></em>
                  against working copy.</p></dd><dt><span class="term">(no <code class="option">--revision</code>)</span></dt><dd><p>The client compares base and working copies of
                  <em class="replaceable"><code>TARGET</code></em>.</p></dd></dl></div><p>If the alternate syntax is used, the server compares
            <em class="replaceable"><code>URL1</code></em> and
            <em class="replaceable"><code>URL2</code></em> at revisions
            <em class="replaceable"><code>N</code></em> and
            <em class="replaceable"><code>M</code></em> respectively.  If either
            <em class="replaceable"><code>N</code></em> or
            <em class="replaceable"><code>M</code></em> are omitted, a value of
            <code class="literal">HEAD</code> is assumed.</p><p>By default, <span class="command"><strong>svn diff</strong></span> ignores the
            ancestry of files and merely compares the contents of the
            two files being compared.  If you use
            <code class="option">--notice-ancestry</code>, the ancestry of the
            paths in question will be taken into consideration when
            comparing revisions (that is, if you run <span class="command"><strong>svn
            diff</strong></span> on two files with identical contents but
            different ancestry you will see the entire contents of the
            file as having been removed and added again).</p></div><div class="refsect1" title="Alternate Names"><a id="idp16711328"></a><h2>Alternate Names</h2><p>di</p></div><div class="refsect1" title="Changes"><a id="idp16712560"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" title="Accesses Repository"><a id="idp16713776"></a><h2>Accesses Repository</h2><p>For obtaining differences against anything but
            <code class="literal">BASE</code> revision in your working copy</p></div><div class="refsect1" title="Switches"><a id="idp16715776"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--old OLD-TARGET
--new NEW-TARGET
--extensions (-x) "ARGS"
--non-recursive (-N)
--diff-cmd CMD
--notice-ancestry
--username USER
--password PASS
--no-auth-cache
--non-interactive
--no-diff-deleted
--config-dir DIR
</pre></div><div class="refsect1" title="Examples"><a id="idp16717488"></a><h2>Examples</h2><p>Compare <code class="literal">BASE</code> and your working copy
            (one of the most popular uses of <span class="command"><strong>svn
            diff</strong></span>):</p><pre class="screen">$ svn diff COMMITTERS
Index: COMMITTERS
===================================================================
--- COMMITTERS  (revision 4404)
+++ COMMITTERS  (working copy)
</pre><p>See how your working copy's modifications compare
            against an older revision:</p><pre class="screen">$ svn diff -r 3900 COMMITTERS
Index: COMMITTERS
===================================================================
--- COMMITTERS  (revision 3900)
+++ COMMITTERS  (working copy)
</pre><p>Compare revision 3000 to revision 3500 using <span class="quote">«<span class="quote">@</span>»</span>
            syntax:</p><pre class="screen">$ svn diff http://svn.collab.net/repos/svn/trunk/COMMITTERS@3000 http://svn.collab.net/repos/svn/trunk/COMMITTERS@3500
Index: COMMITTERS
===================================================================
--- COMMITTERS  (revision 3000)
+++ COMMITTERS  (revision 3500)
…
</pre><p>Compare revision 3000 to revision 3500 using range
            notation (you only pass the one URL in this
            case):</p><pre class="screen">$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk/COMMITTERS
Index: COMMITTERS
===================================================================
--- COMMITTERS  (revision 3000)
+++ COMMITTERS  (revision 3500)
</pre><p>Compare revision 3000 to revision 3500 of all files in
            <code class="filename">trunk</code> using range notation:</p><pre class="screen">$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk
          </pre><p>Compare revision 3000 to revision 3500 of only three
            files in <code class="filename">trunk</code> using range
            notation:</p><pre class="screen">$ svn diff -r 3000:3500 --old http://svn.collab.net/repos/svn/trunk COMMITTERS README HACKING
          </pre><p>If you have a working copy, you can obtain the
            differences without typing in the long URLs:</p><pre class="screen">$ svn diff -r 3000:3500 COMMITTERS
Index: COMMITTERS
===================================================================
--- COMMITTERS  (revision 3000)
+++ COMMITTERS  (revision 3500)
</pre><p>Use <code class="option">--diff-cmd</code>
            <em class="replaceable"><code>CMD</code></em> <code class="option">-x</code> to
            pass arguments directly to the external diff
            program</p><pre class="screen">$ svn diff --diff-cmd /usr/bin/diff -x "-i -b" COMMITTERS
Index: COMMITTERS
===================================================================
0a1,2
&gt; This is a test
&gt;
</pre></div></div><div class="refentry" title="svn export"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.export"></a><div class="titlepage"></div><a id="idp16734288" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn export — Export a clean directory tree.</p></div><div class="refsect1" title="Synopsis"><a id="idp16737360"></a><h2>Synopsis</h2><pre class="programlisting">svn export [-r REV] URL[@PEGREV] [PATH]</pre><pre class="programlisting">svn export [-r REV] PATH1[@PEGREV] [PATH2]</pre></div><div class="refsect1" title="Description"><a id="idp16739584"></a><h2>Description</h2><p>The first form exports a clean directory tree from the
            repository specified by URL, at revision
            <em class="replaceable"><code>REV</code></em> if it is given, otherwise
            at <code class="literal">HEAD</code>, into
            <em class="replaceable"><code>PATH</code></em>.  If
            <em class="replaceable"><code>PATH</code></em> is omitted, the last
            component of the <em class="replaceable"><code>URL</code></em> is used
            for the local directory name.</p><p>The second form exports a clean directory tree from
            the working copy specified by
            <em class="replaceable"><code>PATH1</code></em> into
            <em class="replaceable"><code>PATH2</code></em>.  All local changes will
            be preserved, but files not under version control will not
            be copied.</p></div><div class="refsect1" title="Alternate Names"><a id="idp16744960"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" title="Changes"><a id="idp16746176"></a><h2>Changes</h2><p>Local disk</p></div><div class="refsect1" title="Accesses Repository"><a id="idp16747392"></a><h2>Accesses Repository</h2><p>Only if exporting from a URL</p></div><div class="refsect1" title="Switches"><a id="idp16748624"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--quiet (-q)
--force
--username USER
--password PASS
--no-auth-cache
--non-interactive
--non-recursive (-N)
--config-dir DIR
--native-eol EOL
--ignore-externals
</pre></div><div class="refsect1" title="Examples"><a id="idp16750272"></a><h2>Examples</h2><p>Export from your working copy (doesn't print every
            file and directory):</p><pre class="screen">$ svn export a-wc my-export
Export complete.
</pre><p>Export directly from the repository (prints every
            file and directory):</p><pre class="screen">$ svn export file:///tmp/repos my-export
A  my-export/test
A  my-export/quiz
…
Exported revision 15.
</pre><p>When rolling operating-system-specific release
            packages, it can be useful to export a tree which uses a
            specific EOL character for line endings.  The
            <code class="option">--native-eol</code> option will do this, but it
            only affects files that have <code class="literal">svn:eol-style =
            native</code> properties attached to them.  For
            example, to export a tree with all CRLF line endings
            (possibly for a Windows .zip file distribution):</p><pre class="screen">$ svn export file://tmp/repos my-export --native-eol CRLF
A  my-export/test
A  my-export/quiz
…
Exported revision 15.
</pre></div></div><div class="refentry" title="svn help"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.help"></a><div class="titlepage"></div><a id="idp16757232" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn help — Help!</p></div><div class="refsect1" title="Synopsis"><a id="idp16760288"></a><h2>Synopsis</h2><pre class="programlisting">svn help [SUBCOMMAND...]</pre></div><div class="refsect1" title="Description"><a id="idp16761792"></a><h2>Description</h2><p>This is your best friend when you're using
            Subversion and this book isn't within reach!</p></div><div class="refsect1" title="Alternate Names"><a id="idp16763088"></a><h2>Alternate Names</h2><p>?, h</p><p>The options <code class="option">-?</code>, <code class="option">-h</code>
            and <code class="option">--help</code> have the same effect as using the
            <span class="command"><strong>help</strong></span> subcommand.</p></div><div class="refsect1" title="Changes"><a id="idp16766720"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" title="Accesses Repository"><a id="idp16767936"></a><h2>Accesses Repository</h2><p>No</p></div><div class="refsect1" title="Switches"><a id="idp16769120"></a><h2>Switches</h2><pre class="screen">--version
--quiet (-q)
--config-dir DIR
</pre></div></div><div class="refentry" title="svn import"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.import"></a><div class="titlepage"></div><a id="idp16771472" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn import — Commit an unversioned file or tree into the 
            repository.</p></div><div class="refsect1" title="Synopsis"><a id="idp16774576"></a><h2>Synopsis</h2><pre class="programlisting">svn import [PATH] URL</pre></div><div class="refsect1" title="Description"><a id="idp16776064"></a><h2>Description</h2><p>Recursively commit a copy of
            <em class="replaceable"><code>PATH</code></em> to
            <em class="replaceable"><code>URL</code></em>.  If
            <em class="replaceable"><code>PATH</code></em> is omitted
            <span class="quote">«<span class="quote"><code class="filename">.</code></span>»</span> is assumed.  Parent
            directories are created in the repository as
            necessary.</p></div><div class="refsect1" title="Alternate Names"><a id="idp16779536"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" title="Changes"><a id="idp16780752"></a><h2>Changes</h2><p>Repository</p></div><div class="refsect1" title="Accesses Repository"><a id="idp16781968"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" title="Switches"><a id="idp16783200"></a><h2>Switches</h2><pre class="screen">--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--non-recursive (-N)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--force-log
--editor-cmd EDITOR
--encoding ENC
--config-dir DIR
--auto-props
--no-auto-props
--ignore-externals
</pre></div><div class="refsect1" title="Examples"><a id="idp16784928"></a><h2>Examples</h2><p>This imports the local directory <code class="filename">myproj</code> into the
            root of your repository:</p><pre class="screen">$ svn import -m "New import" myproj http://svn.red-bean.com/repos/test
Adding         myproj/sample.txt
…
Transmitting file data .........
Committed revision 16.
</pre><p>This imports the local directory <code class="filename">myproj</code>
            into <code class="filename">trunk/misc</code> in your repository.  The
            directory <code class="filename">trunk/misc</code> need not exist before
            you import into it—<span class="command"><strong>svn import</strong></span> will
            recursively create directories for you:</p><pre class="screen">$ svn import -m "New import" myproj \
    http://svn.red-bean.com/repos/test/trunk/misc/myproj
Adding         myproj/sample.txt
…
Transmitting file data .........
Committed revision 19.
</pre><p>After importing data, note that the original tree is
            <span class="emphasis"><em>not</em></span> under version control.  To start
            working, you still need to <span class="command"><strong>svn checkout</strong></span>
            a fresh working copy of the tree.</p></div></div><div class="refentry" title="svn info"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.info"></a><div class="titlepage"></div><a id="idp16794448" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn info — Display information about a local or remote 
            item.</p></div><div class="refsect1" title="Synopsis"><a id="idp16797552"></a><h2>Synopsis</h2><pre class="programlisting">svn info [TARGET...]</pre></div><div class="refsect1" title="Description"><a id="idp16799040"></a><h2>Description</h2><p>Print information about the working copy paths or
           URLs specified.  The information shown for both may
           include:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Path</p></li><li class="listitem"><p>Name</p></li><li class="listitem"><p>URL</p></li><li class="listitem"><p>Repository Root</p></li><li class="listitem"><p>Repository UUID</p></li><li class="listitem"><p>Revision</p></li><li class="listitem"><p>Node Kind</p></li><li class="listitem"><p>Last Changed Author</p></li><li class="listitem"><p>Last Changed Revision</p></li><li class="listitem"><p>Last Changed Date</p></li><li class="listitem"><p>Lock Token</p></li><li class="listitem"><p>Lock Owner</p></li><li class="listitem"><p>Lock Created (date)</p></li><li class="listitem"><p>Lock Expires (date)</p></li></ul></div><p>Additional kinds of information available only for
            working copy paths are:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Schedule</p></li><li class="listitem"><p>Copied From URL</p></li><li class="listitem"><p>Copied From Rev</p></li><li class="listitem"><p>Text Last Updated</p></li><li class="listitem"><p>Properties Last Updated</p></li><li class="listitem"><p>Checksum</p></li><li class="listitem"><p>Conflict Previous Base File</p></li><li class="listitem"><p>Conflict Previous Working File</p></li><li class="listitem"><p>Conflict Current Base File</p></li><li class="listitem"><p>Conflict Properties File</p></li></ul></div></div><div class="refsect1" title="Alternate Names"><a id="idp16814704"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" title="Changes"><a id="idp16815920"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" title="Accesses Repository"><a id="idp16817136"></a><h2>Accesses Repository</h2><p>Only if operating on URLs</p></div><div class="refsect1" title="Switches"><a id="idp16818368"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--recursive (-R)
--targets FILENAME
--incremental
--xml
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" title="Examples"><a id="idp16820000"></a><h2>Examples</h2><p><span class="command"><strong>svn info</strong></span> will show you all the
            useful information that it has for items in your working
            copy.  It will show information for files:</p><pre class="screen">$ svn info foo.c
Path: foo.c
Name: foo.c
URL: http://svn.red-bean.com/repos/test/foo.c
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 4417
Node Kind: file
Schedule: normal
Last Changed Author: sally
Last Changed Rev: 20
Last Changed Date: 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003)
Text Last Updated: 2003-01-16 21:18:16 -0600 (Thu, 16 Jan 2003)
Properties Last Updated: 2003-01-13 21:50:19 -0600 (Mon, 13 Jan 2003)
Checksum: d6aeb60b0662ccceb6bce4bac344cb66
</pre><p>It will also show information for directories:</p><pre class="screen">$ svn info vendors
Path: vendors
URL: http://svn.red-bean.com/repos/test/vendors
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 19
Node Kind: directory
Schedule: normal
Last Changed Author: harry
Last Changed Rev: 19
Last Changed Date: 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003)
Properties Last Updated: 2003-01-16 23:39:02 -0600 (Thu, 16 Jan 2003)
</pre><p><span class="command"><strong>svn info</strong></span> also acts on URLs (also
             note that the file readme.doc in this example is locked,
             so lock information is also provided):</p><pre class="screen">$ svn info http://svn.red-bean.com/repos/test/readme.doc
Path: readme.doc
Name: readme.doc
URL: http://svn.red-bean.com/repos/test/readme.doc
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 1
Node Kind: file
Schedule: normal
Last Changed Author: sally
Last Changed Rev: 42
Last Changed Date: 2003-01-14 23:21:19 -0600 (Tue, 14 Jan 2003)
Lock Token: opaquelocktoken:14011d4b-54fb-0310-8541-dbd16bd471b2
Lock Owner: harry
Lock Created: 2003-01-15 17:35:12 -0600 (Wed, 15 Jan 2003)
Lock Comment (1 line):
My test lock comment
</pre></div></div><div class="refentry" title="svn list"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.list"></a><div class="titlepage"></div><a id="idp16827904" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn list — List directory entries in the repository.</p></div><div class="refsect1" title="Synopsis"><a id="idp16830992"></a><h2>Synopsis</h2><pre class="programlisting">svn list [TARGET[@REV]...]</pre></div><div class="refsect1" title="Description"><a id="idp16832496"></a><h2>Description</h2><p>List each <em class="replaceable"><code>TARGET</code></em> file and
            the contents of each <em class="replaceable"><code>TARGET</code></em>
            directory as they exist in the repository.  If
            <em class="replaceable"><code>TARGET</code></em> is a working copy path,
            the corresponding repository URL will be used.</p><p>The default <em class="replaceable"><code>TARGET</code></em> is
            <span class="quote">«<span class="quote"><code class="filename">.</code></span>»</span>, meaning the
            repository URL of the current working copy
            directory.</p><p>With <code class="option">--verbose</code>, the following fields show
            the status of the item:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Revision number of the last
            commit</p></li><li class="listitem"><p>Author of the
            last commit</p></li><li class="listitem"><p>Size (in
            bytes)</p></li><li class="listitem"><p>Date and time of
            the last commit</p></li></ul></div><p>With <code class="option">--xml</code>, output is in XML format (with
            a header and an enclosing document element unless
            <code class="option">--incremental</code> is also specified).  All of the
            information is present; the <code class="option">--verbose</code> option
            is not accepted.</p></div><div class="refsect1" title="Alternate Names"><a id="idp16842480"></a><h2>Alternate Names</h2><p>ls</p></div><div class="refsect1" title="Changes"><a id="idp16843664"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" title="Accesses Repository"><a id="idp16844880"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" title="Switches"><a id="idp16846064"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--verbose (-v)
--recursive (-R)
--incremental
--xml
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" title="Examples"><a id="idp16847696"></a><h2>Examples</h2><p><span class="command"><strong>svn list</strong></span> is most useful if you
            want to see what files a repository has without
            downloading a working copy:</p><pre class="screen">$ svn list http://svn.red-bean.com/repos/test/support
README.txt
INSTALL
examples/
…
</pre><p>You can pass the <code class="option">--verbose</code> switch for
            additional information, rather like the UNIX command
            <span class="command"><strong>ls -l</strong></span>:</p><pre class="screen">$ svn list --verbose file:///tmp/repos
     16 sally         28361 Jan 16 23:18 README.txt
     27 sally             0 Jan 18 15:27 INSTALL
     24 harry               Jan 18 11:27 examples/
</pre><p>For further details, see <a class="xref" href="#svn.tour.history.list" title="svn list">«<span class="command"><strong>svn list</strong></span>»</a>.</p></div></div><div class="refentry" title="svn lock"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.lock"></a><div class="titlepage"></div><a id="idp16855040" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn lock — Lock working copy paths or URLs in the
              repository, so that no other user can commit changes to
              them.</p></div><div class="refsect1" title="Synopsis"><a id="idp16858208"></a><h2>Synopsis</h2><pre class="programlisting">svn lock TARGET...</pre></div><div class="refsect1" title="Description"><a id="idp16859696"></a><h2>Description</h2><p>Lock each <em class="replaceable"><code>TARGET</code></em>.  If any
            <em class="replaceable"><code>TARGET</code></em> is already locked by
            another user, print a warning and continue locking the
            rest of the <em class="replaceable"><code>TARGET</code></em>s.  Use
            <code class="option">--force</code> to steal a lock from another user
            or working copy.</p></div><div class="refsect1" title="Alternate Names"><a id="idp16862848"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" title="Changes"><a id="idp16864064"></a><h2>Changes</h2><p>Working Copy, Repository</p></div><div class="refsect1" title="Accesses Repository"><a id="idp16865296"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" title="Switches"><a id="idp16866480"></a><h2>Switches</h2><pre class="screen">--targets FILENAME
--message (-m) TEXT
--file (-F) FILE
--force-log
--encoding ENC
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
--force
</pre></div><div class="refsect1" title="Examples"><a id="idp16868128"></a><h2>Examples</h2><p>Lock two files in your working copy:</p><pre class="screen">
$ svn lock tree.jpg house.jpg
'tree.jpg' locked by user 'harry'.
'house.jpg' locked by user 'harry'.
</pre><p>Lock a file in your working copy that is currently
            locked by another user:</p><pre class="screen">$ svn lock tree.jpg
svn: warning: Path '/tree.jpg is already locked by user 'harry in \
     filesystem '/svn/repos/db'

$ svn lock --force foo
'tree.jpg' locked by user 'sally'.
</pre><p>Lock a file without a working copy:</p><pre class="screen">$ svn lock http://svn.red-bean.com/repos/test/tree.jpg
'tree.jpg' locked by user 'sally'.
</pre><p>For further details, see <a class="xref" href="#svn.advanced.locking" title="Locking">«Locking»</a>.</p></div></div><div class="refentry" title="svn log"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.log"></a><div class="titlepage"></div><a id="idp16874416" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn log — Display commit log messages.</p></div><div class="refsect1" title="Synopsis"><a id="idp16877456"></a><h2>Synopsis</h2><pre class="programlisting">svn log [PATH]</pre><pre class="programlisting">svn log URL [PATH...]</pre></div><div class="refsect1" title="Description"><a id="idp16879632"></a><h2>Description</h2><p>The default target is the path of your current
            directory.  If no arguments are supplied, <span class="command"><strong>svn
            log</strong></span> shows the log messages for all files and
            directories inside of (and including) the current working
            directory of your working copy.  You can refine the
            results by specifying a path, one or more revisions, or
            any combination of the two.  The default revision range
            for a local path is <code class="literal">BASE:1</code>.</p><p>If you specify a URL alone, then it prints log
            messages for everything that the URL contains.  If you
            add paths past the URL, only messages for those paths
            under that URL will be printed.  The default revision range
            for a URL is <code class="literal">HEAD:1</code>.</p><p>With <code class="option">--verbose</code>, <span class="command"><strong>svn log</strong></span>
            will also print all affected paths with each log message.
            With <code class="option">--quiet</code>, <span class="command"><strong>svn log</strong></span>
            will not print the log message body itself (this is
            compatible with <code class="option">--verbose</code>).</p><p>Each log message is printed just once, even if more
            than one of the affected paths for that revision were
            explicitly requested.  Logs follow copy history by
            default.  Use <code class="option">--stop-on-copy</code> to disable
            this behavior, which can be useful for determining branch
            points.</p></div><div class="refsect1" title="Alternate Names"><a id="idp16888432"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" title="Changes"><a id="idp16889648"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" title="Accesses Repository"><a id="idp16890864"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" title="Switches"><a id="idp16892048"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--quiet (-q)
--verbose (-v)
--targets FILENAME
--stop-on-copy
--incremental
--limit NUM
--xml
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" title="Examples"><a id="idp16893712"></a><h2>Examples</h2><p>You can see the log messages for all the paths that
            changed in your working copy by running <span class="command"><strong>svn
            log</strong></span> from the top:</p><pre class="screen">$ svn log
------------------------------------------------------------------------
r20 | harry | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Tweak.
------------------------------------------------------------------------
r17 | sally | 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003) | 2 lines
…
</pre><p>Examine all log messages for a particular file in
            your working copy:</p><pre class="screen">$ svn log foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
…
</pre><p>If you don't have a working copy handy, you can log
            a URL:</p><pre class="screen">$ svn log http://svn.red-bean.com/repos/test/foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
…
</pre><p>If you want several distinct paths underneath the
            same URL, you can use the <code class="literal">URL [PATH...]</code>
            syntax.</p><pre class="screen">$ svn log http://svn.red-bean.com/repos/test/ foo.c bar.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line

Added new file bar.c
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
…
</pre><p>When you're concatenating the results of multiple
            calls to the log command, you may want to use the
            <code class="option">--incremental</code> switch. <span class="command"><strong>svn
            log</strong></span> normally prints out a dashed line at the
            beginning of a log message, after each subsequent log
            message, and following the final log message.  If you
            ran <span class="command"><strong>svn log</strong></span> on a range of two
            revisions, you would get this:</p><pre class="screen">$ svn log -r 14:15
------------------------------------------------------------------------
r14 | …

------------------------------------------------------------------------
r15 | …

------------------------------------------------------------------------
</pre><p>However, if you wanted to gather 2 non-sequential
            log messages into a file, you might do something like
            this:</p><pre class="screen">$ svn log -r 14 &gt; mylog
$ svn log -r 19 &gt;&gt; mylog
$ svn log -r 27 &gt;&gt; mylog
$ cat mylog
------------------------------------------------------------------------
r14 | …

------------------------------------------------------------------------
------------------------------------------------------------------------
r19 | …

------------------------------------------------------------------------
------------------------------------------------------------------------
r27 | …

------------------------------------------------------------------------
</pre><p>You can avoid the clutter of the double dashed lines
            in your output by using the incremental switch:</p><pre class="screen">$ svn log --incremental -r 14 &gt; mylog
$ svn log --incremental -r 19 &gt;&gt; mylog
$ svn log --incremental -r 27 &gt;&gt; mylog
$ cat mylog
------------------------------------------------------------------------
r14 | …

------------------------------------------------------------------------
r19 | …

------------------------------------------------------------------------
r27 | …
</pre><p>The <code class="option">--incremental</code> switch provides
            similar output control when using the
            <code class="option">--xml</code> switch.</p><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>If you run <span class="command"><strong>svn log</strong></span> on a specific
              path and provide a specific revision and get no output
              at all</p><pre class="screen">$ svn log -r 20 http://svn.red-bean.com/untouched.txt
------------------------------------------------------------------------
</pre><p>That just means that the path was not modified in
              that revision.  If you log from the top of the
              repository, or know the file that changed in that
              revision, you can specify it explicitly:</p><pre class="screen">$ svn log -r 20 touched.txt
------------------------------------------------------------------------
r20 | sally | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Made a change.
------------------------------------------------------------------------
</pre></td></tr></tbody></table></div></div></div><div class="refentry" title="svn merge"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.merge"></a><div class="titlepage"></div><a id="idp16915248" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn merge — Apply the differences between two sources to a
          working copy path.</p></div><div class="refsect1" title="Synopsis"><a id="idp16918368"></a><h2>Synopsis</h2><pre class="programlisting">svn merge sourceURL1[@N] sourceURL2[@M] [WCPATH]</pre><pre class="programlisting">svn merge sourceWCPATH1@N sourceWCPATH2@M [WCPATH]</pre><pre class="programlisting">svn merge -r N:M SOURCE[@REV] [WCPATH]</pre></div><div class="refsect1" title="Description"><a id="idp16921312"></a><h2>Description</h2><p>In the first and second forms, the source paths (URLs
            in the first form, working copy paths in the second) are
            specified at revisions <em class="replaceable"><code>N</code></em> and
            <em class="replaceable"><code>M</code></em>.  These are the two sources
            to be compared.  The revisions default to
            <code class="literal">HEAD</code> if omitted.</p><p>In the third form, <em class="replaceable"><code>SOURCE</code></em>
            can be a URL or working copy item, in which case the
            corresponding URL is used.  This URL, at revisions
            <em class="replaceable"><code>N</code></em> and
            <em class="replaceable"><code>M</code></em>, defines the two sources to
            be compared.</p><p><em class="replaceable"><code>WCPATH</code></em> is the working copy
            path that will receive the changes.  If
            <em class="replaceable"><code>WCPATH</code></em> is omitted, a default
            value of <span class="quote">«<span class="quote"><code class="filename">.</code></span>»</span> is assumed,
            unless the sources have identical basenames that match a
            file within <span class="quote">«<span class="quote"><code class="filename">.</code></span>»</span>: in which
            case, the differences will be applied to that file.</p><p>Unlike <span class="command"><strong>svn diff</strong></span>, the merge command
            takes the ancestry of a file into consideration when
            performing a merge operation.  This is very important when
            you're merging changes from one branch into another and
            you've renamed a file on one branch but not the other.</p></div><div class="refsect1" title="Alternate Names"><a id="idp16930896"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" title="Changes"><a id="idp16932112"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" title="Accesses Repository"><a id="idp16933328"></a><h2>Accesses Repository</h2><p>Only if working with URLs</p></div><div class="refsect1" title="Switches"><a id="idp16934560"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--non-recursive (-N)
--quiet (-q)
--force
--dry-run
--diff3-cmd CMD
--ignore-ancestry
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" title="Examples"><a id="idp16936224"></a><h2>Examples</h2><p>Merge a branch back into the trunk (assuming that
            you have a working copy of the trunk, and that the branch
            was created in revision 250):</p><pre class="screen">$ svn merge -r 250:HEAD http://svn.red-bean.com/repos/branches/my-branch
U  myproj/tiny.txt
U  myproj/thhgttg.txt
U  myproj/win.txt
U  myproj/flo.txt
</pre><p>If you branched at revision 23, and you want to
            merge changes on trunk into your branch, you could do
            this from inside the working copy of your branch:</p><pre class="screen">$ svn merge -r 23:30 file:///tmp/repos/trunk/vendors
U  myproj/thhgttg.txt
…
</pre><p>To merge changes to a single file:</p><pre class="screen">$ cd myproj
$ svn merge -r 30:31 thhgttg.txt
U  thhgttg.txt
</pre></div></div><div class="refentry" title="svn mkdir"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.mkdir"></a><div class="titlepage"></div><a id="idp16941664" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn mkdir — Create a new directory under version control.</p></div><div class="refsect1" title="Synopsis"><a id="idp16944752"></a><h2>Synopsis</h2><pre class="programlisting">svn mkdir PATH...</pre><pre class="programlisting">svn mkdir URL...</pre></div><div class="refsect1" title="Description"><a id="idp16946928"></a><h2>Description</h2><p>Create a directory with a name given by the final
            component of the <em class="replaceable"><code>PATH</code></em> or URL.
            A directory specified by a working copy
            <em class="replaceable"><code>PATH</code></em> is scheduled for addition
            in the working copy.  A directory specified by a URL is
            created in the repository via an immediate commit.
            Multiple directory URLs are committed atomically.  In both
            cases all the intermediate directories must already
            exist.</p></div><div class="refsect1" title="Alternate Names"><a id="idp16949456"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" title="Changes"><a id="idp16950672"></a><h2>Changes</h2><p>Working copy, repository if operating on a URL</p></div><div class="refsect1" title="Accesses Repository"><a id="idp16951920"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" title="Switches"><a id="idp16953152"></a><h2>Switches</h2><pre class="screen">--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--editor-cmd EDITOR
--encoding ENC
--force-log
--config-dir DIR
</pre></div><div class="refsect1" title="Examples"><a id="idp16954800"></a><h2>Examples</h2><p>Create a directory in your working copy:</p><pre class="screen">$ svn mkdir newdir
A         newdir
</pre><p>Create one in the repository (instant commit, so a
            log message is required):</p><pre class="screen">$ svn mkdir -m "Making a new dir." http://svn.red-bean.com/repos/newdir

Committed revision 26.
</pre></div></div><div class="refentry" title="svn move"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.move"></a><div class="titlepage"></div><a id="idp16958864" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn move — Move a file or directory.</p></div><div class="refsect1" title="Synopsis"><a id="idp16961936"></a><h2>Synopsis</h2><pre class="programlisting">svn move SRC DST</pre></div><div class="refsect1" title="Description"><a id="idp16963424"></a><h2>Description</h2><p>This command moves a file or directory in your
            working copy or in the repository.</p><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>This command is equivalent to an <span class="command"><strong>svn
              copy</strong></span> followed by <span class="command"><strong>svn
              delete</strong></span>.</p></td></tr></tbody></table></div><div class="note" title="Примечание" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Примечание]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/note.png"></td><th align="left">Примечание</th></tr><tr><td valign="top" align="left"><p>Subversion does not support moving between working
              copies and URLs.  In addition, you can only move files
              within a single repository—Subversion does not
              support cross-repository moving.</p></td></tr></tbody></table></div><div class="variablelist"><dl><dt><span class="term">WC  -&gt; WC</span></dt><dd><p>Move and schedule a file or directory for
                  addition (with history).</p></dd><dt><span class="term">URL -&gt; URL</span></dt><dd><p>Complete server-side rename.</p></dd></dl></div></div><div class="refsect1" title="Alternate Names"><a id="idp16971648"></a><h2>Alternate Names</h2><p>mv, rename, ren</p></div><div class="refsect1" title="Changes"><a id="idp16972864"></a><h2>Changes</h2><p>Working copy, repository if operating on a URL</p></div><div class="refsect1" title="Accesses Repository"><a id="idp16974112"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" title="Switches"><a id="idp16975344"></a><h2>Switches</h2><pre class="screen">--message (-m) TEXT
--file (-F) FILE
--revision (-r) REV
--quiet (-q)
--force
--username USER
--password PASS
--no-auth-cache
--non-interactive
--editor-cmd EDITOR
--encoding ENC
--force-log
--config-dir DIR
</pre></div><div class="refsect1" title="Examples"><a id="idp16977024"></a><h2>Examples</h2><p>Move a file in your working copy:</p><pre class="screen">$ svn move foo.c bar.c
A         bar.c
D         foo.c
</pre><p>Move a file in the repository (an immediate commit,
            so it requires a commit message):</p><pre class="screen">$ svn move -m "Move a file" http://svn.red-bean.com/repos/foo.c \
                            http://svn.red-bean.com/repos/bar.c

Committed revision 27.
</pre></div></div><div class="refentry" title="svn propdel"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.propdel"></a><div class="titlepage"></div><a id="idp16981168" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn propdel — Remove a property from an item.</p></div><div class="refsect1" title="Synopsis"><a id="idp16984240"></a><h2>Synopsis</h2><pre class="programlisting">svn propdel PROPNAME [PATH...]</pre><pre class="programlisting">svn propdel PROPNAME --revprop -r REV [URL]</pre></div><div class="refsect1" title="Description"><a id="idp16986464"></a><h2>Description</h2><p>This removes properties from files, directories, or
            revisions.  The first form removes versioned properties
            in your working copy, while the second removes unversioned
            remote properties on a repository revision.</p></div><div class="refsect1" title="Alternate Names"><a id="idp16987904"></a><h2>Alternate Names</h2><p>pdel, pd</p></div><div class="refsect1" title="Changes"><a id="idp16989120"></a><h2>Changes</h2><p>Working copy, repository only if operating on a URL</p></div><div class="refsect1" title="Accesses Repository"><a id="idp16990368"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" title="Switches"><a id="idp16991600"></a><h2>Switches</h2><pre class="screen">--quiet (-q)
--recursive (-R)
--revision (-r) REV
--revprop
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" title="Examples"><a id="idp16993216"></a><h2>Examples</h2><p>Delete a property from a file in your working
            copy</p><pre class="screen">$ svn propdel svn:mime-type  some-script
property 'svn:mime-type' deleted from 'some-script'.
</pre><p>Delete a revision property:</p><pre class="screen">$ svn propdel --revprop -r 26 release-date
property 'release-date' deleted from repository revision '26'
</pre></div></div><div class="refentry" title="svn propedit"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.propedit"></a><div class="titlepage"></div><a id="idp16997248" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn propedit — Edit the property of one or more items under
            version control.</p></div><div class="refsect1" title="Synopsis"><a id="idp17000368"></a><h2>Synopsis</h2><pre class="programlisting">svn propedit PROPNAME PATH...</pre><pre class="programlisting">svn propedit PROPNAME --revprop -r REV [URL]</pre></div><div class="refsect1" title="Description"><a id="idp17002592"></a><h2>Description</h2><p>Edit one or more properties using your favorite
            editor.  The first form edits versioned properties in
            your working copy, while the second edits unversioned
            remote properties on a repository revision.</p></div><div class="refsect1" title="Alternate Names"><a id="idp17004032"></a><h2>Alternate Names</h2><p>pedit, pe</p></div><div class="refsect1" title="Changes"><a id="idp17005248"></a><h2>Changes</h2><p>Working copy, repository only if operating on a URL</p></div><div class="refsect1" title="Accesses Repository"><a id="idp17006496"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" title="Switches"><a id="idp17007728"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--revprop
--username USER
--password PASS
--no-auth-cache
--non-interactive
--encoding ENC
--editor-cmd EDITOR
--config-dir DIR
</pre></div><div class="refsect1" title="Examples"><a id="idp17009344"></a><h2>Examples</h2><p><span class="command"><strong>svn propedit</strong></span> makes it easy to
            modify properties that have multiple values:</p><pre class="screen">$ svn propedit svn:keywords  foo.c
    &lt;svn will launch your favorite editor here, with a buffer open
    containing the current contents of the svn:keywords property.  You
    can add multiple values to a property easily here by entering one
    value per line.&gt;
Set new value for property 'svn:keywords' on 'foo.c'
</pre></div></div><div class="refentry" title="svn propget"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.propget"></a><div class="titlepage"></div><a id="idp17013360" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn propget — Print the value of a property.</p></div><div class="refsect1" title="Synopsis"><a id="idp17016432"></a><h2>Synopsis</h2><pre class="programlisting">svn propget PROPNAME [TARGET[@REV]...]</pre><pre class="programlisting">svn propget PROPNAME --revprop -r REV [URL]</pre></div><div class="refsect1" title="Description"><a id="idp17018656"></a><h2>Description</h2><p>Print the value of a property on files,
            directories, or revisions.  The first form prints the
            versioned property of an item or items in your working
            copy, while the second prints unversioned remote
            property on a repository revision.  See <a class="xref" href="#svn.advanced.props" title="Свойства">«Свойства»</a> for more information on
            properties.</p></div><div class="refsect1" title="Alternate Names"><a id="idp17020880"></a><h2>Alternate Names</h2><p>pget, pg</p></div><div class="refsect1" title="Changes"><a id="idp17022064"></a><h2>Changes</h2><p>Working copy, repository only if operating on a URL</p></div><div class="refsect1" title="Accesses Repository"><a id="idp17023312"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" title="Switches"><a id="idp17024544"></a><h2>Switches</h2><pre class="screen">--recursive (-R)
--revision (-r) REV
--revprop
--strict
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" title="Examples"><a id="idp17026160"></a><h2>Examples</h2><p>Examine a property of a file in your working
            copy:</p><pre class="screen">$ svn propget svn:keywords foo.c
Author
Date
Rev
</pre><p>The same goes for a revision property:</p><pre class="screen">$ svn propget svn:log --revprop -r 20
Began journal.
</pre></div></div><div class="refentry" title="svn proplist"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.proplist"></a><div class="titlepage"></div><a id="idp17030192" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn proplist — List all properties.</p></div><div class="refsect1" title="Synopsis"><a id="idp17033248"></a><h2>Synopsis</h2><pre class="programlisting">svn proplist [TARGET[@REV]...]</pre><pre class="programlisting">svn proplist --revprop -r REV [URL]</pre></div><div class="refsect1" title="Description"><a id="idp17035456"></a><h2>Description</h2><p>List all properties on files, directories, or
            revisions.  The first form lists versioned properties in
            your working copy, while the second lists unversioned remote
            properties on a repository revision.</p></div><div class="refsect1" title="Alternate Names"><a id="idp17036896"></a><h2>Alternate Names</h2><p>plist, pl</p></div><div class="refsect1" title="Changes"><a id="idp17038112"></a><h2>Changes</h2><p>Working copy, repository only if operating on a URL</p></div><div class="refsect1" title="Accesses Repository"><a id="idp17039360"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" title="Switches"><a id="idp17040592"></a><h2>Switches</h2><pre class="screen">--verbose (-v)
--recursive (-R)
--revision (-r) REV
--quiet (-q)
--revprop
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" title="Examples"><a id="idp17042224"></a><h2>Examples</h2><p>You can use proplist to see the properties on an
            item in your working copy:</p><pre class="screen">$ svn proplist foo.c
Properties on 'foo.c':
  svn:mime-type
  svn:keywords
  owner
</pre><p>But with the <code class="option">--verbose</code> flag, svn
            proplist is extremely handy as it also shows you the
            values for the properties:</p><pre class="screen">$ svn proplist --verbose foo.c
Properties on 'foo.c':
  svn:mime-type : text/plain
  svn:keywords : Author Date Rev
  owner : sally
</pre></div></div><div class="refentry" title="svn propset"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.propset"></a><div class="titlepage"></div><a id="idp17046912" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn propset — Set PROPNAME to PROPVAL on files, directories, or revisions.</p></div><div class="refsect1" title="Synopsis"><a id="idp17050016"></a><h2>Synopsis</h2><pre class="programlisting">svn propset PROPNAME [PROPVAL | -F VALFILE] PATH...</pre><pre class="programlisting">svn propset PROPNAME --revprop -r REV [PROPVAL | -F VALFILE] [URL]</pre></div><div class="refsect1" title="Description"><a id="idp17052272"></a><h2>Description</h2><p>Set <em class="replaceable"><code>PROPNAME</code></em> to
            <em class="replaceable"><code>PROPVAL</code></em> on files, directories,
            or revisions.  The first example creates a versioned, local
            property change in the working copy, and the second
            creates an unversioned, remote property change on a
            repository revision.</p><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>Subversion has a number of <span class="quote">«<span class="quote">special</span>»</span>
              properties that affect its behavior.  See <a class="xref" href="#svn.ref.properties" title="Свойства Subversion">«Свойства Subversion»</a> for more on these
              properties.</p></td></tr></tbody></table></div></div><div class="refsect1" title="Alternate Names"><a id="idp17056848"></a><h2>Alternate Names</h2><p>pset, ps</p></div><div class="refsect1" title="Changes"><a id="idp17058032"></a><h2>Changes</h2><p>Working copy, repository only if operating on a URL</p></div><div class="refsect1" title="Accesses Repository"><a id="idp17059280"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" title="Switches"><a id="idp17060512"></a><h2>Switches</h2><pre class="screen">--file (-F) FILE
--quiet (-q)
--revision (-r) REV
--targets FILENAME
--recursive (-R)
--revprop
--username USER
--password PASS
--no-auth-cache
--non-interactive
--encoding ENC
--force
--config-dir DIR
</pre></div><div class="refsect1" title="Examples"><a id="idp17062192"></a><h2>Examples</h2><p>Set the mimetype on a file:</p><pre class="screen">$ svn propset svn:mime-type image/jpeg foo.jpg
property 'svn:mime-type' set on 'foo.jpg'
</pre><p>On a UNIX system, if you want a file to have the
            executable permission set:</p><pre class="screen">$ svn propset svn:executable ON somescript
property 'svn:executable' set on 'somescript'
</pre><p>Perhaps you have an internal policy to set certain
            properties for the benefit of your coworkers:</p><pre class="screen">$ svn propset owner sally foo.c
property 'owner' set on 'foo.c'
</pre><p>If you made a mistake in a log message for a
            particular revision and want to change it, use
            <code class="option">--revprop</code> and set <code class="literal">svn:log</code>
            to the new log message:</p><pre class="screen">$ svn propset --revprop -r 25 svn:log "Journaled about trip to New York."
property 'svn:log' set on repository revision '25'
</pre><p>Or, if you don't have a working copy, you can
            provide a URL.</p><pre class="screen">$ svn propset --revprop -r 26 svn:log "Document nap." http://svn.red-bean.com/repos
property 'svn:log' set on repository revision '25'
</pre><p>Lastly, you can tell propset to take its input from
            a file.  You could even use this to set the contents of a
            property to something binary:</p><pre class="screen">$ svn propset owner-pic -F sally.jpg moo.c
property 'owner-pic' set on 'moo.c'
</pre><div class="note" title="Примечание" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Примечание]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/note.png"></td><th align="left">Примечание</th></tr><tr><td valign="top" align="left"><p>By default, you cannot modify revision properties
              in a Subversion repository.  Your repository
              administrator must explicitly enable revision property
              modifications by creating a hook named
              <code class="literal">pre-revprop-change</code>.  See <a class="xref" href="#svn.reposadmin.create.hooks" title="Hook Scripts">«Hook Scripts»</a> for more information on
              hook scripts.</p></td></tr></tbody></table></div></div></div><div class="refentry" title="svn resolved"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.resolved"></a><div class="titlepage"></div><a id="idp17075104" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn resolved — Remove <span class="quote">«<span class="quote">conflicted</span>»</span> state on
            working copy files or directories.</p></div><div class="refsect1" title="Synopsis"><a id="idp17078656"></a><h2>Synopsis</h2><pre class="programlisting">svn resolved PATH...</pre></div><div class="refsect1" title="Description"><a id="idp17080144"></a><h2>Description</h2><p>Remove <span class="quote">«<span class="quote">conflicted</span>»</span> state on working copy
            files or directories.  This routine does not semantically
            resolve conflict markers; it merely removes
            conflict-related artifact files and allows
            <em class="replaceable"><code>PATH</code></em> to be committed again;
            that is, it tells Subversion that the conflicts have been
            <span class="quote">«<span class="quote">resolved</span>»</span>.  See <a class="xref" href="#svn.tour.cycle.resolve" title="Разрешение конфликтов (при слиянии с чужими изменениями)">«Разрешение конфликтов (при слиянии с чужими 
        изменениями)»</a> for an in-depth look at
            resolving conflicts.</p></div><div class="refsect1" title="Alternate Names"><a id="idp17083760"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" title="Changes"><a id="idp17084944"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" title="Accesses Repository"><a id="idp17086160"></a><h2>Accesses Repository</h2><p>No</p></div><div class="refsect1" title="Switches"><a id="idp17087344"></a><h2>Switches</h2><pre class="screen">--targets FILENAME
--recursive (-R)
--quiet (-q)
--config-dir DIR
</pre></div><div class="refsect1" title="Examples"><a id="idp17088880"></a><h2>Examples</h2><p>If you get a conflict on an update, your working
            copy will sprout three new files:</p><pre class="screen">$ svn update
C  foo.c
Updated to revision 31.
$ ls
foo.c
foo.c.mine
foo.c.r30
foo.c.r31
</pre><p>Once you've resolved the conflict and
            <code class="filename">foo.c</code> is ready to be committed, run
            <span class="command"><strong>svn resolved</strong></span> to let your working copy
            know you've taken care of everything.</p><div class="warning" title="Предупреждение" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Предупреждение]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/warning.png"></td><th align="left">Предупреждение</th></tr><tr><td valign="top" align="left"><p>You <span class="emphasis"><em>can</em></span> just remove the
              conflict files and commit, but <span class="command"><strong>svn
              resolved</strong></span> fixes up some bookkeeping data
              in the working copy administrative area in addition
              to removing the conflict files, so we recommend that
              you use this command.</p></td></tr></tbody></table></div></div></div><div class="refentry" title="svn revert"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.revert"></a><div class="titlepage"></div><a id="idp17095952" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn revert — Undo all local edits.</p></div><div class="refsect1" title="Synopsis"><a id="idp17099008"></a><h2>Synopsis</h2><pre class="programlisting">svn revert PATH...</pre></div><div class="refsect1" title="Description"><a id="idp17100496"></a><h2>Description</h2><p>Reverts any local changes to a file or directory and
            resolves any conflicted states.  <span class="command"><strong>svn
            revert</strong></span> will not only revert the contents of an
            item in your working copy, but also any property
            changes.  Finally, you can use it to undo any scheduling
            operations that you may have done (e.g. files scheduled
            for addition or deletion can be
            <span class="quote">«<span class="quote">unscheduled</span>»</span>).</p></div><div class="refsect1" title="Alternate Names"><a id="idp17103200"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" title="Changes"><a id="idp17104416"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" title="Accesses Repository"><a id="idp17105632"></a><h2>Accesses Repository</h2><p>No</p></div><div class="refsect1" title="Switches"><a id="idp17106816"></a><h2>Switches</h2><pre class="screen">--targets FILENAME
--recursive (-R)
--quiet (-q)
--config-dir DIR
</pre></div><div class="refsect1" title="Examples"><a id="idp17108352"></a><h2>Examples</h2><p>Discard changes to a file:</p><pre class="screen">$ svn revert foo.c
Reverted foo.c
</pre><p>If you want to revert a whole directory of files,
            use the <code class="option">--recursive</code> flag:</p><pre class="screen">$ svn revert --recursive .
Reverted newdir/afile
Reverted foo.c
Reverted bar.txt
</pre><p>Lastly, you can undo any scheduling
            operations:</p><pre class="screen">$ svn add mistake.txt whoops
A         mistake.txt
A         whoops
A         whoops/oopsie.c

$ svn revert mistake.txt whoops
Reverted mistake.txt
Reverted whoops

$ svn status
?      mistake.txt
?      whoops
</pre><div class="note" title="Примечание" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Примечание]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/note.png"></td><th align="left">Примечание</th></tr><tr><td valign="top" align="left"><p>If you provide no targets to <span class="command"><strong>svn
              revert</strong></span>, it will do nothing—to protect
              you from accidentally losing changes in your working
              copy, <span class="command"><strong>svn revert</strong></span> requires you to
              provide at least one target.</p></td></tr></tbody></table></div></div></div><div class="refentry" title="svn status"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.status"></a><div class="titlepage"></div><a id="idp17116512" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn status — Print the status of working copy files and directories.</p></div><div class="refsect1" title="Synopsis"><a id="idp17119600"></a><h2>Synopsis</h2><pre class="programlisting">svn status [PATH...]</pre></div><div class="refsect1" title="Description"><a id="idp17121088"></a><h2>Description</h2><p>Print the status of working copy files and
            directories.  With no arguments, it prints only locally
            modified items (no repository access).  With
            <code class="option">--show-updates</code>, add working revision
            and server out-of-date information.  With
            <code class="option">--verbose</code>, print full revision
            information on every item.</p><p>The first six columns in the output are each one
            character wide, and each column gives you information
            about different aspects of each working copy item.</p><p>The first column indicates that an item
            was added, deleted, or otherwise changed.</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>No modifications.</p></dd><dt><span class="term">'A'</span></dt><dd><p>Item is scheduled for Addition.</p></dd><dt><span class="term">'D'</span></dt><dd><p>Item is scheduled for Deletion.</p></dd><dt><span class="term">'M'</span></dt><dd><p>Item has been modified.</p></dd><dt><span class="term">'R'</span></dt><dd><p>Item has been replaced in your working copy.
                This means the file was scheduled for deletion, and
                then a new file with the same name was scheduled for
                addition in its place.</p></dd><dt><span class="term">'C'</span></dt><dd><p>The contents (as opposed to the properties) of
                  the item conflict with updates received from the
                  repository.</p></dd><dt><span class="term">'X'</span></dt><dd><p>Item is related to an externals definition.</p></dd><dt><span class="term">'I'</span></dt><dd><p>Item is being ignored (e.g. with the
                  <code class="literal">svn:ignore</code> property).</p></dd><dt><span class="term">'?'</span></dt><dd><p>Item is not under version control.</p></dd><dt><span class="term">'!'</span></dt><dd><p>Item is missing (e.g. you moved or deleted it
                  without using <span class="command"><strong>svn</strong></span>).  This also
                  indicates that a directory is incomplete (a checkout
                  or update was interrupted).</p></dd><dt><span class="term">'~'</span></dt><dd><p>Item is versioned as one kind of object (file,
                  directory, link), but has been replaced by different
                  kind of object.</p></dd></dl></div><p>The second column tells the status of a file's or
            directory's properties.</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>No modifications.</p></dd><dt><span class="term">'M'</span></dt><dd><p>Properties for this item have been
                  modified.</p></dd><dt><span class="term">'C'</span></dt><dd><p>Properties for this item are in conflict with
                  property updates received from the
                  repository.</p></dd></dl></div><p>The third column is populated only if the
            working copy directory is locked. (See
            <a class="xref" href="#svn.tour.other.cleanup" title="svn cleanup">«<span class="command"><strong>svn cleanup</strong></span>»</a>.)</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>Item is not locked.</p></dd><dt><span class="term">'L'</span></dt><dd><p>Item is locked.</p></dd></dl></div><p>The fourth column is populated only if the item is
            scheduled for addition-with-history.</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>No history scheduled with commit.</p></dd><dt><span class="term">'+'</span></dt><dd><p>History scheduled with commit.</p></dd></dl></div><p>The fifth column is populated only if the item is
            switched relative to its parent (see <a class="xref" href="#svn.branchmerge.switchwc" title="Переключение рабочей копии">«Переключение рабочей копии»</a>).</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>Item is a child of its parent directory.</p></dd><dt><span class="term">'S'</span></dt><dd><p>Item is switched.</p></dd></dl></div><p>The sixth column is populated with lock information.</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>When <code class="option">--show-updates</code> is used,
                the file is not locked.  If
                <code class="option">--show-updates</code> is
                <span class="emphasis"><em>not</em></span> used, this merely means that
                the file is not locked in this working copy.</p></dd><dt><span class="term">K</span></dt><dd><p>File is locked in this working copy.</p></dd><dt><span class="term">O</span></dt><dd><p>File is locked either by another user or in
                another working copy.  This only appears when
                <code class="option">--show-updates</code> is used.</p></dd><dt><span class="term">T</span></dt><dd><p>File was locked in this working copy, but the
                lock has been <span class="quote">«<span class="quote">stolen</span>»</span>and is invalid.
                The file is currently locked in the repository.  This
                only appears when <code class="option">--show-updates</code> is
                used.</p></dd><dt><span class="term">B</span></dt><dd><p>File was locked in this working copy, but the
                lock has been <span class="quote">«<span class="quote">broken</span>»</span>and is invalid.
                The file is no longer locked This only appears when
                <code class="option">--show-updates</code> is used.</p></dd></dl></div><p>The out-of-date information appears in the seventh
            column (only if you pass the
            <code class="option">--show-updates</code> switch).</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>The item in your working copy is up-to-date.</p></dd><dt><span class="term">'*'</span></dt><dd><p>A newer revision of the item exists on the
                  server.</p></dd></dl></div><p>The remaining fields are variable width and
            delimited by spaces.  The working revision is the next
            field if the <code class="option">--show-updates</code> or
            <code class="option">--verbose</code> switches are passed.</p><p>If the <code class="option">--verbose</code> switch is passed,
            the last committed revision and last committed author
            are displayed next.</p><p>The working copy path is always the final field, so
            it can include spaces.</p></div><div class="refsect1" title="Alternate Names"><a id="idp17184448"></a><h2>Alternate Names</h2><p>stat, st</p></div><div class="refsect1" title="Changes"><a id="idp17185664"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" title="Accesses Repository"><a id="idp17186880"></a><h2>Accesses Repository</h2><p>Only if using <code class="option">--show-updates</code></p></div><div class="refsect1" title="Switches"><a id="idp17188384"></a><h2>Switches</h2><pre class="screen">--show-updates (-u)
--verbose (-v)
--non-recursive (-N)
--quiet (-q)
--no-ignore
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
--ignore-externals
</pre></div><div class="refsect1" title="Examples"><a id="idp17190048"></a><h2>Examples</h2><p>This is the easiest way to find out what changes you
            have made to your working copy:</p><pre class="screen">$ svn status wc
 M     wc/bar.c
A  +   wc/qax.c
</pre><p>If you want to find out what files in your working
            copy are out-of-date, pass the
            <code class="option">--show-updates</code> switch (this will
            <span class="emphasis"><em>not</em></span> make any changes to your
            working copy).  Here you can see that
            <code class="filename">wc/foo.c</code> has changed in the
            repository since we last updated our working
            copy:</p><pre class="screen">$ svn status --show-updates wc
 M           965    wc/bar.c
       *     965    wc/foo.c
A  +         965    wc/qax.c
Status against revision:    981
</pre><div class="note" title="Примечание" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Примечание]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/note.png"></td><th align="left">Примечание</th></tr><tr><td valign="top" align="left"><p><code class="option">--show-updates</code>
              <span class="emphasis"><em>only</em></span> places an asterisk next to
              items that are out of date (that is, items that will be
              updated from the repository if you run <span class="command"><strong>svn
              update</strong></span>).  <code class="option">--show-updates</code> does
              <span class="emphasis"><em>not</em></span> cause the status listing to
              reflect the repository's version of the item.</p></td></tr></tbody></table></div><p>And finally, the most information you can get out of
            the status subcommand:</p><pre class="screen">$ svn status --show-updates --verbose wc
 M           965       938 sally        wc/bar.c
       *     965       922 harry        wc/foo.c
A  +         965       687 harry        wc/qax.c
             965       687 harry        wc/zig.c
Head revision:   981
</pre><p>For many more examples of <span class="command"><strong>svn status</strong></span>,
            see <a class="xref" href="#svn.tour.cycle.examine.status" title="svn status">«<span class="command"><strong>svn status</strong></span>»</a>.</p></div></div><div class="refentry" title="svn switch"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.switch"></a><div class="titlepage"></div><a id="idp17202592" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn switch — Update working copy to a different URL.</p></div><div class="refsect1" title="Synopsis"><a id="idp17205616"></a><h2>Synopsis</h2><pre class="programlisting">svn switch URL [PATH]</pre><pre class="programlisting">switch --relocate FROM TO [PATH...]</pre></div><div class="refsect1" title="Description"><a id="idp17207808"></a><h2>Description</h2><p>This subcommand updates your working copy to mirror
            a new URL—usually a URL which shares a common
            ancestor with your working copy, although not
            necessarily.  This is the Subversion way to move a
            working copy to a new branch.  See <a class="xref" href="#svn.branchmerge.switchwc" title="Переключение рабочей копии">«Переключение рабочей копии»</a> for an in-depth look at
            switching.</p></div><div class="refsect1" title="Alternate Names"><a id="idp17210176"></a><h2>Alternate Names</h2><p>sw</p></div><div class="refsect1" title="Changes"><a id="idp17211360"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" title="Accesses Repository"><a id="idp17212576"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" title="Switches"><a id="idp17213760"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--non-recursive (-N)
--quiet (-q)
--diff3-cmd CMD
--relocate FROM TO
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
</pre></div><div class="refsect1" title="Examples"><a id="idp17215408"></a><h2>Examples</h2><p>If you're currently inside the directory
            <code class="filename">vendors</code> which was branched to
            <code class="filename">vendors-with-fix</code> and you'd like to
            switch your working copy to that branch:</p><pre class="screen">$ svn switch http://svn.red-bean.com/repos/branches/vendors-with-fix .
U  myproj/foo.txt
U  myproj/bar.txt
U  myproj/baz.c
U  myproj/qux.c
Updated to revision 31.
</pre><p>And to switch back, just provide the URL to the
            location in the repository from which you originally
            checked out your working copy:</p><pre class="screen">$ svn switch http://svn.red-bean.com/repos/trunk/vendors .
U  myproj/foo.txt
U  myproj/bar.txt
U  myproj/baz.c
U  myproj/qux.c
Updated to revision 31.
</pre><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>You can just switch part of your working copy to a
              branch if you don't want to switch your entire working
              copy.</p></td></tr></tbody></table></div><p>Sometimes an administrator might change the
            <span class="quote">«<span class="quote">base location</span>»</span> of your repository—in
            other words, the contents of the repository doesn't
            change, but the main URL used to reach the root of the
            repository does.  For example, the hostname may change,
            the URL scheme, or any part of the URL which leads to the
            repository itself.  Rather than checkout a new working
            copy, you can have the <span class="command"><strong>svn switch</strong></span>
            command <span class="quote">«<span class="quote">rewrite</span>»</span> the beginnings of all the
            URLs in your working copy.  Use the
            <code class="option">--relocate</code> option to do the substitution.
            No file contents are changed, nor is the repository
            contacted.  It's similar to running a Perl script over
            your working copy <code class="filename">.svn/</code> directories
            which runs <span class="command"><strong>s/OldRoot/NewRoot/</strong></span>.</p><pre class="screen">$ svn checkout file:///tmp/repos test
A  test/a
A  test/b
…

$ mv repos newlocation
$ cd test/

$ svn update
svn: Unable to open an ra_local session to URL
svn: Unable to open repository 'file:///tmp/repos'

$ svn switch --relocate file:///tmp/repos file:///tmp/newlocation .
$ svn update
At revision 3.
</pre><div class="warning" title="Предупреждение" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Предупреждение]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/warning.png"></td><th align="left">Предупреждение</th></tr><tr><td valign="top" align="left"><p>Be careful when using the
            <code class="option">--relocate</code> option.  If you mistype the
            argument, you might end up creating nonsensical URLs
            within your working copy that render the whole workspace
            unusable and tricky to fix.  It's also important to
            understand exactly when one should or shouldn't use
            <code class="option">--relocate</code>.  Here's the rule of
            thumb:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If the working copy needs to reflect a
                  new directory <span class="emphasis"><em>within</em></span> the
                  repository, then use just <span class="command"><strong>svn
                  switch</strong></span>.</p></li><li class="listitem"><p>If the working copy still reflects the
                  same repository directory, but the location of the
                  repository itself has changed, then use <span class="command"><strong>svn
                  switch --relocate</strong></span>.</p></li></ul></div></td></tr></tbody></table></div></div></div><div class="refentry" title="svn unlock"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.unlock"></a><div class="titlepage"></div><a id="idp17233136" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn unlock — Unlock working copy paths or URLs.</p></div><div class="refsect1" title="Synopsis"><a id="idp17236256"></a><h2>Synopsis</h2><pre class="programlisting">svn unlock TARGET...</pre></div><div class="refsect1" title="Description"><a id="idp17237744"></a><h2>Description</h2><p>Unlock each <em class="replaceable"><code>TARGET</code></em>.  If any
            <em class="replaceable"><code>TARGET</code></em> is either locked by
            another user or no valid lock token exists in the working
            copy, print a warning and continue unlocking the rest of
            the <em class="replaceable"><code>TARGET</code></em>s.  Use
            <code class="option">--force</code> to break a lock belonging to
            another user or working copy.</p></div><div class="refsect1" title="Alternate Names"><a id="idp17240960"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" title="Changes"><a id="idp17242176"></a><h2>Changes</h2><p>Working Copy, Repository</p></div><div class="refsect1" title="Accesses Repository"><a id="idp17243408"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" title="Switches"><a id="idp17244592"></a><h2>Switches</h2><pre class="screen">--targets FILENAME
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
--force
</pre></div><div class="refsect1" title="Examples"><a id="idp17246176"></a><h2>Examples</h2><p>Unlock two files in your working copy:</p><pre class="screen">
$ svn unlock tree.jpg house.jpg
'tree.jpg' unlocked.
'house.jpg' unlocked.
</pre><p>Unlock a file in your working copy that is currently
            locked by another user:</p><pre class="screen">$ svn unlock tree.jpg
svn: 'tree.jpg' is not locked in this working copy
$ svn unlock --force tree.jpg
'tree.jpg' unlocked.
</pre><p>Unlock a file without a working copy:</p><pre class="screen">$ svn unlock http://svn.red-bean.com/repos/test/tree.jpg
'tree.jpg unlocked.
</pre><p>For further details, see <a class="xref" href="#svn.advanced.locking" title="Locking">«Locking»</a>.</p></div></div><div class="refentry" title="svn update"><div class="refentry.separator"><hr></div><a id="svn.ref.svn.c.update"></a><div class="titlepage"></div><a id="idp17252544" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svn update — Update your working copy.</p></div><div class="refsect1" title="Synopsis"><a id="idp17255616"></a><h2>Synopsis</h2><pre class="programlisting">svn update [PATH...]</pre></div><div class="refsect1" title="Description"><a id="idp17257104"></a><h2>Description</h2><p><span class="command"><strong>svn update</strong></span> brings changes from the
            repository into your working copy.  If no revision given,
            it brings your working copy up-to-date with the
            <code class="literal">HEAD</code> revision.  Otherwise, it
            synchronizes the working copy to the revision given by the
            <code class="option">--revision</code> switch.  As part of the
            synchronization, <span class="command"><strong>svn update</strong></span> also
            removes any stale locks (see <a class="xref" href="#svn.tour.other.cleanup" title="svn cleanup">«<span class="command"><strong>svn cleanup</strong></span>»</a>) found in the
            working copy.</p><p>For each updated item a line will start with a
            character reporting the action taken.  These characters
            have the following meaning:</p><div class="variablelist"><dl><dt><span class="term">A</span></dt><dd><p>Added</p></dd><dt><span class="term">D</span></dt><dd><p>Deleted</p></dd><dt><span class="term">U</span></dt><dd><p>Updated</p></dd><dt><span class="term">C</span></dt><dd><p>Conflict</p></dd><dt><span class="term">G</span></dt><dd><p>Merged</p></dd></dl></div><p>A character in the first column signifies an update
            to the actual file, while updates to the file's
            properties are shown in the second column.</p></div><div class="refsect1" title="Alternate Names"><a id="idp17271120"></a><h2>Alternate Names</h2><p>up</p></div><div class="refsect1" title="Changes"><a id="idp17272352"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" title="Accesses Repository"><a id="idp17273568"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" title="Switches"><a id="idp17274752"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--non-recursive (-N)
--quiet (-q)
--diff3-cmd CMD
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR
--ignore-externals
</pre></div><div class="refsect1" title="Examples"><a id="idp17276400"></a><h2>Examples</h2><p>Pick up repository changes that have happened since
            your last update:</p><pre class="screen">$ svn update
A  newdir/toggle.c
A  newdir/disclose.c
A  newdir/launch.c
D  newdir/README
Updated to revision 32.
</pre><p>You can also update your working copy to an older
            revision (Subversion doesn't have the concept of
            <span class="quote">«<span class="quote">sticky</span>»</span> files like CVS does; see <a class="xref" href="#svn.forcvs" title="Приложение B. Subversion для пользователей CVS">Приложение&nbsp;B, <em>Subversion для пользователей CVS</em></a>):</p><pre class="screen">$ svn update -r30
A  newdir/README
D  newdir/toggle.c
D  newdir/disclose.c
D  newdir/launch.c
U  foo.c
Updated to revision 30.
</pre><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Подсказка]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/tip.png"></td><th align="left">Подсказка</th></tr><tr><td valign="top" align="left"><p>If you want to examine an older revision of a
              single file, you may want to use <span class="command"><strong>svn
              cat</strong></span>.</p></td></tr></tbody></table></div></div></div></div></div><div class="sect1" title="svnadmin"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.ref.svnadmin"></a><span class="command"><strong>svnadmin</strong></span></h2></div></div></div><p><span class="command"><strong>svnadmin</strong></span> is the administrative tool for
      monitoring and repairing your Subversion repository.  For
      detailed information, see <a class="xref" href="#svn.reposadmin.maint.tk.svnadmin" title="svnadmin">«svnadmin»</a>.</p><p>Since <span class="command"><strong>svnadmin</strong></span> works via direct repository access
      (and thus can only be used on the machine that holds the
      repository), it refers to the repository with a path, not a URL.</p><div class="sect2" title="svnadmin Switches"><div class="titlepage"><div><div><h3 class="title"><a id="svn.ref.svnadmin.sw"></a><span class="command"><strong>svnadmin</strong></span> Switches</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="option">--bdb-log-keep</code></span></dt><dd><p>(Berkeley DB specific) Disable automatic log removal
              of database log files.</p></dd><dt><span class="term"><code class="option">--bdb-txn-nosync</code></span></dt><dd><p>(Berkeley DB specific) Disables fsync when
              committing database transactions.</p></dd><dt><span class="term"><code class="option">--bypass-hooks</code></span></dt><dd><p>Bypass the repository hook system.</p></dd><dt><span class="term"><code class="option">--clean-logs</code></span></dt><dd><p>Removes unused Berkeley DB logs.</p></dd><dt><span class="term"><code class="option">--force-uuid</code></span></dt><dd><p>By default, when loading data into repository that
              already contains revisions, <span class="command"><strong>svnadmin</strong></span>
              will ignore the <code class="literal">UUID</code> from the dump
              stream.  This switch will cause the repository's
              <code class="literal">UUID</code> to be set to the
              <code class="literal">UUID</code> from the stream.</p></dd><dt><span class="term"><code class="option">--ignore-uuid</code></span></dt><dd><p>By default, when loading an empty repository,
              <span class="command"><strong>svnadmin</strong></span> will use the
              <code class="literal">UUID</code> from the dump stream.  This
              switch will cause that UUID to be ignored.</p></dd><dt><span class="term"><code class="option">--incremental</code></span></dt><dd><p>Dump a revision only as a diff against the
              previous revision, instead of the usual
              fulltext.</p></dd><dt><span class="term"><code class="option">--parent-dir
          <em class="replaceable"><code>DIR</code></em></code></span></dt><dd><p>When loading a dump file, root paths at
              <em class="replaceable"><code>DIR</code></em> instead of
              <code class="filename">/</code>.</p></dd><dt><span class="term"><code class="option">--revision</code> (<code class="option">-r</code>)
          <em class="replaceable"><code>ARG</code></em></span></dt><dd><p>Specify a particular revision to operate
              on.</p></dd><dt><span class="term"><code class="option">--quiet</code></span></dt><dd><p>Do not show normal progress—show only
              errors.</p></dd><dt><span class="term"><code class="option">--use-post-commit-hook</code></span></dt><dd><p>When loading a dump file, run the repository's
              post-commit hook after finalizing each newly loaded
              revision.</p></dd><dt><span class="term"><code class="option">--use-pre-commit-hook</code></span></dt><dd><p>When loading a dump file, run the repository's
              pre-commit hook before finalizing each newly loaded
              revision.  If the hook fails, abort the commit and
              terminate the load process.</p></dd></dl></div></div><div class="sect2" title="svnadmin Subcommands"><div class="titlepage"><div><div><h3 class="title"><a id="svn.ref.svnadmin.c"></a><span class="command"><strong>svnadmin</strong></span> Subcommands</h3></div></div></div><div class="refentry" title="svnadmin create"><a id="svn.ref.svnadmin.c.create"></a><div class="titlepage"></div><a id="idp17322704" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnadmin create — Create a new, empty repository.</p></div><div class="refsect1" title="Synopsis"><a id="idp17325792"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin create REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17327296"></a><h2>Description</h2><p>Create a new, empty repository at the path provided.
              If the provided directory does not exist, it will be
              created for you.<sup>[<a id="idp17328384" href="#ftn.idp17328384" class="footnote">57</a>]</sup> As of
              Subversion 1.2, <span class="command"><strong>svnadmin</strong></span> creates new
              repositories with the <code class="literal">fsfs</code> filesystem
              backend by default.</p></div><div class="refsect1" title="Switches"><a id="idp17332352"></a><h2>Switches</h2><pre class="screen">--bdb-txn-nosync
--bdb-log-keep
--config-dir DIR
--fs-type TYPE
</pre></div><div class="refsect1" title="Examples"><a id="idp17333808"></a><h2>Examples</h2><p>Creating a new repository is just this easy:</p><pre class="screen">$ svnadmin create /usr/local/svn/repos
</pre><p>In Subversion 1.0, a Berkeley DB repository is always
            created.  In Subversion 1.1, a Berkeley DB repository is
            the default repository type, but an FSFS repository can be
            created using the <code class="option">--fs-type</code>
            option:</p><pre class="screen">$ svnadmin create /usr/local/svn/repos --fs-type fsfs
</pre></div><div class="footnotes"><br><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.idp17328384" href="#idp17328384" class="para">57</a>] </sup>Remember,
              <span class="command"><strong>svnadmin</strong></span> works only with local
              <span class="emphasis"><em>paths</em></span>, not
              <span class="emphasis"><em>URLs</em></span>.</p></div></div></div><div class="refentry" title="svnadmin deltify"><div class="refentry.separator"><hr></div><a id="svn.ref.svnadmin.c.deltify"></a><div class="titlepage"></div><a id="idp17338464" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnadmin deltify — Deltify changed paths in a revision range.</p></div><div class="refsect1" title="Synopsis"><a id="idp17341616"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin deltify [-r LOWER[:UPPER]] REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17343136"></a><h2>Description</h2><p><span class="command"><strong>svnadmin deltify</strong></span> only exists in
            current versions of Subversion due to historical reasons.
            This command is deprecated and no longer needed.</p><p>It dates from a time when Subversion offered
            administrators greater control over compression strategies
            in the repository.  This turned out to be a lot of
            complexity for <span class="emphasis"><em>very</em></span> little gain, and
            this <span class="quote">«<span class="quote">feature</span>»</span> was deprecated.</p></div><div class="refsect1" title="Switches"><a id="idp17346512"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--quiet (-q)
</pre></div></div><div class="refentry" title="svnadmin dump"><div class="refentry.separator"><hr></div><a id="svn.ref.svnadmin.c.dump"></a><div class="titlepage"></div><a id="idp17348912" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnadmin dump — Dump the contents of filesystem to stdout.</p></div><div class="refsect1" title="Synopsis"><a id="idp17352032"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin dump REPOS_PATH [-r LOWER[:UPPER]] [--incremental]</pre></div><div class="refsect1" title="Description"><a id="idp17353568"></a><h2>Description</h2><p>Dump the contents of filesystem to stdout in a
            <span class="quote">«<span class="quote">dumpfile</span>»</span> portable format, sending feedback
            to stderr.  Dump revisions
            <em class="replaceable"><code>LOWER</code></em> rev through
            <em class="replaceable"><code>UPPER</code></em> rev.  If no revisions are
            given, dump all revision trees.  If only
            <em class="replaceable"><code>LOWER</code></em> is given, dump that one
            revision tree.  See <a class="xref" href="#svn.reposadmin.maint.migrate" title="Migrating a Repository">«Migrating a Repository»</a>
            for a practical use.</p><p>By default, the Subversion dumpfile stream contains a
            single revision (the first revision in the requested
            revision range) in which every file and directory in the
            repository in that revision is presented as if that whole
            tree was added at once, followed by other revisions (the
            remainder of the revisions in the requested range) which
            contain only the files and directories which were modified
            in those revisions.  For a modified file, the complete
            fulltext representation of its contents, as well as all of
            its properties, are presented in the dumpfile; for a
            directory, all of its properties are presented.</p><p>There are a pair of useful options which modify the
            dumpfile generator's behavior.  The first is the
            <code class="option">--incremental</code> option, which simply causes
            that first revision in the dumpfile stream to contain only
            the files and directories modified in that revision,
            instead of being presented as the addition of a new tree,
            and in exactly the same way that every other revision in
            the dumpfile is presented.  This is useful for generating
            a dumpfile that is to be loaded into another repository
            which already has the files and directories that exist in
            the original repository.</p><p>The second useful option is <code class="option">--deltas</code>.
            This switch causes <span class="command"><strong>svnadmin dump</strong></span> to,
            instead of emitting fulltext representations of file
            contents and property lists, emit only deltas of those
            items against their previous versions.  This reduces (in
            some cases, drastically) the size of the dumpfile that
            <span class="command"><strong>svnadmin dump</strong></span> creates.  There are, however,
            disadvantages to using this option—deltified
            dumpfiles are more CPU intensive to create, cannot be
            operated on by <span class="command"><strong>svndumpfilter</strong></span>, and tend
            not to compress as well as their non-deltified counterparts
            when using third-party tools like <span class="command"><strong>gzip</strong></span>
            and <span class="command"><strong>bzip2</strong></span>.</p></div><div class="refsect1" title="Switches"><a id="idp17365856"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--incremental
--quiet (-q)
--deltas
</pre></div><div class="refsect1" title="Examples"><a id="idp17367392"></a><h2>Examples</h2><p>Dump your whole repository:</p><pre class="screen">$ svnadmin dump /usr/local/svn/repos
SVN-fs-dump-format-version: 1
Revision-number: 0
* Dumped revision 0.
Prop-content-length: 56
Content-length: 56
…
</pre><p>Incrementally dump a single transaction from your
            repository:</p><pre class="screen">$ svnadmin dump /usr/local/svn/repos -r 21 --incremental
* Dumped revision 21.
SVN-fs-dump-format-version: 1
Revision-number: 21
Prop-content-length: 101
Content-length: 101
…
</pre></div></div><div class="refentry" title="svnadmin help"><div class="refentry.separator"><hr></div><a id="svn.ref.svnadmin.c.help"></a><div class="titlepage"></div><a id="idp17371584" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnadmin help — Help!</p></div><div class="refsect1" title="Synopsis"><a id="idp17374672"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin help [SUBCOMMAND...]</pre></div><div class="refsect1" title="Description"><a id="idp17376176"></a><h2>Description</h2><p>This subcommand is useful when you're trapped on a
            desert island with neither a net connection nor a copy of
            this book.</p></div><div class="refsect1" title="Alternate Names"><a id="idp17377520"></a><h2>Alternate Names</h2><p>?, h</p></div></div><div class="refentry" title="svnadmin hotcopy"><div class="refentry.separator"><hr></div><a id="svn.ref.svnadmin.c.hotcopy"></a><div class="titlepage"></div><a id="idp17379616" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnadmin hotcopy — Make a hot copy of a repository.</p></div><div class="refsect1" title="Synopsis"><a id="idp17382704"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin hotcopy REPOS_PATH NEW_REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17384224"></a><h2>Description</h2><p>This subcommand makes a full <span class="quote">«<span class="quote">hot</span>»</span> backup
            of your repository, including all hooks, configuration
            files, and, of course, database files.  If you pass the
            <code class="option">--clean-logs</code> switch,
            <span class="command"><strong>svnadmin</strong></span> will perform a hotcopy of your
            repository, and then remove unused Berkeley DB logs from
            the original repository.  You can run this command at any
            time and make a safe copy of the repository, regardless of
            whether other processes are using the repository.</p></div><div class="refsect1" title="Switches"><a id="idp17387472"></a><h2>Switches</h2><pre class="screen">--clean-logs
</pre></div></div><div class="refentry" title="svnadmin list-dblogs"><div class="refentry.separator"><hr></div><a id="svn.ref.svnadmin.c.list-dblogs"></a><div class="titlepage"></div><a id="idp17389792" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnadmin list-dblogs — Ask
          Berkeley DB which log files exist for a given Subversion
          repository (applies only to repositories using the
          <code class="literal">bdb</code> backend).</p></div><div class="refsect1" title="Synopsis"><a id="idp17393728"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin list-dblogs REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17395232"></a><h2>Description</h2><p>Berkeley DB creates logs of all changes to the
            repository, which allow it to recover in the face of
            catastrophe.  Unless you enable
            <code class="literal">DB_LOG_AUTOREMOVE</code>, the log files
            accumulate, although most are no longer used and can be
            deleted to reclaim disk space.  See <a class="xref" href="#svn.reposadmin.maint.diskspace" title="Managing Disk Space">«Managing Disk Space»</a> for more
            information.</p></div></div><div class="refentry" title="svnadmin list-unused-dblogs"><div class="refentry.separator"><hr></div><a id="svn.ref.svnadmin.c.list-unused-dblogs"></a><div class="titlepage"></div><a id="idp17399104" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnadmin list-unused-dblogs — Ask Berkeley DB which log files can be safely
          deleted (applies only to repositories using the
          <code class="literal">bdb</code> backend).</p></div><div class="refsect1" title="Synopsis"><a id="idp17402976"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin list-unused-dblogs REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17404480"></a><h2>Description</h2><p>Berkeley DB creates logs of all changes to the
            repository, which allow it to recover in the face of
            catastrophe.  Unless you enable
            <code class="literal">DB_LOG_AUTOREMOVE</code>, the log files
            accumulate, although most are no longer used and can be
            deleted to reclaim disk space.  See <a class="xref" href="#svn.reposadmin.maint.diskspace" title="Managing Disk Space">«Managing Disk Space»</a> for more
            information.</p></div><div class="refsect1" title="Examples"><a id="idp17407408"></a><h2>Examples</h2><p>Remove all unused log files from a repository:</p><pre class="screen">$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033

$ svnadmin list-unused-dblogs /path/to/repos | xargs rm
## disk space reclaimed!
</pre></div></div><div class="refentry" title="svnadmin load"><div class="refentry.separator"><hr></div><a id="svn.ref.svnadmin.c.load"></a><div class="titlepage"></div><a id="idp17410448" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnadmin load — Read a
            <span class="quote">«<span class="quote">dumpfile</span>»</span>-formatted stream from
            stdin.</p></div><div class="refsect1" title="Synopsis"><a id="idp17414016"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin load REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17415520"></a><h2>Description</h2><p>Read a <span class="quote">«<span class="quote">dumpfile</span>»</span>-formatted stream from
            stdin, committing new revisions into the repository's
            filesystem.  Send progress feedback to stdout.</p></div><div class="refsect1" title="Switches"><a id="idp17417312"></a><h2>Switches</h2><pre class="screen">--quiet (-q)
--ignore-uuid
--force-uuid
--use-pre-commit-hook
--use-post-commit-hook
--parent-dir
</pre></div><div class="refsect1" title="Example"><a id="idp17418880"></a><h2>Example</h2><p>This shows the beginning of loading a repository from
            a backup file (made, of course, with <span class="command"><strong>svnadmin
            dump</strong></span>):</p><pre class="screen">$ svnadmin load /usr/local/svn/restored &lt; repos-backup
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : test ... done.
     * adding path : test/a ... done.
…
</pre><p>Or if you want to load into a subdirectory:</p><pre class="screen">$ svnadmin load --parent-dir new/subdir/for/project /usr/local/svn/restored &lt; repos-backup
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : test ... done.
     * adding path : test/a ... done.
…
</pre></div></div><div class="refentry" title="svnadmin lslocks"><div class="refentry.separator"><hr></div><a id="svn.ref.svnadmin.c.lslocks"></a><div class="titlepage"></div><a id="idp17424032" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnadmin lslocks — Print descriptions of all locks.</p></div><div class="refsect1" title="Synopsis"><a id="idp17427056"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin lslocks REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17428560"></a><h2>Description</h2><p>Print descriptions of all locks in a repository.</p></div><div class="refsect1" title="Switches"><a id="idp17429808"></a><h2>Switches</h2><p>None</p></div><div class="refsect1" title="Example"><a id="idp17431024"></a><h2>Example</h2><p>This lists the one locked file in the repository at
            <code class="filename">/svn/repos</code></p><pre class="screen">$ svnadmin lslocks /svn/repos
Path: /tree.jpg
UUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753
Owner: harry
Created: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)
Expires: 
Comment (1 line):
Rework the uppermost branches on the bald cypress in the foreground.
</pre></div></div><div class="refentry" title="svnadmin lstxns"><div class="refentry.separator"><hr></div><a id="svn.ref.svnadmin.c.lstxns"></a><div class="titlepage"></div><a id="idp17434624" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnadmin lstxns — Print the names of all uncommitted transactions.</p></div><div class="refsect1" title="Synopsis"><a id="idp17437776"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin lstxns REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17439232"></a><h2>Description</h2><p>Print the names of all uncommitted transactions.  See
            <a class="xref" href="#svn.reposadmin.maint.cleanup" title="Repository Cleanup">«Repository Cleanup»</a> for information on how
            uncommitted transactions are created and what you should
            do with them.</p></div><div class="refsect1" title="Examples"><a id="idp17441472"></a><h2>Examples</h2><p>List all outstanding transactions in a
            repository.</p><pre class="screen">$ svnadmin lstxns /usr/local/svn/repos/
1w
1x
</pre></div></div><div class="refentry" title="svnadmin recover"><div class="refentry.separator"><hr></div><a id="svn.ref.svnadmin.c.recover"></a><div class="titlepage"></div><a id="idp17444352" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnadmin recover — Bring a repository database back into a
          consistent state (applies only to repositories using the
          <code class="literal">bdb</code> backend).  In addition, if
          <code class="filename">repos/conf/passwd</code> does not exist, it
          will create a default password file .</p></div><div class="refsect1" title="Synopsis"><a id="idp17448992"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin recover REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17450496"></a><h2>Description</h2><p>Run this command if you get an error indicating that
            your repository needs to be recovered.</p></div><div class="refsect1" title="Switches"><a id="idp17451792"></a><h2>Switches</h2><pre class="screen">--wait
</pre></div><div class="refsect1" title="Examples"><a id="idp17453280"></a><h2>Examples</h2><p>Recover a hung repository:</p><pre class="screen">$ svnadmin recover /usr/local/svn/repos/
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 34.
</pre><p>Recovering the database requires an exclusive lock on
            the repository. (This is a <span class="quote">«<span class="quote">database lock</span>»</span>;
            see <a class="xref" href="#svn.advanced.locking.meanings" title="Three meanings of «lock»">Three meanings of <span class="quote">«<span class="quote">lock</span>»</span></a>.)
            If another process is accessing the repository,
            then <span class="command"><strong>svnadmin recover</strong></span> will error:</p><pre class="screen">$ svnadmin recover /usr/local/svn/repos
svn: Failed to get exclusive repository access; perhaps another process
such as httpd, svnserve or svn has it open?

$
</pre><p>The <code class="option">--wait</code> option, however, will
            cause <span class="command"><strong>svnadmin recover</strong></span> to wait
            indefinitely for other processes to disconnect:</p><pre class="screen">$ svnadmin recover /usr/local/svn/repos --wait
Waiting on repository lock; perhaps another process has it open?

### time goes by…

Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 34.
</pre></div></div><div class="refentry" title="svnadmin rmlocks"><div class="refentry.separator"><hr></div><a id="svn.ref.svnadmin.c.rmlocks"></a><div class="titlepage"></div><a id="idp17462224" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnadmin rmlocks — Unconditionally remove one or more locks from a
          repository.</p></div><div class="refsect1" title="Synopsis"><a id="idp17465360"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin rmlocks REPOS_PATH LOCKED_PATH...</pre></div><div class="refsect1" title="Description"><a id="idp17466880"></a><h2>Description</h2><p>Remove lock from each <em class="replaceable"><code>LOCKED_PATH</code></em>.</p></div><div class="refsect1" title="Switches"><a id="idp17468512"></a><h2>Switches</h2><p>None</p></div><div class="refsect1" title="Example"><a id="idp17469728"></a><h2>Example</h2><p>This deletes the locks on
            <code class="filename">tree.jpg</code> and
            <code class="filename">house.jpg</code> in the repository at
            <code class="filename">/svn/repos</code></p><pre class="screen">$ svnadmin rmlocks /svn/repos tree.jpg house.jpg
Removed lock on '/tree.jpg.
Removed lock on '/house.jpg.
</pre></div></div><div class="refentry" title="svnadmin rmtxns"><div class="refentry.separator"><hr></div><a id="svn.ref.svnadmin.c.rmtxns"></a><div class="titlepage"></div><a id="idp17474656" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnadmin rmtxns — Delete transactions from a repository.</p></div><div class="refsect1" title="Synopsis"><a id="idp17477824"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin rmtxns REPOS_PATH TXN_NAME...</pre></div><div class="refsect1" title="Description"><a id="idp17479296"></a><h2>Description</h2><p>Delete outstanding transactions from a repository.
            This is covered in detail in <a class="xref" href="#svn.reposadmin.maint.cleanup" title="Repository Cleanup">«Repository Cleanup»</a>.</p></div><div class="refsect1" title="Switches"><a id="idp17481312"></a><h2>Switches</h2><pre class="screen">--quiet (-q)
</pre></div><div class="refsect1" title="Examples"><a id="idp17482800"></a><h2>Examples</h2><p>Remove named transactions:</p><pre class="screen">$ svnadmin rmtxns /usr/local/svn/repos/ 1w 1x
</pre><p>Fortunately, the output of <span class="command"><strong>lstxns</strong></span>
            works great as the input for <span class="command"><strong>rmtxns</strong></span>:</p><pre class="screen">$ svnadmin rmtxns /usr/local/svn/repos/  `svnadmin lstxns /usr/local/svn/repos/`
</pre><p>Which will remove all uncommitted transactions from
            your repository.</p></div></div><div class="refentry" title="svnadmin setlog"><div class="refentry.separator"><hr></div><a id="svn.ref.svnadmin.c.setlog"></a><div class="titlepage"></div><a id="idp17488688" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnadmin setlog — Set the log-message on a revision.</p></div><div class="refsect1" title="Synopsis"><a id="idp17491776"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin setlog REPOS_PATH -r REVISION FILE</pre></div><div class="refsect1" title="Description"><a id="idp17493296"></a><h2>Description</h2><p>Set the log-message on revision REVISION to the
            contents of FILE.</p><p>This is similar to using <span class="command"><strong>svn propset
            --revprop</strong></span> to set the <code class="literal">svn:log</code> property
            on a revision, except that you can also use the option
            <code class="option">--bypass-hooks</code> to avoid running any pre- or
            post-commit hooks, which is useful if the modification of
            revision properties has not been enabled in the pre-revprop-change
            hook.</p><div class="warning" title="Предупреждение" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Предупреждение]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/warning.png"></td><th align="left">Предупреждение</th></tr><tr><td valign="top" align="left"><p>Revision properties are not under version control,
              so this command will permanently overwrite the previous
              log message.</p></td></tr></tbody></table></div></div><div class="refsect1" title="Switches"><a id="idp17498096"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--bypass-hooks
</pre></div><div class="refsect1" title="Examples"><a id="idp17499600"></a><h2>Examples</h2><p>Set the log message for revision 19 to the contents of
            the file <code class="filename">msg</code>:</p><pre class="screen">$ svnadmin setlog /usr/local/svn/repos/ -r 19 msg
</pre></div></div><div class="refentry" title="svnadmin verify"><div class="refentry.separator"><hr></div><a id="svn.ref.svnadmin.c.verify"></a><div class="titlepage"></div><a id="idp17503152" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnadmin verify — Verify the data stored in the repository.</p></div><div class="refsect1" title="Synopsis"><a id="idp17506304"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin verify REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17507760"></a><h2>Description</h2><p>Run this command if you wish to verify the integrity
            of your repository.  This basically iterates through all
            revisions in the repository by internally dumping all
            revisions and discarding the output.</p></div><div class="refsect1" title="Examples"><a id="idp17509200"></a><h2>Examples</h2><p>Verify a hung repository:</p><pre class="screen">$ svnadmin verify /usr/local/svn/repos/
* Verified revision 1729.
</pre></div></div></div></div><div class="sect1" title="svnlook"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.ref.svnlook"></a><span class="command"><strong>svnlook</strong></span></h2></div></div></div><p><span class="command"><strong>svnlook</strong></span> is a command-line utility for
      examining different aspects of a Subversion repository.  It
      does not make any changes to the repository—it's just
      used for <span class="quote">«<span class="quote">peeking</span>»</span>.
      <span class="command"><strong>svnlook</strong></span> is typically used by the
      repository hooks, but a repository administrator might find it
      useful for diagnostic purposes.</p><p>Since <span class="command"><strong>svnlook</strong></span> works via direct repository access
      (and thus can only be used on the machine that holds the
      repository), it refers to the repository with a path, not a URL.</p><p>If no revision or transaction is specified,
      <span class="command"><strong>svnlook</strong></span> defaults to the youngest (most
      recent) revision of the repository.</p><div class="sect2" title="svnlook Switches"><div class="titlepage"><div><div><h3 class="title"><a id="svn.ref.svnlook.sw"></a><span class="command"><strong>svnlook</strong></span> Switches</h3></div></div></div><p>Switches in <span class="command"><strong>svnlook</strong></span> are global, just
        like in <span class="command"><strong>svn</strong></span> and
        <span class="command"><strong>svnadmin</strong></span>; however, most switches only
        apply to one subcommand since the functionality of
        <span class="command"><strong>svnlook</strong></span> is (intentionally) limited in
        scope.</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--no-diff-deleted</code></span></dt><dd><p>Prevents <span class="command"><strong>svnlook</strong></span> from printing
              differences for deleted files.  The default behavior
              when a file is deleted in a transaction/revision is
              to print the same differences that you would see if
              you had left the file but removed all the content.</p></dd><dt><span class="term"><code class="option">--revision</code>
            (<code class="option">-r</code>)</span></dt><dd><p>Specify a particular revision number that you wish
              to examine.</p></dd><dt><span class="term"><code class="option">--revprop</code></span></dt><dd><p>Operates on a revision property instead of a
              Subversion property specific to a file or directory.
              This switch requires that you also pass a revision
              with the <code class="option">--revision</code>
              (<code class="option">-r</code>) switch.  See <a class="xref" href="#svn.reposadmin.basics.revprops" title="Unversioned Properties">«Unversioned Properties»</a> for more details on
              unversioned properties.</p></dd><dt><span class="term"><code class="option">--transaction</code>
            (<code class="option">-t</code>)</span></dt><dd><p>Specify a particular transaction ID that you wish to
              examine.</p></dd><dt><span class="term"><code class="option">--show-ids</code></span></dt><dd><p>Show the filesystem node revision IDs for each path in the filesystem
              tree.</p></dd></dl></div></div><div class="sect2" title="svnlook"><div class="titlepage"><div><div><h3 class="title"><a id="svn.ref.svnlook.c"></a><span class="command"><strong>svnlook</strong></span></h3></div></div></div><div class="refentry" title="svnlook author"><a id="svn.ref.svnlook.c.author"></a><div class="titlepage"></div><a id="idp17540496" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook author — Print the author.</p></div><div class="refsect1" title="Synopsis"><a id="idp17543616"></a><h2>Synopsis</h2><pre class="programlisting">svnlook author REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17545072"></a><h2>Description</h2><p>Print the author of a revision or transaction in
            the repository.</p></div><div class="refsect1" title="Switches"><a id="idp17546352"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--transaction (-t)
</pre></div><div class="refsect1" title="Examples"><a id="idp17547872"></a><h2>Examples</h2><p><span class="command"><strong>svnlook author</strong></span> is handy, but not
          very exciting:</p><pre class="screen">$ svnlook author -r 40 /usr/local/svn/repos
sally
</pre></div></div><div class="refentry" title="svnlook cat"><div class="refentry.separator"><hr></div><a id="svn.ref.svnlook.c.cat"></a><div class="titlepage"></div><a id="idp17551296" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook cat — Print the contents of a file.</p></div><div class="refsect1" title="Synopsis"><a id="idp17554368"></a><h2>Synopsis</h2><pre class="programlisting">svnlook cat REPOS_PATH PATH_IN_REPOS</pre></div><div class="refsect1" title="Description"><a id="idp17555872"></a><h2>Description</h2><p>Print the contents of a file.</p></div><div class="refsect1" title="Switches"><a id="idp17557104"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--transaction (-t)
</pre></div><div class="refsect1" title="Examples"><a id="idp17558624"></a><h2>Examples</h2><p>This shows the contents of a file in transaction
            <code class="literal">ax8</code>, located at
            <code class="filename">/trunk/README</code>:</p><pre class="screen">$ svnlook cat -t ax8 /usr/local/svn/repos /trunk/README

               Subversion, a version control system.
               =====================================

$LastChangedDate: 2003-07-17 10:45:25 -0500 (Thu, 17 Jul 2003) $

Contents:

     I. A FEW POINTERS
    II. DOCUMENTATION
   III. PARTICIPATING IN THE SUBVERSION COMMUNITY
…
</pre></div></div><div class="refentry" title="svnlook changed"><div class="refentry.separator"><hr></div><a id="svn.ref.svnlook.c.changed"></a><div class="titlepage"></div><a id="idp17563184" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook changed — Print the paths that were changed.</p></div><div class="refsect1" title="Synopsis"><a id="idp17566240"></a><h2>Synopsis</h2><pre class="programlisting">svnlook changed REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17567744"></a><h2>Description</h2><p>Print the paths that were changed in a particular
            revision or transaction, as well as <span class="quote">«<span class="quote">svn
            update-style</span>»</span> status letters in the first two
            columns:</p><div class="variablelist"><dl><dt><span class="term">'<code class="literal">A </code>'</span></dt><dd><p>Item added to repository.</p></dd><dt><span class="term">'<code class="literal">D </code>'</span></dt><dd><p>Item deleted from repository.</p></dd><dt><span class="term">'<code class="literal">U </code>'</span></dt><dd><p>File contents changed.</p></dd><dt><span class="term">'<code class="literal">_U</code>'</span></dt><dd><p>Properties of item changed.</p></dd><dt><span class="term">'<code class="literal">UU</code>'</span></dt><dd><p>File contents and properties changed.</p></dd></dl></div><p>Files and directories can be distinguished, as directory
            paths are displayed with a trailing '<code class="literal">/</code>'
            character.</p></div><div class="refsect1" title="Switches"><a id="idp17582416"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--transaction (-t)
</pre></div><div class="refsect1" title="Examples"><a id="idp17583936"></a><h2>Examples</h2><p>This shows a list of all the changed files in
            revision 39 of a test repository:</p><pre class="screen">$ svnlook changed -r 39 /usr/local/svn/repos
A   trunk/vendors/deli/
A   trunk/vendors/deli/chips.txt
A   trunk/vendors/deli/sandwich.txt
A   trunk/vendors/deli/pickle.txt
U   trunk/vendors/baker/bagel.txt
_U  trunk/vendors/baker/croissant.txt
UU  trunk/vendors/baker/pretzel.txt
D   trunk/vendors/baker/baguette.txt
</pre></div></div><div class="refentry" title="svnlook date"><div class="refentry.separator"><hr></div><a id="svn.ref.svnlook.c.date"></a><div class="titlepage"></div><a id="idp17587056" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook date — Print the datestamp.</p></div><div class="refsect1" title="Synopsis"><a id="idp17590144"></a><h2>Synopsis</h2><pre class="programlisting">svnlook date REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17591632"></a><h2>Description</h2><p>Print the datestamp of a revision or transaction in
            a repository.</p></div><div class="refsect1" title="Switches"><a id="idp17592912"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--transaction (-t)
</pre></div><div class="refsect1" title="Examples"><a id="idp17594432"></a><h2>Examples</h2><p>This shows the date of revision 40 of a test
            repository:</p><pre class="screen">$ svnlook date -r 40 /tmp/repos/
2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)
</pre></div></div><div class="refentry" title="svnlook diff"><div class="refentry.separator"><hr></div><a id="svn.ref.svnlook.c.diff"></a><div class="titlepage"></div><a id="idp17597344" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook diff — Print differences of changed files and properties.</p></div><div class="refsect1" title="Synopsis"><a id="idp17600464"></a><h2>Synopsis</h2><pre class="programlisting">svnlook diff REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17601952"></a><h2>Description</h2><p>Print GNU-style differences of changed files and
            properties in a repository.</p></div><div class="refsect1" title="Switches"><a id="idp17603248"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--transaction (-t)
--no-diff-added
--no-diff-deleted
</pre></div><div class="refsect1" title="Examples"><a id="idp17604800"></a><h2>Examples</h2><p>This shows a newly added (empty) file, a deleted
            file, and a copied file:</p><pre class="screen">$ svnlook diff -r 40 /usr/local/svn/repos/
Copied: egg.txt (from rev 39, trunk/vendors/deli/pickle.txt)

Added: trunk/vendors/deli/soda.txt
==============================================================================

Modified: trunk/vendors/deli/sandwich.txt
==============================================================================
--- trunk/vendors/deli/sandwich.txt (original)
+++ trunk/vendors/deli/sandwich.txt 2003-02-22 17:45:04.000000000 -0600
@@ -0,0 +1 @@
+Don't forget the mayo!

Modified: trunk/vendors/deli/logo.jpg
==============================================================================
(Binary files differ)

Deleted: trunk/vendors/deli/chips.txt
==============================================================================

Deleted: trunk/vendors/deli/pickle.txt
==============================================================================
</pre><p>If a file has a non-textual
            <code class="literal">svn:mime-type</code> property, then the
            differences are not explicitly shown.</p></div></div><div class="refentry" title="svnlook dirs-changed"><div class="refentry.separator"><hr></div><a id="svn.ref.svnlook.c.dirs-changed"></a><div class="titlepage"></div><a id="idp17609792" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook dirs-changed — Print the directories that were themselves changed.</p></div><div class="refsect1" title="Synopsis"><a id="idp17612944"></a><h2>Synopsis</h2><pre class="programlisting">svnlook dirs-changed REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17614400"></a><h2>Description</h2><p>Print the directories that were themselves changed
            (property edits) or whose file children were
            changed.</p></div><div class="refsect1" title="Switches"><a id="idp17615728"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--transaction (-t)
</pre></div><div class="refsect1" title="Examples"><a id="idp17617248"></a><h2>Examples</h2><p>This shows the directories that changed in
            revision 40 in our sample repository:</p><pre class="screen">$ svnlook dirs-changed -r 40 /usr/local/svn/repos
trunk/vendors/deli/
</pre></div></div><div class="refentry" title="svnlook help"><div class="refentry.separator"><hr></div><a id="svn.ref.svnlook.c.help"></a><div class="titlepage"></div><a id="idp17620128" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook help — Help!</p></div><div class="refsect1" title="Synopsis"><a id="idp17623216"></a><h2>Synopsis</h2><pre class="programlisting">Also svnlook -h and svnlook -?.</pre></div><div class="refsect1" title="Description"><a id="idp17624720"></a><h2>Description</h2><p>Displays the help message for svnlook.  This
            command, like its brother <span class="command"><strong>svn help</strong></span>, is
            also your friend, even though you never call it anymore
            and forgot to invite it to your last party.</p></div><div class="refsect1" title="Alternate Names"><a id="idp17626832"></a><h2>Alternate Names</h2><p>?, h</p></div></div><div class="refentry" title="svnlook history"><div class="refentry.separator"><hr></div><a id="svn.ref.svnlook.c.history"></a><div class="titlepage"></div><a id="idp17628992" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook history — Print information about the history of a path in
            the repository (or the root directory if no path is
            supplied).</p></div><div class="refsect1" title="Synopsis"><a id="idp17632224"></a><h2>Synopsis</h2><pre class="programlisting">svnlook history REPOS_PATH [PATH_IN_REPOS]</pre></div><div class="refsect1" title="Description"><a id="idp17633744"></a><h2>Description</h2><p>Print information about the history of a path in
            the repository (or the root directory if no path is
            supplied).</p></div><div class="refsect1" title="Switches"><a id="idp17635072"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--show-ids
</pre></div><div class="refsect1" title="Examples"><a id="idp17636528"></a><h2>Examples</h2><p>This shows the history output for the path
            <code class="filename">/tags/1.0</code> as of revision 20 in our
            sample repository.</p><pre class="screen">$ svnlook history -r 20 /usr/local/svn/repos /tags/1.0 --show-ids
REVISION   PATH &lt;ID&gt;
--------   ---------
      19   /tags/1.0 &lt;1.2.12&gt;
      17   /branches/1.0-rc2 &lt;1.1.10&gt;
      16   /branches/1.0-rc2 &lt;1.1.x&gt;
      14   /trunk &lt;1.0.q&gt;
      13   /trunk &lt;1.0.o&gt;
      11   /trunk &lt;1.0.k&gt;
       9   /trunk &lt;1.0.g&gt;
       8   /trunk &lt;1.0.e&gt;
       7   /trunk &lt;1.0.b&gt;
       6   /trunk &lt;1.0.9&gt;
       5   /trunk &lt;1.0.7&gt;
       4   /trunk &lt;1.0.6&gt;
       2   /trunk &lt;1.0.3&gt;
       1   /trunk &lt;1.0.2&gt;
</pre></div></div><div class="refentry" title="svnlook info"><div class="refentry.separator"><hr></div><a id="svn.ref.svnlook.c.info"></a><div class="titlepage"></div><a id="idp17640848" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook info — Print the author, datestamp, log message size,
            and log message.</p></div><div class="refsect1" title="Synopsis"><a id="idp17644000"></a><h2>Synopsis</h2><pre class="programlisting">svnlook info REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17645488"></a><h2>Description</h2><p>Print the author, datestamp, log message size, and
            log message.</p></div><div class="refsect1" title="Switches"><a id="idp17646768"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--transaction (-t)
</pre></div><div class="refsect1" title="Examples"><a id="idp17648288"></a><h2>Examples</h2><p>This shows the info output for revision 40 in our
            sample repository.</p><pre class="screen">$ svnlook info -r 40 /usr/local/svn/repos
sally
2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)
15
Rearrange lunch.
</pre></div></div><div class="refentry" title="svnlook lock"><div class="refentry.separator"><hr></div><a id="svn.ref.svnlook.c.lock"></a><div class="titlepage"></div><a id="idp17651136" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook lock — If a lock exists on a path in the repository,
            describe it.</p></div><div class="refsect1" title="Synopsis"><a id="idp17654272"></a><h2>Synopsis</h2><pre class="programlisting">svnlook lock REPOS_PATH PATH_IN_REPOS</pre></div><div class="refsect1" title="Description"><a id="idp17655776"></a><h2>Description</h2><p>Print all information available for the lock at
              <em class="replaceable"><code>PATH_IN_REPOS</code></em>.  If
              <em class="replaceable"><code>PATH_IN_REPOS</code></em> is not locked,
              print nothing.</p></div><div class="refsect1" title="Switches"><a id="idp17657968"></a><h2>Switches</h2><p>None</p></div><div class="refsect1" title="Examples"><a id="idp17659232"></a><h2>Examples</h2><p>This describes the lock on the file
            <code class="filename">tree.jpg</code>.</p><pre class="screen">$ svnlook lock /svn/repos tree.jpg
UUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753
Owner: harry
Created: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)
Expires: 
Comment (1 line):
Rework the uppermost branches on the bald cypress in the foreground.
</pre></div></div><div class="refentry" title="svnlook log"><div class="refentry.separator"><hr></div><a id="svn.ref.svnlook.c.log"></a><div class="titlepage"></div><a id="idp17662944" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook log — Print the log message.</p></div><div class="refsect1" title="Synopsis"><a id="idp17666000"></a><h2>Synopsis</h2><pre class="programlisting">svnlook log REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17667488"></a><h2>Description</h2><p>Print the log message.</p></div><div class="refsect1" title="Switches"><a id="idp17668704"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--transaction (-t)
</pre></div><div class="refsect1" title="Examples"><a id="idp17670224"></a><h2>Examples</h2><p>This shows the log output for revision 40 in our sample
            repository:</p><pre class="screen">$ svnlook log /tmp/repos/
Rearrange lunch.
</pre></div></div><div class="refentry" title="svnlook propget"><div class="refentry.separator"><hr></div><a id="svn.ref.svnlook.c.propget"></a><div class="titlepage"></div><a id="idp17673168" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook propget — Print the raw value of a property on a path in
            the repository.</p></div><div class="refsect1" title="Synopsis"><a id="idp17676352"></a><h2>Synopsis</h2><pre class="programlisting">svnlook propget REPOS_PATH PROPNAME [PATH_IN_REPOS]</pre></div><div class="refsect1" title="Description"><a id="idp17677872"></a><h2>Description</h2><p>List the value of a property on a path in the
            repository.</p></div><div class="refsect1" title="Alternate Names"><a id="idp17679136"></a><h2>Alternate Names</h2><p>pg, pget</p></div><div class="refsect1" title="Switches"><a id="idp17680352"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--transaction (-t)
--revprop
</pre></div><div class="refsect1" title="Examples"><a id="idp17681872"></a><h2>Examples</h2><p>This shows the value of the <span class="quote">«<span class="quote">seasonings</span>»</span> property
            on the file <code class="filename">/trunk/sandwich</code> in the
            <code class="literal">HEAD</code> revision:</p><pre class="screen">$ svnlook pg /usr/local/svn/repos seasonings /trunk/sandwich
mustard
</pre></div></div><div class="refentry" title="svnlook proplist"><div class="refentry.separator"><hr></div><a id="svn.ref.svnlook.c.proplist"></a><div class="titlepage"></div><a id="idp17686640" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook proplist — Print the names and values of versioned file and
            directory properties.</p></div><div class="refsect1" title="Synopsis"><a id="idp17689824"></a><h2>Synopsis</h2><pre class="programlisting">svnlook proplist REPOS_PATH [PATH_IN_REPOS]</pre></div><div class="refsect1" title="Description"><a id="idp17691344"></a><h2>Description</h2><p>List the properties of a path in the repository.  With
            <code class="option">--verbose</code>, show the property values too.</p></div><div class="refsect1" title="Alternate Names"><a id="idp17693024"></a><h2>Alternate Names</h2><p>pl, plist</p></div><div class="refsect1" title="Switches"><a id="idp17694240"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--transaction (-t)
--verbose (-v)
--revprop
</pre></div><div class="refsect1" title="Examples"><a id="idp17695776"></a><h2>Examples</h2><p>This shows the names of properties set on the file
            <code class="filename">/trunk/README</code> in the
            <code class="literal">HEAD</code> revision:</p><pre class="screen">$ svnlook proplist /usr/local/svn/repos /trunk/README
  original-author
  svn:mime-type
</pre><p>This is the same command as in the previous example,
            but this time showing the property values as well:</p><pre class="screen">$ svnlook --verbose proplist /usr/local/svn/repos /trunk/README
  original-author : fitz
  svn:mime-type : text/plain
</pre></div></div><div class="refentry" title="svnlook tree"><div class="refentry.separator"><hr></div><a id="svn.ref.svnlook.c.tree"></a><div class="titlepage"></div><a id="idp17701392" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook tree — Print the tree.</p></div><div class="refsect1" title="Synopsis"><a id="idp17704480"></a><h2>Synopsis</h2><pre class="programlisting">svnlook tree REPOS_PATH [PATH_IN_REPOS]</pre></div><div class="refsect1" title="Description"><a id="idp17705984"></a><h2>Description</h2><p>Print the tree, starting at
            <em class="replaceable"><code>PATH_IN_REPOS</code></em> (if supplied, at
            the root of the tree otherwise), optionally showing node
            revision IDs.</p></div><div class="refsect1" title="Switches"><a id="idp17707776"></a><h2>Switches</h2><pre class="screen">--revision (-r) REV
--transaction (-t)
--show-ids
</pre></div><div class="refsect1" title="Examples"><a id="idp17709296"></a><h2>Examples</h2><p>This shows the tree output (with node-IDs) for revision
            40 in our sample repository:</p><pre class="screen">$ svnlook tree -r 40 /usr/local/svn/repos --show-ids
/ &lt;0.0.2j&gt;
 trunk/ &lt;p.0.2j&gt;
  vendors/ &lt;q.0.2j&gt;
   deli/ &lt;1g.0.2j&gt;
    egg.txt &lt;1i.e.2j&gt;
    soda.txt &lt;1k.0.2j&gt;
    sandwich.txt &lt;1j.0.2j&gt;
</pre></div></div><div class="refentry" title="svnlook uuid"><div class="refentry.separator"><hr></div><a id="svn.ref.svnlook.c.uuid"></a><div class="titlepage"></div><a id="idp17712336" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook uuid — Print the repository's
          <code class="literal">UUID</code>.</p></div><div class="refsect1" title="Synopsis"><a id="idp17716128"></a><h2>Synopsis</h2><pre class="programlisting">svnlook uuid REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17717616"></a><h2>Description</h2><p>Print the <code class="literal">UUID</code> for the repository.
            the UUID is the repository's
            <span class="emphasis"><em>u</em></span>niversal <span class="emphasis"><em>u</em></span>nique
            <span class="emphasis"><em>id</em></span>entifier.  The Subversion client
            uses this identifier to differentiate between one
            repository and another.</p></div><div class="refsect1" title="Examples"><a id="idp17721024"></a><h2>Examples</h2><pre class="screen">$ svnlook uuid /usr/local/svn/repos
e7fe1b91-8cd5-0310-98dd-2f12e793c5e8
</pre></div></div><div class="refentry" title="svnlook youngest"><div class="refentry.separator"><hr></div><a id="svn.ref.svnlook.c.youngest"></a><div class="titlepage"></div><a id="idp17723456" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnlook youngest — Print the youngest revision number.</p></div><div class="refsect1" title="Synopsis"><a id="idp17726544"></a><h2>Synopsis</h2><pre class="programlisting">svnlook youngest REPOS_PATH</pre></div><div class="refsect1" title="Description"><a id="idp17728048"></a><h2>Description</h2><p>Print the youngest revision number of a repository.</p></div><div class="refsect1" title="Examples"><a id="idp17729296"></a><h2>Examples</h2><p>This shows the youngest revision of our sample
          repository:</p><pre class="screen">$ svnlook youngest /tmp/repos/
42
</pre></div></div></div></div><div class="sect1" title="svnserve"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.ref.svnserve"></a><span class="command"><strong>svnserve</strong></span></h2></div></div></div><p><span class="command"><strong>svnserve</strong></span> allows access to Subversion
      repositories using the <code class="literal">svn</code> network protocol.
      You can run svnserve either as a standalone server process, or
      you can have another process, such as <span class="command"><strong>inetd</strong></span>,
      <span class="command"><strong>xinetd</strong></span> or <span class="command"><strong>sshd</strong></span>, launch it
      for you.</p><p>Once the client has selected a repository by transmitting
      its URL, <span class="command"><strong>svnserve</strong></span> reads a file named
      <code class="filename">conf/svnserve.conf</code> in the repository
      directory to determine repository-specific settings such as what
      authentication database to use and what authorization policies
      to apply.  See <a class="xref" href="#svn.serverconfig.svnserve" title="Собственный сервер svnserve">«Собственный сервер svnserve»</a> for details of
      the <code class="filename">svnserve.conf</code> file.</p><div class="sect2" title="svnserve Switches"><div class="titlepage"><div><div><h3 class="title"><a id="svn.ref.svnserve.sw"></a><span class="command"><strong>svnserve</strong></span> Switches</h3></div></div></div><p>Unlike the previous commands we've
        described. <span class="command"><strong>svnserve</strong></span> has no
        subcommands—<span class="command"><strong>svnserve</strong></span> is controlled
        exclusively by switches.</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--daemon</code> (<code class="option">-d</code>)</span></dt><dd><p>Causes <span class="command"><strong>svnserve</strong></span> to run in daemon
              mode.  <span class="command"><strong>svnserve</strong></span> backgrounds itself
              and accepts and serves TCP/IP connections on the svn
              port (3690, by default).</p></dd><dt><span class="term"><code class="option">--listen-port</code>=<em class="replaceable"><code>PORT</code></em></span></dt><dd><p>Causes svnserve to listen on
              <em class="replaceable"><code>PORT</code></em> when run in daemon
              mode.</p></dd><dt><span class="term"><code class="option">--listen-host</code>=<em class="replaceable"><code>HOST</code></em></span></dt><dd><p>Causes <span class="command"><strong>svnserve</strong></span> to listen on the
              interface specified by <em class="replaceable"><code>HOST</code></em>,
              which may be either a hostname or an IP address.</p></dd><dt><span class="term"><code class="option">--foreground</code></span></dt><dd><p>When used together with <code class="option">-d</code>, this
              switch causes <span class="command"><strong>svnserve</strong></span> to stay in the
              foreground.  This switch is mainly useful for
              debugging.</p></dd><dt><span class="term"><code class="option">--inetd</code> (<code class="option">-i</code>)</span></dt><dd><p>Causes <span class="command"><strong>svnserve</strong></span> to use the
              stdin/stdout file descriptors, as is appropriate for a
              daemon running out of <span class="command"><strong>inetd</strong></span>.</p></dd><dt><span class="term"><code class="option">--help</code> (<code class="option">-h</code>)</span></dt><dd><p>Displays a usage summary and exits.</p></dd><dt><span class="term"><code class="option">--version</code></span></dt><dd><p>Displays version information, a list of repository
            back-end modules available, and exits.</p></dd><dt><span class="term"><code class="option">--root</code>=<em class="replaceable"><code>ROOT</code></em>
          (<code class="option">-r</code>=<em class="replaceable"><code>ROOT</code></em>)</span></dt><dd><p>Sets the virtual root for repositories served by
              <span class="command"><strong>svnserve</strong></span>.  The pathname in URLs
              provided by the client will be interpreted relative to
              this root, and will not be allowed to escape this
              root.</p></dd><dt><span class="term"><code class="option">--tunnel</code> (<code class="option">-t</code>)</span></dt><dd><p>Causes <span class="command"><strong>svnserve</strong></span> to run in tunnel
              mode, which is just like the <span class="command"><strong>inetd</strong></span>
              mode of operation (serve one connection over
              stdin/stdout) except that the connection is considered
              to be pre-authenticated with the username of the current
              uid.  This flag is selected by the client when running
              over a tunnel agent such as
              <span class="command"><strong>ssh</strong></span>.</p></dd><dt><span class="term"><code class="option">--tunnel-user NAME</code></span></dt><dd><p>Used in conjunction with <code class="option">--tunnel</code>
              switch; tells svnserve to assume that
              <em class="replaceable"><code>NAME</code></em> is the authenticated
              user, rather than the UID of the svnserve
              process.  Useful for users wishing to share a single
              system account over SSH, but maintaining separate commit
              identities.</p></dd><dt><span class="term"><code class="option">--threads</code> (<code class="option">-T</code>)</span></dt><dd><p>When running in daemon mode, causes
              <span class="command"><strong>svnserve</strong></span> to spawn a thread instead of
              a process for each connection.  The
              <span class="command"><strong>svnserve</strong></span> process still backgrounds
              itself at startup time.</p></dd><dt><span class="term"><code class="option">--listen-once</code> (<code class="option">-X</code>)</span></dt><dd><p>Causes <span class="command"><strong>svnserve</strong></span> to accept one
              connection on the svn port, serve it, and exit.  This
              option is mainly useful for debugging.</p></dd></dl></div></div></div><div class="sect1" title="svnversion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.ref.svnversion"></a><span class="command"><strong>svnversion</strong></span></h2></div></div></div><div class="refentry" title="svnversion"><a id="svn.ref.svnversion.re"></a><div class="titlepage"></div><a id="idp17789056" class="indexterm"></a><div class="refnamediv"><h2>Имя</h2><p>svnversion — Summarize the local revision(s) of a working
                    copy.</p></div><div class="refsect1" title="Synopsis"><a id="svn.ref.svnversion.re.syn"></a><h2>Synopsis</h2><pre class="programlisting">svnversion [OPTIONS] [WC_PATH [TRAIL_URL]]</pre></div><div class="refsect1" title="Description"><a id="svn.ref.svnversion.re.desc"></a><h2>Description</h2><p><span class="command"><strong>svnversion</strong></span> is a program for
          summarizing the revision mixture of a working copy.  The
          resultant revision number, or revision range, is written to
          standard output.</p><p><em class="replaceable"><code>TRAIL_URL</code></em>, if present, is the
          trailing portion of the URL used to determine if
          <em class="replaceable"><code>WC_PATH</code></em> itself is switched
          (detection of switches within
          <em class="replaceable"><code>WC_PATH</code></em> does not rely on
          <em class="replaceable"><code>TRAIL_URL</code></em>).</p><p>When WC_PATH is not defined the current directory
          will be used as the working copy path.  TRAIL_URL cannot be
          defined if WC_PATH is not explicitly given.</p></div><div class="refsect1" title="Switches"><a id="svn.ref.svnversion.re.sw"></a><h2>Switches</h2><p>Like <span class="command"><strong>svnserve</strong></span>,
          <span class="command"><strong>svnversion</strong></span> has no subcommands, it only
          has switches.</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--no-newline</code> (<code class="option">-n</code>)</span></dt><dd><p>Omit the usual trailing newline from the output.</p></dd><dt><span class="term"><code class="option">--committed</code> (<code class="option">-c</code>)</span></dt><dd><p>Use the last-changed revisions rather than the
              current (i.e., highest locally available) revisions.</p></dd><dt><span class="term"><code class="option">--help</code> (<code class="option">-h</code>)</span></dt><dd><p>Print a help summary.</p></dd><dt><span class="term"><code class="option">--version</code></span></dt><dd><p>Print the version of <span class="command"><strong>svnversion</strong></span>
              and exit with no error.</p></dd></dl></div></div><div class="refsect1" title="Examples"><a id="svn.ref.svnversion.re.examples"></a><h2>Examples</h2><p>If the working copy is all at the same revision (for
          example, immediately after an update), then that revision is
          printed out:</p><pre class="screen">$ svnversion
4168</pre><p>You can add TRAIL_URL to show that the working copy is
          not switched from what you expect.  Note that the WC_PATH was
          required in this command:</p><pre class="screen">$ svnversion . /repos/svn/trunk
4168</pre><p>For a mixed-revision working copy, the range of
          revisions present is printed:</p><pre class="screen">$ svnversion
4123:4168</pre><p>If the working copy contains modifications, a trailing
          "M" is added:</p><pre class="screen">$ svnversion
4168M</pre><p>If the working copy is switched, a trailing "S" is
          added:</p><pre class="screen">$ svnversion
4168S</pre><p>Thus, here is a mixed-revision, switched working copy
          containing some local modifications:</p><pre class="screen">$ svnversion
4212:4168MS</pre><p>If invoked on a directory that is not a working copy,
          <span class="command"><strong>svnversion</strong></span> assumes it is an exported
          working copy and prints "exported":</p><pre class="screen">$ svnversion
exported</pre></div></div></div><div class="sect1" title="mod_dav_svn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.ref.mod_dav_svn"></a><span class="command"><strong>mod_dav_svn</strong></span></h2></div></div></div><div class="refentry" title="mod_dav_svn Configuration Directives"><a id="svn.ref.mod_dav_svn.conf"></a><div class="titlepage"></div><div class="refnamediv"><h2>Имя</h2><p><code class="literal">mod_dav_svn</code> Configuration
        Directives — Apache configuration
        directives for serving Subversion repositories through Apache
        HTTP Server.</p></div><div class="refsect1" title="Description"><a id="svn.ref.mod_dav_svn.conf.desc"></a><h2>Description</h2><p>This section briefly describes each of the Subversion
          Apache configuration directives.  For an in-depth
          description of configuring Apache with Subversion, see <a class="xref" href="#svn.serverconfig.httpd" title="httpd, the Apache HTTP server">«httpd, the Apache HTTP server»</a>.)</p></div><div class="refsect1" title="Directives"><a id="svn.ref.mod_dav_svn.conf.directives"></a><h2>Directives</h2><div class="variablelist"><dl><dt><span class="term"><code class="literal">DAV svn</code></span></dt><dd><p>This directive must be included in any
                <code class="literal">Directory</code> or
                <code class="literal">Location</code> block for a Subversion
                repository.  It tells httpd to use the Subversion
                backend for mod_dav to handle all requests.</p></dd><dt><span class="term"><code class="literal">SVNAutoversioning On</code></span></dt><dd><p>This directive allows write requests from WebDAV
                clients to result in automatic commits.  A generic log
                message is auto-generated and attached to each
                revision.  If you enable Autoversioning, you'll likely
                want to set <code class="literal">ModMimeUsePathInfo On</code>
                so that <code class="literal">mod_mime</code> can set
                <code class="literal">svn:mime-type</code> to the correct
                mime-type automatically (as best as
                <code class="literal">mod_mime</code> is able to, of course).
                For more information, see <a class="xref" href="#svn.webdav" title="Приложение C. WebDAV и автоматическое управление версиями">Приложение&nbsp;C, <em>WebDAV и автоматическое управление версиями</em></a></p></dd><dt><span class="term"><code class="literal">SVNPath</code></span></dt><dd><p>This directive specifies the location in the
                filesystem for a Subversion repository's files.  In a
                configuration block for a Subversion repository,
                either this directive or
                <code class="literal">SVNParentPath</code> must be present, but
                not both.</p></dd><dt><span class="term"><code class="literal">SVNSpecialURI</code></span></dt><dd><p>Specifies the URI component (namespace) for
                special Subversion resources.  The default is
                <span class="quote">«<span class="quote"><code class="literal">!svn</code></span>»</span>, and most
                administrators will never use this directive.  Only
                set this if there is a pressing need to have a file
                named <code class="filename">!svn</code> in your repository.  If
                you change this on a server already in use, it will
                break all of the outstanding working copies and your
                users will hunt you down with pitchforks and flaming
                torches.</p></dd><dt><span class="term"><code class="literal">SVNReposName</code></span></dt><dd><p>Specifies the name of a Subversion repository for
                use in <code class="literal">HTTP GET</code> requests.  This
                value will be prepended to the title of all directory
                listings (which are served when you navigate to a
                Subversion repository with a web browser).  This
                directive is optional.</p></dd><dt><span class="term"><code class="literal">SVNIndexXSLT</code></span></dt><dd><p>Specifies the URI of an XSL transformation for
                directory indexes.  This directive is optional.</p></dd><dt><span class="term"><code class="literal">SVNParentPath</code></span></dt><dd><p>Specifies the location in the filesystem of a
                parent directory whose child directories are
                Subversion repositories.  In a configuration block for
                a Subversion repository, either this directive or
                <code class="literal">SVNPath</code> must be present, but not
                both.</p></dd><dt><span class="term"><code class="literal">SVNPathAuthz</code></span></dt><dd><p>Control path-based authorization by enabling or
                disabling subrequests.  See <a class="xref" href="#svn.serverconfig.httpd.authz.pathauthzoff" title="Disabling Path-based Checks">«Disabling Path-based Checks»</a> for details.</p></dd></dl></div></div></div></div><div class="sect1" title="Свойства Subversion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.ref.properties"></a>Свойства Subversion</h2></div></div></div><div class="refentry" title="Свойства Subversion"><a id="svn.ref.svnprops"></a><div class="titlepage"></div><div class="refnamediv"><h2>Имя</h2><p>Свойства Subversion — 
        это свойства, которые определяются Subversion для управления ее поведением.</p></div><div class="refsect1" title="Описание"><a id="svn.ref.svnprops.desc"></a><h2>Описание</h2><p>Subversion позволяет пользователям использовать любые
          именнованные версионируемые <a class="link" href="#property" title="property">свойства</a>
          для файлов и каталогов, а так же неверсионируемые для
          <a class="link" href="#revision" title="revision">версий</a>. Ограничения
          накладываются лишь на свойства с префиксом <span class="quote">«<span class="quote">svn:</span>»</span>.
          Свойства в этом простанстве имен зарезервированы для
          самой Subversion. Пользователи могут изменять значения
          таких свойства для управляния поведение Subversion, но они
          не должны создавать новых <span class="quote">«<span class="quote">svn:</span>»</span> свойств.</p></div><div class="refsect1" title="Версионируемые свойства"><a id="svn.ref.properties.versioned-props"></a><h2>Версионируемые свойства</h2><div class="variablelist"><dl><dt><span class="term"><code class="literal">svn:executable</code></span></dt><dd><p>Наличие такого свойства говорит клиенту пометить
                такой файл как исполняемый в рабочих копиях
                на Unix машинах. Смотри
                <a class="xref" href="#svn.advanced.props.special.executable" title="Исполнимость файла">«Исполнимость файла»</a>.</p></dd><dt><span class="term"><code class="literal">svn:mime-type</code></span></dt><dd><p>Будучи задано для файла, определяет
                MIME тип файла. Это позволяет клиенту решить, что
                он может без опяски использовать построчное слияние
                при обновлении. Это свойство также влияет на восприятие
                файла веб браузером. Смотри
                <a class="xref" href="#svn.advanced.props.special.mime-type" title="Тип содержимого файла">«Тип содержимого файла»</a>. </p></dd><dt><span class="term"><code class="literal">svn:ignore</code></span></dt><dd><p>Будучи задано для <a class="link" href="#directory" title="directory">каталога</a>,
                определяет список шаблонов имен файлов,
                которые будут игнорироваться <span class="command"><strong>svn status</strong></span>
                и другими <a class="link" href="#subcommand" title="sub~">подкомандами</a>.
                Смотри
                <a class="xref" href="#svn.advanced.props.special.ignore" title="Пропуск неверсионированных элементов">«Пропуск неверсионированных элементов»</a></p></dd><dt><span class="term"><code class="literal">svn:keywords</code></span></dt><dd><p>Будучи задано для файла, содержит имена ключевых слов,
                которые клиент должн разименованы в файле.
                Смотри
                <a class="xref" href="#svn.advanced.props.special.keywords" title="Подстановка ключевых слов">«Подстановка ключевых слов»</a>.</p></dd><dt><span class="term"><code class="literal">svn:eol-style</code></span></dt><dd><p>Значение этого свойства, заданного для файла,
                указывает клиенту механизм обработки символов конца
                строк в рабочей копии. Смотри
                <a class="xref" href="#svn.advanced.props.special.eol-style" title="Символы конца строки">«Символы конца строки»</a>.</p></dd><dt><span class="term"><code class="literal">svn:externals</code></span></dt><dd><p>Будучи задано для <a class="link" href="#directory" title="directory">каталога</a>,
                определяет многострочный список других частей и URL-ов
                кой клиент также должен включить в рабочую копию. Смотри
                <a class="xref" href="#svn.advanced.externals" title="Внешние зависимости">«Внешние зависимости»</a>.</p></dd><dt><span class="term"><code class="literal">svn:special</code></span></dt><dd><p>Наличие этого свойства у файла указывает на то,
                что он не является обычным файлом. Это может быть
                символическая ссылка или любой другой специальный
                объект.</p></dd><dt><span class="term"><code class="literal">svn:needs-lock</code></span></dt><dd><p>Наличие этого свойства у файла, указывает клиенту
                пометить его в рабочей копии доступным только для чтения,
                как напоминание о необходимости
                <a class="link" href="#lock" title="lock">заблокировать</a> файл перед его
                редактированием. Смотри                
                <a class="xref" href="#svn.advanced.locking.lock-communication" title="Lock Communication">«Lock Communication»</a>.</p></dd></dl></div></div><div class="refsect1" title="Unversioned Properties"><a id="svn.ref.properties.unversioned-props"></a><h2>Unversioned Properties</h2><div class="variablelist"><dl><dt><span class="term"><code class="literal">svn:author</code></span></dt><dd><p>If present, contains the authenticated username of
                the person who created the revision.  (If not present,
                then the revision was committed anonymously.)</p></dd><dt><span class="term"><code class="literal">svn:date</code></span></dt><dd><p>Contains the UTC time the revision was created, in
                ISO format.  The value comes from the server
                machine's clock.</p></dd><dt><span class="term"><code class="literal">svn:log</code></span></dt><dd><p>Contains the log message describing the
                revision.</p></dd><dt><span class="term"><code class="literal">svn:autoversioned</code></span></dt><dd><p>If present, the revision was created via the
                autoversioning feature.  See
                <a class="xref" href="#svn.webdav.autoversioning" title="Autoversioning">«Autoversioning»</a>.</p></dd></dl></div></div></div></div><div class="footnotes"><br><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.idp16237920" href="#idp16237920" class="para">56</a>] </sup>Да, да, вам не нужна подкоманда что бы задействовать
      параметра командной строки <code class="option">--version</code>, но мы вернемся
      к этому уже через минуту.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp17328384" href="#idp17328384" class="para">57</a>] </sup>Remember,
              <span class="command"><strong>svnadmin</strong></span> works only with local
              <span class="emphasis"><em>paths</em></span>, not
              <span class="emphasis"><em>URLs</em></span>.</p></div></div></div><div class="appendix" title="Приложение A. Быстрый старт в Subversion"><div class="titlepage"><div><div><h2 class="title"><a id="svn.intro"></a>Приложение A. Быстрый старт в Subversion</h2></div></div></div><div class="toc"><p><strong>Содержание</strong></p><dl><dt><span class="sect1"><a href="#svn.intro.install">Установка Subversion</a></span></dt><dt><span class="sect1"><a href="#svn.intro.quickstart">Быстрый старт в Subversion</a></span></dt></dl></div><p>Некоторые испытывают трудности поглощения новой технологии
    читая приближение <span class="quote">«<span class="quote">сверху вниз</span>»</span>, предлагаемое этой
    книгой. Этот раздел представляет собой очень короткое введение в
    Subversion и предназначен для того, что бы помочь изучающим
    <span class="quote">«<span class="quote">снизу вверх</span>»</span>. Если вы из тех, кто предпочитает
    учиться на экспериментах то последующая демонстрация поможет
    вам начать. По ходу дела мы даем ссылки на соответствующие
    главы книги.
  </p><p>Если вы не совсем знакомы с концепциями контроля версий или
    моделью <span class="quote">«<span class="quote">копирование-изменение-слияние</span>»</span>, используемой
    как CVS так и Subversion, перед тем как идти дальше, вам нужно
    прочитать <a class="xref" href="#svn.basic" title="Глава 1. Фундаментальные понятия">Глава&nbsp;1, <em>Фундаментальные понятия</em></a>.</p><div class="sect1" title="Установка Subversion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.intro.install"></a>Установка Subversion</h2></div></div></div><p>Subversion построена на слое переносимости под названием
      APR (the Apache Portable Runtime library). Библиотека APR предоставляет
      все интерфейсы, необходимые для функционирования Subversion под
      управлением различных операционных систем: доступ к жесткому диску,
      доступ к сети, управление памятью, и тому подобное. Не смотря на то,
      что Subversion может использовать Apache как сервер, ее зависимость
      от Apache <span class="emphasis"><em>не означает</em></span> того, что Apache
      является необходимым компонентом. APR представляет собой отдельную
      библиотеку, которую может использовать любое приложение. Кроме прочего,
      это означает, что как и Apache, Subversion клиенты и серверы работают
      на любой операционной системе на которой работает httpd сервер Apache:
      Windows, Linux, все разновидности BSD, MacOS X, Netware и другие.
    </p><p>Наиболее простой способ получить Subversion - скачать бинарный
      пакет, собранный для вашей операционной системы. Как правило, эти
      пакеты присланные волонтерами, доступны для загрузки с веб-сайта
      Subversion (<a class="ulink" href="http://subversion.tigris.org/" target="_top">http://subversion.tigris.org</a>). Сайт обычно
      содержит графический инсталлятор для пользователей операционных
      систем Microsoft. Если вы используете Unix-подобную ОС то для получения
      Subversion вы можете использовать пакетную систему, специфичную для
      вашей системы (RPM, DEB, ports tree и т. д.).
    </p><p>В качестве альтернативного варианта вы можете построить Subversion
      прямо из исходного кода. Закачайте с web-сайта Subversion последний
      релиз исходного кода. После его распаковки для его сборки
      следуйте инструкциям в файле <code class="filename">INSTALL</code>. Обратите
      внимание, что такой пакет содержит все необходимое для сборки клиента командной строки,
      способного работать с удаленным хранилищем (обычно это библиотеки apr,
      apr-util и  neon). Однако некоторые опциональные части Subversion имеют
      много других зависимостей, таких как Berkeley DB и возможно Apache httpd.
      Если вы хотите выполнить полную сборку, убедитесь, что у вас есть все
      пакеты, указанные в файле <code class="filename">INSTALL</code>.</p><p>Если вы один из тех, кто предпочитает использовать максимально современное
      програмное обеспечение, вы можете получить исходники Subversion прямо из репозитория
      Subversion. Само собой, чтобы сделать это, необходимо чтобы у вас уже был клиент Subversion.
      Затем вы можете создать рабочую копию репозитория исходного кода Subversion из
      <a class="ulink" href="http://svn.collab.net/repos/svn/trunk/" target="_top">http://svn.collab.net/repos/svn/trunk/</a>:
      <sup>[<a id="idp19649664" href="#ftn.idp19649664" class="footnote">58</a>]</sup></p><pre class="screen">$ svn checkout http://svn.collab.net/repos/svn/trunk subversion
A    subversion/HACKING
A    subversion/INSTALL
A    subversion/README
A    subversion/autogen.sh
A    subversion/build.conf
…
</pre><p>
      Приведенная выше команда создаст последнюю версию исходного кода
      Subversion в поддиректории <code class="filename">subversion</code> вашей 
      рабочей директории. Очевидно, вы можете скорректировать последний
      аргумент так как вам нужно. Хотя независимо от того как вы назовете 
      директорию с новой рабочей копией, после того как эта операция завершится,
      у вас будут исходики Subversion. Конечно, вам все еще необходимо получить
      несколько вспомогательных библиотек (apr, apr-util, и так далее.)
      —Чтобы узнать детали, обратитесь к файлу <code class="filename">INSTALL</code> каталоге верхнего 
      уровня вашей рабочей копии.
    </p></div><div class="sect1" title="Быстрый старт в Subversion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.intro.quickstart"></a>Быстрый старт в Subversion</h2></div></div></div><div class="blockquote"><blockquote class="blockquote"><p><span class="quote">«<span class="quote">Пожалуйста, удостоверьтесь что ваши посадочные места 
        находятся в верткальном положении, а ваши столики закреплены.
        Бортпроводникам приготовиться к взлету.….</span>»</span></p></blockquote></div><p>Это очень поверхностное руководство, которое покажет вам основы 
      конфигурации и работы с Subversion. К тому времени как вы закончите 
      читать это руководство, у вас должно быть понимание типичного использования 
      Subversion.</p><div class="note" title="Примечание" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Примечание]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/note.png"></td><th align="left">Примечание</th></tr><tr><td valign="top" align="left"><p>Примеры, используемые в этом приложении предполагают наличие у
        вас работающих Subversion клиента для командной строки
        <span class="command"><strong>svn</strong></span> и инструмента администрирования
        <span class="command"><strong>svnadmin</strong></span>. Кроме этого он рассчитан на то, что вы
        используете Subversion версии 1.2 или более поздней (для того, чтобы
        это проверить, выполните <span class="command"><strong>svn --version</strong></span>).</p></td></tr></tbody></table></div><p>Subversion хранит всю версионированную информацию в
      центральном хранилище. Для начала, создадим новое
      хранилище:</p><pre class="screen">$ svnadmin create /path/to/repos
$ ls /path/to/repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</pre><p>Эта команда создает новую директорию
      <code class="filename">/path/to/repos</code> содержащую Subversion
      хранилище. Убедитесь, что эта директория находится на локальном
      диске, <span class="emphasis"><em>не</em></span> на сетевой шаре. Преимущественно в
      эта новая директория (кроме прочего) содержит набор файлов базы данных.
      Вы не увидите своих версионированных файлов если вы загляните внутрь.
      Больше информации о создании и поддержке хранилища ищите в
      <a class="xref" href="#svn.reposadmin" title="Глава 5. Администрирование хранилища">Глава&nbsp;5, <em>Администрирование хранилища</em></a>.</p><p>У Subversion нет понятия <span class="quote">«<span class="quote">проект</span>»</span>. Хранилище
      является просто виртуальной версионированной файловой системой,
      большое дерево файлов, которое может содержать все, что угодно.
      Одни администраторы предпочитают держать в хранилище только
      один проект, другие держать в хранилище множество проектов,
      размещая их в отдельных директориях. Достоинства каждого из
      подходов рассмотрены в  <a class="xref" href="#svn.reposadmin.projects.chooselayout" title="Choosing a Repository Layout">«Choosing a Repository Layout»</a>. В любом случае,
      хранилище управляет только файлами и директориями, оставляя
      за человеком право интерпретировать отдельные директории
      как <span class="quote">«<span class="quote">проекты</span>»</span>. Поэтому, если в тексте книги вы
      встретите упоминание проекта, помните, что имеется в виду
      просто директория (или несколько директорий) хранилища.</p><p>В этом примере мы подразумеваем наличие у вас какого то проекта
      (набора файлов или директорий), который вы хотите импортировать в
      только что созданное Subversion хранилище. Начните с объединения их
      в отдельной директории названой <code class="filename">myproject</code>
      (или как-то иначе). По причинам, которые будут ясны позже (см.
      <a class="xref" href="#svn.branchmerge" title="Глава 4. Ветвление и слияние">Глава&nbsp;4, <em>Ветвление и слияние</em></a>), ваше дерево проекта должно содержать
      три директории верхнего уровня с названиями
      <code class="filename">branches</code>, <code class="filename">tags</code> и
      <code class="filename">trunk</code>. Вся ваша информация должна находиться в
       директории <code class="filename">trunk</code>, а директории
      <code class="filename">branches</code> и <code class="filename">tags</code> должны быть
      пустыми:</p><pre class="screen">/tmp/myproject/branches/
/tmp/myproject/tags/
/tmp/myproject/trunk/
                     foo.c
                     bar.c
                     Makefile
                     …
</pre><p>Использовать поддиректории <code class="filename">branches</code>,
      <code class="filename">tags</code> и <code class="filename">trunk</code> не 
      обязательно. Просто такой подход чаще всего используется и
      вероятнее всего в дальнейшем вы будете использовать именно
      его.</p><p>Как только вы получите готовое дерево данных, импортируйте его
      в хранилище при помощи команды <span class="command"><strong>svn import</strong></span>
      (см. <a class="xref" href="#svn.tour.other.import" title="svn import">«<span class="command"><strong>svn import</strong></span>»</a>):</p><pre class="screen">$ svn import /tmp/myproject file:///path/to/repos/myproject -m "initial import"
Adding         /tmp/myproject/branches
Adding         /tmp/myproject/tags
Adding         /tmp/myproject/trunk
Adding         /tmp/myproject/trunk/foo.c
Adding         /tmp/myproject/trunk/bar.c
Adding         /tmp/myproject/trunk/Makefile
…
Committed revision 1.
$
</pre><p>Теперь в хранилище находится это дерево данных. Как было
      отмечено ранее, вы не увидите своих файлов если загляните в
      хранилище напрямую; все хранится в базе данных. Однако сейчас
      воображаемая файловая системы хранилища имеет директорию верхнего
      уровня с названием <code class="filename">myproject</code> которая
      содержит вашу информацию.</p><p>Обратите внимание на то, что первоначальная директория
      <code class="filename">/tmp/project</code> остается без изменений;
      Subversion о ней не знает. (Фактически, при желании, вы можете даже
      удалить этот каталог.) Чтобы начать работать с информацией хранилища
      вам нужно создать новую <span class="quote">«<span class="quote">рабочую копию</span>»</span> информации,
      своего рода частное рабочее пространство. Попросите Subversion
      создать рабочую копию директории <code class="filename">myproject/trunk</code>
      хранилища:</p><pre class="screen">$ svn checkout file:///path/to/repos/myproject/trunk myproject
A  myproject/foo.c
A  myproject/bar.c
A  myproject/Makefile
…
Checked out revision 1.
</pre><p>Сейчас у вас в новой директории <code class="filename">myproject</code>
      есть личная копия части хранилища. В рабочей копии вы можете
      редактировать файлы, а затем зафиксировать внесенные изменения
      в хранилище.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Откройте свою рабочую копию и отредактируйте
          содержимое файлов.</p></li><li class="listitem"><p>Выполните <span class="command"><strong>svn diff</strong></span> чтобы увидеть
          объединенный diff внесенных изменений.</p></li><li class="listitem"><p>Выполните <span class="command"><strong>svn commit</strong></span> для фиксации
          новой версии ваших файлов в хранилище.</p></li><li class="listitem"><p>Выполните <span class="command"><strong>svn update</strong></span> для приведения
          рабочей копии в <span class="quote">«<span class="quote">актуальное</span>»</span> состояние по
          отношению к хранилищу.</p></li></ul></div><p>Для получения полного списка возможных действий с рабочей копией
      прочтите <a class="xref" href="#svn.tour" title="Глава 2. Экскурсия по Subversion">Глава&nbsp;2, <em>Экскурсия по Subversion</em></a>.</p><p>После этого вы можете сделать ваше хранилище доступным
      для других через сеть. См. <a class="xref" href="#svn.serverconfig" title="Глава 6. Настройка сервера">Глава&nbsp;6, <em>Настройка сервера</em></a> для
      знакомства с различными типами доступных серверных процессов
      и методами их настройки.</p><p>### TODO:  Let's make this into a full tutorial, rather than 
      simply referring off to other sections. ###</p></div><div class="footnotes"><br><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.idp19649664" href="#idp19649664" class="para">58</a>] </sup>Обратите внимание, что URL в указаном примере окнчивается не директорией <code class="literal">svn</code>, 
        а поддиректорией <code class="literal">trunk</code>. Смотрите обсуждение модели ветвления и меток Subversion,
        для выяснения причин этого.</p></div></div></div><div class="appendix" title="Приложение B. Subversion для пользователей CVS"><div class="titlepage"><div><div><h2 class="title"><a id="svn.forcvs"></a>Приложение B. Subversion для пользователей CVS</h2></div></div></div><div class="toc"><p><strong>Содержание</strong></p><dl><dt><span class="sect1"><a href="#svn.forcvs.revnums">Revision Numbers Are Different Now</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.directories">Directory Versions</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.disconnected">More Disconnected Operations</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.status-vs-update">Distinction Between Status and Update</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.forcvs.status-vs-update.status">Status</a></span></dt><dt><span class="sect2"><a href="#svn.forcvs.status-vs-update.update">Update</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.forcvs.branches-and-tags">Branches and Tags</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.properties">Metadata Properties</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.conflicts">Conflict Resolution</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.binary-and-trans">Binary Files and Translation</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.modules">Versioned Modules</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.auth">Authentication</a></span></dt><dt><span class="sect1"><a href="#svn.forcvs.convert">Converting a Repository from CVS to Subversion</a></span></dt></dl></div><p>This appendix is a guide for CVS users new to Subversion.
    It's essentially a list of differences between the two systems
    as <span class="quote">«<span class="quote">viewed from 10,000 feet</span>»</span>.  For each section, we
    provide backreferences to relevant chapters when
    possible.</p><p>Although the goal of Subversion is to take over the current
    and future CVS user base, some new features and design changes
    were required to fix certain <span class="quote">«<span class="quote">broken</span>»</span> behaviors
    that CVS had.  This means that, as a CVS user, you may need to
    break habits—ones that you forgot were odd to begin
    with.</p><div class="sect1" title="Revision Numbers Are Different Now"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.revnums"></a>Revision Numbers Are Different Now</h2></div></div></div><p>In CVS, revision numbers are per-file.  This is because CVS
      stores its data in RCS files; each file has a corresponding RCS
      file in the repository, and the repository is roughly laid out
      according to the structure of your project tree.</p><p>In Subversion, the repository looks like a single
      filesystem.  Each commit results in an entirely new filesystem
      tree; in essence, the repository is an array of trees.  Each of
      these trees is labeled with a single revision number.  When
      someone talks about <span class="quote">«<span class="quote">revision 54</span>»</span>, they're talking
      about a particular tree (and indirectly, the way the filesystem
      looked after the 54th commit).</p><p>Technically, it's not valid to talk about <span class="quote">«<span class="quote">revision 5
      of <code class="filename">foo.c</code></span>»</span>.  Instead, one would say
      <span class="quote">«<span class="quote"><code class="filename">foo.c</code> as it appears in revision
      5</span>»</span>.  Also, be careful when making assumptions about the
      evolution of a file.  In CVS, revisions 5 and 6 of
      <code class="filename">foo.c</code> are always different.  In Subversion,
      it's most likely that <code class="filename">foo.c</code> did
      <span class="emphasis"><em>not</em></span> change between revisions 5 and
      6.</p><p>For more details on this topic, see <a class="xref" href="#svn.basic.in-action.revs" title="Правки">«Правки»</a>.</p></div><div class="sect1" title="Directory Versions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.directories"></a>Directory Versions</h2></div></div></div><p>Subversion tracks tree structures, not just file contents.
      It's one of the biggest reasons Subversion was written to
      replace CVS.</p><p>Here's what this means to you, as a former CVS user:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The <span class="command"><strong>svn add</strong></span> and <span class="command"><strong>svn
          delete</strong></span> commands work on directories now, just as
          they work on files.  So do <span class="command"><strong>svn copy</strong></span> and
          <span class="command"><strong>svn move</strong></span>.  However, these commands do
          <span class="emphasis"><em>not</em></span> cause any kind of immediate change
          in the repository.  Instead, the working items are simply
          <span class="quote">«<span class="quote">scheduled</span>»</span> for addition or deletion.  No
          repository changes happen until you run <span class="command"><strong>svn
          commit</strong></span>.</p></li><li class="listitem"><p>Directories aren't dumb containers anymore; they have
          revision numbers like files.  (Or more properly, it's
          correct to talk about <span class="quote">«<span class="quote">directory
          <code class="filename">foo/</code> in revision 5</span>»</span>.)</p></li></ul></div><p>Let's talk more about that last point.  Directory versioning
      is a hard problem; because we want to allow mixed-revision
      working copies, there are some limitations on how far we can
      abuse this model.</p><p>From a theoretical point of view, we define <span class="quote">«<span class="quote">revision
      5 of directory <code class="filename">foo</code></span>»</span> to mean a
      specific collection of directory-entries and properties.  Now
      suppose we start adding and removing files from
      <code class="filename">foo</code>, and then commit.  It would be a lie
      to say that we still have revision 5 of
      <code class="filename">foo</code>.  However, if we bumped
      <code class="filename">foo</code>'s revision number after the commit,
      that would be a lie too; there may be other changes to
      <code class="filename">foo</code> we haven't yet received, because we
      haven't updated yet.</p><p>Subversion deals with this problem by quietly tracking
      committed adds and deletes in the <code class="filename">.svn</code>
      area.  When you eventually run <span class="command"><strong>svn update</strong></span>,
      all accounts are settled with the repository, and the
      directory's new revision number is set correctly.
      <span class="emphasis"><em>Therefore, only after an update is it truly safe to
      say that you have a <span class="quote">«<span class="quote">perfect</span>»</span> revision of a
      directory.</em></span> Most of the time, your working copy will
      contain <span class="quote">«<span class="quote">imperfect</span>»</span> directory revisions.</p><p>Similarly, a problem arises if you attempt to commit
      property changes on a directory.  Normally, the commit would
      bump the working directory's local revision number.  But again,
      that would be a lie, because there may be adds or deletes that
      the directory doesn't yet have, because no update has happened.
      <span class="emphasis"><em>Therefore, you are not allowed to commit
      property-changes on a directory unless the directory is
      up-to-date.</em></span></p><p>For more discussion about the limitations of directory
      versioning, see <a class="xref" href="#svn.basic.in-action.mixedrevs" title="Смешивание правок в рабочих копиях">«Смешивание правок в рабочих копиях»</a>.</p></div><div class="sect1" title="More Disconnected Operations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.disconnected"></a>More Disconnected Operations</h2></div></div></div><p>In recent years, disk space has become outrageously cheap
      and abundant, but network bandwidth has not.  Therefore, the
      Subversion working copy has been optimized around the scarcer
      resource.</p><p>The <code class="filename">.svn</code> administrative directory
      serves the same purpose as the <code class="filename">CVS</code>
      directory, except that it also stores read-only,
      <span class="quote">«<span class="quote">pristine</span>»</span> copies of your files.  This allows you
      to do many things off-line:</p><div class="variablelist"><dl><dt><span class="term"><span class="command"><strong>svn status</strong></span></span></dt><dd><p>Shows you any local changes you've made (see <a class="xref" href="#svn.tour.cycle.examine.status" title="svn status">«<span class="command"><strong>svn status</strong></span>»</a>)</p></dd><dt><span class="term"><span class="command"><strong>svn diff</strong></span></span></dt><dd><p>Shows you the details of your changes (see <a class="xref" href="#svn.tour.cycle.examine.diff" title="svn diff">«<span class="command"><strong>svn diff</strong></span>»</a>)</p></dd><dt><span class="term"><span class="command"><strong>svn revert</strong></span></span></dt><dd><p>Removes your local changes (see <a class="xref" href="#svn.tour.cycle.examine.revert" title="svn revert">«<span class="command"><strong>svn revert</strong></span>»</a>)</p></dd></dl></div><p>Also, the cached pristine files allow the Subversion client
      to send differences when committing, which CVS cannot do.</p><p>The last subcommand in the list is new; it will not only
      remove local changes, but it will un-schedule operations such as
      adds and deletes.  It's the preferred way to revert a file;
      running <span class="command"><strong>rm file; svn update</strong></span> will still work, but
      it blurs the purpose of updating.  And, while we're on this
      subject…

    </p></div><div class="sect1" title="Distinction Between Status and Update"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.status-vs-update"></a>Distinction Between Status and Update</h2></div></div></div><p>In Subversion, we've tried to erase a lot of the confusion
      between the <span class="command"><strong>cvs status</strong></span> and
      <span class="command"><strong>cvs update</strong></span> commands.</p><p>The <span class="command"><strong>cvs status</strong></span> command has two purposes:
      first, to show the user any local modifications in the working
      copy, and second, to show the user which files are out-of-date.
      Unfortunately, because of CVS's hard-to-read status output, many
      CVS users don't take advantage of this command at all.  Instead,
      they've developed a habit of running <span class="command"><strong>cvs
      update</strong></span> or <span class="command"><strong>cvs -n update</strong></span> to quickly
      see their changes.  If users forget to use
      the <code class="option">-n</code> option, this has the side effect of
      merging repository changes they may not be ready to deal
      with.</p><p>With Subversion, we've tried to remove this muddle by making
      the output of <span class="command"><strong>svn status</strong></span> easy to read for
      both humans and parsers.  Also, <span class="command"><strong>svn update</strong></span>
      only prints information about files that are updated,
      <span class="emphasis"><em>not</em></span> local modifications.</p><div class="sect2" title="Status"><div class="titlepage"><div><div><h3 class="title"><a id="svn.forcvs.status-vs-update.status"></a>Status</h3></div></div></div><p><span class="command"><strong>svn status</strong></span> prints all files that have
        local modifications.  By default, the repository is not
        contacted.  While this subcommand accepts a fair number of
        options, the following are the most commonly used ones:</p><div class="variablelist"><dl><dt><span class="term"><code class="option">-u</code></span></dt><dd><p>Contact the repository to determine, and then display,
              out-of-dateness information.</p></dd><dt><span class="term"><code class="option">-v</code></span></dt><dd><p>Show <span class="emphasis"><em>all</em></span> entries under
              version control.</p></dd><dt><span class="term"><code class="option">-N</code></span></dt><dd><p>Run non-recursively (do not descend into
              subdirectories).</p></dd></dl></div><p>The <span class="command"><strong>status</strong></span> command has two output
        formats.  In the default <span class="quote">«<span class="quote">short</span>»</span> format, local
        modifications look like this:</p><pre class="screen">$ svn status
M      foo.c
M      bar/baz.c
</pre><p>If you specify the <code class="option">--show-updates</code>
        (<code class="option">-u</code>) switch, a longer output format is
        used:</p><pre class="screen">$ svn status -u
M            1047   foo.c
       *     1045   faces.html
       *            bloo.png
M            1050   bar/baz.c
Status against revision:   1066
</pre><p>In this case, two new columns appear.  The second column
        contains an asterisk if the file or directory is out-of-date.
        The third column shows the working-copy's revision number of the
        item.  In the example above, the asterisk indicates that
        <code class="filename">faces.html</code> would be patched if we updated,
        and that <code class="filename">bloo.png</code> is a newly added file in
        the repository.  (The absence of any revision number next to
        <code class="filename">bloo.png</code> means that it doesn't yet exist in
        the working copy.)</p><p>Lastly, here's a quick summary of the most common status codes that
        you may see:</p><pre class="screen">A    Resource is scheduled for Addition
D    Resource is scheduled for Deletion
M    Resource has local Modifications
C    Resource has Conflicts (changes have not been completely merged
       between the repository and working copy version)
X    Resource is eXternal to this working copy (may come from another
       repository).  See <a class="xref" href="#svn.advanced.externals" title="Внешние зависимости">«Внешние зависимости»</a>
?    Resource is not under version control
!    Resource is missing or incomplete (removed by another tool than
       Subversion)
</pre><p>For a more detailed discussion of <span class="command"><strong>svn
        status</strong></span>, see <a class="xref" href="#svn.tour.cycle.examine.status" title="svn status">«<span class="command"><strong>svn status</strong></span>»</a>.</p></div><div class="sect2" title="Update"><div class="titlepage"><div><div><h3 class="title"><a id="svn.forcvs.status-vs-update.update"></a>Update</h3></div></div></div><p><span class="command"><strong>svn update</strong></span> updates your working copy,
        and only prints information about files that it updates.</p><p>Subversion has combined the CVS <code class="literal">P</code> and
        <code class="literal">U</code> codes into just <code class="literal">U</code>.  When
        a merge or conflict occurs, Subversion simply prints
        <code class="literal">G</code> or <code class="literal">C</code>, rather than a
        whole sentence about it.</p><p>For a more detailed discussion of <span class="command"><strong>svn
        update</strong></span>, see <a class="xref" href="#svn.tour.cycle.update" title="Обновление рабочей копии">«Обновление рабочей копии»</a>.</p></div></div><div class="sect1" title="Branches and Tags"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.branches-and-tags"></a>Branches and Tags</h2></div></div></div><p>Subversion doesn't distinguish between filesystem space and
      <span class="quote">«<span class="quote">branch</span>»</span> space; branches and tags are ordinary
      directories within the filesystem.  This is probably the single
      biggest mental hurdle a CVS user will need to climb.  Read all
      about it in <a class="xref" href="#svn.branchmerge" title="Глава 4. Ветвление и слияние">Глава&nbsp;4, <em>Ветвление и слияние</em></a>.</p><div class="warning" title="Предупреждение" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Предупреждение]" src="%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B2%20Subversion_files/warning.png"></td><th align="left">Предупреждение</th></tr><tr><td valign="top" align="left"><p>Since Subversion treats branches and tags as ordinary
        directories, always remember to check out the
        <code class="literal">trunk</code>
        (<code class="literal">http://svn.example.com/repos/calc/trunk/</code>)
        of your project, and not the project itself
        (<code class="literal">http://svn.example.com/repos/calc/</code>).  If
        you make the mistake of checking out the project itself,
        you'll wind up with a working copy that contains a copy of
        your project for every branch and tag you
        have.<sup>[<a id="idp19970976" href="#ftn.idp19970976" class="footnote">59</a>]</sup></p></td></tr></tbody></table></div></div><div class="sect1" title="Metadata Properties"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.properties"></a>Metadata Properties</h2></div></div></div><p>A new feature of Subversion is that you can attach arbitrary
      metadata (or <span class="quote">«<span class="quote">properties</span>»</span>) to files and
      directories.  Properties are arbitrary name/value pairs
      associated with files and directories in your working
      copy.</p><p>To set or get a property name, use the <span class="command"><strong>svn
      propset</strong></span> and <span class="command"><strong>svn propget</strong></span>
      subcommands.  To list all properties on an object, use
      <span class="command"><strong>svn proplist</strong></span>.</p><p>For more information, see <a class="xref" href="#svn.advanced.props" title="Свойства">«Свойства»</a>.</p></div><div class="sect1" title="Conflict Resolution"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.conflicts"></a>Conflict Resolution</h2></div></div></div><p>CVS marks conflicts with in-line <span class="quote">«<span class="quote">conflict
      markers</span>»</span>, and prints a <code class="literal">C</code> during an
      update.  Historically, this has caused problems, because CVS
      isn't doing enough.  Many users forget about (or don't see) the
      <code class="literal">C</code> after it whizzes by on their terminal.
      They often forget that the conflict-markers are even present,
      and then accidentally commit files containing
      conflict-markers.</p><p>Subversion solves this problem by making conflicts more
      tangible.  It remembers that a file is in a state of conflict,
      and won't allow you to commit your changes until you run
      <span class="command"><strong>svn resolved</strong></span>.  See <a class="xref" href="#svn.tour.cycle.resolve" title="Разрешение конфликтов (при слиянии с чужими изменениями)">«Разрешение конфликтов (при слиянии с чужими 
        изменениями)»</a> for more details.</p></div><div class="sect1" title="Binary Files and Translation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.binary-and-trans"></a>Binary Files and Translation</h2></div></div></div><p>In the most general sense, Subversion handles binary files
      more gracefully than CVS does.  Because CVS uses RCS, it can
      only store successive full copies of a changing binary file.
      Subversion, however, expresses differences between files using a
      binary-differencing algorithm, regardless of whether they
      contain textual or binary data.  That means that all files are
      stored differentially (compressed) in the repository.</p><p>CVS users have to mark binary files with
      <code class="option">-kb</code> flags, to prevent data from being garbled
      (due to keyword expansion and line-ending translations).  They
      sometimes forget to do this.</p><p>Subversion takes the more paranoid route—first, it never
      performs any kind of keyword or line-ending translation unless
      you explicitly ask it do so (see <a class="xref" href="#svn.advanced.props.special.keywords" title="Подстановка ключевых слов">«Подстановка ключевых слов»</a> and <a class="xref" href="#svn.advanced.props.special.eol-style" title="Символы конца строки">«Символы конца строки»</a> for more details).  By default,
      Subversion treats all file data as literal byte strings, and
      files are always stored in the repository in an untranslated
      state.</p><p>Second, Subversion maintains an internal notion of whether a
      file is <span class="quote">«<span class="quote">text</span>»</span> or <span class="quote">«<span class="quote">binary</span>»</span> data, but
      this notion is <span class="emphasis"><em>only</em></span> extant in the working
      copy.  During an <span class="command"><strong>svn update</strong></span>, Subversion will
      perform contextual merges on locally modified text files, but
      will not attempt to do so for binary files.</p><p>To determine whether a contextual merge is possible,
      Subversion examines the <code class="literal">svn:mime-type</code>
      property.  If the file has no <code class="literal">svn:mime-type</code>
      property, or has a mime-type that is textual (e.g.
      <code class="literal">text/*</code>),
      Subversion assumes it is text.  Otherwise, Subversion assumes
      the file is binary.  Subversion also helps users by running a
      binary-detection algorithm in the <span class="command"><strong>svn import</strong></span>
      and <span class="command"><strong>svn add</strong></span> commands.  These commands will
      make a good guess and then (possibly) set a binary
      <code class="literal">svn:mime-type</code> property on the file being
      added.  (If Subversion guesses wrong, the user can always remove
      or hand-edit the property.)</p></div><div class="sect1" title="Versioned Modules"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.modules"></a>Versioned Modules</h2></div></div></div><p>Unlike CVS, a Subversion working copy is aware that it has
      checked out a module.  That means that if somebody changes the
      definition of a module (e.g. adds or removes components), then a
      call to <span class="command"><strong>svn update</strong></span> will update the working
      copy appropriately, adding and removing components.</p><p>Subversion defines modules as a list of directories within a
      directory property:  see <a class="xref" href="#svn.advanced.externals" title="Внешние зависимости">«Внешние зависимости»</a>.</p></div><div class="sect1" title="Authentication"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.auth"></a>Authentication</h2></div></div></div><p>With CVS's pserver, you are required to <span class="quote">«<span class="quote">login</span>»</span>
      to the server before any read or write operation—you even
      have to login for anonymous operations.  With a Subversion
      repository using Apache <span class="command"><strong>httpd</strong></span> or
      <span class="command"><strong>svnserve</strong></span> as the server, you don't provide
      any authentication credentials at the outset—if an
      operation that you perform requires authentication, the server
      will challenge you for your credentials (whether those
      credentials are username and password, a client certificate, or
      even both).  So if your repository is world-readable, you will
      not be required to authenticate at all for read
      operations.</p><p>As with CVS, Subversion still caches your credentials on
      disk (in your <code class="filename">~/.subversion/auth/</code>
      directory) unless you tell it not to by using the
      <code class="option">--no-auth-cache</code> switch.</p><p>The exception to this behavior, however, is in the case of
      accessing an <span class="command"><strong>svnserve</strong></span> server over an SSH
      tunnel, using the <code class="literal">svn+ssh://</code> URL schema.  In
      that case, the <span class="command"><strong>ssh</strong></span> program unconditionally
      demands authentication just to start the tunnel.</p></div><div class="sect1" title="Converting a Repository from CVS to Subversion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.forcvs.convert"></a>Converting a Repository from CVS to Subversion</h2></div></div></div><p>Perhaps the most important way to familiarize CVS users with
      Subversion is to let them continue to work on their projects
      using the new system.  And while that can be somewhat
      accomplished using a flat import into a Subversion repository of
      an exported CVS repository, the more thorough solution involves
      transferring not just the latest snapshot of their data, but all
      the history behind it as well, from one system to another.  This
      is an extremely difficult problem to solve that involves
      deducing changesets in the absence of atomicity, and translating
      between the systems' completely orthogonal branching policies,
      among other complications.  Still, there are a handful of tools
      claiming to at least partially support the ability to convert
      existing CVS repositories into Subversion ones.</p><p>One such tool is cvs2svn
      (<a class="ulink" href="http://cvs2svn.tigris.org/" target="_top">http://cvs2svn.tigris.org/</a>), a Python script
      originally created by members of Subversion's own development
      community.  Others include Lev Serebryakov's RefineCVS
      (<a class="ulink" href="http://lev.serebryakov.spb.ru/refinecvs/" target="_top">http://lev.serebryakov.spb.ru/refinecvs/</a>).
      These tools have various levels of completeness, and may make
      entirely different decisions about how to handle your CVS
      repository history.  Whichever tool you decide to use, be sure
      to perform as much verification as you can stand on the
      conversion results—after all, you've worked hard to build
      that history!</p><p>For an updated collection of links to known converter tools,
      visit the Links page of the Subversion website
      (<a class="ulink" href="http://subversion.tigris.org/project_links.html" target="_top">http://subversion.tigris.org/project_links.html</a>).</p></div><div class="footnotes"><br><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.idp19970976" href="#idp19970976" class="para">59</a>] </sup>That is, providing you don't run out of
        disk space before your checkout
        finishes.</p></div></div></div><div class="appendix" title="Приложение C. WebDAV и автоматическое управление версиями"><div class="titlepage"><div><div><h2 class="title"><a id="svn.webdav"></a>Приложение C. WebDAV и автоматическое управление версиями</h2></div></div></div><div class="toc"><p><strong>Содержание</strong></p><dl><dt><span class="sect1"><a href="#svn.webdav.basic">Basic WebDAV Concepts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.webdav.basic.original">Original WebDAV</a></span></dt><dt><span class="sect2"><a href="#svn.webdav.basic.deltav">DeltaV Extensions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn.webdav.svn-and-deltav">Subversion and DeltaV</a></span></dt><dt><span class="sect1"><a href="#svn.webdav.autoversioning">Autoversioning</a></span></dt><dt><span class="sect1"><a href="#svn.webdav.clients">Client Interoperability</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn.webdav.clients.standalone">Standalone WebDAV applications</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.webdav.clients.standalone.windows">Microsoft Office, Dreamweaver, Photoshop</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.standalone.free">Cadaver, DAV Explorer</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.webdav.clients.file-explorer-extensions">File-explorer WebDAV extensions</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.webdav.clients.file-explorer-extensions.windows">Microsoft Web Folders</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.file-explorer-extensions.linux-de">Nautilus, Konqueror</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn.webdav.clients.fs-impl">WebDAV filesystem implementation</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn.webdav.clients.fs-impl.windows">WebDrive, NetDrive</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.fs-impl.macosx">Mac OS X</a></span></dt><dt><span class="sect3"><a href="#svn.webdav.clients.fs-impl.linux">Linux davfs2</a></span></dt></dl></dd></dl></dd></dl></div><p>WebDAV is an extension to HTTP, and is growing more and more
    popular as a standard for file-sharing.  Today's operating systems
    are becoming extremely Web-aware, and many now have built-in
    support for mounting <span class="quote">«<span class="quote">shares</span>»</span> exported by WebDAV
    servers.</p><p>If you use Apache/mod_dav_svn as your Subversion network
    server, then to some extent, you are also running a WebDAV server.
    This appendix gives some background on the nature of this
    protocol, how Subversion uses it, and how well Subversion
    interoperates with other software that is WebDAV-aware.</p><div class="sect1" title="Basic WebDAV Concepts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.webdav.basic"></a>Basic WebDAV Concepts</h2></div></div></div><p>This section provides a very brief, very general overview to
      the ideas behind WebDAV.  It should lay the foundation for
      understanding WebDAV compatibility issues between clients and
      servers.</p><div class="sect2" title="Original WebDAV"><div class="titlepage"><div><div><h3 class="title"><a id="svn.webdav.basic.original"></a>Original WebDAV</h3></div></div></div><p>RFC 2518 defines a set of concepts and accompanying
        extension methods to HTTP 1.1 that make the web into a more
        universal read/write medium.  The basic idea is that a
        WebDAV-compliant web server can act like a generic file
        server; clients can mount shared folders that behave much like
        NFS or SMB filesystems.</p><p>The tragedy, though, is that the RFC 2518 WebDAV
        specification does not provide any sort of model for version
        control, despite the <span class="quote">«<span class="quote">V</span>»</span> in DAV.  Basic WebDAV
        clients and servers assume only one version of each file or
        directory exists, and can be repeatedly overwritten.</p><p>Here are the concepts and terms introduced in basic
        WebDAV:</p><div class="variablelist"><dl><dt><span class="term">Resources</span></dt><dd><p> WebDAV lingo refers to any server-side object
              (that can be described with a URI) as a
              <em class="firstterm">resource</em>.</p></dd><dt><span class="term">New write methods</span></dt><dd><p>Beyond the standard HTTP <code class="literal">PUT</code>
              method (which creates or overwrites a web resource),
              WebDAV defines new <code class="literal">COPY</code> and
              <code class="literal">MOVE</code> methods for duplicating or
              rearranging resources.</p></dd><dt><span class="term">Collections</span></dt><dd><p>A <em class="firstterm">collection</em> is the WebDAV
              term for a grouping of resources.  In most cases, it
              is analogous to a directory.  Whereas file resources
              can be written or created with a
              <code class="literal">PUT</code> method, collection resources
              are created with the new <code class="literal">MKCOL</code>
              method.</p></dd><dt><span class="term">Properties</span></dt><dd><p>This is the same idea present in
              Subversion—metadata attached to files and
              collections.  A client can list or retrieve properties
              attached to a resource with the new
              <code class="literal">PROPFIND</code> method, and can change
              them with the <code class="literal">PROPPATCH</code> method.
              Some properties are wholly created and controlled by
              users (e.g. a property called <span class="quote">«<span class="quote">color</span>»</span>),
              and others are wholly created and controlled by the
              WebDAV server (e.g. a property that contains the last
              modification time of a file).  The former kind are
              called <em class="firstterm">dead properties</em>, and the
              latter kind are called <em class="firstterm">live
                properties</em>.</p></dd><dt><span class="term">Locking</span></dt><dd><p>A WebDAV server may decide to offer a locking
              feature to clients—this part of the
              specification is optional, although most WebDAV
              servers do offer the feature.  If present, then
              clients can use the new <code class="literal">LOCK</code> and
              <code class="literal">UNLOCK</code> methods to mediate access to
              a resource.  In most cases these methods are used to
              create exclusive write locks (as discussed in <a class="xref" href="#svn.basic.vsn-models.lock-unlock" title="Модель Блокирование-Изменение-Разблокирование">«Модель Блокирование-Изменение-Разблокирование»</a>), although shared write
              locks are also possible in some server
              implementations.</p></dd><dt><span class="term">Access control</span></dt><dd><p>A more recent specification (RFC 3744) defines a
              system for defining access control lists (ACLs) on
              WebDAV resources.  Some clients and servers have begun
              to implement this feature.</p></dd></dl></div></div><div class="sect2" title="DeltaV Extensions"><div class="titlepage"><div><div><h3 class="title"><a id="svn.webdav.basic.deltav"></a>DeltaV Extensions</h3></div></div></div><p>Because RFC 2518 left out versioning concepts, another
        committee was left with the responsibility of writing RFC
        3253, which adds versioning to WebDAV,
        a.k.a. <span class="quote">«<span class="quote">DeltaV</span>»</span>.  WebDAV/DeltaV clients and
        servers are often called just <span class="quote">«<span class="quote">DeltaV</span>»</span> programs,
        since DeltaV implies the existence of basic WebDAV.</p><p>DeltaV introduces a whole slew of new acronyms, but don't
        be intimidated.  The ideas are fairly straightforward:</p><div class="variablelist"><dl><dt><span class="term">Per-resource versioning</span></dt><dd><p>Like CVS and other version-control systems,
              DeltaV assumes that each resource has a potentially
              infinite number of states.  A client begins by placing
              a resource under version control using the new
              <code class="literal">VERSION-CONTROL</code> method.</p></dd><dt><span class="term">Server-side working-copy model</span></dt><dd><p>Some DeltaV servers support the ability to create
              a virtual workspace on the server, where all of your
              work is performed.  Clients use the
              <code class="literal">MKWORKSPACE</code> method to create a
              private area, then indicate they want to change
              specific resources by <span class="quote">«<span class="quote">checking them out</span>»</span>
              into the workspace, editing them, and <span class="quote">«<span class="quote">checking
              them in</span>»</span> again.  In HTTP terms, the sequence of
              methods would be <code class="literal">CHECKOUT</code>,
              <code class="literal">PUT</code>,
              <code class="literal">CHECKIN</code>.</p></dd><dt><span class="term">Client-side working-copy model</span></dt><dd><p>Some DeltaV servers also support the idea that the
              client may have a private working copy on local disk.
              When the client wants to commit changes to the server,
              it begins by creating a temporary server transaction
              (called an <em class="firstterm">activity</em>) with the
              <code class="literal">MKACTIVITY</code> method.  The client then
              performs a <code class="literal">CHECKOUT</code> on each
              resource it wishes to change and sends
              <code class="literal">PUT</code> requests.  Finally, the client
              performs a <code class="literal">CHECKIN</code> resource, or
              sends a <code class="literal">MERGE</code> request to check in
              all resources at once.</p></dd><dt><span class="term">Configurations</span></dt><dd><p>DeltaV allows you define flexible collections of
              resources called <span class="quote">«<span class="quote">configurations</span>»</span>, which
              don't necessarily correspond to particular
              directories.  A configuration can be made to point to
              specific versions of files, and then a
              <span class="quote">«<span class="quote">baseline</span>»</span> snapshot can be made, much
              like a tag.</p></dd><dt><span class="term">Extensibility</span></dt><dd><p>DeltaV defines a new method,
              <code class="literal">REPORT</code>, which allows the client and
              server to perform customized data exchanges.  While
              DeltaV defines a number of standardized history reports
              that a client can request, the server is also free
              to define custom reports.  The client sends a
              <code class="literal">REPORT</code> request with a
              properly-labeled XML body full of custom data; assuming
              the server understands the specific report-type, it
              responds with an equally custom XML body.  This
              technique is very similar to XML-RPC.</p></dd></dl></div></div></div><div class="sect1" title="Subversion and DeltaV"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.webdav.svn-and-deltav"></a>Subversion and DeltaV</h2></div></div></div><p>The original WebDAV standard has been widely successful.
      Every modern computer operating system has a general WebDAV
      client built-in (details to follow), and a number of popular
      standalone applications are also able to speak WebDAV —
      Microsoft Office, Dreamweaver, and Photoshop to name a few.  On
      the server end, the Apache webserver has been able to provide
      WebDAV services since 1998 and is considered the de-facto
      open-source standard.  There are several other commercial WebDAV
      servers available, including Microsoft's own IIS.</p><p>DeltaV, unfortunately, has not been so successful.  It's
      very difficult to find any DeltaV clients or servers.  The few
      that do exist are relatively unknown commercial products, and
      thus it's very difficult to test interoperability.  It's not
      entirely clear as to why DeltaV has remained stagnant.  Some
      argue that the specification is just too complex, others argue
      that while WebDAV's features have mass appeal (even the least
      technical users appreciate network file-sharing), version
      control features aren't interesting or necessary for most users.
      Finally, some have argued that DeltaV remains unpopular because
      there's still no open-source server product which implements
      it.</p><p>When Subversion was still in its design phase, it seemed
      like a great idea to use Apache httpd as the main network
      server.  It already had a module to provide WebDAV services.
      DeltaV was a relatively new specification.  The hope was that
      the Subversion server module (mod_dav_svn) would eventually
      evolve into an open-source DeltaV reference implementation.
      Unfortunately, DeltaV has a very specific versioning model that
      doesn't quite line up with Subversion's model.  Some concepts
      were mappable, others were not.</p><p>The upshot is that</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The Subversion client is not a fully-implemented DeltaV
          client.</p><p>The client needs certain things from the server that
          DeltaV cannot provide, and thus is largely dependent on a
          number of Subversion-specific <code class="literal">REPORT</code>
          requests that only mod_dav_svn understands.</p></li><li class="listitem"><p>mod_dav_svn is not a fully-implemented DeltaV server.</p><p>Many portions of the DeltaV specification were irrelevant to
          Subversion, and thus left unimplemented.</p></li></ol></div><p>There is still some debate in the developer community as to
      whether or not it's worthwhile to remedy either of these
      situations.  It's fairly unrealistic to change Subversion's
      design to match DeltaV, so there's probably no way the client
      can ever learn to get everything it needs from a general DeltaV
      server.  On the other hand,
      mod_dav_svn <span class="emphasis"><em>could</em></span> be further developed to
      implement all of DeltaV, but it's hard to find motivation to do
      so—there are almost no DeltaV clients to interoperate
      with.</p></div><div class="sect1" title="Autoversioning"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.webdav.autoversioning"></a>Autoversioning</h2></div></div></div><p>While the Subversion client is not a full DeltaV client, nor
      the Subversion server a full DeltaV server, there's still a
      glimmer of WebDAV interoperability to be happy about:  it's
      called autoversioning.</p><p>Autoversioning is an optional feature defined in the DeltaV
      standard.  A typical DeltaV server will reject an ignorant
      WebDAV client attempting to do a <code class="literal">PUT</code> to a
      file that's under version control.  To change a
      version-controlled file, the server expects a series proper
      versioning requests: something like
      <code class="literal">MKACTIVITY</code>, <code class="literal">CHECKOUT</code>,
      <code class="literal">PUT</code>, <code class="literal">CHECKIN</code>.  But if the
      DeltaV server supports autoversioning, then write-requests from
      basic WebDAV clients are accepted.  The server behaves as if the
      client had issued the proper series of versioning requests,
      performing a commit under the hood.  In other words, it allows a
      DeltaV server to interoperate with ordinary WebDAV
      clients that don't understand versioning.</p><p>Because so many operating systems already have integrated
      WebDAV clients, the use case for this feature borders on
      fantastical: imagine an office of ordinary users running
      Microsoft Windows or Mac OS.  Each user <span class="quote">«<span class="quote">mounts</span>»</span>
      the Subversion repository, which appears to be an ordinary
      network folder.  They use the shared folder as they always do:
      open files, edit them, save them.  Meanwhile, the server is
      automatically versioning everything.  Any administrator (or
      knowledgeable user) can still use a Subversion client to search
      history and retrieve older versions of data.</p><p>This scenario isn't fiction: it's real and it works, as of
      Subversion 1.2 and later.  To activate autoversioning in
      mod_dav_svn, use the <code class="literal">SVNAutoversioning</code>
      directive within the <code class="filename">httpd.conf</code> Location
      block, like so:</p><pre class="screen">&lt;Location /repos&gt;
  DAV svn
  SVNPath /path/to/repository
  SVNAutoversioning on
&lt;/Location&gt;
</pre><p>When SVNAutoversioning is active, write requests from WebDAV
      clients result in automatic commits.  A generic log message is
      auto-generated and attached to each revision.</p><p>Before activating this feature, however, understand what
      you're getting into.  WebDAV clients tend to do
      <span class="emphasis"><em>many</em></span> write requests, resulting in a huge
      number of automatically committed revisions.  For example, when
      saving data, many clients will do a <code class="literal">PUT</code> of a
      0-byte file (as a way of reserving a name) followed by another
      <code class="literal">PUT</code> with the real filedata.  The single
      file-write results in two separate commits.  Also consider that
      many applications auto-save every few minutes, resulting in even
      more commits.</p><p>If you have a post-commit hook program that sends email, you
      may want to disable email generation either altogether, or on
      certain sections of the repository; it depends on whether you
      think the influx of emails will still prove to be valuable
      notifications or not.  Also, a smart post-commit hook program
      can distinguish between a transaction created via autoversioning
      and one created through a normal <span class="command"><strong>svn commit</strong></span>.
      The trick is to look for a revision property
      named <code class="literal">svn:autoversioned</code>.  If present, the
      commit was made by a generic WebDAV client.</p><p>Another feature that may be a useful complement
      for <code class="literal">SVNAutoversioning</code> comes from
      Apache's <code class="literal">mod_mime</code> module.  If a generic
      WebDAV client adds a new file to the repository, there's no
      opportunity for the user to set the
      the <code class="literal">svn:mime-type</code> property.  This might cause
      the file to appear as <span class="quote">«<span class="quote">generic</span>»</span> icon when viewed
      within a WebDAV shared folder, not having an association with
      any application.  One remedy is to have a sysadmin (or other
      Subversion-knowledgable person) check out a working copy and
      manually set the <code class="literal">svn:mime-type</code> property on
      necessary files. But there's potentially no end to such cleanup
      tasks.  Instead, you can use
      the <code class="literal">ModMimeUsePathInfo</code> directive in
      your Subversion <code class="literal">&lt;Location&gt;</code>
      block:</p><pre class="screen">&lt;Location /repos&gt;
  DAV svn
  SVNPath /path/to/repository
  SVNAutoversioning on

  ModMimeUsePathInfo on

&lt;/Location&gt;
</pre><p>This directive allows <code class="literal">mod_mime</code> to attempt
      automatic deduction of the mime-type on new files that enter the
      repository via autoversioning.  The module looks at the file's
      named extension and possibly the contents as well; if the file
      matches some common patterns, then the the
      file's <code class="literal">svn:mime-type</code> property will be set
      automatically.</p></div><div class="sect1" title="Client Interoperability"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="svn.webdav.clients"></a>Client Interoperability</h2></div></div></div><p>All WebDAV clients fall into one of three
      categories—standalone applications, file-explorer
      extensions, or filesystem implementations.  These categories
      broadly define the types of WebDAV functionality available to
      users.  <a class="xref" href="#svn.webdav.clients.tbl-1" title="Таблица C.1. Common WebDAV Clients">Таблица&nbsp;C.1, «Common WebDAV Clients»</a> gives our
      categorization and a quick description of some common pieces of
      WebDAV-enabled software.  More details about these software
      offerings, as well as their general category, can be found in
      the sections that follow.</p><div class="table"><a id="svn.webdav.clients.tbl-1"></a><p class="title"><strong>Таблица C.1. Common WebDAV Clients</strong></p><div class="table-contents"><table summary="Common WebDAV Clients" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Software</th><th>Category</th><th>Description</th></tr></thead><tbody><tr><td>Adobe Photoshop</td><td>Standalone WebDAV applications</td><td>Image editing software, allowing direct opening
              from, and writing to, WebDAV URLs</td></tr><tr><td>Cadaver</td><td>Standalone WebDAV applications</td><td>Command-line WebDAV client supporting file
              transfer, tree, and locking operations</td></tr><tr><td>DAV Explorer</td><td>Standalone WebDAV applications</td><td>GUI tool for exploring WebDAV shares</td></tr><tr><td>davfs2</td><td>WebDAV filesystem implementation</td><td>Linux file system driver that allows you to mount a
              WebDAV share</td></tr><tr><td>GNOME Nautilus</td><td>File-explorer WebDAV extensions</td><td>GUI file explorer able to perform tree
              operations on a WebDAV share</td></tr><tr><td>KDE Konqueror</td><td>File-explorer WebDAV extensions</td><td>GUI file explorer able to perform tree
              operations on a WebDAV share</td></tr><tr><td>Mac OS X</td><td>WebDAV filesystem implementation</td><td>Operating system with built-in support for mounting
              WebDAV shares locally</td></tr><tr><td>Macromedia Dreamweaver</td><td>Standalone WebDAV applications</td><td>Web production software able to directly read from
              and write to WebDAV URLs</td></tr><tr><td>Microsoft Office</td><td>Standalone WebDAV applications</td><td>Office productivity suite with several components
              able to directly read from and write to WebDAV
              URLs</td></tr><tr><td>Microsoft Web Folders</td><td>File-explorer WebDAV extensions</td><td>GUI file explorer program able to perform tree
              operations on a WebDAV share</td></tr><tr><td>Novell NetDrive</td><td>WebDAV filesystem implementation</td><td>Drive-mapping program for assigning Windows drive
              letters to a mounted remote WebDAV share</td></tr><tr><td>SRT WebDrive</td><td>WebDAV filesystem implementation</td><td>File transfer software which, among other things,
              allows the assignment of Windows drive letters to a
              mounted remote WebDAV share</td></tr></tbody></table></div></div><br class="table-break"><br><div class="sect2" title="Standalone WebDAV applications"><div class="titlepage"><div><div><h3 class="title"><a id="svn.webdav.clients.standalone"></a>Standalone WebDAV applications</h3></div></div></div><p>A WebDAV application is a program which contains built-in
        functionality for speaking WebDAV protocols with a WebDAV
        server.  We'll cover some of the most popular programs with
        this kind of WebDAV support.</p><div class="sect3" title="Microsoft Office, Dreamweaver, Photoshop"><div class="titlepage"><div><div><h4 class="title"><a id="svn.webdav.clients.standalone.windows"></a>Microsoft Office, Dreamweaver, Photoshop</h4></div></div></div><p>On Windows, there are several well-known applications
          that contain integrated WebDAV client functionality, such as
          Microsoft's Office,
          <sup>[<a id="idp20309424" href="#ftn.idp20309424" class="footnote">60</a>]</sup>
          Adobe's Photoshop, and Macromedia's Dreamweaver programs.
          They're able to directly open and save to URLs, and tend to
          make heavy use of WebDAV locks when editing a file.</p><p>Note that while many of these programs also exist for
          the Mac OS X, they do not appear to support WebDAV directly
          on that platform.  In fact, on Mac OS X, the
          <span class="guimenu">File-&gt;Open</span> dialog box doesn't allow
          one to type a path or URL at all.  It's likely that the
          WebDAV features were deliberately left out of Macintosh
          versions of these programs, since OS X already provides such
          excellent low-level filesystem support for WebDAV.</p></div><div class="sect3" title="Cadaver, DAV Explorer"><div class="titlepage"><div><div><h4 class="title"><a id="svn.webdav.clients.standalone.free"></a>Cadaver, DAV Explorer</h4></div></div></div><p>Cadaver is a bare-bones Unix commandline program for
          browsing and changing WebDAV shares.  Like the Subversion
          client, it uses the neon HTTP library—not surprisingly,
          both neon and cadaver are written by the same author.  Cadaver
          is free software (GPL license) and is available at <a class="ulink" href="http://www.webdav.org/cadaver/" target="_top">http://www.webdav.org/cadaver/</a>.</p><p>Using cadaver is similar to using a commandline FTP
          program, and thus it's extremely useful for basic WebDAV
          debugging.  It can be used to upload or download files in a
          pinch, and also to examine properties, copy, move, lock or
          unlock files:</p><pre class="screen">$ cadaver http://host/repos
dav:/repos/&gt; ls
Listing collection `/repos/': succeeded.
Coll: &gt; foobar                                 0  May 10 16:19
      &gt; playwright.el                       2864  May  4 16:18
      &gt; proofbypoem.txt                     1461  May  5 15:09
      &gt; westcoast.jpg                      66737  May  5 15:09

dav:/repos/&gt; put README
Uploading README to `/repos/README':
Progress: [=============================&gt;] 100.0% of 357 bytes succeeded.

dav:/repos/&gt; get proofbypoem.txt
Downloading `/repos/proofbypoem.txt' to proofbypoem.txt:
Progress: [=============================&gt;] 100.0% of 1461 bytes succeeded.
</pre><p>DAV Explorer is another standalone WebDAV client, written
          in Java.  It's under a free Apache-like license and is
          available at <a class="ulink" href="http://www.ics.uci.edu/%7Ewebdav/" target="_top">http://www.ics.uci.edu/~webdav/</a>.
          DAV Explorer does everything cadaver does, but has the
          advantages of being portable and being a more user-friendly GUI
          application.  It's also one of the first clients to support
          the new WebDAV Access Control Protocol (RFC 3744).</p><p>Of course, DAV Explorer's ACL support is useless in this
          case, since mod_dav_svn doesn't support it.  The fact that
          both Cadaver and DAV Explorer support some limited DeltaV
          commands isn't particularly useful either, since they don't
          allow <code class="literal">MKACTIVITY</code> requests.  But it's not
          relevant anyway; we're assuming all of these clients are
          operating against an autoversioning repository.</p></div></div><div class="sect2" title="File-explorer WebDAV extensions"><div class="titlepage"><div><div><h3 class="title"><a id="svn.webdav.clients.file-explorer-extensions"></a>File-explorer WebDAV extensions</h3></div></div></div><p>Some popular file explorer GUI programs support WebDAV
        extensions which allow a user to browse a DAV share as if it
        was just another directory on the local computer, and allowing
        basic tree editing operations on the items in that share.  For
        example, Windows Explorer is able to browse a WebDAV server as
        a <span class="quote">«<span class="quote">network place</span>»</span>.  Users can drag files to and
        from the desktop, or can rename, copy, or delete files in the
        usual way.  But because it's only a feature of the
        file-explorer, the DAV share isn't visible to ordinary
        applications.  All DAV interaction must happen through the
        explorer interface.</p><div class="sect3" title="Microsoft Web Folders"><div class="titlepage"><div><div><h4 class="title"><a id="svn.webdav.clients.file-explorer-extensions.windows"></a>Microsoft Web Folders</h4></div></div></div><p>Microsoft was one of the original backers of the WebDAV
          specification, and first started shipping a client in Windows
          98, known as <span class="quote">«<span class="quote">Web Folders</span>»</span>.  This client was also
          shipped in Windows NT4 and 2000.</p><p>The original Web Folders client was an extension to
          Explorer, the main GUI program used to browse filesystems.  It
          works well enough.  In Windows 98, the feature might need to
          be explicitly installed if Web Folders aren't already visible
          inside <span class="quote">«<span class="quote">My Computer</span>»</span>.  In Windows 2000, simply
          add a new <span class="quote">«<span class="quote">network place</span>»</span>, enter the URL, and the
          WebDAV share will pop up for browsing.</p><p>With the release of Windows XP, Microsoft started shipping
          a new implementation of Web Folders, known as the <span class="quote">«<span class="quote">WebDAV
          mini-redirector</span>»</span>.  The new implementation is a
          filesystem-level client, allowing WebDAV shares to be mounted
          as drive letters.  Unfortunately, this implementation is
          incredibly buggy.  The client usually tries to convert http
          URLs (<code class="literal">http://host/repos</code>) into UNC share
          notation (<code class="literal">\\host\repos</code>); it also often
          tries to use Windows Domain authentication to respond to
          basic-auth HTTP challenges, sending usernames as
          <code class="literal">HOST\username</code>.  These interoperability
          problems are severe and documented in numerous places around
          the web, to the frustration of many users.  Even Greg Stein,
          the original author of Apache's WebDAV module, recommends
          against trying to use XP Web Folders against an Apache
          server.</p><p>It turns out that the original
          <span class="quote">«<span class="quote">Explorer-only</span>»</span> Web Folders implementation isn't
          dead in XP, it's just buried.  It's still possible to find it
          by using this technique:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Go to 'Network Places'.</p></li><li class="listitem"><p>Add a new network place.</p></li><li class="listitem"><p>When prompted, enter the URL of the repository, but
              <span class="emphasis"><em>include a port number</em></span> in the URL.
              For example, <code class="literal">http://host/repos</code> would be
              entered as <code class="literal">http://host:80/repos</code> instead.
            </p></li><li class="listitem"><p>Respond to any authentication prompts.</p></li></ol></div><p>There are a number of other rumored workarounds to the
          problems, but none of them seem to work on all versions and
          patchlevels of Windows XP.  In our tests, only the previous
          algorithm seems to work consistently on every system.  The
          general consensus of the WebDAV community is that you should
          avoid the new Web Folders implementation and use the old one
          instead, and that if you need a real filesystem-level
          client for Windows XP, then use a third-party program like
          WebDrive or NetDrive.</p><p>A final tip: if you're attempting to use XP Web Folders,
          make sure you have the absolute latest version from
          Microsoft.  For example, Microsoft released a bug-fixed
          version in January 2005, available at
          <a class="ulink" href="http://support.microsoft.com/?kbid=892211" target="_top">http://support.microsoft.com/?kbid=892211</a>.
          In particular, this release is known to fix a bug whereby
          browsing a DAV share shows an unexpected infinite
          recursion.</p></div><div class="sect3" title="Nautilus, Konqueror"><div class="titlepage"><div><div><h4 class="title"><a id="svn.webdav.clients.file-explorer-extensions.linux-de"></a>Nautilus, Konqueror</h4></div></div></div><p>Nautilus is the official file manager/browser for the
          GNOME desktop (<a class="ulink" href="http://www.gnome.org/" target="_top">http://www.gnome.org</a>), and
          Konqueror is the manager/browser for the KDE desktop (<a class="ulink" href="http://www.kde.org/" target="_top">http://www.kde.org</a>).  Both of these applications have
          an explorer-level WebDAV client built-in, and operate just
          fine against an autoversioning repository.</p><p>In GNOME's Nautilus, from the <span class="guimenu">File
          menu</span>, select <span class="guimenuitem">Open
          location</span> and enter the URL.  The repository
          should then be displayed like any other filesystem.</p><p>In KDE's Konqueror, you need to use the
          <code class="literal">webdav://</code> scheme when entering the URL in
          the location bar.  If you enter an <code class="literal">http://</code>
          URL, Konqueror will behave like an ordinary web browser.
          You'll likely see the generic HTML directory listing produced
          by mod_dav_svn.  By entering
          <code class="literal">webdav://host/repos</code> instead of
          <code class="literal">http://host/repos</code>, Konqueror becomes a
          WebDAV client and displays the repository as a
          filesystem.</p></div></div><div class="sect2" title="WebDAV filesystem implementation"><div class="titlepage"><div><div><h3 class="title"><a id="svn.webdav.clients.fs-impl"></a>WebDAV filesystem implementation</h3></div></div></div><p>The WebDAV filesystem implementation is arguably the best
        sort of WebDAV client.  It's implemented as a low-level
        filesystem module, typically within the operating system's
        kernel.  This means that the DAV share is mounted like any
        other network filesystem, similar to mounting an NFS share on
        Unix, or attaching an SMB share as drive-letter in Windows.
        As a result, this sort of client provides completely
        transparent read/write WebDAV access to all programs.
        Applications aren't even aware that WebDAV requests are
        happening.</p><div class="sect3" title="WebDrive, NetDrive"><div class="titlepage"><div><div><h4 class="title"><a id="svn.webdav.clients.fs-impl.windows"></a>WebDrive, NetDrive</h4></div></div></div><p>Both WebDrive and NetDrive are excellent commercial
          products which allow a WebDAV share to be attached as drive
          letters in Windows.  We've had nothing but success with
          these products.  At the time of writing, WebDrive can be
          purchased from South River Technologies (<a class="ulink" href="http://www.southrivertech.com/" target="_top">http://www.southrivertech.com</a>).  NetDrive ships with
          Netware, is free of charge, and can be found by searching
          the web for <span class="quote">«<span class="quote">netdrive.exe</span>»</span>.  Though it is
          freely available online, users are required to have a
          Netware license.  (If any of that sounds odd to you, you're
          not alone.  See this page on Novell's website: <a class="ulink" href="http://www.novell.com/coolsolutions/qna/999.html" target="_top">http://www.novell.com/coolsolutions/qna/999.html</a>)</p></div><div class="sect3" title="Mac OS X"><div class="titlepage"><div><div><h4 class="title"><a id="svn.webdav.clients.fs-impl.macosx"></a>Mac OS X</h4></div></div></div><p>Apple's OS X operating system has an integrated
          filesystem-level WebDAV client.  From the Finder, select the
          <span class="guimenuitem">Connect to Server</span> item from the
          <span class="guimenu">Go menu</span>.  Enter a WebDAV URL, and it
          appears as a disk on the desktop, just like any other
          mounted volume.  You can also mount a WebDAV share from the
          Darwin terminal by using the <code class="literal">webdav</code>
          filesystem type with the <span class="command"><strong>mount</strong></span> command:</p><pre class="screen">$ mount -t webdav http://svn.example.com/repos/project /some/mountpoint
$
</pre><p>Note that if your mod_dav_svn is older than version 1.2,
          OS X will refuse to mount the share as read-write; it will
          appear as read-only.  This is because OS X insists on
          locking support for read-write shares, and the ability to lock
          files first appeared in Subversion 1.2.</p><p>One more word of warning: OS X's WebDAV client can
          sometimes be overly sensitive to HTTP redirects.  If OS X is
          unable to mount the repository at all, you may need to enable
          the BrowserMatch directive in the Apache server's
          <code class="filename">httpd.conf</code>:</p><pre class="screen">BrowserMatch "^WebDAVFS/1.[012]" redirect-carefully
</pre></div><div class="sect3" title="Linux davfs2"><div class="titlepage"><div><div><h4 class="title"><a id="svn.webdav.clients.fs-impl.linux"></a>Linux davfs2</h4></div></div></div><p>Linux davfs2 is a filesystem module for the Linux kernel,
          whose development is located at <a class="ulink" href="http://dav.sourceforge.net/" target="_top">http://dav.sourceforge.net/</a>.  Once installed, a WebDAV
          network share can be mounted with the usual Linux mount
          command:</p><pre class="screen">$ mount.davfs http://host/repos /mnt/dav
</pre></div></div></div><div class="footnotes"><br><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.idp20309424" href="#idp20309424" class="para">60</a>] </sup>WebDAV support was removed from Microsoft Access for
              some reason, but exists in the rest of the Office
              suite.</p></div></div></div><div class="appendix" title="Приложение D. Инструменты от сторонних разработчиков"><div class="titlepage"><div><div><h2 class="title"><a id="svn.3rdparty"></a>Приложение D. Инструменты от сторонних разработчиков</h2></div></div></div><p>Модульная архитектура Subversion (рассмотренная в разделе
    <a class="xref" href="#svn.developer.layerlib" title="Layered Library Design">«Layered Library Design»</a>) и наличие надстроек для
    различных языков программирования (см. раздел
    <a class="xref" href="#svn.developer.usingapi.otherlangs" title="Using Languages Other than C and C++">«Using Languages Other than C and C++»</a>) делает её
    перспективным кандидатом в качестве дополнения или бекенда для других
    программ. На странице Ссылки веб-сайта Subversion
    <a class="ulink" href="http://subversion.tigris.org/project_links.html" target="_top">http://subversion.tigris.org/project_links.html</a> есть
    перечень большого количества программ от сторонних разработчиков,
    использующих возможности Subversion <span class="quote">«<span class="quote">под капотом</span>»</span>.</p></div><div class="appendix" title="Приложение E. Copyright"><div class="titlepage"><div><div><h2 class="title"><a id="svn.copyright"></a>Приложение E. Copyright</h2></div></div></div><pre class="programlisting">
Copyright (c) 2002-2006
Ben Collins-Sussman, Brian W. Fitzpatrick, C. Michael Pilato.  

This work is licensed under the Creative Commons Attribution License.
To view a copy of this license, visit
http://creativecommons.org/licenses/by/2.0/ or send a letter to
Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305,
USA.

A summary of the license is given below, followed by the full legal
text.

--------------------------------------------------------------------

You are free:

    * to copy, distribute, display, and perform the work
    * to make derivative works
    * to make commercial use of the work

Under the following conditions:
	
Attribution. You must give the original author credit.

    * For any reuse or distribution, you must make clear to others the
      license terms of this work.

    * Any of these conditions can be waived if you get permission from
      the author.

Your fair use and other rights are in no way affected by the above.

The above is a summary of the full license below.

====================================================================

Creative Commons Legal Code
Attribution 2.0

CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
LEGAL SERVICES. DISTRIBUTION OF THIS LICENSE DOES NOT CREATE AN
ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
REGARDING THE INFORMATION PROVIDED, AND DISCLAIMS LIABILITY FOR
DAMAGES RESULTING FROM ITS USE.

License

THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS
CREATIVE COMMONS PUBLIC LICENSE ("CCPL" OR "LICENSE"). THE WORK IS
PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE
WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS
PROHIBITED.

BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND
AGREE TO BE BOUND BY THE TERMS OF THIS LICENSE. THE LICENSOR GRANTS
YOU THE RIGHTS CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF
SUCH TERMS AND CONDITIONS.

1. Definitions

   a. "Collective Work" means a work, such as a periodical issue,
      anthology or encyclopedia, in which the Work in its entirety in
      unmodified form, along with a number of other contributions,
      constituting separate and independent works in themselves, are
      assembled into a collective whole. A work that constitutes a
      Collective Work will not be considered a Derivative Work (as
      defined below) for the purposes of this License.

   b. "Derivative Work" means a work based upon the Work or upon the
      Work and other pre-existing works, such as a translation,
      musical arrangement, dramatization, fictionalization, motion
      picture version, sound recording, art reproduction, abridgment,
      condensation, or any other form in which the Work may be recast,
      transformed, or adapted, except that a work that constitutes a
      Collective Work will not be considered a Derivative Work for the
      purpose of this License. For the avoidance of doubt, where the
      Work is a musical composition or sound recording, the
      synchronization of the Work in timed-relation with a moving
      image ("synching") will be considered a Derivative Work for the
      purpose of this License.

   c. "Licensor" means the individual or entity that offers the Work
      under the terms of this License.

   d. "Original Author" means the individual or entity who created the Work.

   e. "Work" means the copyrightable work of authorship offered under
      the terms of this License.

   f. "You" means an individual or entity exercising rights under this
      License who has not previously violated the terms of this
      License with respect to the Work, or who has received express
      permission from the Licensor to exercise rights under this
      License despite a previous violation.

2. Fair Use Rights. Nothing in this license is intended to reduce,
   limit, or restrict any rights arising from fair use, first sale or
   other limitations on the exclusive rights of the copyright owner
   under copyright law or other applicable laws.

3. License Grant. Subject to the terms and conditions of this License,
   Licensor hereby grants You a worldwide, royalty-free,
   non-exclusive, perpetual (for the duration of the applicable
   copyright) license to exercise the rights in the Work as stated
   below:

   a. to reproduce the Work, to incorporate the Work into one or more
      Collective Works, and to reproduce the Work as incorporated in
      the Collective Works;

   b. to create and reproduce Derivative Works;

   c. to distribute copies or phonorecords of, display publicly,
      perform publicly, and perform publicly by means of a digital
      audio transmission the Work including as incorporated in
      Collective Works;

   d. to distribute copies or phonorecords of, display publicly,
      perform publicly, and perform publicly by means of a digital
      audio transmission Derivative Works.

   e.

      For the avoidance of doubt, where the work is a musical composition:

         i. Performance Royalties Under Blanket Licenses. Licensor
            waives the exclusive right to collect, whether
            individually or via a performance rights society
            (e.g. ASCAP, BMI, SESAC), royalties for the public
            performance or public digital performance (e.g. webcast)
            of the Work.

        ii. Mechanical Rights and Statutory Royalties. Licensor waives
            the exclusive right to collect, whether individually or
            via a music rights agency or designated agent (e.g. Harry
            Fox Agency), royalties for any phonorecord You create from
            the Work ("cover version") and distribute, subject to the
            compulsory license created by 17 USC Section 115 of the US
            Copyright Act (or the equivalent in other jurisdictions).

   f. Webcasting Rights and Statutory Royalties. For the avoidance of
      doubt, where the Work is a sound recording, Licensor waives the
      exclusive right to collect, whether individually or via a
      performance-rights society (e.g. SoundExchange), royalties for
      the public digital performance (e.g. webcast) of the Work,
      subject to the compulsory license created by 17 USC Section 114
      of the US Copyright Act (or the equivalent in other
      jurisdictions).

The above rights may be exercised in all media and formats whether now
known or hereafter devised. The above rights include the right to make
such modifications as are technically necessary to exercise the rights
in other media and formats. All rights not expressly granted by
Licensor are hereby reserved.

4. Restrictions.The license granted in Section 3 above is expressly
   made subject to and limited by the following restrictions:

   a. You may distribute, publicly display, publicly perform, or
      publicly digitally perform the Work only under the terms of this
      License, and You must include a copy of, or the Uniform Resource
      Identifier for, this License with every copy or phonorecord of
      the Work You distribute, publicly display, publicly perform, or
      publicly digitally perform. You may not offer or impose any
      terms on the Work that alter or restrict the terms of this
      License or the recipients' exercise of the rights granted
      hereunder. You may not sublicense the Work. You must keep intact
      all notices that refer to this License and to the disclaimer of
      warranties. You may not distribute, publicly display, publicly
      perform, or publicly digitally perform the Work with any
      technological measures that control access or use of the Work in
      a manner inconsistent with the terms of this License
      Agreement. The above applies to the Work as incorporated in a
      Collective Work, but this does not require the Collective Work
      apart from the Work itself to be made subject to the terms of
      this License. If You create a Collective Work, upon notice from
      any Licensor You must, to the extent practicable, remove from
      the Collective Work any reference to such Licensor or the
      Original Author, as requested. If You create a Derivative Work,
      upon notice from any Licensor You must, to the extent
      practicable, remove from the Derivative Work any reference to
      such Licensor or the Original Author, as requested.

   b. If you distribute, publicly display, publicly perform, or
      publicly digitally perform the Work or any Derivative Works or
      Collective Works, You must keep intact all copyright notices for
      the Work and give the Original Author credit reasonable to the
      medium or means You are utilizing by conveying the name (or
      pseudonym if applicable) of the Original Author if supplied; the
      title of the Work if supplied; to the extent reasonably
      practicable, the Uniform Resource Identifier, if any, that
      Licensor specifies to be associated with the Work, unless such
      URI does not refer to the copyright notice or licensing
      information for the Work; and in the case of a Derivative Work,
      a credit identifying the use of the Work in the Derivative Work
      (e.g., "French translation of the Work by Original Author," or
      "Screenplay based on original Work by Original Author"). Such
      credit may be implemented in any reasonable manner; provided,
      however, that in the case of a Derivative Work or Collective
      Work, at a minimum such credit will appear where any other
      comparable authorship credit appears and in a manner at least as
      prominent as such other comparable authorship credit.

5. Representations, Warranties and Disclaimer

UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING,
LICENSOR OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR
WARRANTIES OF ANY KIND CONCERNING THE WORK, EXPRESS, IMPLIED,
STATUTORY OR OTHERWISE, INCLUDING, WITHOUT LIMITATION, WARRANTIES OF
TITLE, MERCHANTIBILITY, FITNESS FOR A PARTICULAR PURPOSE,
NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY,
OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT
DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED
WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.

6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY
   APPLICABLE LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY
   LEGAL THEORY FOR ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE
   OR EXEMPLARY DAMAGES ARISING OUT OF THIS LICENSE OR THE USE OF THE
   WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
   DAMAGES.

7. Termination

   a. This License and the rights granted hereunder will terminate
      automatically upon any breach by You of the terms of this
      License. Individuals or entities who have received Derivative
      Works or Collective Works from You under this License, however,
      will not have their licenses terminated provided such
      individuals or entities remain in full compliance with those
      licenses. Sections 1, 2, 5, 6, 7, and 8 will survive any
      termination of this License.

   b. Subject to the above terms and conditions, the license granted
      here is perpetual (for the duration of the applicable copyright
      in the Work). Notwithstanding the above, Licensor reserves the
      right to release the Work under different license terms or to
      stop distributing the Work at any time; provided, however that
      any such election will not serve to withdraw this License (or
      any other license that has been, or is required to be, granted
      under the terms of this License), and this License will continue
      in full force and effect unless terminated as stated above.

8. Miscellaneous

   a. Each time You distribute or publicly digitally perform the Work
      or a Collective Work, the Licensor offers to the recipient a
      license to the Work on the same terms and conditions as the
      license granted to You under this License.

   b. Each time You distribute or publicly digitally perform a
      Derivative Work, Licensor offers to the recipient a license to
      the original Work on the same terms and conditions as the
      license granted to You under this License.

   c. If any provision of this License is invalid or unenforceable
      under applicable law, it shall not affect the validity or
      enforceability of the remainder of the terms of this License,
      and without further action by the parties to this agreement,
      such provision shall be reformed to the minimum extent necessary
      to make such provision valid and enforceable.

   d. No term or provision of this License shall be deemed waived and
      no breach consented to unless such waiver or consent shall be in
      writing and signed by the party to be charged with such waiver
      or consent.

   e. This License constitutes the entire agreement between the
      parties with respect to the Work licensed here. There are no
      understandings, agreements or representations with respect to
      the Work not specified here. Licensor shall not be bound by any
      additional provisions that may appear in any communication from
      You. This License may not be modified without the mutual written
      agreement of the Licensor and You.

Creative Commons is not a party to this License, and makes no warranty
whatsoever in connection with the Work. Creative Commons will not be
liable to You or any party on any legal theory for any damages
whatsoever, including without limitation any general, special,
incidental or consequential damages arising in connection to this
license. Notwithstanding the foregoing two (2) sentences, if Creative
Commons has expressly identified itself as the Licensor hereunder, it
shall have all rights and obligations of Licensor.

Except for the limited purpose of indicating to the public that the
Work is licensed under the CCPL, neither party will use the trademark
"Creative Commons" or any related trademark or logo of Creative
Commons without the prior written consent of Creative Commons. Any
permitted use will be in compliance with Creative Commons'
then-current trademark usage guidelines, as may be published on its
website or otherwise made available upon request from time to time.

Creative Commons may be contacted at http://creativecommons.org/.

====================================================================
</pre></div><div class="index" title="Предметный указатель"><div class="titlepage"><div><div><h2 class="title"><a id="svn.index"></a>Предметный указатель</h2></div></div></div><div class="index"><div class="indexdiv"><h3>Символы</h3><dl><dt>###</dt><dd><dl><dt>TODO: More indexterms!, <a class="indexterm" href="#svn.preface">Об этой книге</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>C</h3><dl><dt>Concurrent Versions System (CVS), <a class="indexterm" href="#svn.preface">Об этой книге</a></dt></dl></div><div class="indexdiv"><h3>S</h3><dl><dt>Subversion</dt><dd><dl><dt>history of, <a class="indexterm" href="#svn.intro.history">История Subversion</a></dt></dl></dd><dt>svn</dt><dd><dl><dt>subcommands</dt><dd><dl><dt>add, <a class="indexterm" href="#svn.ref.svn.c.add">svn add</a></dt><dt>blame, <a class="indexterm" href="#svn.ref.svn.c.blame">svn blame</a></dt><dt>cat, <a class="indexterm" href="#svn.ref.svn.c.cat">svn cat</a></dt><dt>checkout, <a class="indexterm" href="#svn.ref.svn.c.checkout">svn checkout</a></dt><dt>cleanup, <a class="indexterm" href="#svn.ref.svn.c.cleanup">svn cleanup</a></dt><dt>commit, <a class="indexterm" href="#svn.ref.svn.c.commit">svn commit</a></dt><dt>copy, <a class="indexterm" href="#svn.ref.svn.c.copy">svn copy</a></dt><dt>delete, <a class="indexterm" href="#svn.ref.svn.c.delete">svn delete</a></dt><dt>diff, <a class="indexterm" href="#svn.ref.svn.c.diff">svn diff</a></dt><dt>export, <a class="indexterm" href="#svn.ref.svn.c.export">svn export</a></dt><dt>help, <a class="indexterm" href="#svn.ref.svn.c.help">svn help</a></dt><dt>import, <a class="indexterm" href="#svn.ref.svn.c.import">svn import</a></dt><dt>info, <a class="indexterm" href="#svn.ref.svn.c.info">svn info</a></dt><dt>list, <a class="indexterm" href="#svn.ref.svn.c.list">svn list</a></dt><dt>lock, <a class="indexterm" href="#svn.ref.svn.c.lock">svn lock</a></dt><dt>log, <a class="indexterm" href="#svn.ref.svn.c.log">svn log</a></dt><dt>merge, <a class="indexterm" href="#svn.ref.svn.c.merge">svn merge</a></dt><dt>mkdir, <a class="indexterm" href="#svn.ref.svn.c.mkdir">svn mkdir</a></dt><dt>move, <a class="indexterm" href="#svn.ref.svn.c.move">svn move</a></dt><dt>propdel, <a class="indexterm" href="#svn.ref.svn.c.propdel">svn propdel</a></dt><dt>propedit, <a class="indexterm" href="#svn.ref.svn.c.propedit">svn propedit</a></dt><dt>propget, <a class="indexterm" href="#svn.ref.svn.c.propget">svn propget</a></dt><dt>proplist, <a class="indexterm" href="#svn.ref.svn.c.proplist">svn proplist</a></dt><dt>propset, <a class="indexterm" href="#svn.ref.svn.c.propset">svn propset</a></dt><dt>resolved, <a class="indexterm" href="#svn.ref.svn.c.resolved">svn resolved</a></dt><dt>revert, <a class="indexterm" href="#svn.ref.svn.c.revert">svn revert</a></dt><dt>status, <a class="indexterm" href="#svn.ref.svn.c.status">svn status</a></dt><dt>switch, <a class="indexterm" href="#svn.ref.svn.c.switch">svn switch</a></dt><dt>unlock, <a class="indexterm" href="#svn.ref.svn.c.unlock">svn unlock</a></dt><dt>update, <a class="indexterm" href="#svn.ref.svn.c.update">svn update</a></dt></dl></dd></dl></dd><dt>svnadmin</dt><dd><dl><dt>subcommands</dt><dd><dl><dt>create, <a class="indexterm" href="#svn.ref.svnadmin.c.create">svnadmin create</a></dt><dt>deltify, <a class="indexterm" href="#svn.ref.svnadmin.c.deltify">svnadmin deltify</a></dt><dt>dump, <a class="indexterm" href="#svn.ref.svnadmin.c.dump">svnadmin dump</a></dt><dt>help, <a class="indexterm" href="#svn.ref.svnadmin.c.help">svnadmin help</a></dt><dt>hotcopy, <a class="indexterm" href="#svn.ref.svnadmin.c.hotcopy">svnadmin hotcopy</a></dt><dt>list-dblogs, <a class="indexterm" href="#svn.ref.svnadmin.c.list-dblogs">svnadmin list-dblogs</a></dt><dt>list-unused-dblogs, <a class="indexterm" href="#svn.ref.svnadmin.c.list-unused-dblogs">svnadmin list-unused-dblogs</a></dt><dt>load, <a class="indexterm" href="#svn.ref.svnadmin.c.load">svnadmin load</a></dt><dt>lslocks, <a class="indexterm" href="#svn.ref.svnadmin.c.lslocks">svnadmin lslocks</a></dt><dt>lstxns, <a class="indexterm" href="#svn.ref.svnadmin.c.lstxns">svnadmin lstxns</a></dt><dt>recover, <a class="indexterm" href="#svn.ref.svnadmin.c.recover">svnadmin recover</a></dt><dt>rmlocks, <a class="indexterm" href="#svn.ref.svnadmin.c.rmlocks">svnadmin rmlocks</a></dt><dt>rmtxns, <a class="indexterm" href="#svn.ref.svnadmin.c.rmtxns">svnadmin rmtxns</a></dt><dt>setlog, <a class="indexterm" href="#svn.ref.svnadmin.c.setlog">svnadmin setlog</a></dt><dt>verify, <a class="indexterm" href="#svn.ref.svnadmin.c.verify">svnadmin verify</a></dt></dl></dd></dl></dd><dt>svnlook</dt><dd><dl><dt>subcommands</dt><dd><dl><dt>author, <a class="indexterm" href="#svn.ref.svnlook.c.author">svnlook author</a></dt><dt>cat, <a class="indexterm" href="#svn.ref.svnlook.c.cat">svnlook cat</a></dt><dt>changed, <a class="indexterm" href="#svn.ref.svnlook.c.changed">svnlook changed</a></dt><dt>date, <a class="indexterm" href="#svn.ref.svnlook.c.date">svnlook date</a></dt><dt>diff, <a class="indexterm" href="#svn.ref.svnlook.c.diff">svnlook diff</a></dt><dt>dirs-changed, <a class="indexterm" href="#svn.ref.svnlook.c.dirs-changed">svnlook dirs-changed</a></dt><dt>help, <a class="indexterm" href="#svn.ref.svnlook.c.help">svnlook help</a></dt><dt>history, <a class="indexterm" href="#svn.ref.svnlook.c.history">svnlook history</a></dt><dt>info, <a class="indexterm" href="#svn.ref.svnlook.c.info">svnlook info</a></dt><dt>lock, <a class="indexterm" href="#svn.ref.svnlook.c.lock">svnlook lock</a></dt><dt>log, <a class="indexterm" href="#svn.ref.svnlook.c.log">svnlook log</a></dt><dt>propget, <a class="indexterm" href="#svn.ref.svnlook.c.propget">svnlook propget</a></dt><dt>proplist, <a class="indexterm" href="#svn.ref.svnlook.c.proplist">svnlook proplist</a></dt><dt>tree, <a class="indexterm" href="#svn.ref.svnlook.c.tree">svnlook tree</a></dt><dt>uuid, <a class="indexterm" href="#svn.ref.svnlook.c.uuid">svnlook uuid</a></dt><dt>youngest, <a class="indexterm" href="#svn.ref.svnlook.c.youngest">svnlook youngest</a></dt></dl></dd></dl></dd><dt>svnversion, <a class="indexterm" href="#svn.ref.svnversion.re">svnversion</a></dt></dl></div></div></div><div class="glossary" title="Русский глоссарий"><div class="titlepage"><div><div><h2 class="title"><a id="svn.glossary.ru"></a>Русский глоссарий</h2></div></div></div><div class="glossdiv" title="Переводятся единожды"><h3 class="title">Переводятся единожды</h3><dl><dt><a id="CVS"></a>Concurrent Versions System</dt><dd><p>система параллельного управления версиями</p><em><span class="remark">Перевод даётся в сноске при первом употреблении. Далее используется
          сокращённое английское название (акроним).</span></em></dd><dt><a id="API"></a>Application Program Interface</dt><dd><p>интерфейс прикладного программирования</p><em><span class="remark">Перевод даётся в сноске при первом употреблении. Далее используется
          сокращённое английское название (акроним).</span></em></dd></dl></div><div class="glossdiv" title="Не переводятся"><h3 class="title">Не переводятся</h3><dl><dt><a id="Windows"></a>Windows</dt><dd><em><span class="remark">Не переводится</span></em></dd><dt><a id="Unix"></a>Unix</dt><dd><em><span class="remark">Не переводится</span></em></dd><dt><a id="SVN"></a>Subversion</dt><dd><em><span class="remark">Не переводится</span></em></dd><dt><a id="Cygwin"></a>Cygwin</dt><dd><em><span class="remark">Не переводится</span></em></dd><dt><a id="Apache"></a>Apache</dt><dd><em><span class="remark">Не переводится</span></em></dd><dt><a id="APR"></a>Apache Portable Runtime</dt><dd><em><span class="remark">Не переводится</span></em></dd><dt><a id="JRE"></a>Java Runtime Environment</dt><dd><em><span class="remark">Не переводится</span></em></dd><dt><a id="IRI"></a>Internationalized Resource Identifiers</dt><dd><em><span class="remark">Не переводится</span></em></dd><dt><a id="URI"></a>Uniform Resource Identifiers</dt><dd><em><span class="remark">Не переводится</span></em></dd><dt><a id="URL"></a>Uniform Resource Locator</dt><dd><em><span class="remark">Не переводится</span></em></dd></dl></div><div class="glossdiv" title="A"><h3 class="title">A</h3><dl><dt><a id="access"></a>access</dt><dd><p>доступ</p></dd><dt><a id="local-access"></a>local ~</dt><dd><p>локальный доступ</p><p>См. также <a class="glossseealso" href="#access">access</a>.</p></dd><dt><a id="anonymous-access"></a>anonymous ~</dt><dd><p>анонимный доступ</p><p>См. также <a class="glossseealso" href="#access">access</a>.</p></dd><dt><a id="atomic"></a>atomic</dt><dd><p>атомарный</p></dd><dt><a id="atomic-commit"></a>~ commit</dt><dd><p>атомарная фиксация</p><p>См. также <a class="glossseealso" href="#atomic">atomic</a>, <a class="glossseealso" href="#commit">commit</a>.</p></dd><dt><a id="atomic-transaction"></a>~ transaction</dt><dd><p>атомарная операция</p><p>См. также <a class="glossseealso" href="#atomic">atomic</a>.</p></dd><dt><a id="autoversioning"></a>autoversioning</dt><dd><p>автоматическое управление версиями</p></dd><dt><a id="architecture"></a>architecture</dt><dd><p>архитектура</p></dd><dt><a id="authentication"></a>authentication</dt><dd><p>установление личности</p></dd><dt><a id="authorization"></a>authorization</dt><dd><p>проверка прав доступа</p></dd></dl></div><div class="glossdiv" title="B"><h3 class="title">B</h3><dl><dt><a id="binary"></a>binary</dt><dd><p>бинарный</p></dd><dt><a id="binary-package"></a>~ package</dt><dd><p>бинарный пакет</p><p>См. также <a class="glossseealso" href="#binary">binary</a>.</p></dd><dt><a id="blame"></a>blame</dt><dd><p>ответственное лицо</p></dd><dt><a id="branch"></a>branch</dt><dd><p>ветвь</p></dd><dt><a id="branching"></a>~ing</dt><dd><p>ветвление</p><p>См. также <a class="glossseealso" href="#branch">branch</a>.</p></dd></dl></div><div class="glossdiv" title="C"><h3 class="title">C</h3><dl><dt><a id="change"></a>change</dt><dd><p>изменение</p></dd><dt><a id="changeset"></a>~set</dt><dd><p>набор изменений</p><p>См. также <a class="glossseealso" href="#change">change</a>.</p></dd><dt><a id="tracking-changes"></a>tracking ~s</dt><dd><p>отслеживание изменений</p><p>См. также <a class="glossseealso" href="#change">change</a>.</p></dd><dt><a id="check-in"></a>check in</dt><dd><p>публиковать, публикация изменений</p><p>См. также <a class="glossseealso" href="#check-out">check out</a>.</p></dd><dt><a id="check-out"></a>check out</dt><dd><p>создавать рабочую копию</p><p>См. также <a class="glossseealso" href="#check-in">check in</a>.</p></dd><dt><a id="client"></a>client</dt><dd><p>клиент</p></dd><dt><a id="client-program"></a>~ program</dt><dd><p>программа-клиент</p><p>См. также <a class="glossseealso" href="#client">client</a>, <a class="glossseealso" href="#program">program</a>.</p></dd><dt><a id="code"></a>code</dt><dd><p>код</p></dd><dt><a id="source-code"></a>source ~</dt><dd><p>исходный код [программы]</p><p>См. также <a class="glossseealso" href="#code">code</a>.</p></dd><dt><a id="command"></a>command</dt><dd><p>команда</p></dd><dt><a id="subcommand"></a>sub~</dt><dd><p>подкоманда</p><p>См. также <a class="glossseealso" href="#command">command</a>.</p></dd><dt><a id="command-line"></a>command line</dt><dd><p>командная строка</p></dd><dt><a id="CLI"></a>~ interface</dt><dd><p>интерфейс командной строки</p><p>См. также <a class="glossseealso" href="#command-line">command line</a>, <a class="glossseealso" href="#interface">interface</a>.</p></dd><dt><a id="command-line-tool"></a>~ tool</dt><dd><p>программа, предназначенная для командной строки</p><em><span class="remark">уточнить по контексту</span></em><p>См. также <a class="glossseealso" href="#command">command</a>.</p></dd><dt><a id="commit"></a>commit</dt><dd><p>фиксация</p><p>См. также <a class="glossseealso" href="#repository">repository</a>.</p></dd><dt><a id="community"></a>community</dt><dd><p>сообщество</p></dd><dt><a id="configure"></a>configure</dt><dd><p>настраивать</p></dd><dt><a id="configuration"></a>configuration</dt><dd><p>настройки</p><p>См. также <a class="glossseealso" href="#configure">configure</a>.</p></dd><dt><a id="conflict"></a>conflict</dt><dd><p>противоречие</p></dd><dt><a id="conflict-resolution"></a>~ resolution</dt><dd><p>разрешение противоречий</p><p>См. также <a class="glossseealso" href="#conflict">conflict</a>.</p></dd><dt><a id="convention"></a>convention</dt><dd><p>соглашение</p></dd><dt><a id="copy"></a>copy</dt><dd><p>копия</p></dd><dd><p>копировать</p></dd><dt><a id="working-copy"></a>working ~</dt><dd><p>рабочая копия</p><p>См. также <a class="glossseealso" href="#copy">copy</a>.</p></dd><dt><a id="copy-modify-merge"></a>copy-modify-merge</dt><dd><p>"скопировал-изменил-слил"</p><p>См. также <a class="glossseealso" href="#copy">copy</a>, <a class="glossseealso" href="#merge">merge</a>.</p></dd><dt><a id="current"></a>current</dt><dd><p>текущий</p></dd></dl></div><div class="glossdiv" title="D"><h3 class="title">D</h3><dl><dt><a id="demon"></a>demon</dt><dd><p>демон</p></dd><dt><a id="demon-process"></a>~ process</dt><dd><p>процесс-демон</p><p>См. также <a class="glossseealso" href="#demon">demon</a>.</p></dd><dt><a id="data"></a>data</dt><dd><p>данные</p></dd><dt><a id="metadata"></a>meta~</dt><dd><p>метаданные</p><p>См. также <a class="glossseealso" href="#data">data</a>.</p></dd><dt><a id="DB"></a>database</dt><dd><p>база данных</p></dd><dt><a id="developer"></a>developer</dt><dd><p>разработчик</p><p>См. также <a class="glossseealso" href="#programmer">~mer</a>.</p></dd><dt><a id="directory"></a>directory</dt><dd><p>каталог</p></dd><dt><a id="administrative-directory"></a>administrative ~</dt><dd><p>служебный каталог</p><p>См. также <a class="glossseealso" href="#directory">directory</a>.</p></dd><dt><a id="diff"></a>diff</dt><dd><p>различие</p></dd><dt><a id="unified-diff"></a>unified ~</dt><dd><p>единый формат записи различий</p><p>См. также <a class="glossseealso" href="#diff">diff</a>.</p></dd><dt><a id="disconnected-operation"></a>disconnected operation</dt><dd><p>операция, не требующая подключения к серверу</p></dd><dt><a id="dowload"></a>dowload</dt><dd><p>загрузка</p></dd><dt><a id="drive"></a>drive</dt><dd><p>диск</p></dd><dt><a id="drive-name"></a>~ name</dt><dd><p>имя диска</p><p>См. также <a class="glossseealso" href="#drive">drive</a>.</p></dd></dl></div><div class="glossdiv" title="E"><h3 class="title">E</h3><dl><dt><a id="email"></a>email</dt><dd><p>электронная почта</p></dd><dt><a id="environment"></a>environment</dt><dd><p>рабочая среда</p></dd><dt><a id="emulation-environment"></a>emulation ~</dt><dd><p>среда эмуляции</p><p>См. также <a class="glossseealso" href="#environment">environment</a>.</p></dd><dt><a id="environment-variable"></a>~ variable</dt><dd><p>переменная рабочей среды</p><p>См. также <a class="glossseealso" href="#environment">environment</a>.</p></dd><dt><a id="external-definition"></a>external definition</dt><dd><p>внешняя зависимость</p></dd></dl></div><div class="glossdiv" title="F"><h3 class="title">F</h3><dl><dt><a id="feature"></a>feature</dt><dd><p>особенность</p></dd><dt><a id="file"></a>file</dt><dd><p>файл</p></dd><dt><a id="file-sharing"></a>~-sharing</dt><dd><p>совместный доступ к файлам</p><p>См. также <a class="glossseealso" href="#file">file</a>.</p></dd><dt><a id="filter"></a>filter</dt><dd><p>фильтр</p></dd><dd><p>фильтрация</p></dd></dl></div><div class="glossdiv" title="G"><h3 class="title">G</h3><dl><dt><a id="GUI"></a>Graphical User Interface</dt><dd><p>графический интерфейс пользователя</p><em><span class="remark">Перевод даётся в сноске при первом употреблении. Далее используется
сокращённое английское название.</span></em></dd><dt>Global Revision Number</dt><dd><p>глобальный номер правки</p></dd></dl></div><div class="glossdiv" title="H"><h3 class="title">H</h3><dl><dt><a id="history"></a>history</dt><dd><p>история</p></dd></dl></div><div class="glossdiv" title="I"><h3 class="title">I</h3><dl><dt><a id="icon"></a>icon</dt><dd><p>значок (на экране)</p></dd><dd><p>символ (в тексте)</p></dd><dt><a id="import"></a>import</dt><dd><p>вносить, заносить</p></dd><dt><a id="interface"></a>interface</dt><dd><p>интерфейс</p></dd><dt><a id="install"></a>install</dt><dd><p>установка (программного обеспечения)</p></dd><dt><a id="install-method"></a>~ method</dt><dd><p>способ установки</p><p>См. также <a class="glossseealso" href="#install">install</a>.</p></dd><dt><a id="installer"></a>~er</dt><dd><p>программа установки</p><p>См. также <a class="glossseealso" href="#install">install</a>.</p></dd></dl></div><div class="glossdiv" title="K"><h3 class="title">K</h3><dl><dt><a id="key"></a>key</dt><dd><p>имя (переменной)</p></dd></dl></div><div class="glossdiv" title="L"><h3 class="title">L</h3><dl><dt><a id="library"></a>library</dt><dd><p>библиотека</p></dd><dt><a id="lightweight"></a>lightweight</dt><dd><p>легкий</p></dd><dt><a id="local"></a>local</dt><dd><p>местный</p></dd><dt><a id="lock"></a>lock</dt><dd><p>блокировать</p></dd><dt><a id="locking"></a>~ing</dt><dd><p>блокировка</p><p>См. также <a class="glossseealso" href="#lock">lock</a>.</p></dd><dt><a id="lock-modify-unlock"></a>lock-modify-unlock</dt><dd><p>"заблокировал-изменил-разблокировал"</p><p>См. также <a class="glossseealso" href="#lock">lock</a>.</p></dd><dt><a id="log"></a>log</dt><dd><p>сообщения истории изменений</p><p>См. также <a class="glossseealso" href="#log-message">log message</a>.</p></dd></dl></div><div class="glossdiv" title="M"><h3 class="title">M</h3><dl><dt><a id="mail"></a>mail</dt><dd><p>почта</p></dd><dt><a id="module"></a>module</dt><dd><p>модуль</p></dd><dt><a id="plug-in-module"></a>plug-in ~</dt><dd><p>подключаемый модуль расширения</p><em><span class="remark">Например, https модуль для Apache</span></em><p>См. также <a class="glossseealso" href="#module">module</a>.</p></dd><dt><a id="merge"></a>merge</dt><dd><p>слияние</p></dd><dt><a id="message"></a>message</dt><dd><p>сообщение</p></dd><dt><a id="log-message"></a>log message</dt><dd><p>сообщение истории изменений</p><p>См. также <a class="glossseealso" href="#log">log</a>.</p></dd><dt><a id="commit-message"></a>commit message</dt><dd><p>сообщение истории изменений</p><p>пояснение изменений</p><p>пояснение фиксируемых изменений</p><p>См. также <a class="glossseealso" href="#commit">commit</a>.</p></dd><dt><a id="mount"></a>mount</dt><dd><p>монтировать</p></dd><dt><a id="mount-share"></a>to ~ share</dt><dd><p>монтировать совместно используемый ресурс</p><p>См. также <a class="glossseealso" href="#mount">mount</a>.</p></dd></dl></div><div class="glossdiv" title="N"><h3 class="title">N</h3><dl><dt><a id="network"></a>network</dt><dd><p>сеть</p></dd><dt><a id="network-layer"></a>~ layer</dt><dd><p>сетевой уровень</p><p>См. также <a class="glossseealso" href="#network">network</a>.</p></dd></dl></div><div class="glossdiv" title="O"><h3 class="title">O</h3><dl><dt><a id="offline"></a>offline</dt><dd><p>автономный</p></dd><dt><a id="offline-operation"></a>~ operation</dt><dd><p>автономная операция</p><p>См. также <a class="glossseealso" href="#offline">offline</a>.</p></dd><dt><a id="option"></a>option</dt><dd><p>настройка</p><p>опция</p></dd><dt><a id="configuration-option"></a>configuration option</dt><dd><p>настройка конфигурации</p><p>См. также <a class="glossseealso" href="#option">option</a>.</p></dd><dt><a id="out-of-date"></a>out-of-date</dt><dd><p>устаревший</p></dd><dt><a id="overlap"></a>overlap</dt><dd><p>наложение (при описании состояния)</p></dd><dt><a id="overlaping"></a>~ing</dt><dd><p>пересекающийся</p><p>См. также <a class="glossseealso" href="#overlap">overlap</a>.</p></dd><dd><p>перекрытие (при описании процесса)</p><p>См. также <a class="glossseealso" href="#overlap">overlap</a>.</p></dd></dl></div><div class="glossdiv" title="P"><h3 class="title">P</h3><dl><dt><a id="patch"></a>patch</dt><dd><p>"заплатка"</p></dd><dt><a id="path"></a>path</dt><dd><p>путь</p></dd><dt><a id="port"></a>port</dt><dd><p>порт</p></dd><dt><a id="program"></a>program</dt><dd><p>программа</p></dd><dd><p>программировать</p></dd><dt><a id="programmer"></a>~mer</dt><dd><p>программист</p><p>См. также <a class="glossseealso" href="#program">program</a>.</p></dd><dt><a id="programming"></a>~ing</dt><dd><p>программирование</p><p>См. также <a class="glossseealso" href="#program">program</a>.</p></dd><dt><a id="property"></a>property</dt><dd><p>свойство</p></dd><dt><a id="property-support"></a>~ support</dt><dd><p>поддержка свойств</p></dd><dt><a id="unversioned-properties"></a>unversioned properties</dt><dd><p>неверсионное свойство</p></dd><dt><a id="protocol"></a>protocol</dt><dd><p>протокол</p></dd><dt><a id="public"></a>public</dt><dd><p>открытый</p></dd><dd><p>доступный</p></dd><dt><a id="public-API"></a>~ API</dt><dd><p>открытый API</p><p>См. также <a class="glossseealso" href="#public">public</a>, <a class="glossseealso" href="#API">Application Program Interface</a>.</p></dd></dl></div><div class="glossdiv" title="R"><h3 class="title">R</h3><dl><dt><a id="read"></a>read</dt><dd><p>чтение</p></dd><dt><a id="read-only"></a>read-only</dt><dd><p>только для чтения</p></dd><dt><a id="repository"></a>repository</dt><dd><p>хранилище</p></dd><dt><a id="central-repository"></a>central ~</dt><dd><p>центральное хранилище</p><p>См. также <a class="glossseealso" href="#repository">repository</a>.</p></dd><dt><a id="remote-repository"></a>remote ~</dt><dd><p>удаленное хранилище</p><p>См. также <a class="glossseealso" href="#remote">remote</a>, <a class="glossseealso" href="#repository">repository</a>.</p></dd><dt><a id="repository-location"></a>~ location</dt><dd><p>место размещения хранилища</p><p>См. также <a class="glossseealso" href="#repository">repository</a>.</p></dd><dt><a id="snapshot-of-repository"></a>snapshot of ~</dt><dd><p>снимок хранилища</p><p>См. также <a class="glossseealso" href="#repository">repository</a>.</p></dd><dt><a id="remote"></a>remote</dt><dd><p>удаленный</p></dd><dt><a id="request"></a>request</dt><dd><p>запрос</p></dd><dt><a id="revert"></a>revert</dt><dd><p>возврат к прежнему состоянию</p></dd><dd><p>вернуть прежнее состояние</p></dd><dt><a id="revision"></a>revision</dt><dd><p>правка</p><p>версия</p></dd><dt><a id="revision-number"></a>~ number</dt><dd><p>номер правки</p><p>номер версии</p><p>См. также <a class="glossseealso" href="#revision">revision</a>.</p></dd><dt><a id="mixed-revision"></a>mixed ~</dt><dd><p>смешанная правка</p><p>См. также <a class="glossseealso" href="#revision">revision</a>.</p></dd><dt><a id="runtime"></a>runtime</dt><dd><p>среда исполнения</p></dd><dt><a id="runtime-option"></a>~ option</dt><dd><p>настройка среды исполнения</p><p>См. также <a class="glossseealso" href="#runtime">runtime</a>.</p></dd><dt><a id="runtime-variable"></a>~ variable</dt><dd><p>переменная среды исполнения</p><p>См. также <a class="glossseealso" href="#runtime">runtime</a>.</p></dd></dl></div><div class="glossdiv" title="S"><h3 class="title">S</h3><dl><dt><a id="separator"></a>separator</dt><dd><p>символ-разделитель</p></dd><dt><a id="path-separator"></a>path ~</dt><dd><p>символ-разделитель компонентов путевого имени</p><p>См. также <a class="glossseealso" href="#separator">separator</a>.</p></dd><dt><a id="serialization"></a>serialization</dt><dd><p>сериализация</p></dd><dt><a id="server"></a>server</dt><dd><p>сервер</p></dd><dt><a id="file-server"></a>file ~</dt><dd><p>файл-сервер</p><p>См. также <a class="glossseealso" href="#server">server</a>.</p></dd><dt><a id="share"></a>share</dt><dd><p>совместно используемый ресурс</p></dd><dt><a id="DAV-share"></a>DAV ~</dt><dd><p>совместно используемый ресурс DAV</p><p>См. также <a class="glossseealso" href="#share">share</a>.</p></dd><dt><a id="network-share"></a>network ~</dt><dd><p>совместно используемый сетевой ресурс</p><p>См. также <a class="glossseealso" href="#share">share</a>, <a class="glossseealso" href="#network">network</a>.</p></dd><dt><a id="slash"></a>slash</dt><dd><p>символ косой черты</p></dd><dt><a id="backward-slash"></a>backward ~</dt><dd><p>символ обратной косой черты</p><p>См. также <a class="glossseealso" href="#slash">slash</a>.</p></dd><dt><a id="forward-slash"></a>forward ~</dt><dd><p>См. <a class="glosssee" href="#slash">slash</a>.</p></dd><dt><a id="software"></a>software</dt><dd><p>программное обеспечение</p></dd><dt><a id="collaboration-software"></a>collaboration ~</dt><dd><p>программное обеспечение для совместной работы</p><p>См. также <a class="glossseealso" href="#software">software</a>.</p></dd><dt><a id="OSS"></a>open-source ~</dt><dd><p>программное обеспечение с открытым исходным кодом</p><p>См. также <a class="glossseealso" href="#software">software</a>.</p></dd><dt><a id="free-software"></a>free ~</dt><dd><p>свободно распространяемое программное обеспечение</p><p>См. также <a class="glossseealso" href="#software">software</a>.</p></dd><dt><a id="SCM"></a>Software Configuration Management</dt><dd><p>система управления конфигурацией программного обеспечения</p><p>См. также <a class="glossseealso" href="#software">software</a>.</p></dd><dt><a id="standalone"></a>standalone</dt><dd><p>самостоятельный</p></dd><dt><a id="status"></a>status</dt><dd><p>статус</p><p>состояние</p></dd><dt><a id="status-listing"></a>status listing</dt><dd><p>список состояния файлов</p><p>См. также <a class="glossseealso" href="#status">status</a>.</p></dd><dt><a id="style"></a>style</dt><dd><p>стиль</p></dd><dt><a id="programming-style"></a>programming ~</dt><dd><p>стиль программирования</p><p>См. также <a class="glossseealso" href="#style">style</a>.</p></dd><dt><a id="subdirectory"></a>subdirectory</dt><dd><p>вложенный каталог</p><p>подкаталог</p><p>См. также <a class="glossseealso" href="#directory">directory</a>.</p></dd><dt><a id="support"></a>support</dt><dd><p>поддержка</p></dd><dt><a id="switch"></a>switch</dt><dd><p>параметр командной строки</p></dd><dt><a id="sysadmin"></a>sysadmin</dt><dd><p>системный администратор</p></dd></dl></div><div class="glossdiv" title="T"><h3 class="title">T</h3><dl><dt><a id="tag"></a>tag</dt><dd><p>метка</p></dd><dt><a id="tagging"></a>~ging</dt><dd><p>назначение метки</p><p>См. также <a class="glossseealso" href="#tag">tag</a>.</p></dd><dt><a id="timestamp"></a>timestamp</dt><dd><p>отметка времени</p></dd><dt><a id="top-level"></a>top-level</dt><dd><p>верхний уровень</p></dd><dd><p>верхнего уровня</p><em><span class="remark">относящийся к верхнему уровню</span></em></dd><dt><a id="tree"></a>tree</dt><dd><p>дерево</p></dd><dt><a id="external-tree"></a>external ~</dt><dd><p>внешнее дерево</p><p>См. также <a class="glossseealso" href="#tag">tag</a>.</p></dd><dt><a id="troubleshooting"></a>troubleshooting</dt><dd><p>поиск и исправление неисправностей</p></dd><dt><a id="tunnel"></a>tunnel</dt><dd><p>тоннель</p></dd><dd><p>прокладывать тоннель</p></dd><dt><a id="tunneling"></a>~ing</dt><dd><p>туннелирование</p></dd></dl></div><div class="glossdiv" title="U"><h3 class="title">U</h3><dl><dt><a id="unblock"></a>unblock</dt><dd><p>разблокировать</p></dd><dt><a id="UNIX-like"></a>Unix-like</dt><dd><p>Unix-подобный</p></dd><dt><a id="URL-schema"></a>URL schema</dt><dd><p>схема URL</p></dd><dt><a id="update"></a>update</dt><dd><p>обновление</p></dd><dd><p>обновлять</p></dd><dt><a id="up-to-date"></a>up-to-date</dt><dd><p>обновленный</p></dd><dd><p>актуальный</p></dd></dl></div><div class="glossdiv" title="V"><h3 class="title">V</h3><dl><dt><a id="value"></a>value</dt><dd><p>значение</p></dd><dt><a id="vendor"></a>vendor</dt><dd><p>поставщик</p></dd><dt><a id="vendor-branch"></a>~ branch</dt><dd><p>ветвь поставщика</p></dd><dt><a id="version"></a>version</dt><dd><p>версия</p></dd><dt><a id="version-control"></a>~ control</dt><dd><p>управление версиями</p><p>См. также <a class="glossseealso" href="#version">version</a>.</p></dd><dt><a id="versioning-model"></a>~ing model</dt><dd><p>модель управления версиями</p><p>См. также <a class="glossseealso" href="#version">version</a>.</p></dd><dt><a id="versioned-directory"></a>~ed directory</dt><dd><p>версионированный каталог</p><p>См. также <a class="glossseealso" href="#version">version</a>.</p></dd><dt><a id="directory-versioning"></a>directory ~ing</dt><dd><p>версионирование каталогов</p><p>См. также <a class="glossseealso" href="#version">version</a>.</p></dd><dt><a id="versioned-metadata"></a>~ed metadata</dt><dd><p>версионированные метаданные</p><p>См. также <a class="glossseealso" href="#version">version</a>, <a class="glossseealso" href="#metadata">meta~</a>.</p></dd><dt><a id="versioned-data"></a>~ed data</dt><dd><p>версионированные данные</p><p>См. также <a class="glossseealso" href="#version">version</a>.</p></dd></dl></div><div class="glossdiv" title="W"><h3 class="title">W</h3><dl><dt><a id="write"></a>write</dt><dd><p>запись</p></dd></dl></div><div class="glossdiv" title="U"><h3 class="title">U</h3><dl><dt><a id="undo"></a>undo</dt><dd><p>отмена</p></dd><dt><a id="undo-changes"></a>to ~ changes</dt><dd><p>отменять внесенные изменения</p><p>См. также <a class="glossseealso" href="#undo">undo</a>.</p></dd><dt><a id="user"></a>user</dt><dd><p>пользователь</p></dd><dt><a id="advanced-user"></a>advanced ~</dt><dd><p>продвинутый пользователь</p></dd></dl></div></div></div>
</body></html>