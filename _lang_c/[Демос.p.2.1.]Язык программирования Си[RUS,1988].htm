<html><head><title>Язык программирования Си.</title></head><body><pre><div align=right><div align=right><form action=mailto:hit@library.niisi.ras.ru method=POST><a href=/HITPARAD/><font color=black>Оцените</font></a> этот текст:<tt><font size=-1><INPUT TYPE=hidden NAME=file VALUE=/MAN/DEMOS210/c.txt><SELECT NAME=ocenka><OPTION VALUE=0>Не читал<OPTION VALUE=10>10<OPTION VALUE=9>9<OPTION VALUE=8>8<OPTION VALUE=7>7<OPTION VALUE=6>6<OPTION VALUE=5>5<OPTION VALUE=4>4<OPTION VALUE=3>3<OPTION VALUE=2>2<OPTION VALUE=1>1</SELECT><INPUT TYPE=submit VALUE=Send></font></tt></form></div><form action=/MAN/DEMOS210/c.txt><select name=format><OPTION VALUE="_Contents">Содержание<OPTION VALUE="_with-big-pictures.html">Fine HTML<OPTION VALUE="_with-big-pictures.html">Printed version<OPTION VALUE="_Ascii.txt">txt(Word,КПК)<OPTION VALUE="">Lib.ru html</select><input type=submit value=go></form></div><pre>
<ul><a name=0></a><h2>Язык программирования Си.</h2></ul>


          Производственно-внедренческий кооператив

                    "И Н Т Е Р Ф Е Й С"

                Диалоговая Единая Мобильная

                    Операционная Система

                        Демос/P 2.1


                 Язык программирования Си.

                           Москва

                            1988


     Описан универсальный язык программирования Си.   Приве-
дены  структура  и  синтаксис языка, правила написания прог-
рамм, даны начальные сведения о взаимодействии  программ  на
Си с операционной системой Демос.








<ul><a name=1></a><h2> * 1.  ВВЕДЕНИЕ</h2></ul>

     Язык Си - это универсальный язык программирования,  для
которого  характерны  экономичность  выражения,  современный
набор операторов и типов данных.  Язык  Си  не  является  ни
языком  "очень  высокого  уровня", ни "большим" языком, и не
предназначается для некоторой специальной  области  примене-
ния,  но  отсутствие ограничений и общность языка делают его
для многих задач более удобным  и  эффективным,  чем  языки,
предположительно более мощные.  Операционная система, компи-
лятор с языка Си и по существу все прикладные программы сис-
темы   "ДЕМОС"  написаны на Си.  Язык Си не связан с какими-
либо определенными аппаратными средствами или  системами,  и
на  нем легко писать программы, которые можно пропускать без
изменений на любой ЭВМ, имеющей Си-компилятор.

     Язык Си является универсальным языком программирования.
Он  первоначально  появился  в  операционной системе <b>UNIX</b>, и
развивался как основной язык систем, совместимых с <b>ОС  UNIX</b>.
Сам язык , однако, не связан с какой-либо одной операционной
системой или машиной; и хотя его называют языком  системного
программирования, так как он удобен для написания операцион-
ных систем, он  может  использоваться  для  написания  любых
больших  вычислительных  программ,  программ  для  обработки
текстов и баз данных.

     Язык Си - это язык относительно "низкого уровня".   Это
означает,  что Си имеет дело с объектами того же вида, что и
большинство ЭВМ, а именно, с символами, числами и  адресами.
Они  могут  объединяться  и пересылаться посредством обычных
арифметических и логических операций, осуществляемых  реаль-
ными ЭВМ.

     В языке Си отсутствуют операции,  имеющие  дело  непос-
редственно  с составными объектами, такими как строки симво-
лов, множества, списки или с массивами, рассматриваемыми как
целое. Здесь, например, нет никакого аналога операциям <b>PL</b>/1,
оперирующим с массивами и строками.  Язык  не  предоставляет
никаких других возможностей распределения памяти, кроме ста-
тического определения и  механизма  стеков,  обеспечиваемого
локальными переменных функций.  Сам по себе язык Си не обес-
печивает никаких возможностей ввода-вывода.  Все  эти  меха-
низмы высокого уровня должны обеспечиваться явно вызываемыми
функциями.

     Аналогично, язык Си предлагает только простые, последо-
вательные конструкции управления: проверки, циклы, группиро-
вание и подпрограммы, но не  мультипрограммирование,  парал-
лельные операции, синхронизацию или сопрограммы.

     Удержание языка в скромных размерах дает реальные преи-
мущества.  Так  как Си относительно мал, он не требует много
места для  своего  описания  и  может  быть  быстро  выучен.


                            <b>-1-</b>


Компилятор  с Си может быть простым и компактным.  Это обес-
печивает высокую степень мобильности языка.  Поскольку  типы
данных  и  структуры управления, имеющиеся в Си, непосредст-
венно поддерживаются большинством существующих ЭВМ,  библио-
тека,  необходимая  во время прогона изолированных программ,
оказывается очень маленькой. На СМ-4, например , она  содер-
жит  только  программы для 32-битового умножения и деления и
для упрятывания и восстановления регистров при входе в функ-
цию.  Конечно, каждая реализация обеспечивает исчерпывающую,
совместимую  библиотеку  функций  для  выполнения   операций
ввода-вывода, обработки строк и распределения памяти, но так
как обращение к ним осуществляется только явно, можно,  если
необходимо,  избежать их вызова; эти функции могут быть ком-
пактно написаны на самом Си.

     Опять же из-за того, что язык Си  отражает  возможности
современных  компьютеров, программы на Си оказываются доста-
точно эффективными, так что не возникает  побуждения  писать
вместо  этого  программы на языке ассемблера.  Хотя Си соот-
ветствует возможностям  многих ЭВМ, он не зависит от  какой-
либо конкретной архитектуры машины и в силу этого без особых
усилий позволяет писать "переносимые" программы, т.е.  прог-
раммы,  которые  можно пропускать без изменений на различных
аппаратных средствах.

     Язык Си  не является языком со строгими типами данных в
смысле  Паскаля или Алгола-68. Он сравнительно снисходителен
к преобразованию данных, хотя и не будет буйно  преобразовы-
вать  типы  данных подобно языку <b>PL</b>/1. Компилятор не предус-
матривает никакой проверки индексов массивов, типов аргумен-
тов и т.д. во время выполнения программы.

     В тех  ситуациях,  когда  желательна  строгая  проверка
типов,  используется  специальная программа <b>lint</b>.  Программа
<b>lint</b>  не генерирует машинного кода, а делает  очень  строгую
проверку всех тех сторон программы, которые можно проконтро-
лировать во время компиляции  и  загрузки.   Она  определяет
несоответствие  типов, несовместимость аргументов, неисполь-
зованные или очевидным образом неинициализированные перемен-
ные, потенциальные трудности переносимости и т.д.

     Из  за  того,  что   в   языке   отсутствуют   средства
ввода/вывода  и т.п., при программировании на нем существен-
ную роль играет библиотека стандартных программ, осуществля-
ющих взаимодействие с системой.  Во всех системах, совмести-
мых с <b>ОС UNIX</b>, к которым относится и ДЕМОС, существует  сов-
местимый   набор   программ   для  ввода/вывода,  управления
памятью, преобразования данных и выполняющих другие функции,
использование   которых  обеспечивает  возможность  переноса
программ на другие ЭВМ.

     В данном документе  описывается  язык  Си,  расширения,
обеспечиваемые  специальным  препроцессором  (фактически они


                            <b>-2-</b>


вошли уже  в  понятие  "язык  Си"),  стандартная  библиотека
ввода/вывода,  и  даются начальные сведения о взаимодействии
программ на Си с <b>ОС  ДЕМОС</b>.   Полное  описание  библиотечных
программ  имеется в руководстве программиста <b>ОС ДЕМОС</b> (части
3 и 4), и в оперативной документации <b>man</b>(2) и <b>man</b>(3).  Хоро-
шим  учебником  по языку Си является книга [1], краткое фор-
мальное описание языка приведено в [2].

     В тексте встречаются примечания, относящиеся к реализа-
ции языка Си в <b>ОС ДЕМОС</b>.  Такие примечания выделяются верти-
кальной чертой справа (как выделен данный абзац).

<ul><a name=2></a><h2> * 2.  СИНТАКСИЧЕСКАЯ НОТАЦИЯ</h2></ul>

     В используемой в этом руководстве синтаксической  нота-
ции синтаксические категории записываются русскими буквами и
символом "_", а все остальные  символы  рассматриваются  как
литерные  (то  есть изображающие сами себя).  Альтернативные
категории перечисляются на отдельных строчках.  Необязатель-
ный  символ,  терминальный  или  нетерминальный, указывается
индексом "необ", так что

               { <b>выражение</b>      }
                          <b>необ</b>

указывает на необязательное выражение, заключенное в  фигур-
ных скобках.  Синтаксис описывается в Приложении 1.

     Если описание не помещается на одной строке,  оно  про-
должается на следующей с некоторым сдвигом вправо, например:

      <b>описание</b>_<b>структуры</b>:
           <b>спецификатор</b>_<b>типа</b>
                  <b>список</b>_<b>описателей</b>_<b>структуры</b>

Здесь следует читать:

 <b>описание</b>_<b>структуры</b>:
  <b>спецификатор</b>_<b>типа  список</b>_<b>описателей</b>_<b>структуры</b>

     Если сделан разбор входного потока на лексемы вплоть до
данного  символа,  то  в  качестве следующей лексемы берется
самая длинная строка символов,

     <b>IBM/370</b> (<b>OS-360</b>)  7 символов, 1 регистр
     <b>VAX</b> 11  (<b>UNIX</b>)    7 символов, 2 регистра


<ul><a name=3></a><h2>2.1.  Ключевые слова</h2></ul>

     Следующие идентификаторы зарезервированы для  использо-
вания  в  качестве  ключевых  слов и не могут использоваться
иным образом:


                            <b>-3-</b>


          <b>int            extern          else</b>
          <b>char           register        for</b>
          <b>float          typedef         do</b>
          <b>double         static          while</b>
          <b>struct         goto            switch</b>
          <b>union          return          case</b>
          <b>long           sizeof          default</b>
          <b>short          break           entry</b>
          <b>unsigned       continue</b>
          <b>auto           if</b>

Ключевое слово  <b>entry</b>  в  настоящее  время  не  используется
каким-либо компилятором; оно зарезервировано для использова-
ния в будущем. В некоторых реализациях  резервируются  также
слова <b>fortran</b> и <b>asm</b>.

<ul><a name=4></a><h2>2.2.  Константы</h2></ul>

     Имеется несколько видов констант,  которые  перечислены
ниже.

<ul><a name=5></a><h2>2.2.1.  Целые константы</h2></ul>

     Целая константа, состоящая из последовательности  цифр,
считается  восьмеричной,  если  она  начинается  с  0 (цифра
нуль), и десятичной в противном случае. Цифры 8  и  9  имеют
восьмеричные  значения   10  и 11 соответственно. Последова-
тельность цифр, которой предшествуют символы  <b>0х</b>  (нуль,  <b>х</b>-
маленькое)  или  <b>0х</b>  (нуль  <b>X</b>-большое),  рассматривается как
шестнадцатиричное целое.  Шестнадцатиричные  цифры  включают
буквы  от <b>a</b> (маленькое) или <b>A</b> (большое) до <b>f</b> (маленькое) или
<b>F</b> (большое) со значениями от 10 до 15. Десятичная константа,
величина которой превышает наибольшее машинное целое со зна-
ком, считается длинной; восьмеричная  или  шестнадцатиричная
константа,  которая  превышает наибольшее машинное целое без
знака, также считается длинной.

<ul><a name=6></a><h2>2.2.2.  Длинные (long) константы</h2></ul>

     Десятичная, восьмеричная  или  шестнадцатиричная  конс-
танта,  за которой непосредственно следует <b>l</b> (эль-маленькое)
или <b>L</b> (эль-большое), является длинной константой. На некото-
рых  машинах  целые и длинные значения могут рассматриваться
как идентичные.

<ul><a name=7></a><h2>2.2.3.  Символьные константы</h2></ul>

     Символьная константа - это символ, заключенный  в  оди-
ночные  кавычки,  как,  например,  '<b>х</b>'. Значением символьной
константы является численное значение этого символа в машин-
ном представлении набора символов.

                            <b>-4-</b>


     Некоторые неграфические символы, одиночная кавычка <b>'</b>  и
обратная  косая черта <b>\</b> могут быть представлены двумя симво-
лами в соответствии со следующей таблицей условных  последо-
вательностей:

      Название                 Код  Обозначение

     новая строка              012     <b>\n</b>
     горизонтальная табуляция  011     <b>\т</b>
     символ возврата на одну   010     <b>\в</b>
     позицию
     возврат каретки           015     <b>\r</b>
     переход на новую страницу 014     <b>\f</b>
     обратная косая черта      0133    <b>\\</b>
     одиночная кавычка         047     <b>\'</b>
     произвольный символ      0ddd     <b>\ddd</b>


     Условная последовательность <b>\ddd</b>  состоит  из  обратной
косой  черты,  за  которой  следуют  1, 2 или 3 восьмеричных
цифры, которые рассматриваются как задающие значение  желае-
мого  символа. Специальным случаем этой конструкции является
последовательность <b>\0</b> (за нулем не следует  цифра),  которая
определяет  нулевой символ. Если следующий за обратной косой
чертой символ не совпадает с одним из указанных, то обратная
косая черта игнорируется.

<ul><a name=8></a><h2>2.2.4.  Вещественные константы</h2></ul>

     Вещественная константа состоит из целой части, десятич-
ной  точки,  дробной части, буквы <b>e</b> (маленькая) или <b>E</b> (боль-
шая) и целой экспоненты с необязательным знаком. Как  целая,
так  и дробная часть являются последовательностью цифр. Либо
целая, либо дробная часть (но не обе)  может  отсутствовать;
либо десятичная точка, либо <b>e</b>  и экспонента (но не то и дру-
гое одновременно) может отсутствовать.   Вещественные  конс-
танты в большинстве реализаций считаются константами двойной
точности.

<ul><a name=9></a><h2>2.3.  Строки</h2></ul>

     Строка - это последовательность символов, заключенная в
двойные кавычки, как, например, "...". Строка имеет тип <b>мас-</b>
<b>сив символов</b> и класс памяти <b>static</b> (см. ниже). Строка иници-
ализирована  указанными  в  ней  символами. Все строки, даже
идентично  записанные,  считаются  различными.    Компилятор
помещает  в конец каждой строки нулевой байт <b>\0</b>, с тем чтобы
просматривающая строку программа могла определить ее  конец.
Перед  стоящим внутри строки символом двойной кавычки <b>"</b> дол-
жен быть поставлен символ  обратной  косой  черты  <b>\</b>;  кроме
того,  могут  использоваться  те  же условные последователь-
ности, что и в символьных константах.  Обратная косая  черта
<b>\</b>,  за  которой непосредственно следует символ новой строки,


                            <b>-5-</b>


игнорируется.

     Имеются макропроцессорные средства, позволяющие объеди-
нять  совпадающие  строки  при  трансляции  с целью экономии
памяти (см. команду <b>xstr</b>).

<ul><a name=10></a><h2>2.4.  Характеристики аппаратных средств</h2></ul>

     Следующая ниже  таблица  суммирует  некоторые  свойства
аппаратного  оборудования,  которые  меняются  от  машины  к
машине. Хотя они и  влияют  на  переносимость  программ,  на
практике  они  представляют  меньшую проблему, чем это может
казаться заранее.
                        Таблица 1.
          -----------------------------------------
          |         <b>CM-ЭВМ   IBM 370 (OS) VAX-11</b>  |
          |           <b>КОИ-8      ebcdic   ASCII</b>   |
          | <b>char</b>      8 бит      8 бит    8 бит   |
          | <b>int</b>       16         32       32      |
          | <b>short</b>     16         16       16      |
          | <b>long</b>      32         32       32      |
          | <b>float</b>     32         32       32      |
          | <b>double</b>    64         64       64      |
          | <b>range</b>   -38/+38     -76/+76   -76/+76 |
          |_______________________________________|

<ul><a name=11></a><h2> * 3.  ОБ'ЕКТЫ ЯЗЫКА СИ</h2></ul>

<ul><a name=12></a><h2>3.1.  Интерпретация идентификаторов</h2></ul>

     С каждым идентификатором в Си связано два атрибута: его
класс  памяти  и  его  тип.  Класс памяти определяет место и
время хранения  памяти,  связанной  с  идентификатором;  тип
определяет смысл величин, находящихся в памяти, определенной
под идентификатором.

     Имеются четыре класса памяти: автоматическая, статичес-
кая,  внешняя и регистровая. Автоматические переменные явля-
ются локальными для каждого  вызова  блока  и  исчезают  при
выходе  из  этого  блока.  Статические  переменные  являются
локальными, но сохраняют свои значения даже после того,  как
управление  передается  за пределы блока. Внешние переменные
существуют и сохраняют свои значения  в  течение  выполнения
всей  программы и могут использоваться для связи между функ-
циями, в том  числе  и  между  независимо  скомпилированными
функциями.  Регистровые  переменные  хранятся (если это воз-
можно) в быстрых регистрах  машины;  подобно  автоматическим
переменным они являются локальными для каждого блока и исче-
зают при выходе из этого блока.

     В  языке  Си  предусмотрено  несколько  основных  типов
объектов:

                            <b>-6-</b>


Символьный.
     - Объекты, описанные  как  символы  (<b>char</b>),  достаточно
       велики,  чтобы хранить любой член из соответствующего
       данной реализации внутреннего набора символов, и если
       действительный  символ  из этого набора символов хра-
       нится в символьной переменной, то ее значение эквива-
       лентно  целому коду этого символа. В символьных пере-
       менных можно хранить и другие величины, но реализация
       будет машинно-зависимой. (На СМ ЭВМ значение символь-
       ных переменных изменяется от -0177 до 0177.)

Целый.
     - Можно использовать до трех размеров целых,  описывае-
       мых  как  <b>short  int</b>,  <b>int</b> и <b>long int</b>.  Длинные целые
       занимают не меньше памяти, чем короткие, но  в  конк-
       ретной  реализации может оказаться, что либо короткие
       целые, либо длинные целые, либо  те  и  другие  будут
       эквивалентны  простым  целым.   "Простые" целые имеют
       естественный размер,  предусматриваемый  архитектурой
       используемой  машины;  другие  размеры  вводятся  для
       удовлетворения специальных потребностей.

Беззнаковый.
     - Целые без знака, описываемые как  <b>unsigned</b>,  подчиня-
       ются законам арифметики по модулю 2**n, где n - число
       битов в их представлении.  (На CM-ЭВМ  длинные  вели-
       чины без знака не предусмотрены).

Вещественный.
     - Вещественные одинарной точности (<b>float</b>) и  веществен-
       ные двойной точности (<b>double</b>) в некоторых реализациях
       могут быть синонимами.  (На СМ ЭВМ float занимает  32
       бита памяти, а <b>double</b> - 64).

В языке нет логического типа данных, а в качестве логических
значений  используются  целые  "0" - "ложь" и "1" - "истина"
(при проверках любое целое,  не  равное  0,  трактуется  как
"истина").

     Поскольку объекты  упомянутых  выше  типов  могут  быть
разумно  интерпретированы  как  числа,  эти типы будут назы-
ваться арифметическими.  Типы <b>char</b> и <b>int</b> всех размеров  сов-
местно будут называться целочисленными.  Типы float и <b>double</b>
совместно будут называться вещественными типами.

     Кроме основных арифметических типов существует  концеп-
туально бесконечный класс производных типов, которые образу-
ются из основных типов следующим образом:

     - массивы объектов большинства типов;

     - функции, которые возвращают объекты заданного типа;

                            <b>-7-</b>


     - указатели на объекты данного типа;

     - структуры,  содержащие  последовательность   объектов
       различных типов;

     - объединения, способные содержать один  из  нескольких
       объектов различных типов.

     Вообще говоря, эти  методы  построения  объектов  могут
применяться рекурсивно.

<ul><a name=13></a><h2>3.2.  Объекты и l_значения</h2></ul>

     Объект является доступным  обработке  участком  памяти;
l_значение  (левое значение) - это выражение, ссылающееся на
объект. Очевидным  примером  выражения  l_значения  является
идентификатор.   Существуют  операции,  результатом  которых
являются l_значения; если, например, <b>e</b> - выражение типа ука-
затель, то <b>*</b><b>e</b> является выражением l_значения, ссылающимся на
тот объект, на который указывает е.   Название  "l_значение"
происходит  от выражения присваивания <b>e1</b>=<b>e2</b>, в котором левая
часть должна быть  выражением  l_значения.  При  последующем
обсуждении каждой операции будет указываться, ожидает ли она
операндов l_значения и выдает ли она l_значение.

<ul><a name=14></a><h2>3.3.  Преобразования</h2></ul>

     Ряд операций может в  зависимости  от  своих  операндов
вызывать  преобразование  значения операнда из одного типа в
другой. В этом разделе объясняются результаты, которые  сле-
дует  ожидать  от  таких  преобразований. В конце подводятся
итоги преобразований, требуемые большинством обычных  опера-
ций; эти сведения дополняются необходимым образом при обсуж-
дении каждой операции.

<ul><a name=15></a><h2>3.3.1.  Символы и целые</h2></ul>

     Символ или короткое целое можно использовать всюду, где
можно  использовать целое. Во всех случаях значение преобра-
зуется  к целому.  Преобразование более короткого  целого  к
более  длинному  всегда сопровождается знаковым расширением;
целые являются величинами со знаком.  Осуществляется или нет
знаковое  расширение  для  символов, зависит от используемой
машины, на СМ-ЭВМ такое преобразование  осуществляется  так,
что  русские буквы при прямом преобразовании получат отрица-
тельные коды.  Область  значений  символьных  переменных  на
CM-ЭВМ  меняется  от  -128  до  127; символы из набора ASCII
имеют положительные значения.  Символьная константа,  задан-
ная с помощью восьмеричной условной последовательности, под-
вергается знаковому расширению и может оказаться отрицатель-
ной; например, '<b>\</b>377' имеет значение -1.

                            <b>-8-</b>


     Когда более длинное целое преобразуется в более  корот-
кое  или  в  <b>char</b>,  оно обрезается слева; лишние биты просто
отбрасываются.

<ul><a name=16></a><h2>3.3.2.  Типы float и double</h2></ul>

     Вся вещественная арифметика в Си выполняется с  двойной
точностью.  Каждый раз, когда объект типа <b>float</b> появляется в
выражении, он удлиняется до  <b>double</b>  посредством  добавления
нулей  в  его дробную часть. Когда объект типа <b>double</b> должен
быть преобразован к типу <b>float</b>, например, при  присваивании,
перед усечением <b>double</b> округляется до длины <b>float</b>.

     Единственное исключение может быть сделано в компилято-
рах  для ЭВМ, на которых нет аппаратных операций над числами
типа <b>double</b> (например, СМ-4).  Уточнить это можно по  описа-
нию компилятора (команда <b>cc</b>).

<ul><a name=17></a><h2>3.3.3.  Вещественные и целочисленные величины</h2></ul>

     Преобразование вещественных значений  к  целочисленному
типу в некоторой степени машинно-зависимо; в частности, нап-
равление усечения отрицательных чисел меняется от  машине  к
машине.  Результат не определен, если значение не помещается
в предоставляемое пространство.

     Преобразование целочисленных  значений  в  вещественные
выполняется без осложнений. Может произойти некоторая потеря
точности, если для результата не хватит длины мантиссы.

<ul><a name=18></a><h2>3.3.4.  Указатели и целые</h2></ul>

     Целое или длинное целое может быть прибавлено к  указа-
телю или вычтено из него; в этом случае первая величина пре-
образуется так, как указывается в  описании операции  сложе-
ния.

     Два указателя на объекты одинакового  типа  могут  быть
вычтены; в этом случае результат преобразуется к целому, как
указывается в описании операции вычитания.

<ul><a name=19></a><h2>3.3.5.  Целое без знака</h2></ul>

     Всякий раз, когда целое без знака объединяется с  прос-
тым  целым,  простое целое преобразуется в целое без знака и
результат оказывается целым без  знака.  Значением  является
наименьшее целое без знака, соответствующее целому со знаком
(по  модулю  2**размер  слова).  В  двоичном  дополнительном
представлении  это преобразование является чисто умозритель-
ным и не изменяет фактическую комбинацию битов.

     Когда целое без знака преобразуется к типу <b>long</b>, значе-
ние  результата  совпадает  со  значением  целого без знака.


                            <b>-9-</b>


Таким образом,  это  преобразование  сводится  к  добавлению
нулей слева.

<ul><a name=20></a><h2>3.3.6.  Арифметические преобразования</h2></ul>

     Подавляющее большинство операций вызывает  преобразова-
ние и определяет типы результата аналогичным образом. Приво-
димая ниже схема в  дальнейшем  будет  называться  "обычными
арифметическими  преобразованиями".   Сначала любые операнды
типа <b>char</b> или <b>short</b> преобразуются в <b>int</b>,  а  любые  операнды
типа  <b>float</b>  преобразуются в <b>double</b>.  Затем, если какой-либо
операнд имеет тип <b>double</b>, то  другой  преобразуется  к  типу
<b>double</b>,  и  это будет типом результата.  В противном случае,
если какой-либо операнд имеет тип <b>long</b>,  то  другой  операнд
преобразуется  к  типу <b>long</b>, и это и будет типом результата.
В  противном  случае,  если  какой-либо  операнд  имеет  тип
<b>unsigned</b>, то другой операнд преобразуется к типу <b>unsigned</b>, и
это будет типом результата.  В противном случае оба операнда
будут иметь тип <b>int</b>, и это будет типом результата.

<ul><a name=21></a><h2> * 4.  ВЫРАЖЕНИЯ</h2></ul>

     Старшинство операций в выражениях совпадает с  порядком
следования  основных подразделов настоящего раздела, начиная
с самого высокого уровня старшинства. Так, например, выраже-
ниями, указываемыми в качестве операндов операции <b>+</b> (п.0.4),
являются выражения, определенные в п.п.0.1-0.3. Внутри  каж-
дого  подраздела  операции  имеют  одинаковое старшинство. В
каждом подразделе для описываемых там  операций  указывается
их  ассоциативность слева или справа. Старшинство и ассоциа-
тивность всех операций в выражениях резюмируются в граммати-
ческой сводке в приложении.

     В противном  случае  порядок  вычислений  выражений  не
определен.  В частности, компилятор может вычислять подвыра-
жения в том порядке, который он находит  наиболее  эффектив-
ным,  даже  если эти подвыражения приводят к побочным эффек-
там. Порядок, в котором происходят побочные эффекты, не спе-
цифицируется. Выражения, включающие коммутативные и ассоциа-
тивные операции (<b>*</b>,<b>+</b>,<b>&</b>,<b>|</b>,<b>^</b>), могут быть переупорядочены про-
извольным  образом  даже  при наличии круглых скобок; в этом
случае необходимо использовать явные промежуточные  перемен-
ные.

     При вычислении выражений обработка переполнения и  про-
верка  при  делении являются машинно-зависимыми. Большинство
реализаций языка Си (в том числе и в  <b>ОС  ДЕМОС</b>)  игнорируют
переполнение  целых; обработка ошибки при делении на 0 и при
всех особых случаях  в  операциях  с  вещественными  числами
меняется  от  машины к машине и обычно выполняется с помощью
библиотечной функции.

                            <b>-10-</b>


<ul><a name=22></a><h2>4.1.  Первичные выражения</h2></ul>

     Первичные выражения, включающие  <b>.</b>,  <b>-</b>>,  индексацию  и
обращения к функциям, группируются слева направо.

    <b>первичное выражение</b>:
       <b>идентификатор</b>
       <b>константа</b>
       <b>строка</b>
       (<b>выражение</b>)
       <b>первичное</b>_<b>выражение</b>  [<b>выражение</b>]
       <b>первичное</b>_<b>выражение</b>  (<b>список</b>_<b>выражений</b>)
                                           <b>необ</b>
       <b>первичное</b>_<b>l</b>_<b>значение</b> <b>.</b> <b>Идентификатор</b>
       <b>первичное</b>_<b>выражение</b> <b>-</b>> <b>идентификатор</b>
    <b>список</b>_<b>выражений</b>:
       <b>выражение</b>
       <b>список</b>_<b>выражений</b>, <b>выражение</b>

Идентификатор является первичным выражением при условии, что
он  описан подходящим образом, как это обсуждается ниже. Тип
идентификатора определяется  его  описанием.  Если,  однако,
типом идентификатора является <b>массив</b> ..., то значением выра-
жения, состоящего из этого идентификатора,  является  указа-
тель  на  первый  объект  в  этом массиве, а типом выражения
будет <b>указатель на</b> .... Более того, идентификатор массива не
является выражением l_значения. Подобным образом интерпрети-
руется идентификатор, который описан как <b>функция</b>, <b>возвращаю-</b>
<b>щая</b> .... За исключением того случая, когда он используется в
позиции имени функции при обращении, преобразуется в  <b>указа-</b>
<b>тель на функцию</b>, <b>которая возвращает</b> ....

     Константа является первичным выражением. В  зависимости
от ее формы типом константы может быть <b>int</b>, <b>long</b> или <b>double</b>.

     Строка является первичным выражением. Исходным ее типом
является  <b>массив  символов</b>; но следуя тем же самым правилам,
которые приведены выше для идентификаторов,  он  модифициру-
ется  в  <b>указатель на символы</b>, и результатом является указа-
тель на первый символ строки.  (Имеется исключение в некото-
рых инициализаторах; см. ниже.)

     Выражение в круглых скобках является первичным  выраже-
нием,  тип  и  значение  которого  идентичны типу и значению
этого выражения без скобок.  Наличие круглых скобок не  вли-
яет на то, является ли выражение l_значением или нет.

     Первичное выражение, за  которым  следует  выражение  в
квадратных скобках, является первичным выражением. Это выра-
жение с индексом. Обычно первичное выражение имеет тип  <b>ука-</b>
<b>затель  на</b>  ...,  индексное выражение имеет тип <b>int</b>, а типом
результата является "...".  Выражение <b>e1</b>[<b>e2</b>] по  определению
идентично  выражению  <b>*</b> ((<b>e1</b>)  <b>+</b> (<b>e2</b>)).  Все, что необходимо


                            <b>-11-</b>


для понимания этой записи, содержится в этом  разделе;  воп-
росы,  связанные с понятием идентификаторов и операций <b>*</b> и <b>+</b>
рассматриваются в п.п. 0.1, 0.2 и 0.4 соответственно; выводы
суммируются ниже.

     Обращение к функции является первичным  выражением,  за
которым следует заключенный в круглые скобки возможно пустой
список выражений, разделенных запятыми, которые и  представ-
ляют  собой фактические аргументы функции. Первичное выраже-
ние должно быть типа <b>функция</b>, <b>возвращающая</b> ..., а  результат
обращения  к функции имеет тип "...".  Как указывается ниже,
ранее не встречавщийся идентификатор, за которым непосредст-
венно  следует  левая круглая скобка, считается описанным по
контексту, как представляющий функцию,  возвращающую  целое;
следовательно чаще всего встречающийся случай функции, возв-
ращающей целое значение, не нуждается в описании.

     Перед обращением любые фактические аргументы типа <b>float</b>
преобразуются  к  типу <b>double</b>, любые аргументы типа <b>char</b> или
<b>short</b> преобразуются к типу <b>int</b>, и, как обычно, имена  масси-
вов преобразуются в указатели. Никакие другие преобразования
не выполняются автоматически; в частности,  не  сравниваются
типы  фактических аргументов с типами формальных аргументов.
Если преобразование необходимо, используйте явное преобразо-
вание.

     При подготовке к вызову функции делается копия  каждого
фактического параметра; таким образом, все передачи аргумен-
тов в языке Си осуществляются строго  по  значению.  Функция
может  изменять значения своих формальных параметров, но эти
изменения не влияют на значения  фактических  параметров.  С
другой  стороны,  имеется  возможность передавать указатель,
при этом функция может изменять значение объекта, на который
этот  указатель  указывает.  Порядок вычисления аргументов в
языке не определен; различные компиляторы вычисляют по  раз-
ному.

     Допускаются рекурсивные обращения к любой функции.

     Первичное выражение, за которым следует точка и иденти-
фикатор,  является  выражением. Первое выражение должно быть
l_значением, именующим структуру или объединение, а  иденти-
фикатор  должен быть именем члена структуры или объединения.
Результатом является l_значение, ссылающееся на  поименован-
ный член структуры или объединения.

     Первичное выражение, за которым следует  стрелка  (сос-
тавленная из знаков <b>-</b> и >) и идентификатор, является выраже-
нием. Первое выражение должно быть указателем  на  структуру
или  объединение, а идентификатор должен именовать член этой
структуры или объединения. Результатом является  l_значение,
ссылающееся на поименованный член структуры или объединения,
на который указывает указательное выражение.


                            <b>-12-</b>


     Следовательно, выражение <b>e1</b><b>-</b>><b>mos</b> является тем же самым,
что  и выражение (<b>*</b><b>e1</b>)<b>.</b><b>mos</b>. Структуры и объединения рассмат-
риваются  ниже.   Приведенные  здесь  правила  использования
структур  и  объединений  не  навязываются  строго, для того
чтобы иметь возможность обойти механизм типов (см.   "Допол-
нительная информация о типах").

<ul><a name=23></a><h2>4.2.  Унарные операции</h2></ul>

     Выражение с  унарными  операциями  группируется  справа
налево.

       <b>унарное</b>_<b>выражение</b>:
                 <b>*</b>  <b>выражение</b>
                 <b>&</b>  <b>l</b>_<b>значение</b>
                 <b>-</b>  <b>выражение</b>
                 <b>!</b>  <b>выражение</b>
                 <b>~</b>  <b>выражение</b>
                 <b>++</b> <b>l</b>_<b>значение</b>
                 <b>--</b> <b>l</b>_<b>значение</b>
                 <b>l</b>_<b>значение</b> <b>++</b>
                 <b>l</b>_<b>значение</b> <b>--</b>
                 <b>(</b><b>имя</b>-<b>типа</b>) <b>выражение</b>
                 <b>sizeof</b>     <b>выражение</b>
                 <b>sizeof</b>    (<b>имя</b>_<b>типа</b>)

Унарная операция <b>*</b> означает косвенную  адресацию:  выражение
должно  быть  указателем, а результатом является l_значение,
ссылающееся на тот объект, на который  указывает  выражение.
Если  типом  выражения  является  <b>указатель на</b> ..., то типом
результата будет "...".

     Результатом унарной операции <b>&</b>  является  указатель  на
объект,  к  которому  ссылается  l_значение. Если l_значение
имеет тип "...", то типом результата будет <b>указатель на</b> ....

     Результатом унарной операции <b>-</b> (минус) является ее опе-
ранд,  взятый  с  противоположным  знаком. Для величины типа
<b>unsigned</b> результат получается вычитанием ее значения из 2**n
(два в степени n), где n-число битов в <b>int</b>. Унарной операции
<b>+</b> (плюс) не существует.

     Результатом операции логического отрицания  <b>!</b>  является
1,  если значение ее операнда равно 0, и 0, если значение ее
операнда отлично от нуля.  Результат имеет тип <b>int</b>. Эта опе-
рация  применима  к любому арифметическому типу или указате-
лям.

     Операция <b>~</b> (символ "тильда", находится на клавише  <b>^</b>  в
нижнем  регистре)  дает обратный код (или дополнение до еди-
ницы) своего операнда.  Выполняются  обычные  арифметические
преобразования. Операнд должен быть целочисленного типа.

                            <b>-13-</b>


     Объект, на который ссылается  операнд  l_значения  пре-
фиксной операции <b>++</b>, увеличивается. Значением является новое
значение операнда, но это не l_значение. Выражение <b>++</b><b>х</b> экви-
валентно <b>х</b> <b>+=</b> 1 . Информацию о преобразованиях смотри в раз-
боре операции сложения (п. 0.4) и операции присваивания  (п.
0.14).

     Префиксная операция <b>--</b> аналогична  префиксной  операции
<b>++</b>, но приводит к уменьшению своего операнда l_значения.

     При применении постфиксной  операции  <b>++</b>  к  l_значению
результатом  является значение объекта, на который ссылается
l_значение. После того, как  результат  принят  к  сведению,
объект  увеличивается точно таким же образом, как и в случае
префиксной операции <b>++</b>. Результат имеет тот же  тип,  что  и
выражение l_значения.

     При применении постфиксной  операции  <b>--</b>  к  l_значению
результатом  является значение объекта, на который ссылается
l_значение. После того, как  результат  принят  к  сведению,
объект  уменьшается  точно  таким же образом, как и в случае
префиксной операции <b>--</b>. Результат имеет тот же  тип,  что  и
выражение l_значения.

     Заключенное в круглые скобки имя типа  данных,  стоящее
перед  выражением,  вызывает  преобразование  значения этого
выражения  к указанному типу.   Эта  конструкция  называется
перевод (cast). Имена типов описываются в следующем разделе.

     Операция <b>sizeof</b> выдает размер своего операнда в  байта.
(Понятие  байт в языке не определено, разве только, как зна-
чение операции <b>sizeof</b>. Однако во всех существующих  реализа-
циях  байтом является пространство, необходимое для хранения
объекта типа <b>char</b>). При  применении  к  массиву  результатом
является  полное число байтов в массиве. Размер определяется
из описаний объектов в выражении. Это выражение семантически
является  целой константой и может быть использовано в любом
месте, где требуется константа. Основное применение эта опе-
рация  находит при вызове процедур, подобных распределителям
памяти, и в системах ввода- вывода.

     Операция <b>sizeof</b> может быть также применена и  к  заклю-
ченному  в  круглые  скобки  имени  типа.  В этом случае она
выдает размер в байтах объекта указанного типа.

     Конструкция <b>sizeof</b> (тип) рассматривается как целое, так
что   выражение   <b>sizeof</b> (<b>тип</b>) - 2   эквивалентно  выражению
(<b>sizeof</b> (<b>тип</b>)) - 2.

<ul><a name=24></a><h2>4.3.  Мультипликативные операции</h2></ul>

     Мультипликативные операции <b>*</b>, <b>/</b>, и <b>%</b> группируются слева
направо.  Выполняются обычные арифметические преобразования.


                            <b>-14-</b>


       <b>мультипликативное</b>_<b>выражение</b>:
                <b>выражение</b> <b>*</b> <b>выражение</b>
                <b>выражение</b> <b>/</b> <b>выражение</b>
                <b>выражение</b> <b>%</b> <b>выражение</b>


     Бинарная операция <b>*</b>  означает  умножение.   Операция  <b>*</b>
ассоциативна, и выражения с несколькими умножениями на одном
и том же уровне могут быть перегруппированы компилятором.

     Бинарная операция <b>/</b> означает деление. При делении поло-
жительных  целых  осуществляется  усечение  по направлению к
нулю, но если один из операндов отрицателен, то форма усече-
ния  зависит  от  используемой машины.  Остаток имеет тот же
знак, что и делимое.  Всегда  справедливо,  что  (<b>a</b><b>/</b><b>b</b>)<b>*</b><b>b</b><b>+</b><b>a</b><b>%</b><b>b</b>
равно <b>a</b> (если <b>b</b> не равно 0).

     Бинарная операция <b>%</b> выдает остаток от  деления  первого
выражения на второе. Выполняются обычные арифметические пре-
образования. Операнды должны быть целого типа.

<ul><a name=25></a><h2>4.4.  Аддитивные операции</h2></ul>

     Аддитивные операции <b>+</b> и <b>-</b> группируются  слева  направо.
Выполняются  обычные арифметические преобразования. Для каж-
дой операции имеются некоторые  дополнительные  возможности,
связанные с типами операндов.

         <b>аддитивное</b>_<b>выражение</b>:
              <b>выражение</b> <b>+</b> <b>выражение</b>
              <b>выражение</b> <b>-</b> <b>выражение</b>


Результатом операции <b>+</b> является сумма операндов. Можно также
складывать  указатель  на объект в массиве и значение любого
целочисленного типа.   Последнее  преобразуется  в  адресное
смещение  посредством  умножения  его  на  длину объекта, на
который указывает этот указатель. Результатом является  ука-
затель  того же самого типа, что и исходный указатель, кото-
рый указывает на другой объект в том же  массиве,  смещенный
соответствующим    образом    относительно   первоначального
объекта. Таким образом, если <b>p</b> является указателем объекта в
массиве,  то  выражение <b>p</b><b>+</b>1 является указателем на следующий
объект в этом массиве.

     Никакие другие комбинации типов для указателей не  раз-
решаются.

     Операция <b>+</b> ассоциативна, и выражение с несколькими сло-
жениями  на одном и том же уровне могут быть переупорядочены
компилятором.

                            <b>-15-</b>


     Результатом операции  <b>-</b>  является  разность  операндов.
Выполняются  обычные  арифметические  преобразования.  Кроме
того, из указателя может быть вычтено значение любого  цело-
численного типа, причем, проводятся те же самые преобразова-
ния, что и при операции сложения.

     Если вычитаются два указателя  на  объекты  одинакового
типа, то результат преобразуется (делением на длину объекта)
к типу <b>int</b>, представляя собой  число  объектов,  разделяющих
указываемые  объекты.  Если  эти  указатели не на объекты из
одного и того же массива, то  такое  преобразование,  вообще
говоря,  даст неожиданные результаты, потому что даже указа-
тели на объекты одинакового типа не  обязаны  отличаться  на
величину, кратную длине объекта.

<ul><a name=26></a><h2>4.5.  Операции сдвига</h2></ul>

     Операции сдвига <b>&lt;</b><b>&lt;</b> и  >>  группируются  слева  направо.
Для  обеих операций проводятся обычные арифметические преоб-
разования их операндов, каждый из которых должен быть целого
типа. Затем правый операнд преобразуется к типу <b>int</b>; резуль-
тат имеет тип левого операнда. Результат не определен,  если
правый  операнд  отрицателен или больше или равен, чем длина
объекта в битах.

         <b>выражение</b>_<b>сдвига</b>:
              <b>выражение</b> <b>&lt;</b><b>&lt;</b> <b>выражение</b>
              <b>выражение</b> >> <b>выражение</b>

Значением выражения <b>e1</b><b>&lt;</b><b>&lt;</b><b>e2</b> является <b>e1</b> (интерпретируемое как
комбинация  битов), сдвинутое влево на <b>e2</b> битов; освобождаю-
щиеся биты заполняются  нулем.  Значением  выражения  <b>e1</b>>><b>e2</b>
является <b>e1</b>, сдвинутое вправо на <b>e2</b> битовых позиций. Если <b>e1</b>
имеет тип <b>unsigned</b>, то  сдвиг  вправо  гарантированно  будет
логическим  (заполнение  нулем);  в  противном  случае сдвиг
может быть (как на CM-ЭВМ)  арифметическим  (освобождающиеся
биты заполняются копией знакового бита).

<ul><a name=27></a><h2>4.6.  Операции отношения</h2></ul>

     Операции отношения группируются слева направо, но  этот
факт не очень полезен; выражение <b>a</b><b>&lt;</b><b>b</b><b>&lt;</b><b>c</b> не означает того, что
оно ,казалось бы, должно означать, а означает ((<b>a</b><b>&lt;</b><b>b</b>)<b>&lt;</b><b>c</b>).

         <b>выражение</b>_<b>отношения</b>:
              <b>выражение</b> <b>&lt;</b> <b>выражение</b>
              <b>выражение</b> > <b>выражение</b>
              <b>выражение</b> <b>&lt;</b><b>=</b> <b>выражение</b>
              <b>выражение</b> ><b>=</b> <b>выражение</b>

Операции <b>&lt;</b> (меньше), > (больше), <b>&lt;</b><b>=</b> (меньше или равно) и  ><b>=</b>
(больше  или равно)  дают 0, если указанное отношение ложно,
и 1, если оно истинно. Результат имеет тип <b>int</b>.  Выполняются


                            <b>-16-</b>


обычные  арифметические  преобразования.  Могут сравниваться
два указателя; результат зависит от относительного  располо-
жения  указываемых объектов в адресном пространстве. Сравне-
ние указателей переносимо только в том случае,  если  указа-
тели указывают на объекты из одного и того же массива.

<ul><a name=28></a><h2>4.7.  Операции равенства</h2></ul>

         <b>выражение</b>_<b>равенства</b>:
              выражение <b>==</b> <b>выражение</b>
              <b>выражение</b> <b>!=</b> <b>выражение</b>

Операции <b>==</b> (равно) и <b>!=</b> (не равно)  в  точности  аналогичны
операциям  отношения,  за  исключением  того,  что они имеют
более низкий уровень старшинства. (поэтому значение  выраже-
ния  <b>a</b><b>&lt;</b><b>b</b><b>==</b><b>c</b><b>&lt;</b><b>d</b>  равно 1 всякий раз, когда выражения <b>a</b><b>&lt;</b><b>b</b> и <b>c</b><b>&lt;</b><b>d</b>
имеют одинаковое значение истинности).

     Указатель можно сравнивать с целым, но результат  будет
машинно-независимым только в том случае, если целым является
константа 0.  Гарантируется, что указатель, которому присво-
ено  значение 0, не указывает ни на какой объект  и на самом
деле оказывается равным 0; общепринято считать такой  указа-
тель нулем.

<ul><a name=29></a><h2>4.8.  Побитовая операция 'и'</h2></ul>

         <b>выражение</b>_<b>и</b>:
              <b>выражение</b> <b>&</b> <b>выражение</b>

Операция <b>&</b> является ассоциативной, и включающие <b>&</b>  выражения
могут  быть переупорядочены компилятором.  Выполняются обыч-
ные  арифметические  преобразования;  результатом   является
побитовая  функция  '<b>и</b>'  операндов.  Эта  операция применима
только к операндам целого типа.

<ul><a name=30></a><h2>4.9.  Побитовая операция исключающего 'или'</h2></ul>

         <b>выражение</b>_<b>исключающего</b>_<b>или</b>:
              <b>выражение</b> <b>^</b> <b>выражение</b>

Операция <b>^</b> (знак надчеркивания, код в КОИ-8  0136)  является
ассоциативной,  и включающие <b>^</b> выражения могут быть переупо-
рядочены компилятором.  Выполняются  обычные  арифметические
преобразования;  результатом является побитовая функция иск-
лючающего '<b>или</b>' операндов.  Операция применима только к опе-
рандам целочисленного типа.

<ul><a name=31></a><h2>4.10.  Побитовая операция включающего 'или'</h2></ul>

         <b>выражение</b>_<b>включающего</b>_<b>или</b>:
              <b>выражение</b> <b>|</b> <b>выражение</b>

                            <b>-17-</b>


Операция <b>|</b> является ассоциативной, и содержащие <b>|</b>  выражения
могут быть переупорядочены. Выполняются обычные арифметичес-
кие преобразования; результатом является  побитовая  функция
включающего  '<b>или</b>'  операндов.   Операция применима только к
операндам целочисленного типа.

<ul><a name=32></a><h2>4.11.  Логическая операция 'и'</h2></ul>

         <b>выражение</b>_<b>логического</b>_<b>и</b>:
              <b>выражение</b> <b>&&</b> <b>выражение</b>

Операция <b>&&</b> группируется слева направо.  Она  возвращает  1,
если  оба  ее операнда отличны от нуля, и 0 в противном слу-
чае. В отличие от <b>&</b> операция <b>&&</b> гарантирует вычисление слева
направо;  более того, если первый операнд равен 0, то значе-
ние второго операнда вообще не вычисляется.

     Операнды не обязаны быть одинакового типа, но каждый из
них должен быть либо одного из основных типов, либо указате-
лем.  Результат всегда имеет тип <b>int</b>.

<ul><a name=33></a><h2>4.12.  Операция логического 'или'</h2></ul>

             <b>выражение</b>_<b>логического</b>_<b>или</b>:
                  <b>выражение</b> <b>||</b> <b>выражение</b>

<b>Операция ||</b> группируется слева направо.  Она  возвращает  1,
если один из операндов отличен от нуля, и 0 в противном слу-
чае. В отличие от операции <b>|</b> операция <b>||</b> гарантирует  вычис-
ление слева направо; более того, если первый операнд отличен
от нуля, то значение второго операнда вообще не вычисляется.

     Операнды не обязаны быть одинакового типа, но каждый из
них должен быть либо одного из основных типов, либо указате-
лем. Результат всегда имеет тип <b>int</b>.

<ul><a name=34></a><h2>4.13.  Условная операция</h2></ul>

       <b>условное</b>_<b>выражение</b>:
            <b>выражение</b> <b>?</b> <b>выражение</b> : <b>выражение</b>

Условные выражения группируются слева  направо.  Вычисляется
значение  первого  выражения, и если оно отлично от нуля, то
результатом будет значение второго  выражения;  в  противном
случае  результатом  будет значение третьего выражения. Если
это возможно, проводятся обычные арифметические преобразова-
ния,  с  тем,  чтобы  привести  второе  и третье выражения к
общему типу; в противном случае, если оба выражения являются
указателями одинакового типа, то результат имеет тот же тип;
в противном случае одно выражение должно быть указателем,  а
другое  -  константой  0, и результат будет иметь тип указа-
теля. Вычисляется только одно из второго и третьего  выраже-
ний.


                            <b>-18-</b>


<ul><a name=35></a><h2>4.14.  Операция присваивания</h2></ul>

     Имеется ряд операций присваивания,  каждая  из  которых
группируется  слева направо. Все операции требуют в качестве
своего левого операнда l_значение, а типом выражения присва-
ивания является тип его левого операнда. Значением выражения
присваивания является значение, хранимое  в  левом  операнде
после  того,  как  присваивание  уже  будет произведено. Две
части составной операции  присваивания  являются  отдельными
лексемами.

      <b>выражение</b>_<b>присваивания</b>:
              <b>l</b>_<b>значение</b> <b>=</b> <b>выражение</b>
              <b>l</b>_<b>значение</b> <b>+=</b> <b>выражение</b>
              <b>l</b>_<b>значение</b> <b>-=</b> <b>выражение</b>
              <b>l</b>_<b>значение</b> <b>*=</b> <b>выражение</b>
              <b>l</b>_<b>значение</b> <b>/=</b> <b>выражение</b>
              <b>l</b>_<b>значение</b> <b>%=</b> <b>выражение</b>
              <b>l</b>_<b>значение</b> >><b>=</b> <b>выражение</b>
              <b>l</b>_<b>значение</b> <b>&lt;</b><b>&lt;</b><b>=</b> <b>выражение</b>
              <b>l</b>_<b>значение</b> <b>&=</b> <b>выражение</b>
              <b>l</b>_<b>значение</b> <b>^=</b> <b>выражение</b>
              <b>l</b>_<b>значение</b> <b>|=</b> <b>выражение</b>


     Когда производится простое присваивание  '<b>=</b>',  значение
выражения  заменяет  значение  объекта, на которое ссылается
l_значение. Если оба операнда имеют арифметический  тип,  то
перед  присваиванием  правый  операнд  преобразуется  к типу
левого операнда.

     В выражение вида <b>e1 оп</b><b>=</b> <b>e2</b>, где <b>оп</b> - одна  из  перечис-
ленных     выше     операций,     эквивалентно     выражению
<b>e1</b> <b>=</b> <b>e1 оп</b> (<b>e2</b>), с тем отличием, что выражение  <b>e1</b>  вычисля-
ется  только  один раз. В случае операций <b>+=</b> и <b>-=</b> левый опе-
ранд может быть указателем, причем при этом  (целочисленный)
правый  операнд преобразуется таким образом, как объяснено в
п. 0.4; все правые операнды и  все  отличные  от  указателей
левые операнды должны иметь арифметический тип.

     Используемые в <b>ОС ДЕМОС</b>  компиляторы допускают присваи-
вание  указателя целому, целого указателю и указателя указа-
телю другого типа.  Такое присваивание является чистым копи-
рованием  без  каких-либо преобразований. Такое употребление
операций присваивания является непереносимым и может  приво-
дить к указателям, которые при использовании вызывают ошибки
адресации. Тем не менее гарантируется, что присваивание ука-
зателю  константы  0  дает  нулевой указатель, который можно
отличать от указателя на любой объект.

                            <b>-19-</b>


<ul><a name=36></a><h2>4.15.  Присваивание структуры</h2></ul>

     Структуры могут быть присвоены, а также переданы  функ-
циям  в  качестве  аргументов  и  возвращены функциями. Типы
участвующих операндов должны совпадать.

<ul><a name=37></a><h2>4.16.  Операция 'запятая<</h2></ul>

         <b>выражение</b>_<b>с</b>_<b>запятой</b>:
              <b>выражение</b> <b>,</b> <b>выражение</b>

Пара выражений, разделенных запятой, вычисляется слева  нап-
раво и значение левого выражения отбрасывается. Типом и зна-
чением результата является тип и значение правого  операнда.
Эта  операция  группируется  слева направо. В контексте, где
запятая имеет специальное значение, как, например, в  списке
фактических  аргументов функций  или в списках инициализато-
ров, операция запятая, описываемая  в  этом  разделе,  может
появляться только в круглых скобках; например, функция

           <b>f</b>(<b>a</b><b>,</b>(<b>t</b>=3<b>,</b><b>t</b>+2)<b>,</b><b>c</b>)

имеет три аргумента, второй из которых имеет значение 5.

<ul><a name=38></a><h2>4.17.  Старшинство и порядок вычисления.</h2></ul>

     В приводимой ниже таблице сведены правила старшинства и
ассоциативности  всех  операций.  Операции,  расположенные в
одной строке, имеют  один  и  тот  же  уровень  старшинства;
строки расположены в порядке убывания старшинства. Так, нап-
ример, операции <b>*</b>, "<b>/</b>" и "<b>%</b>" имеют одинаковый уровень  стар-
шинства, который выше, чем уровень операций "<b>+</b>" и "<b>-</b>".



                            <b>-20-</b>


                     Таблица 2
    ------------------------------------------
    | Оператор           |   Ассоциативность |
    |____________________|___________________|
    | <b>() [] -</b>> <b>.</b>         |   слева направо   |
    |____________________|___________________|
    |  <b>~   ++  --  -  f</b>  |   справа налево   |
    |(<b>type</b>)  <b>*  &  sizeof</b>|                   |
    |____________________|___________________|
    | <b>*  /  %</b>            |   слева направо   |
    |____________________|___________________|
    | <b>+  -</b>               |   слева направо   |
    |____________________|___________________|
    | <b>&lt;</b><b>&lt;</b>  >>             |   слева направо   |
    |____________________|___________________|
    | <b>&lt;</b>  <b>&lt;</b><b>=</b>  >  ><b>=</b>       |   слева направо   |
    |____________________|___________________|
    | <b>==  !=</b>             |   слева направо   |
    |____________________|___________________|
    | <b>&</b>                  |   слева направо   |
    |____________________|___________________|
    | <b>^</b>                  |   слева направо   |
    |____________________|___________________|
    | <b>|</b>                  |   слева направо   |
    |____________________|___________________|
    | <b>&&</b>                 |   слева направо   |
    |____________________|___________________|
    | <b>||</b>                 |   слева направо   |
    |____________________|___________________|
    | <b>?:</b>                 |   справа налево   |
    |____________________|___________________|
    | <b>=  +=  -=</b>  и т.п.  |   справа налево   |
    |____________________|___________________|
    | <b>,</b>                  |   слева направо   |
    |____________________|___________________|


     Отметим, что уровень старшинства  побитовых  логических
операций <b>&</b>, <b>^</b> и <b>|</b> ниже уровня операций <b>==</b> и <b>!=</b>. Это приводит
к тому, что  осуществляющие  побитовую  проверку  выражения,
подобные

            <b>if</b> ((<b>х</b> <b>&</b> <b>mask</b>) <b>==</b> 0) ...

для получения правильных результатов  должны  заключаться  в
круглые скобки, в противном случае оно будет понято так:

    <b>выражение:</b>    <b>x</b> <b>&</b>   <b>mask</b> <b>== 0</b>
    <b>понято как:</b>   <b>x</b> <b>& (</b> <b>mask</b> <b>== 0 )</b>

                            <b>-21-</b>


<ul><a name=39></a><h2> * 5.  ОПИСАНИЯ</h2></ul>

     Описания используются для указания интерпретации, кото-
рую язык Си будет давать каждому идентификатору; они не обя-
зательно резервируют память, соответствующую идентификатору.
Описания имеют форму

    <b>описание</b>:
      <b>спецификаторы</b>_<b>описания список</b>_<b>описателей</b>;
                                           <b>необ</b>

Описатели в списке описателей содержат описываемые идентифи-
каторы.   Спецификаторы описания представляют собой последо-
вательность  спецификаторов  типа  и  спецификаторов  класса
памяти.

     <b>спецификаторы</b>_<b>описания</b>:
         <b>с</b>_<b>типа с</b>_<b>описания</b>
                        <b>необ</b>
         <b>с</b>_<b>класса</b>_<b>памяти с</b>_<b>описания</b>
                                 <b>необ</b>
    где <b>c</b>_... - <b>спецификатор</b>_...

Список описателей должен быть согласованным в смысле, описы-
ваемом ниже.

<ul><a name=40></a><h2>5.1.  Спецификаторы класса памяти</h2></ul>

     ниже перечисляются спецификаторы класса памяти:

       <b>спецификатор</b>_<b>класса</b>_<b>памяти</b>:
                 <b>auto</b>
                 <b>static</b>
                 <b>extern</b>
                 <b>register</b>
                 <b>typedef</b>


     Спецификатор <b>typedef</b> не резервирует память и называется
"спецификатором  класса  памяти"  только  по  синтаксическим
соображениям; это обсуждается ниже.  Смысл различных классов
памяти был обсужден ранее (см. "Объекты языка Си").

     Описания  <b>auto</b>,  <b>static</b>  и  <b>register</b>  служат  также   в
качестве определений в том смысле, что они вызывают резерви-
рование нужного количества памяти.  В случае  <b>extern</b>  должно
присутствовать внешнее определение указываемых идентификато-
ров где то вне функции, в которой они описаны.

     Описание <b>register</b> лучше  всего  представлять  себе  как
описание  <b>auto</b>  вместе  с намеком компилятору, что описанные
таким образом переменные будут часто использоваться.  Эффек-
тивны  только несколько первых таких описаний. Кроме того, в


                            <b>-22-</b>


регистрах могут  храниться  только  переменные  определенных
типов;  на CM-ЭВМ это <b>int</b>, <b>char</b> или указатель.  Существует и
другое ограничение на использование регистровых  переменных:
к  ним нельзя применять операцию взятия адреса <b>&</b>. При разум-
ном использовании регистровых описаний можно ожидать получе-
ния  меньших по размеру и более быстрых программ, но в буду-
щем улучшение генерирования кодов может  сделать  их  ненуж-
ными.

     В компиляторе для СМ ЭВМ воспринимаются первые 3 описа-
ния <b>register</b> в каждой функции.

     Описание может содержать не более одного  спецификатора
класса  памяти.   Если  описание  не  содержит спецификатора
класса памяти, то считается, что  он  имеет  значение  <b>auto</b>,
если описание находится внутри некоторой функции, и <b>extern</b> в
противном случае.  Исключение:  функции  никогда  не  бывают
автоматическими.

<ul><a name=41></a><h2>5.2.  Спецификаторы типа</h2></ul>

     Ниже перечисляются спецификаторы типа.

    <b>спецификатор</b>_<b>типа</b>:
        <b>char</b>
        <b>short</b>
        <b>int</b>
        <b>long</b>
        <b>unsigned</b>
        <b>float</b>
        <b>double</b>
         <b>спецификатор</b>_<b>структуры</b>_<b>или</b>_<b>объединения</b>
         <b>спецификатор</b>_<b>перечисления</b>
         <b>определяющее</b>_<b>тип</b>_<b>имя</b>

Слова <b>long</b>, <b>short</b> и <b>unsigned</b> можно рассматривать как  прила-
гательные; допустимы следующие комбинации:

          <b>short int</b>
          <b>long int</b>
          <b>unsigned int</b>
          <b>long float</b>

Последняя комбинация означает то же, что и <b>double</b>. В осталь-
ном  описание  может содержать не более одного спецификатора
типа. Если описание не содержит спецификатора типа, то  счи-
тается, что он имеет значение <b>int</b>.

     Спецификаторы структур и объединений обсуждаются  в  п.
0.5,  спецификация  перечислимого типа - в п.0.6; описания с
определяющими тип именами <b>typedef</b> обсуждаются в п. 0.9.

                            <b>-23-</b>


<ul><a name=42></a><h2>5.3.  Описатели</h2></ul>

     Входящий  в  описание  список  описателей  представляет
собой  последовательность  разделенных  запятыми описателей,
каждый из которых может иметь инициализатор.

     <b>список</b>_<b>описателей</b>:
           <b>инициализируемый</b>_<b>описатель</b>
           <b>инициализируемый</b>_<b>описатель</b>,<b>спи</b>-
                              <b>сок</b>_<b>описателей</b>
     <b>инициализируемый</b>_<b>описатель</b>:
           <b>описатель инициализатор</b>
                               <b>необ</b>

Инициализаторы описываются в п.0.6. Спецификаторы и описания
указывают  тип и класс памяти объектов, на которые ссылаются
описатели.  Описатели имеют следующий синтаксис:

     <b>описатель</b>:
          <b>идентификатор</b>
          ( <b>описатель</b> )
          <b>*</b> <b>описатель</b>
          <b>описатель</b> ()
          <b>описатель</b> [<b>константное</b>-<b>выражение</b>]
                                         <b>необ</b>

Группирование такое же, как и в выражениях.

<ul><a name=43></a><h2>5.4.  Смысл описателей</h2></ul>

     Каждый описатель рассматривается как утверждение  того,
что  когда  конструкция той же самой формы, что и описатель,
появляется в выражении, то она выдает объект указанного типа
и  указанного класса памяти. Каждый описатель содержит ровно
один идентификатор; это именно тот идентификатор, который  и
описывается.

     Если в качестве описателя появляется просто идентифика-
тор,  то  он  имеет тип, указываемый в специфицирующем заго-
ловке описания.

     Описатель в круглых  скобках  идентичен  описателю  без
круглых  скобок,  но  круглые  скобки могут изменять связи в
составных описателях.  Примеры смотри ниже.

     Представим себе описание

              <b>t     di</b>

где <b>t</b> - спецификатор типа (подобный <b>int</b> и т.д.), а <b>di</b> - опи-
сатель.   Предположим, что это описание приводит к тому, что
соответствующий идентификатор  имеет  тип  ...<b>t</b>,  где  "..."
пусто, если <b>di</b> просто отдельный идентификатор (так что тип <b>х</b>


                            <b>-24-</b>


в <b>int</b> <b>х</b> просто <b>int</b>). Тогда, если <b>di</b> имеет форму

             <b>*</b><b>d</b>

то содержащийся идентификатор будет иметь тип ...  <b>указатель</b>
<b>на t</b>.

     Если <b>di</b> имеет форму

             <b>d</b>()

то содержащийся идентификатор имеет тип ... <b>функция</b>, <b>возвра-</b>
<b>щающая t</b>.

     Если <b>di</b> имеет форму

            <b>d</b>[<b>константное</b>_<b>выражение</b>]

или

            <b>d</b>[ ]

то содержащийся идентификатор имеет тип ... <b>массив t</b>. В пер-
вом случае константным выражением является выражение, значе-
ние которого можно определить во время компиляции и  которое
имеет  тип  <b>int</b>.  (точное определение константного выражения
дано ниже). Когда несколько спецификаций  вида  "массив  из"
оказываются  примыкающими,  то создается многомерный массив;
константное  выражение,  задающее  границы  массивов,  может
отсутствовать  только  у  первого  члена этой последователь-
ности.  Такое опускание полезно, когда массив является внеш-
ним  или  формальным  и его фактическое определение, которое
выделяет память, приводится в другом месте. Первое констант-
ное  выражение может быть опущено также тогда, когда за опи-
сателем следует инициализация. В этом случае размер  опреде-
ляется по числу приведенных инициализируемых элементов.

     Массив может быть  образован  из  элементов  одного  из
основных  типов,  из указателей, из структур или объединений
или из других массивов (чтобы  образовать  многомерный  мас-
сив).

     Не все возможности, которые разрешены  с  точки  зрения
указанного  выше  синтаксиса,  фактически допустимы. Имеются
следующие ограничения: функции не могут  возвращать  массивы
или  функции,  хотя  они могут возвращать указатели на такие
вещи; не существует массивов функций, хотя могут  быть  мас-
сивы  указателей на функции. Аналогично, структуры или объе-
динения не могут содержать функцию, но они  могут  содержать
указатель на функцию.

     В качестве примера рассмотрим описание

                            <b>-25-</b>


    <b>int</b> <b>i</b>, <b>*</b><b>ip</b>, <b>f</b>(), <b>*</b><b>fip</b>(), (<b>*</b><b>pfi</b>)();

в котором описывается целое <b>i</b>, указатель <b>ip</b> на целое,  функ-
ция  <b>f</b>, возвращающая целое, функция <b>fip</b>, возвращающая указа-
тель на целое, и указатель <b>pfi</b> на функцию,  которая  возвра-
щает  целое.  Особенно полезно сравнить два последних описа-
теля. Связь в <b>*</b><b>fip</b>() можно представить в виде <b>*(</b><b>fip</b>()),  так
что  описанием  предполагается,  что  в  выражении требуется
обращение к функции <b>fip</b> и последующее использование  косвен-
ной  адресации  для  выдачи с помощью полученного результата
(указателя)  целого.  В  описателе  (<b>*</b><b>pfi</b>)()  дополнительные
скобки необходимы, поскольку они точно так же, как и в выра-
жении, указывают, что косвенная  адресация  через  указатель
выдает  функцию,  которая  затем  вызывается;  эта вызванная
функция возвращает целое.

     В качестве другого примера приведем описание

    <b>float</b> <b>fa</b>[17], <b>*</b><b>afp</b>[17];

в котором описывается массив чисел типа <b>float</b> и массив  ука-
зателей на числа типа <b>float</b>. Наконец,

    <b>static int</b> <b>х3d</b>[3][5][7];

описывает  статический  трехмерный  массив  целых   размером
3*5*7. Более подробно: <b>х3d</b> является массивом из трех элемен-
тов; каждый элемент является массивом пяти массивов;  каждый
последний  массив является массивом из семи целых. Каждое из
выражений <b>х3d</b>, <b>х3d</b>[<b>i</b>], <b>х3d</b>[<b>i</b>][<b>j</b>] и <b>х3d</b>[<b>i</b>][<b>j</b>][<b>k</b>] может разум-
ным  образом  появляться  в выражениях. Первые три имеют тип
"массив", последнее имеет тип <b>int</b>.

<ul><a name=44></a><h2>5.5.  Описание структур и объединений</h2></ul>

     Структура - это объект, состоящий из последовательности
именованных  членов.  Каждый  член  может быть произвольного
типа. Объединение - это  объект,  который  в  данный  момент
может  содержать любой из нескольких членов. Спецификаторы и
объединения имеют одинаковую форму.

     <b>спецификатор</b>_<b>структуры</b>_<b>или</b>_<b>объединения</b>:

         <b>структура</b>_<b>или</b>_<b>объединение</b>   <b>{</b> <b>спи</b>-
            <b>сок</b>_<b>описаний</b>_<b>структуры</b> <b>}</b>
         <b>идентификатор</b>_<b>структуры</b>_<b>или</b>_<b>объедине</b>-
             <b>ния</b> <b>{</b> <b>список</b>-<b>описаний</b>-<b>структуры</b> <b>}</b>
         <b>идентификатор</b>_<b>структуры</b>_<b>или</b>_<b>объединения</b>

     <b>структура</b>_<b>или</b>_<b>объединение</b>:
                   <b>struct</b>
                   <b>union</b>

                            <b>-26-</b>


Список_описаний_структуры является последовательностью  опи-
саний членов структуры или объединения:

      <b>список</b>_<b>описаний</b>_<b>структуры</b>:
           <b>описание</b>_<b>структуры</b>
           <b>описание</b>_<b>структуры спи</b>-
                    <b>сок</b>_<b>описаний</b>_<b>структуры</b>

      <b>описание</b>_<b>структуры</b>:
           <b>спецификатор</b>_<b>типа спи</b>-
                  <b>сок</b>_<b>описателей</b>_<b>структуры</b>

      <b>список</b>_<b>описателей</b>_<b>структуры</b>:
           <b>описатель</b>_<b>структуры</b>
           <b>описатель</b>_<b>структуры</b>,<b>список</b>_<b>опи</b>-
                          <b>сателей</b>_<b>структуры</b>

В обычном случае описатель структуры является просто  описа-
телем  члена структуры или объединения. Член структуры может
также  состоять из  специфицированного  числа  битов.  Такой
член  называется  также полем; его длина отделяется от имени
поля двоеточием.

      <b>описатель</b>_<b>структуры</b>:
           <b>описатель</b>
           <b>описатель</b>: <b>константное</b>_<b>выражение</b>
           : <b>константное</b>_<b>выражение</b>


Внутри структуры описанные в ней объекты имеют адреса, кото-
рые увеличиваются в соответствии с чтением описаний объектов
слева направо.  Каждый член структуры, который  не  является
полем,  начинается  с  адресной границы, соответствующей его
типу; следовательно в структуре могут оказаться  неименован-
ные  дыры.  Члены,  являющиеся полями, помещаются в машинные
целые; они не перекрывают границы слова.  Поле,  которое  не
умещается  в оставшемся в данном слове пространстве, помеща-
ется в следующее слово. Поля  выделяются  справа  налево  на
CM-ЭВМ, но могут выделяться слева направо на других машинах.

     Описатель структуры, который не содержит  описателя,  а
только  двоеточие  и  ширину,  указывает неименованное поле,
полезное для  заполнения  свободного  пространства  с  целью
соответствия  задаваемым  извне  схемам.  Специальный случай
неименованного поля с шириной 0 используется для указания  о
выравнивании  следующего  поля  на  границу  слова. При этом
предполагается, что "следующее поле" действительно  является
полем,  а не обычным членом структуры, поскольку в последнем
случае выравнивание осуществляется автоматически.

     Сам язык не накладывает ограничений на  типы  объектов,
описанных  как поля, но от реализаций не требуется обеспечи-
вать что-либо отличное от целых полей. Более того, даже поля


                            <b>-27-</b>


типа  <b>int</b> могут рассматриваться как не имеющие знака. На CM-
ЭВМ поля не имеют знака и могут принимать только целые  зна-
чения.  Во  всех  реализациях  отсутствуют массивы полей и к
полям не применима операция взятия  адреса  <b>&</b>,  так  что  не
существует и указателей на поля.

     Объединение можно представить себе как  структуру,  все
члены которой начинаются со смещения 0 и размер которой дос-
таточен, чтобы содержать любой из ее членов. В каждый момент
объединение может содержать не более одного из своих членов.

     Спецификатор структуры или объединения во второй форме,
т.е. один из:

      <b>struct</b> <b>идент</b> <b>{</b><b>список</b>_<b>описаний</b>_<b>структуры</b><b>}</b>
      <b>union</b> <b>идент</b> <b>{</b><b>список</b>-<b>описаний</b>-<b>структуры</b><b>}</b>

описывает <b>идент</b> в  качестве  ярлыка  структуры  (или  ярлыка
объединения)  для структуры, специфицированной этим списком.
Последующее описание может затем использовать  третью  форму
спецификатора, один из

       <b>struct</b> <b>идент</b>
       <b>union</b> <b>идент</b>

Ярлыки структур дают возможность определения структур, кото-
рые  ссылаются  на  самих себя; они также позволяют неоднок-
ратно использовать приведенную только один раз длинную часть
описания.  Запрещается  описывать структуру или объединение,
которые содержат образец самого себя, но структура или объе-
динение могут содержать указатель на структуру или объедине-
ние такого же вида, как они сами.

     Имена членов и ярлыков структур могут совпадать с  име-
нами  обычных  переменных.   Однако  имена  ярлыков и членов
должны быть взаимно различными.

     Две структуры могут иметь  общую  начальную  последова-
тельность  членов; это означает, что тот же самый член может
появиться в двух различных структурах, если он имеет  одина-
ковый  тип  в  обеих  структурах и если все предыдущие члены
обеих структур одинаковы. Фактически компилятор только  про-
веряет, что имя в двух различных структурах имеет одинаковый
тип и одинаковое  смещение,  но  если  предшествующие  члены
отличаются, то конструкция оказывается непереносимой.

     Вот простой пример описания структуры:

                            <b>-28-</b>


             <b>struct</b> <b>tnode</b> <b>{</b>
                  <b>char</b> <b>tword</b>[20];
                  <b>int</b> <b>count</b>;
                  <b>struct</b> <b>tnode</b> <b>*</b><b>left</b>;
                  <b>struct</b> <b>tnode</b> <b>*</b><b>right</b>;
             <b>}</b>;

такая структура содержит массив из 20 символов, целое и  два
указателя  на такие же структуры. Как только приведено такое
описание, описание

              <b>struct</b> <b>tnode s</b>, <b>*</b><b>sp</b>;

говорит о том, что <b>s</b> является структурой указанного вида,  а
<b>sp</b>  является  указателем  на  структуру указанного вида. При
наличии этих описаний выражение

             <b>sp</b><b>-</b>><b>count</b>

ссылается на поле <b>count</b> структуры, на которую указывает  <b>sp</b>;
выражение

             <b>s</b>.<b>left</b>

ссылается на указатель левого поддерева  в  структуре  <b>s</b>,  а
выражение

             <b>s</b>.<b>right</b><b>-</b>><b>tword</b>[0]

ссылается на первый символ члена <b>tword</b> правого поддерева  из
<b>s</b>.

<ul><a name=45></a><h2>5.6.  Перечислимый тип</h2></ul>

     Перечислимый тип  данных  аналогичен   скалярным  типам
языка Паскаль.  Спецификатор перечислимого типа имеет следу-
ющий вид:

    <b>спецификатор</b>_<b>перечисления</b>:
       <b>enum</b> <b>список</b>_<b>перечисления</b>
       <b>enum</b> <b>идентификатор  список</b>_<b>перечисления</b>
       <b>enum</b> <b>идентификатор</b>

    <b>список</b>_<b>перечисления</b>:
       <b>перечисляемое</b>
       <b>список</b>_<b>перечисления</b>, <b>перечисляемое</b>

    <b>перечисляемое</b>:
       <b>идентификатор</b>
       <b>идентификатор</b> <b>=</b> <b>константное выражение</b>


                            <b>-29-</b>


     Роль идентификатора в  <b>спецификаторе</b>_<b>перечисления</b>  пол-
ностью     аналогична     роли     ярлыка     структуры    в
<b>спецификаторе</b>_<b>структуры</b>; идентификатор обозначает определен-
ное перечисление. Например, описание

        <b>enum</b> <b>color</b> <b>{</b><b>red</b>, <b>white</b>, <b>black</b>, <b>blue</b> <b>}</b>;
        . . .
        <b>enum</b> <b>color</b> <b>*</b><b>cp</b>, <b>col</b>;

объявляет идентификатор  <b>color</b>  ярлыком  перечисления  типа,
описывающего различные цвета и затем объявляет <b>cр</b> указателем
на объект этого типа, а <b>col</b> - объектом этого типа.

     Идентификаторы в <b>списке</b>_<b>перечисления</b> становятся   конс-
тантами и могут появляться там, где требуются (по контексту)
константы. Если не используется вторая форма  перечисляемого
(с равенством <b>=</b>), то величины констант начинаются с 0 и воз-
растают на 1 в соответствии с прочтением их  описания  слева
направо. Перечисляемое с присвоением <b>=</b> придает соответствую-
щему идентификатору указанную величину; последующие  иденти-
фикаторы продолжают прогрессию от приписанной величины.

     Ярлыки перечислений и имена констант должны  быть  раз-
личными и не совпадать с именами ярлыков и членов структур.

     Объекты данного типа перечисления  рассматриваются  как
объекты, имеющие тип, отличный от любых типов и контролирую-
щая программа <b>lint</b> сообщает об ошибках несоответствия типов.
В  реализации  на CM_ЭВМ со всеми перечисляемыми переменными
оперируют так, как если бы они имели тип <b>int</b>.

<ul><a name=46></a><h2>5.7.  Инициализация</h2></ul>

     Описатель может указывать начальное значение  описывае-
мого  идентификатора. Инициализатор состоит из выражения или
заключенного в фигурные скобки списка значений, перед  кото-
рыми ставится знак <b>=</b>.

    <b>инициализатор</b>:
       <b>=</b> <b>выражение</b>
       <b>= {список</b><b>_</b><b>иниц}</b>
       <b>= {</b><b>список</b>_<b>иниц</b>,<b>}</b>
    <b>список</b>_<b>иниц</b>:
      <b>выражение</b>
      <b>список</b>_<b>иниц</b>,<b>список</b>_<b>иниц</b>
      <b>{</b><b>список</b>_<b>иниц</b><b>}</b>


где

    <b>список</b>_<b>иниц</b> - <b>список</b>_<b>инициализаторов</b>

                            <b>-30-</b>


     Все выражения, входящие в инициализатор статической или
внешней  переменной, должны быть либо константными выражени-
ями, либо выражениями, которые сводятся к адресу ранее  опи-
санной  переменной,  смещенному  на  константное  (возможно,
нулевое) выражение. Автоматические и регистровые  переменные
могут быть инициализированы произвольными выражениями, вклю-
чающими константы и ранее описанные переменные и функции.

     Гарантируется, что неинициализированные  статические  и
внешние переменные получают в качестве начальных значений 0;
неинициализированные автоматические и регистровые переменные
в качестве начальных значений содержат мусор.

     Когда инициализатор применяется  к  скаляру  (указателю
или  объекту  арифметического типа), то он состоит из одного
выражения, возможно заключенного в фигурные скобки.  Началь-
ное  значение объекта находится из выражения; выполняются те
же самые преобразования, что и при присваивании.

     Когда описываемая переменная является агрегатом (струк-
турой  или  массивом), то инициализатор состоит из заключен-
ного в фигурные скобки и разделенного запятыми списка иници-
ализаторов  для  членов агрегата. Этот список составляется в
порядке возрастания индекса или в  соответствии  с  порядком
членов.  Если  агрегат  содержит подагрегаты, то это правило
применяется рекурсивно к членам  агрегата.  Если  количество
инициализаторов  в  списке  оказывается  меньше числа членов
агрегата, то оставшиеся члены агрегата  заполняются  нулями.
Запрещается  инициализировать объединения или автоматические
агрегаты.

     Фигурные  скобки  могут  интерпретироваться   следующим
образом.  Если  инициализатор  начинается  с  левой фигурной
скобки, то последующий разделенный запятыми список инициали-
заторов инициализирует члены агрегата; будет ошибкой, если в
списке окажется больше инициализаторов, чем членов агрегата.
Если  однако  инициализатор  не  начинается с левой фигурной
скобки, то из списка берется только нужное для  членов  дан-
ного агрегата число элементов; оставшиеся элементы использу-
ются для инициализации  следующего  члена  агрегата,  частью
которого является настоящий агрегат. Следовательно, скобки в
некоторых случаях  можно опускать.

     Последнее сокращение допускает возможность  инициализа-
ции  массива типа <b>char</b> с помощью строки. В этом случае члены
массива последовательно инициализируются символами строки.

     Например,

                <b>int</b> <b>х</b>[] <b>= {</b>1,3,5<b>}</b>;

описывает и инициализирует <b>х</b>  как  одномерный  массив;  пос-
кольку   размер   массива   не   специфицирован,   а  список


                            <b>-31-</b>


инициализатора содержит три элемента, считается, что  массив
состоит из трех членов.

     Вот пример инициализации с полным использованием фигур-
ных скобок:

      <b>float *</b><b>y</b><b>[4][3] = {</b>
              <b>( 1, 3, 5 ),</b>
              <b>( 2, 4, 6 ),</b>
              <b>( 3, 5, 7 ),</b>
        <b>};</b>

Здесь 1, 3 и 5 инициализируют первую строку массива <b>y</b>[0],  а
именно  <b>y</b>[0][0], <b>y</b>[0][1] и <b>y</b>[0][2]. Аналогичным образом сле-
дующие две строчки инициализируют <b>y</b>[1] и <b>y</b>[2]. Инициализатор
заканчивается  преждевременно, и, следовательно, массив <b>y</b>[3]
инициализируется нулями. В точности такого же эффекта  можно
было бы достичь, написав

        <b>float</b> <b>y</b>[<b>4</b>][<b>3</b>] <b>= {</b>
              1, 3, 5, 2, 4, 6, 3, 5, 7
        <b>}</b>;

Инициализатор для <b>y</b> начинается с левой фигурной  скобки,  но
инициализатора для <b>y</b>[0] нет. Поэтому используется 3 элемента
из списка.  Аналогично следующие три  элемента  используются
последовательно для <b>y</b>[1] и <b>y</b>[2]. Следующее описание

                <b>float</b> <b>y</b>[4][3] <b>= {</b>
                      <b>{1}, {2}, {3}, {4}</b>
                };

инициализирует первый столбец <b>y</b> (если его рассматривать  как
двумерный массив), а остальные элементы заполняются нулями.

     И наконец, описание

     <b>char</b> <b>msg</b>[] <b>=</b> "<b>syntax error on line</b> <b>%</b><b>s</b><b>\n</b>";

демонстрирует инициализацию элементов символьного массива  с
помощью строки.

<ul><a name=47></a><h2>5.8.  Имена типов</h2></ul>

     В двух случаях (для явного указания типа преобразования
в  конструкции  перевода  и  для аргументов операции <b>sizeof</b>)
желательно иметь возможность задавать тип данных.  Это  осу-
ществляется  с  помощью  "имени  типа",  которое по существу
является описанием объекта такого типа,  в  котором  опущено
имя самого объекта.


                            <b>-32-</b>


     Имя типа:
         <b>спецификатор</b>_<b>типа абстрактный</b>_<b>описатель</b>
     <b>абстрактный</b>_<b>описатель</b>:
         <b>пусто</b>
        (<b>абстрактный</b>_<b>описатель</b>)
        <b>*</b><b>абстрактный описатель</b>
         <b>абстрактный</b>_<b>описатель</b> ()
         <b>абстрактный</b>_<b>описатель</b> [<b>констант</b>-
                         <b>ное выражение</b>]
                                   <b>необ</b>

Во избежание двусмысленности в конструкции

            (<b>абстрактный</b>_<b>описатель</b>)

требуется, чтобы <b>абстрактный</b>_<b>описатель</b> был непуст. При  этом
ограничении   возможно  однозначно  определить  то  место  в
абстрактном_описателе, где должен  появиться  идентификатор,
если  бы  эта конструкция была описателем в описании. Имено-
ванный тип совпадает тогда с типом гипотетического идентифи-
катора. Например, имена типов

             <b>int</b>
             <b>int *</b>
             <b>int *</b>[3]
             <b>int</b> (<b>*</b>)[3]
             <b>int *</b>()
             <b>int</b> (<b>*</b>)()

именуют соответственно типы "целый", "указатель  на  целое",
"массив  из  трех указателей на целое", "указатель на массив
из трех целых", " функция, возвращающая указатель на  целое"
и "указатель на функцию, возвращающую целое".

<ul><a name=48></a><h2>5.9.  Описатель typedef</h2></ul>

     Описания, в которых "<b>класс памяти</b>"  специфицирован  как
<b>typedef</b>,  не  вызывают  выделения  памяти.  Вместо этого они
определяют идентификаторы, которые позднее  можно  использо-
вать  так,  словно  они являются ключевыми словами, имеющими
основные или производные типы.

       <b>определяющее</b>_<b>тип</b>_<b>имя</b>:
                 <b>идентификатор</b>

В  пределах  области  действия  описания  со  спецификатором
<b>typedef</b>  каждый  идентификатор,  описанный в нем, становится
синтаксически эквивалентным ключевому  слову,  имеющему  тот
тип,  который ассоциирует с идентификатором в описанном в п.
0.4 смысле.  Например, после описаний

     <b>typedef int</b> <b>miles</b>, <b>*</b><b>klicksp</b>;
     <b>typedef struct { double</b> <b>re</b>, <b>im</b>;<b>}</b> <b>complex</b>;


                            <b>-33-</b>


конструкции

             <b>miles distance</b>;
             <b>extern</b> <b>klicksp metricp</b>;
             <b>complex z</b>, <b>*</b><b>zp</b>;

становятся законными описаниями;  при  этом  типом  distance
является  <b>int</b>, типом <b>metricp</b> - "указатель на <b>int</b>", типом <b>z</b> -
специфицированная структура и типом <b>zp</b> - указатель на  такую
структуру.

     Спецификатор <b>typedef</b> не  вводит  каких-либо  совершенно
новых типов, а только определяет синонимы для типов, которые
можно было бы специфицировать и другим способом. Так в  при-
веденном  выше примере переменная <b>distance</b> считается имеющей
точно такой же тип, что и любой другой объект,  описанный  в
<b>int</b>.

<ul><a name=49></a><h2> * 6.  ОПЕРАТОРЫ</h2></ul>

     За исключением особо оговариваемых  случаев,  операторы
выполняются последовательно.

<ul><a name=50></a><h2>6.1.  Операторное выражение</h2></ul>

     большинство операторов являются операторными  выражени-
ями, которые имеют форму

                <b>выражение</b>;

Обычно операторные  выражения  являются  присваиваниями  или
обращениями к функциям.

<ul><a name=51></a><h2>6.2.  Составной оператор (или блок)</h2></ul>

     С тем, чтобы допустить возможность  использования  нес-
кольких  операторов  там,  где  ожидается присутствие только
одного, предусматривается составной оператор (который  также
называют "блоком"):

     <b>составной оператор</b>:
          <b>{</b><b>список</b>_<b>описаний  список</b>_<b>операторов</b><b>}</b>
                      <b>необ               необ</b>

     <b>список</b>_<b>описаний</b>:
          <b>описание</b>
          <b>описание список</b>_<b>описаний</b>

     <b>список</b>_<b>операторов</b>:
          <b>оператор</b>
          <b>оператор список</b>_<b>операторов</b>

Если какой-либо идентификатор из <b>списка</b>_<b>описаний</b> был  описан


                            <b>-34-</b>


ранее,  то во время выполнения блока внешнее описание подав-
ляется и снова вступает в силу после выхода из блока.

     Любая инициализация автоматических и регистровых  пере-
менных  проводится при каждом входе в блок через его начало.
В компиляторе <b>ОС ДЕМОС</b> разрешается (но это плохая  практика)
передавать  управление внутрь блока; в таком случае эти ини-
циализации не выполняются. Инициализации  статических  пере-
менных проводятся только один раз, когда начинается выполне-
ние программы.

     Находящиеся внутри блока внешние описания  не  резерви-
руют памяти, так что их инициализация не разрешается.

<ul><a name=52></a><h2>6.3.  Условные операторы</h2></ul>

     Имеются две формы условных операторов:

         <b>if</b> (<b>выражение</b>) <b>оператор</b>
         <b>if</b> (<b>выражение</b>) <b>оператор</b> <b>else</b> <b>оператор</b>

В обоих случаях вычисляется выражение и, если оно отлично от
нуля,  то  выполняется первый подоператор. Во втором случае,
если выражение равно нулю, выполняется  второй  подоператор.
Как  обычно,  двусмысленность  <b>else</b>  разрешается связыванием
<b>else</b> с последним встречающимся <b>if</b>, у которого нет <b>else</b>.

<ul><a name=53></a><h2>6.4.  Оператор while</h2></ul>

     Оператор <b>while</b> имеет форму

           <b>while</b> (<b>выражение</b>) <b>оператор</b>

Подоператор выполняется повторно до тех пор,  пока  значение
выражения  остается  отличным от нуля. Проверка производится
перед каждым выполнением оператора.

<ul><a name=54></a><h2>6.5.  Оператор do</h2></ul>

     Оператор <b>do</b> имеет форму

            <b>do</b> <b>оператор</b> <b>while</b> (<b>выражение</b>)

Оператор выполняется повторно  до  тех  пор,  пока  значение
выражения не станет равным нулю. Проверка производится после
каждого выполнения оператора.

<ul><a name=55></a><h2>6.6.  Оператор for</h2></ul>

     Оператор <b>for</b> имеет форму

    (<b>выражение1</b>;<b>выражение2</b>;<b>выражение3</b>)<b>оператор</b>
            <b>необ       необ       необ</b>


                            <b>-35-</b>


Оператор <b>for</b> эквивалентен следующему:

            <b>выражение1</b>;
               <b>while</b>   (<b>выражение2</b>) <b>{</b>
                       <b>оператор</b>
                       <b>выражение3</b>;
            <b>}</b>

Таким образом,  первое  выражение  определяет  инициализацию
цикла; второе специфицирует проверку, выполняемую перед каж-
дой итерацией, так что  выход  из  цикла  происходит  тогда,
когда  значение выражения становится нулем; третье выражение
часто задает приращение параметра, который вычисляется после
каждой итерации.

     Любое выражение или все они могут  быть  опущены.  Если
отсутствует  второе выражение, то предложение с <b>while</b> счита-
ется эквивалентным <b>while</b>(1); другие отсутствующие  выражения
просто опускаются из приведенного выше расширения.

<ul><a name=56></a><h2>6.7.  Оператор switch</h2></ul>

     Оператор  <b>switch</b>  (переключатель),  вызывает   передачу
управления  к одному из нескольких операторов, в зависимости
от значения выражения. Оператор имеет форму

            <b>switch</b> (<b>выражение</b>) <b>оператор</b>

В выражении проводятся обычные  арифметические  преобразова-
ния,  результат  должен иметь тип <b>int</b>. <b>Оператор</b> обычно явля-
ется составным.  Любой оператор внутри этого оператора может
быть помечен одним или более вариантным префиксом <b>case</b>, име-
ющим форму:

            <b>case</b> <b>константное выражение</b>:

Где <b>константное выражение</b> должно иметь тип <b>int</b>.  Никакие две
вариантные константы в одном и том же переключателе не могут
иметь одинаковое значение. Точное  определение  константного
выражения приводится ниже.

     Кроме того, может присутствовать один операторный  пре-
фикс вида

            <b>default</b>:


     При выполнении оператора <b>switch</b> вычисляется входящее  в
него  выражение  и сравнивается с каждой вариантной констан-
той. Если одна из  вариантных  констант  оказывается  равной
значению  этого  выражения,  то управление передается опера-
тору, который следует за совпадающим  вариантным  префиксом.
Если   ни  одна  из  вариантных  констант  не  совпадает  со


                            <b>-36-</b>


значением выражения и если  при  этом  присутствует  префикс
<b>default</b>,  то  управление  передается  оператору, помеченному
этим префиксом. Если ни один из вариантов не подходит и пре-
фикс  <b>default</b> отсутствует, то ни один из операторов в перек-
лючателе не выполняется.

     Сами по себе префиксы <b>case</b> и <b>default</b> не изменяют выпол-
нения программы, программа выполняется последовательно, пока
не встретится  явная  передача  управления.  Для  выхода  из
переключателя имеется оператор <b>break</b> (п.0.8).

     Обычно оператор, который входит в переключатель,  явля-
ется  составным.   Описания  могут появляться в начале этого
оператора, но  инициализации  автоматических  и  регистровых
переменных будут неэффективными.

     Пример:

     <b>switch</b> (<b>regim</b>) {
     <b>case</b> '<b>x</b>': <b>regx</b><b>++</b>;
     <b>case</b> '<b>X</b>': <b>case</b> '<b>Y</b>': <b>regY</b><b>++</b>; <b>break</b>;
     <b>case</b> '-': <b>regx</b> = 0; <b>break</b>;
     <b>default</b>: <b>err</b>("Ошибка"); <b>goto</b> <b>next</b>;
     }


<ul><a name=57></a><h2>6.8.  Оператор break</h2></ul>

     Оператор

            <b>break</b>;

вызывает  завершение  выполнения  наименьшего  охватывающего
этот  оператор оператора <b>while</b>, <b>do</b>, <b>for</b> или <b>switch</b>; управле-
ние передается оператору, следующему за завершенным операто-
ром.

<ul><a name=58></a><h2>6.9.  Оператор continue</h2></ul>

     Оператор

            <b>continue</b>;

приводит к передаче управления на  продолжающую  цикл  часть
наименьшего  охватывающего этот оператор оператора <b>while</b>, <b>do</b>
или <b>for</b>; то есть на конец цикла. Более точно,  в  каждом  из
операторов

     <b>while</b>(...) { | <b>do</b> {          | <b>for</b>(...) <b>{</b>
        ...       |   ...         |      ...
     <b>contin</b>: ;    |  <b>contin</b>: ;    |   <b>contin</b>: ;
     }            | } <b>while</b>(...); | }

                            <b>-37-</b>


оператор <b>continue</b> эквивалентен оператору <b>goto</b>  <b>contin</b>.   (За
<b>contin</b>: следует пустой оператор; см. п. 0.13.).

<ul><a name=59></a><h2>6.10.  Оператор возврата</h2></ul>

     Возвращение из функции в вызывающую программу осуществ-
ляется  с  помощью  оператора  <b>return</b>, который имеет одну из
следующих форм

              <b>return</b>;
              <b>return</b> <b>выражение</b>;

В первом случае возвращаемое значение неопределено. Во  вто-
ром  случае в вызывающую функцию возвращается значение выра-
жения. Если требуется, выражение преобразуется к типу  функ-
ции,  в  которой  оно появляется, как в случае присваивания.
Попадание на конец функции эквивалентно возврату без возвра-
щаемого значения.

     Возвращать можно значение арифметического типа, а также
структуру (но не массив).

<ul><a name=60></a><h2>6.11.  Оператор goto</h2></ul>

     Управление можно передавать безусловно с помощью опера-
тора

           <b>goto</b> <b>идентификатор1</b>

Идентификатор должен быть меткой (п. 0.12), локализованной в
данной функции.

<ul><a name=61></a><h2>6.12.  Помеченный оператор</h2></ul>

     Перед любым оператором может стоять метка, имеющая вид:

               <b>идентификатор</b>:

Метки используются только для указания места,  куда  переда-
ется  управление  оператором  <b>goto</b>.  Областью действия метки
является данная функция, за  исключением  тех  подблоков,  в
которых тот же идентификатор описан снова.

<ul><a name=62></a><h2>6.13.  Пустой оператор</h2></ul>

     Пустой оператор имеет форму:

                    <b>;</b>

Пустой оператор оказывается полезным, так как  он  позволяет
поставить  метку перед закрывающей скобкой <b>}</b> составного опе-
ратора или указать пустое тело в операторах цикла, таких как
<b>while</b>.


                            <b>-38-</b>


<ul><a name=63></a><h2> * 7.  ВНЕШНИЕ ОПРЕДЕЛЕНИЯ</h2></ul>

     Си-программа  представляет   собой   последовательность
внешних определений. Внешнее определение описывает идентифи-
катор как имеющий класс памяти <b>extern</b> (по  умолчанию),  или,
возможно, <b>static</b>, и специфицированный тип. Спецификатор типа
также может быть пустым; в этом случае  считается,  что  тип
является  типом  <b>int</b>.  Область  действия внешних определений
распространяется до конца файла, в  котором  они  приведены,
точно  так  же,  как  влияние описаний простирается до конца
блока. Синтаксис внешних определений не отличается  от  син-
таксиса  описаний,  за  исключением того, что только на этом
уровне можно приводить текст функций.

<ul><a name=64></a><h2>7.1.  Внешнее определение функции</h2></ul>

     Определение функции имеет форму

    <b>определение</b>_<b>функции</b>:
         <b>спецификаторы</b>_<b>описания описа</b>-
                           <b>необ</b>
                   <b>тель</b>_<b>функции тело</b>_<b>функции</b>

Единственными спецификаторами класса памяти, допускаемыми  в
качестве   спецификаторов-описания,   являются   <b>extern</b>  или
<b>static</b>; о различии между ними смотри  в  следующем  разделе.
Описатель  функции подобен описателю для <b>функции</b>, <b>возвращаю-</b>
<b>щей</b> ..., за исключением того, что он перечисляет  формальные
параметры определяемой функции.

     <b>описатель</b>_<b>функции</b>:
          <b>описатель</b> (<b>список</b>_<b>параметров</b>)
                                   <b>необ</b>
     <b>список параметров</b>:
          <b>идентификатор</b>
          <b>идентификатор</b>, <b>список</b>_<b>параметров</b>

<b>Тело</b>_<b>функции</b> имеет форму

      <b>тело</b>_<b>функции</b>:
           <b>список</b>_<b>описаний составной</b>_<b>оператор</b>

Идентификаторы из списка параметров  могут  быть  описаны  в
списке  описаний.  Любой  идентификатор из этого списка, тип
которого не указан, считается имеющим тип <b>int</b>.  Единственным
допустимым   здесь  спецификатором  класса  памяти  является
<b>register</b>; если  такой  класс  памяти  специфицирован,  то  в
начале выполнения функции  соответствующий фактический пара-
метр копируется, если это возможно, в регистр.

     Вот простой пример полного определения функции:

                            <b>-39-</b>


             <b>int</b> <b>max</b>(<b>a</b>, <b>b</b>, <b>c</b>)
             <b>int</b> <b>a</b>, <b>b</b>, <b>c</b>;
             <b>{</b>
                 <b>int</b> <b>m</b>;
                 <b>m</b> = (<b>a</b>&gt;<b>b</b>) ? <b>a</b>:<b>b</b>;
                 <b>return</b>((<b>m</b>&gt;<b>c</b>) ? <b>m</b>:<b>c</b>);
             <b>}</b>

Здесь    <b>int</b>    -    спецификатор-типа,     <b>maх</b>(<b>a</b>,<b>b</b>,<b>c</b>)     -
описатель_функции,  <b>int a</b>,<b>b</b>,<b>c</b>;  - список-описаний формальных
параметров, <b>{ ... }</b> - блок, содержащий текст оператора.

     В языке Си все фактические параметры типа <b>float</b>  преоб-
разуются к типу <b>double</b>, так что описания формальных парамет-
ров, объявленных как <b>float</b>,  могут  работать  с  параметрами
типа  <b>double</b>. Аналогично, поскольку ссылка на массив в любом
контексте (в частности в фактическом параметре) рассматрива-
ется  как указатель на первый элемент массива, описания фор-
мальных параметров вида <b>массив</b> ...  могут работать с  факти-
ческими  параметрами  типа  <b>указатель на</b> ... И наконец, пос-
кольку функции не могут быть переданы функции,  бессмысленно
описывать  формальный  параметр  как  функцию  (указатели на
такие объекты, конечно, допускаются).

ПРИМЕЧАНИЕ

     В некоторых версиях языка Си, в  частности,  в  версиях
     для  микропроцессоров,  может  быть  запрещена передача
     структур и объединений через параметры функции.

<ul><a name=65></a><h2>7.2.  Внешние определения данных</h2></ul>

     Внешнее определение данных имеет форму:

         <b>определение</b>_<b>данных</b>:
                    <b>описание</b>

Классом памяти таких данных может быть <b>extern</b> (в  частности,
по умолчанию) или <b>static</b>, но не <b>auto</b> или <b>register</b>.

<ul><a name=66></a><h2> * 8.  ОБЛАСТЬ ДЕЙСТВИЯ ИДЕНТИФИКАТОРОВ</h2></ul>

     Вся Си-программа не обязательно компилируется  одновре-
менно; исходный текст программы может храниться в нескольких
файлах и ранее скомпилированные процедуры могут  загружаться
из библиотек. Связь между функциями может осуществляться как
через явные обращения, так и в результате  работы  редактора
связей.

     Поэтому следует рассмотреть два вида областей действия:
во  первых,  ту,  которая  может  быть  названа  лексической
областью  действия  идентификатора  и  которая  по  существу
является  той  областью  в программе, где этот идентификатор


                            <b>-40-</b>


можно использовать, не  вызывая  диагностического  сообщения
"неопределенный  идентификатор"; и во-вторых, область дейст-
вия, которая связана с внешними идентификаторами  и  которая
характеризуется  правилом, что ссылки на один и тот же внеш-
ний идентификатор являются ссылками на один и тот же объект.

<ul><a name=67></a><h2>8.1.  Лексическая область действия</h2></ul>

     Лексическая область действия идентификаторов, описанных
во  внешних  определениях,  простирается  от  определения до
конца исходного файла, в котором он  находится.  Лексическая
область  действия  идентификаторов,  являющихся  формальными
параметрами, распространяется на ту функцию, к  которой  они
относятся.  Лексическая  область  действия  идентификаторов,
описанных в начале блока, простирается до конца этого блока.
Лексической  областью  действия меток является та функция, в
которой они находятся.

     Поскольку все ссылки на один и тот же внешний идентифи-
катор  относятся к одному и тому же объекту, компилятор про-
веряет все описания одного и того же внешнего идентификатора
на  совместимость;  в  действительности  их область действия
распространяется на весь файл, в котором они находятся.

     Во всех случаях, однако, если  некоторый  идентификатор
явным образом описан в начале блока, включая и блок, который
образует функцию, то действие любого описания этого  иденти-
фикатора вне блока приостанавливается до конца этого блока.

     Напомним  также,  что  идентификаторы,  соответствующие
обычным переменным, с одной стороны, и идентификаторы, соот-
ветствующие членам и ярлыкам структур и объединений, с  дру-
гой  стороны, формируют два непересекающихся класса, которые
не вступают в противоречие. Члены и ярлыки структур подчиня-
ются  тем  же  самым правилам определения областей действия,
как  и  другие  идентификаторы.  Имена,  специфицируемые   с
помощью  <b>typedef</b>, входят в тот же класс, что и обычные иден-
тификаторы.  Они могут  быть  переопределены  во  внутренних
блоках,  но  во  внутреннем  описании тип должен быть указан
явно:

            <b>typedef float</b> <b>distance</b>;
            ...
            <b>{</b>
                    <b>auto int</b> <b>distance</b>;
                    ...

Во втором описании спецификатор типа <b>int</b> должен  присутство-
вать,  так как в противном случае это описание будет принято
за описание без описателей с типом <b>distance</b>.


                            <b>-41-</b>


<ul><a name=68></a><h2>8.2.  Область действия внешних идентификаторов</h2></ul>

     Если функция ссылается на идентификатор, описанный  как
<b>extern</b>,  то  где-то  среди  файлов или библиотек, образующих
полную программу,  должно  содержаться  внешнее  определение
этого  идентификатора. Все функции данной программы, которые
ссылаются на один и тот же внешний идентификатор,  ссылаются
на один и тот же объект, так что следует позаботиться, чтобы
специфицированные в этом определении тип и размер были  сов-
местимы  с  типом и размером, указываемыми в каждой функции,
которая ссылается на эти данные.

     Появление ключевого слова <b>extern</b> во внешнем определении
указывает  на то, что память для описанных в нем идентифика-
торов будет выделена в другом файле. Следовательно, в состо-
ящей  из многих файлов программе внешнее определение иденти-
фикатора, не содержащее спецификатора <b>extern</b>,  должно  появ-
ляться  только  в  одном из этих файлов. Любые другие файлы,
которые желают дать внешнее  определение  этого  идентифика-
тора,  должны включать в это определение слово <b>extern</b>. Иден-
тификатор может быть инициализирован только в том  описании,
которое приводит к выделению памяти.

     Из этого правила в <b>ОС ДЕМОС</b> имеется исключение. Внешний
объект  может  присутствовать  в  нескольких  описаниях  без
<b>extern</b>. При этом длина объекта  в  разных  описаниях  должна
совпадать,  а  инициализация,  если  она есть, должна прово-
диться ровно в одном из описаний.  При нарушении этих правил
будет  выдана  ошибка  на  этапе редактировании связей прог-
раммы.

     Идентификаторы, внешнее определение которых  начинается
со  слова <b>static</b>, недоступны из других файлов. Функции могут
быть описаны как <b>static</b>.

<ul><a name=69></a><h2>8.3.  Неявные описания</h2></ul>

     Не всегда необходимо специфицировать и класс  памяти  и
тип  идентификатора  в  описании.  Во внешних определениях и
описаниях формальных  параметров  и  членов  структур  класс
памяти  определяется по контексту. Если в находящемся внутри
функции описании не указан тип, а только  класс  памяти,  то
предполагается,  что  идентификатор  имеет  тип <b>int</b>; если не
указан класс памяти, а только тип, то идентификатор  предпо-
лагается  описанным  как <b>auto</b>. Исключение из последнего пра-
вила дается для функций, потому что  спецификатор  <b>auto</b>  для
функций  является бессмысленным (язык Си не в состоянии ком-
пилировать программу в стек); если идентификатор  имеет  тип
<b>функция</b>,  <b>возвращающая</b> ..., то он предполагается неявно опи-
санным как <b>extern</b>.

     Входящий в выражение и неописанный ранее идентификатор,
за   которым   следует  скобка  <b>(</b>,  считается  описанным  по


                            <b>-42-</b>


контексту как <b>функция</b>, <b>возвращающая</b> <b>int</b>.

       /* <b>extern</b> */ <b>int</b> <b>tab</b>[100];
       <b>static</b> /* <b>int</b> */ <b>t1</b>;
       /* <b>int</b> */ <b>func</b>(<b>i</b>) /* <b>int</b> <b>i</b>; */
       <b>{ register</b> /* <b>int</b> */ <b>k</b>;
         /* <b>auto</b> */ <b>char</b> <b>buf</b>[512];
         /* <b>extern int</b> <b>f1</b>(); */
         ... <b>f1</b>(<b>a</b>,<b>b</b>) ...


<ul><a name=70></a><h2> * 9.  ПРЕПРОЦЕССОР ЯЗЫКА 'СИ'</h2></ul>

     Компилятор языка Си содержит препроцессор, который поз-
воляет  осуществлять макроподстановки, условную компиляцию и
включение именованных  файлов.  Строки,  начинающиеся  с  <b>#</b>,
являются командами этого препроцессорa. Синтаксис этих строк
не связан с остальным языком; они могут появляться  в  любом
месте  и  их влияние распространяется (независимо от области
действия) до конца исходного программного файла.  Фактически
препроцессор  расширяет возможности языка Си, реализуя такие
функции, которые в других  языках  входят  в  состав  самого
языка (например, параметрические константы в Фортране-77).

<ul><a name=71></a><h2>9.1.  Замена лексем</h2></ul>

     Команда

    <b>#define</b> <b>идентификатор строка</b>_<b>лексем</b>

(обратите внимание на отсутствие в конце  точки  с  запятой)
приводит к тому, что препроцессор заменяет последующие вхож-
дения  этого  идентификатора  на  указанную  строку  лексем.
Строка вида

    <b>#define</b> <b>идентификатор</b>(<b>идентифика</b>-
         <b>тор</b>,...,<b>идентификатор</b>) <b>строка</b>_<b>лексем</b>

где между первым идентификатором и открывающейся скобкой "("
нет  пробела, представляет собой макроопределение с аргумен-
тами. В дальнейшем первый идентификатор, за которым  следует
открывающая скобка "(", последовательность разделенных запя-
тыми лексем и закрывающая  скобка  ")",  заменяются  строкой
лексем из определения. Каждое вхождение идентификатора, упо-
мянутого в списке формальных параметров в определении, заме-
няется  соответствующей  строкой лексем из обращения. Факти-
ческими аргументами в обращении являются строки лексем, раз-
деленные  запятыми;  однако запятые, входящие в закавыченные
строки или заключенные в круглые скобки, не разделяют  аргу-
ментов.   Количество  формальных  и  фактических  параметров
должно совпадать. Текст внутри строки или  символьной  конс-
танты не подлежит замене.

                            <b>-43-</b>


     В обоих случаях замененная строка просматривается снова
с  целью обнаружения других идентификаторов, известных преп-
роцессору. В обоих случаях слишком длинная строка  определе-
ния может быть продолжена на другой строке, если поместить в
конце продолжаемой строки обратную косую черту "<b>\</b>".

     Описываемая возможность особенно полезна для  определе-
ния "объявляемых констант", как, например,

    <b>#define</b> TABSIZE 100
    <b>int</b> <b>table</b>[TABSIZE];

или для замены некоторых функций с помощью макроподстановки:

    <b>#define</b> <b>max</b>(<b>a</b>,<b>b</b>) ((<b>a</b>)&gt;(<b>b</b>)?(<b>a</b>):(<b>b</b>))
    <b>x</b> = <b>max</b>(<b>y</b>,20)

(в последнем определении <b>a</b> и <b>b</b> взяты  в  скобки,  для  того,
чтобы  фактическими  параметрами  макро могли бы быть произ-
вольные выражения.

     Команда

    <b>#undef</b> <b>идентификатор</b>

приводит к отмене препроцессорного определения данного иден-
тификатора.

     Определить идентификатор  можно  не  только  с  помощью
команды  <b>#define</b>,  но  также  и  при  вызове  компилятора, с
помощью параметров команды <b>cc</b>.

<ul><a name=72></a><h2>9.2.  Включение файлов</h2></ul>

     Команда

    <b>#include</b> "<b>filename</b>"


приводит к замене этой строки на все содержимое файла с име-
нем  <b>filename</b>.  Файл  с этим именем сначала ищется в текущем
справочнике, а затем в других "стандартных" местах,  опреде-
ляемых  пользователем  при  вызове компилятора. В отличие от
этого команда

    <b>#include</b> &lt;<b>filename</b>&gt;

ищет файл только в стандартном справочнике системы.

     В <b>ОС ДЕМОС</b> файл ищется в справочнике /<b>usr</b>/<b>include</b>.

     Команды <b>#include</b> могут быть вложенными.

                            <b>-44-</b>


<ul><a name=73></a><h2>9.3.  Условная компиляция</h2></ul>

     Команда препроцессора

     <b>#if</b> <b>константное выражение</b>

проверяет, отлично ли от нуля значение константного  выраже-
ния.  Команда:

    <b>#ifdef</b> <b>идентификатор</b>

проверяет,  определен  ли  этот  идентификатор  в  настоящий
момент в препроцессоре, т.е. определен ли этот идентификатор
с помощью команды <b>#define</b>. Команда:

    <b>#ifndef</b> <b>идентификатор</b>

проверяет, является ли этот идентификатор в данный момент не
определенным для препроцессора.

     За каждым из трех перечисленных видов строк может  сле-
довать произвольное число строк, возможно содержащих команду
препроцессора

    <b>#else</b>

а затем должна следовать команда:

    <b>#endif</b>

Если проверяемое условие  истинно,  то  любые  строки  между
<b>#else</b> и <b>#endif</b> игнорируются. Если проверяемое условие ложно,
то любые строки между проверяемой строкой и <b>#else</b>  или,  при
отсутствии <b>#else</b>, <b>#endif</b> игнорируются.

     Эти конструкции могут быть вложенными.

     Например:

    <b>#ifdef DEBUG</b>
    <b>fprintf</b>(<b>stderr</b>,"<b>i</b>=%<b>o j</b>=%<b>d\n</b>",<b>i</b>,<b>j</b>);
    <b>#endif</b>

Переменная препроцессора может быть определена не  только  в
самой программе, но и при вызове транслятора.

<ul><a name=74></a><h2>9.4.  Команда #line</h2></ul>

     Для других препроцессоров,  генерирующих  Си-программы,
полезна следующая команда:

    <b>#line</b> <b>константа</b> <b>"</b><b>имя</b>_<b>файла</b>"

                            <b>-45-</b>


которая сообщает компилятору  (для  диагностических  сообще-
ний),  что  следующая  строка  исходного  файла имеет номер,
задаваемый константой, и что текущий входной файл  именуется
<b>именем</b>_<b>файла</b>.   Если  <b>имя</b>_<b>файла</b> отсутствует, то запоминаемое
имя файла не изменяется.  Пример:

    <b>#line</b> 250 "<b>gram</b>.<b>y</b>"


<ul><a name=75></a><h2> * 10.  ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ О ТИПАХ</h2></ul>

     В этом разделе обобщаются сведения об операциях,  кото-
рые можно применять только к объектам определенных типов.

<ul><a name=76></a><h2>10.1.  Структуры и объединения</h2></ul>

     Со структурами и объединениями могут производиться сле-
дующие  операции:  ссылка  на  один  из членов структуры или
объединения (с помощью  операции  <b>.</b>),  получение  адреса  (с
помощью  унарной  операции <b>&</b>), присваивание структуры струк-
туре, передача структуры в качестве  формального  параметра,
возврат  структуры  функцией.  Все остальные операции запре-
щены.

     В реализации возвращения структур функциями  на  CM-ЭВМ
имеется  коварный  дефект: если во время возврата происходит
прерывание и та же самая функция  реентерабельно  вызывается
во время этого прерывания, то значение, возвращаемое из пер-
вого вызова, может быть испорчено. Эта трудность может  воз-
никнуть только при наличии истинного прерывания, как из опе-
рационной системы, так и из программы пользователя; прерыва-
ния,  которое  действительно асинхронно; обычные рекурсивные
вызовы совершенно безопасны.

     В разделе "Выражения" говорится,  что  при  прямой  или
косвенной  ссылке  на  структуру  (с  помощью  <b>.</b> или <b>-</b>>) имя
справа должно быть членом конструкции, названной или указан-
ной выражением слева. Это ограничение не навязывается строго
компилятором, чтобы дать возможность  обойти  правила  соот-
ветствия  типов.   В  действительности  перед  <b>.</b> допускается
любое l_значение и затем предполагается, что это  l_значение
имеет  форму структуры, для которой стоящее справа имя явля-
ется членом. Таким же образом, от выражения, стоящего  перед
<b>-</b>>,  требуется  только  быть  указателем или целым. В случае
указателя предполагается, что он указывает на структуру, для
которой  стоящее справа имя является членом. В случае целого
оно рассматривается  как  абсолютный  адрес  соответствующей
структуры, заданный в единицах машинной памяти.

     Такие структуры не являются переносимыми.


                            <b>-46-</b>


<ul><a name=77></a><h2>10.2.  Функции</h2></ul>

     Только две операции можно применять к функции:  вызвать
ее или извлечь ее адрес. Если имя функции входит в выражение
не в позиции имени функции, соответствующей обращению к ней,
то  генерируется  указатель  на  эту функцию. Следовательно,
чтобы передать одну функцию другой, можно написать

            <b>int</b> <b>f</b>();
            ...
            <b>g</b>(<b>f</b>);

тогда определение функции <b>g</b> могло бы выглядеть так:

            <b>g</b>(<b>funcp</b>)
            <b>int</b> (<b>*</b><b>funcp</b>)();
            <b>{</b>
                    ...
                    (<b>*</b><b>funcp</b>)();
                    ...
            <b>}</b>

Обратите внимание, что  в  вызывающей  процедуре  функция  <b>f</b>
должна быть описана явно, потому что за ее появлением в <b>g</b>(<b>f</b>)
не следует скобка "(".

<ul><a name=78></a><h2>10.3.  Массивы, указатели и индексация</h2></ul>

     Каждый раз, когда идентификатор, имеющий  тип  массива,
появляется в выражении, он преобразуется в указатель на пер-
вый член этого массива.  Из-за этого преобразования  массивы
не являются l_значениями. По определению операция индексации
"[]" интерпретируется таким образом,  что  <b>e1</b>[<b>e2</b>]  считается
идентичным  выражению <b>*</b>((<b>e1</b>)+(<b>e2</b>)). Согласно правилам преоб-
разований, применяемым при операции <b>+</b>, если <b>e1</b> -  массив,  а
<b>e2</b>  -  целое,  то  <b>e1</b>[<b>e2</b>] ссылается на <b>e2</b>-й член массива <b>e1</b>.
Поэтому, несмотря на несимметричный вид, операция индексации
является коммутативной.

     В случае многомерных массивов  применяется  аналогичное
правило.    Если   <b>e</b>   является  <b>n</b>-мерным  массивом  размера
<b>i</b>*<b>j</b>*...*<b>k</b>, то при появлении в выражении  <b>e</b>  преобразуется  в
указатель  на (<b>n</b>-1)-мерный массив размера <b>j</b>*...*<b>k</b>. Если опе-
рация <b>*</b> либо явно, либо неявно,  как  результат  индексации,
применяется к этому указателю, то результатом операции будет
указанный (<b>n</b>-1)-мерный массив, который сам немедленно преоб-
разуется в указатель.

     Рассмотрим, например, описание:

            <b>int</b> <b>u</b>[3][5];

Здесь  <b>u</b>  -  массив  целых  размера  3*5.  При  появлении  в


                            <b>-47-</b>


выражении u преобразуется в указатель на первый из трех мас-
сивов из 5 целых. В  выражении  <b>u</b>[<b>i</b>],  которое  эквивалентно
<b>*</b>(<b>u</b>+<b>i</b>), сначала <b>u</b> преобразуется в указатель так, как описано
выше; затем <b>i</b> преобразуется к типу <b>u</b>, что вызывает умножение
<b>i</b> на длину объекта, на который указывает указатель, а именно
на 5 целых объектов. Результаты складываются,  и  применение
косвенной адресации дает массив (из 5 целых), который в свою
очередь преобразуется в указатель на первое из  этих  целых.
Если  в  выражение  входит  и  другой индекс, то та же самая
аргументация применяется  снова;  результатом  на  этот  раз
будет целое.

     Из всего этого следует, что массивы в языке Си хранятся
построчно  (последний индекс изменяется быстрее всего) и что
первый индекс в описании  помогает  определить  общее  коли-
чество  памяти, требуемое для хранения массива, но не играет
никакой другой роли в вычислениях, связанных с индексацией.

<ul><a name=79></a><h2>10.4.  Явные преобразования указателей</h2></ul>

     Разрешаются определенные преобразования  с  использова-
нием  указателей.  Они имеют некоторые зависящие от конкрет-
ной реализации аспекты.  Все эти преобразования  задаются  с
помощью операции явного преобразования типа.

     Указатель может быть преобразован в любой  из  целочис-
ленных типов, достаточно большой для его хранения. Требуется
ли при этом <b>int</b> или <b>long</b>, зависит от конкретной машины (в <b>ОС</b>
<b>ДЕМОС</b>  для  СМ  ЭВМ  требуется  <b>int</b>).  Преобразующая функция
также  является  машинно-зависимой,  но  она  будет   вполне
естественной  для  тех,  кто  знает  структуру  адресации  в
машине. Детали для  некоторых  конкретных  машин  приводятся
ниже.

     Объект целочисленного типа  может  быть  явным  образом
преобразован  в указатель. Такое преобразование всегда пере-
водит преобразованное из указателя целое в тот же самый ука-
затель, но в других случаях оно будет машинно-зависимым.

     Указатель на один тип может быть преобразован в  указа-
тель  на  другой тип. Если преобразуемый указатель не указы-
вает на объекты,  которые  подходящим  образом  выравнены  в
памяти,  то результирующий указатель может при использовании
вызывать ошибки адресации. Гарантируется, что  указатель  на
объект заданного размера может быть преобразован в указатель
на объект меньшего размера и снова обратно, не претерпев при
этом изменения.

     Например, процедура распределения памяти <b>alloc</b> могла бы
принимать  запрос  на размер выделяемого объекта в байтах, а
возвращать указатель на символы; это можно было бы использо-
вать следующим образом.

                            <b>-48-</b>


            extern char *<b>alloc</b>();
            <b>double *</b><b>dp</b>;
            <b>dp</b>=(<b>double*</b>) <b>alloc</b>(<b>sizeof</b>(<b>double</b>));
            <b>*</b><b>dp</b>=22.0/7.0;

Функция <b>alloc</b> должна обеспечивать (машинно-зависимым  спосо-
бом), что возвращаемое ею значение будет подходящим для пре-
образования в указатель на <b>double</b>; в таком случае  использо-
вание этой функции будет переносимым.

     Представление указателя  на  CM-ЭВМ  соответствует  16-
битовому  целому и измеряется в байтах. Объекты типа <b>char</b> не
имеют никаких ограничений  на  выравнивание;  все  остальные
объекты должны иметь четные адреса.

<ul><a name=80></a><h2> * 11.  КОНСТАНТНЫЕ ВЫРАЖЕНИЯ</h2></ul>

     В нескольких местах в  языке  Си  требуются  выражения,
которые после вычисления становятся константами: после вари-
антного префикса <b>case</b>, в качестве границ массивов и в иници-
ализаторах.  В первых двух случаях выражение может содержать
только целые константы,  символьные  константы  и  выражения
<b>sizeof</b>, возможно связанные либо бинарными операциями

       <b>+ - * / . % & | ^</b> <b>&lt;</b><b>&lt;</b> >> <b>== 1=</b> <b>&lt;</b>> <b>&lt;</b><b>=</b> ><b>=</b>

либо унарными операциями

            <b>- ~</b>

либо тернарной операцией

            <b>?:</b>

Круглые скобки могут использоваться для группировки,  но  не
для обращения к функциям.

     В случае инициализаторов допускается большая  (ударение
на  букву  о)  свобода; кроме перечисленных выше константных
выражений можно также применять унарную операцию <b>&</b> к внешним
или  статическим объектам и к внешним или статическим масси-
вам, имеющим  в  качестве  индексов  константное  выражение.
Унарная  операция  <b>&</b>  может  быть  также применена неявно, в
результате появления неиндексированных массивов  и  функций.
Основное  правило  заключается  в  том, что после вычисления
инициализатор должен становится либо константой, либо  адре-
сом  ранее описанного внешнего или статического объекта плюс
или минус константа.

<ul><a name=81></a><h2> * 12.  СООБРАЖЕНИЯ О ПЕРЕНОСИМОСТИ</h2></ul>

     Одним из достоинств языка  Си  считается  переносимость
программ на Си, которая связана как с относительной машинной


                            <b>-49-</b>


независимостью самого языка, так и с  совместимостью  среды,
обеспечиваемой  совместимыми  с ОС UNIX операционными систе-
мами.  Вместе с тем, при написании на языке Си  таких  прог-
рамм,  которые не должны зависеть от конкретной ЭВМ, необхо-
димо учитывать то, что некоторые части  языка  Си  по  своей
сути  машинно-зависимы. Следующее ниже перечисление потенци-
альных трудностей хотя  и  не  являются  всеобъемлющими,  но
выделяет основные из них.

     Вопросы, целиком связанные с аппаратным  оборудованием,
такие  как  размер слова, свойства вещественной арифметики и
целого деления, не представляют особенных затруднений.  Дру-
гие аспекты аппаратных средств находят свое отражение в раз-
личных реализациях.  Некоторые из них, в частности, знаковое
расширение (преобразующее отрицательный символ в отрицатель-
ное целое) и порядок, в котором помещаются  байты  в  слове,
представляют  собой  неприятность,  которая должна тщательно
отслеживаться. Большинство остальных проблем этого  типа  не
вызывает сколько_нибудь значительных затруднений.

     Число  переменных  типа  <b>register</b>,  которое  фактически
может быть помещено в регистры, меняется от машины к машине,
также как и набор допустимых для них типов. Тем не менее все
компиляторы  на  своих  машинах работают надлежащим образом;
лишние или недопустимые регистровые описания игнорируются.

     Некоторые трудности возникают только при  использовании
сомнительной  практики программирования, или при использова-
нии особенностей конкретной реализации.   Писать  программы,
которые  зависят  от  таких  особенностей, чрезвычайно нера-
зумно.

     Языком не  указывается  порядок  вычисления  аргументов
функций;  они вычисляются справа налево на CM-ЭВМ и ЭВМ <b>PDP</b>-
11 и <b>VAXR-11 фирмы DEC</b>  и  слева   направо  на   большинстве
остальных  машин.  Порядок,  в  котором  происходят побочные
эффекты, также не специфицируется.

     Так как символьные константы в  действительности  явля-
ются  объектами типа <b>int</b>, допускается использование символь-
ных констант, состоящих из нескольких символов. Однако, пос-
кольку  порядок,  в  котором  символы приписываются к слову,
меняется от машины к машине, конкретная реализация  оказыва-
ется весьма машинно_зависимой.

     Порядок присваивания полей к словам и символов к  целым
также зависит от ЭВМ.  Такие различия незаметны для изолиро-
ванных программ, в которых не разрешено смешивать типы (пре-
образуя,  например,  указатель  на <b>int</b> в указатель на <b>char</b> и
затем проверяя указываемую память),  но  должны  учитываться
при согласовании с накладываемыми извне схемами памяти.

                            <b>-50-</b>


     Язык, принятый на  различных  компиляторах,  отличается
только незначительными деталями. Самое заметное отличие сос-
тоит в том, что используемый в настоящее время компилятор на
CM-ЭВМ  не  инициализирует  структуры, которые содержат поля
битов, не имеет типа "unsigned <b>char</b>" и имеет некоторые огра-
ничения  на операции присваивания в определенных контекстах,
связанных с использованием значения присваивания структур.

<ul><a name=82></a><h2>12.1.  Анахронизмы</h2></ul>

     В старых программах можно встретить некоторые  устарев-
шие конструкции. Хотя большинство версий компилятора поддер-
живает такие анахронизмы, они в конце концов исчезнут, оста-
вив за собой только проблемы переносимости.

     В ранних версиях Си для проблем присваивания  использо-
валась  форма  =<b>оп</b>,  а  не  <b>оп</b>=, приводя к двусмысленностям,
типичным примером которых является

            <b>х</b> =-1

где <b>х</b> фактически уменьшается, поскольку операции <b>=</b> и <b>-</b>  при-
мыкают  друг  к другу, но что вполне могло рассматриваться и
как присваивание -1 к <b>х</b>.

     Синтаксис  инициализаторов   изменился:   раньше   знак
равенства,  с  которого начинается инициализатор, отсутство-
вал, так что вместо

            <b>int</b> <b>х</b> = 1;

использовалось

            <b>int</b> <b>х</b> 1;


изменение было внесено из_за инициализации

            <b>int</b> <b>f</b> (1+2)

которая достаточно сильно  напоминает  определение  функции,
чтобы смутить компиляторы.

<ul><a name=83></a><h2> * 13.  СТАНДАРТНАЯ БИБЛИОТЕКА ВВОДА И ВЫВОДА</h2></ul>

     Средства  ввода/вывода  не  являются  составной  частью
языка  Си.   В этой главе будет описана "стандартная библио-
тека ввода/вывода", то есть набор функций, разработанных для
обеспечения  стандартной  системы ввода/вывода для Си- прог-
рамм. Эти функции отражают только те операции, которые могут
быть обеспечены на большинстве современных операционных сис-
тем. Процедуры достаточно эффективны для того, чтобы пользо-
ватели  редко  чувствовали  необходимость  обойти  их  "ради


                            <b>-51-</b>


эффективности", как бы ни была важна конкретная  задача.   И
наконец, эти процедуры были задуманы авторами языка "перено-
симыми" в том смысле, что они должны существовать в  совмес-
тимом  виде  на  любой  системе,  где имеется язык Си, и что
программы, которые ограничивают свои взаимодействия  с  сис-
темными  возможностями, предоставляемыми стандартной библио-
текой, можно будет переносить с одной системы на  другую  по
существу без изменений.

     Далее   описываются   основные   принципы   организации
ввода/вывода  в программах на языке Си, использующих библио-
теку ввода/вывода. Полное описание этой библиотеки имеется в
руководстве  программиста  (часть 4) или в оперативной доку-
ментации ("<b>man</b>(3)").   Программы,  работающие  в  ОС  ДЕМОС,
могут  также  обращаться  к  функциям  ввода/вывода  низкого
уровня, которые реализованы непосредственно в ядре <b>ОС ДЕМОС</b>,
но такая необходимость возникает достаточно редко.

<ul><a name=84></a><h2>13.1.  Обращение к стандартной библиотеке</h2></ul>

     Каждый исходный файл, который обращается к  функции  из
стандартной  библиотеки,  должен  где  то в начале содержать
строку

            <b>#include</b> &lt;<b>stdio.h</b>&gt;

В файле <b>stdio.h</b> определяются некоторые макросы и переменные,
используемые библиотекой ввода/вывода.

<ul><a name=85></a><h2>13.2.  Стандартный ввод и вывод</h2></ul>

     Самый простой механизм ввода заключается  в  чтении  по
одному символу за раз из "стандартного ввода" (обычно с тер-
минала пользователя)  с  помощью  функции  <b>getchar</b>.  Функция
<b>getchar</b>()  целого типа при каждом к ней обращении возвращает
следующий вводимый символ.  В  большинстве  систем,  которые
поддерживают  язык Си, терминал может быть заменен некоторым
файлом с помощью обозначения "<b>&lt;</b>". Если  некоторая  программа
<b>prog</b> использует функцию <b>getchar</b>, то командная строка

            <b>prog</b> <b>&lt;</b><b>infile</b>

приведет к тому, что <b>prog</b> будет читать из файла <b>infile</b>, а не
с  терминала. Переключение ввода делается таким образом, что
сама программа  <b>prog</b>  не  замечает  изменения;  в  частности
строка "<b>&lt;</b><b>infile</b>" не включается в командную строку аргументов
(см. следующую главу).  Переключение ввода оказывается неза-
метным и в том случае, когда вывод поступает из другой прог-
раммы через межпроцессный канал.  Например, командная строка

            <b>otherprog</b> <b>|</b> <b>prog</b>

прогоняет  две  программы,  <b>otherprog</b>  и  <b>prog</b>,   так,   что


                            <b>-52-</b>


стандартным  вводом для <b>prog</b> служит стандартный вывод <b>other-</b>
<b>prog</b>.

     Функция <b>getchar</b> возвращает значение <b>EOF</b>, когда достига-
ется  конец  файла, какой бы ввод она при этом не считывала.
Стандартная библиотека полагает символическую константу  <b>EOF</b>
равной -1 (посредством <b>#define</b> в файле <b>stdio.h</b>), но проверки
следует писать в терминах <b>EOF</b>, а не -1, чтобы избежать зави-
симости от конкретного значения.

     Вывод можно осуществлять с помощью функции  <b>putchar</b>(<b>c</b>),
помещающей  символ  '<b>c</b>'  в  "стандартный  вывод", который по
умолчанию является терминалом. Вывод можно при вызове  прог-
раммы  направить в некоторый файл с помощью обозначения ">".
Если <b>prog</b> использует <b>putchar</b>, то командная строка

            <b>prog</b> > <b>outfile</b>


приведет к записи стандартного вывода в файл <b>outfile</b>,  а  не
на терминал.  В системе <b>ДЕМОС</b> можно также использовать межп-
роцессный канал.

     В стандартной библиотеке ввода/вывода "функции" <b>getchar</b>
и <b>putchar</b> на самом деле могут быть макросами.  Это позволяет
избежать накладных расходов на обращение к функции для обра-
ботки каждого символа.

<ul><a name=86></a><h2>13.3.  Форматный вывод - функция printf</h2></ul>

     Две функции: <b>printf</b> для вывода и <b>scanf</b> для ввода  (сле-
дующий  раздел) позволяют преобразовывать численные величины
в символьное представление и обратно.  Они  также  позволяют
генерировать и интерпретировать форматные строки.  Функция

            <b>printf</b>(<b>control</b>, <b>arg1</b>, <b>arg2</b>, ...)

преобразует аргументы в текстовую  форму  в  соответствии  с
форматами,  заданными в управляющей строке <b>control</b>, и выдает
результат в стандартный вывод. Управляющая  строка  содержит
два  типа  объектов: обычные символы, которые просто копиру-
ются в выходной поток, и спецификации преобразований, каждая
из которых вызывает преобразование и печать очередного аргу-
мента <b>printf</b>.

     Каждая спецификация преобразования начинается с символа
"<b>%</b>" и заканчивается символом преобразования (буквой, опреде-
ляющей тип преобразования).  Между "<b>%</b>" и символом преобразо-
вания могут находиться:

     - Знак минус, который вызывает выравнивание  преобразо-
       ванного аргумента по левому краю поля.

                            <b>-53-</b>


     - Строка цифр, задающая минимальную ширину поля. Преоб-
       разованное  число  будет напечатано в поле по крайней
       мере этой ширины, а если необходимо,  то  и  в  более
       широком.  Если  преобразованный аргумент имеет меньше
       символов, чем указанная  ширина  поля,  то  он  будет
       дополнен  слева (или справа, если было указано вырав-
       нивание по левому  краю)  заполняющими  символами  до
       этой  ширины.  Заполняющим  символом  обычно является
       пробел, а если ширина поля указывается  с  лидирующим
       нулем, то этим символом будет нуль (лидирующий нуль в
       данном случае не означает восьмеричной ширины поля).

     - Точка, которая  отделяет  ширину  поля  от  следующей
       строки цифр.

     - Строка цифр (точность);  указывает максимальное число
       символов  строки, которые должны быть напечатаны, или
       число печатаемых справа от десятичной точки цифр  для
       переменных типа <b>float</b> или <b>double</b>.

     - Модификатор длины <b>l</b>,  который  указывает,  что  соот-
       ветствующий элемент данных имеет тип <b>long</b>, а не <b>int</b>.

     Ниже приводятся символы преобразования и их смысл:

<b>d</b>    - аргумент преобразуется к десятичному виду;

<b>o</b>    - аргумент  преобразуется  в  беззнаковую  восьмеричную
       форму (без лидирующего нуля);

<b>x</b>    - аргумент преобразуется в беззнаковую  шестнадцатерич-
       ную форму (без лидирующих 0х);

u    - аргумент  преобразуется  в   беззнаковую   десятичную
       форму;

<b>c</b>    - аргумент рассматривается как отдельный символ;

<b>s</b>    - аргумент является строкой: символы строки  печатаются
       до  тех  пор,  пока не будет достигнут нулевой символ
       или не будет напечатано количество символов,  указан-
       ное в спецификации точности;

<b>e</b>    - аргумент, рассматриваемый как переменная  типа  <b>float</b>
       или  <b>double</b>,  преобразуется в десятичную форму в виде
       [-]<b>m</b>.<b>nnnnnne</b>[+-]<b>хх</b>, где длина строки из  <b>n</b>  определя-
       ется указанной точностью. Точность по умолчанию равна
       6;

<b>f</b>    - аргумент, рассматриваемый как переменная  типа  <b>float</b>
       или  <b>double</b>,  преобразуется в десятичную форму в виде
       [-]<b>mmm</b>.<b>nnnnn</b>, где длина строки из n определяется ука-
       занной  точностью.  Точность  по  умолчанию  равна 6.


                            <b>-54-</b>


       Отметим, что эта точность  не  определяет  количество
       печатаемых в формате <b>f</b> значащих цифр;

<b>g</b>    - используется или формат <b>%e</b> или <b>%f</b>, какой короче; нез-
       начащие нули не печатаются.

Вместо "<b>ld</b>"можно использовать "<b>D</b>", вместо "<b>lo</b>" - "<b>O</b>", вместо
"<b>lx</b>" - "<b>X</b>".

     Если идущий за <b>%</b> символ не является символом преобразо-
вания, то печатается сам этот символ; следовательно,символ <b>%</b>
можно напечатать, указав <b>%%</b>.

     Большинство  из  форматных   преобразований   очевидно.
Единственным  исключением  является то, как точность взаимо-
действует со строками. Следующая таблица демонстрирует влия-
ние различных спецификаций на печать "<b>hello</b>, <b>world</b>" (12 сим-
волов). Вокруг каждого поля  помещены  двоеточия  для  того,
чтобы можно было определить его протяженность.

      :<b>%</b>10<b>s</b>:      :<b>hello</b>, <b>world</b>:
      :<b>%</b>10<b>-s</b>:     :<b>hello</b>, <b>world</b>:
      :<b>%</b>20<b>s</b>:      :        <b>hello</b>, <b>world</b>:
      :<b>%-</b>20<b>s</b>:     :<b>hello</b>, <b>world</b>        :
      :<b>%</b>20.10<b>s</b>:   :          <b>hello</b>, <b>wor</b>:
      :<b>%-</b>20.10<b>s</b>:  :<b>hello</b>, <b>wor</b>          :
      :<b>%.</b>10<b>s</b>:     :<b>hello</b>, <b>wor</b>:


ПРЕДОСТЕРЕЖЕНИЕ: <b>printf</b> использует свой первый аргумент  для
определения  числа  последующих  аргументов и их типов. Если
количество аргументов окажется недостаточным или  они  будут
иметь   несоответствующие  типы,  то  возникнет  путаница  и
результаты будут неверными.

<ul><a name=87></a><h2>13.4.  Форматный ввод - функция scanf</h2></ul>

     Осуществляющая ввод  функция  scanf  является  аналогом
<b>printf</b>  и  позволяет проводить в обратном направлении многие
из тех же самых преобразований. Функция

            <b>scanf</b>(<b>control</b>, <b>arg1</b>, <b>arg2</b>, ...)

читает символы из стандартного ввода,  интерпретирует  их  в
соответствии  с  форматом,  указанном в аргументе <b>control</b>, и
помещает  результаты  в  остальные  аргументы.   Управляющая
строка описывается ниже; другие аргументы, каждый из которых
должен быть указателем, определяют, куда  следует  поместить
соответствующим образом преобразованный ввод.

     Управляющая строка обычно содержит спецификации  преоб-
разования, которые используются для непосредственной интерп-
ретации  входных  последовательностей.  Управляющая   строка


                            <b>-55-</b>


может содержать:

     - пробелы, табуляции или символы новой строки ("символы
       пустых промежутков"), которые игнорируются;

     - обычные символы (не <b>%</b>), которые предполагаются совпа-
       дающими  со  следующими отличными от "символов пустых
       промежутков" символами входного потока;

     - спецификации преобразования, состоящие из символа  %,
       необязательного  символа  подавления  присваивания <b>*</b>,
       необязательного числа, задающего максимальную  ширину
       поля и символа преобразования.

     Спецификация преобразования  управляет  преобразованием
следующего  поля  ввода. Обычно результат помещается в пере-
менную,  которая  указывается  соответствующим   аргументом.
Если,  однако , с помощью символа * указано подавление прис-
ваивания, то это поле ввода просто пропускается  и  никакого
присваивания  не  производится.  Поле ввода определяется как
строка символов, которые отличны от "символов простых проме-
жутков"; оно продолжается либо до следующего символа пустого
промежутка, либо пока не будет исчерпана ширина  поля,  если
она  указана.  Отсюда  следует,  что  при  поиске нужного ей
ввода, функция <b>scanf</b> будет пересекать  границы  строк,  пос-
кольку символ новой строки является одним из символов пустых
промежутков.

     Имеется возможность задания  более  сложного  алгоритма
выделения  полей  ввода, которая описана в руководстве прог-
раммиста ("<b>scanf</b>(3)").

     Символ  преобразования  определяет  интерпретацию  поля
ввода;  поскольку  в  Си  аргументы  передаются по значению,
аргументы <b>scanf</b> должны быть указателями. Допускаются следую-
щие символы преобразования:

<b>d</b>    - На вводе ожидается десятичное целое;  соответствующий
       аргумент должен быть указателем на целое.

<b>o</b>    - На вводе ожидается восьмеричное целое  (с  лидирующим
       нулем  или без него); соответствующий аргумент должен
       быть указателем на целое.

<b>x</b>    - На вводе ожидается шестнадцатиричное целое (с лидиру-
       ющими  0<b>х</b> или без них); соответствующий аргумент дол-
       жен быть указателем на целое.

<b>h</b>    - На вводе ожидается целое типа <b>short</b>;  соответствующий
       аргумент должен быть указателем на целое типа <b>short</b>.

<b>c</b>    - Ожидается отдельный символ; соответствующий  аргумент
       должен быть указателем на символы; следующий вводимый


                            <b>-56-</b>


       символ помещается в указанное место. Обычный  пропуск
       символов  пустых  промежутков  в этом случае подавля-
       ется; для чтения следующего символа, который не явля-
       ется  символом пустого промежутка, пользуйтесь специ-
       фикацией преобразования <b>%</b>1<b>s</b>.

<b>s</b>    - Ожидается символьная строка; соответствующий аргумент
       должен быть указателем символов, который указывает на
       массив  символов,  достаточно  большой  для  принятия
       строки и добавляемого в конце символа \0.

<b>f</b>    - Ожидается число с вещественной точкой;  соответствую-
       щий  аргумент  должен  быть  указателем на переменную
       типа <b>float</b>.

<b>e</b>    - Символ преобразования <b>e</b>  является  синонимом  для  <b>f</b>.
       Формат  ввода переменной типа <b>float</b> включает необяза-
       тельный знак, строку цифр, возможно содержащую  деся-
       тичную точку и необязательное поле экспоненты, состо-
       ящее из буквы <b>e</b>, за которой следует  целое,  возможно
       имеющее знак.

     Перед символами преобразования <b>d</b>, <b>o</b> и  <b>x</b>  может  стоять
буква  <b>l</b>,  которая  означает, что в списке аргументов должен
находиться указатель на переменную типа <b>long</b>, а не типа <b>int</b>.
Аналогично,  буква <b>l</b> может стоять перед символами преобразо-
вания <b>e</b> или <b>f</b>, говоря о том, что в списке аргументов  должен
находиться  указатель  на  переменную типа <b>double</b>, а не типа
<b>float</b>.

     Например, обращение

             <b>int</b>  1;
             <b>float</b> <b>х</b>;
             <b>char</b> <b>name</b>[50];
             <b>scanf</b>("%<b>d</b> %<b>f</b> %<b>s</b>", &<b>i</b>, &<b>х</b>, <b>name</b>);

со строкой на вводе

             25    54.32<b>e</b>-1   <b>thompson</b>

приводит к присваиванию <b>i</b> значения 25, <b>х</b> - значения 5.432  и
<b>name</b>  -  строки  "<b>thompson</b>",  надлежащим образом законченной
символом <b>\</b>0.  Эти три поля ввода можно разделить  произволь-
ным  числом  пробелов,  табуляций  и  символов новой строки,
сколько вы пожелаете. Обращение

         <b>int</b>   <b>i</b>;
         <b>float</b> <b>х</b>;
         <b>char</b> <b>name</b>[50];
         <b>scanf</b>("%<b>2d</b> %<b>f</b> %*<b>d</b> %<b>2s</b>", &<b>i</b>, &<b>х</b>, <b>name</b>);

с вводом


                            <b>-57-</b>


             <b>56789 0123 45а72</b>

присвоит <b>i</b> <b>значение</b> <b>56</b>, <b>х</b> - <b>789</b>.<b>0</b>, пропустит <b>0123</b> и поместит
в  <b>name</b>  строку "<b>45</b>". При следующем обращении к любой проце-
дуре ввода рассмотрение начнется с буквы <b>a</b>. В этих двух при-
мерах  name  является указателем и, следовательно, перед ним
не нужно помещать знак <b>&</b>.

     В качестве другого примера приведем программу для  сум-
мирования чисел, вводимых с терминала:

    <b>#include</b>  &lt;<b>stdio.h</b>&gt;
     <b>main</b>()    /* Примитивный калькулятор */
     <b>{</b>
          <b>double</b> <b>sum</b>, <b>v</b>;
          <b>sum</b> =0;
          <b>while</b> (<b>scanf</b>("<b>%</b><b>lf</b>", <b>&</b><b>v</b>) !=<b>EOF</b>)
               <b>printf</b>("<b>\t</b><b>%</b>.2<b>fFI\n</b>", <b>sum</b> += <b>v</b>);
     <b>}</b>

Выполнение функции <b>scanf</b> заканчивается либо тогда, когда она
исчерпывает  свою  управляющую  строку, либо когда некоторый
элемент ввода не соответствует очередной спецификации преоб-
разования.   В качестве своего значения она возвращает число
правильно распознанных элементов ввода. Это число может быть
использовано  для определения количества найденных элементов
ввода. При выходе на конец файла возвращается <b>EOF</b>;  подчерк-
нем, что это значение отлично от 0, означающего, что следую-
щий вводимый символ не удовлетворяет первой  спецификации  в
управляющей  строке.  При следующем обращении к <b>scanf</b>  поиск
возобновляется непосредственно за последним введенным симво-
лом.

     ПРЕДОСТЕРЕЖЕНИЕ: аргументы функции  <b>scanf</b>  должны  быть
указателями.  Несомненно,  наиболее  распространенная ошибка
состоит в написании

            <b>scanf</b>("<b>%</b><b>d</b>", <b>n</b>);

вместо

            <b>scanf</b>("<b>%</b><b>d</b>", <b>&</b><b>n</b>);

<ul><a name=88></a><h2>13.5.  Форматное преобразование в памяти</h2></ul>

     От функции <b>scanf</b> и <b>printf</b> происходят функции <b>sscanf</b>   и
<b>sprintf</b>, которые осуществляют аналогичные преобразования, но
оперируют со строкой, а не с файлом. Обращения к этим  функ-
циям имеют вид:

                            <b>-58-</b>


      <b>sprintf</b>(<b>string</b>, <b>control</b>, <b>arg1</b>, <b>arg2</b>, ...)
      <b>sscanf</b>(<b>string</b>, <b>control</b>, <b>arg1</b>, <b>arg2</b>, ...)

Как и раньше , функция <b>sprintf</b>  преобразует  свои  аргументы
<b>arg1</b>,  <b>arg2</b>  и  т.д.  в соответствии с форматом, указанным в
<b>control</b>, но помещает результаты в <b>string</b>, а не в стандартный
вывод. Конечно, строка <b>string</b> должна быть достаточно велика,
чтобы принять результат.  Например, если name - это символь-
ный массив, а <b>n</b> - целое, то

            <b>sprintf</b>(<b>name</b>, "<b>temp</b><b>%d</b>", <b>n</b>);

создает в name строку вида "<b>tempnnn</b>", где <b>nnn</b> - значение <b>n</b>.

     Функция <b>sscanf</b> выполняет обратные преобразования -  она
просматривает  строку  string  в  соответствии  с форматом в
аргументе <b>control</b> и помещает результирующие значения в аргу-
менты  <b>arg1</b>,  <b>arg2</b> и т.д. Эти аргументы должны быть указате-
лями. В результате обращения

            <b>sscanf</b>(<b>name</b>, "<b>temp</b><b>%d</b>", <b>&</b><b>n</b>);

переменная n получает значение  строки  цифр,  следующих  за
<b>temp</b> в <b>name</b>.

<ul><a name=89></a><h2>13.6.  Доступ к файлам</h2></ul>

     Описанные в начале данного раздела программы читают  из
стандартного ввода и пишут в стандартный вывод, которые пре-
доставляются программе операционной системой.

     Для программ, которые сами должны организовывать  связь
с  файлами,  в  библиотеке  ввода/вывода действуют следующие
правила.

     Прежде чем  считывать из некоторого файла  или  записы-
вать  в него, этот файл должен быть открыт с помощью функции
<b>open</b> из стандартной библиотеки. Функция <b>fopen</b> берет  внешнее
имя  (подобное  <b>х</b>.<b>c</b>  или  "<b>temp002</b>") и возвращает внутреннее
имя, которое должно использоваться при  последующих  чтениях
из файла или записях в него.

     Это внутреннее имя, называемое "<b>указателем файла</b>", фак-
тически  является  указателем  структуры,  которая  содержит
информацию о файле, такую как место размещения буфера, теку-
щая  позиция символа в буфере, происходит ли чтение из файла
или запись в него и тому подобное.  Пользователи не  обязаны
знать  эти  детали, потому что среди определений, получаемых
из файла <b>stdio.h</b>,  содержится  определение  этой  структуры.
Единственное   необходимое   для  указателя  файла  описание
            демонстрируется примером: <b>FILE *</b><b>fp</b>;

                            <b>-59-</b>


     Здесь говорится, что <b>fp</b> является  указателем  на  <b>FILE</b>.
Обратите  внимание,  что <b>file</b> является именем типа, подобным
<b>int</b>,  а  не  ярлыком  структуры;   это   реализовано   через
"<b>#define</b>".

     Обращение  к  функции  <b>fopen</b>  в  программе  имеет  вид:
<b>fp</b>=<b>fopen</b>(<b>name</b>,<b>mode</b>);
Первым аргументом функции <b>fopen</b> является имя файла,  которое
задается  в  виде  символьной сроки "<b>name</b>".  <b>Второй аргумент</b>
<b>mode</b> (режим) также является символьной строкой, которая ука-
зывает,  как  этот  файл  будет  использоваться. Допустимыми
режимами являются: чтение (<b>r</b>), запись (<b>w</b>) и добавление  (<b>a</b>),
возможен  еще  символ + справа (например, <b>r</b>+), который озна-
чает, что возможно и чтение, и запись в файл.

     Если вы откроете файл, который еще не  существует,  для
записи  или добавления, то такой файл будет создан (если это
возможно).  Открытие существующего файла на запись  приводит
к отбрасыванию его старого содержимого. Попытка чтения несу-
ществующего файла является ощибкой. Ошибки могут быть  обус-
ловлены  и  другими  причинами  (например, попытка чтения из
файла, не имея на то  разрешения).  При  наличии  какой-либо
ошибки  функция  возвращает  нулевое значение указателя <b>NULL</b>
(которое для удобства также определяется в файле <b>stdio.h</b>).

     Другой необходимой вещью  является  способ  чтения  или
записи,  если  файл уже открыт. Здесь имеется несколько воз-
можностей, из которых  <b>getc</b>  и  <b>putc</b>  являются  простейшими.
Функция <b>getc</b> считывает из файла следующий символ; ей необхо-
дим указатель файла, чтобы знать, из  какого  файла  читать.
                   Обращение: <b>c</b>=<b>getc</b>(<b>fp</b>)
помещает в <b>c</b> следующий символ из файла, указанного посредст-
вом <b>fp</b>, и <b>EOF</b>, если достигнут конец файла.

                    Функция <b>putc</b>: <b>putc</b>(<b>c</b>,<b>fp</b>)
помещает символ <b>c</b> в файл <b>fp</b> и возвращает <b>c</b>. Подобно функциям
<b>getchar</b>  и  <b>putchar</b>,  <b>getc</b> и <b>putc</b> могут быть макросами, а не
функциями.

     При запуске  программы  автоматически  открываются  три
файла,  которые  снабжены  определенными указателями файлов.
Этими файлами являются стандартный ввод, стандартный вывод и
стандартный  вывод  ошибок; соответствующие указатели файлов
называются <b>stdin</b>, <b>stdout</b> и <b>stderr</b>.  Обычно все эти указатели
связаны  с терминалом, но <b>stdin</b> и <b>stdout</b> могут быть перенап-
равлены на файлы или в межпроцессный канал.

     Функции <b>getchar</b> и <b>putchar</b> могут быть определены в  тер-
минах getc, <b>putc</b>, <b>stdin</b> и <b>stdout</b> следующим образом:

      <b>#define getchar</b>()    <b>getc</b>(<b>stdin</b>)
      <b>#define putchar</b>(<b>c</b>)   <b>putc</b>(<b>c</b>, <b>stdout</b>)

                            <b>-60-</b>


При работе с файлами для форматного  ввода  и  вывода  можно
использовать функции <b>fscanf</b>  и  <b>fprintf</b>. Они идентичны функ-
циям <b>scanf</b>  и  <b>printf</b>, за исключением того, что первым аргу-
ментом  является  указатель  файла,  определяющий  тот файл,
который будет читаться или куда будет вестись запись; управ-
ляющая строка будет вторым аргументом.

     Указатели файлов <b>stdin</b>  и  <b>stdout</b> заранее определены  в
библиотеке  ввода-вывода  как стандартный ввод и стандартный
вывод; они могут быть использованы в любом месте, где  можно
использовать объект типа <b>FILE *</b>. Они, однако, являются конс-
тантами, а не переменными, так что их нельзя изменять.

     Функция <b>fclose</b> является обратной по отношению к  <b>fopen</b>;
она разрывает связь между указателем файла и внешним именем,
установленную функцией <b>fopen</b>, и высвобождает указатель файла
для другого файла. В операционной системе имеются  ограниче-
ния на число одновременно открытых  файлов,  которыми  может
распоряжаться  программа.   Функция <b>fclose</b> закрывает файл, а
также вызывает выдачу информации из буфера, в  котором  <b>putc</b>
собирает  вывод (при нормальном завершении программы функция
<b>fclose</b>  вызывается  автоматически  для   каждого   открытого
файла).

<ul><a name=90></a><h2>13.7.  Обработка ошибок - stderr  и  exit</h2></ul>

     При печати диагностических сообщений желательно,  чтобы
они  поступали на терминал, даже если стандартный вывод пос-
тупает в некоторый файл или в межпроцессный канал.

     Чтобы лучше обрабатывать такую  ситуацию,  к  программе
точно  таким  же образом, как <b>stdin</b>  и <b>stdout</b>, автоматически
присоединяется второй выходной файл, называемый <b>stderr</b>. Если
это вообще возможно, вывод, записанный в файле <b>stderr</b>, появ-
ляется на  терминале  пользователя,  даже  если  стандартный
вывод  направляется  в  другое  место (на самом деле имеется
возможность направить такие сообщения в файл,  но  этого  не
происходит при простом перенаправлении стандартного вывода).

     Программа может  также  использовать  функцию  <b>exit</b>  из
стандартной  библиотеки, обращение к которой вызывает завер-
шение выполнения программы. Аргумент функции  <b>exit</b>  доступен
программе,  вызвавшей программу пользователя в качестве под-
задачи, так что она может проверить успешное  или  неудачное
завершение  данной  программы.   По соглашению, величина 0 в
качестве возвращаемого значения свидетельствует о  том,  что
все в порядке, а различные ненулевые значения являются приз-
наками ненормальных ситуаций.

     Функция <b>exit</b> вызывает функцию fclose для каждого откры-
того  выходного  файла, с тем чтобы вывести всю помещенную в
буферы выходную информацию, а затем вызывает функцию  _<b>exit</b>.
Функция _<b>exit</b> приводит к немедленному завершению без очистки


                            <b>-61-</b>


каких-либо буферов; конечно,  при  желании  к  этой  функции
можно обратиться непосредственно.

<ul><a name=91></a><h2>13.8.  Ввод и вывод строк</h2></ul>

     Стандартная  библиотека  содержит  функцию  <b>fgets</b>.    В
результате обращения

            <b>fgets</b>(<b>line</b>, <b>maxline</b>, <b>fp</b>)

следующая строка ввода (включая символ новой строки)  считы-
вается  из  файла <b>fp</b> в символьный массив <b>line</b>; самое большее
<b>maxline</b>-<b>1</b>  символ  будет  прочитан.  Результирующая   строка
заканчивается  символом  <b>\0</b>. Обычно функция <b>fgets</b> возвращает
<b>line</b>; в конце файла она возвращает <b>NULL</b>.

     Предназначенная для  вывода  функция  <b>fputs</b>  записывает
строку  (которая не обязана содержать символ новой строки) в
файл:

            <b>fputs</b>(<b>line</b>, <b>fp</b>)


     Функции  <b>gets</b> и <b>puts</b>  являются  упрощенными  вариантами
<b>fgets</b>   и  <b>fputs</b>,  которые  работают  с файлами стандартного
ввода и вывода и не проверяют длину строки; <b>gets</b> не  записы-
вает  символ  новой строки в память, а  <b>puts</b> дописывает этот
символ в  файл в конце строки:

            <b>gets</b>(<b>line</b>)
            <b>puts</b>(<b>line</b>)


<ul><a name=92></a><h2>13.9.  Функция ungetc</h2></ul>

     Стандартная библиотека содержит  функцию,  возвращающую
последний считанный символ.  В результате обращения

             <b>ungetc</b>(<b>c</b>,<b>fp</b>)

символ <b>c</b> возвращается в файл <b>fp</b>.  Позволяется  возвращать  в
каждый файл только один символ.

<ul><a name=93></a><h2>13.10.  Разные стандартные функции</h2></ul>

     Стандартная библиотека предоставляет множество разнооб-
разных  функций,  некоторые  из которых оказываются особенно
полезными.

<ul><a name=94></a><h2>13.10.1.  Управление памятью</h2></ul>

     Функция <b>calloc</b> служит для запросов памяти.   В  резуль-
тате обращения


                            <b>-62-</b>


             <b>calloc</b>(<b>n</b>, <b>sizeof</b>(<b>objеct</b>))

возвращается либо указатель пространства,  достаточного  для
размещения  n  объектов  указанного размера, либо <b>NULL</b>, если
запрос не может быть удовлетворен. Отводимая память  инициа-
лизируется нулевыми значениями.  Функция <b>malloc</b> делает то же
самое, но память задается в байтах:

            <b>malloc</b>(<b>size</b>)


     Указатель обладает нужным для рассматриваемых  объектов
выравниванием,  но  ему  следует приписывать соответствующий
тип, как в следующем примере

             <b>char *calloc</b>();
             <b>int *ip</b>;
             <b>ip</b>=(<b>int</b>*) <b>calloc</b>(<b>n</b>,<b>sizeof</b>(<b>int</b>));


     Функция <b>free</b>(<b>p</b>) освобождает  пространство,  на  которое
указывает  <b>p</b>,  причем  указатель <b>p</b> первоначально должен быть
получен в результате обращения к <b>calloc</b>. Здесь  нет  никаких
ограничений  на  порядок освобождения пространства, но осво-
бождение чего либо, не полученного с помощью <b>calloc</b> или <b>mal-</b>
<b>loc</b>, приводит к тяжелым ошибкам.

<ul><a name=95></a><h2>13.10.2.  Стандартные функции языка Си</h2></ul>

     В стандартную библиотеку функций на  языке  Си  входит,
помимо  описанных, множество самых разных функций. Подробное
описание их  приведено  в  руководстве  программисту  по  <b>ОС</b>
<b>ДЕМОС</b>, часть 4 (библиотечные функции), и в оперативной доку-
ментации (<b>man</b>(3)).  Ниже в скобках приведены названия разде-
лов оперативной документации, в которых имеются соответству-
ющие описания:

     - операции со строками (<b>string</b>);

     - преобразование данных без <b>sscanf</b>  и  <b>sprintf</b>"  (<b>atoi</b>,
       <b>itoa</b>, <b>atof</b>, <b>ftoa</b>);

     - математические функции (<b>sin</b>, <b>exp</b>, ...);

     - проверка и преобразование символов (<b>ctype</b>);

     - и многое другое.

<ul><a name=96></a><h2> * 14.  ВЗАИМОДЕЙСТВИЕ С ОПЕРАЦИОННОЙ СИСТЕМОЙ</h2></ul>

                            <b>-63-</b>


<ul><a name=97></a><h2>14.1.  Подготовка программ на Си в ОС ДЕМОС</h2></ul>

     В операционной системе ДЕМОС программы  могут  состоять
из  одного  или нескольких модулей, написанных на языках Си,
Фортран-77, Ассемблер. Для трансляции и сборки  программ  на
языке  Си  служит команда <b>cc</b>. В простейшем случае трансляция
осуществляется по команде:

     <b>cc</b> <b>файл1</b>.<b>c</b> <b>файл2</b>.<b>c</b> ...

где <b>файл1</b>.<b>c</b>, <b>файл2</b>.<b>c</b>, ... - имена файлов,  содержащих  прог-
раммы на языке Си (имена таких файлов должны оканчиваться на
суффикс <b>.c</b>). Команда осуществляет  трансляцию  перечисленных
программ  и их объединение редактором связей.  Если трансля-
ция прошла без ошибок,  создается  исполняемый  файл  <b>a.out</b>,
который можно запустить на счет, введя команду:

    <b>a.out</b>

(то есть набрав просто имя этого файла).   Трансляцию  часто
проводят  в  два  этапа: сначала транслируют отдельные прог-
раммы, получая  объектные  модули,  а  затем  объединяют  их
вместе  (в предыдущем примере это было сделано автоматически
командой <b>cc</b>).  Раздельная трансляция выглядит примерно так:

     <b>cc</b> <b>файл1</b>.<b>c</b> <b>файл2</b>.<b>c</b> ...
     <b>cc</b> <b>файлN</b>.<b>c</b> <b>файлN1</b>.<b>c</b> ...
     <b>cc</b> <b>файл1</b>.<b>o</b> <b>файл2</b>.<b>o</b> ... <b>файлN</b>.<b>o</b> ...

В более сложном случае программа может состоять  из  модулей
на  разных языках, результат трансляции может быть записан в
файл, отличный от <b>a.out</b>, можно оттранслировать программу для
отладки с помощью отладчика <b>cdeb</b>, и т.п.  Подробное описание
вызова  компилятора  имеется  в   руководстве   программиста
(<b>cc</b>(1),  <b>ld</b>(1)).  В общем случае программы на Си запускаются
интерпретаторами <b>shell</b> или <b>cshell</b> командой:

    <b>имя</b>_<b>файла аргументы назначение</b>_<b>ввода</b>_<b>вывода</b>

где любая часть, кроме  имени файла, может отсутствовать.

     Любая программа на  Си  в  <b>ОС  ДЕМОС</b>  должна  содержать
головную  функцию с именем <b>main</b>. Работа программы начинается
с этой функции, причем информация о аргументах команды пере-
дается через ее формальные параметры.

<ul><a name=98></a><h2>14.2.  Доступ к аргументам команды</h2></ul>

     Операционная система <b>ДЕМОС</b> позволяет  передавать  аргу-
менты команды начинающей выполняться программе.  Когда функ-
ция <b>main</b> вызывается системой, она вызывается с  двумя  аргу-
ментами. Первый аргумент (типа <b>int</b>, условно называемый <b>argc</b>)
указывает число аргументов в командной  строке,  с  которыми


                            <b>-64-</b>


происходит  обращение  к  программе;  второй аргумент (<b>argv</b>)
является указателем на массив символьных  строк,  содержащих
эти аргументы, по одному в строке.

     Самую простую иллюстрацию этой возможности и  необходи-
мых  при  этом  описаний дает программа <b>echo</b>, которая просто
печатает в одну строку аргументы командной строки,  разделяя
их пробелами. , Если дана команда

            <b>echo</b> <b>hello</b>, <b>world</b>

     то в результате получим:

            <b>hello</b>, <b>world</b>


     По соглашению  <b>argv</b>[0]  является  именем,  по  которому
вызывается  программа, так что <b>argc</b> по меньшей мере равен 1.
В приведенном выше примере <b>argc</b> равен 3, а <b>argv</b>[0],  <b>argv</b>[1]
и <b>argv</b>[2] равны соответственно <b>echo</b>, <b>hello</b>, и <b>world</b>.  Первым
фактическим  агументом  является  <b>argv</b>[1],  а  последним   -
<b>argv</b>[<b>argc</b>-1].  Если  <b>argc</b> равен 1, то за именем программы не
следует никакой командной строки аргументов. Все  это  пока-
зано в <b>echo</b>:

     <b>main</b>(<b>argc</b>, <b>argv</b>)
     <b>int</b> <b>argc</b>;
     <b>char *</b><b>argv</b>[];
    <b>{</b>
        <b>int</b> <b>i</b>;
        <b>for</b> (<b>i</b> = 1; <b>i</b> &lt; <b>argc</b>; <b>i</b>++)
            <b>printf</b>("<b>%</b><b>s</b><b>%</b><b>c</b>", <b>argv</b>[<b>i</b>],
              (<b>i</b>&lt;<b>argc</b>-1) <b>? ' ' : '\n');</b>
     <b>}</b>

Поскольку <b>argv</b> является указателем на массив указателей,  то
существует  несколько  способов  написания  этой  программы,
использующих работу с указателем, а не  с  индексацией  мас-
сива. Следующий пример демонстрирует другой вариант:

     <b>main</b>(<b>argc</b>, <b>argv</b>)
     <b>int</b> <b>argc</b>;
     <b>char **</b><b>argv</b>;
     <b>{</b>
        <b>while</b> (--<b>argc</b> &gt; 0)
            <b>printf</b>("<b>%</b><b>s</b><b>%</b><b>c</b>",<b>*++</b><b>argv</b>,
            (<b>argc</b> &gt; 1)     <b>? ' ' : '\n'</b>);
     <b>}</b>


     Кроме строки аргументов, программа получает от  системы
набор  переменных, описывающих среду, в которой она выполня-
ется.   Каждая  переменная  состоит  из  имени  и   значения


                            <b>-65-</b>


(текстовой строки).  Например, переменная  <b>TERM</b> передает тип
терминала, с которого программа запущена. Для запроса значе-
ния переменной по имени используется функция <b>getenv</b>:

    <b>char *</b><b>getenv</b>();
    <b>par</b> = <b>getenv</b>("<b>имя</b>_<b>переменной</b>")

Функция возвращает указатель на строку -  значение  перемен-
ной, либо <b>NULL</b>, если имя не найдено в описании среды.

<ul><a name=99></a><h2> * 15.  ИНТЕРФЕЙС СИСТЕМЫ ДЕМОС</h2></ul>

     Все без  исключения  возможности  операционной  системы
<b>ДЕМОС</b> доступны из программ на языке Си.  Материал этой главы
относится к интерфейсу между Си-программами  и  операционной
системой  <b>ДЕМОС</b>.   Материал   делится  на  следующие  части:
ввод/вывод, система файлов, процессы,  сигналы.  Предполага-
ется  знание  основных  концепций  ОС <b>ДЕМОС</b>, а также понятий
"файл", "процесс", "сигнал".  Подробное  описание  системных
вызовов  и соответствующих им функций из стандартной библио-
теке имеется в руководстве программиста по <b>ОС ДЕМОС</b> и в опе-
ративной  документации (части 2 и 3).  Например, если в опи-
сании говорится о функции <b>popen</b>(3),  то  подробное  описание
следует  искать  в  руководстве программиста, часть 4, или в
оперативной документации, часть 3; справку о  функции  можно
получить на терминал, набрав <b>man</b> 3 <b>popen</b>.

<ul><a name=100></a><h2>15.1.  Ввод/вывод</h2></ul>

     В описании библиотеки ввода/вывода был  описан  универ-
сальный  интерфейс,  который одинаков для всего многообразия
операционных систем. На каждой конкретной операционной  сис-
теме  функции  стандартной библиотеки должны быть написаны в
терминах ввода-вывода, доступных на данной машине. В следую-
щих  разделах  описан  набор  функций  ввода/вывода  нижнего
уровня, поддерживаемых ядром операционной системы <b>ДЕМОС</b>.

<ul><a name=101></a><h2>15.1.1.  Дескрипторы файлов</h2></ul>

     В операционной системе <b>ДЕМОС</b> весь  ввод  и  вывод  осу-
ществляется  посредством чтения файлов или их записи, потому
что все периферийные устройства, включая  терминал пользова-
теля,  являются  файлами  определенной файловой системы. Это
означает, что один однородный интерфейс управляет всеми свя-
зями между программой и периферийными устройствами.

     В наиболее общем случае  перед  чтением  из  файла  или
записью  в файл необходимо сообщить системе о намерении сде-
лать это; этот процесс называется "открытием" файла. Система
выясняет,  имеет  ли программа право поступать таким образом
(существует ли этот файл? имеется ли  разрешение на  обраще-
ние  к  нему?), и если все в порядке, возвращает в программу
небольшое положительное целое число, называемое дескриптором


                            <b>-66-</b>


файла.   Всякий  раз, когда этот файл используется для ввода
или вывода, для идентификации файла употребляется дескриптор
файла,  а  не его имя (здесь существует примерная аналогия с
использованием <b>read</b> (5,...) и <b>write</b> (6,...) в Фортране). Вся
информация об открытом файле содержится в системе; программа
пользователя обращается  к  файлу  только  через  дескриптор
файла.

     Для удобства выполнения обычных операций ввода и вывода
с помощью терминала пользователя существуют специальные сог-
лашения. Когда интерпретатор команд (<b>shell</b>) прогоняет  прог-
рамму,  он  открывает три файла, называемые стандартным вво-
дом, стандартным выводом и стандартным выводом ошибок, кото-
рые  имеют соответственно числа 0, 1 и 2 в качестве дескрип-
торов этих файлов. В нормальном состоянии все они связаны  с
терминалом,  так  что  если  программа читает с дескриптором
файла 0 и пишет с дескрипторами файлов 1 и 2, то  она  может
осуществлять  ввод  и вывод с помощью терминала, не заботясь
об открытии соответствующих файлов.

     Пользователь  программы  может  перенаправлять  ввод  и
вывод  на файлы, используя в интерпретаторе команд символы <b>&lt;</b>
и >:

            <b>prog</b> &lt; <b>infile</b> > <b>outfile</b>

В этом  случае  интерпретатор  команд   изменит  определение
дескрипторов  файлов  0  и 1 с терминала на указанные файлы.
Обычно дескриптор файла 2 остается связанным  с  терминалом,
так  что сообщения об ошибках могут поступать туда. Подобные
замечания справедливы и тогда, когда ввод и вывод  связан  с
межпроцессным  каналом.  Следует отметить, что в этом случае
связь программы с файлами изменяется  интерпретатором  <b>shell</b>
(или  <b>cshell</b>),  а  не  программой.  Сама программа, пока она
использует файл 0 для ввода и файлы 1 и  2  для  вывода,  не
знает  ни  откуда  приходит  ее  ввод,  ни куда поступает ее
выдача.

<ul><a name=102></a><h2>15.1.2.  Низкоуровневый ввод/вывод.</h2></ul>

     Самый низкий уровень ввода/вывода в  системе  <b>ДЕМОС</b>  не
предусматривает  ни  какой-либо  буферизации, ни какого-либо
другого сервиса; он по  существу  является  непосредственным
обращением  к  операционной системе.  Весь ввод и вывод осу-
ществляется двумя функциями: <b>read</b> и <b>write</b>.  Первым  аргумен-
том обеих функций является дескриптор файла. Вторым аргумен-
том является буфер в вашей программе, откуда или куда должны
поступать  данные.  Третий  аргумент  - это число подлежащих
пересылке байтов. Обращения к этим функциям имеют вид:

            <b>n</b>_<b>read</b>=<b>read</b>(<b>fd</b>,<b>buf</b>,<b>n</b>);
            <b>n</b>_<b>written</b>=<b>write</b>(<b>fd</b>,<b>buf</b>,<b>n</b>);

                            <b>-67-</b>


При каждом обращении возвращается счетчик байтов,  указываю-
щий  фактическое число переданных байтов. При чтении возвра-
щенное число байтов может оказаться меньше, чем  запрошенное
число.  Возвращенное  нулевое  число  байтов  означает конец
файла, а "-1" указывает на наличие  какой-либо  ошибки.  При
записи возвращенное значение равно числу фактически записан-
ных байтов; несовпадение этого числа с числом байтов,  кото-
рое   предполагалось  записать,  обычно  свидетельствует  об
ошибке.

     Количество байтов, подлежащих чтению или записи,  может
быть совершенно произвольным. Двумя самыми распространенными
величинами являются "1", что означает передачу  одного  сим-
вола  за обращение (т.е. без использования буфера), и "512",
что соответствует физическому размеру блока на многих  пери-
ферийных  устройствах.  Этот последний размер будет наиболее
эффективным, но даже ввод или вывод  по  одному  символу  за
обращение не будет слишком дорогим.

     Пример. Копирование ввода на вывод.   В  системе  <b>ДЕМОС</b>
эта  программа  будет  копировать  что  угодно  куда угодно,
потому что ввод и вывод могут быть перенаправлены  на  любой
файл или устройство.

    <b>#define</b> <b>BUFSIZE 512</b>
    <b>main</b>() /*copy input to output*/
    {
         <b>char</b> <b>buf</b>[<b>BUFSIZE</b>];
         <b>int</b> <b>n</b>;
         <b>while</b>((<b>n</b>=<b>read</b>(0,buf,<b>BUFSIZE</b>))&gt;0)
              <b>write</b>(1,<b>buf</b>,<b>n</b>);
    }

Если размер файла не будет кратен <b>BUFSIZE</b>, то при  очередном
обращении  к  <b>read</b>  будет  возвращено  меньшее число байтов,
которые затем записываются с помощью  <b>write</b>;  при  следующем
после этого обращении к <b>read</b> будет возвращен нуль.

<ul><a name=103></a><h2>15.1.3.  Открытие, создание, закрытие и удаление</h2></ul>

     Во всех случаях, если только не используются определен-
ные  по  умолчанию стандартные файлы ввода, вывода и ошибок,
вы должны явно открывать файлы, чтобы затем  читать  из  них
или писать в них. Для этой цели существуют две функции: <b>open</b>
и <b>creat</b>.

     Функция <b>open</b> весьма сходна с функцией  <b>fopen</b>,  рассмот-
ренной  выше,  за  исключением  того, что вместо возвращения
указателя файла она  возвращает  дескриптор  файла,  который
является просто целым типа <b>int</b>.

            <b>int</b> <b>fd</b>;
            <b>fd</b>=<b>open</b>(<b>name</b>,<b>rwmode</b>);


                            <b>-68-</b>


Как и в случае  <b>fopen</b>,  аргумент  <b>name</b>  является  символьной
строкой,  соответствующей внешнему имени файла. Однако аргу-
мент, определяющий режим доступа, отличен: <b>rwmode</b> равно: 0 -
для  чтения,  1  - для записи, 2 - для чтения и записи. Если
происходит какая-то ошибка, функция <b>open</b> возвращает "-1";  в
противном  случае  она возвращает неотрицательный дескриптор
файла.

     Попытка открыть файл, который не  существует,  является
ошибкой.  Функция  <b>creat</b>  предоставляет возможность создания
новых файлов или перезаписи старых. В результате обращения:

            <b>fd</b>=<b>creat</b>(<b>name</b>,<b>pmode</b>);

возвращает дескриптор файла, если оказалось  возможным  соз-
дать  файл с именем <b>name</b>, и "-1" в противном случае.  Созда-
ние файла, который  уже  существует,  не  является  ошибкой:
<b>creat</b> усечет его до нулевой длины.

     Если файл ранее не существовал, то <b>creat</b> создает его  с
определенным   режимом  защиты,  специфицируемым  аргументом
<b>pmode</b>. В системе файлов <b>ОС ДЕМОС</b> с файлом связываются девять
битов  защиты  информации,  которые управляют разрешением на
чтение, запись и выполнение для владельца файла, для  группы
владельцев  и для всех остальных пользователей.  Таким обра-
зом, трехзначное  восьмеричное  число  наиболее  удобно  для
записи режима защиты. Например, число 0755 свидетельствует о
разрешении на чтение, запись и выполнение для владельца и  о
разрешении  на чтение и выполнение для группы и всех осталь-
ных.

     Существует ограничение (обычно 15 - 25)  на  количество
файлов,  которые  программа  может  иметь открытыми одновре-
менно. В соответствии с этим любая  программа,  собирающаяся
работать со многими файлами, должна быть подготовлена к пов-
торному использованию дескрипторов файлов.  Процедура  <b>close</b>
прерывает связь между дескриптором файла и открытым файлом и
освобождает дескриптор файла для использования с другим фай-
лом.   Завершение  выполнения  программы  через  <b>exit</b>  или в
результате возврата из головной функции приводит к  закрытию
всех открытых файлов.

     Функция удаления <b>unlink</b>(<b>filename</b>)  удаляет  из  системы
файл  с  именем <b>filename</b> (Точнее, удаляет имя <b>filename</b>, файл
удаляется, если на него не остается ссылок под другими  име-
нам).

<ul><a name=104></a><h2>15.1.4.  Произвольный доступ - lseek</h2></ul>

     Обычно при работе с файлами ввод и вывод осуществляется
последовательно:  при  каждом  обращении  к  функциям <b>read</b> и
<b>write</b> чтение или запись начинаются  с  позиции,  непосредст-
венно   следующей   за   предыдущей   обработанной.  Но  при


                            <b>-69-</b>


необходимости файл может читаться или записываться  в  любом
произвольном порядке.  Обращение к системе с помощью функции
<b>lseek</b> позволяет передвигаться по файлу, не производя  факти-
ческого чтения или записи. В результате обращения

             <b>lseek</b>(<b>fd</b>,<b>offset</b>,<b>origin</b>);

текущая позиция в файле с дескриптором <b>fd</b>  передвигается  на
позицию  <b>offset</b>  (смещение), которая отсчитывается от места,
указываемого аргументом <b>origin</b> (начало отсчета). Последующее
чтение  или  запись  будут теперь начинаться с этой позиции.
Аргумент <b>offset</b> имеет тип <b>long</b>; <b>fd</b> и <b>origin</b> имеют  тип  <b>int</b>.
Аргумент  <b>origin</b> может принимать значения 0, 1 или 2, указы-
вая на то, что величина <b>offset</b>  должна  отсчитываться  соот-
ветственно  от начала файла, от текущей позиции или от конца
файла. Например, чтобы дополнить файл, следует перед записью
найти его конец:

             <b>lseek</b>(<b>fd</b>,0<b>l</b>,2);

чтобы вернуться к началу, можно написать:

             <b>lseek</b>(<b>fd</b>,<b>0l</b>,0);

Обратите внимание на аргумент <b>0</b>l; его можно было бы записать
и в виде (<b>long</b>) 0.

     Функция <b>lseek</b> позволяет обращаться с  файлами  примерно
так же, как с большими массивами, только ценой более медлен-
ного доступа.

Пример. Функция, считывающая любое количество байтов,  начи-
ная с произвольного места в файле.

    /*читать n байтов с позиции <b>pos</b> в <b>buf</b> */
         <b>get</b>(<b>fd</b>,<b>pos</b>,<b>buf</b>,<b>n</b>)
        <b>int</b> <b>fd</b>, <b>n</b>;
        <b>long</b> <b>pos</b>;
        <b>char *</b><b>buf</b>;
        {
             <b>lseek</b>(<b>fd</b>,<b>pos</b>,0); /*get to pos */
             <b>return</b>(<b>read</b>(<b>fd</b>,<b>buf</b>,<b>n</b>));
        <b>}</b>


<ul><a name=105></a><h2>15.2.  Управление процессами</h2></ul>

     В операционной системе <b>ДЕМОС</b> часто требуется вызвать из
программы  и  выполнить  в  виде  отдельного процесса другую
программу.  Следующий  раздел  описывает  простейший  способ
сделать  это,  а  далее  будут  рассмотрены базовые средства
управления процессами, имеющиеся в <b>ОС ДЕМОС</b>.

                            <b>-70-</b>


<ul><a name=106></a><h2>15.2.1.  Функция system</h2></ul>

     Простейший способ вызвать другую программу -  использо-
вать стандартную функцию <b>system</b>:

     <b>system</b>("<b>командная строка</b>")

Функция имеет один параметр - строку, которую  она  анализи-
рует и выполняет точно так же, как выполняются команды, вво-
димые интерпретатором <b>shell</b> с терминала.  Функция  выполняет
команду  и  возвращает  целое число - код ответа выполненной
команды (0,  если  все  кончилось  нормально).  В  <b>командной</b>
<b>строке</b>     воспринимаются     любые    символы    управления
вводом/выводом >, <b>&lt;</b>, и т.п.

     Следует учесть, что, если в программе  вывод  буферизу-
ется,  то перед вызовом функции <b>system</b> необходимо вытолкнуть
буфера, например вызвав функцию <b>fflush</b>.

<ul><a name=107></a><h2>15.2.2.  Вызов программы на низком уровне - execl</h2></ul>

     Вызов программы в <b>ОС  ДЕМОС</b>  осуществляется  с  помощью
нескольких  элементарных  функций, одна из которых - функция
<b>execl</b> - осуществляет вызов новой программы вместо уже выпол-
няющейся,  без  возврата в вызывающую программу. Обращение в
ней имеет вид:

     <b>execl</b>(<b>команда</b>,<b>арг0</b>,<b>арг1</b>,...,<b>аргN</b>,<b>NULL</b>);

где "команда" - строка символов, точно именующая файл  вызы-
ваемой  команды.  Например, для вызова команды <b>pr</b> необходимо
указать имя /<b>bin</b>/<b>pr</b>.  Остальные аргументы также представляют
собой строки символов и просто передаются команде в качестве
аргументов, при этом <b>арг0</b> обычно представляет  собой  просто
сокращенное  имя  команды, а остальные аргументы - параметры
данной команды.

     Вызов <b>execl</b> в случае нормального  запуска  новой  прог-
раммы  заменяет  ею текущую программу, управление из функции
<b>execl</b> возвращается только в случае ошибки (например, не най-
дена  команда  с  указанным  именем).   В библиотеке имеется
целый набор функций, осуществляющих то же самое  и  отличаю-
щихся  только представлением параметров (<b>execl</b>(2), <b>execv</b>(2),
<b>execvp</b>(2), ...) и тем, что  некоторые  функции  осуществляют
поиск команды в стандартном наборе справочников.

<ul><a name=108></a><h2>15.2.3.  Порождение нового процесса - fork</h2></ul>

     Для того, чтобы запустить параллельно новую  программу,
необходимо  прежде  всего  уметь запускать параллельный про-
цесс.  Для этого в <b>ОС ДЕМОС</b> служит функция  "<b>fork</b>"  (развет-
виться):

                            <b>-71-</b>


     <b>proc</b>_<b>id</b> = <b>fork</b>()

Программа разделяется на две идентичные копии, которые  про-
должают  выполняться  как  два независимых процесса. Одна из
программ - процесс "сын" -  получает  от  функции  <b>fork</b>  код
ответа  0, другая - "родитель" - получает номер, под которым
запущен процесс "сын".   В  простейшем  случае  для  запуска
параллельной программы вызов <b>fork</b> комбинируется с <b>execl</b> сле-
дующим образом:

     <b>if</b>( <b>fork</b>() == 0)
     <b>{</b> /* Это процесс - сын */
     ... настройка файлов ...
     <b>execl</b>(... );
     /*Сюда мы попадаем при ошибке в <b>execl</b> */
     <b>perror</b>("Не могу запустить процесс");
     <b>exit</b>(1);
     <b>}</b>
     ... продолжение основной программы ...

Здесь программа после вызова <b>fork</b> анализирует, в каком  про-
цессе  ("родитель"  или  "сын") она выполняется и, в зависи-
мости от этого, ведет себя по разному. Если  основная  прог-
рамма  должна  ждать окончания "сына", то она должна вызвать
функцию <b>wait</b>:

     <b>int</b> <b>status</b>;
     ...
     <b>if</b>( <b>fork</b>() == 0)
     <b>{ ... execl</b>(...); <b>exit</b>(1);
     }
     <b>wait</b>(<b>&</b><b>status</b>));

Функция <b>wait</b> возвращает идентификатор процесса -  "сына",  и
засылает  в переменную <b>status</b> код завершения этого процесса.
Код завершения состоит из двух частей - младшие 8 битов фор-
мируются системой и обозначают причину окончания процесса; в
случае нормального окончания по функции <b>exit</b>"  они  содержат
0.  Старшие  8  битов  в случае, если программа окончилась в
результате вызова <b>exit</b>, берутся из аргумента вызова  функции
<b>exit</b>; обычно передается 0 при нормальном завершении и число,
отличное от нуля, в случае каких либо ошибок.

     Ни <b>fork</b>, ни <b>execl</b> не затрагивают открытых файлов, после
<b>fork</b>  ранее  открытые  файлы  начинают использоваться обоими
процессами совместно, то есть используются одни и те же ука-
затели  позиции  чтения/записи.  Если новому процессу требу-
ется передать какие то открытые файлы,  или  изменить  файлы
стандартного  ввода/вывода, настройка программы на эти файлы
делается после вызова <b>fork</b> в процессе-сыне до вызова  <b>execl</b>.
Следует  заметить, что при буферизованном вводе/выводе необ-
ходимо сбросить буфера перед  вызовом  <b>fork</b>(),  иначе  вывод
накопленной   информации   может  произойти  дважды  -  и  в


                            <b>-72-</b>


"родительском", и в новом процессе.

<ul><a name=109></a><h2>15.2.4.  Канал межпроцессной связи</h2></ul>

     Межпроцессный канал - это особый файл, устроенный таким
образом,  что  один  процесс неограниченно записывает в него
информацию, а другой  читает,  причем  система  обеспечивает
буферизацию  данных и  синхронизацию процессов.  Межпроцесс-
ные каналы могут создаваться  интерпретатором  команд  <b>shell</b>
или <b>cshell</b>, например:

     <b>ls | pr</b>

Существуют библиотечные функции <b>popen</b> и <b>pclose</b>,  позволяющие
запустить  параллельный процесс, который будет читать инфор-
мацию, записываемую в указанный файл данным процессом,  или,
напротив,  будет  поставлять породившему его процессу данные
для чтения (см. <b>popen</b>(3)). Эти  функции  используют  базовые
возможности  построения каналов, которые поддерживаются опе-
рационной системой.

     Для создания канала межпроцессной связи служит  функция
<b>pipe</b>:

     <b>int</b> <b>fd</b>[2];
     ...
     <b>stat</b> = <b>pipe</b>(<b>fd</b>);
     <b>if</b>(<b>stat</b> == -1) /* Была ошибка */...

Здесь <b>fd</b> - массив, в который засылается два дескриптора фай-
лов  - <b>fd</b>[1] для записи в канал, <b>fd</b>[0] для чтения из канала.
Эти дескрипторы могут использоваться наравне с дескрипторами
обычных файлов.

     Синхронизация обменов  построена  таким  образом,  что,
если  процесс  читает пустой канал, он будет ждать появления
данных; если в канале осталось много несчитанной информации,
записывающий   процесс  будет  ждать  освобождения  места  в
канале. Наконец, если у канала сторона для  записи  закрыта,
при чтении будет получен код ответа "0" - конец файла.

     Как правило, программа создает канал по  запросу  <b>pipe</b>,
после  чего разделяется на две копии с помощью функции <b>fork</b>.
Затем в одном из получившихся процессов закрывается  сторона
канала для чтения,  в другом - закрывается дескриптор записи
в канал.  Теперь после вызова <b>execl</b> начинается обмен  инфор-
мацией  по межпроцессному каналу между параллельно выполняю-
щимися программами.

     В случае, если обмен должен происходить через стандарт-
ный  ввод или вывод, используется функция <b>dup</b> для связывания
дескрипторов файлов.  Например, следующий фрагмент программы
служит  для  запуска  программы  <b>pr</b>  так,  чтобы  данные  на


                            <b>-73-</b>


стандартный ввод  программы  <b>pr</b>  поступали  из  стандартного
вывода основной программы:

     <b>int</b> <b>fd</b>[2];
    <b>#define</b> <b>R</b> 0
    <b>#define</b> <b>W</b> <b>1</b>
     <b>pipe</b>(<b>fd</b>);
     <b>if</b>(<b>fork</b>() == 0)
     <b>{ close</b>(<b>fd</b>[<b>W</b>]); <b>close</b>(0); <b>dup</b>(<b>fd</b>[<b>R</b>]);
       <b>close</b>(<b>fd</b>[<b>R</b>]);
       <b>execl</b>("/<b>bin</b>/<b>pr</b>","<b>pr</b>",<b>NULL</b>);
       <b>exit</b>(1);  /* Если ошибка в execl */
     }
     <b>close</b>(<b>fd</b>[<b>R</b>]); <b>close</b>(1); <b>dup</b>(<b>fd</b>[<b>W</b>]);
     <b>close</b>(<b>fd</b>[<b>W</b>]);
     .... счет, при записи проверяем, не было
     .... ли ошибки записи.
     <b>close</b>(1);

В этом примере полностью опущена обработка возможных ошибок.
Для  связывания дескрипторов стандартного ввода или вывода с
каналом  межпроцессной  связи  здесь  использована   функция
<b>dup</b>(<b>fd</b>)", которая возвращает дупликат дескриптора <b>fd</b>, причем
используется наименьший свободный дескриптор файла.   Следо-
вательно,  после  закрытия  файла с дескриптором 0 ближайшее
обращение к функции <b>dup</b> свяжет дескриптор  0  с  заданным  в
аргументе  <b>dup</b>  дескриптором.   После  вызова  <b>dup</b>  ненужный
больше дескриптор <b>fd</b>[0] или <b>fd</b>[1] закрывают.

<ul><a name=110></a><h2>15.3.  Сигналы и прерывания</h2></ul>

     Нормальный ход выполнения программы в  ОС  <b>ДЕМОС</b>  может
прерываться  "сигналами".  Сигналы  могут  появляться  как в
результате действия внешних причин (например,  в  результате
нажатия  на терминале клавиши, интерпретируемой системой как
"прерывание" - <b>interupt</b>), так и в  результате  ошибок  прог-
раммы.

     Функция, изменяющая принятые по умолчанию  действия  по
сигналу,  называется  <b>signal</b>  и  имеет два аргумента. Первый
специфицирует  сигнал,  а  второй  представляет  собой  либо
ссылку  на  функцию,  либо специальное выражение, означающее
требование "игнорировать" сигнал либо  "стандартная  реакция
на  сигнал".   Условные обозначения записаны в файле вставок
<b>signal.h</b>:

    <b>#include</b> &lt;<b>signal.h</b>&gt;
     <b>signal</b> (<b>СИГНАЛ</b>,<b>РЕАКЦИЯ</b>)

<b>СИГНАЛ</b> - это один из стандартных  кодов  сигналов,  например
<b>SIGINT</b>,  <b>SIGKILL</b>,  ... (подробнее см. <b>signal</b>(2)).  <b>РЕАКЦИЯ</b> -
это либо ссылка на функцию, которая будет вызвана при  полу-
чении сигнала, либо один из идентификаторов:


                            <b>-74-</b>


     <b>SIG</b><b>_</b><b>IGN</b> - игнорировать,
     <b>SIG</b><b>_</b><b>DFL</b> - по умолчанию.

Во всех случаях функция <b>signal</b>  возвращает  старое  значение
описателя  <b>РЕАКЦИЯ</b>.   Существуют некоторые тонкости, которые
иллюстрируются следующим фрагментом программы:

    <b>#include</b> &lt;<b>signal.h</b>&gt;
    <b>main</b>()
    {
     <b>int</b> <b>onintr</b>(); /* Описание обязательно */
     <b>if</b>(<b>signal</b>(<b>SIGINT,SIG</b><b>_</b><b>IGN</b>) != <b>SIG</b><b>_</b><b>IGN</b>)
     <b>{ signal(SIGINT</b>, <b>onintr</b>); <b>}</b>
     ...
      <b>exit</b>(0);
    <b>}</b>

    <b>onintr</b>()
    <b>{ unlink</b>(<b>tempfile</b>);
      <b>exit</b>(1);
    <b>}</b>

Проверка (if(<b>signal</b>...) связана с  тем,  что  сигнал  <b>SIGINT</b>
посылается  на  все  процессы,  начатые с данного терминала.
Если программа выполняется в фоновом  режиме,  интерпретатор
<b>shell</b>  при запуске программы устанавливает в ней игнорирова-
ние сигнала <b>SIGINT</b>, для того, чтобы с терминала  прерывались
только  интерактивные  процессы. Переключение обработки сиг-
нала <b>SIGINT</b> на функцию <b>onintr</b> без проверки  перечеркнуло  бы
все действия <b>shell</b> по защите фоновых процессов.

     Еще одна особенность связана с возвратом  из  программы
обработки сигнала. Если прерывание произошло во время выпол-
нения программы, возврат  из  функции  обработки  прерывания
приведет  к  нормальному  продолжению  ее  выполнения. Если,
однако, прерывание пришло во время операции чтения с  терми-
нала,  операция  чтения будет прервана, и произойдет возврат
из функции чтения <b>read</b> с нулевым счетчиком байтов. Как  пра-
вило,  функция  обработки  прерываний должна в таких случаях
устанавливать какой либо флаг, а программа  чтения,  получив
нулевой  счетчик байтов после операции <b>read</b>, может проверить
этот флаг и установить, что же произошло -  достигнут  конец
файла или было прерывание.

     Если программа обладает средствами реакции на  прерыва-
ния  и, в то же время, вызывает другие программы, желательно
управлять реакцией на прерывание примерно таким образом:

                            <b>-75-</b>


     <b>signal</b>(<b>SIGINT</b>, <b>onintr</b>);
     ...
     <b>if</b>(<b>fork</b>() == 0)
     <b>{ signal</b>(<b>SIGINT</b>, <b>SIG</b><b>_</b><b>DFL</b>);
       <b>execl</b>(...)
       ...
     <b>}</b>
     <b>signal</b>(<b>SIGINT</b>, <b>SIG</b><b>_</b><b>IGN</b>);
     <b>wait</b>(<b>&</b><b>status</b>);
     <b>signal</b>(<b>SIGINT</b>, <b>onintr</b>);

В этом случае прерывания, посылаемые с  терминала  во  время
выполнения запущенной параллельно программы, будут прерывать
только эту программу.

<ul><a name=111></a><h2> * 16.  СВОДКА СИНТАКСИЧЕСКИХ ПРАВИЛ</h2></ul>

     Эта сводка синтаксиса языка Си предназначена скорее для
облегчения  понимания  и  не  является  точной формулировкой
языка.

<ul><a name=112></a><h2>16.1.  Выражения</h2></ul>

     Основными выражениями являются следующие:

    выражение:
           первичное_выражение
         <b>*</b> выражение
         <b>&</b> выражение
         <b>-</b> выражение
         <b>!</b> выражение
         <b>~</b> выражение
        <b>++</b> l_значение
        <b>--</b> l_значение
           l_значение <b>++</b>
           l_значение <b>--</b>
           <b>sizeof</b> выражение
           (имя типа) выражение
           выражение бинарная_операция
                              выражение
           выражение <b>?</b> выражение <b>:</b> выражение
           l_значение операция_присваивания
                               выражение
           выражение , выражение

                            <b>-76-</b>


    первичное_выражение:
         идентификатор
         константа
         строка
        ^ (выражение)
         первичное_выражение (список выражений)
                                          необ
         первичное_выражение [выражение]
         l_значение . Идентификатор
         первичное выражение <b>-</b>> идентификатор
    l_значение:
         идентификатор
         первичное_выражение [выражение]
         l_значение . Идентификатор
         первичное_выражение <b>-</b>> идентификатор
         <b>*</b> выражение
         (l_значение)

Операции первичных выражений

             <b>()  []  .  -</b>>

имеют самый высокий приоритет и группируются слева  направо.
Унарные операции

      <b>*  &  -  !  ~  ++  --  sizeof</b>(имя типа)

имеют более низкий приоритет, чем операции первичных выраже-
ний,  но  более высокий, чем приоритет любой бинарной опера-
ции. Эти операции группируются справа налево.  Условная опе-
рация  группируется  справа  налево,  все  бинарные операции
группируются слева направо и их приоритет убывает в  следую-
щем порядке:

        бинарная операция:
                       <b>*   /   %</b>
                       <b>+   -</b>
                       >>  <b>&lt;</b><b>&lt;</b>
                       <b>&lt;</b>   >  <b>&lt;</b><b>=</b>    ><b>=</b>
                       <b>==  !=</b>
                       <b>&</b>
                       <b>~</b>
                       <b>|</b>
                       <b>&&</b>
                       <b>||</b>
                       <b>?:</b>

Все операции присваивания имеют одинаковый приоритет и груп-
пируются справа налево:

    <b>=  +=  -=  *=  ?=  %=</b> >><b>=</b>  <b>&lt;</b><b>&lt;</b><b>=  &=  ~=  |=</b>

Операция запятая имеет самый низкий приоритет и группируется


                            <b>-77-</b>


слева направо.

<ul><a name=113></a><h2>16.2.  Описания</h2></ul>

Описание:

    спецификаторы_описания список_инициа-
                         лизируемых_описателей;
                                           необ


Спецификаторы_описания:

      спецификатор_типа спецификаторы_описания
                                           необ
        спецификатор_класса_памяти специфи-
                                каторы_описания
                                           необ
    спецификатор_класса_памяти:
             <b>auto</b>
             <b>static</b>
             <b>extern</b>
             <b>register</b>
             <b>typedef</b>

    спецификатор_типа:
             <b>char</b>
             <b>short</b>
             <b>int</b>
             <b>long</b>
             <b>unsigned</b>
             <b>float</b>
             <b>double</b>
        спецификатор_структуры_или_объединения
        определяющее_тип_имя
        спецификатор_перечисления

    список_инициализируемых_описателей:
        инициализируемый_описатель
        инициализируемый_описатель,спи-
              сок_инициализируемых_описателей

    инициализируемый_описатель
             описатель_инициализатор
                                 необ

    описатель:
        идентификатор
        (описатель)
        <b>*</b> описатель
        описатель <b>()</b>

                            <b>-78-</b>


        описатель [константное выражение ]
                                     необ

    спецификатор_структуры_или_объединения:
        <b>struct</b> список_описателей_структуры
        <b>struct</b> идентификатор {список_опи-
                              саний_структуры}
        <b>struct</b> идентификатор
        <b>union</b> {список_описаний_структуры}
        <b>union</b> идентификатор {список_опи-
                             саний_структуры}
        <b>union</b> идентификатор

    список_описаний_структуры:
        описание_структуры
        описание_структуры список_опи-
                           саний_структуры

    описание структуры:
        спецификатор_типа список_описа-
                          телей_структуры

    список_описателей_структуры
        описатель_структуры
        описатель_структуры,список_описа-
                            телей_структуры

    описатель_структуры:
        описатель
        описатель<b>:</b> константное выражение
        <b>:</b>константное_выражение

    инициализатор:
        <b>=</b> выражение
        <b>= {</b>список_инициализатора<b>}</b>
        <b>= {</b>список_инициализатора<b>}</b>

    список инициализатора:
        выражение
        список_инициализатора,список_ини-
                              циализатора
        <b>{</b>список_инициализатора<b>}</b>

    имя_типа:
        спецификатор_типа абстракт-
                          ный_описатель

                            <b>-79-</b>


    абстрактный_описатель:
        пусто
        <b>{</b>абстрактный_описатель<b>}</b>
        <b>*</b> абстрактный_описатель
        абстрактный_описатель <b>()</b>
        абстрактный_описатель [констант-
                               ное_выражение]
                                        необ

    определяющее_тип_имя:
        идентификатор

    спецификатор_перечисления:
       <b>enum</b> список_перечисления
       <b>enum</b> идентификатор  список_перечисления
       <b>enum</b> идентификатор

    список_перечисления:
       перечисляемое
       список_перечисления, перечисляемое

    перечисляемое:
       идентификатор
       идентификатор <b>=</b> константное выражение

<ul><a name=114></a><h2>16.3.  Операторы</h2></ul>

    составной_оператор:
        <b>{</b>список_описаний список_операторов<b>}</b>
                     необ              необ

    список_описаний:
        описание
        описание список_описаний

    список_операторов:
        оператор
        оператор список_операторов


                            <b>-80-</b>


    оператор:
        составной оператор
        выражение;
        <b>if</b> (выражение) оператор
        <b>if</b> (выражение) оператор <b>else</b> оператор
        <b>while</b> (выражение) оператор
        <b>do</b> оператор <b>while</b> (выражение);
        <b>for</b>(выражение1;выражение2;выражение3)
                   необ       необ       необ
             оператор
        <b>switch</b> (выражение) оператор
        <b>case</b> константное_выражение <b>:</b> оператор
        <b>default:</b> оператор
        <b>break</b>;
        <b>continue</b>;
        <b>return</b>;
        <b>return</b> выражение;
        <b>goto</b> идентификатор;
        идентификатор <b>:</b> оператор
        ;

<ul><a name=115></a><h2>16.4.  Внешние определения</h2></ul>

    программа:
        внешнее_определение
        внешнее_определение программа

    внешнее_определение:
        определение_функции
        определение_данных

    определение_функции:
        спецификатор_типа  описатель_функ-
                      необ
                           ции тело_функции

    описатель_функции:
        описатель (список_параметров)
                                 необ
    список_параметров:
        идетификатор
        идентификатор , список_параметров

    тело_функции:
        список_описаний_типа оператор_функции

    оператор_функции:
        <b>{</b>список описаний список_операторов<b>}</b>
                     необ

                            <b>-81-</b>


    определение данных:
        <b>extern</b>    спецификатор_типа    спи-
           необ                 необ
               сок инициализируемых описателей;
                                           необ
        <b>static</b>    спецификатор типа     список
              необ                 необ
                  инициализируемых описателей;
                                          необ

<ul><a name=116></a><h2>16.5.  Препроцессор</h2></ul>

    <b>#define</b> идентификатор строка_лексем
    <b>#define</b> идентификатор(идентифика-
           тор,...,идентификатор) строка_лексем
    <b>#undef</b> идентификатор
    <b>#include</b> "имя_файла"
    <b>#include</b> <b>&lt;</b><b>имя</b>_<b>файла</b>>
    <b>#if</b> константное_выражение
    <b>#ifdef</b> идентификатор
    <b>#ifndef</b> идентификатор
    <b>#else</b>
    <b>#endif</b>
    <b>#line</b> константа "имя_файла"
                            необ


<ul><a name=117></a><h2> * 17.  Примеры программ на Си</h2></ul>

     Пример 1: функции  <b>fgets</b> и <b>fputs</b> (см. раздел "Стандарт-
ная библиотека ввода/вывода. Ввод/вывод строк").




                            <b>-82-</b>


    <b>#include</b>  &lt;<b>stdio.h</b>&gt;
    <b>char *fgets</b>(<b>s</b>,<b>n</b>,<b>iop</b>) /*взять<b>&lt;</b><b>=n</b> символов*/
    <b>char *</b><b>s</b>;             /* из <b>iop</b> */
    <b>int</b> <b>n</b>;
    <b>register FILE *</b><b>iop</b>;
    <b>{</b>
         <b>register int</b> <b>c</b>;
         <b>register char *</b><b>cs</b>;
         <b>cs</b> = <b>s</b>;
         <b>while</b>(--<b>n</b>&gt;0&&(<b>c</b>=<b>getc</b>(<b>iop</b>)) !=<b>EOF</b>)
              <b>if</b> ((<b>*</b><b>cs</b>++ = <b>c</b>)=='<b>\n</b>')
                   <b>break</b>;
         <b>*</b><b>cs</b> = '<b>\0</b>';
         <b>return</b>((<b>c</b>==<b>EOF</b> && <b>cs</b>==<b>s</b>) ? <b>NULL</b> : <b>s</b>);
    <b>}</b>
    <b>fputs</b>(<b>s</b>,<b>iop</b>) /*поместить строку <b>s</b> в */
    <b>register char *</b><b>s</b>;  /* файл <b>iop</b> */
    <b>register FILE *</b><b>iop</b>;
    {
         <b>register int</b> <b>c</b>;
         <b>while</b> (<b>c</b> = <b>*</b><b>s</b>++)
              <b>putc</b>(<b>c</b>,<b>iop</b>);
    <b>}</b>


Пример 2. Программа для разделения одного большого файла  на
несколько  частей  так,  чтобы  каждая  часть  начиналась со
строки .<b>sh 1</b> ...




                            <b>-83-</b>


    <b>#include</b> &lt;<b>stdio.h</b>&gt;
    <b>#define NEWH "</b>.<b>sh 1</b>" /*Признак разделения*/

    /* Трансляция:
      <b>cc -o</b> <b>ds ds</b>.<b>c</b>
       Запуск:
    <b>ds</b> откуда кудапреф кудасуфф
       результат:
    <b>ds</b> <b>a pref suff</b>
    переписывает файл <b>a</b> в файлы
    <b>pref00</b>.<b>suff</b>, <b>pref01</b>.<b>suff</b>, ...
    */

    <b>main</b> (<b>ac</b>,<b>av</b>)
    <b>char **</b><b>av</b>;
    <b>{</b>
     <b>int</b> <b>nfile</b>=0;   /* Порядковый номер файла*/
     <b>char</b> <b>str</b>[512]; /* Буфер для строки*/
     <b>if</b>(<b>ac</b> != 4)
     <b>{</b>
      <b>fprintf</b>(<b>stderr</b>,
          "Неверное число аргументов0);
      <b>exit</b>(1);
     <b>}</b>
    /* <b>freopen</b> аналогично <b>fopen</b>, но изменяет
    указанный описатель файла, а не создает
    новый. Здесь мы переопределяем
    <b>stdin</b> */
     <b>if</b>(!<b>freopen</b>(<b>av</b>[1],"<b>r</b>",<b>stdin</b>))
     <b>{</b>
      <b>fprintf</b>(<b>stderr</b>,
             "Не могу открыть:<b>%</b><b>s</b>0,<b>av</b>[1]);
             <b>exit</b>(2);
     <b>}</b>
    /* Переопределили файл станд. вывода */
     <b>of</b>(<b>av</b>[2],<b>nfile</b>,<b>av</b>[3]);

     <b>while</b>( <b>gets</b>(<b>str</b>))
     <b>{</b>
    /* <b>strncmp</b>(<b>s1</b>,<b>s2</b>,<b>l</b><b>) сравнивает две строки</b>
     <b>и возвращает 0, если первые</b> <b>l</b> символов
     совпадают */
      <b>if</b>(<b>strncmp</b>(<b>str</b>,<b>NEWH</b>,<b>strlen</b>(<b>NEWH</b>))== 0)
      <b>{</b>
       <b>fclose</b>(<b>fp</b>);
       <b>nfile</b>++;
    /* Это просто информационное сообщение */
       <b>fprintf</b>(<b>stderr</b>,
            "Начало части <b>%d</b>0,<b>nfile</b>);
       <b>fp</b> = <b>of</b>(<b>av</b>[2],<b>nfile</b>,<b>av</b>[3]);
       <b>}</b>
      <b>puts</b>(<b>str</b>);
      <b>if</b>(<b>ferror</b>(<b>stdout</b>)) <b>{</b>


                            <b>-84-</b>


        <b>fprintf</b>(<b>stderr</b>,
        "Ош записи в файл номер <b>%.2d</b>0,<b>nfile</b>);
        <b>exit</b>(4);
       <b>}</b>
     <b>}</b>
     <b>exit</b> (0);
    <b>}</b>

    /* Эта функция создает имя файла
     из трех частей и открывает его
     как стандартный вывод */

    <b>of</b>(<b>s1</b>,<b>n</b>,<b>s2</b>)
    <b>char *</b><b>s1</b>,<b>*</b><b>s2</b>;
    <b>{</b>
     <b>register FILE *</b><b>f</b>;
     <b>char</b> <b>buf</b>[100];
    /* <b>sprintf</b> возвращает свой первый аргумент */
     <b>if</b>(( <b>f</b> = <b>freopen</b>(
      <b>sprintf</b>(<b>buf</b>,"<b>%s%02d.%s</b>",<b>s1</b>,<b>n</b>,<b>s2</b>)
      ,"<b>w</b>",<b>stdout</b>))== <b>NULL</b>)
     <b>{</b>
       <b>fprintf</b>(<b>stderr</b>,
        "Не могу открыть файл:<b>%s</b>0,<b>buf</b>);
       <b>exit</b>(4);
     <b>}</b>
     <b>return</b>;
    <b>}</b>




                            <b>-85-</b>


                         СОДЕРЖАНИЕ

                      ''АННОТАЦИЯ'' ...................    2

1.  ВВЕДЕНИЕ ..........................................    1

2.  СИНТАКСИЧЕСКАЯ НОТАЦИЯ ............................    3
2.1.  Ключевые слова ..................................    3
2.2.  Константы .......................................    4
2.2.1.  Целые константы ...............................    4
2.2.2.  Длинные (<b>long</b>) константы ......................    4
2.2.3.  Символьные константы ..........................    4
2.2.4.  Вещественные константы ........................    5
2.3.  Строки ..........................................    5
2.4.  Характеристики аппаратных средств ...............    6

3.  ОБ'ЕКТЫ ЯЗЫКА СИ ..................................    6
3.1.  Интерпретация идентификаторов ...................    6
3.2.  Объекты и l_значения ............................    8
3.3.  Преобразования ..................................    8
3.3.1.  Символы и целые ...............................    8
3.3.2.  Типы <b>float</b> и <b>double</b> ...........................    9
3.3.3.  Вещественные и целочисленные величины .........    9
3.3.4.  Указатели и целые .............................    9
3.3.5.  Целое без знака ...............................    9
3.3.6.  Арифметические преобразования .................   10

4.  ВЫРАЖЕНИЯ .........................................   10
4.1.  Первичные выражения .............................   11
4.2.  Унарные операции ................................   13
4.3.  Мультипликативные операции ......................   14
4.4.  Аддитивные операции .............................   15
4.5.  Операции сдвига .................................   16
4.6.  Операции отношения ..............................   16
4.7.  Операции равенства ..............................   17
4.8.  Побитовая операция '<b>и</b>' ..........................   17
4.9.  Побитовая операция исключающего '<b>или</b>' ...........   17
4.10. Побитовая операция включающего '<b>или</b>' ............   17
4.11. Логическая операция '<b>и</b>' .........................   18
4.12. Операция логического '<b>или'</b> ......................   <b>18</b>
4.13. Условная операция ...............................   18
4.14. Операция присваивания ...........................   19
4.15. Присваивание структуры ..........................   20
4.16. Операция '<b>запятая</b>' ..............................   20
4.17. Старшинство и порядок вычисления. ...............   20

5.  ОПИСАНИЯ ..........................................   22
5.1.  Спецификаторы класса памяти .....................   22
5.2.  Спецификаторы типа ..............................   23
5.3.  Описатели .......................................   24
5.4.  Смысл описателей ................................   24


                            <b>-86-</b>


5.5.  Описание структур и объединений .................   26
5.6.  Перечислимый тип ................................   29
5.7.  Инициализация ...................................   30
5.8.  Имена типов .....................................   32
5.9.  Описатель <b>typedef</b> ...............................   33

6.  ОПЕРАТОРЫ .........................................   34
6.1.  Операторное выражение ...........................   34
6.2.  Составной оператор (или блок) ...................   34
6.3.  Условные операторы ..............................   35
6.4.  Оператор <b>while</b> ..................................   35
6.5.  Оператор <b>do</b> .....................................   35
6.6.  Оператор <b>for</b> ....................................   35
6.7.  Оператор <b>switch</b> .................................   36
6.8.  Оператор <b>break</b> ..................................   37
6.9.  Оператор <b>continue</b> ...............................   37
6.10. Оператор возврата ...............................   38
6.11. Оператор <b>goto</b> ...................................   38
6.12. Помеченный оператор .............................   38
6.13. Пустой оператор .................................   38

7.  ВНЕШНИЕ ОПРЕДЕЛЕНИЯ ...............................   39
7.1.  Внешнее определение функции .....................   39
7.2.  Внешние определения данных ......................   40

8.  ОБЛАСТЬ ДЕЙСТВИЯ ИДЕНТИФИКАТОРОВ ..................   40
8.1.  Лексическая область действия ....................   41
8.2.  Область действия внешних идентификаторов ........   42
8.3.  Неявные описания ................................   42

9.  ПРЕПРОЦЕССОР ЯЗЫКА 'СИ' ...........................   43
9.1.  Замена лексем ...................................   43
9.2.  Включение файлов ................................   44
9.3.  Условная компиляция .............................   45
9.4.  Команда <b>#line</b> ...................................   45

10. ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ О ТИПАХ .................   46
10.1. Структуры и объединения .........................   46
10.2. Функции .........................................   47
10.3. Массивы, указатели и индексация .................   47
10.4. Явные преобразования указателей .................   48

11. КОНСТАНТНЫЕ ВЫРАЖЕНИЯ .............................   49

12. СООБРАЖЕНИЯ О ПЕРЕНОСИМОСТИ .......................   49
12.1. Анахронизмы .....................................   51

13. СТАНДАРТНАЯ БИБЛИОТЕКА ВВОДА И ВЫВОДА .............   51
13.1. Обращение к стандартной библиотеке ..............   52
13.2. Стандартный ввод и вывод ........................   52
13.3. Форматный вывод - функция <b>printf</b> ................   53
13.4. Форматный ввод - функция <b>scanf</b> ..................   55
13.5. Форматное преобразование в памяти ...............   58


                            <b>-87-</b>


13.6. Доступ к файлам .................................   59
13.7. Обработка ошибок - <b>stderr</b>  и  <b>exit</b> ..............   61
13.8. Ввод и вывод строк ..............................   62
13.9. Функция <b>ungetc</b> ..................................   62
13.10.Разные стандартные функции ......................   62
13.10.1.Управление памятью ............................   62
13.10.2.Стандартные функции языка Си ..................   63

14. ВЗАИМОДЕЙСТВИЕ С ОПЕРАЦИОННОЙ СИСТЕМОЙ ............   63
14.1. Подготовка программ на Си в <b>ОС ДЕМОС</b> ............   64
14.2. Доступ к аргументам команды .....................   64

15. ИНТЕРФЕЙС СИСТЕМЫ <b>ДЕМОС</b> ...........................   66
15.1. Ввод/вывод ......................................   66
15.1.1. Дескрипторы файлов ............................   66
15.1.2. Низкоуровневый ввод/вывод. ....................   67
15.1.3. Открытие, создание, закрытие и удаление .......   68
15.1.4. Произвольный доступ - <b>lseek</b> ...................   69
15.2. Управление процессами ...........................   70
15.2.1. Функция <b>system</b> ................................   71
15.2.2. Вызов программы на низком уровне - <b>execl</b> ......   71
15.2.3. Порождение нового процесса - <b>fork</b> .............   71
15.2.4. Канал межпроцессной связи .....................   73
15.3. Сигналы и прерывания ............................   74

16. Сводка синтаксических правил ......................   76
16.1. Выражения .......................................   76
16.2. Описания ........................................   78
16.3. Операторы .......................................   80
16.4. Внешние определения .............................   81
16.5. Препроцессор ....................................   82

17. Примеры программ на Си ............................   82




                            <b>-88-</b>

<pre><hr noshade><small>Обращений с начала месяца: <b>52</b>, Last-modified: Mon, 29 Jun 1998 14:37:17 GMT
</small><div align=right><form action=mailto:hit@library.niisi.ras.ru method=POST><a href=/HITPARAD/><font color=black>Оцените</font></a> этот текст:<tt><font size=-1><INPUT TYPE=hidden NAME=file VALUE=/MAN/DEMOS210/c.txt><SELECT NAME=ocenka><OPTION VALUE=0>Не читал<OPTION VALUE=10>10<OPTION VALUE=9>9<OPTION VALUE=8>8<OPTION VALUE=7>7<OPTION VALUE=6>6<OPTION VALUE=5>5<OPTION VALUE=4>4<OPTION VALUE=3>3<OPTION VALUE=2>2<OPTION VALUE=1>1</SELECT><INPUT TYPE=submit VALUE=Send></font></tt></form></div>

</body></html>
