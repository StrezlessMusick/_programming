1.2.2.1 коннцепты безопасности POSIX

Этот мануал документирует различные пропорции безопасности GNU c библиотеки функций, в строках, которые следуют за их прототипах и выглядят как:
Предварительно:
	Многопочно-безопасная
	к Асинхронным сигналам безопасная
	к асинхронному завершению безопасна

Свойства помогают соответствовать критериям, следующим из стандарта POSIX для таких контекстов безопасности как
Поточная, к асинхронным сигналам и к асинхронному завершению безапасный.
Интуитивное определение этих всойствпытаясь озаглавить значение стандартных определений, далее

МП-безопасная или Потоко-безопасная функция безопасна к вызовам в других потоках. МП - Многопоточная.

........

АС-безопасная или к асинхронным сигналам безопасная функция безопасна для вызовов обработчиками асинхронных сигналов

........

АЗ-безопассная, или к асинхронному завершению безопасная функция - безопасная для вызовов, когда включено асинхронное завершение.
Стандарт POSIX определяет только три фукции, которые ФЗ-безопасны: pthread_cancel, pthread_setcancelstate, и pthread_setcanceltype.
В настояящее время GNU c библиотека не предоставляет гарантий за исключением этих трех функций, но 

1.2.2.2 Небезопасные особенности
Функции, которые небезопасны для вызовов в конечном контексте объявляются с ключевыми словами, которые описывают их особенности, которые делают их небезопасными.
АС-небезопасные особенности в этом разделе показывают, что функции никогда не безопасны для вызовов, когда включена асинхронная обработка сигналов.
АЗ-небезопасные особенности показывают, что они никогда не безопасны для вызовов, когда включено асинхронное заверщшение. 
МП-небезопасные особенности отсутствуют в этом разделе.

блокировка
Функции, помеченные как блокировка и АС-небезопасные, могут быть прерваны сигналом во время удержания нерекурсивной блокировки.
Если обработчик сигнала вызывает другую такую функцию, она делает такую же блокировку, и в результате получается мертвая-локировка.
Функции, помеченные как блокировка и АЗ-небезопасные, могут, если асинхронно завершены, не выполнить разблокровку, которая была бы выполнена если бы их выполнение не было бы прервано асинхронным завершением потока.
Однажды взяв блокировку, попытки взять ее будут блокироваться неопределенно.

повреждение
АС-небезопасные функции, помеченные как повреждение, могут повреждать структуры данных и вести себя неопределенно когда прерваны, или интерпретируются другими такими функциями.
В отличие от функций, помеченных как блокировка, эти делают рекурсивные блокировки чтобы избежать проблем МП-безопасности, но этого недостаточно, чтобы остановить обработчик прерывания от просмотра частично обновленной структуры данных.


=============================================================
6.3.3 преобразование одиночных символов

Наиболее фундаментальными функциями преобразований являются те, которые работают с одиночными символами.
Пожалуйста помните, что это не всегда одиночные байты.
since - так как
Но так как очень часто подмножество множества мультибайтовых символов содержит однобайтовые последовательности, есть функции, помогающие преобразовывать байты.
Часто ASCII является подчастью набора мультибайтовых символов.
В этом случае, каждый ASCII символ соответствует сам себе, а все оставшиеся символы имеют по крайней мере 1й символ за мпределами 0..127.
>> beyond - загробная жизнь, за пределами.

Функция win_t btowc(int c)
>> preliminary - предварительно
Предварительно:
	многопоточно-безопасная
	к асинхронным сигналам небезопасная: 

Предварительно: 
	если !ps МП-небезопасно: гонка
	AS-небезопасно: ??? 
	AC-небезопасно: ???
	см. <концепцию безопасности POSIX>

Функция wcrtomb ("широкий символ прерываемо в многобайтовый") преобразовывает 1 широкий сивол в мультибайтовую строку, соответствующую этому символу.

Если s - нулевой указатель, функция переустанавливает состояние в объекте, указываемом ps (или внутренний объект mbstate_t) в начальное состояние.
Оно также может быть достигнуто таким вызовом как этот: 
wcrtombs(temp_buf,L'\0',ps)
если s - нулевой указатель, wcrtomb представляет, как буд-то пишет во внутренний буфер, гарантированно достаточно большой.

Если wc - нулевой широкий символ, wcrtomb выпускает, если это необходимо, сдвиговую последовательность, чтобы установить значение ps в начальное состояние, следуя после одиночного нулевого байта, который сохраняется в строке s.

В противном случае байтовая последовательность (возможно включающая сдвиговую )
