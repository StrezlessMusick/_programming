<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Запуск и Окончание Процесса</TITLE>
 <LINK HREF="glibc-23.html" REL=next>
 <LINK HREF="glibc-21.html" REL=previous>
 <LINK HREF="glibc.html#toc22" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2">
<LINK REL="stylesheet" href="http://www.opennet.ru/opennet4.css" type="text/css">
<!--htdig_noindex-->
<FORM method="get" action="http://www.opennet.ru/search.shtml">
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%">
<TR>
<TD VALIGN="BOTTOM" BGCOLOR="#E9EAD6" style="background: #E9EAD6 url('http://www.opennet.ru/back.gif') repeat-x bottom left">
<A HREF="http://www.opennet.ru/"><IMG SRC="http://www.opennet.ru/opennet2.gif" HEIGHT=60 WIDTH=249 ALT="The OpenNET Project" BORDER="0"></A><br>
</TD>

<TD BGCOLOR="#B0B190" WIDTH="1"><IMG SRC="http://www.opennet.ru/p.gif" HEIGHT=1 WIDTH=1 ALT=""></TD>

<TD VALIGN=TOP ALIGN=RIGHT WIDTH="470" HEIGHT="70" BGCOLOR="#D9DAC6">
<TABLE BORDER=0 CELLPADDING=1 WIDTH="470">
<TR>
<TD HEIGHT=60 BGCOLOR="#D9DAC6">

<script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
 style="display:inline-block;width:468px;height:60px"
 data-ad-client="ca-pub-2075278885744463"
 data-ad-slot="4070171090"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</TD>
</TR>
</TABLE>
</TD>

<TD BGCOLOR="#B0B190" WIDTH="1"><IMG SRC="http://www.opennet.ru/p.gif" HEIGHT=1 WIDTH=1 ALT=""></TD>
<TD WIDTH="40" BGCOLOR="#E9EAD6" style="background: #E9EAD6 url('http://www.opennet.ru/back.gif') repeat-x bottom left">&nbsp;</TD>
<TD BGCOLOR="#B0B190" WIDTH="1"><IMG SRC="http://www.opennet.ru/p.gif" HEIGHT=1 WIDTH=1 ALT=""></TD>

<TD VALIGN=TOP ALIGN=RIGHT WIDTH="130" BGCOLOR="#E9EAD6" ROWSPAN=3>
<a              
href="http://click.opennet.ru/cgi-bin/opennet/hjump.cgi?lanbilling9" target=_blank><img              
src="http://www.opennet.ru/img/lanbilling9.gif" width=130 height=125 border=0 alt=""></a>

</TD>

</TR>

<TR BGCOLOR="#B0B190"><TD COLSPAN=6><IMG SRC="http://www.opennet.ru/p.gif" HEIGHT=1 WIDTH=1 ALT=""></TD></TR>


<TR BGCOLOR="#E9EAD6">
<TD ALIGN=CENTER COLSPAN=5>
<table width="100%">
<tr>
<td rowspan=2 width=300 nowrap class="h">
<INPUT type=hidden name=exclude value="index|/man.shtml"><A HREF="http://www.opennet.ru/search.shtml" class="h"><u>Поиск</u></A>&nbsp;(<A HREF="http://www.opennet.ru/keywords/" class="h">теги</A>):&nbsp;<INPUT type="text" size="20" name="words" value="" title='для поиска в google наберите "g фраза"'>
</td><td width="20%">
&nbsp;   <A HREF="http://www.opennet.ru/opennews/" class="h"><b><u>НОВОСТИ</u></b></A> (<a href="http://www.opennet.ru/news/opennet.shtml" class="h">+</a>)
</td><td width="20%">
  <A HREF="http://www.opennet.ru/mp/" class="h"><b><u>КОНТЕНТ</u></b></A>
</td><td width="20%">
  <A HREF="http://wiki.opennet.ru" class="h"><b><u>WIKI</u></b></A>
</td><td width="20%">
   <A HREF="http://www.opennet.ru/man.shtml" class="h"><b><u>MAN'ы</u></b></A>
</td><td width="20%">
   <A HREF="http://www.opennet.ru/forum/" class="h"><b><u>ФОРУМ</u></b></A>
</td></tr>
</table>
</TD>
<TD BGCOLOR="#B0B190" WIDTH="1"><IMG SRC="http://www.opennet.ru/p.gif" HEIGHT=1 WIDTH=1 ALT=""></TD>
</TR>
<TR BGCOLOR="#B0B190"><TD COLSPAN=7><IMG SRC="http://www.opennet.ru/p.gif" HEIGHT=2 WIDTH=1 ALT=""></TD></TR>
</TABLE>

<div style="float: left; width: 279; text-align: left;padding-right: 60px;" id=adv><A HREF="http://www.ip-as.ru" target=_blank><IMG SRC="http://www.opennet.ru/img/ipas3.gif" BORDER="0" width="279" height="40"></A></div>
<div style="padding-top: 0px;position:absolute;left:50%;margin-left:-235px;width:470px;" id=adv2>
<script language=JavaScript src="http://www.opennet.ru/cgi-bin/opennet/hints.cgi?itsoft"></script> 
</div>
<div style="width: 279;float: right;" id=adv3>
</div>
<div style="clear: both;"></div>
<br>

<script language="JavaScript"><!--
d=document;a='';r=escape(d.referrer);a+=';r='+r;
js=10; d.write('<img src="http://top.list.ru/counter'+
'?id=77689;js='+js+a+';rand='+Math.random()+
'" alt="" height=1 width=1>');
if(js>11)d.write('<'+'!-- ')//--></script><noscript><img
src="http://top.list.ru/counter?js=na;id=77689"
height=1 width=1 alt="">
</noscript>

</FORM>
<!--/htdig_noindex-->


<table  BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" style="margin-bottom: 5px;margin-top: 5px;">
<tr><td>
<TABLE  BORDER=0 CELLSPACING=0 CELLPADDING=4 BGCOLOR="#E9EAD6" WIDTH="100%">
<TR BGCOLOR="#C7CBB1"><TD><FONT COLOR="#000090">
<b><a href="http://www.opennet.ru/docs/">Каталог документации</a> / 
<a href="http://www.opennet.ru/docs/124.shtml">Раздел "Программирование, языки"</a> /
<a href="index.html">Оглавление документа</a>
</b>
</TD></TR>
</TABLE>
</TD></TR>
<TR BGCOLOR="#B0B190"><TD><IMG SRC="http://www.opennet.ru/p.gif" HEIGHT=3 WIDTH=1 ALT=""></TD></TR>
</TABLE>

<A HREF="glibc-23.html">Вперед</A>
<A HREF="glibc-21.html">Назад</A>
<A HREF="glibc.html#toc22">Содержание</A>
<HR>
<H2><A NAME="s22">22. Запуск и Окончание Процесса</A></H2>

<P>
<P>Процессы - примитивные модули для распределения ресурсов системы.
Каждый процесс имеет собственное адресное пространство. Процесс
выполняет программу; Вы можете иметь многократные процессы,
выполняющие ту же самую программу, но каждый процесс имеет собственную
копию программы внутри собственного адресного пространства и выполняет
ее независимо от других копий.
<P>Эта глава объясняет, что ваша программа должна делать, чтобы
обработать запуск процесса, завершить процесс, и получить информацию
(аргументы и среду) из родительского процесса.
<P>
<H2><A NAME="ss22.1">22.1 Аргументы Программы</A>
</H2>

<P>
<P>Система начинает программу C, вызывая функцию main. Вы должны
написать функцию, именованную main, иначе Вы не будете способны
линковать вашу программу без ошибок.
<P>Вы можете определять main без аргументов, или брать два
аргумента, которые представляют аргументы командной строки программы,
примерно так:
<BLOCKQUOTE><CODE>
<PRE>
                int main (int argc, char *argv[])
</PRE>
</CODE></BLOCKQUOTE>
      Аргументы командной строки - отделяемые пропуском лексемы,
заданные в команде оболочки, используемой, чтобы вызвать программу;
таким образом, в " cat foo bar ", аргументы - " foo " и " bar ".
Программа может рассматривать аргументы командной строки единственым
способом - через аргументы main.
<P>Значение argc аргумента - число аргументов командной строки.
Аргумент argv - вектор строк; элементы - индивидуальные строки
аргументов командной строки. Имя файла выполняемой программы также
включено в вектор как первый элемент; значение argc учитывает этот
элемент. Пустой указатель всегда следует за последним элементом: argv
[argc] - это пустой указатель.
<P>Для команды " cat foo bar ", argc - 3, и argv имеет три элемента,
" cat ", " foo " и " bar ".
<P>Если синтаксис для аргументов командной строки вашей программы
является достаточно простым, Вы может просто выбирать аргументы из
argv вручную. Но если ваша программа берет фиксированное число
аргументов, или все аргументы интерпретируются одинаковым образом (как
имена файлов, например), Вам лучше использовать getopt, чтобы делать
синтаксический анализ.
<P>
<H3>Синтаксические Соглашения Аргументов Программы</H3>

<P>
<P>POSIX рекомендует эти соглашения для аргументов командной строки.
Getopt (см. Раздел 22.1.2 [Опции Синтаксического анализа]) облегчит их
реализацию.
<UL>
<LI>       Аргументы - опции, если они начинаются с разделителя дефиса (" - ").</LI>
<LI>       За разделителем могут следовать много опций в одиночной
лексеме, если опции не берут аргументов. Таким образом, " -abc "
эквивалентно " -a -b -c ".</LI>
<LI>       Имена опций - одиночные алфавитно-цифровые символы (как для
isalnum; см. Раздел 4.1 [Классификация Символов]).</LI>
<LI>       Некоторые опции требуют аргумента. Например, команда ` -o '
ld требует аргумент - имя выходного файла.</LI>
<LI>       Опция и ее аргумент могут не занимать отдельные лексемы.
(Другими словами, пропуск, отделяющий их необязателен.) Таким образом,
" -o foo " и " -ofoo " эквивалентны.</LI>
<LI>       Опции обычно предшествуют другим аргументам, не-опциям. команды</LI>
</UL>
     Реализация getopt в библиотеке GNU C обычно делает так, как будто
все аргументы опции были определены перед всеми аргументами не-опциями
для целей синтаксического анализа, даже если пользователь вашей
программы смешал опции и аргументы не-опции. Она делает это,
переупорядочивая элементы массива argv. Это поведение нестандартно;
если Вы хотите подавлять его, определите _POSIX_OPTION_ORDER
переменную среды. См. Раздел 22.2.2 [Стандартная Среда].
<UL>
<LI>        Аргумент " -- " завершает все опции; все остальные аргументы 
обрабатываются как аргументы-не-опции, даже если они начинаются с 
дефиса.</LI>
<LI>        Лексема, состоящая из одиночного символа дефиса 
интерпретируется как обычный аргумент-не-опция. Обычно, она 
используется, чтобы определить ввод из или вывод в стандартный ввод 
и вывод.</LI>
<LI>        Опции могут быть обеспечены в любом порядке, или появляться 
многократно. Интерпретация оставлена до специфической прикладной 
программы.</LI>
</UL>

GNU добавляет длинные опции к этому соглашению. Длинные опции 
состоят из " -- " сопровождаемых именем, составленным из алфавитно&shy;
цифровых символов, и подчеркивания. Имена опций - обычно от одного 
до трех слов длинной, с дефисами, чтобы отделить слова. 
Пользователи могут сокращать имена опций, если только сокращения 
уникальны.
<P>Пример длинной опции " --name=value ". Этот синтаксис дает 
возможность длинной опции принять аргумент, который является 
самостоятельно необязательным.
<P>В конечном счете, система GNU будет обеспечивать длинные имена 
опций в оболочке.
<P>
<H3>Опции Программ Синтаксического анализа</H3>

<P>
<P>
<P>Имеются подробности относительно того, как вызвать getopt 
функцию. Чтобы использовать это средство, ваша программа должна 
включить заглавный файл " unistd.h ".
<BLOCKQUOTE><CODE>
<PRE>
       int opterr  (переменная)
</PRE>
</CODE></BLOCKQUOTE>

Если значение этой переменной является отличным от нуля, то 
getopt, печатает сообщение об ошибках в стандартный поток ошибки, 
если она сталкивается с неизвестным символом опции или опцией с 
отсутствующим требуемым аргументом. Это - заданное по умолчанию 
поведение. Если Вы обнуляете эту переменную, getopt, не печатает 
никаких сообщений, но она все еще возвращает символ ? чтобы 
указывать ошибку.
<BLOCKQUOTE><CODE>
<PRE>
       int optopt  (переменная)
</PRE>
</CODE></BLOCKQUOTE>

Когда getopt сталкивается с неизвестным символом опции или 
опцией с отсутствующим требуемым аргументом, она сохраняет этот 
символ опции в этой переменной. Вы можете использовать ее для 
обеспечения ваших собственных диагностических сообщений.
<BLOCKQUOTE><CODE>
<PRE>
       int optind  (переменная)
</PRE>
</CODE></BLOCKQUOTE>

Эта переменная будет установлена getopt как индекс следующего 
элемента массива argv, который будет обработан. Если getopt нашла 
все аргументы-опции, Вы можете использовать эту переменную, чтобы 
определить, где начинаются остающиеся аргументы-не-опции. Начальное 
значение этой переменной 1.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       char * optarg  (переменная)
</PRE>
</CODE></BLOCKQUOTE>

Эта переменная будет установлена getopt, чтобы указать число  
аргументов опций, для тех опций кторые принимают аргументы.
<BLOCKQUOTE><CODE>
<PRE>
       int getopt (int argc, char **argv, const char *options)   (функция)
</PRE>
</CODE></BLOCKQUOTE>
       Getopt функция получает следующий аргумент-опцию списка 
параметров, заданного argv и argc аргументами. 
<P>Аргумент-опция - строка, которая определяет символы опции, 
которые являются допустимыми для этой программы. Символ опции в 
этой строке может сопровождаться двоеточием (": ") чтобы указать, 
что она берет требуемый аргумент.
<P>Если строка аргумента-опции начинается с дефиса (" - "), она 
обрабатывается особенно. Это разрешает аргументам-не-опциям,  
возвращаться, как будто они были связаны с последним символом 
опции.
<P>Getopt функция возвращает символ опции для следующей опции 
командной строки. Когда нет больше аргументов-опций, она возвращает 
-1. Может все еще иметься большое количество аргументов-не-опций; 
Вы должны сравнить внешнюю переменную optind c параметром argc, 
чтобы проверить это.
<P>Если опция имеет аргумент, getopt возвращает аргумент, сохраняя 
его в переменной optarg. Вы обычно не должны копировать optarg 
строку, так как это - указатель в первоначальный массив argv, а не 
в статическую область, которая могла бы быть перезаписана.
<P>Если getopt находит символ опции в argv, который не был включен 
в опции, или отсутствующий аргумент некоторой опции, она возвращает 
"? ", устанавливает внешнюю переменную optopt как фактический символ
опции. Если первый символ опции - двоеточие (":"), то getopt 
возвращает ":" вместо "? " Чтобы указать отсутствующий аргумент 
опции. Кроме того, если внешняя переменная opterr отлична от нуля 
(который является значением по умолчанию), getopt печатает 
сообщение об ошибках.
<P>
<P>
<P>
<P>
<P>
<P>
<H3>Пример Синтаксического Анализа Аргументов с getopt</H3>

<P>
<P>
<P>Вот пример, показывающий, как getopt обычно используется:
<BLOCKQUOTE><CODE>
<PRE>
        #include &lt;unistd.h&gt;
        #include &lt;stdio.h&gt;
        int
        main (int argc, char **argv)
        {
                int aflag = 0;
                int bflag = 0;
                char *cvalue = NULL;
                int index;
                int c;
                opterr = 0;
                while ((c = getopt (argc, argv, "abc:")) != -1)
                switch (c)
                {
                        case 'a':
                                aflag = 1;
                                break;
                        case 'b':
                                bflag = 1;
                                break;
                        case 'c':
                                cvalue = optarg;
                                break;
                        case '?':
                                if (isprint (optopt))
                                        fprintf (stderr, "Unknown option        
                                                `-%c'.\n", optopt);
                                else
                                        fprintf (stderr, "Unknown option        
                                character `\\x%x'.\n", optopt);
                                return 1;
                        default:
                                abort ();
                }
                printf ("aflag = %d, bflag = %d, cvalue = %s\n",        
                                aflag, bflag, cvalue);
                for (index = optind; index &lt; argc; index++)
                        printf ("Non-option argument %s\n",             
                                argv[index]);
                return 0;
        }
</PRE>
</CODE></BLOCKQUOTE>

Имеются некоторые примеры, показывающие, что эта программа 
печатает с различными комбинациями аргументов:
<BLOCKQUOTE><CODE>
<PRE>
                % testopt
                aflag = 0, bflag = 0, cvalue = (null)
       
                % testopt -a -b
                aflag = 1, bflag = 1, cvalue = (null)
       
                % testopt -ab
                aflag = 1, bflag = 1, cvalue = (null)
       
                % testopt -c foo
                aflag = 0, bflag = 0, cvalue = foo
       
                % testopt -cfoo
                aflag = 0, bflag = 0, cvalue = foo
       
                % testopt arg1
                aflag = 0, bflag = 0, cvalue = (null)
                Non-option argument arg1
       
                % testopt -a arg1
                aflag = 1, bflag = 0, cvalue = (null)
                Non-option argument arg1
       
                % testopt -c foo arg1
                aflag = 0, bflag = 0, cvalue = foo
                Non-option argument arg1
       
                % testopt -a -- -b
                aflag = 1, bflag = 0, cvalue = (null)
                Non-option argument -b
       
                % testopt -a &shy;
                aflag = 1, bflag = 0, cvalue = (null)
                Non-option argument &shy;
</PRE>
</CODE></BLOCKQUOTE>
<H3>Синтаксический анализ Длинных Опций</H3>

<P>
<P>
<P>Чтобы воспринимать GNU стиль длинных опций также как одиночно&shy;
символьные опции, используйте getopt_long вместо getopt. Вы должны 
заставить каждую программу принимать длинные опции, если она 
использует опции, это занимает немного ресурсов, и помогает 
новичкам помнить, как использовать программу.
<P>
<BLOCKQUOTE><CODE>
<PRE>
       struct option  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Эта структура описывает одиночное длинное имя опции для 
getopt_long. Аргумент longopts должен быть массивом этих структур, 
по одной для каждой длинной опции.
<P>Завершите массив элементом, содержащим все нули.
<P>Структура option имеет поля:
<BLOCKQUOTE><CODE>
<PRE>
                        const char *name
</PRE>
</CODE></BLOCKQUOTE>

Это поле - имя опции. Это - строка.
<BLOCKQUOTE><CODE>
<PRE>
                        int has_arg
</PRE>
</CODE></BLOCKQUOTE>

Это поле говорит, берет ли опция аргумент. Это - целое число, и 
имеются три законных значения: no_argument, required_argument и 
optional_argument.
<BLOCKQUOTE><CODE>
<PRE>
                        int *flag
                        int val  
</PRE>
</CODE></BLOCKQUOTE>

Эти поля управляют, как сообщать или действовать на опцию, когда 
она прочитана.
<P>Если flag - пустой указатель, то val - значение, которое 
идентифицирует эту опцию. Часто эти значения выбраны, чтобы 
однозначно идентифицировать специфические длинные опции.
<P>Если flag - не пустой указатель, это должен быть адрес int 
переменной, которая является флагом для этой опции. Значение в val 
- значение, которое нужно сохранить во флаге, чтобы указать, что 
опция была замечена.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       int getopt_long (int argc, char **argv, const char *shortopts, struct option *longopts, int *indexptr) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Декодирует опции из вектора argv (чья длина argc). Аргумент 
shortopts описывает короткие опции, принимаемые точно так же как 
это делается в getopt. Аргумент longopts описывает длинные опции 
(см. выше).
<P>Когда getopt_long сталкивается с короткой опцией, она делает ту 
же самую вещь, что и getopt: она возвращает символьный код для 
опции, и сохраняет аргумент этой опции (если он имеется) в optarg.
<P>Когда getopt_long сталкивается с длинной опцией, она действует, 
основываясь на flag и val полях определения этой опции.
<P>Если flag - пустой указатель, то getopt_long возвращает 
содержимое val, чтобы указать какую опцию она нашла. Вы должны
указывать различные значения в val поле для опций с различными 
значениями, так что Вы можете декодировать эти значения после того, 
как getopt_long возвращается. Если длинная опция  эквивалентна 
короткой опции, Вы может использовать код символа короткой опции в 
val.
<P>Если flag - не пустой указатель, значит эта опция должна только  
установить флаг в программе. Флаг - переменная типа int, что Вы и 
определяете. Поместите адрес флага в поле flag. Поместите в val 
поле значение, которое Вы хотели бы, чтобы эта опция сохранила во 
флаге. В этом случае, getopt_long возвращает 0.
<P>Для любой длинной опции, getopt_long сообщает Вам индекс в 
массиве longopts определения опций, сохраняя его в *indexptr. Вы 
можете получить имя опции через longopts [*indexptr].name . Так что 
Вы можете различать длинные опции или значениями в их val полях или 
их индексами.
<P>Когда длинная опция имеет аргумент, getopt_long помещает 
значение аргумента в переменную optarg перед возвращением. Когда 
опция не имеет никакого аргумента, значение в optarg - пустой 
указатель.
<P>Когда getopt_long не имеет больше опций для обработки, она 
возвращает -1, и оставляет в переменной optind индекс следующего 
остающегося аргумента в argv.
<P>
<P>
<P>
<H3>Пример Синтаксического анализа Длинных Опций</H3>

<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        #include &lt;stdio.h&gt;
        static int verbose_flag;
        int
        main (argc, argv)
                                int argc;
                                char **argv;
        {
                int c;
                while (1)
                {
                        static struct option long_options[] = {
                                {"verbose", 0, &amp;verbose_flag, 1}, 
                                {"brief", 0, &amp;verbose_flag, 0}, 
                                {"add", 1, 0, 0},
                                {"append", 0, 0, 0},
                                {"delete", 1, 0, 0},
                                {"create", 0, 0, 0},
                                {"file", 1, 0, 0},
                                {0, 0, 0, 0}
                        };
                        int option_index = 0;
                        c = getopt_long (argc, argv, "abc:d:",
                        long_options, &amp;option_index);
                        if (c == -1)
                                break;
                        switch (c)
                        {
                                case 0:
                                   if (long_options[option_index].flag  
                                                                        != 0)
                                        break;
                                   printf ("option %s",                         
                 long_options[option_index].name);
                                   if (optarg)
                                        printf (" with arg %s", optarg);
                                        printf ("\n");
                                        break;
                                case 'a':
                                        puts ("option -a\n");
                                        break;
                                case 'b':
                                        puts ("option -b\n");
                                        break;
                                case 'c':
                                        printf ("option -c with value   
                                                `%s'\n", optarg);
                                        break;
                                case 'd':
                                        printf ("option -d with value   
                                                `%s'\n", optarg);
                                        break;
                                case '?':
                /* getopt_long already printed an error message. */
                                        break;
                                default:
                                        abort ();
                        }
                }
                if (verbose_flag)
                        puts ("verbose flag is set");
       /* Печатаем любые остающиеся аргументы командной строки  
                                                        (не опции). */
                        if (optind &lt; argc)
                        {
                                printf ("non-option ARGV-elements: ");
                                while (optind &lt; argc)
                                        printf ("%s ", argv[optind++]);
                                putchar ('\n');
                        }
                        exit (0);
                }
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss22.2">22.2 Переменные среды</A>
</H2>

<P>
<P>
<P>Когда программа выполняется, она получает информацию 
относительно контекста, в котором она вызывалась двумя способами. 
Первый механизм использует argv и argc аргументы функции main, и 
обсужден в Разделе 22.1 [Аргументы Программы]. Второй механизм 
использует переменные среды и обсужден в этом разделе.
<P>Механизм argv обычно используется, чтобы передать аргументы 
командной строки, специфические для специфической вызываемой 
программы. Среда, с другой стороны, следит за информацией, которая 
разделена многими программами, и к ней менее часто обращаются.
<P>Переменные среды, обсужденные в этом разделе - те же самые 
переменные среды, что Вы устанавливаете используя присванивание и  
команду export в оболочке. Программы, выполненные из оболочки 
наследуют все переменные среды из оболочки.
<P>Стандартные переменные среды используются для уточнения 
инфрмации относительно исходного каталога пользователя, типа 
терминала, текущего стандарта, и так далее; Вы можете определять 
дополнительные переменные для других целей. Набор всех переменных 
среды, которые имеют значения, общеизвестен как среда.
<P>Имена переменных среды чувствительны к регистру и не должны 
содержать символ "=".
<P>Определенные системой переменные среды неизменны относительно
верхнего регистра.
<P>Значения переменных среды могут быть чем угодно, что может 
представляться как строка. Значение не должно содержать внедренный 
пустой символ, так как им принято завершать строку.
<P>
<H3>Доступ к Среде</H3>

<P>
<P>
<P>К значению переменной среды можно обращаться  getenv функцией.
Это объявлено в заглавном файле " stdlib.h ".
<P>
<BLOCKQUOTE><CODE>
<PRE>
       char * getenv (const char *name)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает строку, которая является значением 
переменной среды. Вы не должны изменять эту строку. В некоторых 
системах не-UNIX, не использующих библиотеку GNU, она может быть 
перезаписана поверх последующими обращениями к getenv (но не к 
любой другой библиотечной функции). Если имя переменной среды не 
определено, значение - пустой указатель.
<P>
<BLOCKQUOTE><CODE>
<PRE>
       int putenv (const char *string)  (функция)
</PRE>
</CODE></BLOCKQUOTE>
       Putenv функция добавляет или удаляет определения из среды. Если 
строка имеет форму " name=value ", определение будет добавлено к 
среде. Иначе, строка интерпретируется как имя переменной среды, и 
любое определение для этой переменной в среде будет удалено.
<P>Библиотека GNU обеспечивает эту функцию для совместимости с 
SVID; она не может быть доступна в других системах.
<P>Вы можете иметь дело непосредственно с основным представлением 
объектов среды, чтобы добавить большое количество переменных к 
среде (например, связываться с другой программой, которую Вы 
собираетесь выполнять; см. Раздел 23.5 [Выполнение Файла]).
<P>
<BLOCKQUOTE><CODE>
<PRE>
       char ** environ  (переменная)
</PRE>
</CODE></BLOCKQUOTE>

Среда представляется как массив строк. Каждая строка имеет 
формат " name=value ". Порядок, в котором строки появляются в среде 
не значителен, но то же самое имя не должно появиться больше чем 
один раз. Последний элемент массива - пустой указатель.
<P>Эта переменная объявлена в заглавном файле " unistd.h ".
<P>Если Вы хотите только получить значение переменной среды, 
использует getenv.
<P>
<H3>Стандартные Переменные среды</H3>

<P>
<P>
<P>Эти переменные среды имеют стандартные значения. Это не 
означает, что они всегда представляются в среде; но если эти 
переменные присутствуют, они имеют эти значения, и Вы не должны 
пробовать использовать эти имена переменных среды для некоторой 
другой цели.
<P>
<BLOCKQUOTE><CODE>
<PRE>
       HOME
</PRE>
</CODE></BLOCKQUOTE>

Это - строка представляет исходный каталог пользователя, или 
начальное значение рабочего каталога по умолчанию.
<P>Пользователь может устанавливать HOME как любое значение. Если, 
Вы должны получить соответствующий исходный каталог для 
специфического пользователя, Вы не должен использовать HOME; 
взамен, найдите имя пользователя в базе данных пользователей (см. 
Раздел 25.12 [База данных Пользователей]).
<BLOCKQUOTE><CODE>
<PRE>
       LOGNAME
</PRE>
</CODE></BLOCKQUOTE>

Это - имя  пользователя, используемое для входа в систему.
Так как значение в среде может быть произвольно, это - не надежный 
способ идентифицировать пользователя, который выполняет процесс; 
функция getlogin (см. Раздел 25.11 [Кто Вошел В Систему] ) лучше 
для той цели.
<P>Для большинства целей, лучше использовать LOGNAME, потому что 
она позволяет  пользователю определять значение.
<BLOCKQUOTE><CODE>
<PRE>
       PATH
</PRE>
</CODE></BLOCKQUOTE>

Путь - последовательность имен каталогов, которая используется 
для поиска файла. Переменная PATH содержит путь, используемый для 
поиска программ, которые будут выполнены.
<P>Execlp и execvp функции (см. Раздел 23.5 [Выполнение Файла]) 
используют эту переменную среды, как и многие оболочки и другие 
утилиты, которые выполнены в терминах этих функций.
<P>Синтаксис пути - последовательность имен каталогов, отделяемых 
двоеточиями. Пустая строка вместо имени каталога замещает текущий 
каталог (см. Раздел 9.1 [Рабочий каталог]).
<P>Типичное значение для этой переменной среды могло бы быть: 
:/bin:/etc:/usr/bin:/usr/new/X11:/usr/new:/usr/local/bin
<P>Это означает что, если пользователь пробует выполнять программу, 
именованную foo, система будет искать файлы, именованные " foo ", " 
/bin/foo ", " /etc/foo ", и так далее. Первый из этих файлов, 
который существует - будет выполнен.
<BLOCKQUOTE><CODE>
<PRE>
       TERM
</PRE>
</CODE></BLOCKQUOTE>

Определяет вид терминала, который получает вывод программы.
Некоторые программы могут использовать эту информацию, чтобы 
пользоваться преимуществом специальных escape-последовательностей 
или режимов терминала, обеспечиваемых специфическими видами 
терминалов. Многие программы, которые используют termcap библиотеку 
(см. раздел " Поиск Описания Терминала " в Библиотечном Руководстве 
Termcap) использует переменную среды TERM.
<BLOCKQUOTE><CODE>
<PRE>
       TZ
</PRE>
</CODE></BLOCKQUOTE>

Определяет часовой пояс. См. Раздел 17.2.5 [Переменная TZ],
для уточнения инфрмации относительно формата этой строки и как она 
используется.
<BLOCKQUOTE><CODE>
<PRE>
       LANG
</PRE>
</CODE></BLOCKQUOTE>

Определяет заданный по умолчанию стандарт, используемый для
категорий атрибутов, если ни LC_ALL ни специфическая переменная 
среды для этого класса не установлены. См. Главу 19 [Стандарты], 
для получения более подробной информации.
<BLOCKQUOTE><CODE>
<PRE>
       LC_COLLATE
</PRE>
</CODE></BLOCKQUOTE>

Определяет какой стандарт использовать для строковой
сортировки.
<BLOCKQUOTE><CODE>
<PRE>
       LC_CTYPE
</PRE>
</CODE></BLOCKQUOTE>

Определяет какой стандарт использовать для символьных
наборов и символьной классификации.
<BLOCKQUOTE><CODE>
<PRE>
       LC_MONETARY
</PRE>
</CODE></BLOCKQUOTE>

Определяет какой стандарт использовать для форматирования
валютных значений.
<BLOCKQUOTE><CODE>
<PRE>
       LC_NUMERIC
</PRE>
</CODE></BLOCKQUOTE>

Определяет какой стандарт использовать для форматирования
чисел.
<BLOCKQUOTE><CODE>
<PRE>
       LC_TIME
</PRE>
</CODE></BLOCKQUOTE>

Определяет то, какой стандарт использовать для
форматирования даты/времени.
<BLOCKQUOTE><CODE>
<PRE>
       _POSIX_OPTION_ORDER
</PRE>
</CODE></BLOCKQUOTE>

Если эта переменная среды определена, она подавляет обычное 
переупорядочение аргументов командной строки getopt. См. Раздел 
22.1.1 [Синтаксис Аргумента].
<P>
<H2><A NAME="ss22.3">22.3 Завершение Программы</A>
</H2>

<P>
<P>
<P>Обычный способ завершения программы - просто возврат функции 
main. Значение состояния выхода, возвращенное из функции main 
используется, чтобы сообщить информацию обратно родительскому 
процессу или оболочке.
<P>Программа может также завершаться вызывая функцию exit.
<P>Кроме того, программы могут быть завершены сигналами; это 
обсуждено более подробно в Главе 21 [Обработка Сигналов]. Функция 
abort вызывает сигнал, который уничтожает программу.
<P>
<P>
<P>
<H3>Нормальное Окончание</H3>

<P>
<P>
<P>Процесс завершается обычно, когда программа вызывает exit. 
Возвращение из main эквивалентно вызову exit, и значение, которое 
main возвращает, используется как аргумент exit.
<P>
<BLOCKQUOTE><CODE>
<PRE>
       void exit (int status)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция exit завершает процесс с состоянием status. Эта функция 
не возвращается.
<P>Нормальное окончание вызывает следующие действия:
<OL>
<LI>        Функции, которые были зарегистрированы с atexit или on_exit 
функциями, вызываются в обратном порядке их регистрации. Этот 
механизм позволяет вашему приложению определять собственные 
действия "очистки", которые нужно выполнить по окончании программы. 
Обычно, это используется, чтобы делать вещи подобно сохранению 
информации о состоянии программы в файле, или размыкании блокировок 
в базах общих данных.</LI>
<LI>        Все открытые потоки будут закрыты. См. Раздел 7.4 [Закрытие 
Потоков]. Кроме того, временные файлы, открытые с tmpfile функцией 
будут удалены; см. Раздел 9.10 [Временные Файлы].</LI>
<LI>        _exit вызывается, завершая программу. См. Раздел 22.3.5 
[Внутренняя организация Окончания].</LI>
</OL>
<H3>Состояние Выхода</H3>

<P>
<P>
<P>Когда программа выходит, она может возвращать родительскому 
процессу малое количество информации относительно причины 
окончания, используя состояние exit. Это - значение между 0 и 255, 
которое выходящий процесс передает как аргумент exit.
<P>Обычно Вы должны использовать состояние exit, чтобы сообщить 
очень широкую информацию относительно успеха или отказа. Вы не 
можете обеспечивать множество подробностей относительно причин для 
отказа, да и большинство родительских процессов не требуют много 
подробностей.
<P>Имеются соглашения для того, что некоторые программы должны 
возвратить. Наиболее общее соглашение - просто 0 для успеха и 1 для 
отказа. Программы, которые выполняют сравнение, используют другое 
соглашение: они используют состояние, 1, чтобы указать 
несоответствие, и состояние 2, чтобы указать неспособность 
сравнить. Ваша программа должна следовать за существующим 
соглашением, если существующее соглашение имеет смысл для нее.
<P>Общее соглашение резервирует значения 128 состояний и более для 
специальных целей. В частности значение 128 используется, чтобы 
указать отказ выполнить другую программу в подпроцессе. Это 
соглашение не удовлетворяет унивверсальным условиям, но неплохо 
следовать за ним в ваших программах.
<P>Предупреждение: Не пробуйте использовать число ошибок как 
состояние exit. Это фактически не очень полезно; родительский 
процесс вообще не должен заботиться, сколько ошибок произошло. К 
тому же значение состояния усекается до восьми бит. Таким образом, 
если программа пробовала передать 256, родитель получит 0 шибок 
т.е. успех.
<P>По той же самой причине не работает использование значения
errno как состояния exit.
<P>Примечание Переносимости: Некоторые не-posix системы используют 
различные соглашения для значений состояния exit. Для большей 
переносимости, Вы можете использовать макрокоманды EXIT_SUCCESS и 
EXIT_FAILURE для стандартного значения состояния успеха и
отказа, соответственно. Они объявлены в файле " stdlib.h ".
<BLOCKQUOTE><CODE>
<PRE>
       int EXIT_SUCCESS  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Эта макрокоманда может использоваться с функцией exit, чтобы 
указать успешное завершение программы.
<P>На системах POSIX, значение этой макрокоманды - 0. В других
системах, значение может быть другим (возможно не-константа) 
целочисленным выражением.
<BLOCKQUOTE><CODE>
<PRE>
       int EXIT_FAILURE  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Эта макрокоманда может использоваться с функцией exit, чтобы 
указать неудачное завершение программы в общем смысле.
<P>На системах POSIX, значение этой макрокоманды 1. На других 
системах, значение может быть другим. 
<P>
<P>
<P>
<P>
<P>
<P>
<H3>Очистки на Выходе</H3>

<P>
<P>
<P>Ваша программа может выполнить собственные функции очистки
при нормальное окончании. Ненадежно вызывать функции очистки
явно перед выходом. Намного лучше делать очистку невидимой для 
приложения, устанавливая функцию очистки используя atexit или 
on_exit.
<BLOCKQUOTE><CODE>
<PRE>
       int atexit (void (*function) (void))  (функция)
</PRE>
</CODE></BLOCKQUOTE>
       Atexit функция регистрирует функцию function, которую нужно 
вызвать при нормальном окончании программы. Функция вызывается без 
аргументов.
<P>Возвращаемое значение из atexit - нуль при успехе и отличное от 
нуля, если функция не может быть зарегистрирована.
<BLOCKQUOTE><CODE>
<PRE>
       int on_exit (void (*function)(int status, void *arg), void *arg)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция - несколько более мощный вариант atexit. Она 
принимает два аргумента, функцию и произвольный указатель. При 
нормальном окончании программы, функция вызывается с двумя 
аргументами: значением состояния, переданным exit, и параметром 
arg.
<P>Эта функция включена в библиотеку GNU C только для совместимости 
с SunOS, и может не обеспечиваться другими реализациями.
<P>Имеется тривиальная программа, которая иллюстрирует 
использование exit и atexit: 
<BLOCKQUOTE><CODE>
<PRE>
                        #include &lt;stdio.h&gt;
                        #include &lt;stdlib.h&gt;
                        void
                        bye (void)
                        {
                                puts ("Goodbye, cruel world....");
                        }
                        int
                        main (void)
                        {
                                atexit (bye);
                                exit (EXIT_SUCCESS);
                        }
</PRE>
</CODE></BLOCKQUOTE>

Когда эта программа выполнена, она печатает сообщение и выходит.
<P>
<H3>Прерывание выполнения Программы</H3>

<P>
<P>
<P>Вы можете прервать вашу программу, используя функцию abort. 
Прототип для этой функции находится в " stdlib.h ".
<BLOCKQUOTE><CODE>
<PRE>
       void abort (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция abort вызывает аварийное окончание программы. Она не 
выполняет функции очистки, зарегистрированные с atexit или on_exit.
<P>Эта функция фактически завершает процесс,  вызывая сигнал 
SIGABRT, и ваша программа может включать обработчик, чтобы прервать 
этот сигнал; см. Главу 21 [Обработка Сигнала].
<P>
<P>
<H3>Внутренняя организация Окончания</H3>

<P>
<P>
<P>Функция _exit - примитив, используемый для окончания процесса 
exit. Она объявлена в заглавном файле " unistd.h ".
<BLOCKQUOTE><CODE>
<PRE>
       void _exit (int status)  (функция)
</PRE>
</CODE></BLOCKQUOTE>
      _exit - функция для завершения процесса с состоянием status. 
Вызов этой функции не выполняет функции очистки, зарегистрированные 
с atexit или on_exit.
<P>Когда процесс завершается по любой причине либо явным запросом 
окончания, либо окончанием в результате сигнала, производятся
следующие действия:
<UL>
<LI>       Все описатели открытого файла в процессе будут закрыты. См. 
Главу 8 [Ввод - вывод низкого уровня].</LI>
<LI>        8 битов младшего разряда возвращающегося кода состояния 
сохранены, для передачи родительскому процессу
через wait или waitpid; см. Раздел 23.6 [Завершение Процесса].</LI>
<LI>        Любым дочерним процессам завершаемого процесса будет назначен 
новый родительский процесс. (Это - init процесс, с ID процесса 1.)</LI>
<LI>        Сигнал SIGCHLD послан родительскому процессу.</LI>
<LI>        Если, процесс является лидером сеанса, который контролировал 
терминал управления, то сигнал SIGHUP будет послан каждому процессу 
в приоритетной работе, и терминал управления - будет отсоединен от
этого сеанса. См. Главу 24 [Управление заданиями].</LI>
<LI>        Если окончание процесса останавлвает любой элемент группы 
этого процесса, то сигнал SIGHUP и сигнал SIGCONT будет послан 
каждому процессу в группе. См. Главу 24 [Управление заданиями].</LI>
</UL>
<P>
<HR>
<A HREF="glibc-23.html">Вперед</A>
<A HREF="glibc-21.html">Назад</A>
<A HREF="glibc.html#toc22">Содержание</A>

<!--htdig_noindex-->
<noindex>
<br>

<table id=ibm_adv align=center><tr valign=top><td width="605">
<iframe src="http://www.opennet.ru/adv_lc.html" height="240" width="605" scrolling="no" name="ibm" border="0" frameborder="0" target="_blank" marginheight="0" marginwidth="0"></iframe>
</td></tr></table>
</noindex>
<!--/htdig_noindex-->


<!-- footer -->
<!--htdig_noindex-->
<br>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=1 WIDTH="100%" BGCOLOR="#B0B190">
<TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" VALIGN="MIDDLE">
<TR>
<TD WIDTH="35%" BGCOLOR="#E9EAD6" ALIGN=LEFT>
<FONT SIZE="-1">
&nbsp;&nbsp;<A HREF="http://www.opennet.ru/cgi-bin/opennet/bookmark.cgi">Закладки&nbsp;на&nbsp;сайте</A><BR>
&nbsp;&nbsp;<A HREF="http://www.opennet.ru/cgi-bin/opennet/bookmark.cgi?submit=add" target="blank_">Проследить&nbsp;за&nbsp;страницей</A>
</FONT>
</TD>
<TD WIDTH="65%" ALIGN=RIGHT BGCOLOR="#E9EAD6">
<FONT SIZE="-1">Created&nbsp;1996-2014&nbsp;by&nbsp;<B><A HREF="http://www.opennet.ru/contact.shtml" title="email mc@tyumen.ru">Maxim&nbsp;Chirkov</A></B></FONT>&nbsp;&nbsp;<BR>
<FONT SIZE="-1"><A HREF="http://www.opennet.ru/add.shtml">Добавить</A>,&nbsp;<A HREF="http://www.opennet.ru/reklama.shtml">Реклама</A>,&nbsp;<A HREF="http://www.opennet.ru/banners2.shtml">Вебмастеру</A>,&nbsp;<A HREF="http://www.opennet.ru/guide.shtml">ГИД</A></FONT>&nbsp;&nbsp;
</TD>
</TR>
</TABLE>
</TD></TR>
</TABLE>


<div align=right><table><tr><td>
<a target=_blank href="http://www.runnet.ru"><img src="http://www.opennet.ru/img/runnet.gif" border=0 height=31 width=88 alt="RUNNet"></a>
<a target=_blank href="http://top.list.ru/jump?from=77689"><img src="http://top.list.ru/counter?id=77689;t=75;l=1" border=0 height=31 width=38 alt="TopList"></a>
<script type="text/javascript"><!--
document.write("<a href='http://www.liveinternet.ru/click' "+
"target=_blank><img src='//counter.yadro.ru/hit?t45.6;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+
"' alt='' title='LiveInternet' "+
"border='0' width='31' height='31'><\/a>")
//--></script>
<a target=_blank href="http://counter.rambler.ru/top100/"><img src="http://counter.rambler.ru/top100.cnt?10566" width=1 height=1 border=0><img src="http://www.opennet.ru/banner.gif" width=88 height=31 border=0></a>
</td></tr></table>
</div>
</form>
<!--/htdig_noindex-->
<!-- end of footer -->

</BODY>
</HTML>
