<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru"> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <meta name="keywords" content="Common Lisp,lisp,лисп" /> <title>ООП: Обобщенные функции</title> <link href="../css/style.css" rel="stylesheet" type="text/css" /><link href="../css/colorize.css" rel="stylesheet" type="text/css" />  </head> <body> <div class="top"> <div id="login"> <a href="http://lisper.ru/register">Регистрация</a> | <a href="http://lisper.ru/login?done=/pcl/object-reorientation-generic-functions">Войти</a> </div> </div> <div id="caution"> <img alt="Lisp — программируемый язык программирования" src="../image/gecko.png" /> <a href="http://www.vkusnoserver.ru/" target="_blank" style="float: right;"> <img src="../vkusnoserver.png" /> </a> </div> <div id="mainmenu"> <ul> <li> <a href="http://lisper.ru/">Главная</a> </li><li> <a href="http://lisper.ru/articles/">Статьи</a> </li><li> <a href="http://lisper.ru/planet/">Планета</a> </li><li> <a href="http://lisper.ru/forum/">Форум</a> </li><li> <a href="http://lisper.ru/apps/">Сервисы</a> </li><li> <a href="index.html">Practical Common Lisp</a> </li><li> <a href="http://lisper.ru/wiki/">Wiki</a> </li><li> <a href="http://lisper.ru/files/">Файлы</a> </li><li> <a href="http://lisper.ru/search">Поиск</a> </li> </ul> </div> <div id="content"> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="practical-a-portable-pathname-library">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right"> <a href="object-reorientation-classes">Следующая</a> </td> </tr> </tbody> </table> <div class="article"><div class="toc"><div class="toc-header">Содержание</div><div class="toc-body"><ul><li><div><a href="object-reorientation-generic-functions#16. &#x41F;&#x435;&#x440;&#x435;&#x445;&#x43E;&#x434;&#x438;&#x43C; &#x43A; &#x43E;&#x431;&#x44A;&#x435;&#x43A;&#x442;&#x430;&#x43C;: &#x41E;&#x431;&#x43E;&#x431;&#x449;&#x435;&#x43D;&#x43D;&#x44B;&#x435; &#x444;&#x443;&#x43D;&#x43A;&#x446;&#x438;&#x438;">16. Переходим к объектам: Обобщенные функции</a><ul><li><div><a href="object-reorientation-generic-functions#&#x41E;&#x431;&#x43E;&#x431;&#x449;&#x435;&#x43D;&#x43D;&#x44B;&#x435; &#x444;&#x443;&#x43D;&#x43A;&#x446;&#x438;&#x438; &#x438; &#x43A;&#x43B;&#x430;&#x441;&#x441;&#x44B;">Обобщенные функции и классы</a></div></li><li><div><a href="object-reorientation-generic-functions#&#x41E;&#x431;&#x43E;&#x431;&#x449;&#x435;&#x43D;&#x43D;&#x44B;&#x435; &#x444;&#x443;&#x43D;&#x43A;&#x446;&#x438;&#x438; &#x438; &#x43C;&#x435;&#x442;&#x43E;&#x434;&#x44B;">Обобщенные функции и методы</a></div></li><li><div><a href="object-reorientation-generic-functions#DEFGENERIC">DEFGENERIC</a></div></li><li><div><a href="object-reorientation-generic-functions#DEFMETHOD">DEFMETHOD</a></div></li><li><div><a href="object-reorientation-generic-functions#&#x41A;&#x43E;&#x43C;&#x431;&#x438;&#x43D;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435; &#x43C;&#x435;&#x442;&#x43E;&#x434;&#x43E;&#x432;">Комбинирование методов</a></div></li><li><div><a href="object-reorientation-generic-functions#&#x421;&#x442;&#x430;&#x43D;&#x434;&#x430;&#x440;&#x442;&#x43D;&#x44B;&#x439; &#x43A;&#x43E;&#x43C;&#x431;&#x438;&#x43D;&#x430;&#x442;&#x43E;&#x440; &#x43C;&#x435;&#x442;&#x43E;&#x434;&#x43E;&#x432;">Стандартный комбинатор методов</a></div></li><li><div><a href="object-reorientation-generic-functions#&#x414;&#x440;&#x443;&#x433;&#x438;&#x435; &#x43A;&#x43E;&#x43C;&#x431;&#x438;&#x43D;&#x430;&#x442;&#x43E;&#x440;&#x44B; &#x43C;&#x435;&#x442;&#x43E;&#x434;&#x43E;&#x432;">Другие комбинаторы методов</a></div></li><li><div><a href="object-reorientation-generic-functions#&#x41C;&#x443;&#x43B;&#x44C;&#x442;&#x438;&#x43C;&#x435;&#x442;&#x43E;&#x434;&#x44B;">Мультиметоды</a><ul><li><div><a href="object-reorientation-generic-functions#&#x41C;&#x443;&#x43B;&#x44C;&#x442;&#x438;&#x43C;&#x435;&#x442;&#x43E;&#x434;&#x44B; &#x43F;&#x440;&#x43E;&#x442;&#x438;&#x432; &#x43F;&#x435;&#x440;&#x435;&#x433;&#x440;&#x443;&#x437;&#x43A;&#x438; &#x43C;&#x435;&#x442;&#x43E;&#x434;&#x43E;&#x432;">Мультиметоды против перегрузки методов</a></div></li></ul></div></li><li><div><a href="object-reorientation-generic-functions#&#x41F;&#x440;&#x43E;&#x434;&#x43E;&#x43B;&#x436;&#x435;&#x43D;&#x438;&#x435; &#x441;&#x43B;&#x435;&#x434;&#x443;&#x435;&#x442; ...">Продолжение следует ...</a></div></li></ul></div></li></ul></div></div>
<div class="chapter" id="16. &#x41F;&#x435;&#x440;&#x435;&#x445;&#x43E;&#x434;&#x438;&#x43C; &#x43A; &#x43E;&#x431;&#x44A;&#x435;&#x43A;&#x442;&#x430;&#x43C;: &#x41E;&#x431;&#x43E;&#x431;&#x449;&#x435;&#x43D;&#x43D;&#x44B;&#x435; &#x444;&#x443;&#x43D;&#x43A;&#x446;&#x438;&#x438;"><h3>16. Переходим к объектам: Обобщенные функции</h3>

<p>Поскольку Lisp был создан за 
пару десятилетий до того момента, когда
объектно-ориентированное программирование (ООП) стало популярным<a class="fn_top" id="fnt__1" href="object-reorientation-generic-functions#fn__1">1)</a>, начинающие Lisp-программисты иногда удивляются, открывая для себя, 
насколько полноценным объектно-ориентированным языком является Common Lisp.  Непосредственные его предшественники
разрабатывались в то время, когда объектно-ориентированное программирование было волнующе-новой парадигмой и проводилось много
экспериментов на тему включения его идей (особенно из языка Smalltalk) в Lisp.
Как часть процесса стандартизации Common Lisp, объединение идей нескольких этих экспериментов было представлено под названием Common Lisp Object System (Объектная Система Common Lisp) или CLOS<a class="fn_top" id="fnt__2" href="object-reorientation-generic-functions#fn__2">2)</a>. Стандарт ANSI включил CLOS в язык, так что сейчас нет смысла 
говорить о CLOS как об отдельной сущности.
</p>
<p>Возможности CLOS внесенные в Common Lisp варьируются от тех, 
без которых крайне тяжело обойтись, до относительно эзотеричных проявлений философии Lisp как язык-инструмента для построения языков.  Полный обзор всех возможностей лежит за пределами данной книги, но в этой и
следующей главе я опишу базовые 
возможности и дам обзор подхода Common Lisp к
объектам.
</p>
<p>В начале вы должны были заметить, что объектная система Common Lisp предлагает достаточно
отличающуюся от других языков реализацию принципов ООП. Если вы имеете глубокое понимание
фундаментальных идей, заложенных в основу ООП, то вы, вероятно, оцените способ, который
использовался в Common Lisp для их реализации.  С другой стороны, если у вас есть
опыт использования ООП только на одном языке, то подход Common Lisp может показаться вам
несколько чуждым; вы должны избегать предположений, что для 
языка существует
только один способ реализации принципов ООП<a class="fn_top" id="fnt__3" href="object-reorientation-generic-functions#fn__3">3)</a>.  Если у вас имеется
небольшой опыт 
объектно-ориентированного программирования, то вы не должны 
испытывать проблем с пониманием изложенных здесь объяснений, хотя, в этом случае, возможно, будет лучше
проигнорировать сравнения с подходами других языков.
</p><div class="chapter" id="&#x41E;&#x431;&#x43E;&#x431;&#x449;&#x435;&#x43D;&#x43D;&#x44B;&#x435; &#x444;&#x443;&#x43D;&#x43A;&#x446;&#x438;&#x438; &#x438; &#x43A;&#x43B;&#x430;&#x441;&#x441;&#x44B;"><h3>Обобщенные функции и классы</h3>

<p>Мощной и фундаментальной особенностью ООП является способ организации программ путем
определения типов данных и связывании операций с ними.  В частности, вам может
понадобиться возможность исполнять операцию, получая поведение, определенное типом
объекта (или объектов) для которых эта операция выполняется. Классическим примером, представленным во всех введениях в ООП, является операция рисования, применимая к
объектам, представляющим различные геометрические фигуры.  Для рисования окружностей,
треугольников или квадратов могут быть реализованы разные методы draw, которые будут
отображать окружность, треугольник или квадрат, в зависимости от объекта, к которому
применяется операция рисования. Эти реализации вводятся
раздельно, и новые версии для рисования других фигур могут быть определены, не затрагивая ни
кода базового класса, ни других draw.
Эта возможность ООП имеет красивое
греческое имя <em>"полиморфизм (polymorphism)"</em>, переводимое как "множество форм", поскольку одна
концептуальная операция, такая как рисование объекта, может иметь множество различных
конкретных форм.
</p>
<p>Common Lisp, подобно другим современным объектно-ориентированным языкам, основан на
классах; все объекты являются экземплярами определенного 
класса<a class="fn_top" id="fnt__4" href="object-reorientation-generic-functions#fn__4">4)</a>.   
Класс объекта определяет его
представление – встроенные классы, такие как  <code>NUMBER</code> и <code>STRING</code> имеют скрытое
представление, доступное только через стандартные функции для работы с этими типами, в то
время как экземпляры классов, определенных пользователем, состоят из именованных частей,
называемых слотами (вы увидите это в следующей главе).
</p>
<p>Классы образуют иерархию/классификацию всех объектов.  Класс может быть определен как
подкласс других классов, называемых базовыми (или суперклассами).  Класс наследует от
суперклассов часть своего определения, а экземпляры класса также считаются и экземплярами
суперклассов.  В Common Lisp иерархия классов имеет один корень – класс <code>T</code>, который
является прямым (или косвенным) суперклассом для всех остальных классов.  Таким образом, в
Common Lisp все данные являются экземплярами класса <code>T</code><a class="fn_top" id="fnt__5" href="object-reorientation-generic-functions#fn__5">5)</a>.  Common Lisp также поддерживает
множественное наследование – один класс может иметь несколько прямых суперклассов.
</p>
<p>Вне семейства языков Lisp, почти все объектно-ориентированные языки следуют базовому
дизайну, заданному языком Simula, когда поведение, связанное с классом, реализуется в виде
методов или функций-членов, которые относятся к определенному классу.  В этих языках
метод, вызываемый для определенного объекта, и класс, к которому этот объект относится,
определяют, какой код будет запущен.  Такая модель называется (в
терминологии Smalltalk) передачей сообщений (message-passing).  Концептуально, вызов
методов начинается с отправки сообщения, содержащего
имя запускаемого метода и необходимые аргументы, экземпляру объекта, метод которого вызывается.
Объект затем использует свой класс для поиска метода, связанного с именем,
указанным в сообщении, и вызывает его.  Поскольку каждый класс может иметь собственный
метод для заданного имени, то одно и то же сообщение, посланное разным объектам, может вызывать разные методы.
</p>
<p>Ранние реализации объектной системы Lisp работали аналогичным образом, предоставляя
специальную функцию <code>SEND</code>, которая могла быть использована для отправки сообщения
определенному объекту.  Однако, это было не совсем удобно, поскольку это делало вызов
метода отличным от обычного вызова функции.  Синтаксически вызов метода записывался как:
</p>
<pre class="code"><span class="paren1">(<span class="">send object 'foo</span>)</span><br/></pre>

<p>вместо:
</p>
<pre class="code"><span class="paren1">(<span class="">foo object</span>)</span><br/></pre>

<p>Более важным являлось то, что поскольку методы не являлись функциями, то они не могли быть
переданы как аргументы для функций высшего порядка, таких как <code>MAPCAR</code>; если кто-то
хотел вызвать метод для всех элементов списка, используя <code>MAPCAR</code>, то он должен был
писать вот так:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mapc_.htm" class="symbol">mapcar</a> #'<span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren3">(<span class="">object</span>)</span> <span class="paren3">(<span class="">send object 'foo</span>)</span></span>)</span> objects</span>)</span><br/></pre>

<p>вместо:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mapc_.htm" class="symbol">mapcar</a> #'foo objects</span>)</span><br/></pre>

<p>В конечном счете, люди, работавшие над объектными системами Lisp, унифицировали методы и
функции путём введения нового их вида, называемого обобщенным (generic).  В дополнение к решению описанных выше проблем,
обобщенные функции открыли новые
возможности объектной системы, включая множество таких, которые попросту не имели
смысла в объектных системах с передачей сообщений.
</p>
<p>Обобщенные функции суть сердце объектной системы Common Lisp и тема оставшейся части данной главы.  
Несмотря на то, что я не могу говорить об обобщенных функциях без упоминания
классов, сначала я остановлюсь на том, как определить и использовать обобщенные
функции.  А в следующей главе я покажу вам как определять ваши собственные классы.
</p>




</div><div class="chapter" id="&#x41E;&#x431;&#x43E;&#x431;&#x449;&#x435;&#x43D;&#x43D;&#x44B;&#x435; &#x444;&#x443;&#x43D;&#x43A;&#x446;&#x438;&#x438; &#x438; &#x43C;&#x435;&#x442;&#x43E;&#x434;&#x44B;"><h3>Обобщенные функции и методы</h3>

<p>Обобщенная функция определяет абстрактную операцию, указывая имя операции и список
параметров, но не определяет реализацию.  Вот, например, как вы можете определить
обобщенную функцию <code>draw</code>, которая будет использоваться для отрисовки различных фигур на
экране:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defgen.htm" class="symbol"><i><span class="symbol">defgeneric</span></i></a> draw <span class="paren2">(<span class="">shape</span>)</span><br/>  <span class="paren2">(<span class=""><span class="keyword">:documentation</span> <span class="string">"Draw the given shape on the screen."</span></span>)</span></span>)</span><br/></pre>

<p>Я опишу синтаксис <code>DEFGENERIC</code> в следующем разделе; сейчас лишь замечу,
что это определение совсем не содержит кода.
</p>
<p>Обобщенная функция являются таковой в том смысле, что она может (по крайней мере в
теории) принимать в качестве аргументов любые объекты<a class="fn_top" id="fnt__6" href="object-reorientation-generic-functions#fn__6">6)</a>.  Однако
сама эта функция не делает ничего; если вы просто определили её, то
при вызове с любыми аргументами она будет выдавать ошибку. Действующая реализация
обобщенной функции обеспечивается методами. Каждый метод предоставляет реализацию обобщенной функции для отдельных классов аргументов.  
Вероятно, наибольшим отличием между системами с
обобщенными функциями и системами с передачей сообщений является то, что методы не принадлежат к классам; они относятся к обобщенной функции, 
которая ответственна за
определение того, какой метод (или методы) будет исполняться в ответ на конкретный вызов.
</p>
<p>Методы указывают, какой вид аргументов они могут обрабатывать путем специализации
требуемых параметров, определенных обобщенной функцией.  Например, для обобщенной функции
<code>draw</code> вы можете определить один метод, который определяет специализацию параметра
<code>shape</code> для объектов, которые являются экземплярами класса <code>circle</code>, 
в то время как другой метод специализирует <code>shape</code> для экземпляров класса <code>triangle</code>.  Они могут выглядеть следующим
образом (не вдаваясь в подробности рисования конкретных фигур):
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> draw <span class="paren2">(<span class=""><span class="paren3">(<span class="">shape circle</span>)</span></span>)</span><br/>  ...</span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> draw <span class="paren2">(<span class=""><span class="paren3">(<span class="">shape triangle</span>)</span></span>)</span><br/>  ...</span>)</span><br/></pre>

<p>При вызове обобщенной функции, она сравнивает переданные аргументы со специализаторами каждого из ее методов с целью найти среди них апплицируемые – чьи специализаторы совместимы с фактическими параметрами (вызова). Если вы вызываете <code>draw</code>, передавая экземпляр <code>circle</code>, то
применяется метод, который специализирует <code>shape</code> для класса <code>circle</code>, а если вы
вызываете передавая <code>triangle</code>, то будет вызван метод, который специализирует <code>shape</code>
для <code>triangle</code>.  В простых случаях будет подходить только один метод, который и будет обрабатывать вызов.  В более сложных случаях могут быть применимы несколько
методов; они будут скомбинированы, как я опишу в разделе "Комбинация методов", в
один действующий метод, который обработает данный вызов.
</p>
<p>Вы можете специализировать параметры двумя способами – обычно вы указываете класс,
экземпляром которого должен быть аргумент.  Поскольку экземпляры класса также
рассматриваются как экземпляры его суперклассов, то метод, специализированный для
конкретного класса, также применим для аргументов, которые могут быть как экземлярами специализирующего класса, так и его подклассов.
Другой вид специализации – так называемый <code>EQL</code>-специализатор, который определяет
конкретный объект к которому применим данный метод.
</p>
<p>Когда обобщенная функция имеет только методы, специализированные для одного параметра, и
все специализации являются специализациями классов, то результат вызова обобщенной функции
сильно похож на вызов метода в системе с передачей сообщений – комбинация имени операции
и класса объекта, для которого она вызывается, определяет, какой метод будет вызван.
</p>
<p>Однако изменение порядка поиска открывает новые возможности, которых нет в системах с
передачей сообщений.  Обобщенные функции поддерживают методы, которые специализируются для
множества параметров, предоставляя каркас, который делает множественное наследование более
управляемым, и который позволяет вам использовать декларативные конструкции для контроля
того, как методы комбинируются в эффективный метод, поддерживая несколько общих методов
использования без наличия кучи дополнительного кода. Я опишу эти вопросы очень скоро.  
Но сначала вам необходимо взглянуть на основы использования
двух макросов, которые используются для определения обобщенных функций: <code>DEFGENERIC</code> и
<code>DEFMETHOD</code>.
</p>



</div><div class="chapter" id="DEFGENERIC"><h3>DEFGENERIC</h3>

<p>Чтобы дать вам почувствовать эти макросы, и ознакомиться с возможностями, которые они
предоставляют, я покажу вам некоторый код, который вы могли бы написать как часть
банковского приложения, или иначе, игрушечное банковское приложение; главная задача –
ознакомиться с возможностями языка, а не научиться писать банковское программное
обеспечение.  Например, данный код даже не пытается претендовать на работу с разными
валютами, а также оставляет в стороне вопросы аудита и целостности транзакций.
</p>
<p>Поскольку я буду обсуждать вопросы создания новых классов только в следующей главе, сейчас вы можете просто предположить, 
что определенные классы уже существуют: для начала предположим, имеется класс <code>bank-account</code> и он имеет два подкласса –
<code>checking-account</code> и <code>savings-account</code>.  Иерархия классов выглядит следующим образом:<br/> 
<img alt="&#x418;&#x437;&#x43E;&#x431;&#x440;&#x430;&#x436;&#x435;&#x43D;&#x438;&#x435;" src="http://lisper.ru/pcl/:pcl:account-hierarchy_1_.png"/>
</p>
<p>Первой обобщенной функцией будет <code>withdraw</code>, которая уменьшает баланс на
указанную сумму.  Если баланс меньше этой суммы, то она должна выдать ошибку и
оставить баланс в неизменном виде.  Вы можете начать с определения обобщенной функции при
помощи <code>DEFGENERIC</code>.
</p>
<p>Основная форма <code>DEFGENERIC</code> похожа на <code>DEFUN</code>, за тем исключением, что нет тела функции.
Список параметров <code>DEFGENERIC</code> определяет параметры, которые должны приниматься всеми
методами, определенными для данной обобщенной функции.  Вместо тела <code>DEFGENERIC</code> может
содержать различные опции.  Одной из опций, которую вы должны всегда указывать, является
<code>:documentation</code>, которая используется для указания строки с описанием назначения обобщенной
функции.  Поскольку обобщенная функция является полностью абстрактной, важно, чтобы и
пользователь и программист имели четкое представление о том, что она делает.  Таким
образом, вы можете определить <code>withdraw</code> следующим образом:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defgen.htm" class="symbol"><i><span class="symbol">defgeneric</span></i></a> withdraw <span class="paren2">(<span class="">account amount</span>)</span><br/>  <span class="paren2">(<span class=""><span class="keyword">:documentation</span> <span class="string">"Withdraw the specified amount from the account.<br/>Signal an error if the current balance is less than amount."</span></span>)</span></span>)</span><br/></pre>







</div><div class="chapter" id="DEFMETHOD"><h3>DEFMETHOD</h3>

<p>Сейчас вы готовы к использованию <code>DEFMETHOD</code> для определения методов, которые реализуют
<code>withdraw</code><a class="fn_top" id="fnt__7" href="object-reorientation-generic-functions#fn__7">7)</a>.
</p>
<p>Список параметров метода должен быть конгруэнтен его обобщенной
функции.  В данном случае это означает, что все методы определенные для <code>withdraw</code>
должны иметь два обязательных параметра.  В более общих чертах, методы должны иметь то же самое
количество обязательных и необязательных параметров, и кроме этого, должны уметь принимать
любые аргументы, относящиеся к остаточным (<code>&amp;rest</code>) или именованным (<code>&amp;key</code>)
параметрам, определенным в обобщенной функции.<a class="fn_top" id="fnt__8" href="object-reorientation-generic-functions#fn__8">8)</a>
</p>
<p>Поскольку базовые действия по списанию денег со счета являются одинаковыми для всех
счетов, то вы можете определить метод, который специализирует параметр <code>account</code> для
класса <code>bank-account</code>.  Вы можете предположить, что функция <code>balance</code> возвращает
текущее значение суммы на счете и может быть использована вместе с функцией <code>SETF</code> (и
таким образом, вместе с <code>DECF</code>) для установки значения баланса.  Функция <code>ERROR</code>
является стандартной функцией для сообщения об ошибках и я ее подробно опишу в главе
19.  Используя эти две функции, вы можете определить основной метод <code>withdraw</code> примерно
так:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> withdraw <span class="paren2">(<span class=""><span class="paren3">(<span class="">account bank-account</span>)</span> amount</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="paren3">(<span class="">&lt; <span class="paren4">(<span class="">balance account</span>)</span> amount</span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_error.htm" class="symbol">error</a> <span class="string">"Account overdrawn."</span></span>)</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_incf_.htm" class="symbol">decf</a> <span class="paren3">(<span class="">balance account</span>)</span> amount</span>)</span></span>)</span><br/></pre>

<p>Как видно из этого кода, форма <code>DEFMETHOD</code> более похожа на <code>DEFUN</code> по сравнению с
<code>DEFGENERIC</code>.  Основным отличием является то, что требуемые параметры могут быть
специализированы путем замены имени параметра на список из двух элементов.  Первым
элементом является имя параметра, а вторым – специализатор, который может быть либо
именем класса, либо <code>EQL</code>-специализатором, форму которого я опишу чуть позже.  Имя
параметра может быть любым – оно не обязательно должно совпадать с именем, указанным в
объявлении обобщенной функции, несмотря на то, что чаще всего они совпадают.
</p>
<p>Этот метод будет использоваться тогда, когда первый аргумент <code>withdraw</code> является
экземпляром класса <code>bank-account</code>.  Второй параметр, <code>amount</code>, неявно специализируется
для класса <code>T</code>, а поскольку все объекты являются экземплярами <code>T</code>, это никак не
затрагивает применимость метода.
</p>
<p>Теперь предположим, что все чековые счета имеют защиту от перерасхода.  Так что, каждый
чековый счет связан с другим счетом в банке, с которого будет производиться списание,
когда на чековом счету недостаточно денег для списания.  Вы можете предположить, что
функция <code>overdraft-account</code> получает объект класса <code>checking-account</code> и возвращает
объект класса <code>bank-account</code>, представляющего собой связанный счет.
</p>
<p>Таким образом, списание с объекта класса <code>checking-account</code> требует выполнения
дополнительных шагов в сравнении со списанием с обычного объекта <code>bank-account</code>.  
Сначала вы должны проверить, является ли списываемая сумма большей, чем имеющаяся на счету, и если это так,
то перенести недостающую сумму со связанного счета.  Затем вы можете продолжать
так же, как и с обычным объектом <code>bank-account</code>.
</p>
<p>Так что вы можете захотеть определить метод <code>withdraw</code>, специализированного для
<code>checking-account</code> для обработки перевода денег с другого счета и последующей передачи
управления методу, специализированного для <code>bank-account</code>.
Такой метод может выглядеть вот так:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> withdraw <span class="paren2">(<span class=""><span class="paren3">(<span class="">account checking-account</span>)</span> amount</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">overdraft <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a__.htm" class="symbol">-</a> amount <span class="paren6">(<span class="">balance account</span>)</span></span>)</span></span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_minusp.htm" class="symbol">plusp</a> overdraft</span>)</span><br/>      <span class="paren4">(<span class="">withdraw <span class="paren5">(<span class="">overdraft-account account</span>)</span> overdraft</span>)</span><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_incf_.htm" class="symbol">incf</a> <span class="paren5">(<span class="">balance account</span>)</span> overdraft</span>)</span></span>)</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_call_n.htm" class="symbol">call-next-method</a></span>)</span></span>)</span><br/></pre>

<p>Функция <code>CALL-NEXT-METHOD</code> является частью системы обобщенных функций и используется для
комбинации FIXME<em>подходящих</em> методов.  Она сообщает, что контроль должен быть передан от текущего метода, к
методу, специализированному для <code>bank-account</code>.<a class="fn_top" id="fnt__9" href="object-reorientation-generic-functions#fn__9">9)</a>  Когда он вызывается без аргументов, как это было сделано в нашем
примере, следующий в цепочке метод будет вызван с теми же аргументами, которые были
переданы обобщенной функции.  Он также может быть вызван с явным указанием аргументов,
которые будут переданы следующему методу.
</p>
<p>Вам не обязательно вызывать <code>CALL-NEXT-METHOD</code> в каждом методе.  Однако, если вы не
будете вызывать эту функцию, то новый метод будет полностью отвечать за реализацию
требуемого поведения обобщенной функции.  Например, если вы хотите создать подкласс
<code>bank-account</code>, названный <code>proxy-account</code>, который не будет отслеживать свой баланс, а
вместо этого будет делегировать списание средств другому счету, то вы можете записать этот
метод следующим образом (предполагая, что функция <code>proxied-account</code> возвращает
соответствующий счет):
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> withdraw <span class="paren2">(<span class=""><span class="paren3">(<span class="">proxy proxy-account</span>)</span> amount</span>)</span><br/>  <span class="paren2">(<span class="">withdraw <span class="paren3">(<span class="">proxied-account proxy</span>)</span> amount</span>)</span></span>)</span><br/></pre>

<p>В заключение, <code>DEFMETHOD</code> также позволяет вам создавать методы, которые специализированы
для конкретного объекта используя <code>EQL</code>-специализатор.  Например, предположим, что
банковское приложение FIXME<em>будет</em> развернуто в каком-то коррумпированном банке.  Предположим, что
переменная <code>*account-of-bank-president*</code> хранит ссылку на конкретный банковский счет,
который относится (как это видно из имени) к президенту банка.  ТакжеFIXME<em>Далее</em> предположим, что
переменная <code>*bank*</code> представляет весь банк, а функция <code>embezzle</code> крадет деньги у
банка.  Президент банка может попросить вас "исправить" функцию <code>withdraw</code> таким
образом, чтобы она обрабатывала его счет другим способом.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> withdraw <span class="paren2">(<span class=""><span class="paren3">(<span class="">account <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a> <span class="special">*account-of-bank-president*</span></span>)</span></span>)</span> amount</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">overdraft <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a__.htm" class="symbol">-</a> amount <span class="paren6">(<span class="">balance account</span>)</span></span>)</span></span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_minusp.htm" class="symbol">plusp</a> overdraft</span>)</span><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_incf_.htm" class="symbol">incf</a> <span class="paren5">(<span class="">balance account</span>)</span> <span class="paren5">(<span class="">embezzle <span class="special">*bank*</span> overdraft</span>)</span></span>)</span></span>)</span><br/>  <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_call_n.htm" class="symbol">call-next-method</a></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Однако заметьте, что форма, указанная в <code>EQL</code>-специализаторе, который используется для
указания объекта (в нашем случае это <code>*account-of-bank-president*</code>) вычисляется один
раз, когда вычисляется <code>DEFMETHOD</code>.  Этот метод будет специализирован для значения
<code>*account-of-bank-president*</code> в тот момент, когда этот метод был определен; последующие
изменения переменной не изменяют метод.
</p>



</div><div class="chapter" id="&#x41A;&#x43E;&#x43C;&#x431;&#x438;&#x43D;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435; &#x43C;&#x435;&#x442;&#x43E;&#x434;&#x43E;&#x432;"><h3>Комбинирование методов</h3>

<p>Вне кода метода использование <code>CALL-NEXT-METHOD</code> не имеет смысла.  
Внутри метода 
использование этой функции обретает смысл за счет того, что механизмы реализации
обобщенных функций при каждом запуске создают эффективный метод из методов, для которых
применимы текущие параметры.  Идея построения эффективного метода путем комбинации
методов, для которых применимы текущие аргументы, является основой концепции обобщенных
функций и это позволяет обобщенным функциям реализовывать возможности, которые недоступны
в системах с передачей сообщений.  Так что следует поближе познакомиться с тем, что в
действительности происходит.  Люди, которые давно знакомы с концепциями систем с передачей
сообщений должны обратить на данный материал особое внимание, поскольку обобщенные функции
кардинально меняют диспатчеризацию методов по сравнению с передачей сообщений, делая
обобщенную функцию (а не класс) ответственной за передачу управления.
</p>
<p>В соответствии с концепцией, эффективный метод строится в три шага: на первом шаге 
обобщенная функция строит список методов, для которых применимы переданные аргументы.  На
втором шаге полученный список методов сортируется в соответствии со специализированными
параметрами.  И в заключение, методы по порядку берутся из списка и их код комбинируется
образуя эффективный метод.<a class="fn_top" id="fnt__10" href="object-reorientation-generic-functions#fn__10">10)</a>
</p>
<p>Для нахождения методов, для которых применимы данные аргументы, обобщенная функция
сравнивает аргументы с соответствующими специализаторами параметров всех определенных
методов.  Метод считается допустимым, только если все специализаторы совместимы с
соответствующими параметрами.
</p>
<p>Когда специализатор является именем класса, он считается совместимым, если указанное имя
совпадает с именем класса аргумента (или именем одного из суперклассов аргумента).
(Заметьте, что параметры без явных специализаторов, неявно специализируются классом <code>T</code>,
так что они будут совместимы с любым аргументом).  <code>EQL</code>-специализатор считается
совместимым, если аргумент является тем же объектом, что указан в специализаторе.
</p>
<p>Поскольку все аргументы проверяются относительно соответствующих специализаторов, все они
влияют на результаты выбора подходящих методов.  Методы, которые явно специализируют более
одного параметра, называются мультиметодами; я опишу их в разделе "Мультиметоды".
</p>
<p>После того, как все соответствующие методы найдены, необходимо отсортировать их, чтобы
затем скомбинировать в эффективный метод.  Для упорядочения двух методов, обобщенная
функция сравнивает их специализаторы параметров слева направо,<a class="fn_top" id="fnt__11" href="object-reorientation-generic-functions#fn__11">11)</a> и первый специализатор, который
отличается в списке параметров методов будет определять их порядок, где первым ставится
метод с более специфичным специализатором.
</p>
<p>Поскольку сортируются только подходящие методы, вы знаете все классы специализаторов, для
которых соответствующий аргумент является экземпляром.  В типичном случае, если два
специализатора класса отличаются, то один будет подклассом другого.  В этом случае
специализатор, именующий подкласс, считается более специфичным.  Поэтому метод, который
специализирован для счета с классом <code>checking-account</code> будет рассматриваться как более
специфичный, чем метод, специализированный для класса <code>bank-account</code>.
</p>
<p>Множественное наследование, немного усложняет идею специфичности, поскольку аргумент может
быть экземпляром двух классов, ни один из которых не является подклассом другого.  Если
такие классы используются как специализаторы параметров, то обобщенная функция не может
упорядочить их используя только правило, что подклассы являются более специфичными, чем их
суперклассы.  В следующей главе я опишу как понятие специфичности было расширено для
обработки множественного наследования.  Сейчас достаточно сказать, что существует алгоритм
для упорядочения специализаторов классов.
</p>
<p>В заключение надо отметить, что <code>EQL</code>-специализатор всегда более специфичен, чем любой
специализатор класса, и поскольку рассматриваются только подходящие методы, то если
<code>EQL</code>-специализатор конкретного параметра имеют более одного метода, то все они должны
иметь одинаковые <code>EQL</code>-специализаторы.  Сравнение данных методов происходит на основе
других параметров.
</p>


</div><div class="chapter" id="&#x421;&#x442;&#x430;&#x43D;&#x434;&#x430;&#x440;&#x442;&#x43D;&#x44B;&#x439; &#x43A;&#x43E;&#x43C;&#x431;&#x438;&#x43D;&#x430;&#x442;&#x43E;&#x440; &#x43C;&#x435;&#x442;&#x43E;&#x434;&#x43E;&#x432;"><h3>Стандартный комбинатор методов</h3>

<p>Теперь, когда вы понимаете как подходящие методы находятся и сортируются, вы готовы поближе
взглянуть на последний шаг – как отсортированный список методов комбинируется в один
эффективный метод.  По умолчанию обобщенные функции используют так называемый
"стандартный комбинатор методов".  Стандартный комбинатор объединяет методы таким образом,
что <code>CALL-NEXT-METHOD</code> работает как это вы уже увидели – сначала запускается
наиболее специфичный метод, и каждый метод может передать управление следующему методу
используя <code>CALL-NEXT-METHOD</code>.
</p>
<p>Однако тут есть больше возможностей.  Методы, которые я обсуждал, называются основными
методами.  Основные методы (как и предполагает их имя) отвечают за реализацию основной
функциональности обобщенных функций.  Стандартный комбинатор методов также поддерживает
три вида вспомогательных методов: <code>:before</code>, <code>:after</code> и <code>:around</code>.  Определение
вспомогательных методов записывается с помощью <code>DEFMETHOD</code> также как и для основных
методов, но кроме этого, между именем метода и списком параметров указывается квалификатор
метода, который именует тип метода.  Например, метод <code>:before</code> для функции <code>withdraw</code>,
которые специализирует параметр <code>account</code> для класса <code>bank-account</code> будет начинаться
со следующей строки:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> withdraw <span class="keyword">:before</span> <span class="paren2">(<span class=""><span class="paren3">(<span class="">account bank-account</span>)</span> amount</span>)</span> ...</span>)</span><br/></pre>

<p>Каждый вид вспомогательных методов комбинируется в эффективный метод разными способами.
Все применимые методы  <code>:before</code> (не только наиболее специфические) запускаются как
часть эффективного метода.  Они запускаются (как и предполагается их именем) до наиболее
специфического основного метода и запускаются, начиная с самого специфического метода.
Таким образом, методы <code>:before</code> могут быть использованы для выполнения любой
подготовительной работы, которая может понадобиться, чтобы убедиться что основной метод
может быть выполнен.  Например, вы можете использовать метод  <code>:before</code>
специализированный для  <code>checking-account</code> для реализации защиты от перерасхода для
чековых счетов:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> withdraw <span class="keyword">:before</span> <span class="paren2">(<span class=""><span class="paren3">(<span class="">account checking-account</span>)</span> amount</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">overdraft <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a__.htm" class="symbol">-</a> amount <span class="paren6">(<span class="">balance account</span>)</span></span>)</span></span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_minusp.htm" class="symbol">plusp</a> overdraft</span>)</span><br/>      <span class="paren4">(<span class="">withdraw <span class="paren5">(<span class="">overdraft-account account</span>)</span> overdraft</span>)</span><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_incf_.htm" class="symbol">incf</a> <span class="paren5">(<span class="">balance account</span>)</span> overdraft</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Этот метод <code>:before</code> имеет три преимущества по сравнению с использованием основного
метода.  Во первых, он явно показывает как метод изменяет общее поведение функции
<code>withdraw</code> – он не пересекается с основным поведением и не изменяет возвращаемое
значение.
</p>
<p>Следующим преимуществом является то, что главный метод, специализированный для класса,
более специфичного, чем <code>checking-account</code> не будет противоречить этому методу
<code>:before</code>, что позволяет автору подкласса <code>checking-account</code> более легко расширить
поведение <code>withdraw</code>, при этом сохраняя старую функциональность.
</p>
<p>И наконец, поскольку метод <code>:before</code> не должен вызывать <code>CALL-NEXT-METHOD</code> для
передачи управления оставшимся методам, нет возможности сделать ошибку, забыв указать
эту функцию.
</p>
<p>Другие вспомогательные методы также организуются в эффективные методы способами, которые
отражены в их именах.  Все методы <code>:after</code> запускаются после основного метода в порядке,
когда наиболее специфичный метод вызывается последним (порядок противоположен вызову
методов <code>:before</code>).  Таким образом, методы <code>:before</code> и <code>:after</code> комбинируются для
создания вложенных обвязок вокруг основной функциональности, обеспечиваемой основными
методами – каждый более специфичный метод <code>:before</code> получит шанс сделать что-то для
менее специфичного метода <code>:before</code>, основные методы могут успешно выполняться, и затем
каждый более специфичный метод <code>:after</code> получает шанс убрать что-то за основным методом
и менее специфичными методами <code>:after</code>.
</p>
<p>И наконец, методы <code>:around</code> комбинируются практически также как и основные методы, за
исключением того, что они выполняются "вокруг" остальных методов. Так что код наиболее
специфического метода <code>:around</code> запускается до любого кода. Внутри кода метода
<code>:around</code>, вызов <code>CALL-NEXT-METHOD</code> приведет к тому, что будет выполняться код
следующего метода <code>:around</code>, или, при вызове из наименее специфического метода
<code>:around</code>, приведет к выполнению цепочки методов <code>:before</code>, основного метода и затем
методов <code>:after</code>.  Почти все методы <code>:around</code> будут иметь в своем коде вызов
<code>CALL-NEXT-METHOD</code>, поскольку метод <code>:around</code> не будет полностью реализовывать (перехватывать)
действия обобщенной функции и всех ее методов, за исключением более специфичных методов
<code>:around</code>. FIXME<em>Последнее предложение и в оригинале рвёт мозг. Я бы попроще объяснил: мол, поскольку методы around срабатывают первыми и наследуются "вовнутрь", то отсутствие call-next-method в любом из них повлечёт невызов всех менее специфичных around и вообще всех before, after и частей собственно метода. Такое поведение нетривиально и чревато, но допустимо для достижения определённых целей (см. ниже).</em>
</p>
<p>Иногда требуется полный перехват действий, но обычно, методы <code>:around</code> используются для
установки некоторого динамического контекста в котором будут выполняться остальные методы
– например, для связывания динамической переменной, или для установки обработчика ошибок
(это я буду обсуждать в главе 19).  Метод <code>:around</code> может не вызывать
<code>CALL-NEXT-METHOD</code> в тех случаях, если он, например, возвращает кэшированое значение,
которое было получено при предыдущих вызовах <code>CALL-NEXT-METHOD</code>.  В любом случае, метод
<code>:around</code>, не вызывающий <code>CALL-NEXT-METHOD</code>, ответственен за корректную реализацию
семантики обобщенной функции для всех классов аргументов, для которых этот метод может
применяться, включая и будущие подклассы.
</p>
<p>Вспомогательные методы являются лишь удобным и лаконичным способом для выражения некоторых
общих подходов (шаблонов).  Они не позволяют сделать ничего невозможного посредством
объединения основных методов с аккуратным соблюдением нескольких соглашений по
кодированию и небольшим количеством дополнительного кода. Вероятно, наибольшей выгодой является то, что они обеспечивают
унифицированный каркас для расширения функциональности обобщенных функций.  Библиотеки
часто определяют обобщенные функции и основные методы для них, позволяя пользователям
изменять их поведение с помощью вспомогательных методов.
</p>


</div><div class="chapter" id="&#x414;&#x440;&#x443;&#x433;&#x438;&#x435; &#x43A;&#x43E;&#x43C;&#x431;&#x438;&#x43D;&#x430;&#x442;&#x43E;&#x440;&#x44B; &#x43C;&#x435;&#x442;&#x43E;&#x434;&#x43E;&#x432;"><h3>Другие комбинаторы методов</h3>

<p>В добавление к стандартному комбинатору методов, язык реализует девять других встроенных
комбинаторов методов, известных как "простые встроенные комбинаторы методов".  Вы также
можете определить собственный комбинатор методов, хотя это довольно редко используемая
возможность, описание которой не является предметом этой книги.  Я коротко опишу как
использовать простые комбинаторы методов, чтобы дать общее представление об имеющихся
возможностях.
</p>
<p>Все простые комбинаторы используют одинаковую стратегию: вместо запуска наиболее
специфического метода, и разрешения ему запускать менее специфичные методы через
<code>CALL-NEXT-METHOD</code>, простые комбинаторы методов создают эффективный метод, содержащий
код всех основных методов, расположенных по порядку, и обернутых вызовом к функции,
макросу или специальному оператору, который и дал комбинатору методов соответствующее имя.
Девять комбинаторов получили имена от операторов: <code>+</code>, <code>AND</code>, <code>OR</code>, <code>LIST</code>,
<code>APPEND</code>, <code>NCONC</code>, <code>MIN</code>, <code>MAX</code> и <code>PROGN</code>.  Простые комбинаторы поддерживают
только два типа методов – основные методы, которые объединяются так, как было описано
выше, и методы <code>:around</code>, которые работают также, как и методы <code>:around</code> в стандартном
комбинаторе.
</p>
<p>Например, обобщенная функция, которая использует комбинатор методов <code>+</code>, вернет сумму
всех результатов, возвращенных вызванными основными методами.  Отметьте, что комбинаторы
<code>AND</code> и <code>OR</code> не обязательно будут выполнять все основные методы, поскольку эти макросы
могут использовать сокращенную схему работы – обобщенная функция, использующая комбинатор
<code>AND</code> вернет значение <code>NIL</code> сразу же, как один из методов вернет его, или в противном
вернет значение, возвращенное последним вызванным методом.  Аналогичным образом,
комбинатор <code>OR</code> вернет первое значение не равное-<code>NIL</code>, возвращенное любым из его
методов.
</p>
<p>Для определения обобщенной функции, которая использует конкретный комбинатор методов, вы
должны указать опцию <code>:method-combination</code> при объявлении <code>DEFGENERIC</code>.  Значение,
указанное данной опцией определяет имя комбинатора методов, который вы хотите
использовать.  Например, для определения обобщенной функции <code>priority</code>, которая
возвращает сумму значений, возвращаемых отдельными методами, используя комбинатор методов
<code>+</code>, вы можете написать следующий код:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defgen.htm" class="symbol"><i><span class="symbol">defgeneric</span></i></a> priority <span class="paren2">(<span class="">job</span>)</span><br/>  <span class="paren2">(<span class=""><span class="keyword">:documentation</span> <span class="string">"Return the priority at which the job should be run."</span></span>)</span><br/>  <span class="paren2">(<span class=""><span class="keyword">:method-combination</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a></span>)</span></span>)</span><br/></pre>

<p>По умолчанию, все эти комбинаторы методов комбинируют методы в порядке начиная с наиболее
специфичного.  Однако вы можете изменить порядок, путем указания ключевого слова
<code>:most-specific-last</code> после имени комбинатора в объявлении функции с помощью
<code>DEFGENERIC</code>.  Порядок скорее всего не имеет значения если вы используете комбинатор
<code>+</code> и методы не имеют побочных эффектов, но в целях демонстрации, я изменю код
<code>priority</code> чтобы он использовал порядок <code>most-specific-last</code>:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defgen.htm" class="symbol"><i><span class="symbol">defgeneric</span></i></a> priority <span class="paren2">(<span class="">job</span>)</span><br/>  <span class="paren2">(<span class=""><span class="keyword">:documentation</span> <span class="string">"Return the priority at which the job should be run."</span></span>)</span><br/>  <span class="paren2">(<span class=""><span class="keyword">:method-combination</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> <span class="keyword">:most-specific-last</span></span>)</span></span>)</span><br/></pre>

<p>Основные методы обобщенных функций, которые используют один из этих комбинаторов, должны
быть квалифицированы именем комбинатора методов.  Таким образом, основной метод,
определенный для функции <code>priority</code> может выглядеть следующим образом:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> priority <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> <span class="paren2">(<span class=""><span class="paren3">(<span class="">job express-job</span>)</span></span>)</span> 10</span>)</span><br/></pre>

<p>Это станет более ясным, если вы рассмотрите определение метода, как конкретную часть обобщенной функции.
</p>
<p>Все простые встроенные комбинаторы методов поддерживают методы <code>:around</code>, которые
работают также как и методы <code>:around</code> в стандартном комбинаторе: наиболее специфичный
метод <code>:around</code> выполняется до любого метода, и он может использовать
<code>CALL-NEXT-METHOD</code> для передачи контроля менее специфичному методу <code>:around</code> до тех
пор, пока не будет достигнут основной метод.  Опция <code>:most-specific-last</code> не влияет на
порядок вызова методов <code>:around</code>.  И, как я отметил ранее, встроенные комбинаторы
методов не поддерживают методы <code>:before</code> и <code>:after</code>.
</p>
<p>Подобно стандартному комбинатору методов, эти комбинаторы не позволяют вам сделать ничего
из того, что вы не можете сделать "вручную".  Вместо этого, они позволяют вам выразить то,
что вы хотите, а язык возьмет на себя заботу о связывании всего вместе, делая ваш код
более кратким и выразительным.
</p>
<p>Честно говоря, примерно в 99 процентах случаев вам будет достаточно стандартного
комбинатора методов.  Оставшийся один процент случаев скорее всего будет обработан
простыми встроенными комбинаторами методов.  Но если вы попадете в ситуацию (вероятность -
примерно одна сотая процента), когда вам не будет подходить ни один из встроенных
комбинаторов, то вы можете посмотреть на описание <code>DEFINE-METHOD-COMBINATION</code> в вашем
любимом справочнике по Common Lisp.
</p>




</div><div class="chapter" id="&#x41C;&#x443;&#x43B;&#x44C;&#x442;&#x438;&#x43C;&#x435;&#x442;&#x43E;&#x434;&#x44B;"><h3>Мультиметоды</h3>

<p>Методы, которые явно специализируют более одного параметра обобщенной функции называются
мультиметодами. Мультиметоды - это то, в чем реально расходятся обобщенные функции и 
передача сообщений.
Языки с передачей сообщений не приспособлены к мультиметодам, поскольку
они не относятся к конкретному классу; вместо этого, каждый мультиметод определяет часть
реализации конкретной обобщенной функции, которая применяется тогда, когда эта функция
вызывается с аргументами, которые соответствуют всем специализированным параметрам.
</p>
<p>FIXME (начало выделенного блока) </p><hr/>
<div class="chapter" id="&#x41C;&#x443;&#x43B;&#x44C;&#x442;&#x438;&#x43C;&#x435;&#x442;&#x43E;&#x434;&#x44B; &#x43F;&#x440;&#x43E;&#x442;&#x438;&#x432; &#x43F;&#x435;&#x440;&#x435;&#x433;&#x440;&#x443;&#x437;&#x43A;&#x438; &#x43C;&#x435;&#x442;&#x43E;&#x434;&#x43E;&#x432;"><h3>Мультиметоды против перегрузки методов</h3>
<p>Программисты, использовавшие статически типизованные языки с системами передачи сообщений,
такие как Java и C++, могут подумать, что мультиметоды похожи на такую возможность этих
языков, как перегрузка методов.  Однако эти две возможности языка в достаточной мере
отличаются, поскольку перегруженные методы выбираются во время компиляции, основываясь
на информации об аргументах, полученной во время компиляции, а не во время исполнения.  Чтобы посмотреть как это работает,
рассмотрим два следующих класса на языке Java:
</p>
<pre class="code"><p>public class A {<br/>
  public void foo<span class="paren1">(<span class="">A a</span>)</span> { System.out.println<span class="paren1">(<span class=""><span class="string">"A/A"</span></span>)</span>; }<br/>
  public void foo<span class="paren1">(<span class="">B b</span>)</span> { System.out.println<span class="paren1">(<span class=""><span class="string">"A/B"</span></span>)</span>; }<br/>
}<br/><br/>public class B extends A {<br/>
  public void foo<span class="paren1">(<span class="">A a</span>)</span> { System.out.println<span class="paren1">(<span class=""><span class="string">"B/A"</span></span>)</span>; }<br/>
  public void foo<span class="paren1">(<span class="">B b</span>)</span> { System.out.println<span class="paren1">(<span class=""><span class="string">"B/B"</span></span>)</span>; }<br/>
}<br/></p></pre>

<p>Теперь посмотрим, что случится, когда вы запустите метод <code>main</code> из этого класса.
</p>
<pre class="code"><p>public class Main {<br/>
  public static void main<span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_string.htm" class="symbol">String</a>[] argv</span>)</span> {<br/>
    A obj = argv[0].equals<span class="paren1">(<span class=""><span class="string">"A"</span></span>)</span> ? new A<span class="paren1">(<span class=""/>)</span> : new B<span class="paren1">(<span class=""/>)</span>;<br/>
    obj.foo<span class="paren1">(<span class="">obj</span>)</span>;<br/>
  }<br/>
}<br/></p></pre>

<p>Когда вы заставляете <code>main</code> создать экземпляр <code>A</code>, она выдаст <code>A/A</code>, как вы и
ожидали.
</p><pre>bash$ java com.gigamonkeys.Main A<br/>A/A<br/></pre>
<p>Однако, если вы заставите <code>main</code> создать экземпляр <code>B</code>, то настоящий тип объекта
<code>obj</code> будет принят во внимание не полностью.
</p><pre>bash$ java com.gigamonkeys.Main B<br/>B/A<br/></pre>
<p>Если бы перегруженные методы работали также как и мультиметоды в Common Lisp, то
программа бы выдала ожидаемый результат: <code>B/B</code>.  Существует возможность реализации
множественной диспатчеризации для систем с передачей сообщений вручную, но это будет
противоречить модели системы с передачей сообщений, поскольку метод с множественной
диспатчеризацией не должен относиться ни к одному из классов.
</p><hr/>
<p>FIXME конец блока
</p>
<p>Мультиметоды полезны в ситуациях, когда вы не знаете к какому классу определенное
поведение должно относиться (в языках с передачей сообщений).  Звук, который издает
барабан, когда вы стучите по нему палочкой, является функцией барабана, или функцией
палочки?  Конечно, он принадлежит обоим предметам.  Для моделирования такой ситуации в
Common Lisp, вы просто определяете функцию <code>beat</code>, которая принимает два аргумента.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defgen.htm" class="symbol"><i><span class="symbol">defgeneric</span></i></a> beat <span class="paren2">(<span class="">drum stick</span>)</span><br/>  <span class="paren2">(<span class=""><span class="keyword">:documentation</span><br/>   <span class="string">"Produce a sound by hitting the given drum with the given stick."</span></span>)</span></span>)</span><br/></pre>

<p>Затем, вы можете определять разные мультиметоды для реализации <code>beat</code> для комбинаций,
которые вам нужны. Например:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> beat <span class="paren2">(<span class=""><span class="paren3">(<span class="">drum snare-drum</span>)</span> <span class="paren3">(<span class="">stick wooden-drumstick</span>)</span></span>)</span> ...</span>)</span><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> beat <span class="paren2">(<span class=""><span class="paren3">(<span class="">drum snare-drum</span>)</span> <span class="paren3">(<span class="">stick brush</span>)</span></span>)</span> ...</span>)</span><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> beat <span class="paren2">(<span class=""><span class="paren3">(<span class="">drum snare-drum</span>)</span> <span class="paren3">(<span class="">stick soft-mallet</span>)</span></span>)</span> ...</span>)</span><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> beat <span class="paren2">(<span class=""><span class="paren3">(<span class="">drum tom-tom</span>)</span> <span class="paren3">(<span class="">stick wooden-drumstick</span>)</span></span>)</span> ...</span>)</span><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> beat <span class="paren2">(<span class=""><span class="paren3">(<span class="">drum tom-tom</span>)</span> <span class="paren3">(<span class="">stick brush</span>)</span></span>)</span> ...</span>)</span><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> beat <span class="paren2">(<span class=""><span class="paren3">(<span class="">drum tom-tom</span>)</span> <span class="paren3">(<span class="">stick soft-mallet</span>)</span></span>)</span> ...</span>)</span><br/></pre>

<p>Мультиметоды не помогают от комбинаторного взрыва – если вам необходимо смоделировать пять
видов барабанов и шесть видов палочек, и каждая из комбинаций дает отдельный звук, то нет
способа упростить это; вам необходимо определить тридцать различных методов для реализации
всех комбинаций, используя мультиметоды или нет.  Мультиметоды помогут вам не писать
собственный код для диспатчинга, позволяя использовать встроенные средства
диспатчеризации, которые были очень удобны при работе с методами, специализированными для
одного параметра.<a class="fn_top" id="fnt__12" href="object-reorientation-generic-functions#fn__12">12)</a>
</p>
<p>Мультиметоды также спасают вас от требования чтобы один набор классов был тесно связан с
другим набором. В нашем примере барабанов/палочек, не требуется чтобы класс, представляющий
барабаны знал о различных классах, представляющих барабанные палочки, и наоборот.
Мультиметоды связывают независимые классы для описания их совместного поведения, при этом
не требуя никакого взаимодействия между самими классами.
</p>

</div></div><div class="chapter" id="&#x41F;&#x440;&#x43E;&#x434;&#x43E;&#x43B;&#x436;&#x435;&#x43D;&#x438;&#x435; &#x441;&#x43B;&#x435;&#x434;&#x443;&#x435;&#x442; ..."><h3>Продолжение следует ...</h3>

<p>Я описал основы (и немного больше) обобщенных функций – "глаголов" объектной системы Common Lisp.  В следующей главе я покажу вам как определять ваши собственные классы.
</p></div></div><div class="footnotes"><div><a class="fn_bot" id="fn__1" href="object-reorientation-generic-functions#fnt__1">1)</a>
Язык Simula, который сейчас считается первым объектно-ориентированным языком,
был создан в начале 1960-х
годов, лишь несколько 
лет после создания McCarthy 
первого Lisp.  Однако,
объектно-ориентированный подход не был популярен до начала 1980-х годов, когда была
выпущена первая доступная версия Smalltalk, за которой последовал выпуск C++ несколько лет
спустя.  Smalltalk позаимствовал часть идей из Lisp и объединил их с идеями из Simula, что
в результате привело к появлению динамического, объектно-ориентированного языка, в то время
как C++ комбинировал идеи Simula и Си, что породило статический объектно-ориентированный язык. Это первоначальное разделение, привело к множеству
неясностей в определении того, что есть объектно-ориентированный подход.  Люди, которые
привыкли к C++, говорят, что некоторые его аспекты, 
такие как строгая инкапсуляция данных,
являются ключевыми характеристиками ООП. А люди, воспитанные на Smalltalk, в свою очередь
указывают, что многие возможности C++ являются лишь возможностями C++, а не основами ООП. 
Говорят, Alan Kay, отец Smalltalk, однажды сказал: <em>"Я ввёл термин
объектно-ориентированный, и могу сказать, что C++ – это не то, что я имел ввиду".</em></div><div><a class="fn_bot" id="fn__2" href="object-reorientation-generic-functions#fnt__2">2)</a>Читается "see-loss". Источник: P. Norvig. "Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp". - Прим. перев.</div><div><a class="fn_bot" id="fn__3" href="object-reorientation-generic-functions#fnt__3">3)</a>Есть люди, который полностью отрицают, что
Common Lisp является объектно-ориентированным языком.  В частности, люди рассматривающие
строгую инкапсуляцию данных в качестве ключевой характеристики 
ООП (обычно это приверженцы
статических языков, таких как C++, Eiffel или Java), не считают Common Lisp
"правильным" объектно-ориентированным языком.  Конечно, при использовании данного
определения, Smalltalk – один из первых объектно-ориентированных языков, также не будет
им считаться.  С другой стороны, люди, рассматривающие передачу сообщений как ключевую
составляющую ООП, также не будут 
рады утверждению о объектной ориентированности Common Lisp, поскольку обобщенные функции Common Lisp предоставляют степени
свободы, не предлагаемые чистой передачей сообщений.</div><div><a class="fn_bot" id="fn__4" href="object-reorientation-generic-functions#fnt__4">4)</a>Языки, основанные на прототипах (prototype-based languages) являются другим видом объектно-ориентированных
языков. В таких языках (самым известным примером будет, пожалуй, JavaScript) объекты создаются
путем клонирования объекта-прототипа. После клонирования, объект может быть модифицирован
и использован как прототип для других объектов.</div><div><a class="fn_bot" id="fn__5" href="object-reorientation-generic-functions#fnt__5">5)</a><code>T</code> является
значением-константой, и класс <code>T</code> не имеет никакого отношения к этой константе, за тем
исключением, что они имеют одинаковые имена.  
Значение <code>T</code> является экземпляром класса
<code>SYMBOL</code> и, косвенно, экземпляром класса <code>T</code>.</div><div><a class="fn_bot" id="fn__6" href="object-reorientation-generic-functions#fnt__6">6)</a>Здесь, как и везде, под
объектом понимается любой тип данных Lisp – Common Lisp не делает различия, как это
делают некоторые языки, между объектами и "примитивными" типами данных; все типы данных в
Common Lisp являются объектами, и каждый объект является экземпляром класса.</div><div><a class="fn_bot" id="fn__7" href="object-reorientation-generic-functions#fnt__7">7)</a>С технической точки зрения, вы можете вообще не использовать <code>DEFGENERIC</code> – если вы определяете метод с помощью <code>DEFMETHOD</code> и соответствующая обобщенная функция
не определена, она будет создана автоматически.  Однако хорошим тоном считается явное
определение обобщенной функции, поскольку это 
предоставляет хорошее место для документирования её предназначения.</div><div><a class="fn_bot" id="fn__8" href="object-reorientation-generic-functions#fnt__8">8)</a>Метод может "принимать" именованные и
остаточные аргументы, определенные в обобщенной функции, путем указания параметра
<code>&amp;rest</code>; тех же именованных параметров, или 
FIXME<em><code>&amp;rest</code>, указания такого же параметра <code>&amp;key</code> или</em>
указывая <code>&amp;allow-other-keys</code> вместе с
<code>&amp;key</code>.  Метод также может указывать именованные параметры, не указанные в списке
параметров обобщенной функции: когда вызывается обобщенная функция, будет принят любой именованный параметр, 
указанный обобщенной функцией или любым другим подходящим методом.
FIXME<em>Одним следствием из правила соответствия является то, что все методы
одной и той же обобщенной функции будут иметь совпадающие списки параметров.
Common Lisp не поддерживает перегрузку методов так, как это делают некоторые
статически типизированные языки как С++ и Java, где одно и тоже имя может
использоваться для методов с разными списками параметров.</em>
</div><div><a class="fn_bot" id="fn__9" href="object-reorientation-generic-functions#fnt__9">9)</a><code>CALL-NEXT-METHOD</code> аналогиченFIXME<em>является приблизительным аналогом</em> вызову
метода для <code>super</code> в Java или использованию явно указанного метода или функции класса в
Python или C++.</div><div><a class="fn_bot" id="fn__10" href="object-reorientation-generic-functions#fnt__10">10)</a>Хотя построение эффективного метода кажется медленным, был
достигнут достаточный прогресс в части обеспечения его эффективности и разработки быстрых
реализаций Common Lisp.  Одной из стратегий является кэширование эффективных методов, так
что следующие вызовы с теми же аргументами, будут обрабатываться сразу.</div><div><a class="fn_bot" id="fn__11" href="object-reorientation-generic-functions#fnt__11">11)</a>в действительности,
порядок сравнения специализаторов настраивается через опцию <code>:argument-precedence-order</code>
макроса <code>DEFGENERIC</code>, хотя она редко используется.</div><div><a class="fn_bot" id="fn__12" href="object-reorientation-generic-functions#fnt__12">12)</a>В языках без мультиметодов, вы должны сами писать диспатчеризующий код
для реализации поведения, которое зависит от нескольких объектов.  Назначением популярного
паттерна проектирования "Визитор (Visitor)" является упорядочение серии методов,
диспатчеризуемых по одному классу, таким образом, чтобы они обеспечивали множественную
диспатчеризацию.  Однако, это требует, чтобы один набор классов знал о других.  Паттерн
"Визитор" также вязнет в комбинаторном росте диспатчеризуемых методов, если он
используется для диспатчеризации более чем двух объектов.</div></div></div> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="practical-a-portable-pathname-library">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right"> <a href="object-reorientation-classes">Следующая</a> </td> </tr> </tbody> </table> </div> <div class="bottom">@2009-2013 lisper.ru</div> 
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7734690-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
 </body> </html>