<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru"> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <meta name="keywords" content="Common Lisp,lisp,лисп" /> <title>Практика. База данных для MP3</title> <link href="../css/style.css" rel="stylesheet" type="text/css" /><link href="../css/colorize.css" rel="stylesheet" type="text/css" />  </head> <body> <div class="top"> <div id="login"> <a href="http://lisper.ru/register">Регистрация</a> | <a href="http://lisper.ru/login?done=/pcl/practical-an-mp3-database">Войти</a> </div> </div> <div id="caution"> <img alt="Lisp — программируемый язык программирования" src="../image/gecko.png" /> <a href="http://www.vkusnoserver.ru/" target="_blank" style="float: right;"> <img src="../vkusnoserver.png" /> </a> </div> <div id="mainmenu"> <ul> <li> <a href="http://lisper.ru/">Главная</a> </li><li> <a href="http://lisper.ru/articles/">Статьи</a> </li><li> <a href="http://lisper.ru/planet/">Планета</a> </li><li> <a href="http://lisper.ru/forum/">Форум</a> </li><li> <a href="http://lisper.ru/apps/">Сервисы</a> </li><li> <a href="index.html">Practical Common Lisp</a> </li><li> <a href="http://lisper.ru/wiki/">Wiki</a> </li><li> <a href="http://lisper.ru/files/">Файлы</a> </li><li> <a href="http://lisper.ru/search">Поиск</a> </li> </ul> </div> <div id="content"> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="practical-web-programming-with-allegroserve">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right"> <a href="practical-a-shoutcast-server">Следующая</a> </td> </tr> </tbody> </table> <div class="article"><div class="toc"><div class="toc-header">Содержание</div><div class="toc-body"><ul><li><div><a href="practical-an-mp3-database#27. &#x41F;&#x440;&#x430;&#x43A;&#x442;&#x438;&#x43A;&#x430;: &#x411;&#x430;&#x437;&#x430; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445; &#x434;&#x43B;&#x44F; MP3">27. Практика: База данных для MP3</a><ul><li><div><a href="practical-an-mp3-database#&#x411;&#x430;&#x437;&#x430; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;">База данных</a></div></li><li><div><a href="practical-an-mp3-database#&#x41E;&#x43F;&#x440;&#x435;&#x434;&#x435;&#x43B;&#x435;&#x43D;&#x438;&#x435; &#x441;&#x445;&#x435;&#x43C;&#x44B; &#x431;&#x430;&#x437;&#x44B; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;">Определение схемы базы данных</a></div></li><li><div><a href="practical-an-mp3-database#&#x412;&#x441;&#x442;&#x430;&#x432;&#x43A;&#x430; &#x437;&#x43D;&#x430;&#x447;&#x435;&#x43D;&#x438;&#x439;">Вставка значений</a></div></li><li><div><a href="practical-an-mp3-database#&#x412;&#x44B;&#x43F;&#x43E;&#x43B;&#x43D;&#x435;&#x43D;&#x438;&#x435; &#x437;&#x430;&#x43F;&#x440;&#x43E;&#x441;&#x43E;&#x432; &#x43A; &#x431;&#x430;&#x437;&#x435; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;">Выполнение запросов к базе данных</a></div></li><li><div><a href="practical-an-mp3-database#&#x424;&#x443;&#x43D;&#x43A;&#x446;&#x438;&#x438; &#x43E;&#x442;&#x431;&#x43E;&#x440;&#x430; (FIXME Matching)">Функции отбора (FIXME Matching)</a></div></li><li><div><a href="practical-an-mp3-database#&#x420;&#x430;&#x431;&#x43E;&#x442;&#x430; &#x441; &#x440;&#x435;&#x437;&#x443;&#x43B;&#x44C;&#x442;&#x430;&#x442;&#x430;&#x43C;&#x438; &#x432;&#x44B;&#x43F;&#x43E;&#x43B;&#x43D;&#x435;&#x43D;&#x438;&#x44F; &#x437;&#x430;&#x43F;&#x440;&#x43E;&#x441;&#x43E;&#x432;">Работа с результатами выполнения запросов</a></div></li><li><div><a href="practical-an-mp3-database#&#x414;&#x440;&#x443;&#x433;&#x438;&#x435; &#x43E;&#x43F;&#x435;&#x440;&#x430;&#x446;&#x438;&#x438; &#x441; &#x431;&#x430;&#x437;&#x43E;&#x439; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;">Другие операции с базой данных</a></div></li></ul></div></li></ul></div></div>
<div class="chapter" id="27. &#x41F;&#x440;&#x430;&#x43A;&#x442;&#x438;&#x43A;&#x430;: &#x411;&#x430;&#x437;&#x430; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445; &#x434;&#x43B;&#x44F; MP3"><h3>27. Практика: База данных для MP3</h3>

<p>В этой главе мы заново рассмотрим идею, впервые упомянутую в главе Chapter 3 – построение базы данных, расположенной в памяти, на основе базовых типов данных Lisp.  Сейчас нашей целью является хранение информации, которую вы извлечете из коллекции файлов в формате MP3 при помощи библиотеки ID3v2 из главы 25.  Вы затем будете использовать эту базу данных в главах  28 и 29 как часть потокового MP3-сервера с  Web-интерфейсом.  Конечно сейчас вы уже можете использовать некоторые из языковых конструкций, изученных со времени изучения главы 3, чтобы создать более совершенный код.
</p>
<div class="chapter" id="&#x411;&#x430;&#x437;&#x430; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;"><h3>База данных</h3>

<p>Основной проблемой базы данных из главы 3 является то, что есть только одна таблица – список, сохраненный в переменной <code>*db*</code>.  Другой проблемой является то, что код ничего не знает о типах значений, сохраненных в разных колонках.  В главе 3 вы просто использовали функцию общего назначения <code>EQUAL</code> для сравнения значений в колонках при выборе строк из базы данных, но у вас были бы проблемы, если бы вы хотели бы сохранить значения, которые не сравниваются с помощью<code>EQUAL</code>, или если бы вы хотели сортировать строки в базе данных, поскольку не такой функции сравнения, похожей на <code>EQUAL</code>.
</p>
<p>Сейчас вы будете решать обе проблемы путем определения класса <code>table</code>, который будет описывать отдельные таблицы базы данных.  Каждый экземпляр класса  <code>table</code> будет состоять из двух слотов – один для хранения данных, а второй – для хранения информации о колонках таблицы, которую смогут использовать функции для работы с базой данных.  Класс выглядит примерно вот так:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defcla.htm" class="symbol"><i><span class="symbol">defclass</span></i></a> table <span class="paren2">(<span class=""/>)</span><br/>  <span class="paren2">(<span class=""><span class="paren3">(<span class="">rows   <span class="keyword">:accessor</span> rows   <span class="keyword">:initarg</span> <span class="keyword">:rows</span> <span class="keyword">:initform</span> <span class="paren4">(<span class="">make-rows</span>)</span></span>)</span><br/>   <span class="paren3">(<span class="">schema <span class="keyword">:accessor</span> schema <span class="keyword">:initarg</span> <span class="keyword">:schema</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Также как и в главе 3, вы можете представлять отдельные строки в виде списков свойств, но сейчас время вы создадите абстракцию, которая позволит вам изменять внутренее представление без особых трудностей. И в данной версии вы будет сохранять данные в векторе, а не в списке свойств, поскольку некоторые операции, которые вы будете поддерживать, например, произвольный доступ к строкам по числовому индексу, и возможность сортировки таблицы, могут быть более эффективно реализованы с помощью векторов.
</p>
<p>Функция <code>make-rows</code>, используемая для инициализации слота <code>rows</code> может быть простой оберткой для функции  <code>MAKE-ARRAY</code>, которая создает пустой вектор с изменяемым размером и указателем заполнения.
</p>
<p>FIXME this should be inside of table/box
Пакет
</p>
<p>Объявление пакета для разрабатываемого вами в этой главе кода будет выглядеть следующим образом:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defpkg.htm" class="symbol"><i><span class="symbol">defpackage</span></i></a> <span class="keyword">:com.gigamonkeys.mp3-database</span><br/>  <span class="paren2">(<span class=""><span class="keyword">:use</span> <span class="keyword">:common-lisp</span> <br/>        <span class="keyword">:com.gigamonkeys.pathnames</span><br/>        <span class="keyword">:com.gigamonkeys.macro-utilities</span><br/>        <span class="keyword">:com.gigamonkeys.id3v2</span></span>)</span><br/>  <span class="paren2">(<span class=""><span class="keyword">:export</span>  <span class="keyword">:*default-table-size*</span><br/>            <span class="keyword">:*mp3-schema*</span><br/>            <span class="keyword">:*mp3s*</span><br/>            <span class="keyword">:column</span><br/>            <span class="keyword">:column-value</span><br/>            <span class="keyword">:delete-all-rows</span><br/>            <span class="keyword">:delete-rows</span><br/>            <span class="keyword">:do-rows</span><br/>            <span class="keyword">:extract-schema</span><br/>            <span class="keyword">:in</span><br/>            <span class="keyword">:insert-row</span><br/>            <span class="keyword">:load-database</span><br/>            <span class="keyword">:make-column</span><br/>            <span class="keyword">:make-schema</span><br/>            <span class="keyword">:map-rows</span><br/>            <span class="keyword">:matching</span><br/>            <span class="keyword">:not-nullable</span><br/>            <span class="keyword">:nth-row</span><br/>            <span class="keyword">:random-selection</span><br/>            <span class="keyword">:schema</span><br/>            <span class="keyword">:select</span><br/>            <span class="keyword">:shuffle-table</span><br/>            <span class="keyword">:sort-rows</span><br/>            <span class="keyword">:table</span><br/>            <span class="keyword">:table-size</span><br/>            <span class="keyword">:with-column-values</span></span>)</span></span>)</span><br/></pre>

<p>Раздел <code>:use</code> дает возможность доступа к функциям и макросам, чьи имена экспортированы из пакетов, созданных в главах 15, 8  и 25, а секция <code>:export</code> используется для объявления функций, реализуемых данным пакетом, и которые будут использоваться в главе 29.
</p>
<p>FIXME end of table/box
</p>

<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defpar.htm" class="symbol"><i><span class="symbol">defparameter</span></i></a> <span class="special">*default-table-size*</span> 100</span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> make-rows <span class="paren2">(<span class="">&amp;optional <span class="paren3">(<span class="">size <span class="special">*default-table-size*</span></span>)</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_ar.htm" class="symbol">make-array</a> size <span class="keyword">:adjustable</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="keyword">:fill-pointer</span> 0</span>)</span></span>)</span><br/></pre>

<p>Для представление схемы таблицы, вам необходимо определить еще один класс – <code>column</code>, каждый экземпляр которого будет содержать информацию об одной колонке в таблице: ее название, способ сравнения значений в колонке на равенство и порядок расположения, значение по умолчанию, а также функцию, которая будет использоваться для нормализации значения при вставке данных в таблицу и при запросе данных из таблицы. Слот <code>schema</code> будет хранить список объектов типа <code>column</code>.  Определение класса будет выглядеть примерно вот так:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defcla.htm" class="symbol"><i><span class="symbol">defclass</span></i></a> column <span class="paren2">(<span class=""/>)</span><br/>  <span class="paren2">(<span class=""><span class="paren3">(<span class="">name               <br/>    <span class="keyword">:reader</span> name<br/>    <span class="keyword">:initarg</span> <span class="keyword">:name</span></span>)</span><br/><br/>   <span class="paren3">(<span class="">equality-predicate<br/>    <span class="keyword">:reader</span> equality-predicate<br/>    <span class="keyword">:initarg</span> <span class="keyword">:equality-predicate</span></span>)</span><br/><br/>   <span class="paren3">(<span class="">comparator<br/>    <span class="keyword">:reader</span> comparator<br/>    <span class="keyword">:initarg</span> <span class="keyword">:comparator</span></span>)</span><br/><br/>   <span class="paren3">(<span class=""><i><span class="symbol">default-value</span></i><br/>    <span class="keyword">:reader</span> <i><span class="symbol">default-value</span></i><br/>    <span class="keyword">:initarg</span> <span class="keyword">:default-value</span><br/>    <span class="keyword">:initform</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span><br/><br/>   <span class="paren3">(<span class="">value-normalizer<br/>    <span class="keyword">:reader</span> value-normalizer<br/>    <span class="keyword">:initarg</span> <span class="keyword">:value-normalizer</span><br/>    <span class="keyword">:initform</span> #'<span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren5">(<span class="">v column</span>)</span> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_declar.htm" class="symbol">declare</a> <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/d_ignore.htm" class="symbol">ignore</a> column</span>)</span></span>)</span> v</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Слоты  <code>equality-predicate</code> и <code>comparator</code> объекта <code>column</code> хранят функции, которые будут использоваться для сравнения значений данной колонки на равенство и порядок расположения.  Например, для колонки, которая будет хранить строковые значения, мы можем использовать функции <code>STRING=</code> в качестве значения <code>equality-predicate</code> и <code>STRING&lt;</code> для <code>comparator</code>, тогда как колонки, хранящие числа, могут использовать функции <code>=</code> и <code>&lt;</code>.
</p>
<p>Слоты  <code>default-value</code> и <code>value-normalizer</code> используются при вставке и при запросе данных (слот <code>value-normalizer</code>).  Когда вы вставляет строку в базу данных, и для определенной колонки не указано значение, то вы можете использовать значение, хранящееся в слоте <code>default-value</code> данной колонки.  Затем, значение (значение по умолчанию или указанное пользователем) нормализуется путем передачи его и объекта, описывающего колонку в БД, в качестве параметров функции, указанной в слоте  <code>value-normalizer</code>.  Вы передаете объект типа  <code>column</code> поскольку для функции <code>value-normalizer</code> может понадобиться некоторые данные, связанные с объектом  <code>column</code>. (Вы увидите пример такого использования в следующем разделе).  Вы также должны нормализовывать значения, передаваемы в запросах, до их сравнения с объектами в базе данных.
</p>
<p>Таким образом,  <code>value-normalizer</code> отвечает за возврат значения, которое может быть спокойно переданно функциям <code>equality-predicate</code> и <code>comparator</code>.  Если <code>value-normalizer</code> не может найти подходящее возвращаемое значение, то она сгенерирует ошибку.
</p>
<p>Другой причиной для нормализации значений до их сохранения в БД является возможность уменьшить потребление памяти и процессора.  Например, если у вас есть колонка, которая должна хранить строковые значения, но количество значений, которые будут сохранены является ограниченным – например, колонка <code>genre</code> (жанр) в базе данных MP3-файлов, то вы можете уменьшить потреление памяти и увеличить скорость работы, путем использования функции <code>value-normalizer</code> для интернирования (FIXME intern - написать что это такое) строк (преобразовать все вызовы <code>STRING=</code> к одному объекту-строке).  Так что вам нужно будет иметь столько строковых объектов, сколько у вас имеется различающихся строк, вне зависимости от того, сколько строк у вас в таблице, и вы тогда сможете использовать для сравнения функцию <code>EQL</code>, а не <code>STRING=</code>, которая является более медленной.<a class="fn_top" id="fnt__1" href="practical-an-mp3-database#fn__1">1)</a>
</p>
</div><div class="chapter" id="&#x41E;&#x43F;&#x440;&#x435;&#x434;&#x435;&#x43B;&#x435;&#x43D;&#x438;&#x435; &#x441;&#x445;&#x435;&#x43C;&#x44B; &#x431;&#x430;&#x437;&#x44B; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;"><h3>Определение схемы базы данных</h3>

<p>Таким образом, чтобы создать экземпляр таблицы, вам необходимо создать список объектов <code>column</code> objects.  Вы можете создать такой список вручную, используя функции <code>LIST</code> и <code>MAKE-INSTANCE</code>.  Но вы скоро заметите, что вы часто создаете множество объектов <code>column</code> с одинаковыми комбинациями функций <code>comparator</code> и <code>equality-predicate</code>. Это происходит оттого, что комбинация функций сравнения по существу определяет тип колонки. Было бы хорошо, если бы был способ определить имена для этих типов, что позволит вам просто указывать, что конкретная колонка является строковй, вместо того, чтобы указывать <code>STRING&lt;</code> и <code>STRING=</code> в качестве функций сравнения.  Одним из способов решения этой проблемы является определение обобщенной функции, <code>make-column</code>, например, вот так:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defgen.htm" class="symbol"><i><span class="symbol">defgeneric</span></i></a> make-column <span class="paren2">(<span class="">name <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_type.htm" class="symbol">type</a> &amp;optional <i><span class="symbol">default-value</span></i></span>)</span></span>)</span><br/></pre>

<p>Теперь вы можете определять методы данной обобщенной функции, специализированные для типа, с использованием <code>EQL</code>, которые будут возвращать объекты <code>column</code> со слотами, заполненными соответствующими значениями.  Вот определения для методов, которые определяют типы колонок с именами <code>string</code> и <code>number</code>:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> make-column <span class="paren2">(<span class="">name <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_type.htm" class="symbol">type</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a> '<a href="http://www.lispworks.com/reference/HyperSpec/Body/a_string.htm" class="symbol">string</a></span>)</span></span>)</span> &amp;optional <i><span class="symbol">default-value</span></i></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_ins.htm" class="symbol">make-instance</a><br/>   'column <br/>   <span class="keyword">:name</span> name<br/>   <span class="keyword">:comparator</span> #'string&lt; <br/>   <span class="keyword">:equality-predicate</span> #'<a href="http://www.lispworks.com/reference/HyperSpec/Body/f_stgeq_.htm" class="symbol">string=</a><br/>   <span class="keyword">:default-value</span> <i><span class="symbol">default-value</span></i><br/>   <span class="keyword">:value-normalizer</span> #'not-nullable</span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> make-column <span class="paren2">(<span class="">name <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_type.htm" class="symbol">type</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a> '<a href="http://www.lispworks.com/reference/HyperSpec/Body/t_number.htm" class="symbol">number</a></span>)</span></span>)</span> &amp;optional <i><span class="symbol">default-value</span></i></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_ins.htm" class="symbol">make-instance</a> <br/>   'column<br/>   <span class="keyword">:name</span> name<br/>   <span class="keyword">:comparator</span> #'&lt; <br/>   <span class="keyword">:equality-predicate</span> #'=<br/>   <span class="keyword">:default-value</span> <i><span class="symbol">default-value</span></i></span>)</span></span>)</span><br/></pre>

<p>Следующая функция –  <code>not-nullable</code>, используется в качестве значения <code>value-normalizer</code> для строковых колонок, и просто возвращает переданное значение для всех случаев, кроме тех, когда ей передают значение <code>NIL</code>, когда она сигнализирует об ошибке:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> not-nullable <span class="paren2">(<span class="">value column</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_or.htm" class="symbol">or</a> value <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_error.htm" class="symbol">error</a> <span class="string">"Column ~a can't be null"</span> <span class="paren4">(<span class="">name column</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Это важно, поскольку вызовы <code>STRING&lt;</code> и <code>STRING=</code> будут выдавать ошибку, если им будут передан <code>NIL</code>; лучше перехватить неправильные значения до того, как они будут вставлены в таблицу, а не тогда, когда мы будем их использовать.<a class="fn_top" id="fnt__2" href="practical-an-mp3-database#fn__2">2)</a>
</p>
<p>Еще одним типом колонки, который понадобится для базы данных MP3 является <code>interned-string</code>, чьи значения интернируются, как это обсуждалось выше.  Поскольку вам нужна хэш-таблица, в которую вы будете интернировать значения, вы должны определить подкласс <code>column</code> – <code>interned-values-column</code>, который добавит еще один слот, чьим значением будет хэш-таблица, которая будет использоваться для интернирования.
</p>
<p>Для реализации интернирования, вам потребуется указать в качестве <code>:initform</code> для слота <code>value-normalizer</code> функцию, которая будет интернировать значение в хэш-таблицу, которая хранится в колонке <code>interned-values</code>.  И поскольку, одна из самых главных причин интенирования значений – возможность использования <code>EQL</code> в качестве функции равенства, то вы также должны добавить <code>#'eql</code> в качестве значения <code>:initform</code> для слота <code>equality-predicate</code>.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defcla.htm" class="symbol"><i><span class="symbol">defclass</span></i></a> interned-values-column <span class="paren2">(<span class="">column</span>)</span><br/>  <span class="paren2">(<span class=""><span class="paren3">(<span class="">interned-values<br/>    <span class="keyword">:reader</span> interned-values<br/>    <span class="keyword">:initform</span> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_has.htm" class="symbol">make-hash-table</a> <span class="keyword">:test</span> #'<a href="http://www.lispworks.com/reference/HyperSpec/Body/f_equal.htm" class="symbol">equal</a></span>)</span></span>)</span><br/>   <span class="paren3">(<span class="">equality-predicate <span class="keyword">:initform</span> #'<a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a></span>)</span><br/>   <span class="paren3">(<span class="">value-normalizer   <span class="keyword">:initform</span> #'intern-for-column</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> intern-for-column <span class="paren2">(<span class="">value column</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">hash <span class="paren5">(<span class="">interned-values column</span>)</span></span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_or.htm" class="symbol">or</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_gethas.htm" class="symbol">gethash</a> <span class="paren5">(<span class="">not-nullable value column</span>)</span> hash</span>)</span><br/>        <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_gethas.htm" class="symbol">gethash</a> value hash</span>)</span> value</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Затем вы можете определить метод <code>make-column</code> специализированный для имени <code>interned-string</code>, который будет возвращать экземпляр <code>interned-values-column</code>.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> make-column <span class="paren2">(<span class="">name <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_type.htm" class="symbol">type</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a> 'interned-string</span>)</span></span>)</span> &amp;optional <i><span class="symbol">default-value</span></i></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_ins.htm" class="symbol">make-instance</a> <br/>   'interned-values-column<br/>   <span class="keyword">:name</span> name<br/>   <span class="keyword">:comparator</span> #'string&lt; <br/>   <span class="keyword">:default-value</span> <i><span class="symbol">default-value</span></i></span>)</span></span>)</span><br/></pre>

<p>С помощью данных методов, определенных для  <code>make-column</code>, вы теперь можете определить функцию, <code>make-schema</code>, которая создат список объектов типа <code>column</code> из списка описаний колонок, каждое из которых содержит имя колонки, имя типа колонки, и, необязательно, значение по умолчанию.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> make-schema <span class="paren2">(<span class="">spec</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mapc_.htm" class="symbol">mapcar</a> #'<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren4">(<span class="">column-spec</span>)</span> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_apply.htm" class="symbol">apply</a> #'make-column column-spec</span>)</span></span>)</span> spec</span>)</span></span>)</span><br/></pre>

<p>Например, с помощью следующего кода вы можете определить схему для таблицы, которая будет использоваться для хранения данных, извлеченных из файлов MP3:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defpar.htm" class="symbol"><i><span class="symbol">defparameter</span></i></a> <span class="special">*mp3-schema*</span> <br/>  <span class="paren2">(<span class="">make-schema <br/>   '<span class="paren3">(<span class=""><span class="paren4">(<span class=""><span class="keyword">:file</span>     <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_string.htm" class="symbol">string</a></span>)</span><br/>     <span class="paren4">(<span class=""><span class="keyword">:genre</span>    interned-string <span class="string">"Unknown"</span></span>)</span><br/>     <span class="paren4">(<span class=""><span class="keyword">:artist</span>   interned-string <span class="string">"Unknown"</span></span>)</span><br/>     <span class="paren4">(<span class=""><span class="keyword">:album</span>    interned-string <span class="string">"Unknown"</span></span>)</span><br/>     <span class="paren4">(<span class=""><span class="keyword">:song</span>     <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_string.htm" class="symbol">string</a></span>)</span><br/>     <span class="paren4">(<span class=""><span class="keyword">:track</span>    <a href="http://www.lispworks.com/reference/HyperSpec/Body/t_number.htm" class="symbol">number</a> 0</span>)</span><br/>     <span class="paren4">(<span class=""><span class="keyword">:year</span>     <a href="http://www.lispworks.com/reference/HyperSpec/Body/t_number.htm" class="symbol">number</a> 0</span>)</span><br/>     <span class="paren4">(<span class=""><span class="keyword">:id3-size</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/t_number.htm" class="symbol">number</a></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Чтобы создать саму таблицу для хранения информации о файлах MP3, вы должны передать <code>*mp3-schema*</code> в качестве аргумента <code>:schema</code> функции <code>MAKE-INSTANCE</code>.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defpar.htm" class="symbol"><i><span class="symbol">defparameter</span></i></a> <span class="special">*mp3s*</span> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_ins.htm" class="symbol">make-instance</a> 'table <span class="keyword">:schema</span> <span class="special">*mp3-schema*</span></span>)</span></span>)</span><br/></pre>

</div><div class="chapter" id="&#x412;&#x441;&#x442;&#x430;&#x432;&#x43A;&#x430; &#x437;&#x43D;&#x430;&#x447;&#x435;&#x43D;&#x438;&#x439;"><h3>Вставка значений</h3>

<p>Сейчас вы готовы к тому, чтобы определить вашу первую операцию для работы с таблицами – <code>insert-row</code>, которая получает список свойств (plist) имен и значений, и таблицу, и добавляет строку к таблице.  Большая часть работы выполняется в дополнительной функции  <code>normalize-row</code>, которая создает список свойств для всех колонок таблицы, используя  нормализованные значения и значения по умолчанию, которые получаются из слотов <code>names-and-values</code>, если значение было указано, или  <code>default-value</code> если значение для конкретной колонки не было указано.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> insert-row <span class="paren2">(<span class="">names-and-values table</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_vec_ps.htm" class="symbol">vector-push-extend</a> <span class="paren3">(<span class="">normalize-row names-and-values <span class="paren4">(<span class="">schema table</span>)</span></span>)</span> <span class="paren3">(<span class="">rows table</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> normalize-row <span class="paren2">(<span class="">names-and-values schema</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a><br/>     for column in schema<br/>     for name  = <span class="paren3">(<span class="">name column</span>)</span><br/>     for value = <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_or.htm" class="symbol">or</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> names-and-values name</span>)</span> <span class="paren4">(<span class=""><i><span class="symbol">default-value</span></i> column</span>)</span></span>)</span><br/>     collect name<br/>     collect <span class="paren3">(<span class="">normalize-for-column value column</span>)</span></span>)</span></span>)</span><br/></pre>

<p>Создание дополнительной функции <code>normalize-for-column</code>, которая получает значение, и объект  <code>column</code> и возвращает нормализованное значение, оправдано тем, что вам будет проводить нормализацию значений при запросах к таблице.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> normalize-for-column <span class="paren2">(<span class="">value column</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_funcal.htm" class="symbol">funcall</a> <span class="paren3">(<span class="">value-normalizer column</span>)</span> value column</span>)</span></span>)</span><br/></pre>

<p>Теперь вы готовы к объединению кода базы данных с кодом из предыдущих глав, чтобы построить базу данных, содержащую информацию выделенную из файлов MP3.  Вы можете определить функцию <code>file-&gt;row</code>, которая будет использовать функцию <code>read-id3</code> из библиотеки  <code>ID3v2</code> для выделения тагов ID3 из файла, и превращения их в список свойств, который будет передан функции <code>insert-row</code>.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> file-&gt;row <span class="paren2">(<span class="">file</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">id3 <span class="paren5">(<span class="">read-id3 file</span>)</span></span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a><br/>     <span class="keyword">:file</span>   <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_namest.htm" class="symbol">namestring</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_tn.htm" class="symbol">truename</a> file</span>)</span></span>)</span><br/>     <span class="keyword">:genre</span>  <span class="paren4">(<span class="">translated-genre id3</span>)</span><br/>     <span class="keyword">:artist</span> <span class="paren4">(<span class="">artist id3</span>)</span><br/>     <span class="keyword">:album</span>  <span class="paren4">(<span class="">album id3</span>)</span><br/>     <span class="keyword">:song</span>   <span class="paren4">(<span class="">song id3</span>)</span><br/>     <span class="keyword">:track</span>  <span class="paren4">(<span class="">parse-track <span class="paren5">(<span class="">track id3</span>)</span></span>)</span><br/>     <span class="keyword">:year</span>   <span class="paren4">(<span class="">parse-year <span class="paren5">(<span class="">year id3</span>)</span></span>)</span><br/>     <span class="keyword">:id3-size</span> <span class="paren4">(<span class="">size id3</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Вам не нужно беспокоиться о нормализации значений, поскольку это будет сделано в <code>insert-row</code>.  Однако, вы должны сконвертировать строки, возвращенные функциями <code>track</code> и <code>year</code> в числа.  Число <code>track</code> (номер композиции) – это таг ID3, который иногда сохраняется как число в виде строки, и иногда как число, за которым следует (через знак слеш) еще одно число, обозначающее количество композиций в альбоме.  Поскольку нам нужен только номер композиции, то вы должны использовать аргумент <code>:end</code> при вызове функции <code>PARSE-INTEGER</code> для того, чтобы указать что разбор должен осуществляться только до знака слеш, если он есть.<a class="fn_top" id="fnt__3" href="practical-an-mp3-database#fn__3">3)</a>
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> parse-track <span class="paren2">(<span class="">track</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> track <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_parse_.htm" class="symbol">parse-integer</a> track <span class="keyword">:end</span> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_pos_p.htm" class="symbol">position</a> <span class="character">#\/</span> track</span>)</span></span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> parse-year <span class="paren2">(<span class="">year</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> year <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_parse_.htm" class="symbol">parse-integer</a> year</span>)</span></span>)</span></span>)</span><br/></pre>

<p>В заключение, вы можете собрать все эти функции вместе с  <code>walk-directory</code> из библиотеки переносимых имен файлов, а также функцией  <code>mp3-p</code> из библиотеки <code>ID3v2</code> чтобы определить функцию, которая загружает в базу данных  MP3 информацию извлеченную из файлов  MP3, которые были найдены в определенном каталоге (и всех его подкаталогах).
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> load-database <span class="paren2">(<span class="">dir db</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_countc.htm" class="symbol">count</a> 0</span>)</span></span>)</span><br/>    <span class="paren3">(<span class="">walk-directory <br/>     dir <br/>     #'<span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren5">(<span class="">file</span>)</span><br/>         <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm" class="symbol">princ</a> <span class="character">#\.</span></span>)</span><br/>         <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_incf_.htm" class="symbol">incf</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_countc.htm" class="symbol">count</a></span>)</span><br/>         <span class="paren5">(<span class="">insert-row <span class="paren6">(<span class="">file-&gt;row file</span>)</span> db</span>)</span></span>)</span><br/>     <span class="keyword">:test</span> #'mp3-p</span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="string">"~&amp;В базу данных загружено ~d файлов."</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_countc.htm" class="symbol">count</a></span>)</span></span>)</span></span>)</span><br/></pre>

</div><div class="chapter" id="&#x412;&#x44B;&#x43F;&#x43E;&#x43B;&#x43D;&#x435;&#x43D;&#x438;&#x435; &#x437;&#x430;&#x43F;&#x440;&#x43E;&#x441;&#x43E;&#x432; &#x43A; &#x431;&#x430;&#x437;&#x435; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;"><h3>Выполнение запросов к базе данных</h3>

<p>После того, как загрузите данные в базу данных, вам необходимо найти способ выполнять запросы к ней.  Для приложения работающего с файлами MP3 вам понадобятся более сложные функции выполнения запросов чем те, которые были использованы в главе 3.  Сейчас вам нужна не только возможность извлекать строки отвечающие определенным критериям, но также и возможность делать выборку только определенных колонок, и возможно, сортировать строки по определенной колонке.  В соответствии с теорией реляционных баз данных, результатом запроса будет новая таблица, содержащая строки и колонки.
</p>
<p>В качестве образца для функции выполнения запросов – <code>select</code> , был взят оператор  <code>SELECT</code>  из языка SQL. Эта функция принимает пять именованных параметров: <code>:from</code>, <code>:columns</code>, <code>:where</code>, <code>:distinct</code> и <code>:order-by</code>.  Аргумент <code>:from</code> указывает объект  <code>table</code> для которого вы хотите выполнить запрос.  Аргумент  <code>:columns</code> указывает то, какие колонки должны быть включены в результат.  В качестве значения должен быть указан список имен колонок, имя одной колонки или  <code>T</code> (значение по умолчанию), указывающее, что должны быть включены все колонки.   Аргумент <code>:where</code> (если он указан), должен быть функцией, которая получает строку, и возвращает истинное значение, если эта строка должна быть включена в результаты.  Немного спустя, вы напишете две функции – <code>matching</code> и <code>in</code>, которые возвращают функции, допустимые для использования в качестве аргумента <code>:where</code>.  Аргумент <code>:order-by</code> (если он указан), должен быть списком имен колонок;  результаты будут отсортированы по соответствующим колонкам.  Также как и для аргумента <code>:columns</code>, вы можете указать лишь одну колонку, просто используя ее имя, что эквивалентно списку из одного элемента.  В заключение, аргумент <code>:distinct</code> является логическим значением, которое указывает – должны ли мы удалять дублирующиеся строки из результата.  Значением по умолчанию для <code>:distinct</code> является <code>NIL</code>.
</p>
<p>Вот несколько примеров использования <code>select</code>:
</p>
<pre class="code"><span class="comment">;; Выбрать все строки где колонка :artist равна "Green Day"<br/></span><span class="paren1">(<span class="">select <span class="keyword">:from</span> <span class="special">*mp3s*</span> <span class="keyword">:where</span> <span class="paren2">(<span class="">matching <span class="special">*mp3s*</span> <span class="keyword">:artist</span> <span class="string">"Green Day"</span></span>)</span></span>)</span><br/><br/><span class="comment">;; Получить отсортированный список артистов, исполняющих песни в жанре "Rock"<br/></span><span class="paren1">(<span class="">select<br/>  <span class="keyword">:columns</span> <span class="keyword">:artist</span><br/>  <span class="keyword">:from</span> <span class="special">*mp3s*</span><br/>  <span class="keyword">:where</span> <span class="paren2">(<span class="">matching <span class="special">*mp3s*</span> <span class="keyword">:genre</span> <span class="string">"Rock"</span></span>)</span><br/>  <span class="keyword">:distinct</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a><br/>  <span class="keyword">:order-by</span> <span class="keyword">:artist</span></span>)</span><br/></pre>

<p>Реализация <code>select</code> вместе со вспомогательными функциями выглядит примерно так:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> select <span class="paren2">(<span class="">&amp;key <span class="paren3">(<span class="">columns <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span> from where distinct order-by</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">rows <span class="paren5">(<span class="">rows from</span>)</span></span>)</span><br/>        <span class="paren4">(<span class="">schema <span class="paren5">(<span class="">schema from</span>)</span></span>)</span></span>)</span><br/><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> where<br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> rows <span class="paren5">(<span class="">restrict-rows rows where</span>)</span></span>)</span></span>)</span><br/><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">unless</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a> columns '<a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> schema <span class="paren5">(<span class="">extract-schema <span class="paren6">(<span class="">mklist columns</span>)</span> schema</span>)</span></span>)</span><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> rows <span class="paren5">(<span class="">project-columns rows schema</span>)</span></span>)</span></span>)</span><br/><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> distinct<br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> rows <span class="paren5">(<span class="">distinct-rows rows schema</span>)</span></span>)</span></span>)</span><br/><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> order-by<br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> rows <span class="paren5">(<span class="">sorted-rows rows schema <span class="paren6">(<span class="">mklist order-by</span>)</span></span>)</span></span>)</span></span>)</span><br/><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_ins.htm" class="symbol">make-instance</a> 'table <span class="keyword">:rows</span> rows <span class="keyword">:schema</span> schema</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> mklist <span class="paren2">(<span class="">thing</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_listp.htm" class="symbol">listp</a> thing</span>)</span> thing <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> thing</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> extract-schema <span class="paren2">(<span class="">column-names schema</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for c in column-names collect <span class="paren3">(<span class="">find-column c schema</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> find-column <span class="paren2">(<span class="">column-name schema</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_or.htm" class="symbol">or</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_find_.htm" class="symbol">find</a> column-name schema <span class="keyword">:key</span> #'name</span>)</span><br/>      <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_error.htm" class="symbol">error</a> <span class="string">"No column: ~a in schema: ~a"</span> column-name schema</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> restrict-rows <span class="paren2">(<span class="">rows where</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rm_rm.htm" class="symbol">remove-if-not</a> where rows</span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> project-columns <span class="paren2">(<span class="">rows schema</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_map.htm" class="symbol">map</a> '<a href="http://www.lispworks.com/reference/HyperSpec/Body/a_vector.htm" class="symbol">vector</a> <span class="paren3">(<span class="">extractor schema</span>)</span> rows</span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> distinct-rows <span class="paren2">(<span class="">rows schema</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rm_dup.htm" class="symbol">remove-duplicates</a> rows <span class="keyword">:test</span> <span class="paren3">(<span class="">row-equality-tester schema</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> sorted-rows <span class="paren2">(<span class="">rows schema order-by</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_sort_.htm" class="symbol">sort</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_cp_seq.htm" class="symbol">copy-seq</a> rows</span>)</span> <span class="paren3">(<span class="">row-comparator order-by schema</span>)</span></span>)</span></span>)</span><br/></pre>

<p>Конечно, самыми интересными частями <code>select</code> является реализация функций <code>extractor</code>, <code>row-equality-tester</code> и <code>row-comparator</code>.
</p>
<p>Как вы можете заключить из того, как эти функции используются, каждая из этих функций должна возвращать новую функцию.  Например, функция <code>project-columns</code> использует значение, возвращенное функцией  <code>extractor</code> в качестве аргумента функции <code>MAP</code>.  Поскольку  <code>project-columns</code> предназначена для возврата набора строк с только определенными значениями колонок, вы можете заключить, что  <code>extractor</code> возвращает функций, которая получает строку в качестве аргумента, и возвращает новую строку, которая содержит только колонки, указанные в переданной ей схеме.  Вот как мы можем реализовать эту функцию:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> extractor <span class="paren2">(<span class="">schema</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">names <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mapc_.htm" class="symbol">mapcar</a> #'name schema</span>)</span></span>)</span></span>)</span><br/>    #'<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren4">(<span class="">row</span>)</span><br/>        <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for c in names collect c collect <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> row c</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Отметьте то, как вы можете выполнить задачу по извлечению имен из схемы за пределами тела замыкания – поскольку замыкание может быть вызвано несколько раз, вы захотите чтобы в нем выполнялось как можно меньше действий при каждом вызове.
</p>
<p>Функции <code>row-equality-tester</code> и <code>row-comparator</code> реализуются аналогичным образом.  Для того, чтобы принять решение о равенстве двух строк, вам необходимо применить соответствующие функции сравнения  каждой из колонок к значениям соответствующих колонок.  Из материала главы 22 мы знаем, что  <code>LOOP</code> всегда возвращает  <code>NIL</code> когда пара значений не проходит тест, в противном случае <code>LOOP</code> вернет <code>T</code>.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> row-equality-tester <span class="paren2">(<span class="">schema</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">names <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mapc_.htm" class="symbol">mapcar</a> #'name schema</span>)</span></span>)</span><br/>        <span class="paren4">(<span class="">tests <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mapc_.htm" class="symbol">mapcar</a> #'equality-predicate schema</span>)</span></span>)</span></span>)</span><br/>    #'<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren4">(<span class="">a b</span>)</span><br/>        <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for name in names <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_and.htm" class="symbol">and</a> test in tests<br/>           always <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_funcal.htm" class="symbol">funcall</a> test <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> a name</span>)</span> <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> b name</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Расположение двух строк по порядку – более сложная задача.  В Lisp функции сравнения возвращают истинное значение, если первый аргумент должен быть расположен перед вторым аргументом, или <code>NIL</code> в противном случае.  Таким образом, <code>NIL</code> может означать, что второй аргумент должен быть расположен перед первым аргументом, или оба аргумента равны. Мы также хотим, чтобы функции сравненпия строк вели себя точно также – возвращали <code>T</code> если первая строка должна быть перед второй, и <code>NIL</code> в противном случае.
</p>
<p>Таким образом, для сравнения двух строк, вы должны сравнить значения тех колонок, по которым вы будете проводить сортировку, используя соответствующую функцию сравнения для каждой из колонок.  Сначала вызывается функция сравнения со значением из первой строки в качестве первого аргумента.  Если функция сравнения вернет истинное значение, то это означает, что первая колонка точно должна распологаться перед второй колонкой, так что вы можете сразу вернуть значение <code>T</code>.
</p>
<p>Но если функция сравнения вернула <code>NIL</code>, то вам нужно определить почему это произошло – либо второе значение должно быть поставлено перед первым, или они равны.  Так что вам необходимо снова вернуть функцию сравнения, но поменять аргументы местами.  Если функция сравнения вернет истинное значение, то это означает, что вторая строка должна стоять перед первой, и вы можете сразу вернуть <code>NIL</code>.  В противном случае, значения в данной колонке равны, и вам необходимо перейти к следующей колонке.  Если вы проверите все колонки и не получите однозначного сравнения в пользу одной из строк, то эти строки равны, и вы должны вернуть <code>NIL</code>.  Функция, которая реализует такой алгоритм, будет выглядеть следующим образом:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> row-comparator <span class="paren2">(<span class="">column-names schema</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">comparators <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mapc_.htm" class="symbol">mapcar</a> #'comparator <span class="paren6">(<span class="">extract-schema column-names schema</span>)</span></span>)</span></span>)</span></span>)</span><br/>    #'<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren4">(<span class="">a b</span>)</span><br/>        <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a><br/>           for name in column-names<br/>           for comparator in comparators<br/>           for a-value = <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> a name</span>)</span><br/>           for b-value = <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> b name</span>)</span><br/>           <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_funcal.htm" class="symbol">funcall</a> comparator a-value b-value</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_return.htm" class="symbol">return</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a><br/>           <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_funcal.htm" class="symbol">funcall</a> comparator b-value a-value</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_return.htm" class="symbol">return</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a><br/>           finally <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_return.htm" class="symbol">return</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

</div><div class="chapter" id="&#x424;&#x443;&#x43D;&#x43A;&#x446;&#x438;&#x438; &#x43E;&#x442;&#x431;&#x43E;&#x440;&#x430; (FIXME Matching)"><h3>Функции отбора (FIXME Matching)</h3>

<p>Аргумент <code>:where</code> функции <code>select</code> может быть любой функцией, которая принимает в качестве аргумента строку и возвращает истинное значение, если она должна быть включена в результаты.  Однако на практике, вам редко понадобится вся мощь вручную написанного кода для выражения критериев запроса.  Так что вы должны лишь реализовать две функции: <code>matching</code> и <code>in</code>, которые будут создавать функции запроса, которые позволят вам создавать общие виды запросов, а также возьмут на себя заботу об использовании соответствующих функций равенства и нормализации для каждой из колонок.
</p>
<p>FIXME The workhouse <code>query-function</code> constructor will be функция <code>matching</code>, которая возвращает функцию, которая будет сравнивать строку с конкретными значениями колонок.  Вы увидели как она может быть использована в предыдущих примерах <code>select</code>.  Например, такой вызов <code>matching</code>:
</p>
<pre class="code"><span class="paren1">(<span class="">matching <span class="special">*mp3s*</span> <span class="keyword">:artist</span> <span class="string">"Green Day"</span></span>)</span><br/></pre>

<p>вернет функцию, которая будет выбирать строки, в которых значение колонки <code>:artist</code> равно <code>"Green Day"</code>.  Вы также можете передавать множество имен колонок и значений – возвращаемая функция будет возвращать истинное значение только тогда, когда все колонки имеют заданные значения.  Например, следующий вызов вернет замыкание, которое будет принимать строки, в которых артист равен <code>"Green Day"</code> и альбом равен <code>"American Idiot"</code>:
</p>
<pre class="code"><span class="paren1">(<span class="">matching <span class="special">*mp3s*</span> <span class="keyword">:artist</span> <span class="string">"Green Day"</span> <span class="keyword">:album</span> <span class="string">"American Idiot"</span></span>)</span><br/></pre>

<p>Вам необходимо передать функции <code>matching</code> объект <code>table</code>, поскольку функции необходим доступ к схеме таблицы для получения функций сравнения и нормализации для тех колонок, для которых выполняется отбор данных.
</p>
<p>Вы строите функцию, возвращаемую функцией  <code>matching</code> из меньших функций, каждая из которые отвечает за проверку значения одной из колонок.  Для того, чтобы создать эти функции, вы должны определить функцию <code>column-matcher</code>, которая получает объект  <code>column</code> и не нормализованное значение и возвращает функцию, которая получает строку и возвращает истинное значение в том случае, если значение заданной колонки соответствует нормализованному значению заданного аргумента.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> column-matcher <span class="paren2">(<span class="">column value</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">name <span class="paren5">(<span class="">name column</span>)</span></span>)</span><br/>        <span class="paren4">(<span class="">predicate <span class="paren5">(<span class="">equality-predicate column</span>)</span></span>)</span><br/>        <span class="paren4">(<span class="">normalized <span class="paren5">(<span class="">normalize-for-column value column</span>)</span></span>)</span></span>)</span><br/>    #'<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren4">(<span class="">row</span>)</span> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_funcal.htm" class="symbol">funcall</a> predicate <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> row name</span>)</span> normalized</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Затем вы создаете список функций <code>column-matching</code> для заданных имен и значений, переданных функции <code>column-matchers</code>:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> column-matchers <span class="paren2">(<span class="">schema names-and-values</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for <span class="paren3">(<span class="">name value</span>)</span> on names-and-values by #'<a href="http://www.lispworks.com/reference/HyperSpec/Body/f_car_c.htm" class="symbol">cddr</a><br/>     <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> value collect<br/>       <span class="paren3">(<span class="">column-matcher <span class="paren4">(<span class="">find-column name schema</span>)</span> value</span>)</span></span>)</span></span>)</span><br/></pre>

<p>Теперь вы можете реализовать <code>matching</code>.  Снова, заметьте, что вы делаете как можно больше работы за пределами замыкания, чтобы выполнить эти операции один раз при создании замыкания, а не при его вызове для каждой из строк таблицы.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> matching <span class="paren2">(<span class="">table &amp;rest names-and-values</span>)</span><br/>  <span class="string">"Build a where function that matches rows with the given column values."</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">matchers <span class="paren5">(<span class="">column-matchers <span class="paren6">(<span class="">schema table</span>)</span> names-and-values</span>)</span></span>)</span></span>)</span><br/>    #'<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren4">(<span class="">row</span>)</span><br/>        <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_everyc.htm" class="symbol">every</a> #'<span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren6">(<span class="">matcher</span>)</span> <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_funcal.htm" class="symbol">funcall</a> matcher row</span>)</span></span>)</span> matchers</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Эта функция выглядит как небольшой клубок замыканий, но стоит пристальней посмотреть на нее для того, чтобы получить "наслаждение" (FIXME flavor) от возможности программирования с функциями как объекты первого класса(FIXME?)
</p>
<p>Задачей <code>matching</code> является возврат функции, которая будет выполняться для каждой строки в таблице для того, чтобы определить – должна ли эта строка быть включена в результат, или нет.  Так что функция <code>matching</code> возвращает замыкание принимающее один параметр – строку <code>row</code>.
</p>
<p>Теперь вспомните, что функция <code>EVERY</code> принимает фунцию-предикат в качестве первого аргумента, и возвращает истинное значение, только если функция будет возвращать истинное значение для каждого из элементов списка, который передан <code>EVERY</code> в качестве второго аргумента.  Однако, в нашем случае список, переданный <code>EVERY</code> является списком функций – функций отбора для конкретных колонок.  Все что вам нужно знать – это то, что каждая функция отбора колонки, при запуске для строки, для которой вы проводите проверку, возвращает истинное значение.  Так что в качестве функции-предиката для <code>EVERY</code> вы передаете еще одно замыкание, которое применит <code>FUNCALL</code> к функции отбора колонки, передав ей параметр <code>row</code>.
</p>
<p>Другой полезной функцией отбора является  <code>in</code>, которая возвращает функцию, которая отбирает строки, где значение определенной колонки входит в заданный набор значений.  Функция  <code>in</code> будет принимать два аргумента – имя колонки, и таблицу, которая содержит значения, с которыми вы будете сравнивать.  Предположим, например, что вы хотите найти все песни в базе данных  MP3, у которых названия совпадают с названиями песен исполняемых <em>Dixie Chicks</em>.  Вы можете написать это выражение <code>where</code> используя функцию <code>in</code> и вспомогательный запрос, например, вот так:<a class="fn_top" id="fnt__4" href="practical-an-mp3-database#fn__4">4)</a>
</p>
<pre class="code"><span class="paren1">(<span class="">select<br/>  <span class="keyword">:columns</span> '<span class="paren2">(<span class=""><span class="keyword">:artist</span> <span class="keyword">:song</span></span>)</span><br/>  <span class="keyword">:from</span> <span class="special">*mp3s*</span><br/>  <span class="keyword">:where</span> <span class="paren2">(<span class="">in <span class="keyword">:song</span> <br/>             <span class="paren3">(<span class="">select<br/>               <span class="keyword">:columns</span> <span class="keyword">:song</span><br/>               <span class="keyword">:from</span> <span class="special">*mp3s*</span><br/>               <span class="keyword">:where</span> <span class="paren4">(<span class="">matching <span class="special">*mp3s*</span> <span class="keyword">:artist</span> <span class="string">"Dixie Chicks"</span></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Хотя запросы более сложные, но реализация <code>in</code> намного проще чем реализация <code>matching</code>.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> in <span class="paren2">(<span class="">column-name table</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">test <span class="paren5">(<span class="">equality-predicate <span class="paren6">(<span class="">find-column column-name <span class="paren1">(<span class="">schema table</span>)</span></span>)</span></span>)</span></span>)</span><br/>        <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_values.htm" class="symbol">values</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_map.htm" class="symbol">map</a> '<a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> #'<span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren1">(<span class="">r</span>)</span> <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> r column-name</span>)</span></span>)</span> <span class="paren6">(<span class="">rows table</span>)</span></span>)</span></span>)</span></span>)</span><br/>    #'<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren4">(<span class="">row</span>)</span><br/>        <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_member.htm" class="symbol">member</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> row column-name</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_values.htm" class="symbol">values</a> <span class="keyword">:test</span> test</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

</div><div class="chapter" id="&#x420;&#x430;&#x431;&#x43E;&#x442;&#x430; &#x441; &#x440;&#x435;&#x437;&#x443;&#x43B;&#x44C;&#x442;&#x430;&#x442;&#x430;&#x43C;&#x438; &#x432;&#x44B;&#x43F;&#x43E;&#x43B;&#x43D;&#x435;&#x43D;&#x438;&#x44F; &#x437;&#x430;&#x43F;&#x440;&#x43E;&#x441;&#x43E;&#x432;"><h3>Работа с результатами выполнения запросов</h3>

<p>Поскольку <code>select</code> возвращает другую таблицу, вам необходимо немного подумать о том, как
вы будете осуществлять доступ к отдельным значениям.  Если вы уверены, что вы никогда не
измените способ представления данных в таблице, то вы можете просто сделать структуру
таблицы частью API и указать, что класс <code>table</code> имеет слот <code>rows</code> который является
вектором содержащим списки свойств, и для доступа к данным в таблице использовать
стандартные функции Common Lisp для работы с векторами и списками свойств.  Но
представление данных – это внутренняя деталь, которую вы можете захотеть изменить.  Также
вы можете не захотеть, чтобы другие разработчики напрямую работали с данными, например, вы
можете захотеть, чтобы никто не мог с помощью <code>SETF</code> вставить в строку ненормализованное
значение.  Так что хорошей идеей может быть определение нескольких абстракций, которые будут обеспечивать нужные вам операции.  Так что, если вы захотите изменить внутреннее представление данных, то вам нужно будет изменить только реализацию этих функций и макросов.  И хотя Common Lisp не позволяет вам полностью запретить доступ к "внутренним" данным, путем предоставления официального API вы по крайней мере сможете указать где проходит граница, разграничивающая внешнее и внутреннее представление.
</p>
<p>Вероятно, наиболее часто используемой операцией с  результатами запроса будет итерация по отдельным строкам, и выделение значений конкретных колонок.  Так что вам нужно предоставить возможность для выполнения эти операций без прямого доступа к вектору строк или использования <code>GETF</code> для получения значения колонки внутри строки.
</p>
<p>Реализация этих операция является тривиальной – эти функции являются лишь врапперами вокруг кода, который бы вы написали, если у вас не было этих абстракций.  Вы можете предоставить два способа итерации по строкам таблицы:  макрос  <code>do-rows</code>, который обеспечивает базовый способ организации циклов, и функцию  <code>map-rows</code>, которая создает список, содержащий результаты применения заданной функции к каждой строке таблицы.<a class="fn_top" id="fnt__5" href="practical-an-mp3-database#fn__5">5)</a>
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmac.htm" class="symbol"><i><span class="symbol">defmacro</span></i></a> do-rows <span class="paren2">(<span class=""><span class="paren3">(<span class="">row table</span>)</span> &amp;body body</span>)</span><br/>  `<span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for ,row across <span class="paren3">(<span class="">rows ,table</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> ,@body</span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> map-rows <span class="paren2">(<span class="">fn table</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for row across <span class="paren3">(<span class="">rows table</span>)</span> collect <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_funcal.htm" class="symbol">funcall</a> fn row</span>)</span></span>)</span></span>)</span><br/></pre>

<p>Для получения значения конкретной колонки внутри строки, вы должны реализовать функцию <code>column-value</code>, которая будет принимать в качестве аргументов строку таблицы и название колонки, и будет возвращать соответствующее значение.  Опять же, это лишь тривиальный враппер вокруг кода, который бы вы и так написали.  Но если вы позже измените внутреннее представление данных, то пользователи <code>column-value</code> не будут об этом знать.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> column-value <span class="paren2">(<span class="">row column-name</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> row column-name</span>)</span></span>)</span><br/></pre>

<p>Хотя <code>column-value</code> является достаточной абстракцией доступа к значениям колонок, вам достаточно часто нужно получать одновременный доступ к значениям сразу нескольких колонок.  Так что мы реализуем макрос <code>with-column-values</code>, который будет связывать набор переменных со значениями извлеченными из строки используя соответствующие именованные параметры.  Так что вместо использования такого кода:
</p>
<pre class="code"><span class="paren1">(<span class="">do-rows <span class="paren2">(<span class="">row table</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">song <span class="paren5">(<span class="">column-value row <span class="keyword">:song</span></span>)</span></span>)</span><br/>        <span class="paren4">(<span class="">artist <span class="paren5">(<span class="">column-value row <span class="keyword">:artist</span></span>)</span></span>)</span><br/>        <span class="paren4">(<span class="">album <span class="paren5">(<span class="">column-value row <span class="keyword">:album</span></span>)</span></span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="string">"~a by ~a from ~a~%"</span> song artist album</span>)</span></span>)</span></span>)</span><br/></pre>

<p>вы можете просто написать следующим образом:
</p>
<pre class="code"><span class="paren1">(<span class="">do-rows <span class="paren2">(<span class="">row table</span>)</span><br/>  <span class="paren2">(<span class=""><i><span class="symbol">with-column-values</span></i> <span class="paren3">(<span class="">song artist album</span>)</span> row<br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="string">"~a by ~a from ~a~%"</span> song artist album</span>)</span></span>)</span></span>)</span><br/></pre>

<p>И снова, реализация не является очень сложной, если вы используете макрос  <code>once-only</code> из главы 8.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmac.htm" class="symbol"><i><span class="symbol">defmacro</span></i></a> <i><span class="symbol">with-column-values</span></i> <span class="paren2">(<span class=""><span class="paren3">(<span class="">&amp;rest vars</span>)</span> row &amp;body body</span>)</span><br/>  <span class="paren2">(<span class="">once-only <span class="paren3">(<span class="">row</span>)</span><br/>    `<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> ,<span class="paren4">(<span class="">column-bindings vars row</span>)</span> ,@body</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> column-bindings <span class="paren2">(<span class="">vars row</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for v in vars collect `<span class="paren3">(<span class="">,v <span class="paren4">(<span class="">column-value ,row ,<span class="paren5">(<span class="">as-keyword v</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> as-keyword <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/t_symbol.htm" class="symbol">symbol</a></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_intern.htm" class="symbol">intern</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_symb_2.htm" class="symbol">symbol-name</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/t_symbol.htm" class="symbol">symbol</a></span>)</span> <span class="keyword">:keyword</span></span>)</span></span>)</span><br/></pre>

<p>И в заключение, вы должны предоставить функции для получения количества строк в таблице, а также для доступа к конкретной строке используя числовой индекс.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> table-size <span class="paren2">(<span class="">table</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_length.htm" class="symbol">length</a> <span class="paren3">(<span class="">rows table</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> nth-row <span class="paren2">(<span class="">n table</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_aref.htm" class="symbol">aref</a> <span class="paren3">(<span class="">rows table</span>)</span> n</span>)</span></span>)</span><br/></pre>

</div><div class="chapter" id="&#x414;&#x440;&#x443;&#x433;&#x438;&#x435; &#x43E;&#x43F;&#x435;&#x440;&#x430;&#x446;&#x438;&#x438; &#x441; &#x431;&#x430;&#x437;&#x43E;&#x439; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;"><h3>Другие операции с базой данных</h3>

<p>И в заключение, вы реализуете несколько дополнительных операций с базой данных, которые будут использованы в главе 29.  Первые две из них являются аналогами выражения <code>DELETE</code> языка SQL.  Функция <code>delete-rows</code> используется для удаления из таблицы строк, соответствующих некоторому критерию.  Также как и <code>select</code> она принимает именованные аргументы <code>:from</code> и <code>:where</code>.  Но в отличии от <code>select</code>, эта функция не возвращает новую таблицу – вместо этого, она изменяет таблицу, переданную в качестве аргумента the <code>:from</code>.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> delete-rows <span class="paren2">(<span class="">&amp;key from where</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a><br/>     with rows = <span class="paren3">(<span class="">rows from</span>)</span><br/>     with store-idx = 0<br/>     for read-idx from 0<br/>     for row across rows<br/>     <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_aref.htm" class="symbol">aref</a> rows read-idx</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span><br/>     <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">unless</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_funcal.htm" class="symbol">funcall</a> where row</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a><br/>       <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_aref.htm" class="symbol">aref</a> rows store-idx</span>)</span> row</span>)</span><br/>       <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_incf_.htm" class="symbol">incf</a> store-idx</span>)</span><br/>     finally <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_fill_p.htm" class="symbol">fill-pointer</a> rows</span>)</span> store-idx</span>)</span></span>)</span></span>)</span><br/></pre>

<p>В интересах повышения производительности, вы можете также реализовать отдельную функцию для удаления всех строк из таблицы.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> delete-all-rows <span class="paren2">(<span class="">table</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren3">(<span class="">rows table</span>)</span> <span class="paren3">(<span class="">make-rows <span class="special">*default-table-size*</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Оставшиеся функции для работы с базой данных не имеют аналогов среди операций с реляционными базами данных, но они будут полезны при написании приложения использующего базу данных MP3.  Первой среди них является функция, которая сортирует строки таблицы изменяя ее.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> sort-rows <span class="paren2">(<span class="">table &amp;rest column-names</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren3">(<span class="">rows table</span>)</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_sort_.htm" class="symbol">sort</a> <span class="paren4">(<span class="">rows table</span>)</span> <span class="paren4">(<span class="">row-comparator column-names <span class="paren5">(<span class="">schema table</span>)</span></span>)</span></span>)</span></span>)</span><br/>  table</span>)</span><br/></pre>

<p>С другой стороны, в приложении, работающем с базой данных MP3, вам может понадобиться функция, которая перемешивает строки в таблице, используя функцию <code>nshuffle-vector</code> из главы 23.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> shuffle-table <span class="paren2">(<span class="">table</span>)</span><br/>  <span class="paren2">(<span class="">nshuffle-vector <span class="paren3">(<span class="">rows table</span>)</span></span>)</span><br/>  table</span>)</span><br/></pre>

<p>И в заключение, снова для приложения работающего с базой данных MP3, вы должны реализовать функцию которая будет выбирать <code>N</code> произвольных строк, возвращая результат в виде новой таблицы.  Эта функция также использует <code>nshuffle-vector</code> вместе с версией <code>random-sample</code>, основанной на <em>Алгоритме S</em> из книги "Искусство программирования, т.2.  Получисленные алгоритмы, 3 изд." Дональда Кнута, и который мы обсуждали в главе 20.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> random-selection <span class="paren2">(<span class="">table n</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_ins.htm" class="symbol">make-instance</a><br/>   'table<br/>   <span class="keyword">:schema</span> <span class="paren3">(<span class="">schema table</span>)</span><br/>   <span class="keyword">:rows</span> <span class="paren3">(<span class="">nshuffle-vector <span class="paren4">(<span class="">random-sample <span class="paren5">(<span class="">rows table</span>)</span> n</span>)</span></span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> random-sample <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_vector.htm" class="symbol">vector</a> n</span>)</span><br/>  <span class="string">"Based on Algorithm S from Knuth. TAOCP, vol. 2. p. 142"</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> with selected = <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_ar.htm" class="symbol">make-array</a> n <span class="keyword">:fill-pointer</span> 0</span>)</span><br/>     for idx from 0<br/>     <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a><br/>       <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a><br/>          with to-select = <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a__.htm" class="symbol">-</a> n <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_length.htm" class="symbol">length</a> selected</span>)</span></span>)</span><br/>          for remaining = <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a__.htm" class="symbol">-</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_length.htm" class="symbol">length</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_vector.htm" class="symbol">vector</a></span>)</span> idx</span>)</span><br/>          while <span class="paren4">(<span class="">&gt;= <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_st.htm" class="symbol">*</a> remaining <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_random.htm" class="symbol">random</a> 1.0</span>)</span></span>)</span> to-select</span>)</span><br/>          <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_incf_.htm" class="symbol">incf</a> idx</span>)</span></span>)</span><br/>       <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_vec_ps.htm" class="symbol">vector-push</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_aref.htm" class="symbol">aref</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_vector.htm" class="symbol">vector</a> idx</span>)</span> selected</span>)</span><br/>     <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="paren3">(<span class="">= <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_length.htm" class="symbol">length</a> selected</span>)</span> n</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_return.htm" class="symbol">return</a> selected</span>)</span></span>)</span><br/></pre>

<p>Имея данный код, вы будете готовы создать (в главе 29) веб-интерфейс для просмотра коллекции файлов в формате MP3.  Но до этого вам необходимо реализовать часть сервера, которая будет транслировать поток музыки в формате MP3 используя протокол Shoutcast, что и является темой следующей главы. 
</p></div></div><div class="footnotes"><div><a class="fn_bot" id="fn__1" href="practical-an-mp3-database#fnt__1">1)</a>Общим основанием для интернирования объектов явялется то, что когда вам нужно сравнивать определенное значение много раз, то стоит выполнит его интернирование, несмотря на некоторые затраты на эту операцию. Функция<code>value-normalizer</code> запускается один раз когда вы вставляете значение, и как вы увидите далее, один раз в начале каждого запроса. Поскольку запрос может приводить к выполнению <code>equality-predicate</code> для каждой из строк таблицы, то общие затраты на интернирование значений, быстро приближаются к нулю.</div><div><a class="fn_bot" id="fn__2" href="practical-an-mp3-database#fnt__2">2)</a>Как всегда, в книгах по программированию правильная обработка ошибок является поводом для сокращения; при разработке в реальных условиях, вы скорее всего определите специальный тип ошибки, и будете использовать его, вместо стандартного:

<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_error.htm" class="symbol">error</a> 'illegal-column-value <span class="keyword">:value</span> value <span class="keyword">:column</span> column</span>)</span><br/></pre>

Затем вы можете подумать о том, где вы можете добавить код перезапуска, который позволит вам восстановить последствия такой ошибки.  И в заключение, в почти любом приложении, вы должны установить обработчики событий, которые позволят выбрать соответствующий код перезапуска.</div><div><a class="fn_bot" id="fn__3" href="practical-an-mp3-database#fnt__3">3)</a>Если какой-то из файлов MP3 содержит неправильные данные в записях <code>track</code> и <code>year</code>, то <code>PARSE-INTEGER</code> может сигнализировать об ошибке. Одним из способов обойти это поведение – передать функции <code>PARSE-INTEGER</code> параметр <code>:junk-allowed</code> равный <code>T</code>, который заставит функцию игнорировать любой "мусор", который следует за числом, и вернуть <code>NIL</code> если чисо не было найдено в строке.  Или, если вы хотите попрактиковаться в использовании системы условий и перезапусков, то вы можете определить специальное значение <code>error</code> и использовать его в качестве сигнала из этих функций, в том случае если данные неправильно оформлены, а также установить несколько точек перезапуска, чтобы позволить этим функциям обработать эти ошибки.</div><div><a class="fn_bot" id="fn__4" href="practical-an-mp3-database#fnt__4">4)</a>Этот запрос также вернет вам все песни исполненяемые <em>Dixie Chicks</em>.  Если вы захотите ограничить этот запрос, чтобы он содержал только артистов, отличных от <em>Dixie Chicks</em>,  то вам нужна более сложная функция  <code>:where</code>.  Поскольку аргументом <code>:where</code> может быть любая функция, то это можно сделать; вы можете удалить собственные песни <em>Dixie Chicks</em>' с помощью вот такого запроса:

<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let*</span></i></a> <span class="paren2">(<span class=""><span class="paren3">(<span class="">dixie-chicks <span class="paren4">(<span class="">matching <span class="special">*mp3s*</span> <span class="keyword">:artist</span> <span class="string">"Dixie Chicks"</span></span>)</span></span>)</span><br/>       <span class="paren3">(<span class="">same-song <span class="paren4">(<span class="">in <span class="keyword">:song</span> <span class="paren5">(<span class="">select <span class="keyword">:columns</span> <span class="keyword">:song</span> <span class="keyword">:from</span> <span class="special">*mp3s*</span> <span class="keyword">:where</span> dixie-chicks</span>)</span></span>)</span></span>)</span><br/>       <span class="paren3">(<span class="">query #'<span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren5">(<span class="">row</span>)</span> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_and.htm" class="symbol">and</a> <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_not.htm" class="symbol">not</a> <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_funcal.htm" class="symbol">funcall</a> dixie-chicks row</span>)</span></span>)</span> <br/>                                   <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_funcal.htm" class="symbol">funcall</a> same-song row</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/>  <span class="paren2">(<span class="">select <span class="keyword">:columns</span> '<span class="paren3">(<span class=""><span class="keyword">:artist</span> <span class="keyword">:song</span></span>)</span> <span class="keyword">:from</span> <span class="special">*mp3s*</span> <span class="keyword">:where</span> query</span>)</span></span>)</span><br/></pre>

Однако это не особо удобно.  Если вы пишете приложение, которому требуется выполнять много сложных запросов, то вы можете захотеть придумать более выразительный язык запросов.</div><div><a class="fn_bot" id="fn__5" href="practical-an-mp3-database#fnt__5">5)</a>Версия  <code>LOOP</code> реализованная в  M.I.T. до стандартизации Common Lisp включала механизм для расширения грамматики  <code>LOOP</code>, которые бы позволяли реализовывать итерацию по новым структурам данных.  Некоторые реализации Common Lisp, которые унаследовали эту реализацию  <code>LOOP</code>, могут до сих пор иметь эту возможность, что делает  <code>do-rows</code> и <code>map-rows</code> не особо нужными.</div></div></div> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="practical-web-programming-with-allegroserve">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right"> <a href="practical-a-shoutcast-server">Следующая</a> </td> </tr> </tbody> </table> </div> <div class="bottom">@2009-2013 lisper.ru</div> 
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7734690-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
 </body> </html>