<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru"> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <meta name="keywords" content="Common Lisp,lisp,лисп" /> <title>Файлы и файловый ввод/вывод</title> <link href="../css/style.css" rel="stylesheet" type="text/css" /><link href="../css/colorize.css" rel="stylesheet" type="text/css" />  </head> <body> <div class="top"> <div id="login"> <a href="http://lisper.ru/register">Регистрация</a> | <a href="http://lisper.ru/login?done=/pcl/files-and-file-io">Войти</a> </div> </div> <div id="caution"> <img alt="Lisp — программируемый язык программирования" src="../image/gecko.png" /> <a href="http://www.vkusnoserver.ru/" target="_blank" style="float: right;"> <img src="../vkusnoserver.png" /> </a> </div> <div id="mainmenu"> <ul> <li> <a href="http://lisper.ru/">Главная</a> </li><li> <a href="http://lisper.ru/articles/">Статьи</a> </li><li> <a href="http://lisper.ru/planet/">Планета</a> </li><li> <a href="http://lisper.ru/forum/">Форум</a> </li><li> <a href="http://lisper.ru/apps/">Сервисы</a> </li><li> <a href="index.html">Practical Common Lisp</a> </li><li> <a href="http://lisper.ru/wiki/">Wiki</a> </li><li> <a href="http://lisper.ru/files/">Файлы</a> </li><li> <a href="http://lisper.ru/search">Поиск</a> </li> </ul> </div> <div id="content"> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="beyond-lists-other-uses-for-cons-cells">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right"> <a href="practical-a-portable-pathname-library">Следующая</a> </td> </tr> </tbody> </table> <div class="article"><div class="toc"><div class="toc-header">Содержание</div><div class="toc-body"><ul><li><div><a href="files-and-file-io#14. &#x424;&#x430;&#x439;&#x43B;&#x44B; &#x438; &#x444;&#x430;&#x439;&#x43B;&#x43E;&#x432;&#x44B;&#x439; &#x432;&#x432;&#x43E;&#x434;/&#x432;&#x44B;&#x432;&#x43E;&#x434;">14. Файлы и файловый ввод/вывод</a><ul><li><div><a href="files-and-file-io#&#x427;&#x442;&#x435;&#x43D;&#x438;&#x435; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445; &#x438;&#x437; &#x444;&#x430;&#x439;&#x43B;&#x43E;&#x432;">Чтение данных из файлов</a></div></li><li><div><a href="files-and-file-io#&#x427;&#x442;&#x435;&#x43D;&#x438;&#x435; &#x434;&#x432;&#x43E;&#x438;&#x447;&#x43D;&#x44B;&#x445; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;">Чтение двоичных данных</a></div></li><li><div><a href="files-and-file-io#&#x411;&#x43B;&#x43E;&#x447;&#x43D;&#x43E;&#x435; &#x447;&#x442;&#x435;&#x43D;&#x438;&#x435;">Блочное чтение</a></div></li><li><div><a href="files-and-file-io#&#x424;&#x430;&#x439;&#x43B;&#x43E;&#x432;&#x44B;&#x439; &#x432;&#x44B;&#x432;&#x43E;&#x434;">Файловый вывод</a></div></li><li><div><a href="files-and-file-io#&#x417;&#x430;&#x43A;&#x440;&#x44B;&#x442;&#x438;&#x435; &#x444;&#x430;&#x439;&#x43B;&#x43E;&#x432;">Закрытие файлов</a></div></li><li><div><a href="files-and-file-io#&#x418;&#x43C;&#x435;&#x43D;&#x430; &#x444;&#x430;&#x439;&#x43B;&#x43E;&#x432;">Имена файлов</a><ul><li><div><a href="files-and-file-io#&#x41A;&#x430;&#x43A; &#x43C;&#x44B; &#x434;&#x43E; &#x44D;&#x442;&#x43E;&#x433;&#x43E; &#x434;&#x43E;&#x43A;&#x430;&#x442;&#x438;&#x43B;&#x438;&#x441;&#x44C;">Как мы до этого докатились</a></div></li></ul></div></li><li><div><a href="files-and-file-io#&#x41A;&#x430;&#x43A; &#x438;&#x43C;&#x435;&#x43D;&#x430; &#x43F;&#x443;&#x442;&#x435;&#x439; &#x43F;&#x440;&#x435;&#x434;&#x441;&#x442;&#x430;&#x432;&#x43B;&#x44F;&#x44E;&#x442; &#x438;&#x43C;&#x435;&#x43D;&#x430; &#x444;&#x430;&#x439;&#x43B;&#x43E;&#x432;">Как имена путей представляют имена файлов</a></div></li><li><div><a href="files-and-file-io#&#x41A;&#x43E;&#x43D;&#x441;&#x442;&#x440;&#x443;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435; &#x438;&#x43C;&#x435;&#x43D; &#x43F;&#x443;&#x442;&#x435;&#x439;">Конструирование имен путей</a></div></li><li><div><a href="files-and-file-io#&#x414;&#x432;&#x430; &#x43F;&#x440;&#x435;&#x434;&#x441;&#x442;&#x430;&#x432;&#x43B;&#x435;&#x43D;&#x438;&#x44F; &#x434;&#x43B;&#x44F; &#x438;&#x43C;&#x435;&#x43D; &#x434;&#x438;&#x440;&#x435;&#x43A;&#x442;&#x43E;&#x440;&#x438;&#x439;">Два представления для имен директорий</a></div></li><li><div><a href="files-and-file-io#&#x412;&#x437;&#x430;&#x438;&#x43C;&#x43E;&#x434;&#x435;&#x439;&#x441;&#x442;&#x432;&#x438;&#x435; &#x441; &#x444;&#x430;&#x439;&#x43B;&#x43E;&#x432;&#x43E;&#x439; &#x441;&#x438;&#x441;&#x442;&#x435;&#x43C;&#x43E;&#x439;">Взаимодействие с файловой системой</a></div></li><li><div><a href="files-and-file-io#&#x414;&#x440;&#x443;&#x433;&#x438;&#x435; &#x43E;&#x43F;&#x435;&#x440;&#x430;&#x446;&#x438;&#x438; &#x432;&#x432;&#x43E;&#x434;&#x430;/&#x432;&#x44B;&#x432;&#x43E;&#x434;&#x430;">Другие операции ввода/вывода</a></div></li></ul></div></li></ul></div></div>
<div class="chapter" id="14. &#x424;&#x430;&#x439;&#x43B;&#x44B; &#x438; &#x444;&#x430;&#x439;&#x43B;&#x43E;&#x432;&#x44B;&#x439; &#x432;&#x432;&#x43E;&#x434;/&#x432;&#x44B;&#x432;&#x43E;&#x434;"><h3>14. Файлы и файловый ввод/вывод</h3>

<p><code>Common Lisp</code> предоставляет мощную библиотеку для работы с файлами. В этой главе я остановлюсь на нескольких элементарных задачах, относящихся к файловыми операциям: чтение, запись, а также отображение структуры файловой системы. Средства Common Lisp, предназначенные для ввода/вывода, аналогичны имеющимся в других языках программирования. Common Lisp предоставляет потоковую абстракцию операций чтения/записи, а для манипулирования файловыми объектами в независимом от операционной системы формате - абстракцию <code>файловых путей</code>. Кроме того, Common Lisp предоставляет некоторое количество уникальных возможностей, такие как чтение и запись s-выражений. 
</p>
<div class="chapter" id="&#x427;&#x442;&#x435;&#x43D;&#x438;&#x435; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445; &#x438;&#x437; &#x444;&#x430;&#x439;&#x43B;&#x43E;&#x432;"><h3>Чтение данных из файлов</h3>

<p>Самая фундаментальная задача ввода/вывода - чтение содержимого файла. Для того, чтобы получить поток, из которого вы можете прочитать содержимое файла, используется функция <code>OPEN</code>. По умолчанию, <code>OPEN</code> возвращает посимвольный поток ввода данных, который можно передать множеству функций, считывающих один или несколько символов текста: <code>READ-CHAR</code> считывает одиночный символ; <code>READ-LINE</code> считывает строку текста, возвращая ее как строку без символа конца строки; функция <code>READ</code> считывает одиночное s-выражение, возвращая объект Lisp. Когда работа с потоком завершена, вы можете закрыть его с помощью функции <code>CLOSE</code>.
</p>
<p>Функция <code>OPEN</code> требует имя файла как единственный обязательный аргумент. Как можно увидеть в секции "Имена файлов", Common Lisp предоставляет два пути для представления имени файла, но наиболее простой способ - использовать строку, содержащую имя в формате, используемом в файловой системе. Так, предполагая, что <code>/some/file/name.txt</code> это файл, возможно открыть его следующим образом:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_open.htm" class="symbol">open</a> <span class="string">"/some/file/name.txt"</span></span>)</span><br/></pre>

<p>Вы можете использовать объект, возвращаемый функцией, как первый аргумент любой функции, осуществляющей чтение. Например, для того, чтобы напечатать первую строку файла, вы можете комбинировать <code>OPEN</code>, <code>READ-LINE</code>, <code>CLOSE</code> следующим образом:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren2">(<span class=""><span class="paren3">(<span class="">in <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_open.htm" class="symbol">open</a> <span class="string">"/some/file/name.txt"</span></span>)</span></span>)</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="string">"~a~%"</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_lin.htm" class="symbol">read-line</a> in</span>)</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_close.htm" class="symbol">close</a> in</span>)</span></span>)</span><br/></pre>

<p>Конечно, при открытии и чтении данных может произойти ряд ошибок. Файл может не существовать, или вы можете непредвиденно достигнуть конца файла в процессе его чтения. По умолчанию, <code>OPEN</code> и <code>READ-*</code> будут сигнализировать об ошибках в данных ситуациях. В главе 19, я рассмотрю как обработать эти ошибки. Сейчас же, однако, будем использовать более легковесное решение: каждая из этих функций принимает аргументы, которые изменяют ее реакцию на исключительные ситуации.
</p>
<p>Если вы хотите открыть файл, который возможно не существует, без генерирования ошибки функцией <code>OPEN</code>, вы можете использовать аргумент <code>:if-does-not-exists</code> для того, чтобы указать другое поведение. Три различных значения допустимы для данного аргумента - <code>:error</code>, по умолчанию; <code>:create</code>, что указывает на необходимость создания файла и повторное его открытие как существующего и <code>NIL</code>, что означает возврат <code>NIL</code> (при неуспешном открытии) вместо потока. Итак, возможно изменить предыдущий пример таким образом, чтобы обработать несуществующий файл.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren2">(<span class=""><span class="paren3">(<span class="">in <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_open.htm" class="symbol">open</a> <span class="string">"/some/file/name.txt"</span> <span class="keyword">:if-does-not-exist</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span></span>)</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> in<br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="string">"~a~%"</span> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_lin.htm" class="symbol">read-line</a> in</span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_close.htm" class="symbol">close</a> in</span>)</span></span>)</span></span>)</span><br/></pre>

<p>Все функции чтения - <code>READ-CHAR</code>, <code>READ-LINE</code>, <code>READ</code> - принимают опциональный аргумент, по умолчанию "истина", который указывает должны ли они сигнализировать об ошибке, если они достигли конца файла. Если этот аргумент установлен в <code>NIL</code>, то они возвращают значение их 3го аргумента, который по умолчанию <code>NIL</code>, вместо ошибки. Таким образом, вывести на печать все строки файла можно следующим способом:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren2">(<span class=""><span class="paren3">(<span class="">in <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_open.htm" class="symbol">open</a> <span class="string">"/some/file/name.txt"</span> <span class="keyword">:if-does-not-exist</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span></span>)</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> in<br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for line = <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_lin.htm" class="symbol">read-line</a> in <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span><br/>         while line <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="string">"~a~%"</span> line</span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_close.htm" class="symbol">close</a> in</span>)</span></span>)</span></span>)</span><br/></pre>

<p>Среди трёх функций чтения, <code>READ</code> – уникальна. Это – та самая функция, которая представляет букву "R" в "REPL", и которая используется для того, чтобы читать исходный код Lisp. Во время вызова она читает одиночное s-выражение, пропуская пробельные символы и комментарии, и возвращает объект Lisp, представляемый s-выражением. Например, предположим, что файл <code>/some/file/name.txt</code> содержит следующие строки:
</p>
<pre class="code"><span class="paren1">(<span class="">1 2 3</span>)</span><br/>456<br/>
"строка" ; это комментарий<br/><span class="paren1">(<span class=""><span class="paren2">(<span class="">a b</span>)</span><br/> <span class="paren2">(<span class="">c d</span>)</span></span>)</span><br/></pre>

<p>Другими словами, он содержит 4 s-выражения: список чисел, число, строку, и список списков. Вы можете считать эти выражения следующим образом:
</p>
<pre class="code"><p>CL-USER&gt; <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defpar.htm" class="symbol"><i><span class="symbol">defparameter</span></i></a> <span class="special">*s*</span> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_open.htm" class="symbol">open</a> <span class="string">"/some/file/name.txt"</span></span>)</span></span>)</span><br/>
*S*<br/>
CL-USER&gt; <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_rd.htm" class="symbol">read</a> <span class="special">*s*</span></span>)</span><br/><span class="paren1">(<span class="">1 2 3</span>)</span><br/>CL-USER&gt; <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_rd.htm" class="symbol">read</a> <span class="special">*s*</span></span>)</span><br/>
456<br/>
CL-USER&gt; <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_rd.htm" class="symbol">read</a> <span class="special">*s*</span></span>)</span><br/>
"строка"<br/>
CL-USER&gt; <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_rd.htm" class="symbol">read</a> <span class="special">*s*</span></span>)</span><br/><span class="paren1">(<span class=""><span class="paren2">(<span class="">A B</span>)</span> <span class="paren2">(<span class="">C D</span>)</span></span>)</span><br/>CL-USER&gt; <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_close.htm" class="symbol">close</a> <span class="special">*s*</span></span>)</span><br/>
T<br/></p></pre>

<p>Как было показано в Главе 3, возможно использовать <code>PRINT</code> для того, чтобы выводить объекты Lisp на печать в удобочитаемой форме. Итак, когда необходимо хранить данные в файлах, <code>PRINT</code> и <code>READ</code> предоставляют простой способ делать это без создания специального формата данных и парсера для их прочтения. Вы даже можете использовать комментарии без ограничений. И, поскольку s-выражения создавались для того, чтобы быть редактируемыми людьми, то они так же хорошо подходят для использования в качестве формата конфигурационных файлов <a class="fn_top" id="fnt__1" href="files-and-file-io#fn__1">1)</a>.
</p>
</div><div class="chapter" id="&#x427;&#x442;&#x435;&#x43D;&#x438;&#x435; &#x434;&#x432;&#x43E;&#x438;&#x447;&#x43D;&#x44B;&#x445; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;"><h3>Чтение двоичных данных</h3>

<p>По умолчанию <code>OPEN</code> возвращает символьные потоки, которые преобразуют байты в символы в соответствии с конкретной схемой кодирования символов <a class="fn_top" id="fnt__2" href="files-and-file-io#fn__2">2)</a>.
</p>
<p>Для чтения потока байтов необходимо передать функции <code>OPEN</code> ключевой параметр <code>:element-type</code> со значением <code>'(unsigned-byte 8)</code> <a class="fn_top" id="fnt__3" href="files-and-file-io#fn__3">3)</a> Полученный поток можно передать функции <code>READ-BYTE</code>, которая будет возвращать целое число от 0 до 255 во время каждого вызова. <code>READ-BYTE</code>, так же, как и функции, работающие с потоками символов, принимает опциональные аргументы, которые указывают, должна ли она сигнализировать об ошибке, если достигнут конец файла, и какое значение возвращать в противном случае. В главе 24 мы построим библиотеку, которая позволит удобно читать структурированные бинарные данные, используя <code>READ-BYTE</code>. <a class="fn_top" id="fnt__4" href="files-and-file-io#fn__4">4)</a>
</p>
</div><div class="chapter" id="&#x411;&#x43B;&#x43E;&#x447;&#x43D;&#x43E;&#x435; &#x447;&#x442;&#x435;&#x43D;&#x438;&#x435;"><h3>Блочное чтение</h3>

<p>Последняя функция для чтения, <code>READ-SEQUENCE</code>, работает с бинарными и символьными потоками. Ей передается последовательность (обычно вектор) и поток, и она  пытается заполнить эту последовательность данными из потока. Функция возвращает индекс первого элемента последовательности, который не был заполнен, либо ее длину, если она была заполнена полностью. Так же возможно передать ключевые аргументы <code>:start</code> и <code>:end</code>, которые указывают на подпоследовательность, которая должна быть заполнена вместо последовательности. Аргумент, определяющий последовательность должен быть типом, который может хранить элементы, из которых состоит поток. Поскольку большинство операционных систем поддерживают только одну какую-либо форму блочных операций ввода/вывода, <code>READ-SEQUENCE</code> скорее всего более эффективна чем чтение последовательных данных несколькими вызовами <code>READ-BYTE</code> или <code>READ-CHAR</code>.
</p>
</div><div class="chapter" id="&#x424;&#x430;&#x439;&#x43B;&#x43E;&#x432;&#x44B;&#x439; &#x432;&#x44B;&#x432;&#x43E;&#x434;"><h3>Файловый вывод</h3>

<p>Для записи данных в файл необходим поток вывода, который можно получить вызовом функции <code>OPEN</code> с ключевым аргументом <code>:direction</code> <code>:output</code>. Когда файл открывается для записи, <code>OPEN</code> предполагает, что файл не должен существовать, и будет сообщать об ошибке в противном случае. Однако, возможно изменить это поведение с помощью ключевого аргумента <code>:if-exists</code>. Передавая значение <code>:supersede</code> можно вызвать замену существующего файла. Значение :append позволяет осуществлять запись таким образом, что новые данные будут помещены в конец файла, а значение <code>:overwrite</code> возвращает поток, который будет переписывать существующие данные с начала файла. Если же передать <code>NIL</code>, то <code>OPEN</code> вернет <code>NIL</code> вместо потока, если файл уже существует. Характерное использование <code>OPEN</code> для вывода данных выглядит следующим образом:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_open.htm" class="symbol">open</a> <span class="string">"/some/file/name.txt"</span> <span class="keyword">:direction</span> <span class="keyword">:output</span> <span class="keyword">:if-exists</span> <span class="keyword">:supersede</span></span>)</span><br/></pre>

<p>Common Lisp также предоставляет некоторые функции для записи данных: <code>WRITE-CHAR</code> пишет одиночный символ в поток. <code>WRITE-LINE</code> пишет строку, за которой следует символ конца строки, с учетом реализации для конкретной платформы. Другая функция, <code>WRITE-STRING</code> пишет строку, не добавляя символ конца строки. Две разные функции могут использоваться для того чтобы вывести символ конца строки: <code>TERPRI</code> - сокращение для "TERminate PRInt" (закончить печать) безусловно печатает символ конца строки, а <code>FRESH-LINE</code> печатает символ конца строки только в том случае, если текущая позиция печати не совпадает с началом строки. <code>FRESH-LINE</code> удобна в том случае, когда желательно избежать паразитных пустых строк в текстовом выводе, генерируемом другими последовательно вызываемыми функциями. Допустим, например, что есть одна функция, которая генерирует вывод и после которой обязательно должен идти перенос строки и другая, которая должна начинаться с новой строки. Но, предположим, что если функции вызываются последовательно, то необходимо обеспечить отсутствие лишних пустых строк в их выводе. Если в начале второй функции используется <code>FRESH-LINE</code>, ее вывод будет постоянно начинать с новой строки, но если она вызывается непосредственно после первой функции, то не будет выводиться лишний перевод строки.
</p>
<p>Некоторые функции позволяют вывести данные Lisp в форме s-выражений: <code>PRINT</code> печатает s-выражение, предваряя его символом начала строки, и пробельным символом после. <code>PRIN1</code> печатает только s-выражение. А функция <code>PPRINT</code> печатает s-выражения аналогично <code>PRINT</code> и <code>PRIN1</code>, но использует "красивую печать", которая пытается печатать s-выражения в эстетически красивом виде.
</p>
<p>Однако, не все объекты могут быть напечатаны в том формате, который понимает <code>READ</code>. Переменная <code>*PRINT-READABLY*</code> контролирует поведение при попытке напечатать подобный объект с помощью <code>PRINT</code>, <code>PRIN1</code> или <code>PPRINT</code>. Когда она равна <code>NIL</code>,  эти функции напечатают объект в таком формате, что <code>READ</code> при попытке чтения гарантировано сообщит об ошибке; в ином случае они просигнализируют об ошибке вместо того, чтобы напечатать объект.
</p>
<p>Еще одна функция, <code>PRINC</code>, также печатает объекты Лиспа, но в виде, удобном для человеческого восприятия. Например, <code>PRINC</code> печатает строки без кавычек. Текстовый вывод может быть еще более замысловатым, если задействовать потрясающе гибкую, и в некоторой степени загадочную функцию <code>FORMAT</code>. В 18 главе я расскажу о некоторых важных тонкостях этой функции, которая, по сути, определяет мини-язык для форматированного вывода.
</p>
<p>Для того, чтобы записать двоичные данные в файл, следует открыть файл функцией <code>OPEN</code> с тем же самым аргументом <code>:element-type</code>, который использовался при чтении данных: <code>'(unsigned-byte 8)</code>. После этого можно записывать в поток отдельные байты функцией <code>WRITE-BYTE</code>.
</p>
<p>Функция блочного вывода <code>WRITE-SEQUENCE</code> принимает как двоичные, так и символьные потоки до тех пор, пока элементы последовательности имеют подходящий тип: символы или байты. Так же как и <code>READ-SEQUENCE</code>, эта функция наверняка более эффективна, чем запись элементов последовательности поодиночке.
</p>
</div><div class="chapter" id="&#x417;&#x430;&#x43A;&#x440;&#x44B;&#x442;&#x438;&#x435; &#x444;&#x430;&#x439;&#x43B;&#x43E;&#x432;"><h3>Закрытие файлов</h3>

<p>Любой, кто писал программы, взаимодействующие с файлами, знает, что важно закрывать файлы, когда работа с ними закончена, так как дескрипторы норовят быть дефицитным ресурсом. Если открывают файлы и забывают их закрывать, вскоре обнаруживают, что больше нельзя открыть ни одного файла<a class="fn_top" id="fnt__5" href="files-and-file-io#fn__5">5)</a>. На первый взгляд может показаться, что достаточно  каждый вызов <code>OPEN</code> сопоставить с вызовом <code>CLOSE</code>. Например, можно всегда обрамлять код, использующий файл, как показано ниже:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren2">(<span class=""><span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/t_stream.htm" class="symbol">stream</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_open.htm" class="symbol">open</a> <span class="string">"/some/file/name.txt"</span></span>)</span></span>)</span></span>)</span> <br/>  <span class="comment">;; работа с потоком<br/></span>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_close.htm" class="symbol">close</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/t_stream.htm" class="symbol">stream</a></span>)</span></span>)</span> <br/></pre>

<p>Однако этом метод имеет две проблемы. Первая — он предрасположен к ошибкам: если забыть написать <code>CLOSE</code>, то будет происходить утечка дескрипторов при каждом вызове этого кода. Вторая – наиболее значительная – нет гарантии, что <code>CLOSE</code> будет достигнут. Например, если в коде, расположенном до <code>CLOSE</code>, есть <code>RETURN</code> или <code>RETURN-FROM</code>, возвращение из <code>LET</code> произойдет без закрытия потока. Или, как вы увидите в 19 главе, если какая-либо часть кода до <code>CLOSE</code> сигнализирует об ошибке, управление может перейти за пределы <code>LET</code> обработчику ошибки и никогда не вернется, чтобы закрыть поток.
</p>
<p>Common Lisp предоставляет общее решение того, как удостовериться, что определенный код всегда исполняется: специальный оператор <code>UNWIND-PROTECT</code>, о котором я расскажу в 20 главе. Так как открытие файла, работа с ним и последующее закрытие очень часто употребляются, Common Lisp предлагает макрос, <code>WITH-OPEN-FILE</code>, основанный на <code>UNWIND-PROTECT</code>, для скрытия этих действий. Ниже — основная форма:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_w_open.htm" class="symbol"><i><span class="symbol">with-open-file</span></i></a> <span class="paren2">(<span class="">stream-var open-argument*</span>)</span> <br/>  body-form*</span>)</span> <br/></pre>

<p>Выражения в <code>body-form*</code> вычисляются с <code>stream-var</code>, связанной с файловым потоком, открытым вызовом <code>OPEN</code> с аргументами <code>open-argument*</code>. <code>WITH-OPEN-FILE</code> удостоверяется, что поток <code>stream-var</code> закрывается до того, как из <code>WITH-OPEN-FILE</code> вернется управление. Поэтому читать файл можно следующим образом:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_w_open.htm" class="symbol"><i><span class="symbol">with-open-file</span></i></a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/t_stream.htm" class="symbol">stream</a> <span class="string">"/some/file/name.txt"</span></span>)</span> <br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="string">"~a~%"</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_lin.htm" class="symbol">read-line</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/t_stream.htm" class="symbol">stream</a></span>)</span></span>)</span></span>)</span> <br/></pre>

<p>Создать файл можно так:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_w_open.htm" class="symbol"><i><span class="symbol">with-open-file</span></i></a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/t_stream.htm" class="symbol">stream</a> <span class="string">"/some/file/name.txt"</span> <span class="keyword">:direction</span> <span class="keyword">:output</span></span>)</span> <br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/t_stream.htm" class="symbol">stream</a> <span class="string">"Какой-то текст."</span></span>)</span></span>)</span> <br/></pre>

<p>Как правило, <code>WITH-OPEN-FILE</code> используется в 90-99 процентах файлового ввода/вывода. Вызовы <code>OPEN</code> и <code>CLOSE</code> понадобятся, если файл нужно открыть в какой-либо функции и оставить поток открытым при возврате из нее. В таком случае вы должны позаботиться о закрытии потока самостоятельно, иначе произойдет утечка файловых дескрипторов и, в конце концов, вы больше не сможете открыть ни одного файла.
</p>
</div><div class="chapter" id="&#x418;&#x43C;&#x435;&#x43D;&#x430; &#x444;&#x430;&#x439;&#x43B;&#x43E;&#x432;"><h3>Имена файлов</h3>

<p>До сих пор мы использовали строки для представления имен файлов. Однако, использование строк как имен файлов привязывает код к конкретной операционной и файловой системам. Точно так же, если конструировать имена в соответствии правилам конкретной схемы именования (скажем, разделение директорий знаком "/"), то вы также привязаны к одной определенной файловой системе.
</p>
<p>Для того, чтобы избежать подобной непереносимости программ, Common Lisp предоставляет другое представление файловых имен: объекты файловых путей. Файловые пути представляют собой файловые имена в структурированном виде, что делает их использование легким без привязки к определенному синтаксису файловых имен. А бремя по переводу между строками в локальном представлении – строками имен – и файловыми путями ложится на плечи реализаций Lisp.
</p>
<p>К несчастью, как и со многими абстракциями, спроектированными для скрытия деталей различных базовых систем, абстракция файловых путей привносит свои трудности. В то время, когда разрабатывались файловые пути, разнообразие широко используемых файловых систем было чуть значительнее, чем сегодня. Но это мало проясняет ситуацию, если все, о чем вы заботитесь, – представление имен файлов в Unix или Windows. Однако однажды поняв какие части этой абстракции можно забыть, как артефакты истории развития файловых путей, вы сможете ловко управлять именами файлов<a class="fn_top" id="fnt__6" href="files-and-file-io#fn__6">6)</a>.
</p>
<p>Как правило, когда возникает необходимость в файловом имени, вы можете использовать как строку имени (namestring), так и файловый путь. Выбор зависит от того, откуда произошло имя. Файловые имена, предоставленные пользователем – например, как аргументы или строки конфигурационного файла – как правило, будут строками имен, так как пользователь знает какая операционная система у него запущена, поэтому не следует ожидать, что он будет беспокоиться о представлении файловых имен в Lisp. Но следуя общепринятой практике, файловые имена будут представлены файловыми путями, так как они переносимы. Поток, который возвращает <code>OPEN</code>, также представляет файловое имя, а именно, файловое имя, которое было изначально использовано для открытия этого потока. Вместе эти три типа упоминаются как указатели файловых путей. Все встроенные функции, ожидающие файловое имя как аргумент, принимают все три типа указателя файловых путей. Например, во всех предыдущих случаях, когда вы использовали строку для представления файлового имени, вы также могли передавать в функцию объект файлового пути или поток.
</p>
<div class="chapter" id="&#x41A;&#x430;&#x43A; &#x43C;&#x44B; &#x434;&#x43E; &#x44D;&#x442;&#x43E;&#x433;&#x43E; &#x434;&#x43E;&#x43A;&#x430;&#x442;&#x438;&#x43B;&#x438;&#x441;&#x44C;"><h3>Как мы до этого докатились</h3>

<p>Историческое разнообразие файловых систем, существующих в период 70-80 годов, можно легко забыть. Кент Питман, один из ведущих технических редакторов стандарта Common Lisp,  описал однажды ситуацию в comp.lang.lisp (Message-ID: <code>sfwzo74np6w.fsf@world.std.com</code>) так:
</p>
<p>В момент завершения проектирования Common Lisp господствующими файловыми системами  были <code>TOPS-10</code>, <code>TENEX</code>, <code>TOPS-20</code>, <code>VAX VMS</code>, <code>AT&amp;T Unix</code>, <code>MIT Multics</code>, <code>MIT ITS</code>, и это не упоминаю группу систем для мэйнфрэймов. В некоторых системах имена файлов были только в верхнем регистре, в других – смешанные, в третьих – чувствительны к регистру, но с возможностью преобразования (как в CL). Какие-то имели групповые символы (wildcards), какие-то – нет. Одни имели <code>:вверх</code> (<code>:up</code>) в относительных файловых путях, другие – нет. Также существовали файловые системы без каталогов, файловые системы без иерархической структуры каталогов, файловые системы без типов файлов, файловые системы без версий, файловые системы без устройств и т.д.
</p>
<p>Если сейчас посмотреть на абстракцию файловых путей с точки зрения какой-нибудь определенной файловой системы, она выглядит нелепо. Но если взять в рассмотрение даже такие две похожие файловые системы, как в Windows и Unix, то вы можете заметить отличия, от которых можно отвлечься с помощью системы файловых путей. Файловые имена в Windows содержат букву диска в то время, как в Unix нет. Другое преимущество владения абстракцией файловых путей, которая спроектирована, чтобы оперировать большим разнообразием файловых систем, которые существовали в прошлом, – ее вероятная способность управлять файловыми системами, которые будут существовать в будущем. Если, скажем, файловые системы с сохранением всех старых данных и истории операций войдут снова в моду, Common Lisp будет к этому готов.
</p>
</div></div><div class="chapter" id="&#x41A;&#x430;&#x43A; &#x438;&#x43C;&#x435;&#x43D;&#x430; &#x43F;&#x443;&#x442;&#x435;&#x439; &#x43F;&#x440;&#x435;&#x434;&#x441;&#x442;&#x430;&#x432;&#x43B;&#x44F;&#x44E;&#x442; &#x438;&#x43C;&#x435;&#x43D;&#x430; &#x444;&#x430;&#x439;&#x43B;&#x43E;&#x432;"><h3>Как имена путей представляют имена файлов</h3>

<p>Файловый путь – это структурированный объект, который представляет файловое имя, используя шесть компонентов: хост, устройство, каталог, имя, тип и версия. Большинство из них принимают атомарные значения, как правило, строки; только  директория – структурный компонент, содержащий список имен каталогов (как строки) с предшествующим ключевым словом: <code>:absolute</code> (абсолютный) или <code>:relative</code> (относительный). Но не все компоненты необходимы на все платформах – это одна из тех вещей, которая вселяет страх в начинающих лисперов, потому что необоснованно сложна. С другой стороны, вам не надо заботиться о том, какие компоненты могут или нет использоваться для представления имен на определенной файловой системе, если только вам не надо создать объект файлового пути с нуля, а это почти никогда и не надо. Взамен Вы обычно получите объект файлового пути либо позволив реализации преобразовать строку имени специфичной для какой-то файловой системы в объект файлового пути, либо создав файловый путь, который перенимает большинство компонент от какого-либо существующего.
</p>
<p>Например, для того, чтобы преобразовать строку имени в файловый путь, используйте функцию <code>PATHNAME</code>. Она принимает на вход указатель файлового пути и возвращает эквивалентный объект файлового пути. Если указатель уже является файловым путем, то он просто возвращается. Если это поток, извлекается первоначальное файловое имя и возвращается. Если это строка имени, она анализируется согласно локальному синтаксису файловых имен. Стандарт языка как независимый от платформы документ не определяет какое-либо конкретное отображение строки имени в файловый путь, но большинство реализаций следуют одним и тем же соглашениям на данной операционной системе.
</p>
<p>На файловых системах Unix, обычно, используются компоненты: директория, имя и тип. В Windows на один компонент больше – обычно устройство или хост – содержит букву диска. На этих платформах строку имени делят на части, а разделителем служит косая черта в Unix и косая или обратная косая черты в Windows. Букву диска в Windows размещают либо в компонент устройства или компонент хост. Все, кроме последнего из оставшихся элементов имени, размещаются в списке, начинающемся с <code>:absolute</code> или <code>:relative</code> в зависимости от того, начинается ли имя с разделителя или нет (игнорирую букву диска, если таковая присутствует). Список становится компонентом каталог файлового пути. Последний элемент делится по самой крайней точке, если она есть, и полученные две части есть компоненты имя и тип, соответственно.<a class="fn_top" id="fnt__7" href="files-and-file-io#fn__7">7)</a>
</p>
<p>Можно проверить каждый компонент файлового пути с функциями <code>PATHNAME-DIRECTORY</code>, <code>PATHNAME-NAME</code> и <code>PATHNAME-TYPE</code>.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_pn_hos.htm" class="symbol">pathname-directory</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pn.htm" class="symbol">pathname</a> <span class="string">"/foo/bar/baz.txt"</span></span>)</span></span>)</span> → <span class="paren1">(<span class=""><span class="keyword">:ABSOLUTE</span> <span class="string">"foo"</span> <span class="string">"bar"</span></span>)</span> <br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_pn_hos.htm" class="symbol">pathname-name</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pn.htm" class="symbol">pathname</a> <span class="string">"/foo/bar/baz.txt"</span></span>)</span></span>)</span>      → "baz" <br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_pn_hos.htm" class="symbol">pathname-type</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pn.htm" class="symbol">pathname</a> <span class="string">"/foo/bar/baz.txt"</span></span>)</span></span>)</span>      → "txt" <br/></pre>

<p>Другие три функции – <code>PATHNAME-HOST</code>, <code>PATHNAME-DEVICE</code> и <code>PATHNAME-VERSION</code> – позволяют получить остальные три составляющие файлового пути, хотя они и не представляют интереса в Unix. В Windows либо <code>PATHNAME-HOST</code>, либо <code>PATHNAME-DEVICE</code> возвратит букву диска.
</p>
<p>Подобно другим встроенным объектам, файловые пути обладают своим синтаксисом для чтения: <code>#p</code>, за которым следует строка, заключенная в двойные кавычки. Это позволяет печатать и считывать s-выражения, содержащие объекты файлового пути, но так как синтаксис зависит от алгоритма анализа строки, эти данные могут быть непереносимыми между разными операционными системами.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pn.htm" class="symbol">pathname</a> <span class="string">"/foo/bar/baz.txt"</span></span>)</span> → #p"/foo/bar/baz.txt" <br/></pre>

<p>Для того, чтобы файловый путь преобразовать обратно в строку имени – например, чтобы представить его пользователю – следует воспользоваться функцией <code>NAMESTRING</code>, которая принимает указатель файлового пути и возвращает строку имени. Две других функции – <code>DIRECTORY-NAMESTRING</code> и <code>FILE-NAMESTRING</code> – возвращают часть строки имени. <code>DIRECTORY-NAMESTRING</code> соединяет элементы компонента каталог в локальное имя каталога. <code>FILE-NAMESTRING</code> – компоненты имя и тип.<a class="fn_top" id="fnt__8" href="files-and-file-io#fn__8">8)</a>
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_namest.htm" class="symbol">namestring</a> #p<span class="string">"/foo/bar/baz.txt"</span></span>)</span>           → "/foo/bar/baz.txt" <br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_namest.htm" class="symbol">directory-namestring</a> #p<span class="string">"/foo/bar/baz.txt"</span></span>)</span> → "/foo/bar/" <br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_namest.htm" class="symbol">file-namestring</a> #p<span class="string">"/foo/bar/baz.txt"</span></span>)</span>      → "baz.txt" <br/></pre>

</div><div class="chapter" id="&#x41A;&#x43E;&#x43D;&#x441;&#x442;&#x440;&#x443;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435; &#x438;&#x43C;&#x435;&#x43D; &#x43F;&#x443;&#x442;&#x435;&#x439;"><h3>Конструирование имен путей</h3>

<p>Вы можете создать файловый путь, используя функцию <code>MAKE-PATHNAME</code>. Она принимает по одному аргументу-ключу на каждую компоненту файлового пути и возвращает файловый путь, заполненный всеми предоставленными компонентами.<a class="fn_top" id="fnt__9" href="files-and-file-io#fn__9">9)</a>
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_pn.htm" class="symbol">make-pathname</a><br/>  <span class="keyword">:directory</span> '<span class="paren2">(<span class=""><span class="keyword">:absolute</span> <span class="string">"foo"</span> <span class="string">"bar"</span></span>)</span><br/>  <span class="keyword">:name</span> <span class="string">"baz"</span><br/>  <span class="keyword">:type</span> <span class="string">"txt"</span></span>)</span> →  #p"/foo/bar/baz.txt"<br/></pre>

<p>Однако, если вы желаете, чтобы ваши программы были переносимыми, то вряд ли вы пожелаете создавать файловые пути с нуля, даже если абстракция файловых путей предохраняет вас от непереносимого синтаксиса файловых имен, ведь файловые имена могут быть непереносимыми еще множеством способов. Например, файловое имя <code>"/home/peter/foo.txt"</code> не очень-то подходит для OS X, в которой <code>/home/</code> представлено <code>/Users/</code>.
</p>
<p>Другой причиной, по которой не следует создавать файловые пути с нуля, является тот факт, что различные реализации используют компоненты файлового пути с небольшими различиями. Например, как было упомянуто выше, некоторые Windows-реализации LISP хранят букву диска в компоненте устройство в то время, как другие – в компоненте хост. Если вы напишите:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_pn.htm" class="symbol">make-pathname</a> <span class="keyword">:device</span> <span class="string">"c"</span> <span class="keyword">:directory</span> '<span class="paren2">(<span class=""><span class="keyword">:absolute</span> <span class="string">"foo"</span> <span class="string">"bar"</span></span>)</span> <span class="keyword">:name</span> <span class="string">"baz"</span></span>)</span> <br/></pre>

<p>то это может быть правильным при использовании одной реализации, но не другой.
</p>
<p>Вместо того, чтобы создавать пути с нуля, проще создать новый файловый путь, используя существующий файловый путь, при помощи аргумента-ключа :defaults функции <code>MAKE-PATHNAME</code>. С этим параметром можно предоставить указатель файлового пути, из которого будут взяты компоненты, не указанные другими аргументами. Для примера, следующее выражение создает файловый путь с расширением <code>.html</code> и компонентами из файлового пути <code>input-file</code>:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_pn.htm" class="symbol">make-pathname</a> <span class="keyword">:type</span> <span class="string">"html"</span> <span class="keyword">:defaults</span> input-file</span>)</span> <br/></pre>

<p>Предполагая, что значение <code>input-file</code> было предоставлено пользователем, этот код – надёжен вопреки различиям операционных систем и реализаций, таким как наличие либо отсутствие в файловом пути буквы диска или место её расположения.<a class="fn_top" id="fnt__10" href="files-and-file-io#fn__10">10)</a>
</p>
<p>Используя эту же технику, можно создать файловый путь с другой компонентой директория.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_pn.htm" class="symbol">make-pathname</a> <span class="keyword">:directory</span> '<span class="paren2">(<span class=""><span class="keyword">:relative</span> <span class="string">"backups"</span></span>)</span> <span class="keyword">:defaults</span> input-file</span>)</span> <br/></pre>

<p>Однако этот код создаст файловый путь с компонентой директория, равной относительному пути "backups/", безотносительно к любым другим компонентам файла input-file. Например:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_pn.htm" class="symbol">make-pathname</a> <span class="keyword">:directory</span> '<span class="paren2">(<span class=""><span class="keyword">:relative</span> <span class="string">"backups"</span></span>)</span> <br/>               <span class="keyword">:defaults</span> #p<span class="string">"/foo/bar/baz.txt"</span></span>)</span> → #p"backups/baz.txt" <br/></pre>

<p>Возможно, когда-нибудь вы захотите объединить два файловых пути, один из которых имеет относительный компонент директория, путем комбинирования их компонент директория. Например, предположим, что имеется относительный файловый путь <code>#p"foo/bar.html"</code>, который вы хотите объединить с абсолютным файловым путем <code>#p"/www/html/"</code>, чтобы получить <code>#p"/www/html/foo/bar.html"</code>. В этом случае <code>MAKE-PATHNAME</code> не подойдет; то, что вам надо, – <code>MERGE-PATHNAMES</code>.
</p>
<p><code>MERGE-PATHNAMES</code> принимает два файловых пути и соединяет их, заполняя при этом компоненты, которые в первом файловом пути равны <code>NIL</code>, соответствующими значениями из второго файлового пути. Это очень похоже на <code>MAKE-PATHNAME</code>, которая заполняет все неопределенные компоненты значениями, предоставленными аргументом <code>:defaults</code>. Однако, <code>MERGE-PATHNAMES</code> особенно относится к компоненте директория: если директория первого файлового пути – относительна, то директорией окончательного файлового пути будет директория первого пути относительно директории второго. Так:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_merge_.htm" class="symbol">merge-pathnames</a> #p<span class="string">"foo/bar.html"</span> #p<span class="string">"/www/html/"</span></span>)</span> → #p"/www/html/foo/bar.html" <br/></pre>

<p>Второй файловый путь также может быть относительным. В этом случае окончательный путь также будет относительным.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_merge_.htm" class="symbol">merge-pathnames</a> #p<span class="string">"foo/bar.html"</span> #p<span class="string">"html/"</span></span>)</span> → #p"html/foo/bar.html" <br/></pre>

<p>Для того, чтобы обратить это процесс, то есть получить файловый путь, который относителен определенной корневой директории, используйте полезную функцию <code>ENOUGH-NAMESTRING</code>.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_namest.htm" class="symbol">enough-namestring</a> #p<span class="string">"/www/html/foo/bar.html"</span> #p<span class="string">"/www/"</span></span>)</span> → "html/foo/bar.html" <br/></pre>

<p>Вы можете соединить <code>ENOUGH-NAMESTRING</code> и <code>MERGE-PATHNAMES</code> для того, чтобы создать файловый путь (с одинаковой относительной частью) в другой корневой директории.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_merge_.htm" class="symbol">merge-pathnames</a> <br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_namest.htm" class="symbol">enough-namestring</a> #p<span class="string">"/www/html/foo/bar/baz.html"</span> #p<span class="string">"/www/"</span></span>)</span> <br/>  #p<span class="string">"/www-backups/"</span></span>)</span> →   #p"/www-backups/html/foo/bar/baz.html" <br/></pre>

<p><code>MERGE-PATHNAMES</code> используется стандартными функциями для доступа к файлам, чтобы дополнять незавершенные файловые пути. Например, пусть есть  файловый путь, имеющий только компоненты имя и тип.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_pn.htm" class="symbol">make-pathname</a> <span class="keyword">:name</span> <span class="string">"foo"</span> <span class="keyword">:type</span> <span class="string">"txt"</span></span>)</span> → #p"foo.txt" <br/></pre>

<p>Если вы попытаетесь передать этот файловый путь как аргумент функции <code>OPEN</code>, недостающие компоненты, как, например, директория, должны быть заполнены, чтобы Lisp смог преобразовать файловый путь в действительное файловое имя. Common Lisp добудет эти значения для недостающих компонент, объединяя данный файловый путь со значением переменной <code>*DEFAULT-PATHNAME-DEFAULTS*</code>. Начальное значение этой переменной определено реализацией, но, как правило, это файловый путь, компонент директория которого представляет ту директорию, в которой Lisp был запущен. Компоненты хост и устройство заполнены подходящими значениями, если в этом есть необходимость. Если <code>MERGE-PATHNAMES</code> вызвана только с одним аргументом, то она объединит аргумент со значением <code>*DEFAULT-PATHNAME-DEFAULTS*</code>. Например, если <code>*DEFAULT-PATHNAME-DEFAULTS*</code> – <code>#p"/home/peter/"</code>, то в результате:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_merge_.htm" class="symbol">merge-pathnames</a> #p<span class="string">"foo.txt"</span></span>)</span> → #p"/home/peter/foo.txt" <br/></pre>

</div><div class="chapter" id="&#x414;&#x432;&#x430; &#x43F;&#x440;&#x435;&#x434;&#x441;&#x442;&#x430;&#x432;&#x43B;&#x435;&#x43D;&#x438;&#x44F; &#x434;&#x43B;&#x44F; &#x438;&#x43C;&#x435;&#x43D; &#x434;&#x438;&#x440;&#x435;&#x43A;&#x442;&#x43E;&#x440;&#x438;&#x439;"><h3>Два представления для имен директорий</h3>

<p>Существует один неприятный момент при работе с файловым путем, который представляет директорию. Файловые объекты разделяют компоненты директория и имя файла, но Unix и Windows рассматривают директории как еще один тип файла. Поэтому, в этих системах, каждая директория может иметь два различных преставления.
</p>
<p>Одно из них, которое я назову <code>представлением файла</code>, рассматривает директорию, как любой другой файл и размещает последний элемент строки имени в компоненты имя и тип. Другое представление – представление директории – помещает все элементы имени в компонент директория, оставляя компоненты имя и тип равными <code>NIL</code>. Если <code>/foo/bar/</code> – директория, тогда любой из следующих двух файловых путей представляет ее.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_pn.htm" class="symbol">make-pathname</a> <span class="keyword">:directory</span> '<span class="paren2">(<span class=""><span class="keyword">:absolute</span> <span class="string">"foo"</span></span>)</span> <span class="keyword">:name</span> <span class="string">"bar"</span></span>)</span> ; file form <br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_pn.htm" class="symbol">make-pathname</a> <span class="keyword">:directory</span> '<span class="paren2">(<span class=""><span class="keyword">:absolute</span> <span class="string">"foo"</span> <span class="string">"bar"</span></span>)</span></span>)</span>       ; directory form <br/></pre>

<p>Когда вы создаете файловые пути с помощью <code>MAKE-PATHNAME</code>, вы можете получить любое из двух представлений, но нужно быть осторожным, когда имеете дело со строками имен. Все современные реализации Lisp создают представление файла, если только строка имени не заканчивается разделителем пути. Но вы не можете полагаться на то, что строки имени, предоставленные пользователем, будут в том либо ином представлении. Например, предположим, что вы запросили у пользователя имя директории, в которой сохраните файл. Пользователь ввел <code>"/home/peter"</code>. Если передать функции <code>MAKE-PATHNAME</code> эту строку как аргумент <code>:defaults</code>:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_pn.htm" class="symbol">make-pathname</a> <span class="keyword">:name</span> <span class="string">"foo"</span> <span class="keyword">:type</span> <span class="string">"txt"</span> <span class="keyword">:defaults</span> user-supplied-name</span>)</span> <br/></pre>

<p>то в конце концов вы сохраните файл как <code>/home/foo.txt</code>, а не <code>/home/peter/foo.text</code>, как предполагалось, так как <code>"peter"</code> из строки имени будет помещен в компонент имя, когда <code>user-supplied-name</code> будет преобразовано в файловый путь. В переносимой библиотеке файловых путей, которую я обсужу в следующей главе, вы напишите функцию pathname-as-directory, которая преобразует файловый объект в представление директории. С этой функцией вы сможете сохранять наверняка файл в директории, указанной пользователем.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_pn.htm" class="symbol">make-pathname</a> <br/>  <span class="keyword">:name</span> <span class="string">"foo"</span> <span class="keyword">:type</span> <span class="string">"txt"</span> <span class="keyword">:defaults</span> <span class="paren2">(<span class="">pathname-as-directory user-supplied-name</span>)</span></span>)</span><br/></pre>

</div><div class="chapter" id="&#x412;&#x437;&#x430;&#x438;&#x43C;&#x43E;&#x434;&#x435;&#x439;&#x441;&#x442;&#x432;&#x438;&#x435; &#x441; &#x444;&#x430;&#x439;&#x43B;&#x43E;&#x432;&#x43E;&#x439; &#x441;&#x438;&#x441;&#x442;&#x435;&#x43C;&#x43E;&#x439;"><h3>Взаимодействие с файловой системой</h3>

<p>Хоть открытие файлов для чтения и записи – наиболее частый вид взаимодействия с файловой системой, порой вам захочется проверить существует ли файл, прочитать содержимое директории, удалить или переименовать файлы, создать директории или получить такую информацию о файле, как: кто его владелец, когда он последний раз был изменен, его длину. Тут-то общность абстракции файловых путей немного некстати. Стандарт языка не определяет, как функции, взаимодействующие с файловой системой, отображаются на какую-то конкретную файловую систему, поэтому у создателей конкретных реализаций есть некоторая свобода действий.
</p>
<p>Несмотря на это большинство функций для взаимодействия с файловой системой просты для понимания. Я расскажу о стандартных функциях и укажу на те, с которыми могут возникнуть проблемы с переносимостью кода между реализациями. В следующей главе вы разработаете переносимую библиотеку файловых путей для того, чтобы сгладить эти проблемы с переносимостью.
</p>
<p>Для того, чтобы проверить существует ли файл, соответствующий указателю файлового пути – будь-то файловый путь, строка имени или файловый поток, – можно использовать функцию <code>PROBE-FILE</code>. Если файл, соответствующий указателю, существует, <code>PROBE-FILE</code> вернет "настоящее" имя файла – файловый путь с любыми преобразованиями уровня файловой системой, как, например, следование по символическим ссылкам. В ином случае, она вернет <code>NIL</code>. Однако, не все реализации позволяют использовать ее для того, чтобы проверить существует ли директория. Также, Common Lisp не предоставляет переносимого способа определить, чем является существующий файл – обычным файлом или директорией. В следующей главе вы сделаете функцию-обертку для <code>PROBE-FILE</code> – <code>file-exists-p</code>, которая может проверить существует ли файл и ответить: данное имя является именем файла или директории.
</p>
<p>Так же стандартная функция для чтения списка файлов – <code>DIRECTORY</code> – работает прекрасно в незамысловатых случаях, но из-за различий реализаций ее использование становится мудреным делом. В следующей главе вы определите функцию чтения содержимого директорий, которая сгладит некоторые из различий.
</p>
<p><code>DELETE-FILE</code> и <code>RENAME-FILE</code> делают то, что следует из их названий. <code>DELETE-FILE</code> принимает указатель файлового пути и удаляет указанный файл, возвращая истину в случае успеха. В ином случае она сигнализирует <code>FILE-ERROR</code>.<a class="fn_top" id="fnt__11" href="files-and-file-io#fn__11">11)</a>
</p>
<p><code>RENAME-FILE</code> принимает два указателя файлового пути и изменяет имя файла, указанного первым параметром, на имя, указанное вторым параметром.
</p>
<p>Вы можете создать директории с помощью функции <code>ENSURE-DIRECTORIES-EXIST</code>. Она принимает указатель файлового пути и удостоверяется, что все элементы компонента директория существуют и являются директориями, создавая их при необходимости. Так как она возвращает файловый путь, который ей был передан, то удобно ее вызывать на месте аргумента другой функции.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_w_open.htm" class="symbol"><i><span class="symbol">with-open-file</span></i></a> <span class="paren2">(<span class="">out <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_ensu_1.htm" class="symbol">ensure-directories-exist</a> name</span>)</span> <span class="keyword">:direction</span> <span class="keyword">:output</span></span>)</span> <br/>   ... <br/>   </span>)</span> <br/></pre>

<p>Обратите внимание, что если вы передаете <code>ENSURE-DIRECTORIES-EXIST</code> имя директории, то оно должно быть в представлении директории, или последняя директория не будет создана. Обе функции <code>FILE-WRITE-DATE</code> и <code>FILE-AUTHOR</code> принимают указатель файлового пути. <code>FILE-WRITE-DATE</code> возвращает количество секунд, которое прошло с полуночи 1-го января 1900 года, среднее время по Гринвичу (GMT), до времени последней записи в файл. <code>FILE-AUTHOR</code> возвращает – в Unix и Windows – владельца файла.<a class="fn_top" id="fnt__12" href="files-and-file-io#fn__12">12)</a>
</p>
<p>Для того, чтобы получить размер файла, используйте функцию <code>FILE-LENGTH</code>. По историческим причинам <code>FILE-LENGTH</code> принимает поток как аргумент, а не файловый путь. В теории это позволяет <code>FILE-LENGTH</code> вернуть размер в терминах типа элементов потока. Однако, так как на большинстве современных операционных системах единственная доступная информация о размере файла – исключая чтение всего файла, чтобы узнать размер – это размер в байтах, что возвращают большинство реализаций, даже если <code>FILE-LENGTH</code> передан символьный поток. Однако, стандарт не требует такого поведения, поэтому ради предсказуемых результатов лучший способ получить размер файла – использовать бинарный поток.<a class="fn_top" id="fnt__13" href="files-and-file-io#fn__13">13)</a>
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_w_open.htm" class="symbol"><i><span class="symbol">with-open-file</span></i></a> <span class="paren2">(<span class="">in filename <span class="keyword">:element-type</span> '<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/t_unsgn_.htm" class="symbol">unsigned-byte</a> 8</span>)</span></span>)</span> <br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_file_l.htm" class="symbol">file-length</a> in</span>)</span></span>)</span> <br/></pre>

<p>Похожая функция, которая также принимает открытый файловый поток в качестве аргумента – <code>FILE-POSITION</code>. Когда ей передают только поток, она возвращает текущую позицию в файле – количество элементов, прочитанных из потока или записанных в него. Когда ее вызывают с двумя аргументами, потоком и указателем позиции, она устанавливает текущей позицией указанную. Указатель позиции должен быть ключевым словом <code>:start</code>, <code>:end</code> или неотрицательным целым числом. Два ключевых слова устанавливают позицию потока в начало или конец. Если же передать функции целое число, то позиция переместится в указанную позицию файла. В случае бинарного потока позиция – это просто смещение в байтах от начала файла. Однако символьные потоки немного сложнее из-за проблем с кодировками. Лучшее что вы можете сделать если нужно переместиться на другую позицию в текстовом файле – всегда передавать <code>FILE-POSITION</code> в качестве второго аргумента только то значение, которое вернула функция <code>FILE-POSITION</code>, вызванная с тем же потоком в качестве единственного аргумента.
</p>
</div><div class="chapter" id="&#x414;&#x440;&#x443;&#x433;&#x438;&#x435; &#x43E;&#x43F;&#x435;&#x440;&#x430;&#x446;&#x438;&#x438; &#x432;&#x432;&#x43E;&#x434;&#x430;/&#x432;&#x44B;&#x432;&#x43E;&#x434;&#x430;"><h3>Другие операции ввода/вывода</h3>

<p>Вдобавок к файловым потокам Common Lisp поддерживает другие типы потоков, которые также можно использовать с разнообразными функциями ввода/вывода для чтения, записи и печати. Например, можно считывать данные из строки или записывать их в строку, используя <code>STRING-STREAM</code>, которые вы можете создать функциями <code>MAKE-STRING-INPUT-STREAM</code> и <code>MAKE-STRING-OUTPUT-STREAM</code>.
</p>
<p><code>MAKE-STRING-INPUT-STREAM</code> принимает строку и необязательные начальный и конечный индексы, указывающие часть строки, которую следует связать с потоком, и возвращает символьный поток, который можно передать как аргумент любой функции символьного ввода, как, например, <code>READ-CHAR</code>, <code>READ-LINE</code> или <code>READ</code>. Например, если у вас есть строка, содержащая число с плавающей точкой с синтаксисом Common Lisp, вы можете преобразовать ее в число с плавающей точкой:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren2">(<span class=""><span class="paren3">(<span class="">s <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_s_1.htm" class="symbol">make-string-input-stream</a> <span class="string">"1.23"</span></span>)</span></span>)</span></span>)</span> <br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_unwind.htm" class="symbol"><i><span class="symbol">unwind-protect</span></i></a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_rd.htm" class="symbol">read</a> s</span>)</span> <br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_close.htm" class="symbol">close</a> s</span>)</span></span>)</span></span>)</span> <br/></pre>

<p><code>MAKE-STRING-OUTPUT-STREAM</code> создает поток, который можно использовать с <code>FORMAT</code>, <code>PRINT</code>, <code>WRITE-CHAR</code>, <code>WRITE-LINE</code> и т.д. Она не принимает аргументов. Что бы вы не записывали, строковый поток вывода будет накапливать это в строке, которую потом можно получить с помощью функции <code>GET-OUTPUT-STREAM-STRING</code>. Каждый раз при вызове <code>GET-OUTPUT-STREAM-STRING</code> внутренняя строка потока очищается, поэтому существующий строковый поток вывода можно снова использовать.
</p>
<p>Однако, использовать эти функции напрямую вы будете редко, так как макросы <code>WITH-INPUT-FROM-STRING</code> и <code>WITH-OUTPUT-TO-STRING</code> предоставляют более удобный интерфейс. <code>WITH-INPUT-FROM-STRING</code> похожа на <code>WITH-OPEN-FILE</code> – она создает строковый поток ввода на основе переданной строки и выполняет код в своем теле с потоком, который присвоен переменной, вами предоставленной. Например, вместо формы <code>LET</code> с явным использованием <code>UNWIND-PROTECT</code>, вероятно, лучше написать:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_w_in_f.htm" class="symbol"><i><span class="symbol">with-input-from-string</span></i></a> <span class="paren2">(<span class="">s <span class="string">"1.23"</span></span>)</span> <br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_rd.htm" class="symbol">read</a> s</span>)</span></span>)</span><br/></pre>

<p>Макрос <code>WITH-OUTPUT-TO-STRING</code> также связывает вновь созданный строковый поток вывода с переменной, вами названной, и затем выполняет код в своем теле. После того, как код был выполнен, <code>WITH-OUTPUT-TO-STRING</code> вернет значение, которое было бы возвращено <code>GET-OUTPUT-STREAM-STRING</code>.
 
</p><pre class="code"><p>CL-USER&gt; <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_w_out_.htm" class="symbol"><i><span class="symbol">with-output-to-string</span></i></a> <span class="paren2">(<span class="">out</span>)</span> <br/>            <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> out <span class="string">"hello, world "</span></span>)</span> <br/>            <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> out <span class="string">"~s"</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> 1 2 3</span>)</span></span>)</span></span>)</span> <br/>
"hello, world <span class="paren1">(<span class="">1 2 3</span>)</span>" <br/></p></pre>

<p>Другие типы потоков, определенные в стандарте языка, предоставляют различные способы "соединения" потоков, то есть позволяют подключать потоки друг к другу почти в любой конфигурации. <code>BROADCAST-STREAM</code> – поток вывода, который посылает записанные данные множеству потоков вывода, переданных как аргументы функции-конструктору <code>MAKE-BROADCAST-STREAM</code>.<a class="fn_top" id="fnt__14" href="files-and-file-io#fn__14">14)</a> В противоположность этому, <code>CONCATENATED-STREAM</code> – поток ввода, который принимает ввод от множества потоков ввода, перемещаясь от потока к потоку, когда очередной поток достигает конца. Потоки <code>CONCATENATED-STREAM</code> создаются функцией <code>MAKE-CONCATENATED-STREAM</code>, которая принимает любое количество потоков ввода в качестве аргументов.
</p>
<p>Еще существуют два вида двунаправленных потоков, которые могут подключать потоки друг к другу – <code>TWO-WAY-STREAM</code> и <code>ECHO-STREAM</code>. Их функции-конструкторы, <code>MAKE-TWO-WAY-STREAM</code> и <code>MAKE-ECHO-STREAM</code>, обе принимают два аргумента, поток ввода и поток вывода, и возвращают поток соответствующего типа, который можно использовать как с потоками ввода, так и с потоками вывода.
</p>
<p>В случае <code>TWO-WAY-STREAM</code> потока, каждое чтение вернет данные из потока ввода, и каждая запись пошлет данные в поток вывода. <code>ECHO-STREAM</code> по существу работает точно так же кроме того, что все данные прочитанные из потока ввода также направляются в поток вывода. То есть поток вывода потока <code>ECHO-STREAM</code> будет содержать стенограмму "беседы" двух потоков.
</p>
<p>Используя эти пять типов потоков, можно построить почти любую топологию сети потоков, какую бы вы ни пожелали.
</p>
<p>В заключение, хотя стандарт Common Lisp не оговаривает какой-либо сетевой API, большинство реализаций поддерживают программирование сокетов и, как правило, реализуют сокеты как еще один тип потока. Следовательно, можно использовать с ними все обычные функции вводы/вывода.<a class="fn_top" id="fnt__15" href="files-and-file-io#fn__15">15)</a>
</p>
<p>Теперь вы готовы двигаться дальше для написания библиотеки, которая позволит сгладить некоторые различия поведения основных функций для работы с файловыми путями в различных реализациях Common Lisp.
</p></div></div><div class="footnotes"><div><a class="fn_bot" id="fn__1" href="files-and-file-io#fnt__1">1)</a>Заметим, однако, что считыватель Lisp, зная как пропускать комментарии, полностью их пропускает. Поэтому, если вы считаете конфигурационный файл, содержащий комментарии, при помощи <code>READ</code>, а затем запишете изменения при помощи <code>PRINT</code>, то потеряете все комментарии.</div><div><a class="fn_bot" id="fn__2" href="files-and-file-io#fnt__2">2)</a>По умолчанию <code>OPEN</code> использует кодировку, используемую в операционной системе, но возможно указать ключевой параметер <code>:external-format</code>, в котором передать используемую схему кодирования, отличную от используемой в операционной системе. Символьные потоки также преобразуют платформозависимые символы конца строки в символ #\Newline.</div><div><a class="fn_bot" id="fn__3" href="files-and-file-io#fnt__3">3)</a>Тип <code>(unsigned-byte 8)</code> обозначает 8-битный беззнаковый байт; "Байты" в Common Lisp могут иметь различный размер поскольку Lisp может выполняться на различных платформах с размерами байтов от 6 до 9 бит, к примеру PDP-10, может адресовать битовые поля различной длины от 1 до 36 бит.</div><div><a class="fn_bot" id="fn__4" href="files-and-file-io#fnt__4">4)</a>В общем, поток может быть либо символьным, либо бинарным, так что невозможно смешивать вызовы <code>READ-BYTE</code> с <code>READ-CHAR</code> и другими символьными функциями. Однако, в некоторых реализациях, таких как Allegro, поддерживаются так называемые бивалентные потоки, которые поддерживают как символьные так и байтовые операции ввода/вывода.</div><div><a class="fn_bot" id="fn__5" href="files-and-file-io#fnt__5">5)</a>Некоторые могут полагать, что это не является проблемой в языках со сборщиком мусора, таких как Lisp. В большинстве реализаций Lisp все потоки, которые больше не нужны, автоматически закрываются. Но на это не надо полагаться, так как сборщик мусора запускается, как правило, когда остается мало памяти. Он ничего не знает о других дефицитных ресурсах таких, как файловые дескрипторы. Если доступно много памяти, то доступные файловые дескрипторы могут быстро закончиться до вызова сборщика мусора.</div><div><a class="fn_bot" id="fn__6" href="files-and-file-io#fnt__6">6)</a>Еще одна причина, по которой система файловых путей выглядит причудливо, – введение логических файловых путей. Однако, вы можете плодотворно использовать систему файловых путей с единственной мыслью в голове о логических файловых путях: о них можно не вспоминать. В двух словах, логические файловые пути позволяют программам, написанных на Common Lisp, ссылаться на файловые пути без именования конкретного файла. Они могут быть отображены впоследствии на конкретную точку файловой системы, когда будет установлена ваша программа, при помощи "преобразования логических файловых путей", которое преобразует эти имена, соответствующие определенному образцу, в файловые пути, представляющие файлы в файловой системе, так называемые физические файловые пути. Они находят применение в определенных ситуациях, но вы может со спокойной душой пройти мимо них.</div><div><a class="fn_bot" id="fn__7" href="files-and-file-io#fnt__7">7)</a>Многие реализации Common Lisp под Unix трактуют файловые имена, чей последний элемент начинается с точки и не содержит больше других точек, следующим образом: помещают весь элемент – вместе с точкой – в компонент имя и оставляют компонент тип равным <code>NIL</code>.

<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_pn_hos.htm" class="symbol">pathname-name</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pn.htm" class="symbol">pathname</a> <span class="string">"/foo/.emacs"</span></span>)</span></span>)</span> -&gt; ".emacs" <br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_pn_hos.htm" class="symbol">pathname-type</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pn.htm" class="symbol">pathname</a> <span class="string">"/foo/.emacs"</span></span>)</span></span>)</span> -&gt; NIL <br/></pre>

Однако, не все реализации следуют этому соглашению. Некоторые создают файловый путь с пустой строкой в качестве имени и emacs в качестве типа.</div><div><a class="fn_bot" id="fn__8" href="files-and-file-io#fnt__8">8)</a>Имя, возвращенное функцией <code>FILE-NAMESTRING</code>, также включает компонент версия на файловой системе, которая использует это.</div><div><a class="fn_bot" id="fn__9" href="files-and-file-io#fnt__9">9)</a>Хост не может быть равным <code>NIL</code>, но если все же это так, то он будет заполнен значением, определенным конкретной реализаций.</div><div><a class="fn_bot" id="fn__10" href="files-and-file-io#fnt__10">10)</a>Для максимальной переносимости, следует писать:

<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_pn.htm" class="symbol">make-pathname</a> <span class="keyword">:type</span> <span class="string">"html"</span> <span class="keyword">:version</span> <span class="keyword">:newest</span> <span class="keyword">:defaults</span> input-file</span>)</span> <br/></pre>

Без аргумента :version на файловой системе с контролем версий, результирующий файловый путь унаследует номер версии от входного файла, который, вероятнее всего, будет неправильным, ведь если файл сохранялся не раз, он будет иметь больший номер, чем созданный <code>HTML</code> файл. В реализациях без поддержки контроля версий, аргумент <code>:version</code> должен игнорироваться. Забота о переносимости – на вашей совести.</div><div><a class="fn_bot" id="fn__11" href="files-and-file-io#fnt__11">11)</a>См. главу 19 насчет обработки ошибок.</div><div><a class="fn_bot" id="fn__12" href="files-and-file-io#fnt__12">12)</a>Для приложений, которым нужен доступ к другим атрибутам файла в определенной операционной системе или на файловой системе, некоторые библиотеки предоставляют обвязки (bindings) для системных вызовов. Библиотека Osicat, размещенная по адресу <a href="http://common-lisp.net/project/osicat/,">http://common-lisp.net/project/osicat/,</a> предоставляет простой API, созданный на основе Universal Foreign Function Interface (UFFI). Она должна работать с большинством реализаций Common Lisp на POSIX-совместимых операционных системах.</div><div><a class="fn_bot" id="fn__13" href="files-and-file-io#fnt__13">13)</a>Количество байтов и символов в файле может разниться, даже если не используется многобайтная кодировка. Потому что символьные потоки также преобразуют специфичные для платформы переносы строк в единственный символ <code>#\Newline</code>. В Windows, в которой используется <code>CRLF</code> в качестве переноса строки, количество символов, как правило, будет меньше чем количество байт. Если вам действительно требуется знать количество символов в файле, то вы должны набраться смелости и написать что-то похоже на:

<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_w_open.htm" class="symbol"><i><span class="symbol">with-open-file</span></i></a> <span class="paren2">(<span class="">in filename</span>)</span> <br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> while <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_cha.htm" class="symbol">read-char</a> in <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_countc.htm" class="symbol">count</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span></span>)</span> <br/></pre>

или, возможно, что-нибудь более эффективное, вроде этого:

<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_w_open.htm" class="symbol"><i><span class="symbol">with-open-file</span></i></a> <span class="paren2">(<span class="">in filename</span>)</span> <br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">scratch <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_stg.htm" class="symbol">make-string</a> 4096</span>)</span></span>)</span></span>)</span> <br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_rd.htm" class="symbol">read</a> = <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_seq.htm" class="symbol">read-sequence</a> scratch in</span>)</span> <br/>          while <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_minusp.htm" class="symbol">plusp</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_rd.htm" class="symbol">read</a></span>)</span> sum <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_rd.htm" class="symbol">read</a></span>)</span></span>)</span></span>)</span><br/></pre>
</div><div><a class="fn_bot" id="fn__14" href="files-and-file-io#fnt__14">14)</a><code>MAKE-BROADCAST-STREAM</code> может создать "черную дыру" для данных, если ее вызвать без аргументов.</div><div><a class="fn_bot" id="fn__15" href="files-and-file-io#fnt__15">15)</a>Наибольшим пробелом в стандартных средствах ввода/вывода Common Lisp является отсутствие способа определения пользователем новых типов потоков. Однако, для определения пользователем потоков существует два стандарта де-факто. Во время разработки стандарта Common Lisp, Дэвид Грэй (David Gray) из Texas Instruments предложил набросок API, который позволяет пользователям определять новые типы потоков. К сожалению, уже не оставалось времени для разбора всех трудностей, поднятых этим наброском, чтобы включить его в стандарт. Но все же много реализаций поддерживают в некоторой форме так называемые потоки Грэя. Они основывают свой API на наброске Грэя. Другой, более новый API – Simple Streams (простые потоки) – были разработаны компанией Franz и включены в Allegro Common Lisp. Они были разработаны, чтобы улучшить производительность определяемых пользователем потоков, схожих с потоками Грэя. Простые потоки позже переняли некоторые открытые реализации Common Lisp.</div></div></div> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="beyond-lists-other-uses-for-cons-cells">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right"> <a href="practical-a-portable-pathname-library">Следующая</a> </td> </tr> </tbody> </table> </div> <div class="bottom">@2009-2013 lisper.ru</div> 
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7734690-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
 </body> </html>