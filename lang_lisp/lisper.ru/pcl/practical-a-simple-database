<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru"> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <meta name="keywords" content="Common Lisp,lisp,лисп" /> <title>Практикум: Простая база данных</title> <link href="../css/style.css" rel="stylesheet" type="text/css" /><link href="../css/colorize.css" rel="stylesheet" type="text/css" />  </head> <body> <div class="top"> <div id="login"> <a href="http://lisper.ru/register">Регистрация</a> | <a href="http://lisper.ru/login?done=/pcl/practical-a-simple-database">Войти</a> </div> </div> <div id="caution"> <img alt="Lisp — программируемый язык программирования" src="../image/gecko.png" /> <a href="http://www.vkusnoserver.ru/" target="_blank" style="float: right;"> <img src="../vkusnoserver.png" /> </a> </div> <div id="mainmenu"> <ul> <li> <a href="http://lisper.ru/">Главная</a> </li><li> <a href="http://lisper.ru/articles/">Статьи</a> </li><li> <a href="http://lisper.ru/planet/">Планета</a> </li><li> <a href="http://lisper.ru/forum/">Форум</a> </li><li> <a href="http://lisper.ru/apps/">Сервисы</a> </li><li> <a href="index.html">Practical Common Lisp</a> </li><li> <a href="http://lisper.ru/wiki/">Wiki</a> </li><li> <a href="http://lisper.ru/files/">Файлы</a> </li><li> <a href="http://lisper.ru/search">Поиск</a> </li> </ul> </div> <div id="content"> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="lather-rinse-repeat-a-tour-of-the-repl">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right"> <a href="syntax-and-semantics">Следующая</a> </td> </tr> </tbody> </table> <div class="article"><div class="toc"><div class="toc-header">Содержание</div><div class="toc-body"><ul><li><div><a href="practical-a-simple-database#3. &#x41F;&#x440;&#x430;&#x43A;&#x442;&#x438;&#x43A;&#x443;&#x43C;: &#x41F;&#x440;&#x43E;&#x441;&#x442;&#x430;&#x44F; &#x431;&#x430;&#x437;&#x430; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;">3. Практикум: Простая база данных</a><ul><li><div><a href="practical-a-simple-database#CD &#x438; &#x417;&#x430;&#x43F;&#x438;&#x441;&#x438;">CD и Записи</a></div></li><li><div><a href="practical-a-simple-database#&#x417;&#x430;&#x43F;&#x43E;&#x43B;&#x43D;&#x435;&#x43D;&#x438;&#x435; CD">Заполнение CD</a></div></li><li><div><a href="practical-a-simple-database#&#x41F;&#x440;&#x43E;&#x441;&#x43C;&#x43E;&#x442;&#x440; &#x441;&#x43E;&#x434;&#x435;&#x440;&#x436;&#x438;&#x43C;&#x43E;&#x433;&#x43E; &#x431;&#x430;&#x437;&#x44B; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;">Просмотр содержимого базы данных</a></div></li><li><div><a href="practical-a-simple-database#&#x423;&#x43B;&#x443;&#x447;&#x448;&#x435;&#x43D;&#x438;&#x435; &#x432;&#x437;&#x430;&#x438;&#x43C;&#x43E;&#x434;&#x435;&#x439;&#x441;&#x442;&#x432;&#x438;&#x44F; &#x441; &#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x43E;&#x432;&#x430;&#x442;&#x435;&#x43B;&#x435;&#x43C;">Улучшение взаимодействия с пользователем</a></div></li><li><div><a href="practical-a-simple-database#&#x421;&#x43E;&#x445;&#x440;&#x430;&#x43D;&#x435;&#x43D;&#x438;&#x435; &#x438; &#x437;&#x430;&#x433;&#x440;&#x443;&#x437;&#x43A;&#x430; &#x431;&#x430;&#x437;&#x44B; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;">Сохранение и загрузка базы данных</a></div></li><li><div><a href="practical-a-simple-database#&#x412;&#x44B;&#x43F;&#x43E;&#x43B;&#x43D;&#x435;&#x43D;&#x438;&#x435; &#x437;&#x430;&#x43F;&#x440;&#x43E;&#x441;&#x43E;&#x432; &#x43A; &#x431;&#x430;&#x437;&#x435; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;">Выполнение запросов к базе данных</a></div></li><li><div><a href="practical-a-simple-database#&#x41E;&#x431;&#x43D;&#x43E;&#x432;&#x43B;&#x435;&#x43D;&#x438;&#x435; &#x441;&#x443;&#x449;&#x435;&#x441;&#x442;&#x432;&#x443;&#x44E;&#x449;&#x438;&#x445; &#x437;&#x430;&#x43F;&#x438;&#x441;&#x435;&#x439; &#x2014; &#x43F;&#x43E;&#x432;&#x442;&#x43E;&#x440;&#x43D;&#x43E;&#x435; &#x438;&#x441;&#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435; where">Обновление существующих записей — повторное использование where</a></div></li><li><div><a href="practical-a-simple-database#&#x418;&#x437;&#x431;&#x430;&#x432;&#x43B;&#x435;&#x43D;&#x438;&#x435; &#x43E;&#x442; &#x434;&#x443;&#x431;&#x43B;&#x438;&#x440;&#x443;&#x44E;&#x449;&#x435;&#x433;&#x43E; &#x43A;&#x43E;&#x434;&#x430; &#x438; &#x431;&#x43E;&#x43B;&#x44C;&#x448;&#x43E;&#x439; &#x432;&#x44B;&#x438;&#x433;&#x440;&#x44B;&#x448;">Избавление от дублирующего кода и большой выигрыш</a></div></li><li><div><a href="practical-a-simple-database#&#x41E;&#x431; &#x443;&#x43F;&#x430;&#x43A;&#x43E;&#x432;&#x43A;&#x435;">Об упаковке</a></div></li></ul></div></li></ul></div></div>
<div class="chapter" id="3. &#x41F;&#x440;&#x430;&#x43A;&#x442;&#x438;&#x43A;&#x443;&#x43C;: &#x41F;&#x440;&#x43E;&#x441;&#x442;&#x430;&#x44F; &#x431;&#x430;&#x437;&#x430; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;"><h3>3. Практикум: Простая база данных</h3>

<p>Очевидно, перед тем, как создавать настоящие программы на Lisp, вам необходимо изучить язык. Но давайте смотреть правде в глаза — вы можете подумать "Practical Common Lisp"? Не оксюморон ли это? Зачем тратить силы на изучение деталей языка, если на нем невозможно сделать что-то дельное?". Итак, для начала я приведу маленький пример того, что можно сделать с помощью Common Lisp. В этой главе вы напишете простую базу данных для организации коллекции CD. В главе 27 вы будете использовать схожую технику при создании базы данных записей в формате MP3 для вашего потокового MP3-сервера. Фактически, можете считать это частью вашего программного проекта — в конце концов, для того, чтобы иметь сколько-нибудь MP3-записей для прослушивания, совсем не помешает знать, какие записи у вас есть, а какие нужно извлечь с диска.
 
</p>
<p>В этой главе я пройдусь по языку Lisp достаточно для того, чтобы вы продвинулись до понимания того, каким образом работает код на нём. Но я не буду вдаваться в детали. Вы можете не беспокоиться, если что-то здесь будет вам непонятно — в нескольких следующих главах все используемые здесь (а также многие другие) конструкции Common Lisp будут описаны гораздо более систематически.
</p>
<p>Одно замечание по терминологии: в этой главе я расскажу о некоторых операторах Lisp. В главе 4 вы узнаете, что Common Lisp предоставляет три разных типа операторов: функции, макросы и операторы специального назначения. Для целей этой главы вам необязательно понимать разницу. Однако я буду ссылаться на различные операторы как на функции, макросы или специальные операторы, в зависимости от того, чем они на самом деле являются, вместо того, чтобы попытаться скрыть эти детали за одним словом — оператор. Сейчас вы можете рассматривать функции, макросы и специальные операторы как более или менее эквивалентные сущности<a class="fn_top" id="fnt__1" href="practical-a-simple-database#fn__1">1)</a>.
</p>
<p>Также имейте ввиду, что я не буду использовать все наиболее сложные техники Common Lisp для вашей первой после "Hello, world" программы. Цель этой главы не в том, чтобы показать, как вам следует писать базу данных на Lisp; скорее, цель в том, чтобы вы получили представление, на что похоже программирование на Lisp и видение того, что даже относительно простая программа на Lisp может иметь много возможностей.
</p>
<div class="chapter" id="CD &#x438; &#x417;&#x430;&#x43F;&#x438;&#x441;&#x438;"><h3>CD и Записи</h3>
<p>Чтобы отслеживать диски, которые нужно перекодировать в MP3, и знать, какие из них должны быть перекодированы в первую очередь, каждая запись в базе данных будет содержать название и имя исполнителя компакт диска, оценку того, насколько он нравится пользователю и флаг, указывающий, был ли диск уже перекодирован. Итак, для начала вам необходим способ представления одной записи в базе данных (другими словами, одного CD). Common Lisp предоставляет для этого много различных структур данных, от простого четырехэлементного списка до определяемого пользователем с помощью CLOS класса данных.
</p>
<p>Для начала вы можете остановиться на простом варианте и использовать список. Вы можете создать его с помощью функции <code>LIST</code>, которая, соответственно, возвращает <strong>список</strong> <a class="fn_top" id="fnt__2" href="practical-a-simple-database#fn__2">2)</a> из переданных аргументов.
</p><pre>CL-USER&gt; (list 1 2 3)<br/> (1 2 3)<br/></pre>
<p>Вы могли бы использовать четырёхэлементный список, отображающий позицию в списке на соответствующее поле записи. Однако другая существующая разновидность списков, называемая <em>property list</em> (список свойств) или, сокращенно, <em>plist</em>, в нашем случае гораздо удобнее. <em>Plist</em> — это такой список, в котором каждый нечетный элемент является <em>символом</em>, описывающим следующий (чётный) элемент списка. На этом этапе я не буду углубляться в подробности понятия <em>символ</em>; по своей природе это имя. Для символов, именующих поля в базе данных, мы можем использовать частный случай символов, называемый <em>символами-ключами</em> (<em>keyword symbol</em>). Ключ — это имя, начинающееся с двоеточия (:), например, :foo <a class="fn_top" id="fnt__3" href="practical-a-simple-database#fn__3">3)</a>. Вот пример <em>plist</em>, использующего символы-ключи :a, :b и :c как имена свойств:
</p><pre>CL-USER&gt; (list :a 1 :b 2 :c 3)<br/>(:A 1 :B 2 :C 3)<br/></pre>
<p>Заметьте, вы можете создать список свойств той же функцией <code>LIST</code>, которой создавали прочие списки. Характер содержимого — вот что делает его списком свойств.
</p>
<p>Причина, по которой использование <em>plist</em> является предпочтительным — наличие функции <code>GETF</code>, в которую передают <em>plist</em> и желаемый символ и получают следующее за символом значение. Это делает <em>plist</em> чем-то вроде упрощенной хэш-таблицы. В Lisp есть и "настоящие" хэш-таблицы, но для ваших текущих нужд достаточно <em>plist</em>, к тому же намного проще сохранять данные в такой форме в файл, это сильно пригодится позже.
</p><pre>CL-USER&gt; (getf (list :a 1 :b 2 :c 3) :a)<br/>1<br/>CL-USER&gt; (getf (list :a 1 :b 2 :c 3) :c)<br/>3<br/></pre>
<p>Теперь, зная это, вам будет достаточно просто написать функцию <code>make-cd</code>, которая получит четыре поля в качестве аргументов и вернёт <em>plist</em>, представляющий CD.
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> make-cd <span class="paren2">(<span class="">title artist rating ripped</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> <span class="keyword">:title</span> title <span class="keyword">:artist</span> artist <span class="keyword">:rating</span> rating <span class="keyword">:ripped</span> ripped</span>)</span></span>)</span><br/></pre>

<p>Слово <code>DEFUN</code> говорит нам,<a class="fn_top" id="fnt__4" href="practical-a-simple-database#fn__4">4)</a> что эта запись определяет новую функцию. Имя функции — <code>make-cd</code>. После имени следует список параметров. Функция содержит четыре параметра — <code>title</code>, <code>artist</code>, <code>rating</code> и <code>ripped</code>. Всё, что следует за списком параметров — тело функции. В данном случае <em>тело</em> — лишь форма, просто вызов функции <strong>LIST</strong>. При вызове <code>make-сd</code> параметры, переданные при вызове, будут связаны с переменными в списке параметров из объявления функции. Например, для создания записи о CD <em>Roses</em> от Kathy Mattea вы можете вызвать <code>make-cd</code> примерно так:
</p><pre> CL-USER&gt; (make-cd "Roses" "Kathy Mattea" 7 t)<br/> (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T) <br/></pre>
</div><div class="chapter" id="&#x417;&#x430;&#x43F;&#x43E;&#x43B;&#x43D;&#x435;&#x43D;&#x438;&#x435; CD"><h3>Заполнение CD</h3>
<p>Впрочем, создание одной записи — ещё не создание базы данных. Вам необходима более комплексная структура данных для хранения записей. Опять же, простоты ради, список представляется здесь вполне подходящим выбором. Также для простоты вы можете использовать глобальную переменную *db*, которую можно будет определить с помощью макроса <strong>DEFVAR</strong>. Звездочки (*) в имени переменной — это договоренность, принятая в языке Lisp при объявлении глобальных переменных. <a class="fn_top" id="fnt__5" href="practical-a-simple-database#fn__5">5)</a> 
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defpar.htm" class="symbol"><i><span class="symbol">defvar</span></i></a> <span class="special">*db*</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span><br/></pre>
<p>Для добавления элементов в *db* можно использовать макрос <strong>PUSH</strong>. Но разумнее немного абстрагировать вещи и определить функцию 'add-record', которая будет добавлять записи в базу данных.
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> add-record <span class="paren2">(<span class="">cd</span>)</span> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_push.htm" class="symbol">push</a> cd <span class="special">*db*</span></span>)</span></span>)</span><br/></pre>
<p>Теперь вы можете использовать <code>add-record</code> вместе с <code>make-cd</code> для добавления CD в базу данных.
</p><pre> CL-USER&gt; (add-record (make-cd "Roses" "Kathy Mattea" 7 t))<br/> ((:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))<br/> CL-USER&gt; (add-record (make-cd "Fly" "Dixie Chicks" 8 t))<br/> ((:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)<br/>  (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))<br/> CL-USER&gt; (add-record (make-cd "Home" "Dixie Chicks" 9 t))<br/> ((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)<br/>  (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)<br/>  (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T)) <br/></pre>
<p>Всё, что REPL выводит после каждого вызова <code>add-record</code> — значения, возвращаемые последним выражением в теле функции, в нашем случае — <code>PUSH</code>. А <code>PUSH</code> возвращает новое значение изменяемой им переменной. Таким образом, после каждого добавления порции данных вы видите содержимое вашей базы данных.
</p></div><div class="chapter" id="&#x41F;&#x440;&#x43E;&#x441;&#x43C;&#x43E;&#x442;&#x440; &#x441;&#x43E;&#x434;&#x435;&#x440;&#x436;&#x438;&#x43C;&#x43E;&#x433;&#x43E; &#x431;&#x430;&#x437;&#x44B; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;"><h3>Просмотр содержимого базы данных</h3>
<p>Вы также можете просмотреть текущее значение *db* в любой момент, набрав *db* в REPL.
</p><pre>CL-USER&gt; *db*<br/>((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)<br/> (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)<br/> (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))<br/></pre>
<p>Правда, это не лучший способ просмотра данных. Вы можете написать функцию <code>dump-db</code>, которая выводит содержимое базы данных в более читабельной форме, например, так:
</p><pre> TITLE:    Home<br/> ARTIST:   Dixie Chicks<br/> RATING:   9<br/> RIPPED:   T<br/> <br/> TITLE:    Fly<br/> ARTIST:   Dixie Chicks<br/> RATING:   8<br/> RIPPED:   T<br/> <br/> TITLE:    Roses<br/> ARTIST:   Kathy Mattea<br/> RATING:   7<br/> RIPPED:   T<br/></pre>
<p>Эта функция может выглядеть так:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> dump-db <span class="paren2">(<span class=""/>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_dolist.htm" class="symbol">dolist</a> <span class="paren3">(<span class="">cd <span class="special">*db*</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="string">"~{~a:~10t~a~%~}~%"</span> cd</span>)</span></span>)</span></span>)</span><br/></pre>
<p>Работа функции заключается в циклическом обходе всех элементов *db* с помощью макроса <strong>DOLIST</strong>, связывая на каждой итерации каждый элемент с переменной <code>cd</code>. Для вывода на экран каждого значения <code>cd</code> используется функция <code>FORMAT</code>.
</p>
<p>Следует признать, вызов <code>FORMAT</code> выглядит немного загадочно. Но в действительности <code>FORMAT</code> не особенно сложнее, чем функция <em>printf</em> из <strong>С</strong> или <strong>Perl</strong> или оператор % из <strong>Python</strong>. В главе 18 я расскажу о <code>FORMAT</code> более подробно. Теперь же давайте шаг за шагом рассмотрим, как работает этот вызов. Как было показано в гл. 2, <code>FORMAT</code> принимает по меньшей мере два аргумента, первый из которых — поток, в который <code>FORMAT</code> направляет свой вывод; <strong>t</strong> — сокращённое обозначение потока *standard-output*.
</p>
<p>Второй аргумент <code>FORMAT</code> — формат строки; он может как содержать символьный текст, так и управляющие команды, контролирующие работу этой функции, например то, как она должна интерпретировать остальные аргументы. Команды, управляющие форматом вывода, начинаются со знака тильды (<strong>~</strong>) (так же, как управляющие команды <em>printf</em> начинаются с %). <code>FORMAT</code> может принимать довольно много таких команд, каждую со своим набором параметров<a class="fn_top" id="fnt__6" href="practical-a-simple-database#fn__6">6)</a>. Однако сейчас я сфокусируюсь только на тех управляющих командах, которые необходимы для написания функции <code>dump-db</code>.
</p>
<p>Команда <strong>~a</strong> служит для придания выводимым строкам некоторой эстетичности. Она принимает аргумент и возвращает его в удобочитаемой форме. Эта команда отобразит ключевые слова без предваряющего двоеточия, и строки — без кавычек. Например:
</p><pre>CL-USER&gt; (format t "~a" "Dixie Chicks")<br/>Dixie Chicks<br/>NIL<br/></pre>
<p>или:
</p><pre>CL-USER&gt; (format t "~a" :title)<br/>TITLE<br/>NIL<br/></pre>

<p>Команда <strong>~t</strong> предназначена для табулирования. Например, <em>~10t</em> указывает <code>FORMAT</code>, что необходимо выделить достаточно места для перемещения в десятый столбец перед выполнением команды <em>~a</em>. <em>~t</em> не принимает аргументов. 
</p><pre>CL-USER&gt; (format t "~a:~10t~a" :artist "Dixie Chicks")<br/>ARTIST:   Dixie Chicks<br/>NIL<br/></pre>

<p>Теперь рассмотрим немного более сложные вещи. Когда <code>FORMAT</code> обнаруживает <em>~{</em>, следующим аргументом должен быть список. <code>FORMAT</code> циклично просматривает весь список, на каждой итерации выполняя команды между <em>~{</em> и <em>~}</em> и используя столько элементов списка, сколько нужно для вывода согласно этим командам. В функции <code>dump-db</code> <code>FORMAT</code> будет циклично просматривать список и на каждой итерации принимать одно ключевое слово и одно значение списка. Команда <strong>~%</strong> не принимает аргументов, но заставляет <code>FORMAT</code> выполнять переход на новую строку. После выполнения команды <strong>~}</strong> итерация заканчивается, и последняя <em>~%</em> заставляет <code>FORMAT</code> сделать ещё один переход на новую строку, чтобы записи, соответствующие каждому CD, были разделены.
Формально, вы также можете использовать <code>FORMAT</code> для вывода именно базы данных, сократив тело функции <code>dump-db</code> до одной строки.
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> dump-db <span class="paren2">(<span class=""/>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="string">"~{~{~a:~10t~a~%~}~%~}"</span> <span class="special">*db*</span></span>)</span></span>)</span><br/></pre>

<p>Это выглядит очень круто или очень страшно в зависимости от того как посмотреть.
</p>





</div><div class="chapter" id="&#x423;&#x43B;&#x443;&#x447;&#x448;&#x435;&#x43D;&#x438;&#x435; &#x432;&#x437;&#x430;&#x438;&#x43C;&#x43E;&#x434;&#x435;&#x439;&#x441;&#x442;&#x432;&#x438;&#x44F; &#x441; &#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x43E;&#x432;&#x430;&#x442;&#x435;&#x43B;&#x435;&#x43C;"><h3>Улучшение взаимодействия с пользователем</h3>
<p>Хотя функция <code>add-record</code> прекрасно выполняет свои обязанности, она слишком необычна для пользователя, не знакомого с Lisp. И если он захочет добавить в базу данных несколько записей, это может показаться ему довольно неудобным. В этом случае вы возможно захотите написать функцию, которая будет запрашивать у пользователя информацию о нескольких CD. В этом случае, вам нужен какой-то способ запросить эту информацию у пользователя и считать её. Для этого создадим следующую функцию:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> prompt-read <span class="paren2">(<span class="">prompt</span>)</span><br/> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/v_debug_.htm" class="symbol"><span class="special">*query-io*</span></a> <span class="string">"~a: "</span> prompt</span>)</span><br/> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_finish.htm" class="symbol">force-output</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/v_debug_.htm" class="symbol"><span class="special">*query-io*</span></a></span>)</span><br/> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_lin.htm" class="symbol">read-line</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/v_debug_.htm" class="symbol"><span class="special">*query-io*</span></a></span>)</span></span>)</span><br/></pre>

<p>Мы использовали уже знакомую нам функцию <code>FORMAT</code>, чтобы вывести приглашение. Заметим, что в строке, описывающей формат, отсутствует &lt;&lt;~%", поэтому перевода курсора на новую строку не происходит. Вызов <strong>FORCE-OUTPUT</strong> необходим в некоторых реализациях для уверенности в том, что Lisp не будет ожидать вывода новой строки перед выводом приглашения.
</p>
<p>Теперь прочитаем одну строку текста с помощью (очень удачно названной!) функции <strong>READ-LINE</strong>. Переменная <code>*QUERY-IO*</code> является глобальной (о чем можно догадаться по наличию в её имени символов <code>*</code>), она содержит входной поток, связанный с терминалом. Значение, возвращаемое функцией <strong>PROMPT-READ</strong> — это значение последней ее формы, вызова <code>READ-LINE</code>, возвращающего прочитанную им строку (без завершающего символа новой строки).
</p>
<p>Вы можете скомбинировать уже существующую функцию <code>make-cd</code> с <code>prompt-read</code>, чтобы построить функцию создания новой записи о CD из данных, которые <code>make-cd</code> по очереди получает для каждого значения.
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> prompt-for-cd <span class="paren2">(<span class=""/>)</span><br/> <span class="paren2">(<span class="">make-cd<br/>  <span class="paren3">(<span class="">prompt-read <span class="string">"Title"</span></span>)</span><br/>  <span class="paren3">(<span class="">prompt-read <span class="string">"Artist"</span></span>)</span><br/>  <span class="paren3">(<span class="">prompt-read <span class="string">"Rating"</span></span>)</span><br/>  <span class="paren3">(<span class="">prompt-read <span class="string">"Ripped [y/n]"</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Это почти правильно, если не считать того, что функция <code>prompt-read</code> возвращает строку. Это хорошо подходит для полей Title и Artist, но значения полей Rating и Ripped — числовое и булево. В зависимости от того, насколько развитым вы хотите сделать пользовательский интерфейс, можете проверять подстроки произвольной длины, чтобы удостовериться в корректности введённых пользователем данных. Теперь давайте опробуем самый очевидный (хотя и не лучший) вариант: мы можем упаковать вызов <code>prompt-read</code>, запрашивающий у пользователя его оценку диска, в вызов специфичной для Lisp функции <strong>PARSE-INTEGER</strong>. Это можно сделать так:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_parse_.htm" class="symbol">parse-integer</a> <span class="paren2">(<span class="">prompt-read <span class="string">"Rating"</span></span>)</span></span>)</span><br/></pre>

<p>К сожалению, по умолчанию функция <code>PARSE-INTEGER</code> сообщает об ошибке, если ей не удаётся разобрать число из введённой строки, или если в строке присутствует "нечисловой" мусор. Однако она может принимать дополнительный параметр :junk-allowed, который позволит нам ненадолго расслабиться.
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_parse_.htm" class="symbol">parse-integer</a> <span class="paren2">(<span class="">prompt-read <span class="string">"Rating"</span></span>)</span> <span class="keyword">:junk-allowed</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span><br/></pre>

<p>Остается ещё одна проблема — если <code>PARSE-INTEGER</code> не удастся выделить число среди "мусорных" данных, она вернёт не число, а <code>NIL</code>. Следуя нашему подходу "сделать просто, пусть даже не совсем правильно", мы в этом случае можем просто задать 0 и продолжить. Макрос <strong>OR</strong> здесь — как раз то, что нужно. Это то же самое, что и операция <strong>||</strong> в Perl, Python, Java и C. Макрос принимает набор выражений и вычисляет их по одному, слева направо. Если какое-нибудь из них дает истинное значение, то оно возвращается как результат макроса <strong>OR</strong>, а остальные — не вычисляются. Если все выражения оказываются ложными, тогда макрос <strong>OR</strong> возвращает ложь (<code>NIL</code>). Таким образом, используем следующую запись:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_or.htm" class="symbol">or</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_parse_.htm" class="symbol">parse-integer</a> <span class="paren3">(<span class="">prompt-read <span class="string">"Rating"</span></span>)</span> <span class="keyword">:junk-allowed</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span> 0</span>)</span><br/></pre>
<p>чтобы получить 0 в качестве значения по умолчанию.
</p>
<p>Исправление кода для запроса состояния Ripped немного проще. Можно воспользоваться стандартной функцией Common Lisp <strong>Y-OR-N-P</strong>.
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_y_or_n.htm" class="symbol">y-or-n-p</a> <span class="string">"Ripped [y/n]: "</span></span>)</span><br/></pre>

<p>Фактически, этот вызов является самой отказоустойчивой частью <code>prompt-for-cd</code>, поскольку <strong>Y-OR-N-P</strong> будет повторно запрашивать у пользователя состояние флага Ripped, если он введет что-нибудь, начинающееся не с <em>y</em>, <em>Y</em>, <em>n</em> или <em>N</em>.
</p>
<p>Собрав код вместе, получим достаточно надёжную функцию <code>prompt-for-cd</code>:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> prompt-for-cd <span class="paren2">(<span class=""/>)</span><br/>  <span class="paren2">(<span class="">make-cd<br/>   <span class="paren3">(<span class="">prompt-read <span class="string">"Title"</span></span>)</span><br/>   <span class="paren3">(<span class="">prompt-read <span class="string">"Artist"</span></span>)</span><br/>   <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_or.htm" class="symbol">or</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_parse_.htm" class="symbol">parse-integer</a> <span class="paren5">(<span class="">prompt-read <span class="string">"Rating"</span></span>)</span> <span class="keyword">:junk-allowed</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span> 0</span>)</span><br/>   <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_y_or_n.htm" class="symbol">y-or-n-p</a> <span class="string">"Ripped [y/n]: "</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Наконец, мы можем закончить интерфейс добавления CD, упаковав <code>prompt-for-cd</code> в функцию, циклично запрашивающую пользователя о новых данных. Воспользуемся простой формой макроса <strong>LOOP</strong>, выполняющего выражения в своём теле до тех пор, пока его выполнение не будет прервано вызовом <strong>RETURN</strong>. Например:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> add-cds <span class="paren2">(<span class=""/>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> <span class="paren3">(<span class="">add-record <span class="paren4">(<span class="">prompt-for-cd</span>)</span></span>)</span><br/>      <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_not.htm" class="symbol">not</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_y_or_n.htm" class="symbol">y-or-n-p</a> <span class="string">"Another? [y/n]: "</span></span>)</span></span>)</span> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_return.htm" class="symbol">return</a></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Теперь с помощью <code>add-cds</code> добавим в базу несколько новых дисков.
</p><pre>CL-USER&gt; (add-cds)<br/>Title: Rockin' the Suburbs<br/>Artist: Ben Folds<br/>Rating: 6<br/>Ripped  [y/n]: y<br/>Another?  [y/n]: y<br/>Title: Give Us a Break<br/>Artist: Limpopo<br/>Rating: 10<br/>Ripped  [y/n]: y<br/>Another?  [y/n]: y<br/>Title: Lyle Lovett<br/>Artist: Lyle Lovett<br/>Rating: 9<br/>Ripped  [y/n]: y<br/>Another?  [y/n]: n<br/>NIL<br/></pre>


</div><div class="chapter" id="&#x421;&#x43E;&#x445;&#x440;&#x430;&#x43D;&#x435;&#x43D;&#x438;&#x435; &#x438; &#x437;&#x430;&#x433;&#x440;&#x443;&#x437;&#x43A;&#x430; &#x431;&#x430;&#x437;&#x44B; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;"><h3>Сохранение и загрузка базы данных</h3>
<p>Хорошо иметь удобный способ добавления записей в базу данных. Но пользователю вряд ли понравится заново добавлять все записи после каждого перезапуска Lisp. К счастью, используя текущие структуры данных, используемые для представления информации, сохранить данные в файл и загрузить их позже — задача тривиальная. Далее приводится функция <code>save-db</code>, которая принимает в качестве параметра имя файла и сохраняет в него текущее состояние базы данных:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> save-db <span class="paren2">(<span class="">filename</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_w_open.htm" class="symbol"><i><span class="symbol">with-open-file</span></i></a> <span class="paren3">(<span class="">out filename<br/>                   <span class="keyword">:direction</span> <span class="keyword">:output</span><br/>                   <span class="keyword">:if-exists</span> <span class="keyword">:supersede</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_w_std_.htm" class="symbol"><i><span class="symbol">with-standard-io-syntax</span></i></a><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm" class="symbol">print</a> <span class="special">*db*</span> out</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Макрос <strong>WITH-OPEN-FILE</strong> открывает файл, связывает поток с переменной, выполняет набор инструкций и затем закрывает файл. Он также гарантирует, что файл обязательно закроется, даже если во время выполнения тела макроса что-то пойдет не так. Список, находящийся сразу после <strong>WITH-OPEN-FILE</strong>, является не вызовом функции, а частью синтаксиса, определяемого этим макросом. Он содержит имя переменной, хранящей файловый поток, в который в теле макроса <strong>WITH-OPEN-FILE</strong> будет вестись запись, значение, которое должно быть именем файла, и несколько параметров, управляющих режимом открытия файла. В нашем примере файл будет открыт для записи (задаётся параметром <code>:direction</code> <code>:output</code>), и, если файл с таким именем уже существует, его содержимое будет перезаписано (параметр <code>:if-exists</code> <code>:supersede</code>).
</p>
<p>После того, как файл открыт, всё, что вам нужно — это печать содержимого базы данных с помощью <code>(print *db* out)</code>. В отличие от <strong>FORMAT</strong>, функция <strong>PRINT</strong> печатает объекты Lisp в форме, которую Lisp может прочитать. Макрос <strong>WITH-STANDARD-IO-SYNTAX</strong> гарантирует, что переменным, влияющим на поведение функции <strong>PRINT</strong>, присвоены стандартные значения. Используйте этот же макрос и при чтении данных из файла для гарантии совместимости операций записи и чтения.
</p>
<p>Аргументом функции <code>save-db</code> должна являться строка, содержащая имя файла, в который пользователь хочет сохранить базу данных. Точный формат строки зависит от используемой операционной системы. Например, в Unix пользователь может вызвать функцию <code>save-db</code> таким образом:
</p><pre>CL-USER&gt; (save-db "~/my-cds.db")<br/>((:TITLE "Lyle Lovett" :ARTIST "Lyle Lovett" :RATING 9 :RIPPED T)<br/> (:TITLE "Give Us a Break" :ARTIST "Limpopo" :RATING 10 :RIPPED T)<br/> (:TITLE "Rockin' the Suburbs" :ARTIST "Ben Folds" :RATING 6 :RIPPED T)<br/> (:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)<br/> (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)<br/> (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 9 :RIPPED T))<br/></pre>

<p>В Windows имя файла может выглядеть так: <code>c:/my-cds.db</code>. Или так: <code>c:<br/>my-cds.db</code><a class="fn_top" id="fnt__7" href="practical-a-simple-database#fn__7">7)</a>.
</p>
<p>Вы можете открыть этот файл в любом текстовом редакторе и посмотреть как выглядят записи. Вы должны увидеть что-то очень похожее на вывод REPL если наберёте <code>*db*</code>.
</p>
<p>Функция загрузки базы данных из файла реализуется аналогично:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> load-db <span class="paren2">(<span class="">filename</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_w_open.htm" class="symbol"><i><span class="symbol">with-open-file</span></i></a> <span class="paren3">(<span class="">in filename</span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_w_std_.htm" class="symbol"><i><span class="symbol">with-standard-io-syntax</span></i></a><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="special">*db*</span> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rd_rd.htm" class="symbol">read</a> in</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>В этот раз нет необходимости задавать <code>:direction</code> в параметрах <code>WITH-OPEN-FILE</code>, так как её значение по умолчанию — <code>:input</code>. И вместо печати вы используете функцию <strong>READ</strong> для чтения из потока <code>in</code>. Это тот же считыватель, что и в REPL, и он может прочитать любое выражение на Lisp, которое можно написать в строке приглашения REPL. Однако, в нашем случае, вы просто читаете и сохраняете выражение, не выполняя его. И снова, макрос <code>WITH-STANDARD-IO-SYNTAX</code> гарантирует, что <code>READ</code> использует тот же базовый синтаксис, что и функция <code>save-db</code>, когда она печатает данные с помощью <code>PRINT</code>.
</p>
<p>Макрос <strong>SETF</strong> является главным оператором присваивания в Common Lisp. Он присваивает своему первому аргументу результат вычисления второго аргумента. Таким образом, в <code>load-db</code> переменная <code>*db*</code> будет содержать объект, прочитанный из файла, а именно, список списков, записанных функцией <code>save-db</code>. Обратите внимание на то, что <code>load-db</code> затирает то, что было в <code>*db*</code> до её вызова. Так что, если вы добавили записи, используя <code>add-records</code> или <code>add-cds</code>, и не сохранили их функцией <code>save-db</code>, эти записи будут потеряны.
</p>
</div><div class="chapter" id="&#x412;&#x44B;&#x43F;&#x43E;&#x43B;&#x43D;&#x435;&#x43D;&#x438;&#x435; &#x437;&#x430;&#x43F;&#x440;&#x43E;&#x441;&#x43E;&#x432; &#x43A; &#x431;&#x430;&#x437;&#x435; &#x434;&#x430;&#x43D;&#x43D;&#x44B;&#x445;"><h3>Выполнение запросов к базе данных</h3>
<p>Теперь, когда у вас есть способ сохранения и загрузки базы данных вместе с удобным интерфейсом для добавления новых записей, ваша коллекция в скором времени может разрастись до такого размера, что вы уже не захотите распечатывать всю базу данных лишь для того, чтобы просмотреть её содержимое. Вам нужно как-то выполнять запросы к базе данных. Возможно, что вы предпочли бы написать что-нибудь вроде:
</p><pre>(select :artist "Dixie Chicks")<br/></pre>
<p>и в ответ на этот запрос получить список всех записей исполнителя Dixie Chicks. И снова оказалось, что выбор списка в качестве контейнера данных был очень удачным.
</p>
<p>Функция <strong>REMOVE-IF-NOT</strong> принимает предикат и список в качестве параметров и возвращает список, содержащий только элементы исходного списка, удовлетворяющие предикату. Другими словами, она удаляет все элементы, не удовлетворяющие предикату. На самом деле, <code>REMOVE-IF-NOT</code> ничего не удаляет — она создает новый список, оставляя исходный список нетронутым. Эта операция аналогична работе утилиты grep. Предикатом может быть любая функция, принимающая один аргумент и возвращающая логическое значение — <code>NIL</code> (ложь) или любое другое значение (истина).
</p>
<p>Например, если вы хотите получить все чётные элементы из списка чисел, можете использовать <code>REMOVE-IF-NOT</code> таким образом:
</p><pre>CL-USER&gt; (remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9 10))<br/>(2 4 6 8 10)<br/></pre>
<p>В этом случае предикатом является функция <strong>EVENP</strong>, которая возвращает "истину", если её аргумент — чётное число. Нотация #' является сокращением выражения "Получить функцию с данным именем". Без #' Lisp обратится к <code>EVENP</code> как к имени переменной и попытается получить ее значение, а не саму функцию.
</p>
<p>Вы также можете передать в <code>REMOVE-IF-NOT</code> анонимную функцию. Например, если бы <code>EVENP</code> не существовало, вы могли бы так написать предыдущее выражение:
</p><pre>CL-USER&gt; (remove-if-not #'(lambda (x) (= 0 (mod x 2))) '(1 2 3 4 5 6 7 8 9 10))<br/>(2 4 6 8 10)<br/></pre>
<p>В этом случае предикатом является анонимная функция
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren2">(<span class="">x</span>)</span> <span class="paren2">(<span class="">= 0 <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_mod.htm" class="symbol">mod</a> x 2</span>)</span></span>)</span></span>)</span><br/></pre>
<p>которая проверяет, равен ли нулю остаток от деления аргумента на 2 (другими словами, является ли аргумент чётным). Если вы хотите извлечь только нечётные числа, используя анонимную функцию, вы можете написать следующее:
</p><pre>CL-USER&gt; (remove-if-not #'(lambda (x) (= 1 (mod x 2))) '(1 2 3 4 5 6 7 8 9 10))<br/>(1 3 5 7 9)<br/></pre>
<p>Заметьте, что <strong>lambda</strong> не является именем функции — это слово показывает, что вы определяете анонимную функцию<a class="fn_top" id="fnt__8" href="practical-a-simple-database#fn__8">8)</a>. Если не считать имени, <code>LAMBDA</code>-выражение выглядит очень похожим на <code>DEFUN</code>: после слова <code>lambda</code> следует список параметров, за которым идёт тело функции.
</p>
<p>Чтобы выбрать все альбомы Dixie Chicks из базы данных, используя <code>REMOVE-IF-NOT</code>, вам нужна функция, возвращающая "истину", если поле в записи <code>artist</code> содержит значение "Dixie Chicks". Помните, мы выбрали <em>список свойств</em> в качестве представления записей базы данных, потому что функция <code>GETF</code> может извлекать из <em>списка свойств</em> именованные поля. Итак, полагая, что <code>cd</code> является именем переменной, хранящей одну запись базы данных, вы можете использовать выражение <code>(getf cd :artist)</code>, чтобы извлечь имя исполнителя. Функция <strong>EQUAL</strong> посимвольно сравнивает переданные ей строковые параметры. Таким образом, <code>(equal (getf cd :artist) "Dixie Chicks")</code> проверит, хранит ли поле <code>artist</code>, для текущей записи в переменной cd, значение "Dixie Chicks". Всё, что вам нужно — упаковать это выражение в <code>LAMBDA</code>-форму, чтобы создать анонимную функцию и передать ее <code>REMOVE-IF-NOT</code>.
</p><pre>CL-USER&gt; (remove-if-not<br/>  #'(lambda (cd) (equal (getf cd :artist) "Dixie Chicks")) *db*)<br/>((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)<br/> (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T))<br/></pre>

<p>Предположим теперь, что вы хотите упаковать всё выражение в функцию, которая принимает имя исполнителя в качестве параметра. Вы можете записать это так:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> select-by-artist <span class="paren2">(<span class="">artist</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rm_rm.htm" class="symbol">remove-if-not</a><br/>   #'<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren4">(<span class="">cd</span>)</span> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_equal.htm" class="symbol">equal</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> cd <span class="keyword">:artist</span></span>)</span> artist</span>)</span></span>)</span><br/>   <span class="special">*db*</span></span>)</span></span>)</span><br/></pre>

<p>Заметьте, что анонимная функция, содержит код, который не будет выполнен, пока функция не вызвана в <code>REMOVE-IF-NOT</code>, тем не менее она может ссылаться на переменную <code>artist</code>. В этом случае анонимная функция не просто избавляет вас от необходимости писать обычную функцию, — она позволяет вам написать функцию, которая берет часть своего значения - содержимое поля <code>artist</code> - из контекста в котором она вызывается.
</p>
<p>Итак, мы покончили с функцией <code>select-by-artist</code>. Однако выборка по исполнителю — лишь одна разновидность запросов, которые вам захочется реализовать. Вы можете написать ещё несколько функций, таких, как <code>select-by-title</code>, <code>select-by-rating</code>, <code>select-by-title-and-artist</code>, и так далее. Но все они будут идентичными, за исключением содержимого анонимной функции. Вместо этого вы можете создать более универсальную функцию <code>select</code>, которая принимает функцию в качестве аргумента.
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> select <span class="paren2">(<span class="">selector-fn</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rm_rm.htm" class="symbol">remove-if-not</a> selector-fn <span class="special">*db*</span></span>)</span></span>)</span><br/></pre>

<p>А что случилось с <code>#</code>'? Дело в том, что в этом случае вам не нужно, чтобы функция <code>REMOVE-IF-NOT</code> использовала функцию под названием <code>selector-fn</code>. Вы хотите, чтобы она использовала анонимную функцию, переданную в качестве аргумента функции <code>select</code> в переменной <code>selector-fn</code>. Однако, символ #' вернулся в вызов <code>select</code>:
</p><pre>CL-USER&gt; (select #'(lambda (cd) (equal (getf cd :artist) "Dixie Chicks")))<br/>((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)<br/> (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T))<br/></pre>
<p>Правда, это выглядит довольно грубо. К счастью, вы можете упаковать создание анонимной функции.
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> artist-selector <span class="paren2">(<span class="">artist</span>)</span><br/>  #'<span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren3">(<span class="">cd</span>)</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_equal.htm" class="symbol">equal</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> cd <span class="keyword">:artist</span></span>)</span> artist</span>)</span></span>)</span></span>)</span><br/></pre>

<p><code>artist-selector</code> возвращает функцию, имеющую ссылку на переменную, которая перестанет существовать после выхода из <code>artist-selector</code><a class="fn_top" id="fnt__9" href="practical-a-simple-database#fn__9">9)</a>. Функция выглядит странно, но она работает именно так, как нам нужно — если вызвать <code>artist-selector</code> с аргументом "Dixie Chicks", мы получим анонимную функцию, которая ищет CD с полем <code>:artist</code>, содержащим "Dixie Chicks", и если вызвать её с аргументом "Lyle Lovett", то мы получим другую функцию, которая будет искать CD с полем <code>:artist</code>, содержащим "Lyle Lovett". Итак, мы можем переписать вызов <code>select</code> следующим образом:
</p><pre>CL-USER&gt; (select (artist-selector "Dixie Chicks"))<br/>  ((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)<br/>   (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T))<br/></pre>
<p>Теперь нам понадобится больше функций, чтобы генерировать выражения для выбора. Но так как вы не хотите писать <code>select-by-title</code>, <code>select-by-rating</code> и др., потому что они будут во многом схожими, вы не станете создавать множество почти идентичных генераторов выражений для выбора значений для каждого из полей. Почему бы не написать генератор функции-выражения для выбора общего назначения — функцию, которая, в зависимости от передаваемых ей аргументов, будет генерировать выражение выбора для разных полей или, может быть, даже комбинации полей? Вы можете написать такую функцию, но сначала нам придётся пройти краткий курс для овладения средством, называемым <em>параметрами-ключами</em> (keyword parameters).
</p>
<p>В функциях, что вы писали до этого, вы задавали простой список параметров, которые связывались с соответствующими аргументами в вызове функции. Например, следующая функция:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> foo <span class="paren2">(<span class="">a b c</span>)</span> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> a b c</span>)</span></span>)</span><br/></pre>
<p>имеет три параметра: <code>a</code>, <code>b</code> и <code>c</code>, и должна быть вызвана с тремя аргументами. Но иногда возникает необходимость в вызове функции, которая может вызываться с переменным числом аргументов. Параметры-ключи — один из способов это сделать. Версия <code>foo</code> с использованием параметров-ключей может выглядеть так:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> foo <span class="paren2">(<span class="">&amp;key a b c</span>)</span> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> a b c</span>)</span></span>)</span><br/></pre>

<p>Единственное отличие — элемент <strong>&amp;key</strong> в начале списка аргументов. Однако вызовы новой функции <code>foo</code> выглядят немного по-другому. Все нижеперечисленные варианты вызова <code>foo</code> допустимы, результат вызова помещён справа от </p>==&gt;<p>.
</p><pre>(foo :a 1 :b 2 :c 3)  ==&gt; (1 2 3)<br/>(foo :c 3 :b 2 :a 1)  ==&gt; (1 2 3)<br/>(foo :a 1 :c 3)       ==&gt; (1 NIL 3)<br/>(foo)                 ==&gt; (NIL NIL NIL)<br/></pre>
<p>Как показывают эти примеры, значения переменных <code>a</code>, <code>b</code> и <code>c</code> привязаны к значениям, которые следуют за соответствующими ключевыми словами. И если какой-либо ключ в вызове отсутствует, соответствующая переменная устанавливается в <code>NIL</code>. Я не буду уточнять, как именно задаются ключевые параметры и как они соотносятся с другими типами параметров, но вам важно знать одну деталь.
</p>
<p>Обычно, когда функция вызывается без аргумента для конкретного параметра-ключа, параметр будет иметь значение <code>NIL</code>. Но иногда нужно различать <code>NIL</code>, который был явно передан в качестве аргумента к параметру-ключу, и <code>NIL</code>, который задаётся по умолчанию. Чтобы сделать это, при задании параметра-ключа вы можете заменить обычное имя списком, состоящим из имени параметра, его значения по умолчанию и другого имени параметра, называемого параметром <code>supplied-p</code>. Этот параметр <code>supplied-p</code> будет содержать значения "истина" или "ложь", в зависимости от того, действительно ли для данного параметра-ключа в данном вызове функции был передан аргумент. Вот версия новой функции <code>foo</code>, которая использует эту возможность.
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> foo <span class="paren2">(<span class="">&amp;key a <span class="paren3">(<span class="">b 20</span>)</span> <span class="paren3">(<span class="">c 30 c-p</span>)</span></span>)</span> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> a b c c-p</span>)</span></span>)</span><br/></pre>

<p>Результаты тех же вызовов теперь выглядят иначе:
</p>
<pre>(foo :a 1 :b 2 :c 3)  ==&gt; (1 2 3 T)<br/>(foo :c 3 :b 2 :a 1)  ==&gt; (1 2 3 T)<br/>(foo :a 1 :c 3)       ==&gt; (1 20 3 T)<br/>(foo)                 ==&gt; (NIL 20 30 NIL)<br/></pre>
<p>Основной генератор выражения выбора, FIXME который по причинам, которые, если вы знакомы с SQL, скоро станут очевидными, можно назвать <strong>where</strong>, является функцией, принимающей четыре параметра-ключа для соответствующих полей в наших записях CD и генерирующей выражение выбора, которое возвращает все записи о CD, совпадающие со значениями, задаваемым в <code>where</code>. Например, можно будет написать такое выражение:
</p><pre class="code"><span class="paren1">(<span class="">select <span class="paren2">(<span class="">where <span class="keyword">:artist</span> <span class="string">"Dixie Chicks"</span></span>)</span></span>)</span><br/></pre>
<p>Или такое:
</p><pre class="code"><span class="paren1">(<span class="">select <span class="paren2">(<span class="">where <span class="keyword">:rating</span> 10 <span class="keyword">:ripped</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span></span>)</span><br/></pre>

<p>Функция выглядит так:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> where <span class="paren2">(<span class="">&amp;key title artist rating <span class="paren3">(<span class="">ripped <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a> ripped-p</span>)</span></span>)</span><br/>  #'<span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren3">(<span class="">cd</span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_and.htm" class="symbol">and</a><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> title    <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_equal.htm" class="symbol">equal</a> <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> cd <span class="keyword">:title</span></span>)</span>  title</span>)</span>  <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> artist   <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_equal.htm" class="symbol">equal</a> <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> cd <span class="keyword">:artist</span></span>)</span> artist</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> rating   <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_equal.htm" class="symbol">equal</a> <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> cd <span class="keyword">:rating</span></span>)</span> rating</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> ripped-p <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_equal.htm" class="symbol">equal</a> <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> cd <span class="keyword">:ripped</span></span>)</span> ripped</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Эта функция возвращает анонимную функцию, возвращающую логическое И для одного условия в каждом поле записей о CD. Каждое условие проверяет, задан ли подходящий аргумент, и если задан, то сравнивает его значение со значением соответствующего поля в записи о CD, или возвращает <code>t</code>, обозначение истины в Lisp, если аргумент не был задан. Таким образом, выражение выбора возвратит <code>t</code> только для тех CD, описание которых совпало по значению с аргументами переданными <code>where</code><a class="fn_top" id="fnt__10" href="practical-a-simple-database#fn__10">10)</a>. Заметьте, что, чтобы задать ключ-параметр <code>ripped</code>, вам необходимо использовать список из трёх элементов, потому что вам нужно знать, действительно ли вызывающая функция передала ключ-параметр <code>:ripped nil</code>, означающее "Выбрать те CD, в поле <code>ripped</code> которых установлено значение <code>nil</code>", либо опустила его, что означает "Мне всё равно, какое значение установлено в поле <code>ripped</code>".
</p>





</div><div class="chapter" id="&#x41E;&#x431;&#x43D;&#x43E;&#x432;&#x43B;&#x435;&#x43D;&#x438;&#x435; &#x441;&#x443;&#x449;&#x435;&#x441;&#x442;&#x432;&#x443;&#x44E;&#x449;&#x438;&#x445; &#x437;&#x430;&#x43F;&#x438;&#x441;&#x435;&#x439; &#x2014; &#x43F;&#x43E;&#x432;&#x442;&#x43E;&#x440;&#x43D;&#x43E;&#x435; &#x438;&#x441;&#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435; where"><h3>Обновление существующих записей — повторное использование where</h3>
<p>Теперь, после того, как у вас есть достаточно универсальные функции <code>select</code> и <code>where</code>, очень логичной представляется реализация следующей возможности, которая необходима каждой базе данных, — возможности обновления отдельных записей. В SQL команда <code>update</code> используется для обновления набора записей, удовлетворяющих конкретному условию <code>where</code>. Эта модель кажется хорошей, особенно когда у вас уже есть генератор условий <code>where</code>. Фактически, функция <code>update</code> — применение некоторых идей, которые вы уже видели: использование передаваемого выражения выбора для указания записей, подлежащих обновлению, и использование аргументов-ключей для задания нового значения. Новая вещь здесь — использование функции <strong>MAPCAR</strong>, которая проходит по списку, в нашем случае это <code>*db*</code>, и возвращает новый список, содержащий результаты вызова функции для каждого элемента исходного списка.
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> update <span class="paren2">(<span class="">selector-fn &amp;key title artist rating <span class="paren3">(<span class="">ripped <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a> ripped-p</span>)</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="special">*db*</span><br/>        <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mapc_.htm" class="symbol">mapcar</a><br/>         #'<span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren5">(<span class="">row</span>)</span><br/>             <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_funcal.htm" class="symbol">funcall</a> selector-fn row</span>)</span><br/>               <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> title    <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> row <span class="keyword">:title</span></span>)</span> title</span>)</span></span>)</span><br/>               <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> artist   <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> row <span class="keyword">:artist</span></span>)</span> artist</span>)</span></span>)</span><br/>               <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> rating   <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> row <span class="keyword">:rating</span></span>)</span> rating</span>)</span></span>)</span><br/>               <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> ripped-p <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> row <span class="keyword">:ripped</span></span>)</span> ripped</span>)</span></span>)</span></span>)</span><br/>             row</span>)</span> <span class="special">*db*</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Ещё одна новинка в этой функции<a class="fn_top" id="fnt__11" href="practical-a-simple-database#fn__11">11)</a> — приложение <code>SETF</code> к сложной форме вида <code>(getf row :title)</code>. Я расскажу о <code>SETF</code> подробнее в главе 6, но сейчас вам просто нужно знать, что это общий оператор присваивания, который может использоваться для присваивания друг другу различных "вещей", а не только переменных. (То, что <code>SETF</code> и <code>GETF</code> имеют настолько похожие имена — просто совпадение. Между ними нет никакой особой взаимосвязи). Сейчас достаточно знать, что после выполнения <code>(setf (getf row :title) title)</code> у списка свойств, на который ссылается <code>row</code>, значением переменной, следующей за именем свойства <code>:title</code>, будет title. С помощью функции <code>update</code>, если вы решите, что действительно любите творчество Dixie Chicks, и что все их альбомы должны быть оценены в 11 баллов, можете выполнить следующую форму<a class="fn_top" id="fnt__12" href="practical-a-simple-database#fn__12">12)</a>:
</p><pre>CL-USER&gt; (update (where :artist "Dixie Chicks") :rating 11)<br/>NIL<br/></pre>
<p>Результат работы функции будет выглядеть так:
</p><pre>CL-USER&gt; (select (where :artist "Dixie Chicks"))<br/>((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 11 :RIPPED T)<br/> (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 11 :RIPPED T))<br/></pre>
<p>Добавить функцию удаления строк из базы данных еще проще.
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> delete-rows <span class="paren2">(<span class="">selector-fn</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="special">*db*</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rm_rm.htm" class="symbol">remove-if</a> selector-fn <span class="special">*db*</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Функция <strong>REMOVE-IF</strong> является дополнением к <code>REMOVE-IF-NOT</code>, она возвращает список всех элементов, удалив те из них, что удовлетворяют предикату. Так же, как и <code>REMOVE-IF-NOT</code>, она, в действительности, не изменяет список, который был ей передан в качестве параметра, тем не менее, сохраняя результат обратно в <code>*db*</code>, <code>delete-rows</code><a class="fn_top" id="fnt__13" href="practical-a-simple-database#fn__13">13)</a> фактически изменяет содержимое базы данных<a class="fn_top" id="fnt__14" href="practical-a-simple-database#fn__14">14)</a>.
</p>






</div><div class="chapter" id="&#x418;&#x437;&#x431;&#x430;&#x432;&#x43B;&#x435;&#x43D;&#x438;&#x435; &#x43E;&#x442; &#x434;&#x443;&#x431;&#x43B;&#x438;&#x440;&#x443;&#x44E;&#x449;&#x435;&#x433;&#x43E; &#x43A;&#x43E;&#x434;&#x430; &#x438; &#x431;&#x43E;&#x43B;&#x44C;&#x448;&#x43E;&#x439; &#x432;&#x44B;&#x438;&#x433;&#x440;&#x44B;&#x448;"><h3>Избавление от дублирующего кода и большой выигрыш</h3>
<p>До сих пор весь код базы данных, обеспечивающий операции <code>INSERT</code>, <code>SELECT</code>, <code>UPDATE</code> и <code>DELETE</code>, если не считать интерфейс командной строки для добавления новых записей и распечатки содержимого базы, укладывался в немногим более пятидесяти строк. Целиком<a class="fn_top" id="fnt__15" href="practical-a-simple-database#fn__15">15)</a>.
</p>
<p>Всё еще существует некоторое раздражающее дублирование кода. И, оказывается, вы можете избавиться от этого дублирования, в то же время сделав код более гибким. Дублирование, о котором я говорю, находится в функции <code>where</code>. Тело функции <code>where</code> — набор условий для каждого поля, таких, как это:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> title <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_equal.htm" class="symbol">equal</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> cd <span class="keyword">:title</span></span>)</span> title</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span><br/></pre>

<p>Сейчас это не так плохо, но, как и во многих случаях дублирования кода, за это всегда приходится платить одну цену: если вы хотите изменить работу этого кода, вам нужно изменять множество копий. И если вы изменили поля в CD, вам придётся добавить или удалить условия для <code>where</code>. <code>update</code> страдает точно таким же дублированием. Это, несомненно, плохо, так как весь смысл функции <code>where</code> заключается в динамической генерации куска кода, проверяющего нужные нам значения; почему она должна производить работу во время выполнения, каждый раз проверяя, было ли ей передано значение <code>title</code>?
</p>
<p>Представьте, что вы попытались оптимизировать этот код и обнаружили, что много времени тратится на проверку того, заданы ли значения <code>title</code> и оставшиеся ключ-параметры<a class="fn_top" id="fnt__16" href="practical-a-simple-database#fn__16">16)</a>. Если вы на самом деле хотите избавиться от этих проверок во время выполнения, вы можете просмотреть программу и найти все места, где вы вызываете <code>where</code>, и посмотреть, какие аргументы вы передаёте. Затем вы можете заменить каждый вызов <code>where</code> анонимной функцией, выполняющей только необходимое вычисления. Например, если вы нашли такой кусок кода:
</p><pre class="code"><span class="paren1">(<span class="">select <span class="paren2">(<span class="">where <span class="keyword">:title</span> <span class="string">"Give Us a Break"</span> <span class="keyword">:ripped</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span></span>)</span><br/></pre>
<p>вы можете заменить его на такой:
</p><pre class="code"><span class="paren1">(<span class="">select<br/> #'<span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren3">(<span class="">cd</span>)</span><br/>     <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_and.htm" class="symbol">and</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_equal.htm" class="symbol">equal</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> cd <span class="keyword">:title</span></span>)</span> <span class="string">"Give Us a Break"</span></span>)</span><br/>          <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_equal.htm" class="symbol">equal</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> cd <span class="keyword">:ripped</span></span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Заметьте, что анонимная функция отличается от той, что возвращает <code>where</code>; мы не пытаемся сохранить вызов <code>where</code>, а обеспечиваем большую производительность функции выбора. Эта анонимная функция имеет условия только для нужных нам полей, и она не производит дополнительной работы, в отличие от функции, которую может возвратить <code>where</code>.
</p>
<p>Вы можете представить себе, что значит пройтись по всему исходному тексту исправить все вызовы <code>where</code> таким образом. И вы можете представить, насколько это болезненно. Если бы этого было достаточно, и это было бы очень важно, вероятно, стоило бы написать некоторого рода препроцессор, который бы конвертировал вызовы <code>where</code> в то, что вы бы написали вручную.
</p>
<p>Средство Lisp, позволяющее делать это очень просто, называется системой макросов. Подчеркиваю, что макрос в Common Lisp не имеет, в сущности, ничего общего (кроме имени) с текстовыми макросами из C и C++. В то время, как препроцессор C оперирует текстовой подстановкой и не знает ничего о стуктуре C и C++, в Lisp макрос, в сущности, является генератором кода, который автоматически запускается для вас компилятором<a class="fn_top" id="fnt__17" href="practical-a-simple-database#fn__17">17)</a>. Когда выражение на Lisp содержит вызов макроса, компилятор Lisp, вместо вычисления аргументов и передачи их в функцию, передает аргументы, не вычисляя их, в код макроса, который, в свою очередь, возвращает новое выражение на Lisp, которое затем вычисляется в месте исходного вызова макроса.
</p>
<p>Я начну с простого и глупого примера и затем покажу, как вы можете заменить функцию <code>where</code> макросом <code>where</code>. Перед тем, как я напишу этот макрос-пример, мне необходимо представить вам одну новую функцию: <strong>REVERSE</strong> принимает аргумент в виде списка и возвращает новый список, который является обратным к исходному. Таким образом, <code>(reverse '(1 2 3))</code> вернёт <code>(3 2 1)</code>. Теперь попробуем создать макрос.
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmac.htm" class="symbol"><i><span class="symbol">defmacro</span></i></a> backwards <span class="paren2">(<span class="">expr</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_revers.htm" class="symbol">reverse</a> expr</span>)</span></span>)</span><br/></pre>

<p>Главное синтаксическое отличие между функцией и макросом заключается в том, что макрос определяется ключевым словом <strong>DEFMACRO</strong>, а не <code>DEFUN</code>. После ключевого слова в определении макроса, подобно определению функции, следует имя, список параметров и тело с выражениями. Однако макросы действуют совершенно по-другому. Вы можете использовать макрос так:
</p><pre>CL-USER&gt; (backwards ("hello, world" t format))<br/>hello, world<br/>NIL<br/></pre>
<p>Как это работает? Когда REPL начинает вычислять выражение <code>backwards</code>, он обнаруживает, что <code>backwards</code> — имя макроса. Поэтому он не вычисляет выражение <code>("hello, world" t format)</code>, что очень хорошо, так как это некорректная для Lisp структура. Далее он передаёт этот список коду <code>backwards</code>. Код <code>backwards</code> передает список в функцию <code>REVERSE</code>, которая возвращает список <code>(format t "hello, world")</code>. Затем <code>backwards</code> передает это значение обратно REPL, который подставляет его на место исходного выражения.
</p>
<p>Макрос <code>backwards</code>, таким образом, определяет новый язык, во многом похожий на Lisp — только задом наперёд — который вы можете вставлять в свой код в любой момент, просто обернув обратное выражение на Lisp в вызов макроса <code>backwards</code>. И в скомпилированной программе на Lisp этот новый язык покажет такую же производительность, как и обычный Lisp, потому что весь код в макросе — код, сгенерированный в новом выражении — выполняется во время компиляции. Другими словами, компилятор сгенерирует один и тот же код, независимо от того, напишете вы <code>(backwards ("hello, world" t format))</code> или <code>(format t "hello, world")</code>.
</p>
<p>Итак, как это поможет решить проблему дублирующегося кода в <code>where</code>? Очень просто. Вы можете написать макрос, генерирующий совершенно такой же код, какой вы написали бы для каждого вызова <code>where</code>. И снова, лучший подход — это разрабатывать код снизу вверх. В оптимизированной вручную функции выбора <code>where</code> для каждого из заданных полей у вас было выражение в следующей форме:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_equal.htm" class="symbol">equal</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> cd field</span>)</span> value</span>)</span><br/></pre>

<p>Давайте напишем функцию, которая, получив имя поля и некоторое значение, возвращает такое выражение. Так как выражение — это просто список, вы можете подумать, что возможно написать что-нибудь вроде:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> make-comparison-expr <span class="paren2">(<span class="">field value</span>)</span>    <span class="comment">; неправильно<br/></span>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_equal.htm" class="symbol">equal</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> cd field</span>)</span> value</span>)</span></span>)</span><br/></pre>

<p>Однако здесь имеется небольшой нюанс: как вы знаете, когда Lisp обнаруживает просто имя вроде <code>field</code> или <code>value</code>, а не первый элемент списка, он полагает, что это имя переменной, и пытается получить ее значение. Это нормально для <code>field</code> и <code>value</code>; это именно то, что нужно. Но он будет обращаться к <code>equal</code>, <code>getf</code> и <code>cd</code> таким же образом, а это в нашем случае нежелательно. Вы, однако, знаете также, как не позволить Lisp пытаться вычислить структуру: поместить перед ней одиночную кавычку (<code/>'). Таким образом, если вы напишете функцию <code>make-comparison-expr</code> вот так, она сделает то, что вам нужно:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> make-comparison-expr <span class="paren2">(<span class="">field value</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> '<a href="http://www.lispworks.com/reference/HyperSpec/Body/f_equal.htm" class="symbol">equal</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> '<a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> 'cd field</span>)</span> value</span>)</span></span>)</span><br/></pre>

<p>Вы можете проверить её работу в REPL:
</p><pre>CL-USER&gt; (make-comparison-expr :rating 10)<br/>(EQUAL (GETF CD :RATING) 10)<br/>CL-USER&gt; (make-comparison-expr :title "Give Us a Break")<br/>(EQUAL (GETF CD :TITLE) "Give Us a Break")<br/></pre>
<p>Но, оказывается, существует лучший способ сделать это. То, что вам действительно нужно, — это иметь возможность написать выражение, которое в большинстве случаев не вычисляется, и затем каким-либо образом выбирать некоторые выражения, которые вы хотите вычислить. И, конечно же, такой механизм существует. Обратная кавычка (<code>`</code>) перед выражением запрещает его вычисление, точно так же, как и прямая одиночная кавычка.
</p><pre>CL-USER&gt; `(1 2 3)<br/>(1 2 3)<br/>CL-USER&gt; '(1 2 3)<br/>(1 2 3)<br/></pre>
<p>Однако в выражении с обратной кавычкой любое подвыражение, перед которым стоит запятая, вычисляется. Обратите внимание на влияние запятой во втором выражении:
</p><pre>`(1 2 (+ 1 2))  ==&gt; (1 2 (+ 1 2))<br/>`(1 2 ,(+ 1 2)) ==&gt; (1 2 3)<br/></pre>
<p>Используя обратную кавычку, вы можете переписать функцию <code>make-comparison-expr</code> следующим образом:
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> make-comparison-expr <span class="paren2">(<span class="">field value</span>)</span><br/>  `<span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_equal.htm" class="symbol">equal</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> cd ,field</span>)</span> ,value</span>)</span></span>)</span><br/></pre>

<p>Теперь, если вы посмотрите на оптимизированную вручную функцию выбора, вы увидите, что тело функции состоит из одного оператора сравнения для каждой пары поле/значение, обернутое в выражение <code>AND</code>. На мгновение предположим, что вам нужно расположить аргументы таким образом, чтобы передать их макросу <code>where</code> единым списком. Вам понадобится функция, которая принимает аргументы этого списка попарно и сохраняет результаты выполнения вызова <code>make-comparison-expr</code> для каждой пары. Чтобы реализовать эту функцию, вы можете воспользоваться мощным макросом <strong>LOOP</strong>.
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> make-comparisons-list <span class="paren2">(<span class="">fields</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> while fields<br/>     collecting <span class="paren3">(<span class="">make-comparison-expr <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_pop.htm" class="symbol">pop</a> fields</span>)</span> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_pop.htm" class="symbol">pop</a> fields</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Полное описание макроса <code>LOOP</code> отложим до 22 главы, а сейчас заметим, что выражение <code>LOOP</code> выполняет именно то, что требуется: оно циклично проходит по всем элементам в списке <code>fields</code>, каждый раз возвращая по два элемента, передаёт их в <code>make-comparison-expr</code> и сохраняет возвращаемые результаты, чтобы их вернуть при выходе из цикла. Макрос POP выполняет операцию, обратную операции, выполняемой макросом <code>PUSH</code>, который вы использовали для добавления записей в <code>*db*</code>.
</p>
<p>Теперь вам нужно просто обернуть список, возвращаемый функцией <code>make-comparison-list</code> в <code>AND</code> и анонимную функцию, которую вы можете реализовать прямо в макросе <code>where</code>. Это просто: используйте обратную кавычку, чтобы создать шаблон, который будет заполнен значениями функции <code>make-comparison-list</code>.
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmac.htm" class="symbol"><i><span class="symbol">defmacro</span></i></a> where <span class="paren2">(<span class="">&amp;rest clauses</span>)</span><br/>  `#'<span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren3">(<span class="">cd</span>)</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_and.htm" class="symbol">and</a> ,@<span class="paren4">(<span class="">make-comparisons-list clauses</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Этот макрос использует вариацию <code>,</code> (а именно, <code>,@</code>) перед вызовом <code>make-comparison-list</code>. Сочетание <code>,@</code> "вклеивает" значение следующего за ним выражения, которое должно возвращать список, во "внешний" список.
</p><pre>`(and ,(list 1 2 3))  ==&gt; (AND (1 2 3))<br/>`(and ,@(list 1 2 3)) ==&gt; (AND 1 2 3)<br/></pre>
<p>Вы также можете использовать <code>,@</code> для "вклейки" элементов в середину списка:
</p><pre>`(and ,@(list 1 2 3) 4) ==&gt; (AND 1 2 3 4)<br/></pre>
<p>Другая важная особенность макроса <code>where</code> — использование <code>&amp;rest</code> в списке аргументов. Так же, как и <code>&amp;key</code>, <code>&amp;rest</code> изменяет способ разбора аргументов. Если в списке параметров обнаруживается <code>&amp;rest</code>, функция или макрос могут принимать произвольное число аргументов, которые собираются в единый список, становящийся значением переменной, имя которой следует за <code>&amp;rest</code>. Итак, если вы вызовите <code>where</code> так:
</p><pre class="code"><span class="paren1">(<span class="">where <span class="keyword">:title</span> <span class="string">"Give Us a Break"</span> <span class="keyword">:ripped</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span><br/></pre>
<p>переменная <code>clauses</code> будет содержать список:
</p><pre class="code"><span class="paren1">(<span class=""><span class="keyword">:title</span> <span class="string">"Give Us a Break"</span> <span class="keyword">:ripped</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span><br/></pre>

<p>Этот список передается функции <code>make-comparisons-list</code>, которая возвращает список выражений сравнения. С помощью функции <strong>MACROEXPAND-1</strong> вы можете точно видеть, какой код будет сгенерирован <code>where</code>. Если вы передадите в <code>MACROEXPAND-1</code> форму, являющуюся вызовом макроса, она вызовет макрос с заданными аргументами и вернёт его развёрнутый вид. Итак, вы можете проверить предыдущий вызов <code>where</code> следующим образом:
</p><pre>CL-USER&gt; (macroexpand-1 '(where :title "Give Us a Break" :ripped t))<br/>#'(LAMBDA (CD)<br/>    (AND (EQUAL (GETF CD :TITLE) "Give Us a Break")<br/>         (EQUAL (GETF CD :RIPPED) T)))<br/>T<br/></pre>
<p>Выглядит неплохо. Теперь попробуем испытать макрос в действии:
</p><pre>CL-USER&gt; (select (where :title "Give Us a Break" :ripped t))<br/>((:TITLE "Give Us a Break" :ARTIST "Limpopo" :RATING 10 :RIPPED T))<br/></pre>
<p>Работает. И макрос <code>where</code> с его двумя функциями-помощниками оказался на одну строку короче, чем старая функция <code>where</code>. И, что самое главное, <code>where</code> больше не привязана к конкретным полям наших записей о CD.
</p>
</div><div class="chapter" id="&#x41E;&#x431; &#x443;&#x43F;&#x430;&#x43A;&#x43E;&#x432;&#x43A;&#x435;"><h3>Об упаковке</h3>
<p>Случилась интересная вещь. Вы избавились от дублирования и сделали код одновременно более производительным и универсальным. Так часто бывает, если правильно выбрать макрос. Это имеет смысл, потому что макрос — это ещё один механизм создания абстракций — абстракций на синтаксическом уровне, а абстракции — это, по определению, более короткий путь для выражения подразумеваемых сущностей. Сейчас код мини-базы данных, который относится к CD и полям, его описывающим, находится только в функциях <code>make-cd</code>, <code>prompt-for-cd</code> и <code>add-cd</code>. Фактически, наш новый макрос будет работать с любой базой данных, основанной на списке свойств.
</p>
<p>Тем не менее, эта база данных всё еще далека от завершения. Вероятно, вы думаете о добавлении множества возможностей, например, таких, как поддержка множества таблиц или более сложных запросов. В главе 27 мы создадим базу данных о записях MP3, которая будет содержать некоторые из этих возможностей.
</p>
<p>Целью этой главы являлось быстрое введение в лишь малую часть возможностей Lisp и демонстрация того, как они используются для написания кода, чуть более интересного, чем <code>"Hello, world"</code>. В следующей главе мы начнём более систематический обзор Lisp.
</p></div></div><div class="footnotes"><div><a class="fn_bot" id="fn__1" href="practical-a-simple-database#fnt__1">1)</a>Прежде, чем я продолжу, очень важно, чтобы вы забыли все, что можете знать о "макросах" в стиле #define, реализованных в препроцессоре C. Макросы Lisp не имеют с ними ничего общего</div><div><a class="fn_bot" id="fn__2" href="practical-a-simple-database#fnt__2">2)</a><code>LIST</code> — по английски <strong>СПИСОК</strong>. Кстати, последние реализации Common Lisp позволяют писать и на родном для вас языке. Например, на русском можно создать макрос <code>СПИСОК</code>, который будет вызывать <code>LIST</code>, например так: <pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmac.htm" class="symbol"><i><span class="symbol">defmacro</span></i></a> список <span class="paren2">(<span class="">&amp;body body</span>)</span> `<span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> ,@body</span>)</span></span>)</span><br/></pre> <em>— Прим. перев.</em></div><div><a class="fn_bot" id="fn__3" href="practical-a-simple-database#fnt__3">3)</a><code>foo</code>, <code>bar</code> — любимые имена переменных у англоговорящих программистов, пишущих книги и документацию <em>— Прим. перев.</em></div><div><a class="fn_bot" id="fn__4" href="practical-a-simple-database#fnt__4">4)</a>Тем, для кого английский родной <em>— Прим. перев.</em></div><div><a class="fn_bot" id="fn__5" href="practical-a-simple-database#fnt__5">5)</a>Использование глобальной переменной имеет ряд недостатков — например, вы можете использовать только одну базу данных в каждый момент времени. В гл. 27, имея за плечами уже солидный багаж знаний о Lisp, вы будете готовы к созданию более гибкой базы данных. В 6 главе вы также увидите, что даже использование глобальных переменных в Common Lisp более гибко, чем это возможно в других языках.</div><div><a class="fn_bot" id="fn__6" href="practical-a-simple-database#fnt__6">6)</a>Одна из наиболее "классных" управляющих команд <code>FORMAT</code> — команда ~R. Всегда хотели знать, как по-английски произносится <em>действительно большое</em> число? Lisp знает. Сделайте так:
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a> <span class="string">"~r"</span> 1606938044258990275541962092</span>)</span><br/></pre>
и вы получите (разбито на строки для удобочитаемости):
"one octillion six hundred six septillion nine hundred thirty-eight sextillion forty-four quintillion two hundred fifty-eight quadrillion nine hundred ninety trillion two hundred seventy-five billion five hundred forty-one million nine hundred sixty-two thousand ninety-two"</div><div><a class="fn_bot" id="fn__7" href="practical-a-simple-database#fnt__7">7)</a>На самом деле, Windows позволяет использовать косую черту ("прямые слэши") в именах файлов, хотя в качестве разделителей имён директорий в этой ОС обычно используются обратные косые ("обратные слэши"). Это очень удобно, ведь иначе вам каждый раз приходилось бы дублировать обратную косую черту, так как это — Escape-символ в строках Lisp.</div><div><a class="fn_bot" id="fn__8" href="practical-a-simple-database#fnt__8">8)</a>Слово <code>lambda</code> используется в Lisp из-за его изначальной связи с лямбда-исчислением, математическим формализмом, изобретенным для изучения математических функций.</div><div><a class="fn_bot" id="fn__9" href="practical-a-simple-database#fnt__9">9)</a>Техническое обозначение функции, ссылающейся на свободную переменную в своём контексте — <strong>замыкание</strong>, потому что функция как бы "смыкается" над переменной. Я подробнее расскажу о замыканиях в главе 6.</div><div><a class="fn_bot" id="fn__10" href="practical-a-simple-database#fnt__10">10)</a>Заметьте, что в Lisp оператор <code>if</code>, как и всё остальное, является выражением, возвращающим значение. Вообще, он больше напоминает тернарный оператор <code>(?:)</code> в Perl, Java и C, поскольку вполне допустимо такое выражение в этих языках:
<pre class="code"><p>some_var = some_boolean ? value1 : value2;<br/></p></pre>
А такое - нет:
<pre class="code"><p>some_var = if <span class="paren1">(<span class="">some_boolean</span>)</span> value1; else value2;<br/></p></pre>
так как в этих языках <code>if</code> — просто оператор, а не выражение.</div><div><a class="fn_bot" id="fn__11" href="practical-a-simple-database#fnt__11">11)</a>Автор ещё забыл упомянуть макрос <code>WHEN</code>. Он будет подробно рассмотрен в 7-й главе. — прим.ред.</div><div><a class="fn_bot" id="fn__12" href="practical-a-simple-database#fnt__12">12)</a>Странно, что функция <code>update</code> здесь возвращает NIL, ведь последней операцией является <code>SETF *db* value</code>, которая, в свою очередь, возвращает присвоенное значение. То есть после присваивания можно наблюдать изменения. (sbcl-1.03) <em>— Прим. перев.</em></div><div><a class="fn_bot" id="fn__13" href="practical-a-simple-database#fnt__13">13)</a>Вы должны использовать имя <code>delete-rows</code> вместо более очевидного <code>delete</code>, потому что в Common Lisp уже есть функция <strong>DELETE</strong>. Система пакетов Lisp предоставляет возможность разрешать такие конфликты имён, так что, если хотите, можете иметь в своей программе собственную функцию <code>delete</code>. Но сейчас ещё рано рассказывать вам о пакетах.</div><div><a class="fn_bot" id="fn__14" href="practical-a-simple-database#fnt__14">14)</a>Если вы беспокоитесь о том, что в этом коде могут возникнуть утечки памяти, будьте уверены: Lisp был первым языком, в котором появилась сборка мусора (и, раз уж на то пошло, использование динамически выделяемой памяти). Память, используемая для старого значения *db*, будет автоматически возвращена системе, как только выяснится, что на неё больше ничто не ссылается.</div><div><a class="fn_bot" id="fn__15" href="practical-a-simple-database#fnt__15">15)</a>Мой друг однажды проводил собеседование с кандидатом на должность программиста и задал ему обычный вопрос, распространённый на таких собеседованиях: "Как вы понимаете, что функция (или метод) стала слишком велика?" "Ну... — ответил кандидат. — Я стараюсь делать так, чтобы любой метод был меньше, чем моя голова."
"Вы хотите сказать, что не можете удержать в голове всех деталей?" — "Нет, я хочу сказать, что сажусь перед монитором, и код не должен быть больше, чем моя голова."</div><div><a class="fn_bot" id="fn__16" href="practical-a-simple-database#fnt__16">16)</a>Вряд ли проверка того, был ли ключ-параметр передан в функцию, приведёт к существенному падению производительности, так как проверка значения переменной на NIL — очень "дешёвая" с точки зрения производительности операция. С другой стороны, эти функции, возвращаемые <code>where</code>, оказываются как раз в середине внутреннего цикла вызовов <code>select</code>, <code>update</code> и <code>delete-rows</code>, так как вызываются для каждой записи в базе данных. В любом случае, для наглядности, пусть будет так.</div><div><a class="fn_bot" id="fn__17" href="practical-a-simple-database#fnt__17">17)</a>Макросы также выполняются интерпретатором, — тем не менее, сущность макросов легче понять, когда думаешь о компилируемом коде. Как и обо всём остальном в этой главе, я расскажу об этом более подробно в следующих главах.</div></div></div> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="lather-rinse-repeat-a-tour-of-the-repl">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right"> <a href="syntax-and-semantics">Следующая</a> </td> </tr> </tbody> </table> </div> <div class="bottom">@2009-2013 lisper.ru</div> 
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7734690-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
 </body> </html>