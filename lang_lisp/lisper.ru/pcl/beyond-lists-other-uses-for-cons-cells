<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru"> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <meta name="keywords" content="Common Lisp,lisp,лисп" /> <title>Не только списки: Другие применения cons-ячеек</title> <link href="../css/style.css" rel="stylesheet" type="text/css" /><link href="../css/colorize.css" rel="stylesheet" type="text/css" />  </head> <body> <div class="top"> <div id="login"> <a href="http://lisper.ru/register">Регистрация</a> | <a href="http://lisper.ru/login?done=/pcl/beyond-lists-other-uses-for-cons-cells">Войти</a> </div> </div> <div id="caution"> <img alt="Lisp — программируемый язык программирования" src="../image/gecko.png" /> <a href="http://www.vkusnoserver.ru/" target="_blank" style="float: right;"> <img src="../vkusnoserver.png" /> </a> </div> <div id="mainmenu"> <ul> <li> <a href="http://lisper.ru/">Главная</a> </li><li> <a href="http://lisper.ru/articles/">Статьи</a> </li><li> <a href="http://lisper.ru/planet/">Планета</a> </li><li> <a href="http://lisper.ru/forum/">Форум</a> </li><li> <a href="http://lisper.ru/apps/">Сервисы</a> </li><li> <a href="index.html">Practical Common Lisp</a> </li><li> <a href="http://lisper.ru/wiki/">Wiki</a> </li><li> <a href="http://lisper.ru/files/">Файлы</a> </li><li> <a href="http://lisper.ru/search">Поиск</a> </li> </ul> </div> <div id="content"> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="they-called-it-lisp-for-a-reason-list-processing">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right"> <a href="files-and-file-io">Следующая</a> </td> </tr> </tbody> </table> <div class="article"><div class="toc"><div class="toc-header">Содержание</div><div class="toc-body"><ul><li><div><a href="beyond-lists-other-uses-for-cons-cells#13. &#x41D;&#x435; &#x442;&#x43E;&#x43B;&#x44C;&#x43A;&#x43E; &#x441;&#x43F;&#x438;&#x441;&#x43A;&#x438;: &#x434;&#x440;&#x443;&#x433;&#x438;&#x435; &#x43F;&#x440;&#x438;&#x43C;&#x435;&#x43D;&#x435;&#x43D;&#x438;&#x44F; cons-&#x44F;&#x447;&#x435;&#x435;&#x43A;">13. Не только списки: другие применения cons-ячеек</a><ul><li><div><a href="beyond-lists-other-uses-for-cons-cells#&#x414;&#x435;&#x440;&#x435;&#x432;&#x44C;&#x44F;">Деревья</a></div></li><li><div><a href="beyond-lists-other-uses-for-cons-cells#&#x41C;&#x43D;&#x43E;&#x436;&#x435;&#x441;&#x442;&#x432;&#x430;">Множества</a></div></li><li><div><a href="beyond-lists-other-uses-for-cons-cells#&#x422;&#x430;&#x431;&#x43B;&#x438;&#x446;&#x44B; &#x43F;&#x43E;&#x438;&#x441;&#x43A;&#x430;: &#x430;&#x441;&#x441;&#x43E;&#x446;&#x438;&#x430;&#x442;&#x438;&#x432;&#x43D;&#x44B;&#x435; &#x441;&#x43F;&#x438;&#x441;&#x43A;&#x438; &#x438; &#x441;&#x43F;&#x438;&#x441;&#x43A;&#x438; &#x441;&#x432;&#x43E;&#x439;&#x441;&#x442;&#x432;">Таблицы поиска: ассоциативные списки и списки свойств</a></div></li><li><div><a href="beyond-lists-other-uses-for-cons-cells#DESTRUCTURING-BIND">DESTRUCTURING-BIND</a></div></li></ul></div></li></ul></div></div>
<div class="chapter" id="13. &#x41D;&#x435; &#x442;&#x43E;&#x43B;&#x44C;&#x43A;&#x43E; &#x441;&#x43F;&#x438;&#x441;&#x43A;&#x438;: &#x434;&#x440;&#x443;&#x433;&#x438;&#x435; &#x43F;&#x440;&#x438;&#x43C;&#x435;&#x43D;&#x435;&#x43D;&#x438;&#x44F; cons-&#x44F;&#x447;&#x435;&#x435;&#x43A;"><h3>13. Не только списки: другие применения cons-ячеек</h3>

<p>Как вы увидели в предыдущей главе, списочный тип данных является
иллюзией, созданной множеством функций, которые манипулируют
cons-ячейками. Common Lisp также предоставляет функции, позволяющие
вам обращаться со структурами данных, созданными из cons-ячеек, как c
деревьями, множествами, и таблицами поиска (<em>lookup tables</em>). В этой
главе я дам вам краткий обзор некоторых из этих структур данных и
оперирующих с ними функций. Как и в случае функций, работающих со
списками, многие из них будут полезны когда вы начнете писать более
сложные макросы, где потребуется обращаться с кодом Lisp как с данными.
</p>

<div class="chapter" id="&#x414;&#x435;&#x440;&#x435;&#x432;&#x44C;&#x44F;"><h3>Деревья</h3>

<p>Рассматривать структуры созданные из cons-ячеек как деревья так же
естественно, как рассматривать их как списки. Ведь что такое список
списков, как не другое представление дерева?  Разница между функцией,
которая обращается с группой cons-ячеек как со списком, и функцией,
обращающейся с той же группой cons-ячеек, как с деревом, определяется
тем, какие ячейки обходят эти функции при поиске значений для дерева
или списка. Те сons-ячейки, которые обходит функция работы со списком,
называются <em>списочной структурой</em>, и располагаются начиная от первой
cons-ячейки и затем следуя ссылкам по <code>CDR</code>, пока не достигнут
<code>NIL</code>.  Элементами списка являются объекты, на которые ссылаются
<code>CAR</code>'ы cons-ячеек списочной структуры. Если cons-ячейка в списочной
структуре имеет <code>CAR</code>, который ссылается на другую cons-ячейку, то
та ячейка, на которую ведет ссылка, считается головой и элементом
внешнего списка.<a class="fn_top" id="fnt__1" href="beyond-lists-other-uses-for-cons-cells#fn__1">1)</a> <em>Древовидная структура</em>, с другой стороны, при обходе следует
ссылкам как по <code>CAR</code>, так и по <code>CDR</code>, пока они указывают на другие
cons-ячейки. Таким образом, значениями в древовидной структуре являются атомы – такие значения, которые не являются cons-ячейками, и на которые ссылаются <code>CAR</code>'ы или
<code>CDR</code>'ы cons-ячеек в древовидной структуре.
</p>
<p>Например, следующая стрелочная диаграмма показывает cons-ячейки,
составляющие список из списков: <code>((1 2) (3 4) (5 6))</code>. Списочная
структура включает в себя только три cons-ячейки внутри пунктирного
блока, тогда как древовидная структура включает все ячейки.
</p>
<p><img alt="&#x418;&#x437;&#x43E;&#x431;&#x440;&#x430;&#x436;&#x435;&#x43D;&#x438;&#x435;" src="pcl:chapter13:ch13-1.png"/>
</p>
<p>Чтобы увидеть разницу между функцией, работающей со списком, и
функцией, работающей с деревом, вы можете рассмотреть как функции
<code>COPY-LIST</code> и <code>COPY-TREE</code> будут копировать эту группу
cons-ячеек. <code>COPY-LIST</code>, как функция, работающая со списком,
копирует cons-ячейки, которые составляют списочную структуру. Другими
словами, она создает новые cons-ячейки соответственно для каждой из
cons-ячеек пунктирного блока. <code>CAR</code>'ы каждой новой ячейки ссылаются
на тот же объект, что и <code>CAR</code>'ы оригинальных cons-ячеек в списочной
структуре. Таким образом, <code>COPY-LIST</code> не копирует подсписки <code>(1, 2)</code>,
<code>(3 4)</code>, или <code>(5 6)</code>, как показано на этой диаграмме:
</p>
<p><img alt="&#x418;&#x437;&#x43E;&#x431;&#x440;&#x430;&#x436;&#x435;&#x43D;&#x438;&#x435;" src="pcl:chapter13:ch13-2.png"/>
</p>
<p><code>COPY-TREE</code>, с другой стороны, создает новые cons-ячейки для каждой
из cons-ячеек на диаграмме и соединяет их вместе в одну структуру, как
показано на следующей диаграмме:
</p>
<p><img alt="&#x418;&#x437;&#x43E;&#x431;&#x440;&#x430;&#x436;&#x435;&#x43D;&#x438;&#x435;" src="pcl:chapter13:ch13-3.png"/>
</p>
<p>Там где cons-ячейки в оригинале ссылаются на атомарное значение,
соответствующие им cons-ячейки в копии будут ссылаться на то же
значение.  Таким образом, единственными объектами, на которые
ссылаются как оригинальное дерево, так и его копия, созданная
<code>COPY-TREE</code>, будут числа <code>5</code>, <code>6</code>, и символ <code>NIL</code>.
</p>
<p>Еще одна функция, которая обходит как <code>CAR</code>'ы так и <code>CDR</code>'ы
cons-ячеек дерева это <code>TREE-EQUAL</code>, которая сравнивает два дерева, и
считает их равными, если их структуры имеют одинаковую форму и если их
листья равны относительно <code>EQL</code> (или если они удовлетворяют условию,
задаваемому через именованный аргумент <code>:test</code>).
</p>
<p>Прочими ориентированными на деревья функциями являются работающие с
деревьями аналоги функций для последовательностей <code>SUBSTITUTE</code> и
<code>NSUBSTITUTE</code>, и их <code>-IF</code> и <code>-IF-NOT</code> варианты. Функция
<code>SUBST</code>, как и <code>SUBSTITUTE</code>, принимает новый элемент, старый
элемент и дерево (в отличие от последовательности), вместе с
именованными аргументами <code>:key</code> и <code>:test</code>, и возвращает новое
дерево с той же формой, что и исходное, но все вхождения старого
элемента заменяются новым. Например:
</p><pre>CL-USER&gt; (subst 10 1 '(1 2 (3 2 1) ((1 1) (2 2))))<br/>(10 2 (3 2 10) ((10 10) (2 2)))<br/></pre>
<p><code>SUBST-IF</code> аналогична <code>SUBSTITUTE-IF</code>. Но вместо старого элемента,
она принимает одноаргументную функцию, которая вызывается с аргументом
в виде каждого атомарного значения в дереве, и всякий раз, когда она
возвращает истину, текущая позиция в новом дереве заменяется новым
значением. <code>SUBST-IF-NOT</code> действует также, за исключением того, что
заменяются те значения, где функция возвращает <code>NIL</code>. <code>NSUBST</code>,
<code>NSUBST-IF</code>, и <code>NSUBST-IF-NOT</code> - это утилизирующие аналоги
соответствующих версий <code>SUBST</code>-функций. Как и с другими
утилизирующими функциями, вам следует использовать эти функции только
как замещение (после профилирования) их
недеструктивных аналогов, в ситуациях, где вы уверены, что нет
опасности повреждения разделяемой структуры. В частности, вы должны
продолжать сохранять возвращаемые значения этих функций, пока у вас нет
гарантии, что результат будет равен, по предикату <code>EQ</code>, оригинальному
дереву. <a class="fn_top" id="fnt__2" href="beyond-lists-other-uses-for-cons-cells#fn__2">2)</a>
</p>

</div><div class="chapter" id="&#x41C;&#x43D;&#x43E;&#x436;&#x435;&#x441;&#x442;&#x432;&#x430;"><h3>Множества</h3>

<p>Множества также могут быть реализованы посредством
cons-ячеек. Фактически, вы можете обращаться с любым списком как с
множеством - Common Lisp предоставляет несколько функций для
выполнения теоретико-множественных операций
над списками. Тем не менее вам следует помнить, что из-за особенности
устройства списков эти операции становятся тем менее и менее
эффективными, чем больше становится множество.
</p>
<p>Впрочем, используя встроенные функции для работы с множествами легко
писать оперирующий с множествами код. И для небольших множеств они
могут быть более эффективными, чем их альтернативы. Если
профилирование показывает вам, что производительность этих функций
является узким местом вашего кода, вы всегда можете заменить множества
на основе списков множествами, основанными на хэш-таблицах или битовых
векторах.
</p>
<p>Для создания множества вы можете использовать функцию
<code>ADJOIN</code>. <code>ADJOIN</code> принимает в качестве аргументов элемент и
список, представляющий множество, и возвращает список, содержащий этот
элемент вместе со всеми элементами исходного множества.  Для того,
чтобы определить, присутствует ли элемент в множестве, функция
просматривает список, и если элемент не найден, то <code>ADJOIN</code> создает
новую cons-ячейку, содержащую этот элемент, ссылающуюся на исходный
список, и возвращает ее. В противном случае она возвращает исходный
список.
</p>
<p><code>ADJOIN</code> также принимает именованные аргументы <code>:key</code> и <code>:test</code>,
которые используются при определении - присутствует ли элемент в
исходном списке. Подобно <code>CONS</code>, <code>ADJOIN</code> не воздействует на
исходный список – если вы хотите модифицировать определенный список,
вам нужно присвоить значение, возвращаемое <code>ADJOIN</code>, тому месту, в котором хранился исходный список. Деструктивный макрос <code>PUSHNEW</code>
сделает это для вас автоматически.
</p><pre>CL-USER&gt; (defparameter *set* ())<br/>*SET*<br/>CL-USER&gt; (adjoin 1 *set*)<br/>(1)<br/>CL-USER&gt; *set*<br/>NIL<br/>CL-USER&gt; (setf *set* (adjoin 1 *set*))<br/>(1)<br/>CL-USER&gt; (pushnew 2 *set*)<br/>(2 1)<br/>CL-USER&gt; *set*<br/>(2 1)<br/>CL-USER&gt; (pushnew 2 *set*)<br/>(2 1)<br/></pre>
<p>Вы можете проверить, принадлежит ли данный элемент множеству с помощью
функции <code>MEMBER</code> и родственных ей функций <code>MEMBER-IF</code> и
<code>MEMBER-IF-NOT</code>. Эти функции похожи на функции для работы с
последовательностями - <code>FIND</code>, <code>FIND-IF</code>, и <code>FIND-IF-NOT</code>, за
исключением того, что они используются только со списками. Вместо
того, чтобы вернуть элемент, когда он присутствует в множестве, они
возвращают cons-ячейку содержащую элемент - другими словами, подсписок
начинающийся с заданного элемента. Если искомый элемент отсутствует в
списке, все три функции возвращают <code>NIL</code>.
</p>
<p>Оставшиеся ориентированные на множества функции предоставляют операции
с группами элементов: <code>INTERSECTION</code>, <code>UNION</code>, <code>SET-DIFFERENCE</code>,
и <code>SET-EXCLUSIVE-OR</code>.  Каждая из этих функций принимает два списка и
именованные аргументы <code>:key</code> и <code>:test</code> и возвращает новый список,
представляющий множество, полученное выполнением соответствующей
операции над двумя списками. <code>INTERSECTION</code> возвращает список,
содержащий все аргументы из обоих списков. <code>UNION</code> возвращает
список, содержащий один экземпляр каждого уникального элемента из двух
своих аргументов.<a class="fn_top" id="fnt__3" href="beyond-lists-other-uses-for-cons-cells#fn__3">3)</a> <code>SET-DIFFERENCE</code>
возвращает список, содержащий все элементы из первого аргумента,
которые не встречаются во втором аргументе. И <code>SET-EXCLUSIVE-OR</code>
возвращает список, содержащий элементы, находящиеся только в одном
либо в другом списках, переданных в качестве аргументов, но не в обоих
одновременно. Каждая из этих функций также имеет утилизирующий аналог,
имя которого получается добавлением <em>N</em> в качестве префикса.
</p>
<p>В заключение, функция <code>SUBSETP</code> принимает в качестве аргументов два
списка и обычные именованные аргументы <code>:key</code> и <code>:test</code> и
возвращает истину, если первый список является подмножеством второго -
то есть, если каждый элемент первого списка также присутствует во
втором списке.  Порядок элементов в списках значения не имеет.
</p><pre>CL-USER&gt; (subsetp '(3 2 1) '(1 2 3 4))<br/>T<br/>CL-USER&gt; (subsetp '(1 2 3 4) '(3 2 1))<br/>NIL<br/></pre>


</div><div class="chapter" id="&#x422;&#x430;&#x431;&#x43B;&#x438;&#x446;&#x44B; &#x43F;&#x43E;&#x438;&#x441;&#x43A;&#x430;: &#x430;&#x441;&#x441;&#x43E;&#x446;&#x438;&#x430;&#x442;&#x438;&#x432;&#x43D;&#x44B;&#x435; &#x441;&#x43F;&#x438;&#x441;&#x43A;&#x438; &#x438; &#x441;&#x43F;&#x438;&#x441;&#x43A;&#x438; &#x441;&#x432;&#x43E;&#x439;&#x441;&#x442;&#x432;"><h3>Таблицы поиска: ассоциативные списки и списки свойств</h3>

<p>Помимо деревьев и множеств вы можете создавать таблицы, которые
отображают ключи на значения вне cons-ячеек. Обычно используются две
разновидности основанных на cons-ячейках таблиц поиска, об обеих я
вскользь упоминал в предыдущих главах. Это <em>ассоциативные списки</em>
(<em>association lists</em> или <em>alists</em>) и <em>списки свойств</em>
(<em>property lists</em> или <em>plists</em>). Вам не стоит использовать списки
свойств или ассоциативные списки для больших таблиц - для них нужно
использовать хэш-таблицы, но стоит знать, как работать с ними обоими,
так как для небольших таблиц они могут быть более эффективны, чем
хэш-таблицы, и еще потому, что у них есть несколько полезных
собственных свойств.
 
Ассоциативный список - это структура данных, которая отображает ключи
на значения, а также поддерживает обратный поиск, находя ключ по
заданному значению. Ассоциативные списки также поддерживают возможность
добавления отображений ключ/значение, которые скрывают существующие
отображения таким образом, что скрывающие отображения могут быть позже
удалены и первоначальные отображения снова станут видимы.
</p>
<p>Если смотреть глубже, то на самом деле ассоциативный список - это просто
список, чьи элементы сами является cons-ячейками. Каждый элемент можно
представлять как пару ключ/значение с ключом в <code>CAR</code> cons-ячейки и
значением в <code>CDR</code>. К примеру, следующая стрелочная диаграмма
представляет ассоциативный список, состоящий из отображения символа
<code>A</code> в номер <code>1</code>, <code>B</code> в номер <code>2</code>, и <code>C</code> в номер <code>3</code>:
</p>
<p><img alt="&#x418;&#x437;&#x43E;&#x431;&#x440;&#x430;&#x436;&#x435;&#x43D;&#x438;&#x435;" src="pcl:chapter13:ch13-4.png"/>
</p>
<p>Если значение CDR не является списком, то cons-ячейки,
представляющие пары ключ/значение, будут <em>точечными парами</em> в
терминах s-выражений. Ассоциативный список, представленный на
предыдущей диаграмме, к примеру, будет напечатан вот так:
</p><pre>((A . 1) (B . 2) (C . 3))<br/></pre>
<p>Главная процедура поиска для ассоциативных списков это <code>ASSOC</code>,
которая принимает ключ и ассоциативный список в качестве аргументов, и
возвращает первую cons-ячейку, чей <code>CAR</code> соответствует ключу или
является <code>NIL</code>, если совпадения не найдено.</p><pre>CL-USER&gt; (assoc 'a '((a . 1) (b . 2) (c . 3)))<br/>(A . 1)<br/>CL-USER&gt; (assoc 'c '((a . 1) (b . 2) (c . 3)))<br/>(C . 3)<br/>CL-USER&gt; (assoc 'd '((a . 1) (b . 2) (c . 3)))<br/>NIL<br/></pre>
<p>Чтобы получить значение, соответствующее заданному ключу, вам следует
просто передать результат <code>ASSOC</code> <code>СDR</code>'у.</p><pre>CL-USER&gt; (cdr (assoc 'a '((a . 1) (b . 2) (c . 3))))<br/>1<br/></pre>
<p>По умолчанию заданный ключ сравнивается с ключами в ассоциативном
списке, используя предикат <code>EQL</code>, но вы можете изменить его с
помощью стандартной комбинации из именованных аргументов <code>:key</code> и
<code>:test</code>. Например, если вы хотите использовать строковые ключи, то
можете написать так:</p><pre>CL-USER&gt; (assoc "a" '(("a" . 1) ("b" . 2) ("c" . 3)) :test #'string=)<br/>("a" . 1)<br/></pre>
<p>Без явного задания в качестве <code>:test</code> предиката <code>STRING=</code> 
<code>ASSOC</code> вероятно вернул бы <code>NIL</code>, потому что две строки с одинаковым
содержимым необязательно равны относительно <code>EQL</code>.
</p><pre>CL-USER&gt; (assoc "a" '(("a" . 1) ("b" . 2) ("c" . 3)))<br/>NIL<br/></pre>
<p>Поскольку при поиске <code>ASSOC</code> просматривает список с начала, одна
пара ключ/значение в ассоциативном списке может скрывать другие пары с
тем же ключом, но находящиеся дальше в списке.
</p><pre>CL-USER&gt; (assoc 'a '((a . 10) (a . 1) (b . 2) (c . 3)))<br/>(A . 10)<br/></pre>
<p>Вы можете добавить пару в начало списка с помощью функции <code>CONS</code>,
как здесь:
</p><pre>(cons (cons 'new-key 'new-value) alist)<br/></pre>
<p>Однако для удобства Common Lisp предоставляет функцию <code>ACONS</code>,
которая позволяет вам написать так:
</p><pre>(acons 'new-key 'new-value alist)<br/></pre>
<p>Подобно <code>CONS</code>, <code>ACONS</code> является функцией и, следовательно, не может
модифицировать место, откуда был передан исходный ассоциативный
список. Если вы хотите модифицировать ассоциативный список, вам нужно
написать так:
</p><pre>(setf alist (acons 'new-key 'new-value alist))<br/></pre>
<p>или так:
</p><pre>(push (cons 'new-key 'new-value) alist)<br/></pre>
<p>Очевидно, время затраченное на поиск в ассоциативном списке при
использовании <code>ASSOC</code>, является функцией от того, насколько глубоко
в списке находится соответствующая пара. В худшем случае для
определения, что никакая пара не соответствует искомой, <code>ASSOC</code>
требуется просмотреть каждый элемент списка. Тем не менее, поскольку
основной механизм работы ассоциативных списков довольно прост, то на
небольших таблицах ассоциативный список может превзойти в
производительности хэш-таблицу.  Также ассоциативные списки могут дать
вам большую гибкость при выполнении поиска. Ранее я отмечал,
что <code>ASSOC</code> принимает именованные аргументы <code>:key</code> и
<code>:test</code>. Если они не соответствуют вашим требованиям, вы можете
использовать функции <code>ASSOC-IF</code> и <code>ASSOC-IF-NOT</code>, которые
возвращают первую пару ключ/значение, чей <code>CAR</code> удовлетворяет (или
не удовлетворяет, в случае <code>ASSOC-IF-NOT</code>) предикату, передаваемому
вместо ключа. Еще три функции - <code>RASSOC</code>, <code>RASSOC-IF</code>, и
<code>RASSOC-IF-NOT</code> действуют так же, как и соответствующие аналогичные
<code>ASSOC</code>-функции, за исключением того, что они используют значение в
<code>CDR</code> каждого элемента как ключ, совершая обратный поиск.
</p>
<p>Функция <code>COPY-ALIST</code> похожа на <code>COPY-TREE</code> за исключением того,
что вместо копирования всей древовидной структуры, она копирует только
те cons-ячейки, которые составляют списочную структуру, плюс те
cons-ячейки, на которые ссылаются <code>CAR</code>'ы этих ячеек. Другими
словами, исходный ассоциативный список и его копия будут оба содержать
одинаковые объекты как в виде ключей, так и значений, даже если ключи
или значения будут состоять из cons-ячеек.
</p>
<p>Наконец вы можете создать ассоциативный список из двух различных
списков ключей и значений с помощью функции <code>PAIRLIS</code>. Получившийся
ассоциативный список может содержать пары либо в том порядке, в каком
они были в исходных списках, либо в обратном порядке. Например, вы
можете получить такой результат:
</p><pre>CL-USER&gt; (pairlis '(a b c) '(1 2 3))<br/>((C . 3) (B . 2) (A . 1))<br/></pre>
<p>Или вы можете получить следующее:
</p><pre>CL-USER&gt; (pairlis '(a b c) '(1 2 3))<br/>((A . 1) (B . 2) (C . 3))<br/></pre>
<p>Другой разновидностью таблицы поиска является список свойств
(property list или сокращенно plist), который вы использовали для
представления строк базы данных в Главе 3. Структурно список свойств
есть просто обычный список с ключами и значениями в виде чередующихся
величин. К примеру, список свойств отображающий <code>A</code>, <code>B</code>, и <code>C</code>,
на <code>1</code>, <code>2</code>, и <code>3</code> это просто список <code>(A 1 B 2 C 3)</code>. На
стрелочной диаграмме он выглядит так:
</p>
<p><img alt="&#x418;&#x437;&#x43E;&#x431;&#x440;&#x430;&#x436;&#x435;&#x43D;&#x438;&#x435;" src="pcl:chapter13:ch13-5.png"/>
</p>
<p>Впрочем, списки свойств являются менее гибкими, чем ассоциативные
списки. В действительности, список свойств поддерживает только одну
фундаментальную операцию поиска, функцию <code>GETF</code>, которая принимает
список свойств и ключ, и возвращает связанное с ключом значение, или
<code>NIL</code>, если ключ не найден. <code>GETF</code> также принимает необязательный
третий аргумент, который возвращается вместо <code>NIL</code>, если ключ не
найден.
</p>
<p>В отличие от <code>ASSOC</code>, которая использует <code>EQL</code> как проверочный
предикат по умолчанию и позволяет использовать другой проверочный
предикат в виде именованного аргумента <code>:test</code>, <code>GETF</code> всегда
использует <code>EQ</code> для проверки, совпадает ли переданный ей ключ с
ключами списка свойств. Следовательно, вам никогда не следует
использовать числа или знаки в качестве ключей в списке свойств; как
вы видели в Главе 4, поведение <code>EQ</code> для этих типов данных фактически
не определено. На практике, ключи в списке свойств почти всегда
являются символами, с тех пор как списки свойств были впервые
изобретены для реализации "свойств" символов, то есть произвольных
отображений между именами и значениями.
</p>
<p>Вы можете использовать <code>SETF</code> вместе с <code>GETF</code> для установки
переменной с заданным ключом. <code>SETF</code> также обращается с <code>GETF</code>
немного особым образом, при котором первый аргумент <code>GETF</code> считается
модифицируемым. Таким образом вы можете вызвать <code>SETF</code> поверх
<code>GETF</code> для добавления новых пар ключ/значение к существующему списку
свойств.</p><pre>CL-USER&gt; (defparameter *plist* ())<br/>*PLIST*<br/>CL-USER&gt; *plist*<br/>NIL<br/>CL-USER&gt; (setf (getf *plist* :a) 1)<br/>1<br/>CL-USER&gt; *plist*<br/>(:A 1)<br/>CL-USER&gt; (setf (getf *plist* :a) 2)<br/>2<br/>CL-USER&gt; *plist*<br/>(:A 2)<br/></pre>
<p>Чтобы удалить пару ключ/значение из списка свойств, вы можете
использовать макрос <code>REMF</code>, который присваивает месту, переданному в
качестве своего первого аргумента, список свойств, содержащий все пары
ключ/значение, за исключением заданной. Он возвращает истину если
заданный ключ был найден.</p><pre>CL-USER&gt; (remf *plist* :a)<br/>T<br/>CL-USER&gt; *plist*<br/>NIL<br/></pre>
<p>Как и <code>GETF</code>, <code>REMF</code> всегда использует <code>EQ</code> для сравнения
заданного ключа с ключами в списке свойств.
</p>
<p>Поскольку списки свойств часто используются в ситуациях, когда вы
хотите извлечь несколько значений свойств из одного и того же списка,
Common Lisp предоставляет функцию <code>GET-PROPERTIES</code>, которая делает
более эффективным извлечение нескольких значений из одного списка
свойств. Она принимает список свойств и список ключей для поиска, и
возвращает, в виде множества значений (<em>multiple values</em>), первый
найденный ключ, соответствующее ему значение, и голову списка,
начинающегося с этого ключа. Это позволяет вам обработать список
свойств, извлекая из него нужные свойства, без продолжительного
повторного поиска с начала списка.  К примеру, следующая функция
эффективно обрабатывает, используя гипотетическую функцию
<code>process-property</code>, все пары ключ/значение в списке свойств для
заданного списка ключей:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> process-properties <span class="paren2">(<span class="">plist keys</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> while plist <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a><br/>        <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_multip.htm" class="symbol">multiple-value-bind</a> <span class="paren4">(<span class="">key value tail</span>)</span> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_get_pr.htm" class="symbol">get-properties</a> plist keys</span>)</span><br/>          <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> key <span class="paren5">(<span class="">process-property key value</span>)</span></span>)</span><br/>          <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> plist <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_car_c.htm" class="symbol">cddr</a> tail</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Последней особенностью списков свойств является их отношение к
символам: каждый символический объект имеет связанный список свойств,
который может быть использован для хранения информации о
символе. Список свойств может быть получен с помощью функции
<code>SYMBOL-PLIST</code>. Тем не менее, обычно вам редко необходим весь список
свойств; чаще вы будете использовать функцию <code>GET</code>, которая
принимает символ и ключ и выполняет роль сокращенной записи для
<code>GETF</code> с аргументами в виде того же ключа и списка символов,
возвращаемого <code>SYMBOL-PLIST</code>.
</p><pre>(get 'symbol 'key) === (getf (symbol-plist 'symbol) 'key)<br/></pre>
<p>Как с <code>GETF</code>, к возвращаемому значению <code>GET</code> можно применить
<code>SETF</code>, так что вы можете присоединить произвольную информацию к
символу, как здесь:
</p><pre>(setf (get 'some-symbol 'my-key) "information")<br/></pre>

<p>Чтобы удалить свойство из списка свойств символа, вы можете
использовать либо <code>REMF</code> поверх <code>SYMBOL-PLIST</code> или удобную
функцию <code>REMPROP</code> <a class="fn_top" id="fnt__4" href="beyond-lists-other-uses-for-cons-cells#fn__4">4)</a>
</p><pre>(remprop 'symbol 'key) === (remf (symbol-plist 'symbol) 'key)<br/></pre>
<p>Возможность связывать произвольную информацию с именами довольно
удобна, если вы занимаетесь какого-либо рода символическим
программированием. К примеру, один макрос, который вы напишете в Главе
24, будет связывать информацию с именами, которую другие экземпляры того
же макроса будут извлекать и использовать при генерации собственных
расширений.
</p>

</div><div class="chapter" id="DESTRUCTURING-BIND"><h3>DESTRUCTURING-BIND</h3>


<p>Последний инструмент для разделки и нарезки списков, о котором я
должен рассказать, поскольку он понадобится вам в дальнейших главах -
это макрос <code>DESTRUCTURING-BIND</code>. Этот макрос предоставляет способ <em>деструктурировать</em> произвольные списки, подобно тому, как
списки параметров макроса могут разбирать на части свои списки
аргументов. Основной скелет <code>DESTRUCTURING-BIND</code> таков:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_destru.htm" class="symbol">destructuring-bind</a> <span class="paren2">(<span class="">parameter*</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a><br/>  body-form*</span>)</span><br/></pre>

<p>Список параметров может включать любые из типов параметров,
поддерживаемых в списках параметров макросов, таких как: <code>&amp;optional</code>,
<code>&amp;rest</code> и <code>&amp;key</code>.<a class="fn_top" id="fnt__5" href="beyond-lists-other-uses-for-cons-cells#fn__5">5)</a> Как и в списке
параметров макроса, любой параметр может быть заменен на вложенный
деструктурирующий список параметров, который разделяет список на
составные части, иначе список целиком был бы связан с заменённым
параметром. Форма <em>list</em> вычисляется один раз и возвращает список,
который затем деструктурируется и соответствующие значения связываются
с переменными в списке параметров. Затем по порядку вычисляются
все <em>body-form</em> с учётом значений связанных переменных. Вот
несколько простых примеров:</p><pre>(destructuring-bind (x y z) (list 1 2 3)<br/>(list :x x :y y :z z)) ==&gt; (:X 1 :Y 2 :Z 3)<br/>(destructuring-bind (x y z) (list 1 (list 2 20) 3)<br/>(list :x x :y y :z z)) ==&gt; (:X 1 :Y (2 20) :Z 3)<br/>(destructuring-bind (x (y1 y2) z) (list 1 (list 2 20) 3)<br/>(list :x x :y1 y1 :y2 y2 :z z)) ==&gt; (:X 1 :Y1 2 :Y2 20 :Z 3)<br/>(destructuring-bind (x (y1 &amp;optional y2) z) (list 1 (list 2 20) 3)<br/>(list :x x :y1 y1 :y2 y2 :z z)) ==&gt; (:X 1 :Y1 2 :Y2 20 :Z 3)<br/>(destructuring-bind (x (y1 &amp;optional y2) z) (list 1 (list 2) 3)<br/>(list :x x :y1 y1 :y2 y2 :z z)) ==&gt; (:X 1 :Y1 2 :Y2 NIL :Z 3)<br/>(destructuring-bind (&amp;key x y z) (list :x 1 :y 2 :z 3)<br/>(list :x x :y y :z z)) ==&gt; (:X 1 :Y 2 :Z 3)<br/>(destructuring-bind (&amp;key x y z) (list :z 1 :y 2 :x 3)<br/>(list :x x :y y :z z)) ==&gt; (:X 3 :Y 2 :Z 1)				   <br/></pre>
<p>Единственный вид параметра, который вы можете использовать как с
<code>DESTRUCTURING-BIND</code>, так и в списках параметров макросов, о котором
я не упомянул в Главе 8, это параметр <code>&amp;whole</code>. Если он указан, то
располагается первым в списке параметров, и связывается со всей формой
списка целиком.<a class="fn_top" id="fnt__6" href="beyond-lists-other-uses-for-cons-cells#fn__6">6)</a> После параметра <code>&amp;whole</code>,
другие параметры могут появляться как обычно, и извлекать определенные
части списка, как если бы параметр <code>&amp;whole</code> отсутствовал. Пример
использования <code>&amp;whole</code> вместе с <code>DESTRUCTURING-BIND</code> выглядит так:</p><pre>(destructuring-bind (&amp;whole whole &amp;key x y z) (list :z 1 :y 2 :x 3)<br/>  (list :x x :y y :z z :whole whole))<br/>==&gt; (:X 3 :Y 2 :Z 1 :WHOLE (:Z 1 :Y 2 :X 3))<br/></pre>
<p>Вы будете использовать параметр <code>&amp;whole</code> в одном из макросов,
составляющих часть библиотеки для генерации HTML, которую вы
разработаете в Главе 31.  Однако мне нужно рассмотреть еще несколько
вопросов, прежде чем вы приступите к ней. После двух глав довольно
лисповских тем про cons-ячейки, вы можете перейти к более скучным
вопросам о том, как работать с файлами и именами файлов.
</p>





</div></div><div class="footnotes"><div><a class="fn_bot" id="fn__1" href="beyond-lists-other-uses-for-cons-cells#fnt__1">1)</a>Возможно создать цепь списочных ячеек, где <code>CDR</code>
последней ячейки будет не <code>NIL</code>, а неким другим атомом. Такая
конструкция будет называться <em>точечным списком</em> (<em>dotted list</em>),
потому что последняя списочная ячейка является точечной парой.</div><div><a class="fn_bot" id="fn__2" href="beyond-lists-other-uses-for-cons-cells#fnt__2">2)</a>Казалось бы, семейство <code>NSUBST</code>-функций не только может, но и
в действительности модифицирует дерево прямо на месте. Однако имеется
один крайний случай: когда переданное "дерево" фактически является
атомом, оно не может быть модифицировано по месту, тогда результатом
NSUBST будет являться отличный от аргумента объект: <code>(nsubst 'x 'y
'y) X</code>.</div><div><a class="fn_bot" id="fn__3" href="beyond-lists-other-uses-for-cons-cells#fnt__3">3)</a><code>UNION</code> принимает только один элемент из каждого
списка, но если один из двух списков содержит дублирующиеся элементы,
результат может также содержать дубликаты.</div><div><a class="fn_bot" id="fn__4" href="beyond-lists-other-uses-for-cons-cells#fnt__4">4)</a>Также возможно напрямую выполнить <code>SETF</code> над
значением, возвращаемым <code>SYMBOL-PLIST</code>. Однако это плохая идея,
поскольку различный код может добавлять различные свойства к символам
списка свойств с различными целями. Если один кусок кода затирает весь
список свойств символа, он может помешать работе другого кода, который
добавил свои свойства к списку.</div><div><a class="fn_bot" id="fn__5" href="beyond-lists-other-uses-for-cons-cells#fnt__5">5)</a>Списки параметров макроса поддерживают один
тип параметра, который не поддерживает <code>DESTRUCTURING-BIND</code> - это
<code>&amp;environment</code>. Тем не менее я не обсуждал этот тип параметра в
Главе 8, и сейчас вам не стоит об этом беспокоиться.</div><div><a class="fn_bot" id="fn__6" href="beyond-lists-other-uses-for-cons-cells#fnt__6">6)</a>Когда параметр <code>&amp;whole</code> используется в списке
параметров макроса, то форма с которой он связан соответствует всей
форме макроса, включая имя макроса</div></div></div> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="they-called-it-lisp-for-a-reason-list-processing">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right"> <a href="files-and-file-io">Следующая</a> </td> </tr> </tbody> </table> </div> <div class="bottom">@2009-2013 lisper.ru</div> 
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7734690-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
 </body> </html>