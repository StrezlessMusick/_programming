<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru"> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <meta name="keywords" content="Common Lisp,lisp,лисп" /> <title>Практика: Библиотека для генерации HTML, Компилятор.</title> <link href="../css/style.css" rel="stylesheet" type="text/css" /><link href="../css/colorize.css" rel="stylesheet" type="text/css" />  </head> <body> <div class="top"> <div id="login"> <a href="http://lisper.ru/register">Регистрация</a> | <a href="http://lisper.ru/login?done=/pcl/practical-an-html-generation-library-the-compiler">Войти</a> </div> </div> <div id="caution"> <img alt="Lisp — программируемый язык программирования" src="../image/gecko.png" /> <a href="http://www.vkusnoserver.ru/" target="_blank" style="float: right;"> <img src="../vkusnoserver.png" /> </a> </div> <div id="mainmenu"> <ul> <li> <a href="http://lisper.ru/">Главная</a> </li><li> <a href="http://lisper.ru/articles/">Статьи</a> </li><li> <a href="http://lisper.ru/planet/">Планета</a> </li><li> <a href="http://lisper.ru/forum/">Форум</a> </li><li> <a href="http://lisper.ru/apps/">Сервисы</a> </li><li> <a href="index.html">Practical Common Lisp</a> </li><li> <a href="http://lisper.ru/wiki/">Wiki</a> </li><li> <a href="http://lisper.ru/files/">Файлы</a> </li><li> <a href="http://lisper.ru/search">Поиск</a> </li> </ul> </div> <div id="content"> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="practical-an-html-generation-library-the-interpreter">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right">  </td> </tr> </tbody> </table> <div class="article"><div class="toc"><div class="toc-header">Содержание</div><div class="toc-body"><ul><li><div><a href="practical-an-html-generation-library-the-compiler#31. &#x41F;&#x440;&#x430;&#x43A;&#x442;&#x438;&#x43A;&#x430;: &#x411;&#x438;&#x431;&#x43B;&#x438;&#x43E;&#x442;&#x435;&#x43A;&#x430; &#x434;&#x43B;&#x44F; &#x433;&#x435;&#x43D;&#x435;&#x440;&#x430;&#x446;&#x438;&#x438; HTML, &#x41A;&#x43E;&#x43C;&#x43F;&#x438;&#x43B;&#x44F;&#x442;&#x43E;&#x440;.">31. Практика: Библиотека для генерации HTML, Компилятор.</a><ul><li><div><a href="practical-an-html-generation-library-the-compiler#&#x41A;&#x43E;&#x43C;&#x43F;&#x438;&#x43B;&#x44F;&#x442;&#x43E;&#x440;">Компилятор</a></div></li><li><div><a href="practical-an-html-generation-library-the-compiler#&#x421;&#x43F;&#x435;&#x446;&#x438;&#x430;&#x43B;&#x44C;&#x43D;&#x44B;&#x435; &#x43E;&#x43F;&#x435;&#x440;&#x430;&#x442;&#x43E;&#x440;&#x44B; FOO">Специальные операторы FOO</a></div></li><li><div><a href="practical-an-html-generation-library-the-compiler#&#x41C;&#x430;&#x43A;&#x440;&#x43E;&#x441;&#x44B; FOO">Макросы FOO</a></div></li><li><div><a href="practical-an-html-generation-library-the-compiler#&#x41F;&#x443;&#x431;&#x43B;&#x438;&#x447;&#x43D;&#x44B;&#x439; &#x438;&#x43D;&#x442;&#x435;&#x440;&#x444;&#x435;&#x439;&#x441; &#x440;&#x430;&#x437;&#x440;&#x430;&#x431;&#x43E;&#x442;&#x447;&#x438;&#x43A;&#x430; (API)">Публичный интерфейс разработчика (API)</a></div></li><li><div><a href="practical-an-html-generation-library-the-compiler#&#x41A;&#x43E;&#x43D;&#x435;&#x446; &#x440;&#x430;&#x431;&#x43E;&#x442;&#x44B;">Конец работы</a></div></li></ul></div></li></ul></div></div>
<div class="chapter" id="31. &#x41F;&#x440;&#x430;&#x43A;&#x442;&#x438;&#x43A;&#x430;: &#x411;&#x438;&#x431;&#x43B;&#x438;&#x43E;&#x442;&#x435;&#x43A;&#x430; &#x434;&#x43B;&#x44F; &#x433;&#x435;&#x43D;&#x435;&#x440;&#x430;&#x446;&#x438;&#x438; HTML, &#x41A;&#x43E;&#x43C;&#x43F;&#x438;&#x43B;&#x44F;&#x442;&#x43E;&#x440;."><h3>31. Практика: Библиотека для генерации HTML, Компилятор.</h3>

<p>Теперь вы готовы к тому, чтобы увидеть как работает компилятор FOO. Основное различие между компилятором и интерпретатором заключается в том, что интерпретатор обрабтывает программу и сразу производит какие-то действия – генерирует HTML, в случае интерпретатора FOO, а компилятор обрабатывает ту же самую прогрумму, и генерирует код на каком-то другом языке, который будет производить те же самые действия.  В языке FOO компилятор является макросом Common Lisp, который транслирует инструкции FOO в код на Common Lisp, так что он может быть встроен в программы на Common Lisp. В общем, компиляторы имеют преимущества над интерпретаторами, поскольку компиляция происходит заранее, так что они могут потратить некоторое количество времени оптимизуя генерируемый код, делая его более эффективным.  Это же делает компилятор FOO, объединяя текстовые строки насколько это возможно, чтобы выдавать точно такой же HTML с меньшим количеством операций записи по сравнению с интерпретатором.  Когда компилятор является макросом Common Lisp, вы также имеете преимущества, поскольку компилятор сможет обрабатывать вставленные куски кода на Common Lisp – компилятору нужно лишь распознать их и вставить в правильное место генерируемого кода.  Компилятор FOO получит некоторые преимущества от использования этой возможности.
</p>
<div class="chapter" id="&#x41A;&#x43E;&#x43C;&#x43F;&#x438;&#x43B;&#x44F;&#x442;&#x43E;&#x440;"><h3>Компилятор</h3>

<p>Базовая архитектура компилятора состоит из трех уровней.  Сначала вы реализуете класс <code>html-compiler</code> который имеет один слот, который содержит расширяемый вектор, который используется для накопления кодов операций (ops), представляющих  вызовы сделанные к обобщенным функциям FIXME backend при выполнении <code>process</code>.
</p>
<p>Затем вы реализуете методы для обобщенных функций FIXME backend interface, которые будут сохранять последовательность действий в векторе.  Каждый код операции представлен списком состоящим из ключевого слова, именующего операцию, и аргументов, переданных функции, которая сгенерировала этот код операции.  Функция <code>sexp-&gt;ops</code> реализует первую стадию компиляции – преобразование списка выражений FOO путем вызова <code>process</code> для каждого выражения с объектом <code>html-compiler</code>.
</p>
<p>Этот вектор с кодами операций, созданный компилятором, затем передается функции, которая оптимизирует его, объединяя последовательные операции <code>raw-string</code> в одну операцию, которая выдаст объединенную строку за один вызов. Функция оптимизации, также может, не обязательно, отбросить операции, которые необходимы только для выдачи хорошо отформатированного кода, что является достаточно важным, поскольку это позволит объединить большее количество операций <code>raw-string</code>.
</p>
<p>И в заключение, оптимизированный вектор с кодами операций передается третьей функции, <code>generate-code</code>, которая возвращает список выражений Common Lisp, выполнение которых приведет к выводу HTML.   Когда переменная <code>*pretty*</code> имеет истинное значение, то <code>generate-code</code> генерирует код, который использует методы, специализированные для  <code>html-pretty-printer</code>, для того, чтобы вывести хорошо отформатированный HTML. Когда <code>*pretty*</code> равна <code>NIL</code>, то эта функция генерирует код, который будет выводить данные напрямую в поток <code>*html-output*</code>.
</p>
<p>Макрос <code>html</code> в действительности генерирует тело выражения, которое содержит два раскрытия кода – одно для случая, когда <code>*pretty*</code> равно <code>T</code>, и второе для случая, когда <code>*pretty*</code> равно <code>NIL</code>.  То, какое выражение будет использоваться, определяется во время выполнения в зависимости от значения переменной <code>*pretty*</code>.  Таким образом, любая функция, которая содержит вызов <code>html</code>, будет иметь код для генерации компактного и хорошо оформленного вывода.
</p>
<p>Другим важным отличием между компилятором и интерпретатором является то, что компилятор может внедрять выражения на Lisp в генерируемый код.  Чтобы воспользоваться этим преимуществом, вам необходимо изменить функцию <code>process</code> таким образом, чтобы она вызывала функции <code>embed-code</code> и <code>embed-value</code> в тех случаях, когда ее просят обработать выражение, которое не является выражением FOO. Поскольку, все FIXME self-evaluating объекты являются допустимыми выражениями FOO, единственными выражениями, которое не будет передано <code>process-sexp-html</code> являются списки, которые не соответствуют синтаксису выражений-ячеек (FIXME cons forms) FOO и не-именованным символам – единственным атомам, которые не вычисляются сами в себя FIXME self-evaluating.  Вы можете предположить, что любой список не относящийся к FOO является кодом, который необходимо выполнять, а все символы являются переменными, чьи значения вы должны вставить в генерируемый код.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> process <span class="paren2">(<span class="">processor form</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_cond.htm" class="symbol"><i><span class="symbol">cond</span></i></a><br/>    <span class="paren3">(<span class=""><span class="paren4">(<span class="">sexp-html-p form</span>)</span> <span class="paren4">(<span class="">process-sexp-html processor form</span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_consp.htm" class="symbol">consp</a> form</span>)</span>       <span class="paren4">(<span class="">embed-code processor form</span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a>                  <span class="paren4">(<span class="">embed-value processor form</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Теперь давайте взглянем на код компилятора.  Во первых вы должны определить две функции, которые абстрагируют вектор, который вы будете использовать для хранения кодов операций в первых двух стадиях компиляции.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> make-op-buffer <span class="paren2">(<span class=""/>)</span> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_ar.htm" class="symbol">make-array</a> 10 <span class="keyword">:adjustable</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="keyword">:fill-pointer</span> 0</span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> push-op <span class="paren2">(<span class="">op ops-buffer</span>)</span> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_vec_ps.htm" class="symbol">vector-push-extend</a> op ops-buffer</span>)</span></span>)</span><br/></pre>

<p>Затем, вы можете определить класс <code>html-compiler</code> и методы, специализированные для него, реализующие FIXME backend interface.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defcla.htm" class="symbol"><i><span class="symbol">defclass</span></i></a> html-compiler <span class="paren2">(<span class=""/>)</span><br/>  <span class="paren2">(<span class=""><span class="paren3">(<span class="">ops <span class="keyword">:accessor</span> ops <span class="keyword">:initform</span> <span class="paren4">(<span class="">make-op-buffer</span>)</span></span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> raw-string <span class="paren2">(<span class=""><span class="paren3">(<span class="">compiler html-compiler</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_string.htm" class="symbol">string</a> &amp;optional newlines-p</span>)</span><br/>  <span class="paren2">(<span class="">push-op `<span class="paren3">(<span class=""><span class="keyword">:raw-string</span> ,<a href="http://www.lispworks.com/reference/HyperSpec/Body/a_string.htm" class="symbol">string</a> ,newlines-p</span>)</span> <span class="paren3">(<span class="">ops compiler</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> newline <span class="paren2">(<span class=""><span class="paren3">(<span class="">compiler html-compiler</span>)</span></span>)</span><br/>  <span class="paren2">(<span class="">push-op '<span class="paren3">(<span class=""><span class="keyword">:newline</span></span>)</span> <span class="paren3">(<span class="">ops compiler</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> freshline <span class="paren2">(<span class=""><span class="paren3">(<span class="">compiler html-compiler</span>)</span></span>)</span><br/>  <span class="paren2">(<span class="">push-op '<span class="paren3">(<span class=""><span class="keyword">:freshline</span></span>)</span> <span class="paren3">(<span class="">ops compiler</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> indent <span class="paren2">(<span class=""><span class="paren3">(<span class="">compiler html-compiler</span>)</span></span>)</span><br/>  <span class="paren2">(<span class="">push-op `<span class="paren3">(<span class=""><span class="keyword">:indent</span></span>)</span> <span class="paren3">(<span class="">ops compiler</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> unindent <span class="paren2">(<span class=""><span class="paren3">(<span class="">compiler html-compiler</span>)</span></span>)</span><br/>  <span class="paren2">(<span class="">push-op `<span class="paren3">(<span class=""><span class="keyword">:unindent</span></span>)</span> <span class="paren3">(<span class="">ops compiler</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> toggle-indenting <span class="paren2">(<span class=""><span class="paren3">(<span class="">compiler html-compiler</span>)</span></span>)</span><br/>  <span class="paren2">(<span class="">push-op `<span class="paren3">(<span class=""><span class="keyword">:toggle-indenting</span></span>)</span> <span class="paren3">(<span class="">ops compiler</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> embed-value <span class="paren2">(<span class=""><span class="paren3">(<span class="">compiler html-compiler</span>)</span> value</span>)</span><br/>  <span class="paren2">(<span class="">push-op `<span class="paren3">(<span class=""><span class="keyword">:embed-value</span> ,value ,<span class="special">*escapes*</span></span>)</span> <span class="paren3">(<span class="">ops compiler</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> embed-code <span class="paren2">(<span class=""><span class="paren3">(<span class="">compiler html-compiler</span>)</span> code</span>)</span><br/>  <span class="paren2">(<span class="">push-op `<span class="paren3">(<span class=""><span class="keyword">:embed-code</span> ,code</span>)</span> <span class="paren3">(<span class="">ops compiler</span>)</span></span>)</span></span>)</span><br/></pre>

<p>После определения этих методов, вы можете реализовать первую стадию компиляции – <code>sexp-&gt;ops</code>.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> sexp-&gt;ops <span class="paren2">(<span class="">body</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> with compiler = <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_ins.htm" class="symbol">make-instance</a> 'html-compiler</span>)</span><br/>     for form in body <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren3">(<span class="">process compiler form</span>)</span><br/>     finally <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_return.htm" class="symbol">return</a> <span class="paren4">(<span class="">ops compiler</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Во время этой фазы, вам нет необходимости учитывать значение переменной <code>*pretty*</code>: просто записывайте все функции вызванные функцией <code>process</code>.  Вот что <code>sexp-&gt;ops</code> сделает из простого выражения FOO:
</p>
<pre class="code"><p>HTML&gt; <span class="paren1">(<span class="">sexp-&gt;ops '<span class="paren2">(<span class=""><span class="paren3">(<span class=""><span class="keyword">:p</span> <span class="string">"Foo"</span></span>)</span></span>)</span></span>)</span><br/>
#<span class="paren1">(<span class=""><span class="paren2">(<span class=""><span class="keyword">:FRESHLINE</span></span>)</span> <span class="paren2">(<span class=""><span class="keyword">:RAW-STRING</span> <span class="string">"&lt;p"</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">NIL</a></span>)</span> <span class="paren2">(<span class=""><span class="keyword">:RAW-STRING</span> <span class="string">"&gt;"</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">NIL</a></span>)</span><br/>  <span class="paren2">(<span class=""><span class="keyword">:RAW-STRING</span> <span class="string">"Foo"</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">T</a></span>)</span> <span class="paren2">(<span class=""><span class="keyword">:RAW-STRING</span> <span class="string">"&lt;/p&gt;"</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">NIL</a></span>)</span> <span class="paren2">(<span class=""><span class="keyword">:FRESHLINE</span></span>)</span></span>)</span><br/></p></pre>

<p>На следующей фазе, функция <code>optimize-static-output</code> принимает вектор кодов операций, и возвращает новый вектор, содержащий оптимизированную версию.  Алгоритм очень прост – для каждой операции <code>:raw-string</code>, функция записывает строку во временный строковый буфер. Таким образом, последовательные вызовы <code>:raw-string</code> приведут к построению одной строки, содержащих объединение всех строк, которые должны быть выведены. Когда вы встречаете код операции, отличный от кода <code>:raw-string</code>, то вы преобразуете созданную строку в последовательность операций <code>:raw-string</code> и <code>:newline</code> используя вспомогательную функцию <code>compile-buffer</code>, и затем добавляете новый код операции.  В этой функции вы также отбрасываете "красивое" форматирование, если значением <code>*pretty*</code> является <code>NIL</code>.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> optimize-static-output <span class="paren2">(<span class="">ops</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">new-ops <span class="paren5">(<span class="">make-op-buffer</span>)</span></span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_w_out_.htm" class="symbol"><i><span class="symbol">with-output-to-string</span></i></a> <span class="paren4">(<span class="">buf</span>)</span><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_flet_.htm" class="symbol"><i><span class="symbol">flet</span></i></a> <span class="paren5">(<span class=""><span class="paren6">(<span class="">add-op <span class="paren1">(<span class="">op</span>)</span> <br/>               <span class="paren1">(<span class="">compile-buffer buf new-ops</span>)</span><br/>               <span class="paren1">(<span class="">push-op op new-ops</span>)</span></span>)</span></span>)</span><br/>        <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for op across ops <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a><br/>             <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_case_.htm" class="symbol">ecase</a> <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_firstc.htm" class="symbol">first</a> op</span>)</span><br/>               <span class="paren1">(<span class=""><span class="keyword">:raw-string</span> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_firstc.htm" class="symbol">second</a> op</span>)</span> buf</span>)</span></span>)</span><br/>               <span class="paren1">(<span class=""><span class="paren2">(<span class=""><span class="keyword">:newline</span> <span class="keyword">:embed-value</span> <span class="keyword">:embed-code</span></span>)</span> <span class="paren2">(<span class="">add-op op</span>)</span></span>)</span><br/>               <span class="paren1">(<span class=""><span class="paren2">(<span class=""><span class="keyword">:indent</span> <span class="keyword">:unindent</span> <span class="keyword">:freshline</span> <span class="keyword">:toggle-indenting</span></span>)</span><br/>                <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="special">*pretty*</span> <span class="paren3">(<span class="">add-op op</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/>        <span class="paren5">(<span class="">compile-buffer buf new-ops</span>)</span></span>)</span></span>)</span><br/>    new-ops</span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> compile-buffer <span class="paren2">(<span class="">buf ops</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> with str = <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_get_ou.htm" class="symbol">get-output-stream-string</a> buf</span>)</span><br/>     for start = 0 then <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_1pl_1_.htm" class="symbol">1+</a> pos</span>)</span><br/>     for pos = <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_pos_p.htm" class="symbol">position</a> <span class="character">#\Newline</span> str <span class="keyword">:start</span> start</span>)</span><br/>     <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="paren3">(<span class="">&lt; start <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_length.htm" class="symbol">length</a> str</span>)</span></span>)</span><br/>     <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren3">(<span class="">push-op `<span class="paren4">(<span class=""><span class="keyword">:raw-string</span> ,<span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_subseq.htm" class="symbol">subseq</a> str start pos</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span> ops</span>)</span><br/>     <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> pos <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren3">(<span class="">push-op '<span class="paren4">(<span class=""><span class="keyword">:newline</span></span>)</span> ops</span>)</span><br/>     while pos</span>)</span></span>)</span><br/></pre>

<p>Последним шагом является преобразование кодов операций в соответствующий код Common Lisp. Эта фаза также учитывает значение переменной <code>*pretty*</code>. Когда  <code>*pretty*</code> имеет истинное значение, то функция генерирует код, который вызывает функции используя переменную <code>*html-pretty-printer*</code>, которая содержит экземпляр класса <code>html-pretty-printer</code>.  А когда значение <code>*pretty*</code> равно <code>NIL</code>, то функция генерирует код, который выводит данные прямо в поток, указанный переменной <code>*html-output*</code>.
</p>
<p>Реализация функции <code>generate-code</code> крайне проста.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> generate-code <span class="paren2">(<span class="">ops</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for op across ops collect <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_apply.htm" class="symbol">apply</a> #'op-&gt;code op</span>)</span></span>)</span></span>)</span><br/></pre>

<p>Вся работа выполняется методами обобщенной функции <code>op-&gt;code</code> специализированной для аргумента <code>op</code> со специализатором <code>EQL</code> для имени операции.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defgen.htm" class="symbol"><i><span class="symbol">defgeneric</span></i></a> op-&gt;code <span class="paren2">(<span class="">op &amp;rest operands</span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> op-&gt;code <span class="paren2">(<span class=""><span class="paren3">(<span class="">op <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a> <span class="keyword">:raw-string</span></span>)</span></span>)</span> &amp;rest operands</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_destru.htm" class="symbol">destructuring-bind</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_string.htm" class="symbol">string</a> check-for-newlines</span>)</span> operands<br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="special">*pretty*</span><br/>      `<span class="paren4">(<span class="">raw-string <span class="special">*html-pretty-printer*</span> ,<a href="http://www.lispworks.com/reference/HyperSpec/Body/a_string.htm" class="symbol">string</a> ,check-for-newlines</span>)</span><br/>      `<span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> ,<a href="http://www.lispworks.com/reference/HyperSpec/Body/a_string.htm" class="symbol">string</a> <span class="special">*html-output*</span></span>)</span></span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> op-&gt;code <span class="paren2">(<span class=""><span class="paren3">(<span class="">op <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a> <span class="keyword">:newline</span></span>)</span></span>)</span> &amp;rest operands</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="special">*pretty*</span><br/>    `<span class="paren3">(<span class="">newline <span class="special">*html-pretty-printer*</span></span>)</span><br/>    `<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_cha.htm" class="symbol">write-char</a> <span class="character">#\Newline</span> <span class="special">*html-output*</span></span>)</span></span>)</span></span>)</span>    <br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> op-&gt;code <span class="paren2">(<span class=""><span class="paren3">(<span class="">op <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a> <span class="keyword">:freshline</span></span>)</span></span>)</span> &amp;rest operands</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="special">*pretty*</span><br/>    `<span class="paren3">(<span class="">freshline <span class="special">*html-pretty-printer*</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_error.htm" class="symbol">error</a> <span class="string">"Bad op when not pretty-printing: ~a"</span> op</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> op-&gt;code <span class="paren2">(<span class=""><span class="paren3">(<span class="">op <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a> <span class="keyword">:indent</span></span>)</span></span>)</span> &amp;rest operands</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="special">*pretty*</span><br/>    `<span class="paren3">(<span class="">indent <span class="special">*html-pretty-printer*</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_error.htm" class="symbol">error</a> <span class="string">"Bad op when not pretty-printing: ~a"</span> op</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> op-&gt;code <span class="paren2">(<span class=""><span class="paren3">(<span class="">op <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a> <span class="keyword">:unindent</span></span>)</span></span>)</span> &amp;rest operands</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="special">*pretty*</span><br/>    `<span class="paren3">(<span class="">unindent <span class="special">*html-pretty-printer*</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_error.htm" class="symbol">error</a> <span class="string">"Bad op when not pretty-printing: ~a"</span> op</span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> op-&gt;code <span class="paren2">(<span class=""><span class="paren3">(<span class="">op <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a> <span class="keyword">:toggle-indenting</span></span>)</span></span>)</span> &amp;rest operands</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="special">*pretty*</span><br/>    `<span class="paren3">(<span class="">toggle-indenting <span class="special">*html-pretty-printer*</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_error.htm" class="symbol">error</a> <span class="string">"Bad op when not pretty-printing: ~a"</span> op</span>)</span></span>)</span></span>)</span><br/></pre>

<p>Два наиболее интересных метода <code>op-&gt;code</code> – это те, которые генерируют код для операций <code>:embed-value</code> и <code>:embed-code</code>.  В методе <code>:embed-value</code>, вы можете генерировать немного отличающийся код в зависимости от значения аргумента <code>escapes</code>, поскольку, если <code>escapes</code> равен <code>NIL</code>, то вам нет необходимости генерировать вызов <code>escape</code>.  И когда и <code>*pretty*</code>, и <code>escapes</code> равны <code>NIL</code>, то вы можете сгенерировать код, который будет использовать функцию <code>PRINC</code> для вывода значения напрямую в поток.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> op-&gt;code <span class="paren2">(<span class=""><span class="paren3">(<span class="">op <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a> <span class="keyword">:embed-value</span></span>)</span></span>)</span> &amp;rest operands</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_destru.htm" class="symbol">destructuring-bind</a> <span class="paren3">(<span class="">value escapes</span>)</span> operands<br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="special">*pretty*</span><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> escapes<br/>        `<span class="paren5">(<span class="">raw-string <span class="special">*html-pretty-printer*</span> <span class="paren6">(<span class="">escape <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_to_.htm" class="symbol">princ-to-string</a> ,value</span>)</span> ,escapes</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span><br/>        `<span class="paren5">(<span class="">raw-string <span class="special">*html-pretty-printer*</span> <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_to_.htm" class="symbol">princ-to-string</a> ,value</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span></span>)</span><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> escapes<br/>        `<span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> <span class="paren6">(<span class="">escape <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_to_.htm" class="symbol">princ-to-string</a> ,value</span>)</span> ,escapes</span>)</span> <span class="special">*html-output*</span></span>)</span><br/>        `<span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm" class="symbol">princ</a> ,value <span class="special">*html-output*</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Так, что что-то подобное вот такому коду:
</p>
<pre class="code"><p>HTML&gt; <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren2">(<span class=""><span class="paren3">(<span class="">x 10</span>)</span></span>)</span> <span class="paren2">(<span class="">html <span class="paren3">(<span class=""><span class="keyword">:p</span> x</span>)</span></span>)</span></span>)</span><br/>
&lt;p&gt;10&lt;/p&gt;<br/>
NIL<br/></p></pre>

<p>будет работать, поскольку <code>html</code> преобразует <code>(:p x)</code> в что-то наподобие вот этого:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_progn.htm" class="symbol"><i><span class="symbol">progn</span></i></a><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> <span class="string">"&lt;p&gt;"</span> <span class="special">*html-output*</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> <span class="paren3">(<span class="">escape <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_to_.htm" class="symbol">princ-to-string</a> x</span>)</span> <span class="string">"&lt;&gt;&amp;"</span></span>)</span> <span class="special">*html-output*</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> <span class="string">"&lt;/p&gt;"</span> <span class="special">*html-output*</span></span>)</span></span>)</span><br/></pre>

<p>Так, что когда будет сгенерирован код, заменяющий вызов  <code>html</code> в контексте <code>LET</code>, то вы получите следующий результат:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren2">(<span class=""><span class="paren3">(<span class="">x 10</span>)</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_progn.htm" class="symbol"><i><span class="symbol">progn</span></i></a><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> <span class="string">"&lt;p&gt;"</span> <span class="special">*html-output*</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> <span class="paren4">(<span class="">escape <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_to_.htm" class="symbol">princ-to-string</a> x</span>)</span> <span class="string">"&lt;&gt;&amp;"</span></span>)</span> <span class="special">*html-output*</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> <span class="string">"&lt;/p&gt;"</span> <span class="special">*html-output*</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>и ссылки на <code>x</code> в сгенерированном коде превратятся в ссылки на лексическую переменную из выражения <code>LET</code>, окружающего выражение <code>html</code>.
</p>
<p>С другой стороны, метод <code>:embed-code</code> интересен, поскольку она крайне примитивен.  Поскольку функция  <code>process</code> передала выражаение функции <code>embed-code</code>, которая сохранила его в операции <code>:embed-code</code>, то все, что вам нужно сделать – извлечь и вернуть это выражение.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> op-&gt;code <span class="paren2">(<span class=""><span class="paren3">(<span class="">op <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a> <span class="keyword">:embed-code</span></span>)</span></span>)</span> &amp;rest operands</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_firstc.htm" class="symbol">first</a> operands</span>)</span></span>)</span><br/></pre>

<p>Это позволяет использовать, например, вот такой код:
</p>
<pre class="code"><p>HTML&gt; <span class="paren1">(<span class="">html <span class="paren2">(<span class=""><span class="keyword">:ul</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_dolist.htm" class="symbol">dolist</a> <span class="paren4">(<span class="">x '<span class="paren5">(<span class="">foo bar baz</span>)</span></span>)</span> <span class="paren4">(<span class="">html <span class="paren5">(<span class=""><span class="keyword">:li</span> x</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/>
&lt;ul&gt;<br/>
  &lt;li&gt;FOO&lt;/li&gt;<br/>
  &lt;li&gt;BAR&lt;/li&gt;<br/>
  &lt;li&gt;BAZ&lt;/li&gt;<br/>
&lt;/ul&gt;<br/>
NIL<br/></p></pre>

<p>Внешний вызов <code>html</code> раскрывается в код, который делает что-то подобное следующему коду:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_progn.htm" class="symbol"><i><span class="symbol">progn</span></i></a><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> <span class="string">"&lt;ul&gt;"</span> <span class="special">*html-output*</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_dolist.htm" class="symbol">dolist</a> <span class="paren3">(<span class="">x '<span class="paren4">(<span class="">foo bar baz</span>)</span></span>)</span> <span class="paren3">(<span class="">html <span class="paren4">(<span class=""><span class="keyword">:li</span> x</span>)</span></span>)</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> <span class="string">"&lt;/ul&gt;"</span> <span class="special">*html-output*</span></span>)</span></span>)</span>))<br/></pre>

<p>И затем, если вы раскроете вызов <code>html</code> в теле <code>DOLIST</code>, то вы получите что-то подобное следующему код:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_progn.htm" class="symbol"><i><span class="symbol">progn</span></i></a><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> <span class="string">"&lt;ul&gt;"</span> <span class="special">*html-output*</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_dolist.htm" class="symbol">dolist</a> <span class="paren3">(<span class="">x '<span class="paren4">(<span class="">foo bar baz</span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_progn.htm" class="symbol"><i><span class="symbol">progn</span></i></a><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> <span class="string">"&lt;li&gt;"</span> <span class="special">*html-output*</span></span>)</span><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> <span class="paren5">(<span class="">escape <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_to_.htm" class="symbol">princ-to-string</a> x</span>)</span> <span class="string">"&lt;&gt;&amp;"</span></span>)</span> <span class="special">*html-output*</span></span>)</span><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> <span class="string">"&lt;/li&gt;"</span> <span class="special">*html-output*</span></span>)</span></span>)</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_seq.htm" class="symbol">write-sequence</a> <span class="string">"&lt;/ul&gt;"</span> <span class="special">*html-output*</span></span>)</span></span>)</span><br/></pre>

<p>Этот код, будет генерировать результат, который вы уже видели выше.
</p></div><div class="chapter" id="&#x421;&#x43F;&#x435;&#x446;&#x438;&#x430;&#x43B;&#x44C;&#x43D;&#x44B;&#x435; &#x43E;&#x43F;&#x435;&#x440;&#x430;&#x442;&#x43E;&#x440;&#x44B; FOO"><h3>Специальные операторы FOO</h3>

<p>Вы можете остановиться на этом – язык FOO достаточно выразителен для генерации практически любого HTML какой вы можете придумать.  Однако, вы можете добавить две новых возможности к языку с помощью небольшого количества кода, который сделает язык более мощным: специальные операторы и макросы.
</p>
<p>Специальные операторы FOO аналогичны специальным операторам в  Common Lisp. Специальные операторы обеспечивают возможность выражения тех вещей, которые не могут быть выражены на языке, поддерживающем только базовые правила вычисления выражений.  Или, если посмотреть с другой стороны, специальные операторы предоставляют доступ к примитивам, используемым ядром языка, вычисляющем выражения.<a class="fn_top" id="fnt__1" href="practical-an-html-generation-library-the-compiler#fn__1">1)</a>
</p>
<p>В качестве простого примера, в компиляторе FOO, ядро языка использует функцию <code>embed-value</code> для генерации кода, который будет вставлять значение переменной в генерируемый HTML.  Однако, поскольку <code>embed-value</code> передаются только символы, то не существует способа (в том языке, который я описывал) включить значение произвольного выражения Common Lisp; в этом случае функция <code>process</code> передает пары значений функции <code>embed-code</code>, а не <code>embed-value</code>, так что возвращаемые значения игнорируются.  Обычно, это то, что нам надо, поскольку главной причиной вставки кода на Lisp в программу на a FOO является возможность использования управляющих конструкций Lisp.  Однако, иногда вы захотите вставить значение вычисленного выражения в сгенерированный HTML.  Например, вы можете захотеть, чтобы программа на FOO генерировала параграф, содержащий случайное число:
</p>
<pre class="code"><span class="paren1">(<span class=""><span class="keyword">:p</span> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_random.htm" class="symbol">random</a> 10</span>)</span></span>)</span><br/></pre>

<p>Но это не будет работать, поскольку код будет вычислен и его значение будет отброшено.
</p>
<pre class="code"><p>HTML&gt; <span class="paren1">(<span class="">html <span class="paren2">(<span class=""><span class="keyword">:p</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_random.htm" class="symbol">random</a> 10</span>)</span></span>)</span></span>)</span><br/>
&lt;p&gt;&lt;/p&gt;<br/>
NIL<br/></p></pre>

<p>В реализованном нами языке, вы можете обойти это путем вычисления значения вне вызова <code>html</code>, и затем вствки его используя переменную.
</p>
<pre class="code"><p>HTML&gt; <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren2">(<span class=""><span class="paren3">(<span class="">x <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_random.htm" class="symbol">random</a> 10</span>)</span></span>)</span></span>)</span> <span class="paren2">(<span class="">html <span class="paren3">(<span class=""><span class="keyword">:p</span> x</span>)</span></span>)</span></span>)</span><br/>
&lt;p&gt;1&lt;/p&gt;<br/>
NIL<br/></p></pre>

<p>Но это будет раздражать, особенно когда вы считаете, что если бы вы могли бы передать выражение  <code>(random 10)</code> функции  <code>embed-value</code> вместо <code>embed-code</code>, то это было бы то, что надо.  Так что вы можете определить специальный оператор <code>:print</code>, который будет обрабатываться ядром языка FOO с использованием правила, отличного от правил для обычных выражений FOO.  А именно, вместо генерации элемента <code>&lt;print&gt;</code>, он будет передавать выражение, заданное в его теле, функции <code>embed-value</code>.  Так что вы сможете вывести параграф, содержащий случайное число с помощью вот такого вот кода:
</p>
<pre class="code"><p>HTML&gt; <span class="paren1">(<span class="">html <span class="paren2">(<span class=""><span class="keyword">:p</span> <span class="paren3">(<span class=""><span class="keyword">:print</span> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_random.htm" class="symbol">random</a> 10</span>)</span></span>)</span></span>)</span></span>)</span><br/>
&lt;p&gt;9&lt;/p&gt;<br/>
NIL<br/></p></pre>

<p>Понятно, что это специальный оператор полезен только в скомпилированном коде на FOO, поскольку <code>embed-value</code> не работает в режиме интерпретации.  Еще одним специальным оператором, который может быть использован и в режиме компиляции, и в режиме интерпретации, является оператор <code>:format</code>, который позволяет вам генерировать вывод используя функцию <code>FORMAT</code>.  Аргментами специального оператора <code>:format</code> являются строка, управляющая форматом вывода данных, и за ней, любые аргументы.  Когда все аргументы <code>:format</code> являются само-вычисляемыми FIXME self-evaluating объектами, то строка генерируется путем передачи аргументов функции <code>FORMAT</code>, и полученная строка затем выводится также как и любая другая строка.  Это позволяет использовать выражения <code>:format</code> в выражениях FOO, переданных функции <code>emit-html</code>.  В скомпилированном коде FOO, аргументами <code>:format</code> могут быть любые выражения Lisp.
</p>
<p>Другие специальные операторы обеспечивают контроль за тем, какие символы будут автоматически преобразовываться, а также использоваться для вывода символов новой строки:  специальный оператор <code>:noescape</code> приводит к вычислению всех выражений, но при этом переменная <code>*escapes*</code> получает значение <code>NIL</code>, в то время, как <code>:attribute</code> вычисляет все выражения с  <code>*escapes*</code> равным <code>*attribute-escapes*</code>.  А оператор <code>:newline</code> преобразуется в код, который выдает явный перевод строки.
</p>
<p>Так что, как вы будете определять специальные операторы?  Существует два аспекта обработки специальных операторов:  как обработчик языка распознает формы, которые используются для представлени специальных операторов  и как он будет знать, какой код выполнять для обработки каждого из специальных операторов?
</p>
<p>Вы можете изменить функцию <code>process-sexp-html</code> чтобы она распозновала каждый их специальных операторов и обрабатывала их соответствующим образом – с логической точки зрения, специальные операторы являются частью реализации языка, и их не будет очень много. Однако, было бы удобно иметь модульный способ добавления новых специальных операторов – не потому-что пользователи FOO будут иметь возможность их добавления, а просто для нашего собственного удобства.
</p>
<p>Определим специальное выражение как список, чьим значением <code>CAR</code> является символ, представляющий имя специального оператора.  Вы можете пометить имена специальных операторов путем добавления не-<code>NIL</code> значения к списку свойств символов принадлежащем пункту FIXME key <code>html-special-operator</code>.  Так что вы можете определить функцию, которая проверяет, является ли данное выражение, выражением специального оператора, примерно вот так:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> special-form-p <span class="paren2">(<span class="">form</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_and.htm" class="symbol">and</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_consp.htm" class="symbol">consp</a> form</span>)</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_symbol.htm" class="symbol">symbolp</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_car_c.htm" class="symbol">car</a> form</span>)</span></span>)</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_get.htm" class="symbol">get</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_car_c.htm" class="symbol">car</a> form</span>)</span> 'html-special-operator</span>)</span></span>)</span></span>)</span><br/></pre>

<p>Код, реализующий каждый из специальных операторов, также ответственен за получение оставшейся части списка FIXME операндов?? и выполнения того, чего требует семантика специального оператора.  Предполагая, что вы также определили функцию <code>process-special-form</code>, которая принимает в качестве аргументов обработчик язык и выражение со специальным оператором, и выполняет соответствующий код для генерации последовательности вызовов для объекта <code>processor</code>, то вы можете расширить функцию <code>process</code> обработкой специальных операторов следующим образом:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> process <span class="paren2">(<span class="">processor form</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_cond.htm" class="symbol"><i><span class="symbol">cond</span></i></a><br/>    <span class="paren3">(<span class=""><span class="paren4">(<span class="">special-form-p form</span>)</span> <span class="paren4">(<span class="">process-special-form processor form</span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><span class="paren4">(<span class="">sexp-html-p form</span>)</span>    <span class="paren4">(<span class="">process-sexp-html processor form</span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_consp.htm" class="symbol">consp</a> form</span>)</span>          <span class="paren4">(<span class="">embed-code processor form</span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a>                     <span class="paren4">(<span class="">embed-value processor form</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Вы должны в начале добавить вызов <code>special-form-p</code> поскольку специальные операторы могут выглядеть также как обычные выражения FOO, точно также как специальные операторы Common Lisp выглядят также как вызовы обычных функций.
</p>
<p>Теперь вам нужно лишь реализовать  <code>process-special-form</code>.  Вместо того, чтобы определять одну монолитную функцию, которая реализует все специальные операторы, вы должны определить макрос, который позволит вам определять специальные операторы, практически также как обычные функции, и который возьмет на себя заботу о добавлении записи  <code>html-special-operator</code> в список свойств имен специальных операторов.   В действительности, значением которое вы сохраняете в списке свойств может быть функция, которая реализует специальный оператор.  Вот определение соответствующего макроса:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmac.htm" class="symbol"><i><span class="symbol">defmacro</span></i></a> <i><span class="symbol">define-html-special-operator</span></i> <span class="paren2">(<span class="">name <span class="paren3">(<span class="">processor &amp;rest other-parameters</span>)</span> &amp;body body</span>)</span><br/>  `<span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_eval_w.htm" class="symbol"><i><span class="symbol">eval-when</span></i></a> <span class="paren3">(<span class=""><span class="keyword">:compile-toplevel</span> <span class="keyword">:load-toplevel</span> <span class="keyword">:execute</span></span>)</span><br/>     <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_get.htm" class="symbol">get</a> ',name 'html-special-operator</span>)</span><br/>           <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren5">(<span class="">,processor ,@other-parameters</span>)</span> ,@body</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Это достаточно сложный вид макроса, но если вы будете изучать по одной строке за раз, то вы не найдете ничего сложного.  Для того, чтобы увидеть как он работает, рассмотрим простое использование этого макроса – определение специального оператора <code>:noescape</code>, и посмотрим на раскрытие этого макроса.  Если вы напишите вот так:
</p>
<pre class="code"><span class="paren1">(<span class=""><i><span class="symbol">define-html-special-operator</span></i> <span class="keyword">:noescape</span> <span class="paren2">(<span class="">processor &amp;rest body</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class=""><span class="special">*escapes*</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_exp_e.htm" class="symbol">exp</a> in body <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren4">(<span class="">process processor <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_exp_e.htm" class="symbol">exp</a></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>то это приведет к получению следующего кода:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_eval_w.htm" class="symbol"><i><span class="symbol">eval-when</span></i></a> <span class="paren2">(<span class=""><span class="keyword">:compile-toplevel</span> <span class="keyword">:load-toplevel</span> <span class="keyword">:execute</span></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_get.htm" class="symbol">get</a> '<span class="keyword">:noescape</span> 'html-special-operator</span>)</span><br/>        <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren4">(<span class="">processor &amp;rest body</span>)</span><br/>          <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren5">(<span class=""><span class="paren6">(<span class=""><span class="special">*escapes*</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span></span>)</span><br/>            <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_exp_e.htm" class="symbol">exp</a> in body <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren6">(<span class="">process processor <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_exp_e.htm" class="symbol">exp</a></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Специальный оператор <code>EVAL-WHEN</code>, как обсуждалось в главе 20, используется для того, чтобы быть уверенными, что данный код будет виден во время компиляции с помощью функции <code>COMPILE-FILE</code>.  Это нужно, если вы захотите определить <code>define-html-special-operator</code> в файле, и затем использовать только что определенный специальный специальный оператор в том же самом файле.
</p>
<p>Затем, выражение <code>SETF</code> устанавливает значение для свойства <code>html-special-operator</code> символа <code>:noescape</code> чтобы оно содержало анонимную функцию, с тем же списком параметров, как это было определено в <code>define-html-special-operator</code>.  За счет того, что для <code>define-html-special-operator</code> параметры разбиваются на две части – <code>processor</code> и все остальное, вы будете уверены в том, что все специальные аргументы будут принимать как минимум один аргумент.
</p>
<p>Тело анонимной функции является выражением, передаваемым  <code>define-html-special-operator</code>.  Задачей анонимной функции является реализация действия специального оператора путем вызова соответствующих функций интерфейса FIXME backend для генерации корректного HTML или кода, который будет генерировать этот HTML.  Она также использует  <code>process</code> для вычисления выражения как выражения FOO.
</p>
<p>Специальный оператор <code>:noescape</code> является достаточно простым – все что он делает, это передача выражения в функцию <code>process</code> с переменной <code>*escapes*</code> установленной в <code>NIL</code>.  Другими словами, этот специальный оператор запрещает стандартное маскирование символов, выполняемое <code>process-sexp-html</code>.
</p>
<p>При использовании специальных операторов определенных таким образом, все что нужно делать <code>process-special-form</code> – всего лишь найти анонимную функцию в списке свойств символа с именем оператора, и применить ее (с помощью <code>APPLY</code>) к списку из обработчика и оставшейся части выражения.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> process-special-form <span class="paren2">(<span class="">processor form</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_apply.htm" class="symbol">apply</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_get.htm" class="symbol">get</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_car_c.htm" class="symbol">car</a> form</span>)</span> 'html-special-operator</span>)</span> processor <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rest.htm" class="symbol">rest</a> form</span>)</span></span>)</span></span>)</span><br/></pre>

<p>Теперь вы готовы к тому, чтобы определить пять оставшихся специальных операторов  FOO.  Похожим на <code>:noescape</code> является <code>:attribute</code>, который вычисляет заданные выражения с переменной <code>*escapes*</code> равной <code>*attribute-escapes*</code>.  Этот специальный оператор полезен, если вы хотите написать вспомогательную функцию, которая будет выдавать значения атрибутов.  Если вы напишите вот такую вот функцию:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> foo-value <span class="paren2">(<span class="">something</span>)</span><br/>  <span class="paren2">(<span class="">html <span class="paren3">(<span class=""><span class="keyword">:print</span> <span class="paren4">(<span class="">frob something</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>то макрос<code>html</code> сгенерирует код, который выполнит маскирование символов, указанных в  <code>*element-escapes*</code>.  Но если вы планируете использовать <code>foo-value</code> следующим образом:
</p>
<pre class="code"><span class="paren1">(<span class="">html <span class="paren2">(<span class=""><span class="keyword">:p</span> <span class="keyword">:style</span> <span class="paren3">(<span class="">foo-value 42</span>)</span> <span class="string">"Foo"</span></span>)</span></span>)</span><br/></pre>

<p>то вы захотите, чтобы генерировался код, который бы использовал данные из переменной uses <code>*attribute-escapes*</code>.  Так что вместо этого, вы можете написать нечто подобное:<a class="fn_top" id="fnt__2" href="practical-an-html-generation-library-the-compiler#fn__2">2)</a>
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> foo-value <span class="paren2">(<span class="">something</span>)</span><br/>  <span class="paren2">(<span class="">html <span class="paren3">(<span class=""><span class="keyword">:attribute</span> <span class="paren4">(<span class=""><span class="keyword">:print</span> <span class="paren5">(<span class="">frob something</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Определение <code>:attribute</code> выглядит следующим образом:
</p>
<pre class="code"><span class="paren1">(<span class=""><i><span class="symbol">define-html-special-operator</span></i> <span class="keyword">:attribute</span> <span class="paren2">(<span class="">processor &amp;rest body</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class=""><span class="special">*escapes*</span> <span class="special">*attribute-escapes*</span></span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_exp_e.htm" class="symbol">exp</a> in body <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren4">(<span class="">process processor <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_exp_e.htm" class="symbol">exp</a></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Два других специальных оператора – <code>:print</code> и <code>:format</code>, используются для вывода значений.  Специальный оператор <code>:print</code>, как обсуждалось ранее, используется в скомпилированных программах на FOO для вставки значения произвольного выражения Lisp.  Специальный оператор  <code>:format</code> соответствует операции генерации строки с помощью выражения <code>(format nil ...)</code> и последующей вставки этой строки в вывод.  Основной причиной определения  <code>:format</code> как специального оператора является удобство.  Так:
</p>
<pre class="code"><span class="paren1">(<span class=""><span class="keyword">:format</span> <span class="string">"Foo: ~d"</span> x</span>)</span><br/></pre>

<p>лучше выглядит чем:
</p>
<pre class="code"><span class="paren1">(<span class=""><span class="keyword">:print</span> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a> <span class="string">"Foo: ~d"</span> x</span>)</span></span>)</span><br/></pre>

<p>Есть также небольшое преимущество если вы используете <code>:format</code> с само-вычисляемыми аргументами FIXME self-evaluating, то FOO может вычислить <code>:format</code> во время компиляции, а не ждать выполнения программы.  Определения для <code>:print</code> и <code>:format</code> выглядят вот так:
</p>
<pre class="code"><span class="paren1">(<span class=""><i><span class="symbol">define-html-special-operator</span></i> <span class="keyword">:print</span> <span class="paren2">(<span class="">processor form</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_cond.htm" class="symbol"><i><span class="symbol">cond</span></i></a><br/>    <span class="paren3">(<span class=""><span class="paren4">(<span class="">self-evaluating-p form</span>)</span><br/>     <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_warn.htm" class="symbol">warn</a> <span class="string">"Redundant :print of self-evaluating form ~s"</span> form</span>)</span><br/>     <span class="paren4">(<span class="">process-sexp-html processor form</span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a><br/>     <span class="paren4">(<span class="">embed-value processor form</span>)</span></span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><i><span class="symbol">define-html-special-operator</span></i> <span class="keyword">:format</span> <span class="paren2">(<span class="">processor &amp;rest args</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_everyc.htm" class="symbol">every</a> #'self-evaluating-p args</span>)</span><br/>    <span class="paren3">(<span class="">process-sexp-html processor <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_apply.htm" class="symbol">apply</a> #'<a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a> args</span>)</span></span>)</span><br/>    <span class="paren3">(<span class="">embed-value processor `<span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a> ,@args</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Специальный оператор <code>:newline</code> приводит к выводу знака новой строки, что иногда удобно.
</p>
<pre class="code"><span class="paren1">(<span class=""><i><span class="symbol">define-html-special-operator</span></i> <span class="keyword">:newline</span> <span class="paren2">(<span class="">processor</span>)</span><br/>  <span class="paren2">(<span class="">newline processor</span>)</span></span>)</span><br/></pre>

<p>В заключение, специальный оператор <code>:progn</code> аналогичен специальному оператору  <code>PROGN</code> в Common Lisp.  Он просто последовательно обрабатывает выражения внутри своего тела.
</p>
<pre class="code"><span class="paren1">(<span class=""><i><span class="symbol">define-html-special-operator</span></i> <span class="keyword">:progn</span> <span class="paren2">(<span class="">processor &amp;rest body</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_exp_e.htm" class="symbol">exp</a> in body <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren3">(<span class="">process processor <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_exp_e.htm" class="symbol">exp</a></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Другими словами, следующий код:
</p>
<pre class="code"><span class="paren1">(<span class="">html <span class="paren2">(<span class=""><span class="keyword">:p</span> <span class="paren3">(<span class=""><span class="keyword">:progn</span> <span class="string">"Foo "</span> <span class="paren4">(<span class=""><span class="keyword">:i</span> <span class="string">"bar"</span></span>)</span> <span class="string">" baz"</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>сгенерирует тот же код, что и:
</p>
<pre class="code"><span class="paren1">(<span class="">html <span class="paren2">(<span class=""><span class="keyword">:p</span> <span class="string">"Foo "</span> <span class="paren3">(<span class=""><span class="keyword">:i</span> <span class="string">"bar"</span></span>)</span> <span class="string">" baz"</span></span>)</span></span>)</span><br/></pre>

<p>Это может быть показаться странным, поскольку обычное выражение FOO может иметь любое количество выражений внутри своего тела.  Однако специальный оператор удобен в одной ситуации – при написании макросов FOO, что приводит нас к последней возможности языка, которую нам надо реализовать.
</p>
</div><div class="chapter" id="&#x41C;&#x430;&#x43A;&#x440;&#x43E;&#x441;&#x44B; FOO"><h3>Макросы FOO</h3>

<p>Макросы FOO аналогичны по духу макросам  Common Lisp.  Макрос FOO является отрывком кода, который принимает в качестве аргумента выражение на FOO, и возвращает в качестве результата новое выражение на FOO, которое затем вычисляется в соответствии со стандартными правилами вычисления выражений на FOO.  Реализация очень похожа на реализацию специальных операторов.
</p>
<p>Также как и для специальных операторов вы можете определить функцию-предикат, которая будет проверять – является ли заданное выражение макросом.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> macro-form-p <span class="paren2">(<span class="">form</span>)</span><br/>  <span class="paren2">(<span class="">cons-form-p form #'<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren4">(<span class="">x</span>)</span> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_and.htm" class="symbol">and</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_symbol.htm" class="symbol">symbolp</a> x</span>)</span> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_get.htm" class="symbol">get</a> x 'html-macro</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Тут мы используем функцию <code>cons-form-p</code>, определенную выше, поскольку мы хотим позволить использовать любой синтаксис FOO выражений.  Однако, вам нужно передать другую функцию-предикат, которая будет проверять – является ли имя выражения символом с не-<code>NIL</code> свойством <code>html-macro</code>.  Также, как и при реализации специальных операторов, мы определим макрос для определения макросов FOO, которая будет отвечать за сохранение функции в списке свойств символа с именем макроса (имя свойства будет равно <code>html-macro</code>).  Однако, определение макроса немного более сложное, поскольку FOO поддерживает использование двух видов макросов. Некоторые из макросов, которые вы будете определять будут вести себя как обычные элементы HTML, и вам может понадобиться упрощенный доступ к списку аттрибутов.  Другие макросы будут требовать упрощенного доступа к элементам их тела.
</p>
<p>Вы можете сделать различие между двумя видами макросов неявным: когда вы определяете макрос FOO, то список параметров может включать параметр <code>&amp;attributes</code>.  Если он будет указан, то макро-выражение будет рассматриваться как обычное выражение-ячейка, и макро-функция будет получать два значения – список свойств-аттрибутов, и список выражений из которых состоит тело выражения.  Макро-выражение без параметра <code>&amp;attributes</code> будет разбираться как не имеющее аттрибутов, и макро-функция будет принимать один параметр – список, содержащий выражения составляющие тело макроса.  Первый вид полезен для шаблонов HTML. Например:
</p>
<pre class="code"><span class="paren1">(<span class=""><i><span class="symbol">define-html-macro</span></i> <span class="keyword">:mytag</span> <span class="paren2">(<span class="">&amp;attributes attrs &amp;body body</span>)</span><br/>  `<span class="paren2">(<span class=""><span class="paren3">(<span class=""><span class="keyword">:div</span> <span class="keyword">:class</span> <span class="string">"mytag"</span> ,@attrs</span>)</span> ,@body</span>)</span></span>)</span><br/></pre>

<pre class="code"><p>HTML&gt; <span class="paren1">(<span class="">html <span class="paren2">(<span class=""><span class="keyword">:mytag</span> <span class="string">"Foo"</span></span>)</span></span>)</span><br/>
&lt;div class='mytag'&gt;Foo&lt;/div&gt;<br/>
NIL<br/>
HTML&gt; <span class="paren1">(<span class="">html <span class="paren2">(<span class=""><span class="keyword">:mytag</span> <span class="keyword">:id</span> <span class="string">"bar"</span> <span class="string">"Foo"</span></span>)</span></span>)</span><br/>
&lt;div class='mytag' id='bar'&gt;Foo&lt;/div&gt;<br/>
NIL<br/>
HTML&gt; <span class="paren1">(<span class="">html <span class="paren2">(<span class=""><span class="paren3">(<span class=""><span class="keyword">:mytag</span> <span class="keyword">:id</span> <span class="string">"bar"</span></span>)</span> <span class="string">"Foo"</span></span>)</span></span>)</span><br/>
&lt;div class='mytag' id='bar'&gt;Foo&lt;/div&gt;<br/>
NIL<br/></p></pre>

<p>Последний вид макросов более полезен для написания макросов, которые манипулируют выражениями, составляющими их тело.  Этот тип макросов может работать как управляющие конструкции HTML. В качестве простого примера рассмотрим следующий макрос, который реализует конструкцию <code>:if</code>:
</p>
<pre class="code"><span class="paren1">(<span class=""><i><span class="symbol">define-html-macro</span></i> <span class="keyword">:if</span> <span class="paren2">(<span class="">test then else</span>)</span><br/>  `<span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> ,test <span class="paren3">(<span class="">html ,then</span>)</span> <span class="paren3">(<span class="">html ,else</span>)</span></span>)</span></span>)</span><br/></pre>

<p>Этот макрос позволит вам писать так:
</p>
<pre class="code"><span class="paren1">(<span class=""><span class="keyword">:p</span> <span class="paren2">(<span class=""><span class="keyword">:if</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_zerop.htm" class="symbol">zerop</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_random.htm" class="symbol">random</a> 2</span>)</span></span>)</span> <span class="string">"Heads"</span> <span class="string">"Tails"</span></span>)</span></span>)</span><br/></pre>

<p>вместо такой, более многословной версии:
</p>
<pre class="code"><span class="paren1">(<span class=""><span class="keyword">:p</span> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_zerop.htm" class="symbol">zerop</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_random.htm" class="symbol">random</a> 2</span>)</span></span>)</span> <span class="paren3">(<span class="">html <span class="string">"Heads"</span></span>)</span> <span class="paren3">(<span class="">html <span class="string">"Tails"</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Для того, чтобы определить какой тип макроса вы должны генерировать, вам необходима функция, которая выполнит разбор списка параметров, переданных <code>define-html-macro</code>.  Эта функция возвращает два значения: имя параметра <code>&amp;attributes</code>, или <code>NIL</code>, если он не указан, и список всех элементов <code>args</code> оставшихся после удаления маркера <code>&amp;attributes</code> и последующих элементов списка.<a class="fn_top" id="fnt__3" href="practical-an-html-generation-library-the-compiler#fn__3">3)</a>
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> parse-html-macro-lambda-list <span class="paren2">(<span class="">args</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">attr-cons <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_member.htm" class="symbol">member</a> '&amp;attributes args</span>)</span></span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_values.htm" class="symbol">values</a> <br/>     <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_car_c.htm" class="symbol">cadr</a> attr-cons</span>)</span><br/>     <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_nconc.htm" class="symbol">nconc</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_ldiffc.htm" class="symbol">ldiff</a> args attr-cons</span>)</span> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_car_c.htm" class="symbol">cddr</a> attr-cons</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<pre class="code"><p>HTML&gt; <span class="paren1">(<span class="">parse-html-macro-lambda-list '<span class="paren2">(<span class="">a b c</span>)</span></span>)</span><br/>
NIL<br/><span class="paren1">(<span class="">A B C</span>)</span><br/>HTML&gt; <span class="paren1">(<span class="">parse-html-macro-lambda-list '<span class="paren2">(<span class="">&amp;attributes attrs a b c</span>)</span></span>)</span><br/>
ATTRS<br/><span class="paren1">(<span class="">A B C</span>)</span><br/>HTML&gt; <span class="paren1">(<span class="">parse-html-macro-lambda-list '<span class="paren2">(<span class="">a b c &amp;attributes attrs</span>)</span></span>)</span><br/>
ATTRS<br/><span class="paren1">(<span class="">A B C</span>)</span><br/></p></pre>

<p>Элемент, следующий за <code>&amp;attributes</code> в списке параметров, также может быть списком параметров.
</p>
<pre class="code"><p>HTML&gt; <span class="paren1">(<span class="">parse-html-macro-lambda-list '<span class="paren2">(<span class="">&amp;attributes <span class="paren3">(<span class="">&amp;key x y</span>)</span> a b c</span>)</span></span>)</span><br/><span class="paren1">(<span class="">&amp;KEY X Y</span>)</span><br/><span class="paren1">(<span class="">A B C</span>)</span><br/></p></pre>

<p>Теперь у вас все готово для написания <code>define-html-macro</code>.  В зависимости от того, были ли указан параметр <code>&amp;attributes</code> вам нужно сгенерировать один или другой из видов HTML макросов, так что главный макрос просто определяет что он должен генерировать, и затем вызывает вспомогательную функцию, которая будет генерировать нужный код.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmac.htm" class="symbol"><i><span class="symbol">defmacro</span></i></a> <i><span class="symbol">define-html-macro</span></i> <span class="paren2">(<span class="">name <span class="paren3">(<span class="">&amp;rest args</span>)</span> &amp;body body</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_multip.htm" class="symbol">multiple-value-bind</a> <span class="paren3">(<span class="">attribute-var args</span>)</span><br/>      <span class="paren3">(<span class="">parse-html-macro-lambda-list args</span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> attribute-var<br/>      <span class="paren4">(<span class="">generate-macro-with-attributes name attribute-var args body</span>)</span><br/>      <span class="paren4">(<span class="">generate-macro-no-attributes name args body</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Функции, которые генерируют соответствующий код выглядят вот так:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> generate-macro-with-attributes <span class="paren2">(<span class="">name attribute-args args body</span>)</span><br/>  <span class="paren2">(<span class=""><i><span class="symbol">with-gensyms</span></i> <span class="paren3">(<span class="">attributes form-body</span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_symbol.htm" class="symbol">symbolp</a> attribute-args</span>)</span> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> attribute-args `<span class="paren5">(<span class="">&amp;rest ,attribute-args</span>)</span></span>)</span></span>)</span><br/>    `<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_eval_w.htm" class="symbol"><i><span class="symbol">eval-when</span></i></a> <span class="paren4">(<span class=""><span class="keyword">:compile-toplevel</span> <span class="keyword">:load-toplevel</span> <span class="keyword">:execute</span></span>)</span><br/>       <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_get.htm" class="symbol">get</a> ',name 'html-macro-wants-attributes</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span><br/>       <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_get.htm" class="symbol">get</a> ',name 'html-macro</span>)</span> <br/>             <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren6">(<span class="">,attributes ,form-body</span>)</span><br/>               <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_destru.htm" class="symbol">destructuring-bind</a> <span class="paren1">(<span class="">,@attribute-args</span>)</span> ,attributes<br/>                 <span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_destru.htm" class="symbol">destructuring-bind</a> <span class="paren2">(<span class="">,@args</span>)</span> ,form-body<br/>                   ,@body</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> generate-macro-no-attributes <span class="paren2">(<span class="">name args body</span>)</span><br/>  <span class="paren2">(<span class=""><i><span class="symbol">with-gensyms</span></i> <span class="paren3">(<span class="">form-body</span>)</span><br/>    `<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_eval_w.htm" class="symbol"><i><span class="symbol">eval-when</span></i></a> <span class="paren4">(<span class=""><span class="keyword">:compile-toplevel</span> <span class="keyword">:load-toplevel</span> <span class="keyword">:execute</span></span>)</span><br/>       <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_get.htm" class="symbol">get</a> ',name 'html-macro-wants-attributes</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span><br/>       <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_get.htm" class="symbol">get</a> ',name 'html-macro</span>)</span><br/>             <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren6">(<span class="">,form-body</span>)</span><br/>               <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_destru.htm" class="symbol">destructuring-bind</a> <span class="paren1">(<span class="">,@args</span>)</span> ,form-body ,@body</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/></span></span></pre>

<p>Функции, которые вы определите, принимают либо один, либо два аргумента, и затем используют <code>DESTRUCTURING-BIND</code> для их разделения, и связывания их с параметрами, определенными в вызове к <code>define-html-macro</code>.  В обоих раскрытиях выражений вам необходимо сохранить макро-функции в списке свойств символа, используя имя свойства равное <code>html-macro</code>, а также логическое значение, указывающее на то, принимает ли макрос параметр <code>&amp;attributes</code>, в свойстве <code>html-macro-wants-attributes</code>.  Вы используете это свойство в следующей функции, <code>expand-macro-form</code>, для того, чтобы определить как макро-функция должна быть запущена:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> expand-macro-form <span class="paren2">(<span class="">form</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_or.htm" class="symbol">or</a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_consp.htm" class="symbol">consp</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_firstc.htm" class="symbol">first</a> form</span>)</span></span>)</span><br/>          <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_get.htm" class="symbol">get</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_firstc.htm" class="symbol">first</a> form</span>)</span> 'html-macro-wants-attributes</span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_multip.htm" class="symbol">multiple-value-bind</a> <span class="paren4">(<span class="">tag attributes body</span>)</span> <span class="paren4">(<span class="">parse-cons-form form</span>)</span><br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_funcal.htm" class="symbol">funcall</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_get.htm" class="symbol">get</a> tag 'html-macro</span>)</span> attributes body</span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_destru.htm" class="symbol">destructuring-bind</a> <span class="paren4">(<span class="">tag &amp;body body</span>)</span> form<br/>      <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_funcal.htm" class="symbol">funcall</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_get.htm" class="symbol">get</a> tag 'html-macro</span>)</span> body</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Нам надо сделать последний шаг для интеграции макросов в наш язык путем добавления соответствующей ветки в  <code>COND</code> в функции <code>process</code>.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> process <span class="paren2">(<span class="">processor form</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_cond.htm" class="symbol"><i><span class="symbol">cond</span></i></a><br/>    <span class="paren3">(<span class=""><span class="paren4">(<span class="">special-form-p form</span>)</span> <span class="paren4">(<span class="">process-special-form processor form</span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><span class="paren4">(<span class="">macro-form-p form</span>)</span>   <span class="paren4">(<span class="">process processor <span class="paren5">(<span class="">expand-macro-form form</span>)</span></span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><span class="paren4">(<span class="">sexp-html-p form</span>)</span>    <span class="paren4">(<span class="">process-sexp-html processor form</span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_consp.htm" class="symbol">consp</a> form</span>)</span>          <span class="paren4">(<span class="">embed-code processor form</span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a>                     <span class="paren4">(<span class="">embed-value processor form</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Это окончательная версия <code>process</code>.
</p>
</div><div class="chapter" id="&#x41F;&#x443;&#x431;&#x43B;&#x438;&#x447;&#x43D;&#x44B;&#x439; &#x438;&#x43D;&#x442;&#x435;&#x440;&#x444;&#x435;&#x439;&#x441; &#x440;&#x430;&#x437;&#x440;&#x430;&#x431;&#x43E;&#x442;&#x447;&#x438;&#x43A;&#x430; (API)"><h3>Публичный интерфейс разработчика (API)</h3>

<p>Теперь вы готовы к реализации макроса <code>html</code> – основной точке входа компилятора FOO. Другими частями публичного интерфейса разработчика являются <code>emit-html</code> и <code>with-html-output</code>, которые мы обсуждали в предыдущей главе, и <code>define-html-macro</code>, которую мы обсуждали в предыдущем разделе. Макрос <code>define-html-macro</code> должен быть частью интерфейса разработчика, поскольку пользователи FOO захотят писать свои собственные макросы. С другой стороны, <code>define-html-special-operator</code> не является частью интерфейса, поскольку он требует слишком глубоко знания внутреннего устройства FOO для определения нового специального оператора. И должно быть очень мало вещей которые не смогут быть сделаны при наличии существующих возможностей языка и специальных операторов.<a class="fn_top" id="fnt__4" href="practical-an-html-generation-library-the-compiler#fn__4">4)</a>
</p>
<p>Последним элементом публичного интерфейса, который мы рассмотрим до <code>html</code>, является еще один макрос – <code>in-html-style</code>.  Этот макрос контролирует то, должен ли FOO генерировать XHTML или простой HTML путем установки переменной <code>*xhtml*</code>.  Причиной того, что вам нужен макрос, является то, что вы можете захотеть обернуть код, который устанавливает <code>*xhtml*</code> в <code>EVAL-WHEN</code>, так что вы можете установить его в файл, и это будет влиять на поведение макроса <code>html</code> находящегося в том же файле.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmac.htm" class="symbol"><i><span class="symbol">defmacro</span></i></a> in-html-style <span class="paren2">(<span class="">syntax</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_eval_w.htm" class="symbol"><i><span class="symbol">eval-when</span></i></a> <span class="paren3">(<span class=""><span class="keyword">:compile-toplevel</span> <span class="keyword">:load-toplevel</span> <span class="keyword">:execute</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_case_.htm" class="symbol">case</a> syntax<br/>      <span class="paren4">(<span class=""><span class="keyword">:html</span> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="special">*xhtml*</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span></span>)</span><br/>      <span class="paren4">(<span class=""><span class="keyword">:xhtml</span> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="special">*xhtml*</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>И в заключение, давайте рассмотрим <code>html</code>.  Единственная нестандартность в реализации <code>html</code> возникает из необходимости генерировать код, который будет использоваться для генерации и компактного, и "красивого" FIXME pretty вывода, в зависимости от значения переменной <code>*pretty*</code> во время выполнения.  Таким образом в <code>html</code> требуется генерировать раскрытие, которое будет содержать выражение <code>IF</code>и две версии кода – одну скомпилированную с  <code>*pretty*</code> равным истине, и одну – для значения переменной равной <code>NIL</code>.  Также составляет сложность то, что достаточно часто один вызов <code>html</code> содержит вложенные вызовы <code>html</code>, например вот так:
</p>
<pre class="code"><span class="paren1">(<span class="">html <span class="paren2">(<span class=""><span class="keyword">:ul</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_dolist.htm" class="symbol">dolist</a> <span class="paren4">(<span class="">item stuff</span>)</span></span>)</span> <span class="paren3">(<span class="">html <span class="paren4">(<span class=""><span class="keyword">:li</span> item</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Если внешний вызов <code>html</code> раскрывается в выражение <code>IF</code> с двумя версиями кода, одним для случая, когда переменная <code>*pretty*</code> имеет истинное значение, и вторым, когда она имеет ложное, то будет глупо, если вложенные выражения <code>html</code> также будут раскрываться в две версии.  В действительности это будет вести к экспоненциальному росту кода, поскольку вложенные <code>html</code> уже будут раскрыты дважды – один раз для ветви <code>*pretty*-is-true</code>, и один раз для ветви <code>*pretty*-is-false</code>.  Если каждое из раскрытий сгенерирует две версии, то вы будете иметь 4 версии кода.  А если вложенное выражение <code>html</code> содержит еще одно вложенное выражение <code>html</code>, то вы получите восемь версий.  Если компилятор достаточно умен, то он может распознать, что большая часть кода не будет использована, и удалит ее, но распознание таких ситуаций займет достаточно большое время, замедляя компиляцию любой функции, которая использует вложенные вызовы <code>html</code>.
</p>
<p>К счастью вы можете легко избежать это разрастание ненужного кода путем генерации раскрытия, которое локально переопределяет макрос  <code>html</code> используя <code>MACROLET</code>, для того, чтобы генерировать только нужный вид кода.  Сначала вы определяете вспомогательную функцию, которая получает вектор кодов операций, возвращаемы <code>sexp-&gt;ops</code> и прогоняет его через функции <code>optimize-static-output</code> и <code>generate-code</code> (две стадии, на которые влияет значение переменной <code>*pretty*</code>) с переменной <code>*pretty*</code> установленной в нужное значение, и затем собирает результирующий код в <code>PROGN</code>. (<code>PROGN</code> возвращает  <code>NIL</code> лишь для унификации результатов.).
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> codegen-html <span class="paren2">(<span class="">ops pretty</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class=""><span class="special">*pretty*</span> pretty</span>)</span></span>)</span><br/>    `<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_progn.htm" class="symbol"><i><span class="symbol">progn</span></i></a> ,@<span class="paren4">(<span class="">generate-code <span class="paren5">(<span class="">optimize-static-output ops</span>)</span></span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span></span>)</span></span>)</span><br/></pre>

<p>Используя эту функцию, вы можете определить <code>html</code> следующим образом:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmac.htm" class="symbol"><i><span class="symbol">defmacro</span></i></a> html <span class="paren2">(<span class="">&amp;whole whole &amp;body body</span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_declar.htm" class="symbol">declare</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/d_ignore.htm" class="symbol">ignore</a> body</span>)</span></span>)</span><br/>  `<span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="special">*pretty*</span><br/>     <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_flet_.htm" class="symbol"><i><span class="symbol">macrolet</span></i></a> <span class="paren4">(<span class=""><span class="paren5">(<span class="">html <span class="paren6">(<span class="">&amp;body body</span>)</span> <span class="paren6">(<span class="">codegen-html <span class="paren1">(<span class="">sexp-&gt;ops body</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span></span>)</span></span>)</span><br/>       <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren5">(<span class=""><span class="paren6">(<span class=""><span class="special">*html-pretty-printer*</span> <span class="paren1">(<span class="">get-pretty-printer</span>)</span></span>)</span></span>)</span> ,whole</span>)</span></span>)</span><br/>     <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_flet_.htm" class="symbol"><i><span class="symbol">macrolet</span></i></a> <span class="paren4">(<span class=""><span class="paren5">(<span class="">html <span class="paren6">(<span class="">&amp;body body</span>)</span> <span class="paren6">(<span class="">codegen-html <span class="paren1">(<span class="">sexp-&gt;ops body</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span></span>)</span></span>)</span><br/>       ,whole</span>)</span></span>)</span></span>)</span><br/></pre>

<p>Параметр <code>&amp;whole</code> представляет оригинальное выражение <code>html</code>, и поскольку он интерполируется в раскрытие в теле двух <code>MACROLET</code>, то он будет обрабатываться с каждым из определений <code>html</code> – для кода, выдающий "красивый" и обычный результат.  Заметьте, что переменная <code>*pretty*</code> используется и при раскрытии макроса и при выполнении сгенерированного кода.  Она используется при раскрытии макроса в <code>codegen-html</code> для того, чтобы заставить <code>generate-code</code> генерировать нужный вид кода.  И она используется во время выполнения в выражении <code>IF</code> сгенерированном макросом <code>html</code> самого верхнего уровня, для того, чтобы определить, какая из ветвей – <code>pretty-printing</code> и <code>non-pretty-printing</code> будет выполнена.
</p>
</div><div class="chapter" id="&#x41A;&#x43E;&#x43D;&#x435;&#x446; &#x440;&#x430;&#x431;&#x43E;&#x442;&#x44B;"><h3>Конец работы</h3>

<p>Как обычно, вы можете продолжить работу над этим кодом для расширения его функциональности.  Одной из интересных задач может быть использование системы генерации вывода для создания других видов выходных данных.  В реализации FOO, которую вы можете скачать с сайта посвященного книге, вы можете найти код, который реализует вывод CSS, который может быть интегрирован в HTML, и в компиляторе и в интерпретаторе.  Это интересный случай, поскольку синтаксис CSS не может быть также просто отображен в s-выражения, как это можно сделать для HTML.  Однако, если вы посмотрите в этот код, то вы увидите, что все равно возможно определить синтаксис, основанный на s-выражениях, для представления разных конструкций, доступных в CSS.
</p>
<p>Более амбициозной задачей будет добавление поддержки генерации JavaScript.  При правильном подходе, добавление поддержки JavaScript в FOO может привести к двум большим победам.  Во первых, если вы определите синтаксис, основанный на s-выражениях, так что вы сможете отобразить его на синтаксис JavaScript, то вы сможете начать писать макросы (на Common Lisp) для добавления новых конструкций к языку, который вы используете для написания кода, исполняемого на стороне пользователя, который затем будет компилироваться в JavaScript. Во вторых, при переводе s-выражений FOO с поддержкой JavaScript в обычный JavaScript, вы можете столкнуться небольшими, но раздражающими различиями в реализации JavaScript в разных браузерах.  Так что код JavaScript генерируемый FOO либо может содержать соответствующие условия для выполнения одних операций в одном браузере, и других в другом браузере, либо может генерировать разный код в зависимости то того, какой браузер вы хотите поддерживать.  Так что, если вы используете FOO в динамически генерируемых страницах, то вы можете использовать информацию из заголовка <code>User-Agent</code>, заставляя функцию <code>request</code> генерировать правильный код JavaScript для конкретного браузера.
</p>
<p>Но если это вас интересует, то вы можете это реализовать сами, поскольку это конец последней практической главы данной книги.  В следующей главе я подведу итоги, сделаю короткий обзор некоторых тем, которые я не затрагивал в этой книги, такие как искать библиотеки, как оптимизовывать код на Common Lisp, и как распространять приложения на Lisp.
</p></div></div><div class="footnotes"><div><a class="fn_bot" id="fn__1" href="practical-an-html-generation-library-the-compiler#fnt__1">1)</a>Аналогия между специальными операторами и макросами FOO, которые я буду обсуждать в следующем разделе, и этими же вещами в Lisp является красивым звуком (FIXME is fairly sound).  В действительности, понимание того, как работают специальные операторы и макросы FOO, могут дать вам некоторое представление о том, почему  Common Lisp объединил их именно таким образом.</div><div><a class="fn_bot" id="fn__2" href="practical-an-html-generation-library-the-compiler#fnt__2">2)</a><code>:noescape</code> и <code>:attribute</code> должны быть определены как специальные операторы, поскольку FOO определяет список маскируемых символов во время компиляции, а не во время выполнения.  Это позволяет FOO выполнять маскирование строк во время компиляции, что более эффективно по сравнению с проверкой всего вывода во время выполнения.</div><div><a class="fn_bot" id="fn__3" href="practical-an-html-generation-library-the-compiler#fnt__3">3)</a>Заметьте, что <code>&amp;attributes</code> это лишь обычный символ, нет ничего специального в символах, чьи имена начинаются с <code>&amp;</code>.</div><div><a class="fn_bot" id="fn__4" href="practical-an-html-generation-library-the-compiler#fnt__4">4)</a>Одним из элементов, который в настоящее время не доступен через специальный оператор – это расстановка отступов.  Если вы захотите сделать FOO более гибким, хотя и ценой того, что его интерфейс разработчика будет более сложным, вы можете добавить специальный оператор, который будет управлять расстановкой отступов.  Но кажется, что цена того, что потребуется объяснять наличие дополнительных операторов, будет перевешивать относительно небольшое преимущество в выразительности.</div></div></div> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="practical-an-html-generation-library-the-interpreter">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right">  </td> </tr> </tbody> </table> </div> <div class="bottom">@2009-2013 lisper.ru</div> 
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7734690-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
 </body> </html>