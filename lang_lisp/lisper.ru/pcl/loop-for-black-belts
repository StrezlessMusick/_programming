<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru"> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <meta name="keywords" content="Common Lisp,lisp,лисп" /> <title>LOOP для мастеров с чёрным поясом</title> <link href="../css/style.css" rel="stylesheet" type="text/css" /><link href="../css/colorize.css" rel="stylesheet" type="text/css" />  </head> <body> <div class="top"> <div id="login"> <a href="http://lisper.ru/register">Регистрация</a> | <a href="http://lisper.ru/login?done=/pcl/loop-for-black-belts">Войти</a> </div> </div> <div id="caution"> <img alt="Lisp — программируемый язык программирования" src="../image/gecko.png" /> <a href="http://www.vkusnoserver.ru/" target="_blank" style="float: right;"> <img src="../vkusnoserver.png" /> </a> </div> <div id="mainmenu"> <ul> <li> <a href="http://lisper.ru/">Главная</a> </li><li> <a href="http://lisper.ru/articles/">Статьи</a> </li><li> <a href="http://lisper.ru/planet/">Планета</a> </li><li> <a href="http://lisper.ru/forum/">Форум</a> </li><li> <a href="http://lisper.ru/apps/">Сервисы</a> </li><li> <a href="index.html">Practical Common Lisp</a> </li><li> <a href="http://lisper.ru/wiki/">Wiki</a> </li><li> <a href="http://lisper.ru/files/">Файлы</a> </li><li> <a href="http://lisper.ru/search">Поиск</a> </li> </ul> </div> <div id="content"> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="programming-in-the-large-packages-and-symbols">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right"> <a href="practical-a-spam-filter">Следующая</a> </td> </tr> </tbody> </table> <div class="article"><div class="toc"><div class="toc-header">Содержание</div><div class="toc-body"><ul><li><div><a href="loop-for-black-belts#22. LOOP &#x434;&#x43B;&#x44F; &#x43C;&#x430;&#x441;&#x442;&#x435;&#x440;&#x43E;&#x432; &#x441; &#x447;&#x435;&#x440;&#x43D;&#x44B;&#x43C; &#x43F;&#x43E;&#x44F;&#x441;&#x43E;&#x43C;.">22. LOOP для мастеров с черным поясом.</a><ul><li><div><a href="loop-for-black-belts#&#x427;&#x430;&#x441;&#x442;&#x438; LOOP">Части LOOP</a></div></li><li><div><a href="loop-for-black-belts#&#x423;&#x43F;&#x440;&#x430;&#x432;&#x43B;&#x435;&#x43D;&#x438;&#x435; &#x438;&#x442;&#x435;&#x440;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435;&#x43C;">Управление итерированием</a></div></li><li><div><a href="loop-for-black-belts#&#x41F;&#x43E;&#x434;&#x441;&#x447;&#x438;&#x442;&#x44B;&#x432;&#x430;&#x44E;&#x449;&#x438;&#x435; &#x446;&#x438;&#x43A;&#x43B;&#x44B; (Counting Loops)">Подсчитывающие циклы (Counting Loops)</a></div></li><li><div><a href="loop-for-black-belts#&#x41E;&#x440;&#x433;&#x430;&#x43D;&#x438;&#x437;&#x430;&#x446;&#x438;&#x44F; &#x446;&#x438;&#x43A;&#x43B;&#x43E;&#x432; &#x43F;&#x43E; &#x43A;&#x43E;&#x43B;&#x43B;&#x435;&#x43A;&#x446;&#x438;&#x44F;&#x43C; &#x438; &#x43F;&#x430;&#x43A;&#x435;&#x442;&#x430;&#x43C;">Организация циклов по коллекциям и пакетам</a></div></li><li><div><a href="loop-for-black-belts#Equals-Then &#x438;&#x442;&#x435;&#x440;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435;">Equals-Then итерирование</a></div></li><li><div><a href="loop-for-black-belts#&#x41B;&#x43E;&#x43A;&#x430;&#x43B;&#x44C;&#x43D;&#x44B;&#x435; &#x43F;&#x435;&#x440;&#x435;&#x43C;&#x435;&#x43D;&#x43D;&#x44B;&#x435;">Локальные переменные</a></div></li><li><div><a href="loop-for-black-belts#&#x414;&#x435;&#x441;&#x442;&#x440;&#x443;&#x43A;&#x442;&#x443;&#x440;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435; &#x43F;&#x435;&#x440;&#x435;&#x43C;&#x435;&#x43D;&#x43D;&#x44B;&#x445;">Деструктурирование переменных</a></div></li><li><div><a href="loop-for-black-belts#&#x41D;&#x430;&#x43A;&#x43E;&#x43F;&#x43B;&#x435;&#x43D;&#x438;&#x435; &#x437;&#x43D;&#x430;&#x447;&#x435;&#x43D;&#x438;&#x44F;">Накопление значения</a></div></li><li><div><a href="loop-for-black-belts#&#x411;&#x435;&#x437;&#x443;&#x441;&#x43B;&#x43E;&#x432;&#x43D;&#x43E;&#x435; &#x432;&#x44B;&#x43F;&#x43E;&#x43B;&#x43D;&#x435;&#x43D;&#x438;&#x435;">Безусловное выполнение</a></div></li><li><div><a href="loop-for-black-belts#&#x423;&#x441;&#x43B;&#x43E;&#x432;&#x43D;&#x43E;&#x435; &#x432;&#x44B;&#x43F;&#x43E;&#x43B;&#x43D;&#x435;&#x43D;&#x438;&#x435;">Условное выполнение</a></div></li><li><div><a href="loop-for-black-belts#&#x41D;&#x430;&#x447;&#x430;&#x43B;&#x44C;&#x43D;&#x44B;&#x435; &#x443;&#x441;&#x442;&#x430;&#x43D;&#x43E;&#x432;&#x43A;&#x438; &#x438; &#x43F;&#x43E;&#x434;&#x44B;&#x442;&#x43E;&#x436;&#x438;&#x432;&#x430;&#x43D;&#x438;&#x435;">Начальные установки и подытоживание</a></div></li><li><div><a href="loop-for-black-belts#&#x41A;&#x440;&#x438;&#x442;&#x435;&#x440;&#x438;&#x438; &#x437;&#x430;&#x432;&#x435;&#x440;&#x448;&#x435;&#x43D;&#x438;&#x44F;">Критерии завершения</a></div></li><li><div><a href="loop-for-black-belts#&#x421;&#x43B;&#x43E;&#x436;&#x438;&#x43C; &#x432;&#x441;&#x435; &#x432;&#x43C;&#x435;&#x441;&#x442;&#x435;">Сложим все вместе</a></div></li></ul></div></li></ul></div></div>
<div class="chapter" id="22. LOOP &#x434;&#x43B;&#x44F; &#x43C;&#x430;&#x441;&#x442;&#x435;&#x440;&#x43E;&#x432; &#x441; &#x447;&#x435;&#x440;&#x43D;&#x44B;&#x43C; &#x43F;&#x43E;&#x44F;&#x441;&#x43E;&#x43C;."><h3>22. LOOP для мастеров с черным поясом.</h3>


<p>В главе 7 я кратко описал расширенный макрос <strong>LOOP</strong>. Как я упоминал тогда, <strong>LOOP</strong> по существу предоставляет язык специального назначения для написания конструкций итерирования.
</p>
<p>Это может показаться весьма хлопотным: изобретение целого языка лишь для написания циклов. Но, если вы задумаетесь о способах использования циклов в программах, эта идея действительно станет обретать смысл. Любая программа любого размера всегда будет содержать циклы. И хотя все они не будут одинаковыми, они также не будут и совершенно различными; при детальном рассмотрении будут выделены образцы (в частности, если включать в них код непосредственно предшествующий и следующий за циклами): образцы инициализации перед циклом, образцы действий внутри цикла и образцы действий после завершения цикла. Язык <strong>LOOP</strong> фиксирует эти образцы, так что вы можете выражать их явно.
</p>
<p>Макрос <strong>LOOP</strong> имеет множество частей: одной из главных претензий противников <strong>LOOP</strong> является то, что он слишком сложен. В этой главе я покажу, что это не так, дав вам систематическое описание различных частей <strong>LOOP</strong> и того, как эти части использовать вместе.
</p>



<div class="chapter" id="&#x427;&#x430;&#x441;&#x442;&#x438; LOOP"><h3>Части LOOP</h3>


<p>Вы можете делать в <strong>LOOP</strong> следующее:
</p><ul><li> Итерировать переменную численно или по различным структурам данных.</li><li> Собирать, подсчитывать, суммировать, искать максимальное и минимальное значения по данным, просматриваемым во время цикла.</li><li> Выполнять произвольные выражения Lisp.</li><li> Решать, когда остановить цикл.</li><li> Осуществлять определенные действия при заданных условиях.</li></ul>
<p>Вдобавок, <strong>LOOP</strong> предоставляет синтакс для следующего:
</p><ul><li> Создание локальных переменных для использования внутри цикла.</li><li> Задание произвольных выражений Lisp для выполнения перед и после цикла.</li></ul>
<p>Базовой структурой <strong>LOOP</strong> является набор предложений (<em>clauses</em>), каждое их которых начинается с <em>ключевого слова loop</em><a class="fn_top" id="fnt__1" href="loop-for-black-belts#fn__1">1)</a>. То, как каждое предложение анализируется макросом <strong>LOOP</strong>, зависит от такого ключевого слова. Некоторые из главных ключевых слов, которые вы видели в главе 7, следующие: for, collecting, summing, counting, do и finally.
</p>



</div><div class="chapter" id="&#x423;&#x43F;&#x440;&#x430;&#x432;&#x43B;&#x435;&#x43D;&#x438;&#x435; &#x438;&#x442;&#x435;&#x440;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435;&#x43C;"><h3>Управление итерированием</h3>


<p>Большинство из так называемых предложений управления итерированием начинаются с ключевого слова loop <code>for</code> или его синонима <code>as</code><a class="fn_top" id="fnt__2" href="loop-for-black-belts#fn__2">2)</a>, за которыми следует имя переменной. Что следует за именем переменной, зависит от типа предложения <code>for</code>.
</p>
<p>Подвыражения (subclauses) предложений <code>for</code> могут итерировать по следующему:</p><ul><li> Численные интервалы, вверх или вниз.</li><li> Отдельные элементы списка.</li><li> cons-ячейки, составляющие список.</li><li> Элементы вектора, включая подтипы, такие как строки и битовые векторы.</li><li> Пары хэш-таблицы.</li><li> Символы пакета.</li><li> Результаты повторных вычислений заданной формы.</li></ul>
<p>Одиночный цикл может содержать несколько предложений <code>for</code>, каждое из которых именует собственную переменную. Если цикл содержит несколько предложений <code>for</code>, он завершается как только любое из них достигает своего условия завершения. Например, следующий цикл:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a><br/>  for item in <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a><br/>  for i from 1 to 10<br/>  <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren2">(<span class="">something</span>)</span></span>)</span><br/></pre>

<p>выполнится максимум 10 раз, но может завершиться и раньше, если список содержим менее десяти элементов.
</p>



</div><div class="chapter" id="&#x41F;&#x43E;&#x434;&#x441;&#x447;&#x438;&#x442;&#x44B;&#x432;&#x430;&#x44E;&#x449;&#x438;&#x435; &#x446;&#x438;&#x43A;&#x43B;&#x44B; (Counting Loops)"><h3>Подсчитывающие циклы (Counting Loops)</h3>


<p>Предложения арифметического итерирования управляют числом раз, которое будет выполнено тело цикла, путем изменения переменной в пределах интервала чисел, выполняя тело на каждом шаге. Такие предложения состоят из от одного до трех следующих <em>предложных оборотов</em> (<em>prepositional phrases</em>), идущих после <code>for</code> (или <code>as</code>): оборот <em>откуда</em> (<em>from where</em>), оборот <em>докуда</em> (<em>to where</em>) и оборот <em>по сколько</em> (<em>by how much</em>).
</p>
<p>Оборот <em>откуда</em> задает начальное значение для переменной предложения. Он состоит из одного из предлогов (prepositions) <code>from</code>, <code>downfrom</code> или <code>upfrom</code>, за которыми следует форма, предоставляющая начальное значение (число).
</p>
<p>Оборот <em>докуда</em> задает точку останова цикла и состоит из одного из предлогов <code>to</code>, <code>upto</code>, <code>below</code>, <code>downto</code> или <code>above</code>, за которыми следует форма, предоставляющая точку останова. С <code>upto</code> и <code>downto</code> цикл завершится (без выполнения тела) когда переменная перейдет точку останова; с <code>below</code> и <code>above</code> он завершится на итерацию ранее. 
</p>
<p>Оборот <em>по сколько</em> состоит из предлога <code>by</code> и формы, которая должна вычисляться в положительное число. Переменная будет изменяться (вверх или вниз, что определяется другими оборотами) на эту величину на каждой итерации, или на единицу, если оборот опущен.
</p>
<p>Вы должны задать по меньшей мере один из этих предложных оборотов. По умолчанию цикл начинается с нуля, переменная на каждой итерации увеличивается на единицу, и цикл продолжается вечно, или, более точно, пока другое предложение не остановит цикл. Вы можете изменить любое из этих умолчаний путем добавления соответствующего предложного оборота. Единственным неудобством является то, что если вы хотите декрементный цикл, не существует значения <em>откуда</em> по умолчанию, поэтому вы должны явно указать его с помощью <code>from</code> или <code>downfrom</code>. Таким образом, следующее:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i upto 10 collect i</span>)</span><br/></pre>

<p>накапливает первые одиннадцать целых чисел (с нуля до десяти), но поведение этого:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i downto -10 collect i</span>)</span>         ; неверно<br/></pre>

<p>не определено. Вместо этого вам нужно написать так:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i from 0 downto -10 collect i</span>)</span><br/></pre>

<p>Также заметьте что, так как <strong>LOOP</strong> является макросом, который запускается во время компиляции, то он может определить направление изменения переменной только по предлогам, но не по зрачениям форм, которые не могут быть известны до времени выполнения. Поэтому следующее:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i from 10 to 20 ...</span>)</span> <br/></pre>

<p>работает хорошо, используя значение приращения по умолчанию. Но это:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i from 20 to 10 ...</span>)</span><br/></pre>

<p>не знает, что нужно считать от двадцати до десяти. Хуже того, это выражение не выдаст вам никакой ошибки: оно просто не выполнит цикл, так как i уже больше десяти. Вместо этого вы должны написать так:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i from 20 downto 10 ...</span>)</span><br/></pre>

<p>или так:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i downfrom 20 to 10 ...</span>)</span><br/></pre>

<p>Наконец, если вам просто нужен цикл, повторяющийся определенное число раз, вы можете заменить предложение следующей формы:
</p>
<pre class="code"><p>for i from 1 to number-form<br/></p></pre>

<p>на предложение <code>repeat</code> следующего вида:
</p>
<pre class="code"><p>repeat number-form<br/></p></pre>

<p>Эти предложения идентичны по своему действию, за исключением того, что предложение <code>repeat</code> не создает явной переменной цикла.
</p>



</div><div class="chapter" id="&#x41E;&#x440;&#x433;&#x430;&#x43D;&#x438;&#x437;&#x430;&#x446;&#x438;&#x44F; &#x446;&#x438;&#x43A;&#x43B;&#x43E;&#x432; &#x43F;&#x43E; &#x43A;&#x43E;&#x43B;&#x43B;&#x435;&#x43A;&#x446;&#x438;&#x44F;&#x43C; &#x438; &#x43F;&#x430;&#x43A;&#x435;&#x442;&#x430;&#x43C;"><h3>Организация циклов по коллекциям и пакетам</h3>


<p>Предложения <code>for</code> для итерирования по спискам гораздо проще, чем арифметические предложения. Они поддерживают только два предложных оборота: <code>in</code> и <code>on</code>.
</p>
<p>Оборот такой формы:
</p>
<pre class="code"><p>for var in list-form<br/></p></pre>

<p>итерирует переменную по всем элементам списка, являющегося результатом вычисления <em>list-form</em>.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i in <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> 10 20 30 40</span>)</span> collect i</span>)</span> ==&gt; <span class="paren1">(<span class="">10 20 30 40</span>)</span><br/></pre>

<p>Иногда это предложение дополняется оборотом <code>by</code>, который задает функцию для продвижения по списку. Значением по умолчанию является <strong>CDR</strong>, но можно использовать любую функцию, принимающую список и возвращающую подсписок. Например, вы можете накапливать каждый второй элемент списка с помощью loop следующим образом:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i in <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> 10 20 30 40</span>)</span> by #'<a href="http://www.lispworks.com/reference/HyperSpec/Body/f_car_c.htm" class="symbol">cddr</a> collect i</span>)</span> ==&gt; <span class="paren1">(<span class="">10 30</span>)</span><br/></pre>

<p>Предложный оборот <code>on</code> используется для итерирования по cons-ячейкам, составляющим список.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for x on <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> 10 20 30</span>)</span> collect x</span>)</span> ==&gt; <span class="paren1">(<span class=""><span class="paren2">(<span class="">10 20 30</span>)</span> <span class="paren2">(<span class="">20 30</span>)</span> <span class="paren2">(<span class="">30</span>)</span></span>)</span><br/></pre>

<p>Этот оборот также принимает предлог <code>by</code>:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for x on <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> 10 20 30 40</span>)</span> by #'<a href="http://www.lispworks.com/reference/HyperSpec/Body/f_car_c.htm" class="symbol">cddr</a> collect x</span>)</span> ==&gt; <span class="paren1">(<span class=""><span class="paren2">(<span class="">10 20 30 40</span>)</span> <span class="paren2">(<span class="">30 40</span>)</span></span>)</span><br/></pre>

<p>Итерирование по элементам вектора (что включает строки и битовые векторы) подобно итерированию по элементам списка, за исключением использования предлога <code>across</code> вместо <code>in</code><a class="fn_top" id="fnt__3" href="loop-for-black-belts#fn__3">3)</a>. Например:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for x across <span class="string">"abcd"</span> collect x</span>)</span> ==&gt; <span class="paren1">(<span class=""><span class="character">#\a</span> <span class="character">#\b</span> <span class="character">#\c</span> <span class="character">#\d</span></span>)</span><br/></pre>

<p>Итерирование по хэш-таблице или пакету немного более сложно, так как хэш-таблицы и пакеты содержат различные множества значений, по которым вы можете захотеть итерировать: ключи или значения в хэш-таблице или различные виды символов в пакете. Оба вида итерирования следуют сходному образцу, который в базовом виде выглядит так:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for var being <a href="http://www.lispworks.com/reference/HyperSpec/Body/s_the.htm" class="symbol"><i><span class="symbol">the</span></i></a> things in hash-or-package ...</span>)</span><br/></pre>

<p>Для хэш-таблиц возможными значениями для <em>things</em> являются <code>hash-keys</code> и <code>hash-values</code>, означающие, что <code>var</code> будет связываться с последовательными значениями ключей или самими значениями хэш-таблицы, соответственно. Форма <em>hash-or-package</em> вычисляется лишь один раз для получения значения, которое должно быть хэш-таблицей.
</p>
<p>Для итерирования по пакету <em>things</em> может быть <code>symbols</code>, <code>present-symbols</code> и <code>external-symbols</code>, и <em>var</em> будет связываться с каждым символом, доступным в пакете, каждым символом, присутствующем в пакете (другими словами, интернированным или импортированным в этот пакет), или с каждым символом, экспортированным из пакета, соответственно. Форма <em>hash-or-package</em> вычисляется для предоставления имени пакета, который будет искаться как с помощью <strong>FIND-PACKAGE</strong>, или объекта пакета. Для частей предложения <code>for</code> также доступны синонимы. На месте <code>the</code> вы можете использовать <code>each</code>, вместо <code>in</code> – <code>of</code>, а также <em>things</em> можно записывать в единственном числе (например, <code>hash-key</code> или <code>symbol</code>).
</p>
<p>И наконец, так как часто при итерировании по хэш-таблицам нужны и ключи, и сами значения, предложения для хэш-таблиц поддерживают использование специального <code>using</code>-подпредложения.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for k being <a href="http://www.lispworks.com/reference/HyperSpec/Body/s_the.htm" class="symbol"><i><span class="symbol">the</span></i></a> hash-keys in h using <span class="paren2">(<span class="">hash-value v</span>)</span> ...</span>)</span><br/><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for v being <a href="http://www.lispworks.com/reference/HyperSpec/Body/s_the.htm" class="symbol"><i><span class="symbol">the</span></i></a> hash-values in h using <span class="paren2">(<span class="">hash-key k</span>)</span> ...</span>)</span><br/></pre>

<p>Оба этих цикла будут связывать <code>k</code> с каждым ключем в хэш-таблице, а <code>v</code> – с соответствующим значением. Обратите внимание, что первый элемент <code>using</code>-подпредложения должен быть записан в единственном числе<a class="fn_top" id="fnt__4" href="loop-for-black-belts#fn__4">4)</a>.
</p>



</div><div class="chapter" id="Equals-Then &#x438;&#x442;&#x435;&#x440;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435;"><h3>Equals-Then итерирование</h3>


<p>Если ни одно из остальных предложений <code>for</code> не предоставляет именно ту форму итерирования переменной, которая вам нужна, вы можете получить полный контроль над итерированием, используя предложение <em>equals-then</em>. Это предложение подобно связывающим предложениям (binding clauses) в циклах <strong>DO</strong>, преведенных к более Algol-подобному синтаксису. Образец использования следующий:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for var = initial-value-form [ then step-form ] ...</span>)</span><br/></pre>

<p>Как обычно, <em>var</em> – имя итерируемой переменной. Ее начальное значение получается путем однократного вычисления <em>initial-value-form</em> перед первой итерацией. На каждой последующей итерации вычисляется <em>step-form</em> и ее значение становится новым значением <em>var</em>. В отсутствие <code>then</code>-части предложения <em>initial-value-form</em> перевычисляется на каждой итерации для предоставления нового значения. Заметьте, что это отличается от связывающего проедложения <strong>DO</strong> без step-формы.
</p>
<p><em>step-form</em> может ссылать на другие переменные loop, включая переменные, созданные другими предложениями <code>for</code> цикла loop. Например:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> repeat 5 <br/>      for x = 0 then y<br/>      for y = 1 then <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> x y</span>)</span><br/>      collect y</span>)</span> ==&gt; <span class="paren1">(<span class="">1 2 4 8 16</span>)</span><br/></pre>

<p>Заметьте, однако, что каждое предложение <code>for</code> вычисляется отдельно в порядке своего появления. Поэтому в предыдущем цикле на второй итерации <code>x</code> устанавливается в значение <code>y</code> до того, как <code>y</code> изменится (другими словами, в 1). Но <code>y</code> затем устанавливает в значение суммы своего старого значения (все еще 1) и нового значения <code>x</code>. Если порядок предложений <code>for</code> изменить, результат изменится.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> repeat 5<br/>      for y = 1 then <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> x y</span>)</span><br/>      for x = 0 then y<br/>      collect y</span>)</span> ==&gt; <span class="paren1">(<span class="">1 1 2 4 8</span>)</span><br/></pre>

<p>Часто, однако, вам нужно, чтобы step-формы для нескольких переменных были вычислены перед тем, как любая из этих переменных получит свое новое значение (подобно тому как это происходит в <strong>DO</strong>). В этом случае вы можете объединить несколько предложений <code>for</code>, заменив все кроме первого <code>for</code> на <code>and</code>. Вы уже видели такую запись в <strong>LOOP</strong>-версии вычисления чисел Фиббоначи в главе 7. Вот другой вариант, основанный на двух предыдущих примерах:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> repeat 5 <br/>      for x = 0 then y<br/>      <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_and.htm" class="symbol">and</a> y = 1 then <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_pl.htm" class="symbol">+</a> x y</span>)</span><br/>      collect y</span>)</span> ==&gt; <span class="paren1">(<span class="">1 1 2 3 5</span>)</span><br/></pre>




</div><div class="chapter" id="&#x41B;&#x43E;&#x43A;&#x430;&#x43B;&#x44C;&#x43D;&#x44B;&#x435; &#x43F;&#x435;&#x440;&#x435;&#x43C;&#x435;&#x43D;&#x43D;&#x44B;&#x435;"><h3>Локальные переменные</h3>


<p>В то время как главные переменные, необходимые внутри цикла, обычно явно объявляются в предложениях <code>for</code>, иногда вам понадобятся вспомогательные переменные, которые вы можете объявить с помощью предложений <code>with</code>.
</p>
<pre class="code"><p>with var [ = value-form ]<br/></p></pre>

<p>Имя <em>var</em> станет именем локальной переменной, которая перестанет существовать после завершения цикла. Если предложение <code>with</code> содержит часть <code>= value-form</code>, то перед первой итерацией цикла переменная будет проинициализирована значением <em>value-form</em>.
</p>
<p>В loop может быть несколько предложений <code>with</code>; каждое предложение вычисляется независимо в порядке их появления, и значение присваивается перед началом обработки следующего предложения, что позволяет последующим переменным зависеть от значения уже объявленных переменных. Взаимно независимые переменные могут быть объявлены в одном предложении <code>with</code> с использованием <code>and</code> между такими декларациями.
</p>



</div><div class="chapter" id="&#x414;&#x435;&#x441;&#x442;&#x440;&#x443;&#x43A;&#x442;&#x443;&#x440;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435; &#x43F;&#x435;&#x440;&#x435;&#x43C;&#x435;&#x43D;&#x43D;&#x44B;&#x445;"><h3>Деструктурирование переменных</h3>


<p>Очень удобной возможностью <strong>LOOP</strong>, о которой я ранее не упоминал, является возможность деструктурирования списковых значений, присваемых переменным цикла. Это позволяет разбирать на части значение списков, которые иначе присваивались бы переменной цикла, подобно тому, как работает <strong>DESTRUCTURING-BIND</strong>, но немного более простым способом. В общем, вы можете заменить любую переменную цикла в предложениях <code>for</code> или <code>with</code> деревом символов, и списковое значение, которое было бы присвоено простой переменной, будет деструктурировано на переменные, именованные символами дерева. Простой пример выглядит следующим образом:
</p><pre>CL-USER&gt; (loop for (a b) in '((1 2) (3 4) (5 6))<br/>            do (format t "a: ~a; b: ~a~%" a b))<br/>a: 1; b: 2<br/>a: 3; b: 4<br/>a: 5; b: 6<br/>NIL<br/></pre>
<p>Такое дерево также может включать в себя точечные пары. В этом случае имя после точки работает как <strong>&amp;rest</strong> параметр: с ним будет связан список, содержащий все оставшиеся элементы списка. Это особенно полезно с <code>for/on</code> циклом, так как значением всегда является список. Например, этот <strong>LOOP</strong> (который я использовал в главе 18 для вывода элементов списка, разделенных запятыми):
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_cons.htm" class="symbol">cons</a> on <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a><br/>    <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="string">"~a"</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_car_c.htm" class="symbol">car</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_cons.htm" class="symbol">cons</a></span>)</span></span>)</span><br/>    <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_car_c.htm" class="symbol">cdr</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_cons.htm" class="symbol">cons</a></span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="string">", "</span></span>)</span></span>)</span><br/></pre>

<p>может также быть записан следующим образом:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for <span class="paren2">(<span class="">item . <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rest.htm" class="symbol">rest</a></span>)</span> on <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a><br/>    <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="string">"~a"</span> item</span>)</span><br/>    <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_rest.htm" class="symbol">rest</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="string">", "</span></span>)</span></span>)</span><br/></pre>

<p>Если вы хотите игнорировать значение деструктурированного списка, вы можете использовать <strong>NIL</strong> на месте имени переменной.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for <span class="paren2">(<span class="">a <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span> in '<span class="paren2">(<span class=""><span class="paren3">(<span class="">1 2</span>)</span> <span class="paren3">(<span class="">3 4</span>)</span> <span class="paren3">(<span class="">5 6</span>)</span></span>)</span> collect a</span>)</span> ==&gt; <span class="paren1">(<span class="">1 3 5</span>)</span><br/></pre>

<p>Если список деструктурирования содержит больше переменных, чем значений в списке, лишние переменные получают значение <strong>NIL</strong>, что делает переменные по существу похожими на <strong>&amp;optional</strong> параметры. Не существует, однако, эквивалента <strong>&amp;key</strong> параметрам.
</p>



</div><div class="chapter" id="&#x41D;&#x430;&#x43A;&#x43E;&#x43F;&#x43B;&#x435;&#x43D;&#x438;&#x435; &#x437;&#x43D;&#x430;&#x447;&#x435;&#x43D;&#x438;&#x44F;"><h3>Накопление значения</h3>


<p>Предложения накопления значения вероятно являются наиболее мощной частью <strong>LOOP</strong>. Хотя предложения управления итерированием предоставляют лаконичный синтаксис для выражения базовых механизмов итерирования, они не отличаются разительно от подобных механизмов, предоставляемых <strong>DO</strong>, <strong>DOLIST</strong> и <strong>DOTIMES</strong>.
</p>
<p>С другой стороны, операторы накопления значения предоставляют возможность лаконичной записи общих идиом накопления во время итерирования. Каждое предожение накопления начинается с глагола и следует следующему образцу:
</p><pre>verb form [ into var ]<br/></pre>
<p>Каждый раз, при прохождении цикла, предложение накопления вычисляет <em>form</em> и сохраняет значение способом, определяемым глаголом <em>verb</em>. С подпредложением <code>into</code> значение сохраняется в переменную под именем <em>var</em>. Переменная является локальной в цикле, как если бы она была объявлена в предложении <code>with</code>. Без подпредложения <code>into</code> предложение накопления накапливает значения в переменную по умолчанию для всего выражения цикла.
</p>
<p>Возможными глаголами являются <code>collect</code>, <code>append</code>, <code>nconc</code>, <code>count</code>, <code>sum</code>, <code>maximize</code> и <code>minimize</code>. Также доступны синонимы в форме причастий настоящего времени: <code>collecting</code>, <code>appending</code>, <code>nconcing</code>, <code>counting</code>, <code>summing</code>, <code>maximizing</code> и <code>minimizing</code>.
</p>
<p>Предложение <code>collect</code> строит список, содержащий все значения <em>form</em> в порядке их просмотра. Эта конструкция особенно полезна, так как код, который вы бы написали для накопления списка, равный по эффективности сгенерированному <strong>LOOP</strong> коду, будет гораздо более сложным, чем вы обычно пишите вручную<a class="fn_top" id="fnt__5" href="loop-for-black-belts#fn__5">5)</a>. Родственными <code>collect</code> являются глаголы <code>append</code> и <code>nconc</code>.
Эти глаголы также накапливают значения в список, но они объединяют значения, которые должны быть списками, в единый список как с помощью функций <strong>APPEND</strong> и <strong>NCONC</strong><a class="fn_top" id="fnt__6" href="loop-for-black-belts#fn__6">6)</a>.
</p>
<p>Остальные предложения накопления значения используются для накопления численных значений. Глагол <code>count</code> подсчитывает число раз, которое форма <em>form</em> была истинна, <code>sum</code> подсчитывает сумму значений, которые принимала форма <em>form</em>, <code>maximize</code> подсчитывает максимальное из этих значения, а <code>minimize</code> — минимальное. Представим, например, что вы определили переменную <code>*random*</code>, содержащую список случайных чисел.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defpar.htm" class="symbol"><i><span class="symbol">defparameter</span></i></a> <span class="special">*random*</span> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> repeat 100 collect <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_random.htm" class="symbol">random</a> 10000</span>)</span></span>)</span></span>)</span><br/></pre>

<p>Следующий цикл вернет список, содержащий различную сводную информацию о числах из <code>*random*</code>:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i in <span class="special">*random*</span><br/>   counting <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_evenpc.htm" class="symbol">evenp</a> i</span>)</span> into evens<br/>   counting <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_evenpc.htm" class="symbol">oddp</a> i</span>)</span> into odds<br/>   summing i into total<br/>   maximizing i into <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_max_m.htm" class="symbol">max</a><br/>   minimizing i into <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_max_m.htm" class="symbol">min</a><br/>   finally <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_return.htm" class="symbol">return</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_max_m.htm" class="symbol">min</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_max_m.htm" class="symbol">max</a> total evens odds</span>)</span></span>)</span></span>)</span><br/></pre>




</div><div class="chapter" id="&#x411;&#x435;&#x437;&#x443;&#x441;&#x43B;&#x43E;&#x432;&#x43D;&#x43E;&#x435; &#x432;&#x44B;&#x43F;&#x43E;&#x43B;&#x43D;&#x435;&#x43D;&#x438;&#x435;"><h3>Безусловное выполнение</h3>


<p>Хоть и удобная для конструкций накопления значения, LOOP не была бы очень хорошим средством итерации общего назначения, если бы не предоставляла способа выполнения произвольного кода в теле цикла.
</p>
<p>Самым простым способом выполнения произвольного кода внутри тела цикла является использование предложения <code>do</code>. По сравнению с вышеописанными предложениями со всеми их предлогами и подвыражениями, <code>do</code> следует модели простоты по Йоде<a class="fn_top" id="fnt__7" href="loop-for-black-belts#fn__7">7)</a>. Предложение <code>do</code> состоит из слова <code>do</code> (или <code>doing</code>), за которым следует одна или более форм Lisp, которые вычисляются при вычислении предложения <code>do</code>. Предложение <code>do</code> заканчивается закрывающей скобкой цикла loop или следующим ключевым словом loop.
</p>
<p>Например, для печати чисел от одного до десяти, вы можете записать следующее:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i from 1 to 10 <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm" class="symbol">print</a> i</span>)</span></span>)</span><br/></pre>


<p>Еще одной формой непосредственного выполнения является предложение <code>return</code>. Это предложение состоит из слова <code>return</code>, за которым следует одна форма Lisp, которая вычисляется, а результат немедленно возвращается как значение цикла loop.
</p>
<p>Вы также можете прервать цикл из предложения <code>do</code> путем использования любого обычного оператора управления потоком вычислений Lisp, таких как <strong>RETURN</strong> и <strong>RETURN-FROM</strong>. Обратите внимание, что предложение <code>return</code> всегда возвращает управление из непосредственно охватывающего выражения <strong>LOOP</strong>, в то время как с помощью <strong>RETURN</strong> и <strong>RETURN-FROM</strong> в предложении <code>do</code> можно вернуть управление из любого охватывающего выражения. Например, сравните следующее:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_block.htm" class="symbol"><i><span class="symbol">block</span></i></a> outer<br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i from 0 <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_return.htm" class="symbol">return</a> 100</span>)</span> <span class="comment">; 100 возвращается из LOOP<br/></span>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm" class="symbol">print</a> <span class="string">"This will print"</span></span>)</span><br/>  200</span>)</span> ==&gt; 200<br/></pre>

<p>с этим:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_block.htm" class="symbol"><i><span class="symbol">block</span></i></a> outer<br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i from 0 <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_ret_fr.htm" class="symbol"><i><span class="symbol">return-from</span></i></a> outer 100</span>)</span></span>)</span> <span class="comment">; 100 возвращается из BLOCK<br/></span>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm" class="symbol">print</a> <span class="string">"This won't print"</span></span>)</span><br/>  200</span>)</span> ==&gt; 100<br/></pre>

<p>Предложения <code>do</code> и <code>return</code> вместе называются предложениями безусловного выполнения.
</p>





</div><div class="chapter" id="&#x423;&#x441;&#x43B;&#x43E;&#x432;&#x43D;&#x43E;&#x435; &#x432;&#x44B;&#x43F;&#x43E;&#x43B;&#x43D;&#x435;&#x43D;&#x438;&#x435;"><h3>Условное выполнение</h3>


<p>Так как предложение <code>do</code> может содержать произвольные формы Lisp, вы можете использовать любые выражения Lisp, включая конструкции управления, такие как <strong>IF</strong> и <strong>WHEN</strong>. Таким образом, следующее является одним из способов написания цикла, печатающего только четные числа от одного до десяти:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i from 1 to 10 <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_evenpc.htm" class="symbol">evenp</a> i</span>)</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm" class="symbol">print</a> i</span>)</span></span>)</span></span>)</span><br/></pre>

<p>Однако иногда вам понадобится условное управление на уровне предложений цикла loop. Например, представим, что вам нужно просуммировать только четные числа от одного до десяти путем использования предложения <code>summing</code>. Вы не сможете написать такой цикл с помощью предложения <code>do</code>, так как не существует способа "вызвать" <code>sum i</code> в середине обычной формы Lisp. В случаях, подобных этому, вам нужно использовать одно из собственных условных выражений <strong>LOOP</strong>:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i from 1 to 10 <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_evenpc.htm" class="symbol">evenp</a> i</span>)</span> sum i</span>)</span> ==&gt; 30<br/></pre>

<p><strong>LOOP</strong> предоставляет три условных конструкции, и все они следуют этому базовому образцу:
</p><pre>  conditional test-form loop-clause<br/></pre>
<p>Условный оператор <em>conditional</em> может быть <code>if</code>, <code>when</code> или <code>unless</code>. <em>test-form</em> — это любая обычная форма Lisp, а предложение <em>loop-clause</em> может быть предложением накопления значения (<code>count</code>, <code>collect</code> и так далее), предложением безусловного выполнения или другим предложением условного выполнения. Несколько предложений цикла могут быть объединены в одну условную конструкцию путем соединения их с помощью <code>and</code>.
</p>
<p> Несколько условных предложений могут быть объединены в одно условное, путем соединения их с помощью <code>and</code>.
</p>
<p>Дополнительным синтаксическим сахаром является возможность использования в первом предложении loop после формы условия переменной <code>it</code> для ссылки на значение, возвращенное этой формой условия. Например, следующий цикл накапливает не равные <strong>NIL</strong> значения, найденные в <code>some-hash</code> по ключам из <code>some-list</code>:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for key in some-list <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_gethas.htm" class="symbol">gethash</a> key some-hash</span>)</span> collect it</span>)</span><br/></pre>

<p>Условное выражение выполняется при каждой итерации цикла. Предложения <code>if</code> и <code>when</code> выполняют свои предложения loop если форма <em>test-form</em> вычисляется в истину. <code>unless</code> же выполняет предложения только если <em>test-form</em> вычисляется в <strong>NIL</strong>. В отличие от так же названных операторов Common Lisp, <code>if</code> и <code>when</code> в <strong>LOOP</strong> являются синонимами — в их поведении нет никакой разницы.
</p>
<p>Все три условных предложения могут также принимать ветвь <code>else</code>, в которой за <code>else</code> следует другое предложение loop либо несколько предложений, объединенных <code>and</code>. Если условные предложения являются вложенными, множество предложений, связанных с внутренним условным предложением, может быть завершено с помощью слова <code>end</code>. <code>end</code> является необязательным, если оно не нужно для разрешения неоднозначности с вложенными условными предложениями: конец условного предложения будет определен по концу цикла либо по началу другого предложения, не присоединенного с помощью <code>and</code>
</p>
<p>Следующий довольно глупый цикл демонстрирует различные формы условных предложений <strong>LOOP</strong>. Функция <code>update-analysis</code> будет вызываться на каждой итерации цикла с последними значениями различных переменных, накапливаемых предложениями внутри условных предложений.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i from 1 to 100<br/>      <a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_evenpc.htm" class="symbol">evenp</a> i</span>)</span><br/>        minimize i into min-even <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_and.htm" class="symbol">and</a> <br/>        maximize i into max-even <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_and.htm" class="symbol">and</a><br/>        <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">unless</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_zerop.htm" class="symbol">zerop</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_mod.htm" class="symbol">mod</a> i 4</span>)</span></span>)</span><br/>          sum i into even-not-fours-total<br/>        end<br/>        <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_and.htm" class="symbol">and</a> sum i into even-total<br/>      else<br/>        minimize i into min-odd <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_and.htm" class="symbol">and</a><br/>        maximize i into max-odd <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_and.htm" class="symbol">and</a><br/>        <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_zerop.htm" class="symbol">zerop</a> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_mod.htm" class="symbol">mod</a> i 5</span>)</span></span>)</span> <br/>          sum i into fives-total<br/>        end<br/>        <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_and.htm" class="symbol">and</a> sum i into odd-total<br/>      <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren2">(<span class="">update-analysis min-even<br/>                          max-even<br/>                          min-odd<br/>                          max-odd<br/>                          even-total<br/>                          odd-total<br/>                          fives-total<br/>                          even-not-fours-total</span>)</span></span>)</span><br/></pre>




</div><div class="chapter" id="&#x41D;&#x430;&#x447;&#x430;&#x43B;&#x44C;&#x43D;&#x44B;&#x435; &#x443;&#x441;&#x442;&#x430;&#x43D;&#x43E;&#x432;&#x43A;&#x438; &#x438; &#x43F;&#x43E;&#x434;&#x44B;&#x442;&#x43E;&#x436;&#x438;&#x432;&#x430;&#x43D;&#x438;&#x435;"><h3>Начальные установки и подытоживание</h3>


<p>Одним из ключевых озарений проектировщиков языка <strong>LOOP</strong> было осознание того, что циклы часто предваряются некоторым кодом, занимающимся начальной установкой каких-то вещей, и завершаются кодом, осуществляющим что-то со значениями, вычисленными в цикле. Простой пример на Perl<a class="fn_top" id="fnt__8" href="loop-for-black-belts#fn__8">8)</a> мог бы выглядеть так:
</p>
<pre class="code"><p>my $evens_sum = 0;<br/>
my $odds_sum  = 0;<br/>
foreach my $i <span class="paren1">(<span class="">@list_of_numbers</span>)</span> {<br/>
  if <span class="paren1">(<span class="">$i % 2</span>)</span> {<br/>
    $odds_sum += $i;<br/>
  } else {<br/>
    $evens_sum += $i;<br/>
  }<br/>
}<br/>
if <span class="paren1">(<span class="">$evens_sum &gt; $odds_sum</span>)</span> {<br/>
  print "Sum of evens greater\n";<br/>
} else {<br/>
  print "Sum of odds greater\n";<br/>
}<br/></p></pre>

<p>Циклической сущностью в этом коде является инструкция <code>foreach</code>. Но сам цикл <code>foreach</code> не является независимым: код в теле цикла ссылается на переменные, объявленные в двух строках перед циклом<a class="fn_top" id="fnt__9" href="loop-for-black-belts#fn__9">9)</a>. А работа, осуществляемая циклом является абсолютно бесполезной без инструкции <code>if</code> после цикла, которая фактически сообщает о результате. В Common Lisp, к тому же, конструкция <strong>LOOP</strong> является выражением, возвращающим значение, и поэтому потребность в осуществлении чего-либо, а именно генерации возвращаемого значения, даже больше.
</p>
<p>Поэтому проектировщики <strong>LOOP</strong> предоставили возможность включения такого, на самом деле являющегося частью цикла, кода в сам цикл. Для этого <strong>LOOP</strong> предоставляет два ключевых слова, <code>initially</code> и <code>finally</code>, которые вводят код для запуска снаружи главного тела цикла.
</p>
<p>После слов <code>initially</code> или <code>finally</code> эти предложения включают все формы Lisp до начала следующего предложения цикла либо до его конца. Все формы <code>initially</code> комбинируются в единую <em>вводную часть</em> (<em>prologue</em>), которая запускается однократно непосредственно после инициализации всех локальных переменных цикла и перед его телом. Формы <code>finally</code> схожим образом комбинируются в <em>заключительную часть</em> (<em>epilogue</em>) и выполняются после последней итерации цикла. И вводная, и заключительная части могут ссылаться на локальные пемеренные цикла.
</p>
<p>Вводная часть всегда запускается, даже если тело цикла не выполняется ни разу. В то же время цикл может вернуть значение без выполнения заключительной части в одном из следующих случаев:
</p><ul><li> Выполнение предложения <code>return</code>.</li><li> <strong>RETURN</strong>, <strong>RETURN-FROM</strong> или другая конструкция передачи управления была вызвана из формы Lisp, находящейся в теле цикла<a class="fn_top" id="fnt__10" href="loop-for-black-belts#fn__10">10)</a>.</li><li> Цикл завершается по предложению <code>always</code>, <code>nerver</code> или <code>thereis</code>, которые я обсужу в следующей секции.</li></ul>
<p>Внутри кода заключительной части для явного предоставления возвращаемого циклом значения могут использоваться <strong>RETURN</strong> или <strong>RETURN-FROM</strong>. Это явно возвращаемое значение имеет приоритет над любым значением, которое может иначе предоставляться предложениями накопления или критерия остановки.
</p>
<p>Для возможности использования <strong>RETURN-FROM</strong> для возврата из указываемого цикла (полезно при вложенных выражениях <strong>LOOP</strong>) вы можете дать <strong>LOOP</strong> имя с помощью ключевого слова loop <code>named</code>. Если предложение <code>named</code> используется в цикле, оно должно идти первым. В качестве простого примера предположим что у вас есть список списков и вы хотите найти в одном из вложенных списков элемент, который удовлетворяет некоторому критерию. Вы можете найти его с помощью пары вложенных циклов подобным образом:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> named outer for <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> in lists <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a><br/>     <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for item in <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a><br/>          <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="paren4">(<span class="">what-i-am-looking-for-p item</span>)</span><br/>            <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_ret_fr.htm" class="symbol"><i><span class="symbol">return-from</span></i></a> outer item</span>)</span></span>)</span></span>)</span></span>)</span><br/></pre>




</div><div class="chapter" id="&#x41A;&#x440;&#x438;&#x442;&#x435;&#x440;&#x438;&#x438; &#x437;&#x430;&#x432;&#x435;&#x440;&#x448;&#x435;&#x43D;&#x438;&#x44F;"><h3>Критерии завершения</h3>


<p>Хотя предложения <code>for</code> и <code>repeat</code> предоставляют базовую инфраструктуру для управления числом итераций, иногда вам понадобится прервать цикл до его завершения. Вы уже видели, как с помощью предложения <code>return</code> или операторов <strong>RETURN</strong> и <strong>RETURN-FROM</strong> внутри предложения <code>do</code> можно немедленно прервать цикл; но как есть общие образцы для накопления значений, так существуют и общие образцы для принятия решений, когда останавливать цикл. Такие образцы поддерживаются в <strong>LOOP</strong> с помощью предложений завершения <code>while</code>, <code>until</code>, <code>always</code>, <code>never</code> и <code>thereis</code>. Все они следуют одинаковому образцу:
</p><pre>  loop-keyword test-form<br/></pre>
<p>Все эти предложения вычисляют форму <em>test-form</em> на каждой итерации и на основе возвращаемого ей значения принимают решение, завершить ли выполнение цикла. Они отличаются в том, что происходит при завершении ими цикла (если он завершается), и как они определяют необходимость такого завершения.
</p>
<p>Ключевые слова <code>loop</code> <code>while</code> и <code>until</code> предоставляют "мягкие" предложения завершения. Если они решают завершить цикл, управление передается в заключительную часть, пропуская оставшуюся часть тела цикла. Затем заключительная часть может вернуть значение или сделать еще что-либо для завершения цикла. Предложение <code>while</code> останавливает цикл как только контрольная форма <em>test-form</em> вычисляется в ложное значение, а <code>until</code>, наоборот, - как только в истинное.
</p>
<p>Другая форма мягкго завершения предоставляется макросом <strong>LOOP-FINISH</strong>. Это обычная форма Lisp, не предложение loop, поэтому она может использоваться в любом месте внутри форм Lisp предложения <code>do</code>. <strong>LOOP-FINISH</strong> также приводит к немедленному переходу к заключительной части, и может быть полезен, когда решение о прерывании цикла не может быть легко умещено в единственную форму, могущую использоваться в предложениях <code>while</code> или <code>until</code>.
</p>
<p>Остальные три предложения, <code>always</code>, <code>never</code> и <code>thereis</code>, останавливают цикл гораздо более жестко: они приводят к немедленному возврату из цикла, пропуская не только все последующие предложения loop, но и заключительную часть. Они также предоставляют значение по умолчанию даже если не приводят к завершению цикла. Однако, если цикл не завершается ни по одному из этих критериев, заключительная часть запускается и может вернуть значение, отличное от значения по умолчанию, предоставляемого предложениями завершения.
</p>
<p>Так как эти предложения предоставляют свои собственные возвращаемые значения, они не могут комбинироваться с предложениями накопления за исключением содержащих подвыражение <code>into</code>. Иначе компилятор (или интерпретатор) должен просигнализировать ошибку во время выполнения. Предложения <code>always</code> и <code>never</code> возвращают только булевы значения, поэтому они наиболее полезны в случае, если вам нужно использовать выражение цикла как часть предиката. Вы можете использовать <code>always</code> для проверки того, что контрольная форма вычисляется в истинное значение на каждой итерации цикла. И наоборот, <code>never</code> проверяет, что контрольная форма на каждой итерации вычисляется в <strong>NIL</strong>. Если контрольная форма "не срабатывает" (возвращает <strong>NIL</strong> в предложении <code>always</code> или не <strong>NIL</strong> в предложении <code>never</code>), цикл немедленно прерывается, возвращая <strong>NIL</strong>. Если же цикл выполняется до конца, предоставляется значение по умолчанию: <strong>T</strong>.
</p>
<p>Например, если вы хотите проверить, что все числа в списке <code>numbers</code> являются четными, вы можете написать следующее:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for n in numbers always <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_evenpc.htm" class="symbol">evenp</a> n</span>)</span></span>)</span><br/>    <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm" class="symbol">print</a> <span class="string">"All numbers even."</span></span>)</span></span>)</span><br/></pre>

<p>Также вы можете записать следующее:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for n in numbers never <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_evenpc.htm" class="symbol">oddp</a> n</span>)</span></span>)</span><br/>    <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm" class="symbol">print</a> <span class="string">"All numbers even."</span></span>)</span></span>)</span><br/></pre>

<p>Предложение <code>thereis</code> используется для проверки, вычисляется ли контрольная форма в истинное значение хотя бы раз. Как только контрольная форма возвращает значение не равное <strong>NULL</strong>, цикл останавливается, возвращая это значение. Если же цикл доходит до конца, предложение <code>thereis</code> предоставляет возвращаемое значение по умолчанию: <strong>NIL</strong>.
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_char_.htm" class="symbol">char</a> across <span class="string">"abc123"</span> thereis <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_digi_1.htm" class="symbol">digit-char-p</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_char_.htm" class="symbol">char</a></span>)</span></span>)</span> ==&gt; 1<br/></pre>

<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_char_.htm" class="symbol">char</a> across <span class="string">"abcdef"</span> thereis <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_digi_1.htm" class="symbol">digit-char-p</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_char_.htm" class="symbol">char</a></span>)</span></span>)</span> ==&gt; NIL<br/></pre>




</div><div class="chapter" id="&#x421;&#x43B;&#x43E;&#x436;&#x438;&#x43C; &#x432;&#x441;&#x435; &#x432;&#x43C;&#x435;&#x441;&#x442;&#x435;"><h3>Сложим все вместе</h3>


<p>Вы увидели все основные возможности <strong>LOOP</strong>. Вы можете комбинировать все выше обсужденные предложения следуя следующим правилам:
</p><ul><li> Предложение <code>named</code>, если указывается, должно быть первым предложением.</li><li> После предложения <code>named</code> идут все остальные предложения <code>initially</code>, <code>with</code>, <code>for</code> и <code>repeat</code>.</li><li> Затем идут предложения тела: условного и безусловного выполнения, накопления, критериев завершения<a class="fn_top" id="fnt__11" href="loop-for-black-belts#fn__11">11)</a>.</li><li> Завершается цикл предложениями <code>finally</code>.</li></ul>
<p>Макрос <strong>LOOP</strong> раскрывается в код, который осуществляет следующие действия:
</p><ul><li> Инициализирует все локальные переменные цикла, которые объявлены в предложениях <code>with</code> или <code>for</code>, а также неявно созданы предложениями накопления. Начальные значения форм вычисляются в порядке появления соответствующих предложений в цикле.</li><li> Выполняет формы, предоставляемые предложениями <code>initially</code> (вводная часть), в порядке их появления в цикле.</li><li> Итерирует, выполняя тело цикла как описано в следующем абзаце.</li><li> Выполняет формы, предоставляемые предложениями <code>finally</code> (заключительная часть), в порядке их появления в цикле.</li></ul>
<p>Во время работы цикла сначала соответствующим образом изменяются все переменные управления итерацией, а затем выполняются все предложения условного и безусловного выполнения, накопления, критериев завершения в том порядке, в каком они появляются в коде цикла. Если любое из предложений тела цикла завершает цикл, оставшаяся часть тела пропускается и происходит возврат из цикла, возможно после выполнения завершающей части.
</p>
<p>И это описывает почти все, связанное с <strong>LOOP</strong><a class="fn_top" id="fnt__12" href="loop-for-black-belts#fn__12">12)</a>. Вы будете использовать <strong>LOOP</strong> далее в этой книге довольно часто, поэтому стоило получить некоторое представление о нем. Ну а после вам самим решать, насколько интенсивно использовать <strong>LOOP</strong>.
</p>
<p>И теперь вы готовы к погружению в практические главы, составляющие оставшуюся часть этой книги. Для начала мы напишем антиспамовый фильтр.
</p>
</div></div><div class="footnotes"><div><a class="fn_bot" id="fn__1" href="loop-for-black-belts#fnt__1">1)</a>Термин <em>ключевое слово loop</em> является несколько неудачным, так как ключевые слова loop не являются ключевыми словами в обычном смысле, то есть символами пакета KEYWORD. На самом деле ими могут быть любые символы с подходящими именами из любых пакетов: макрос <strong>LOOP</strong> заботится только об их именах. Обычно же они записываются без спецификатора пакета и поэтому считываются (и интернируются при необходимости) в текущий пакет</div><div><a class="fn_bot" id="fn__2" href="loop-for-black-belts#fnt__2">2)</a>Так как одной из целей <strong>LOOP</strong> является возможность записи выражений итерирования в синтаксисе, близком к английскому, многие ключевые слова имеют синонимы, которые трактуются <strong>LOOP</strong> как одинаковые, но дают при этом некоторую свободу в выражении вещей на более естественном английском языке учитывая различные контексты.</div><div><a class="fn_bot" id="fn__3" href="loop-for-black-belts#fnt__3">3)</a>Вас может удивить, почему <strong>LOOP</strong> не может определить, итерирует ли он по списку или по вектору, без указания различных предлогов. Это еще одно следствие того, что <strong>LOOP</strong> является макросом: то, является значение списком или вектором, не может быть известно до времени выполнения, а <strong>LOOP</strong>, как макрос, должен сгенерировать код во время компиляции. Также создатели <strong>LOOP</strong> ставили целью генерацию максимально эффективного кода. Для генерации эффективного кода для итерирования, например, по вектору необходимо знать во время компиляции, что значением во время выполнения будет вектор, поэтому и нужны различные предлоги.</div><div><a class="fn_bot" id="fn__4" href="loop-for-black-belts#fnt__4">4)</a>Даже не спрашивайте меня, почему авторы <strong>LOOP</strong> отступили от стиля без скобок для <code>using</code>-подпредложения.</div><div><a class="fn_bot" id="fn__5" href="loop-for-black-belts#fnt__5">5)</a>Трюк заключается в удержании хвоста списка и добавления новых cons-ячеек путем <strong>SETF</strong> <strong>CDR</strong>'а хвоста. Написанный вручную эквивалент кода, генерируемого <code>(loop for i upto 10 collect i)</code> будет выглядеть подобным образом:

<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_do_do.htm" class="symbol">do</a> <span class="paren2">(<span class=""><span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span> <span class="paren3">(<span class="">tail <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span> <span class="paren3">(<span class="">i 0 <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_1pl_1_.htm" class="symbol">1+</a> i</span>)</span></span>)</span></span>)</span><br/>    <span class="paren2">(<span class=""><span class="paren3">(<span class="">&gt; i 10</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a></span>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">new <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_cons.htm" class="symbol">cons</a> i <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span></span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_null.htm" class="symbol">null</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a></span>)</span><br/>        <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> new</span>)</span><br/>        <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_car_c.htm" class="symbol">cdr</a> tail</span>)</span> new</span>)</span></span>)</span><br/>    <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_setf.htm" class="symbol">setf</a> tail new</span>)</span></span>)</span></span>)</span><br/></pre>

Конечно вы редко, если вообще, будете писать подобный код. Вы будете использовать либо <strong>LOOP</strong>, либо, если по каким-то причинам вы не захотите использовать <strong>LOOP</strong>, стандартную идиому <strong>PUSH</strong>/<strong>NREVERSE</strong> накопления значений.</div><div><a class="fn_bot" id="fn__6" href="loop-for-black-belts#fnt__6">6)</a>Напомним, что <strong>NCONC</strong> является деструктивной версией <strong>APPEND</strong> — использование предложения <code>nconc</code> безопасно только в том случае, если накапливаемые вами значения являются новыми списками, которые не разделяют какую либо свою структуру с другими списками. Например, это безопасно:

<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i upto 3 <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_nconc.htm" class="symbol">nconc</a> <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> i i</span>)</span></span>)</span> ==&gt; <span class="paren1">(<span class="">0 0 1 1 2 2 3 3</span>)</span><br/></pre>

Но это доставит вам хлопот:

<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm" class="symbol"><i><span class="symbol">loop</span></i></a> for i on <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_list.htm" class="symbol">list</a> 1 2 3</span>)</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_nconc.htm" class="symbol">nconc</a> i</span>)</span> ==&gt; неопределено<br/></pre>

Последнее наиболее вероятно зациклится навечно, так как различные части списка, созданного с помощью <code>(list 1 2 3)</code>, будут деструктивно модифицированы, указывая друг на друга. Но даже это не гарантируется — поведение просто неопределено.</div><div><a class="fn_bot" id="fn__7" href="loop-for-black-belts#fnt__7">7)</a>"Нет! Не пытайся. Делай... или не делай. Но не пытайся." – Йода, Империя наносит ответный удар.</div><div><a class="fn_bot" id="fn__8" href="loop-for-black-belts#fnt__8">8)</a>Я не придираюсь к Perl здесь — этот пример выглядел бы примерно так же на любом языке с основанным на C синтаксисом.</div><div><a class="fn_bot" id="fn__9" href="loop-for-black-belts#fnt__9">9)</a>Perl позволяет вам не объявлять переменные, если вы не используете режим <code>strict</code>. Но вам следует <em>всегда</em> использовать его в Perl. Эквивалентный код на Python, Java или C потребовал бы обязательного объявления переменных.</div><div><a class="fn_bot" id="fn__10" href="loop-for-black-belts#fnt__10">10)</a>Вы можете нормально, с запуском заключительной части, завершить цикл из кода Lisp, выполняемого как часть тела цикла, с помощью локального макроса <strong>LOOP-FINISH</strong>.</div><div><a class="fn_bot" id="fn__11" href="loop-for-black-belts#fnt__11">11)</a>Некоторые реализации Common Lisp позволяют вам смешивать предложения тела и предложения <code>for</code>, но это неспецифицировано, поэтому другие реализации отвергнут такие циклы.</div><div><a class="fn_bot" id="fn__12" href="loop-for-black-belts#fnt__12">12)</a>Одним из аспектов <strong>LOOP</strong>, которого я даже не касался, является синтаксис объявления типов переменных цикла. Конечно, я также не обсуждал и объявление типов вне <strong>LOOP</strong>. Последнее я вкратце обсужу в главе 32. Для информации же о том, как декларации типов работают с <strong>LOOP</strong>, обратитесь к вашему любимому справочнику по Common Lisp.</div></div></div> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="programming-in-the-large-packages-and-symbols">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right"> <a href="practical-a-spam-filter">Следующая</a> </td> </tr> </tbody> </table> </div> <div class="bottom">@2009-2013 lisper.ru</div> 
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7734690-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
 </body> </html>