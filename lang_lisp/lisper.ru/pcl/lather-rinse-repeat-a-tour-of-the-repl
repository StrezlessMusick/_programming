<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru"> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <meta name="keywords" content="Common Lisp,lisp,лисп" /> <title>Намылить, смыть, повторить: знакомство с REPL</title> <link href="../css/style.css" rel="stylesheet" type="text/css" /><link href="../css/colorize.css" rel="stylesheet" type="text/css" />  </head> <body> <div class="top"> <div id="login"> <a href="http://lisper.ru/register">Регистрация</a> | <a href="http://lisper.ru/login?done=/pcl/lather-rinse-repeat-a-tour-of-the-repl">Войти</a> </div> </div> <div id="caution"> <img alt="Lisp — программируемый язык программирования" src="../image/gecko.png" /> <a href="http://www.vkusnoserver.ru/" target="_blank" style="float: right;"> <img src="../vkusnoserver.png" /> </a> </div> <div id="mainmenu"> <ul> <li> <a href="http://lisper.ru/">Главная</a> </li><li> <a href="http://lisper.ru/articles/">Статьи</a> </li><li> <a href="http://lisper.ru/planet/">Планета</a> </li><li> <a href="http://lisper.ru/forum/">Форум</a> </li><li> <a href="http://lisper.ru/apps/">Сервисы</a> </li><li> <a href="index.html">Practical Common Lisp</a> </li><li> <a href="http://lisper.ru/wiki/">Wiki</a> </li><li> <a href="http://lisper.ru/files/">Файлы</a> </li><li> <a href="http://lisper.ru/search">Поиск</a> </li> </ul> </div> <div id="content"> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="introduction-why-lisp">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right"> <a href="practical-a-simple-database">Следующая</a> </td> </tr> </tbody> </table> <div class="article"><div class="toc"><div class="toc-header">Содержание</div><div class="toc-body"><ul><li><div><a href="lather-rinse-repeat-a-tour-of-the-repl#2. &#x41D;&#x430;&#x43C;&#x44B;&#x43B;&#x438;&#x442;&#x44C;, &#x441;&#x43C;&#x44B;&#x442;&#x44C;, &#x43F;&#x43E;&#x432;&#x442;&#x43E;&#x440;&#x438;&#x442;&#x44C;: &#x437;&#x43D;&#x430;&#x43A;&#x43E;&#x43C;&#x441;&#x442;&#x432;&#x43E; &#x441; REPL">2. Намылить, смыть, повторить: знакомство с REPL</a><ul><li><div><a href="lather-rinse-repeat-a-tour-of-the-repl#&#x412;&#x44B;&#x431;&#x43E;&#x440; &#x440;&#x435;&#x430;&#x43B;&#x438;&#x437;&#x430;&#x446;&#x438;&#x438; Lisp">Выбор реализации Lisp</a></div></li><li><div><a href="lather-rinse-repeat-a-tour-of-the-repl#&#x412;&#x432;&#x435;&#x434;&#x435;&#x43D;&#x438;&#x435; &#x432; Lisp in a Box">Введение в Lisp in a Box</a></div></li><li><div><a href="lather-rinse-repeat-a-tour-of-the-repl#&#x41E;&#x441;&#x432;&#x43E;&#x431;&#x43E;&#x434;&#x438;&#x442;&#x435; &#x441;&#x432;&#x43E;&#x439; &#x440;&#x430;&#x437;&#x443;&#x43C;: &#x418;&#x43D;&#x442;&#x435;&#x440;&#x430;&#x43A;&#x442;&#x438;&#x432;&#x43D;&#x43E;&#x435; &#x43F;&#x440;&#x43E;&#x433;&#x440;&#x430;&#x43C;&#x43C;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435;">Освободите свой разум: Интерактивное программирование</a></div></li><li><div><a href="lather-rinse-repeat-a-tour-of-the-repl#&#x42D;&#x43A;&#x441;&#x43F;&#x435;&#x440;&#x438;&#x43C;&#x435;&#x43D;&#x442;&#x44B; &#x432; REPL">Эксперименты в REPL</a></div></li><li><div><a href="lather-rinse-repeat-a-tour-of-the-repl#&quot;&#x417;&#x434;&#x440;&#x430;&#x432;&#x441;&#x442;&#x432;&#x443;&#x439;, &#x43C;&#x438;&#x440;!&quot; &#x432; &#x441;&#x442;&#x438;&#x43B;&#x435; Lisp">"Здравствуй, мир!" в стиле Lisp</a></div></li><li><div><a href="lather-rinse-repeat-a-tour-of-the-repl#&#x421;&#x43E;&#x445;&#x440;&#x430;&#x43D;&#x435;&#x43D;&#x438;&#x435; &#x432;&#x430;&#x448;&#x435;&#x439; &#x440;&#x430;&#x431;&#x43E;&#x442;&#x44B;">Сохранение вашей работы</a></div></li></ul></div></li></ul></div></div>
<div class="chapter" id="2. &#x41D;&#x430;&#x43C;&#x44B;&#x43B;&#x438;&#x442;&#x44C;, &#x441;&#x43C;&#x44B;&#x442;&#x44C;, &#x43F;&#x43E;&#x432;&#x442;&#x43E;&#x440;&#x438;&#x442;&#x44C;: &#x437;&#x43D;&#x430;&#x43A;&#x43E;&#x43C;&#x441;&#x442;&#x432;&#x43E; &#x441; REPL"><h3>2. Намылить, смыть, повторить: знакомство с REPL</h3>
<p>В этой главе вы настроите среду программирования и напишете свои первые программы на Common Lisp. Мы воспользуемся лёгким в установке дистрибутивом <strong>Lisp in a Box</strong>, разработанным <em>Matthew Danish</em> и <em>Mikel Evins</em>, который включает в себя реализацию Common Lisp, <strong>Emacs</strong> - мощный текстовый редактор прекрасно подходящий для Lisp-а а также <strong>SLIME</strong><a class="fn_top" id="fnt__1" href="lather-rinse-repeat-a-tour-of-the-repl#fn__1">1)</a> — среду разработки для Common Lisp, основанной на Emacs.
</p>
<p>Этот набор предоставляет программисту современную среду разработки на Common Lisp, поддерживающую инкрементальный интерактивный стиль разработки, характерный для программирования на этом языке. Среда SLIME даёт дополнительное преимущество в виде унифицированного пользовательского интерфейса, не зависящего от выбранных вами операционной системы и реализации Common Lisp. В своей книге я буду ориентироваться на среду Lisp in a Box, но те, кто хочет изучить другие среды разработки, например, графические интегрированные среды разработки  (IDE - Integrated Development Environment), предоставляемые некоторыми коммерческими поставщиками, или среды, основанные на других текстовых редакторах, не должны испытывать больших трудностей в понимании.<a class="fn_top" id="fnt__2" href="lather-rinse-repeat-a-tour-of-the-repl#fn__2">2)</a>
</p>




<div class="chapter" id="&#x412;&#x44B;&#x431;&#x43E;&#x440; &#x440;&#x435;&#x430;&#x43B;&#x438;&#x437;&#x430;&#x446;&#x438;&#x438; Lisp"><h3>Выбор реализации Lisp</h3>
<p>Первое, что вам предстоит сделать — выбрать реализацию Lisp. Это может показаться немного странным тем, кто раньше занимался программированием на таких языках как Perl, Python, Visual Basic (VB), C# или Java. Разница между Common Lisp и этими языками заключается в том, что Common Lisp определяется своим стандартом: не существует ни единственной его реализации, контролируемой "великодушным диктатором" (как в случае с Perl и Python), ни канонической реализации, контролируемой одной компанией (как в случае с VB, C# или Java). Любой желающий может создать свою реализацию на основе стандарта. Кроме того, изменения в стандарт должны вноситься в соответствии с процессом, контролируемым Американским Национальным Институтом Стандартов (ANSI). Этот процесс организован таким образом, что "случайные лица", такие, как частные поставщики программных решений, не могут вносить изменения в стандарт по своему усмотрению<a class="fn_top" id="fnt__3" href="lather-rinse-repeat-a-tour-of-the-repl#fn__3">3)</a>. Таким образом, стандарт Common Lisp — это договор между поставщиком Common Lisp и использующими Common Lisp разработчиками; этот договор подразумевает, что, если вы пишете программу, использующую возможности языка так, как это описано в стандарте, вы можете рассчитывать, что эта программа запустится на любой совместимой реализации Common Lisp.
</p>
<p>С другой стороны, стандарт может не покрыть все то, что вам может понадобиться в ваших программах. Более того, на некоторые аспекты языка спецификация намеренно отсутствует, чтобы дать возможность экспериментальным путем решить спорные вопросы языка. Таким образом, каждая реализация предоставляет пользователям как возможности,  входящие в стандарт, так и возможности, выходящие за его пределы. В зависимости от того, что нужно будет программировать, вы можете выбрать реализацию Common Lisp, поддерживающую именно те дополнительные возможности, которые вам больше всего понадобятся. С другой стороны, если вы позволите другим разработчикам пользоваться вашим Lisp кодом, например, в виде библиотек, вы, вероятно, захотите — конечно, в пределах возможного — писать переносимый код на Common Lisp. Для нужд написания переносимого кода, который, в то же время, использует возможности, не описанные в стандарте, Common Lisp предоставляет гибкий способ писать код, "зависящий" от возможностей текущей реализации. Вы увидите пример такого кода в главе 15, когда мы будем разрабатывать простую библиотеку, "сглаживающую" некоторые различия в обработке разными реализациями Lisp имён файлов.
</p>
<p>Сейчас, однако, наиболее важная характеристика реализации — её способность работать в вашей любимой операционной системе. Сотрудники компании Franz, занимающейся разработкой Allegro Common Lisp, выпустили пробную версию своего продукта, предназначенного для использования с этой книгой, который работает под GNU/Linux, Windows и OS X. У читателей, предпочитающих реализации с открытым исходным кодом, есть несколько вариантов. <strong>SBCL</strong><a class="fn_top" id="fnt__4" href="lather-rinse-repeat-a-tour-of-the-repl#fn__4">4)</a> - высококачественная открытая реализация, способная компилировать в машинный код и работать на множестве различных UNIX-систем, включая Linux и OS X. SBCL — "наследник" <strong>CMUCL</strong><a class="fn_top" id="fnt__5" href="lather-rinse-repeat-a-tour-of-the-repl#fn__5">5)</a> —  реализации Common Lisp, разработанной в университете <strong>Carnegie Mellon</strong>, и, как и CMUCL, является всеобщим достоянием, за исключением нескольких пунктов, покрываемых BSD-подобными (Berkley Software Distributions) лицензиями. CMUCL — тоже хороший выбор, однако SBCL обычно легче в установке и поддерживает 21-разрядный Unicode<a class="fn_top" id="fnt__6" href="lather-rinse-repeat-a-tour-of-the-repl#fn__6">6)</a>. <strong>OpenMCL</strong> будет отличным выбором для пользователей OS X: эта реализация способна компилировать в машинный код, поддерживать работу с потоками, а также прекрасно интегрируется с библиотеками Carbon и Cocoa. Кроме перечисленных, существуют и другие свободные и коммерческие реализации. Если вы захотите получить больше информации, в главе 32 вы найдёте список ресурсов.
</p>
<p>Весь код на Lisp, приведённый в этой книге, должен работать на любой совместимой реализации Common Lisp, если явно не указано обратное, и SLIME будет "сглаживать" некоторые различия между реализациями, предоставляя общий интерфейс для взаимодействия с Lisp. Сообщения интерпретатора, приведённые в этой книге, сгенерированы <strong>Allegro</strong>, запущенном на <strong>GNU/Linux</strong>. В некоторых случаях другие реализации Lisp могут генерировать сообщения, незначительно отличающиеся от приведённых.
</p>
</div><div class="chapter" id="&#x412;&#x432;&#x435;&#x434;&#x435;&#x43D;&#x438;&#x435; &#x432; Lisp in a Box"><h3>Введение в Lisp in a Box</h3>
<p>Lisp in a Box спроектирован с целью быть "дружелюбным" к лисперам-новичкам и предоставлять первоклассную среду разработки на Lisp с минимальными усилиями, и потому всё что вам нужно для работы - это взять соответствующий пакет для вашей операционной системы и выбранную вами реализацию Lisp с веб-сайта Lisp in a Box (см. главу 32) и далее следовать инструкциям по установке.
</p>
<p>Так как Lisp in a Box использует Emacs в качестве текстового редактора, вы должны хоть немного уметь им пользоваться. Возможно, лучший способ начать работать с Emacs - это изучать его по встроенному учебнику (tutorial). Чтобы вызвать tutorial, выберете первый пункт меню Help – Emacs tutorial. Или же зажмите Ctrl и нажмите h, затем отпустите Ctrl и нажмите t. Большинство команд в Emacs доступно через комбинации клавиш, поэтому они будут встречаться довольно часто, и чтобы долго не описывать комбинации (например: "зажмите Ctrl и нажмите h, затем..."), в Emacs существует краткая форма записи комбинаций клавиш. Клавиши, которые должны быть нажаты вместе, пишутся вместе, разделяются тире и называются связками; связки разделяются пробелами. C обозначает Ctrl, а M - Meta (Alt). Например вызов tutorial будет выглядеть таким образом: C-h t.
</p>
<p>Tutorial также описывает много других полезных команд Emacs и вызывающих их комбинаций клавиш. У Emacs также есть расширенная онлайн документация, для просмотра которой используется специальный браузер – Info. Чтобы её вызвать нажмите C-h i. У Info также есть своя справка, которую можно вызвать, нажав клавишу h, находясь в браузере Info. Emacs предоставляет ещё несколько способов получить справку – это все сочетания клавиш, начинающиеся с C-h – полный список по C-h ?. В этом списке есть две полезные вещи: C-h k "объяснит" комбинацию клавиш, а C-h w – команду.
</p>
<p>Ещё одна важная часть терминологии (для тех, кто отказался от работы с tutorial) - это буфер. Во время работы в Emacs, каждый файл, который Вы редактируете, представлен в отдельном буфере. Только один буфер может быть "текущим" в любой момент времени. В текущий буфер поступает весь ввод – всё, что Вы печатаете и любые команды, которые вызываете. Буферы также используются для представления взаимодействия с программами (например с Common Lisp). Есть одна простая вещь, которую вы должны знать – "переключение буферов", означающее смену текущего буфера, так что Вы можете редактировать определённый файл или взаимодействовать с определённой программой. Команда switch-to-buffer, привязанная к комбинации клавиш C-x b, запрашивает имя буфера (в нижней части окна Emacs). Во время ввода имени буфера, Вы можете пользоваться автодополнением по клавише Tab, которое по начальным символам завершает имя буфера или выводит список возможных вариантов. Просто нажав ввод, Вы переключитесь в буфер "по-умолчанию" (таким же образом и обратно). Вы также можете переключать буферы, выбирая нужный пункт в меню Buffers.
</p>
<p>В определенных контекстах для переключения на определенные буферы могут быть доступны другие комбинации клавиш. Например, при редактировании исходных файлов Lisp сочетание клавиш C-c C-z переключает на буфер, в котором вы взаимодействуете с Lisp.
</p>





</div><div class="chapter" id="&#x41E;&#x441;&#x432;&#x43E;&#x431;&#x43E;&#x434;&#x438;&#x442;&#x435; &#x441;&#x432;&#x43E;&#x439; &#x440;&#x430;&#x437;&#x443;&#x43C;: &#x418;&#x43D;&#x442;&#x435;&#x440;&#x430;&#x43A;&#x442;&#x438;&#x432;&#x43D;&#x43E;&#x435; &#x43F;&#x440;&#x43E;&#x433;&#x440;&#x430;&#x43C;&#x43C;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435;"><h3>Освободите свой разум: Интерактивное программирование</h3>

<p>При запуске Lisp in a Box, вы должны увидеть приглашение, которое может выглядеть примерно так :</p><pre> CL-USER&gt;<br/></pre>
<p>Это приглашение Lisp. Как и приглашение оболочки DOS или UNIX, приглашение Lisp — это место, куда вы можете печатать выражения, которые заставляют компьютер делать что-либо. Однако вместо того, чтобы считывать и выполнять строку команд оболочки, Lisp считывает Lisp выражения, вычисляет их согласно правилам Lisp и печатает результат. Потом он (Lisp) повторяет свои действия со следующим введенным вами выражением. Вот вам бесконечный цикл: считывания, вычисления, и печати(вывода на экран), поэтому он называется <em>цикл-чтение-вычисление-печать</em> (по-английски <em>read-eval-print-loop</em>), или сокращённо REPL . Этот процесс может также называться  <em>top-level</em>, <em>top-level listener</em>, или <em>Lisp listener</em>.
</p>
<p>Через окружение, предоставленное REPL'ом, вы можете определять и переопределять элементы программ такие как переменные, функции, классы и методы; вычислять выражения Lisp; загружать файлы, содержащие исходные тексты Lisp или скомпилированные программы; компилировать целые файлы или отдельные функции; входить в отладчик; пошагово выполнять программы; и проверять состояние отдельных объектов Lisp.
</p>
<p>Все эти возможности встроены в язык, и доступны через функции, определённые в стандарте языка. Если вы захотите, вы можете построить достаточно приемлемую среду разработки только из REPL и текстового редактора, который знает как правильно форматировать код Lisp. Но для истинного опыта Lisp программирования вам необходима среда разработки типа SLIME, которая бы позволяла вам взаимодействовать с Lisp как посредством REPL, так и при редактировании исходных файлов. Например, вы ведь не захотите каждый раз копировать и вставлять куски кода из редактора в REPL или перезагружать весь файл только потому, что изменилось одно определение, ваше окружение должно позволять вам вычислять или компилировать как отдельные выражения так и целые файлы из вашего редактора<a class="fn_top" id="fnt__7" href="lather-rinse-repeat-a-tour-of-the-repl#fn__7">7)</a>.
</p>








</div><div class="chapter" id="&#x42D;&#x43A;&#x441;&#x43F;&#x435;&#x440;&#x438;&#x43C;&#x435;&#x43D;&#x442;&#x44B; &#x432; REPL"><h3>Эксперименты в REPL</h3>

<p>Для знакомства с REPL, вам необходимо выражение Lisp, которое может быть прочитано, вычислено и выведено на экран. Простейшее выражение Lisp - это число. Если вы наберете 10 в приглашении Lisp и нажмете ВВОД, то сможете увидите что-то наподобие:
</p><pre> CL-USER&gt; 10<br/> 10<br/></pre>
<p>Первая 10 - это то, что вы набрали. Считыватель Lisp, R в REPL, считывает текст "10" и создаёт объект Lisp, представляющий число 10. Этот объект - самовычисляемый объект, это означает, что такой объект при передаче в вычислитель, E в REPL, вычисляется сам в себя. Это значение подаётся на устройство вывода REPL, которое напечатает объект "10" в отдельной строке. Хотя это и похоже на сизифов труд, можно получить что-то поинтереснее, если дать интерпретатору Lisp пищу для размышлений. Например, вы можете набрать (+ 2 3) в приглашении Lisp.
</p><pre> CL-USER&gt; (+ 2 3)<br/> 5<br/></pre>
<p>Все что в скобках - это список, в данном случае список из трех элементов: символ <code>+</code>, и числа 2 и 3. Lisp, в общем случае, вычисляет списки, считая первый элемент именем функции, а остальные - выражениями для вычисления и передачи в качестве аргументов этой функции. В нашем случае, символ  <code>+</code> - название функции которая вычисляет сумму. 2 и 3 вычисляются сами в себя и передаются в функцию суммирования, которая возвращает 5. Значение 5 отправляется на устройство вывода, которое отображает его. Lisp может вычислять выражения и другими способами, но не будем сильно отдаляться от основной темы. Сначала нам нужно написать . . .
</p>











</div><div class="chapter" id="&quot;&#x417;&#x434;&#x440;&#x430;&#x432;&#x441;&#x442;&#x432;&#x443;&#x439;, &#x43C;&#x438;&#x440;!&quot; &#x432; &#x441;&#x442;&#x438;&#x43B;&#x435; Lisp"><h3>"Здравствуй, мир!" в стиле Lisp</h3>

<p>Нет законченной книги по программированию без программы "Здравствуй, мир" ("hello, world")<a class="fn_top" id="fnt__8" href="lather-rinse-repeat-a-tour-of-the-repl#fn__8">8)</a>. После того как интерпретатор запущен, нет ничего проще чем набрать строку "Здравствуй, мир".
</p><pre> CL-USER&gt; "Здравствуй, мир"<br/>  "Здравствуй, мир"<br/></pre>
<p>Это работает, поскольку строки, также как и числа, имеют символьный синтаксис, понимаемый <em>считывателем</em> Lisp, и являются самовычисляемыми объектами:  Lisp считывает строку в двойных кавычках и создает в памяти строковой объект, который при вычислении вычисляется сам в себя и потом печатается в том же символьном представлении. Кавычки не являются частью строкового объекта в памяти - это просто синтаксис, который позволяет считывателю определить, что этот объект - строка. Устройство вывода REPL напечатает кавычки тоже, потому что оно пытается выводить объекты в таком же виде, в каком понимает их считыватель.
</p>
<p>Однако, наш пример не может квалифицироваться как программа "Здравствуй, мир". Это, скорее, значение "Здравствуй, мир".
</p>
<p>Вы можете сделать шаг к настоящей программе, напечатав код, который, в качестве побочного эффекта, отправит на стандартный вывод строку "Здравствуй, мир". Common Lisp предоставляет несколько путей для вывода данных, но самый гибкий - это функция FORMAT. FORMAT получает переменное количество параметров, но только два из них обязательны: указание, куда осуществлять вывод, и строка для вывода. В следующей главе Вы увидите, как строка может содержать встроенные директивы, которые позволяют вставлять в строку последующие параметры функции (а-ля <code>printf</code> или строка <strong>%</strong> из Python). До тех пор, пока строка не содержит символа <strong>~</strong>, она будет выводиться как есть. Если вы передадите t в качестве первого параметра, функция FORMAT направит отформатированную строку на стандартный вывод. Итак, выражение FORMAT для печати "Здравствуй, мир" выглядит примерно так:<a class="fn_top" id="fnt__9" href="lather-rinse-repeat-a-tour-of-the-repl#fn__9">9)</a>
</p><pre> CL-USER&gt; (format t "Здравствуй, мир")<br/> Здравствуй, мир<br/> NIL<br/></pre>
<p>Стоит заметить, что результатом выражения FORMAT является NIL в строке после вывода "Здравствуй, мир". Этот NIL является результатом вычисления выражения FORMAT, напечатанного REPL. (NIL – это Lisp-версия false и/или null. Подробнее об этом рассказывается в главе 4.) В отличие от других выражений, рассмотренных ранее, нас больше интересует побочный эффект выражения FORMAT (в данном случае, печать на стандартный вывод), чем возвращаемое им значение. Но каждое выражение в Lisp вычисляется в некоторый результат<a class="fn_top" id="fnt__10" href="lather-rinse-repeat-a-tour-of-the-repl#fn__10">10)</a>.
</p>
<p>Однако, до сих пор остается спорным, написали ли мы настоящую программу. Но вы ведь здесь. Вы видите восходящий стиль программирования, поддерживаемый REPL: вы можете экспериментировать с различными подходами и строить решения из уже протестированных частей. Теперь, когда у вас есть простое выражение, которое делает то, что вы хотите, нужно просто упаковать его в функцию. Функции являются одним из основных строительных материалов в Lisp и могут быть определены с помощью выражения DEFUN подобным образом:
</p><pre> CL-USER&gt; (defun hello-world () (format t "Здравствуй, мир"))<br/> HELLO-WORLD<br/></pre>
<p>Выражение hello-world, следующее за DEFUN, является именем функции. В главе 4 мы рассмотрим, какие именно символы могут использоваться в именах, но сейчас будет достаточно сказать, что многие символы, такие как &lt;&lt;-", недопустимые в именах в других языках можно использовать в Common Lisp. Это стандартный стиль Lisp – "not to mention more in line with normal English typography" – формирование составных имен с помощью дефисов, как в hello-world, вместо использования знаков подчеркивания, как в hello_world, или использованием заглавных букв внутри имени, как helloWorld. Скобки () после имени отделяют список параметров, который в данном случае пуст, так как функция не принимает аргументов. Остальное - это тело функции.
</p>
<p>В какой-то мере это выражение подобно всем другим, которые вы видели, всего лишь еще одно выражение для чтения, вычисления и печати, осуществляемых REPL. Возвращаемое значение в этом случае - это имя только что определенной функции<a class="fn_top" id="fnt__11" href="lather-rinse-repeat-a-tour-of-the-repl#fn__11">11)</a>. Но, подобно выражению FORMAT, это выражение более интересно своими побочными эффектами, нежели возвращаемым значением. Однако, в отличие от выражения FORMAT, побочные эффекты невидимы: после вычисления этого выражения создается новая функция, не принимающая аргументов, с телом <code>(format t "Здравствуй, мир")</code> и ей дается имя HELLO-WORLD.
</p>
<p>Теперь, после определения функции, вы можете вызвать ее следующим образом:
</p><pre> CL-USER&gt; (hello-world)<br/> Здравствуй, мир<br/> NIL<br/></pre>
<p>Вы можете видеть, что вывод в точности такой же, как при вычислении выражения FORMAT напрямую, включая значение NIL, напечатанное REPL. Функции в Common Lisp автоматически возвращают значение последнего вычисленного выражения.
</p>




















</div><div class="chapter" id="&#x421;&#x43E;&#x445;&#x440;&#x430;&#x43D;&#x435;&#x43D;&#x438;&#x435; &#x432;&#x430;&#x448;&#x435;&#x439; &#x440;&#x430;&#x431;&#x43E;&#x442;&#x44B;"><h3>Сохранение вашей работы</h3>

<p>Вы могли бы утверждать, что это готовая программа "Здравствуй, мир". Однако, остаётся одна проблема. Если вы выйдете из Lisp и перезапустите его, определение функции исчезнет. Написав такую изящную функцию, вы захотите сохранить вашу работу.
</p>
<p>Это достаточно легко. Вы просто должны создать файл, в котором сохраните определение. В Emacs вы можете создать новый файл набрав C-x C-f, и затем, когда Emacs выведет подсказку, введите имя файла, который вы хотите создать. Не особо важно, где будет находиться этот файл. Обычно исходные файлы Common Lisp именуются с расширением .lisp, хотя некоторые люди предпочитают .cl.
</p>
<p>Открыв файл, вы можете набирать определение функции, введённое ранее в области REPL. Обратите внимание, что после набора открывающей скобки и слова DEFUN, в нижней части окна Emacs SLIME подскажет вам предполагаемые аргументы. Точная форма зависит от используемой вами реализации Common Lisp, но вы вероятно увидите что-то вроде этого:
</p><pre> (defun name varlist &amp;rest body)<br/></pre>
<p>Сообщение будет исчезать, когда вы будете начинать печатать каждый новый элемент, и снова появляться после ввода пробела. При вводе определения в файл, вы можете захотеть разбить определение после списка параметров так, чтобы оно занимало две строки. Если вы нажмете Enter, а затем Tab, SLIME автоматически выровняет вторую строку соответствующим образом<a class="fn_top" id="fnt__12" href="lather-rinse-repeat-a-tour-of-the-repl#fn__12">12)</a>:
</p>
<pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> hello-world <span class="paren2">(<span class=""/>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="string">"Здравствуй, мир"</span></span>)</span></span>)</span><br/></pre>

<p>SLIME также поможет вам в согласовании скобок – как только вы наберете закрывающую скобку, SLIME подсветит соответствующую открывающую скобку. Или вы можете просто набрать C-c C-q для вызова команды slime-close-parens-at-point, которая вставит столько закрывающих скобок, сколько нужно для согласования со всем открытыми скобками.
</p>
<p>Теперь вы можете отправить это определение в вашу среду Lisp несколькими способами. Самый простой - это набрать C-c C-c, когда курсор находится где-нибудь внутри или сразу после формы DEFUN, что вызовет команду slime-compile-defun, которая, в свою очередь, пошлет определение в Lisp для вычисления и компиляции. Для того, чтобы убедиться, что это работает, вы можете сделать несколько изменений в hello-world, перекомпилировать ее, а затем вернуться назад в REPL, используя C-c C-z или C-x b, и вызвать ее снова. Например, вы можете сделать эту функцию более грамматически правильной.
</p><pre class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm" class="symbol"><i><span class="symbol">defun</span></i></a> hello-world <span class="paren2">(<span class=""/>)</span><br/>  <span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm" class="symbol">format</a> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a> <span class="string">"Здравствуй, мир!"</span></span>)</span></span>)</span><br/></pre>
<p>Теперь перекомпилируем ее с помощью C-c C-c и перейдем в REPL, набрав C-c C-z, чтобы попробовать новую версию.
</p><pre> CL-USER&gt; (hello-world)<br/> Здравствуй, мир!<br/> NIL<br/></pre>
<p>Теперь вы возможно захотите сохранить файл, с которым работаете; находясь в буфере hello.lisp, наберите C-x C-s для вызова функции Emacs save-buffer.
</p>
<p>Теперь, для того, чтобы попробовать перезагрузить эту функцию из файла с исходным кодом, вы должны выйти из Lisp и перезапустить его. Для выхода вы можете использовать клавишную комбинацию SLIME: находясь в REPL, наберите запятую. Внизу окна Emacs вам будет предложено ввести команду. Наберите quit (или sayoonara), а затем нажмите Enter. Произойдет выход из Lisp, а все окна, созданные SLIME (такие как буфер REPL), закроются<a class="fn_top" id="fnt__13" href="lather-rinse-repeat-a-tour-of-the-repl#fn__13">13)</a>. Теперь перезапустите SLIME, набрав M-x slime.
</p>
<p>Просто ради интереса, вы можете попробовать вызвать hello-world.
</p><pre> CL-USER&gt; (hello-world)<br/></pre>
<p>После этого возникнет новый буфер SLIME, содержимое которого будет начинаться с чего-то вроде этого:
</p><pre>attempt to call `HELLO-WORLD' which is an undefined function.<br/>   [Condition of type UNDEFINED-FUNCTION]<br/>Restarts:<br/>   0: [TRY-AGAIN] Try calling HELLO-WORLD again.<br/>   1: [RETURN-VALUE] Return a value instead of calling HELLO-WORLD.<br/>   2: [USE-VALUE] Try calling a function other than HELLO-WORLD.<br/>   3: [STORE-VALUE] Setf the symbol-function of HELLO-WORLD and call it again.<br/>   4: [ABORT] Abort handling SLIME request.<br/>   5: [ABORT] Abort entirely from this process.<br/>Backtrace:<br/>  0: (SWANK::DEBUG-IN-EMACS #&lt;UNDEFINED-FUNCTION @ #x716b082a&gt;)<br/>  1: ((FLET SWANK:SWANK-DEBUGGER-HOOK SWANK::DEBUG-IT))<br/>  2: (SWANK:SWANK-DEBUGGER-HOOK #&lt;UNDEFINED-FUNCTION @ #x716b082a&gt; #&lt;Function SWANK-DEBUGGER-HOOK&gt;)<br/>  3: (ERROR #&lt;UNDEFINED-FUNCTION @ #x716b082a&gt;)<br/>  4: (EVAL (HELLO-WORLD))<br/>  5: (SWANK::EVAL-REGION "(hello-world)<br/>" T)<br/></pre>
<p>Что же произошло? Просто вы попытались вызвать функцию, которая не существует. Но не смотря на такое количество выведенной информации, Lisp на самом деле обрабатывает такую ситуацию изящно. В отличие от Java или Python, Common Lisp не просто генерирует исключение и разворачивает стек. И он точно не завершается, оставив после себя образ памяти (dump core), только потому, что вы попытались вызвать несуществующую функцию. Вместо этого он перенесет вас в отладчик.
</p>
<p>Во время работы с отладчиком вы все еще имеете полный доступ к Lisp, поэтому вы можете вычислять выражения для исследования состояния вашей программы и может быть даже для исправления каких-то вещей. Сейчас не стоит беспокоиться об этом; просто наберите q для выхода из отладчика и возвращения назад в REPL. Буфер отладчика исчезнет, а REPL выведет следующее:
</p><pre>CL-USER&gt; (hello-world) <br/>; Evaluation aborted<br/>CL-USER&gt;<br/></pre>
<p>Конечно, в отладчике можно сделать гораздо больше, чем просто выйти из него – в главе 19 мы увидим, например, как отладчик интегрируется с системой обработки ошибок. А сейчас, однако, важной вещью, которую нужно знать, является то, что вы всегда можете выйти из отладчика и вернуться обратно в REPL, набрав q.
</p>
<p>Вернувшись в REPL вы можете попробовать снова. Ошибка произошла, потому что Lisp не знает определения hello-world. Поэтому вам нужно предоставить Lisp определение, сохраненное нами в файле hello.lisp. Вы можете сделать это несколькими способами. Вы можете переключиться назад в буфер, содержащий файл (наберите C-x b, а затем введите hello.lisp) и перекомпилировать определение, как вы это делали ранее с помощью C-c C-c. Или вы можете загрузить файл целиком (что будет более удобным способом, если файл содержит множество определений) путем использования функции LOAD в REPL следующим образом:
</p><pre>CL-USER&gt; (load "hello.lisp")<br/>; Loading /home/peter/my-lisp-programs/hello.lisp<br/>T<br/></pre>
<p>T означает, что загрузка всех определений произошла успешно<a class="fn_top" id="fnt__14" href="lather-rinse-repeat-a-tour-of-the-repl#fn__14">14)</a>. Загрузка файла с помощью LOAD в сущности эквивалентна набору каждого выражения этого файла в REPL в том порядке, в каком они находятся в файле, таким образом, после вызова LOAD, hello-world должен быть определен.
</p><pre>CL-USER&gt; (hello-world)<br/>Здравствуй, мир!<br/>NIL<br/></pre>
<p>Еще один способ загрузки определений файла - предварительная компиляция файла с помощью COMPILE-FILE, а затем загрузка (с помощью LOAD) уже скомпилированного файла, называемого FASL-файлом, что является сокращением для fast-load file (быстро загружаемый файл). COMPILE-FILE возвращает имя FASL-файла, таким образом мы можем скомпилировать и загрузить файл из REPL следующим образом:
</p><pre>CL-USER&gt; (load (compile-file "hello.lisp"))<br/>;;; Compiling file hello.lisp<br/>;;; Writing fasl file hello.fasl<br/>;;; Fasl write complete<br/>; Fast loading /home/peter/my-lisp-programs/hello.fasl<br/>T<br/></pre>
<p>SLIME также предоставляет возможность загрузки и компиляции файлов без использования REPL. Когда вы находитесь в буфере с исходным кодом, вы можете использовать C-c C-l для загрузки файла с помощью slime-load-file. Emacs выведет запрос имени файла для загрузки с уже введенным именем текущего файла; вы можете просто нажать Enter. Или же вы можете набрать C-c C-k для компиляции и загрузки файла, представляемого текущим буфером. В некоторых реализациях Common Lisp компилирование кода таким образом выполнится немного быстрее; в других - нет, обычно потому что они всегда компилируют весь файл целиком.
</p>
<p>Этого должно быть достаточно, чтобы дать вам почувствовать красоту того, как осуществляется программирование на Lisp. Конечно, я пока не описал всех трюков и техник, но вы увидели важнейшие элементы – взаимодействие с REPL, загрузку и тестирование нового кода, настройку и отладку. Серьезные хакеры Lisp часто держат образ Lisp непрерывно запущенным многие дни, добавляя, переопределяя и тестируя части своих программ инкрементально.
</p>
<p>Кроме того, даже если приложение, написанное на Lisp, уже развернуто, часто существует возможность обратиться к REPL. В главе 26 вы увидите как можно использовать REPL и SLIME для взаимодействия с Lisp, запустившим Web-сервер, в то же самое время, когда он продолжает отдавать Web-страницы. Возможно даже использовать SLIME для соединения с Lisp,  запущенным на другой машине, что позволяет, например, отлаживать удаленный сервер так же, как локальный.
</p>

<p>И даже более впечатляющий пример удаленной отладки произошел в миссии NASA "Deep Space 1" в 1998 году. Через полгода после запуска космического корабля, небольшой код на Lisp  должен был управлять космическим кораблем в течении двух дней для проведения серии экспериментов. Однако, неуловимое состояние гонки (race condition) в коде не было выявлено при тестировании на земле и было обнаружено уже в космосе. Когда ошибка была выявлена в космосе (100 миллионов миль от Земли) команда смогла произвести диагностику и исправление работающего кода, что позволило завершить эксперимент<a class="fn_top" id="fnt__15" href="lather-rinse-repeat-a-tour-of-the-repl#fn__15">15)</a>. Один из программистов сказал об этом следующее:
</p>
<p>Отладка программы, работающей на оборудовании стоимостью 100 миллионов долларов, которая находится в 100 миллионах миль от вас, является интересным опытом. REPL, работающий на космическом корабле, предоставляет бесценные возможности в нахождении и устранении проблем.
</p>
<p>Вы пока не готовы отправлять какой бы то ни было код Lisp в дальний космос, но в следующей главе вы напишите программу, которая немного более интересна, чем "Здравствуй, мир!".
</p>
</div></div><div class="footnotes"><div><a class="fn_bot" id="fn__1" href="lather-rinse-repeat-a-tour-of-the-repl#fnt__1">1)</a>Superior Lisp Interaction Mode for Emacs</div><div><a class="fn_bot" id="fn__2" href="lather-rinse-repeat-a-tour-of-the-repl#fnt__2">2)</a>Если у вас уже был неудачный опыт работы с Emacs, то вы должны знать, что Lisp in a Box — IDE, имеющая в своём составе Emacs-подобный редактор и не требующая от вас отличного знания Emacs для программирования на Lisp. Однако с использованием текстового редактора, имеющего некоторую базовую поддержку Lisp, программировать будет на порядок приятнее. Наверняка вам захочется, чтобы редактор автоматически помечал парные скобки и сам мог расставить отступы в коде на Lisp. Так как Emacs почти целиком написан на одном из диалектов Lisp, Elisp, он имеет довольно хорошую поддержку редактирования такого кода. История Emacs неразрывно связана с историей Lisp и культурой Lisp-хакеров: первые версии Emacs, как и его непосредственные предшественники <strong>TECMACS</strong> и <strong>TMACS</strong>, были написаны заинтересованными в Lisp разработчиками в Массачусетском Технологическом Институте (MIT). Редакторами, использовавшимися на Lisp-машинах, были версии Emacs, целиком написанные на Lisp. Под влиянием любви хакеров к рекурсивным акронимам две первые реализации Emacs для Lisp-машин были названы <strong>EINE</strong> и <strong>ZWEI</strong>, что означало "EINE Is Not Emacs" и "ZWEI Was EINE Initially" соответственно. Некоторое время был распространён производный от ZWEI редактор, названный более прозаично, <strong>ZMACS</strong>.</div><div><a class="fn_bot" id="fn__3" href="lather-rinse-repeat-a-tour-of-the-repl#fnt__3">3)</a>На самом деле, существует очень малая вероятность пересмотра стандарта языка. Хотя существует некоторое количество недостатков, которые пользователи языка могут желать исправить, согласно процессу стандартизации ANSI существующий стандарт не подлежит открытию для внесения небольших изменений, и эти недостатки, на самом деле, не вызывают ни у кого серьёзных трудностей. Возможно, будущее стандартизации Common Lisp — за стандартами "де-факто", больше похожее на "стандартизацию" Perl и Python, когда различные разработчики экспериментируют с интерфейсами прикладного программирования (API) и библиотеками для реализации вещей, не описанных в стандарте языка, а другие разработчики могут принимать их; или заинтересованные программисты будут разрабатывать переносимые библиотеки для сглаживания различий между реализациями возможностей, не описанных в стандарте языка.</div><div><a class="fn_bot" id="fn__4" href="lather-rinse-repeat-a-tour-of-the-repl#fnt__4">4)</a>Steel Bank Common Lisp</div><div><a class="fn_bot" id="fn__5" href="lather-rinse-repeat-a-tour-of-the-repl#fnt__5">5)</a>CMU Common Lisp</div><div><a class="fn_bot" id="fn__6" href="lather-rinse-repeat-a-tour-of-the-repl#fnt__6">6)</a>SBCL стал "ответвлением" CMUCL, так как его разработчики хотели сосредоточиться на упорядочивании его внутренней организации и сделать его легче в сопровождении. "Ответвление" вышло очень удачным. Исправления ошибок привели к появлению серьёзных различий между двумя проектами, и, как теперь поговаривают, их снова планируют объединить.</div><div><a class="fn_bot" id="fn__7" href="lather-rinse-repeat-a-tour-of-the-repl#fnt__7">7)</a>Для использования русского языка необходима соотв. настройка Emacs, Slime(cvs-версия), и Вашего интерпретатора LISP. – прим. переводчика</div><div><a class="fn_bot" id="fn__8" href="lather-rinse-repeat-a-tour-of-the-repl#fnt__8">8)</a>Досточтимая фраза "hello, world" предшествует даже классической книге по языку C Кернигана и Ритчи, которая сыграла огромную роль в её популяризации. Первоначальный "hello, world" похоже пришёл из книги Брайана Кернигана "A Tutorial Introduction to the Language B", которая была частью Bell Laboratories Computing Science Technical Report #8: The Programming Language B, опубликованного в январе 1973 г. (Отчёт выложен в интернет <a href="http://cm.bell-labs.com/cm/cs/who/dmr/bintro.html.">http://cm.bell-labs.com/cm/cs/who/dmr/bintro.html.</a>) </div><div><a class="fn_bot" id="fn__9" href="lather-rinse-repeat-a-tour-of-the-repl#fnt__9">9)</a>Есть несколько других выражений, которые тоже выводят строку "Здравствуй, мир"</div><div><a class="fn_bot" id="fn__10" href="lather-rinse-repeat-a-tour-of-the-repl#fnt__10">10)</a>На самом деле, как вы увидите, когда будет рассказано о возврате множественных значений, технически возможно написание выражений, которые не вычисляются ни в какие значения, но даже такие выражения рассматриваются как возвращающие NIL при вычислении в контексте, ожидающем возврата значения</div><div><a class="fn_bot" id="fn__11" href="lather-rinse-repeat-a-tour-of-the-repl#fnt__11">11)</a>В главе 4 будет рассказано, почему имя преобразуется в верхний регистр</div><div><a class="fn_bot" id="fn__12" href="lather-rinse-repeat-a-tour-of-the-repl#fnt__12">12)</a>Вы также можете ввести определение в двух строках в REPL, так как REPL читает выражение целиком, а не по строкам</div><div><a class="fn_bot" id="fn__13" href="lather-rinse-repeat-a-tour-of-the-repl#fnt__13">13)</a>клавишные комбинации SLIME – это не часть Common Lisp, это команды SLIME</div><div><a class="fn_bot" id="fn__14" href="lather-rinse-repeat-a-tour-of-the-repl#fnt__14">14)</a>Если по каким-то причинам LOAD не выполнилась успешно, вы получите другую ошибку и будете перенаправлены в отладчик. Если это произошло, наиболее вероятной причиной может быть то, что Lisp не может найти файл, возможно из-за того, что его текущая директория не совпадает с той, в которой находится файл. В этом случае вы можете выйти из отладчика, набрав q, а затем использовать клавиатурную комбинацию SLIME cd для изменения текущей директории – наберите запятую, а затем на приглашние к вводу команды – cd и имя директории, где был сохранен hello.lisp</div><div><a class="fn_bot" id="fn__15" href="lather-rinse-repeat-a-tour-of-the-repl#fnt__15">15)</a><a href="http://www.flownet.com/gat/jpl-lisp.html">http://www.flownet.com/gat/jpl-lisp.html</a></div></div></div> <table width="100%"> <tbody> <tr> <td width="20%" align="left"> <a href="introduction-why-lisp">Предыдущая</a> </td> <td width="60%" align="center"> <a href="index.html">Оглавление</a> </td> <td width="20%" align="right"> <a href="practical-a-simple-database">Следующая</a> </td> </tr> </tbody> </table> </div> <div class="bottom">@2009-2013 lisper.ru</div> 
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7734690-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
 </body> </html>