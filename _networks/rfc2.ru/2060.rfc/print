<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../2060.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 2060 — Протокол IMAP v.4, rev. 1</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../2060.rfc">RFC 2060 — Протокол IMAP v.4, rev. 1</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 2060</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank"><span itemprop="alternativeHeadline">Internet Message Access Protocol v.4 rev.1</span></a></dd><dd><div class="icon i7"></div> Другие версии: RFC 1730, <strong class="obsoleted_by">RFC 3501</strong></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Предложенный стандарт</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1996-12-01">Декабрь 1996</time></dd><dd><div class="icon i5"></div> Автор: <span itemprop="author">M. Crispin</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div id="text" itemprop="articleBody"><h3>Статус документа</h3><p>Этот документ содержит предлагаемый стандарт протокола (standards track protocol) для сообщества Internet и является запросом к обсуждению в целях развития стандарта. Информацию о текущем состоянии стандартизации протокола можно найти в Internet Official Protocol Standards (STD 1). Документ может распространяться свободно.</p><h3>Тезисы</h3><p>Протокол IMAP4rev1 (Internet Message Access Protocol, Version 4rev1) обеспечивает клиентам возможность доступа и манипуляций с почтовыми сообщениями на сервере. IMAP4rev1 разрешает манипуляции с удаленными папками сообщений, называемыми почтовыми ящиками (mailboxes), как с локальными почтовыми ящиками. IMAP4rev1 также позволяет offline-клиентам синхронизировать почтовые ящики с сервером (см. [IMAP-DISC]).</p><p>IMAP4rev1 включает операции создания, удаления и переименования почтовых ящиков, проверки наличия новых сообщений, удаления сообщений навсегда, установки и сброса флагов, разбора [RFC-822] и [MIME-IMB]; поиска и селективной выборки атрибутов сообщений, текста или их фрагментов. Доступ к сообщениям в IMAP4rev1 обеспечивается по номерам сообщений, которые просто присваиваются по порядку или задаются с обеспечением уникальности каждого номера.</p><p>Протокол IMAP4rev1 поддерживает один сервер. Механизм настройки конфигурации для поддержки множества серверов IMAP4rev1 обсуждается в работе [ACAP].</p><p>IMAP4rev1 не поддерживает функций передачи почты, для решения таких задач служат транспортные почтовые протоколы типа [SMTP].</p><p>При разработке IMAP4rev1 учитывалось требование совместимости с [IMAP2] и неопубликованным протоколом IMAP2bis. По мере разработки IMAP4rev1 от некоторых возможностей ранних версий протоколов пришлось отказаться. Устаревшие команды, отклики и форматы данных, с которыми реализация IMAP4rev1 может встретиться при работе с ранними версиями, описаны в [IMAP-OBSOLETE]. Другие вопросы совместимости с IMAP2bis (наиболее распространенный вариант ранних протоколов) обсуждаются в работе [IMAP-COMPAT]. Полное рассмотрение вопросов совместимости с редкими (и практически вымершими) вариантами [IMAP2] приводится в [IMAP-HISTORICAL] — этот документ представляет в основном исторический интерес.</p><h2>Оглавление</h2><ul class="map"><li><a href="print#p1">1. Как работать с документом</a></li><li class="lia"><a href="print#p1.1">1.1. Структура документа</a></li><li class="lia"><a href="print#p1.2">1.2. Используемые соглашения</a></li><li><a href="print#p2">2. Обзор</a></li><li class="lia"><a href="print#p2.1">2.1. Канальный уровень</a></li><li class="lia"><a href="print#p2.2">2.2. Команды и отклики</a></li><li class="lib"><a href="print#p2.2.1">2.2.1. Передатчик клиента и приемник сервера</a></li><li class="lib"><a href="print#p2.2.2">2.2.2. Приемник клиента и передатчик сервера</a></li><li class="lia"><a href="print#p2.3">2.3. Атрибуты сообщения</a></li><li class="lib"><a href="print#p2.3.1">2.3.1. Номера сообщений</a></li><li class="lic"><a href="print#p2.3.1.1">2.3.1.1. Уникальный идентификатор сообщения (UID)</a></li><li class="lic"><a href="print#p2.3.1.2">2.3.1.2. Порядковый номер сообщения</a></li><li class="lib"><a href="print#p2.3.2">2.3.2. Флаги сообщения</a></li><li class="lib"><a href="print#p2.3.3">2.3.3. Внутренняя дата сообщения</a></li><li class="lib"><a href="print#p2.3.4">2.3.4. Размер сообщения [RFC-822]</a></li><li class="lib"><a href="print#p2.3.5">2.3.5. Структура конверта</a></li><li class="lib"><a href="print#p2.3.6">2.3.6. Структура тела сообщения (Body Structure)</a></li><li class="lia"><a href="print#p2.4">2.4. Текст сообщения</a></li><li><a href="print#p3">3. Состояния сервера и команды</a></li><li class="lia"><a href="print#p3.1">3.1. Состояние Non-Authenticated</a></li><li class="lia"><a href="print#p3.2">3.2. Состояние Authenticated</a></li><li class="lia"><a href="print#p3.3">3.3. Состояние Selected</a></li><li class="lia"><a href="print#p3.4">3.4. Состояние Logout</a></li><li><a href="print#p4">4. Форматы данных</a></li><li class="lia"><a href="print#p4.1">4.1. Атом (Atom)</a></li><li class="lia"><a href="print#p4.2">4.2. Число</a></li><li class="lia"><a href="print#p4.3">4.3. Строка</a></li><li class="lib"><a href="print#p4.3.1">4.3.1. 8-битовые и двоичные строки</a></li><li class="lib"><a href="print#p4.4">4.4. Список в скобках (Parenthesized List)</a></li><li class="lib"><a href="print#p4.5">4.5. Пустой формат (NIL)</a></li><li><a href="print#p5">5. Работа протокола</a></li><li class="lia"><a href="print#p5.1">5.1. Именование почтовых ящиков</a></li><li class="lib"><a href="print#p5.1.1">5.1.1. Иерархия имен</a></li><li class="lib"><a href="print#p5.1.2">5.1.2. Соглашение о пространстве имен</a></li><li class="lib"><a href="print#p5.1.3">5.1.3. Соглашение об использовании других языков в именах</a></li><li class="lia"><a href="print#p5.2">5.2. Обновление размеров и статуса сообщений</a></li><li class="lia"><a href="print#p5.3">5.3. Отклики при отсутствии обрабатываемых команд</a></li><li class="lia"><a href="print#p5.4">5.4. Таймер автоматического отключения</a></li><li class="lia"><a href="print#p5.5">5.5. Обработка множества команд</a></li><li><a href="print#p6">6. Команды клиента</a></li><li class="lia"><a href="print#p6.1">6.1. Команды клиента для любого состояния</a></li><li class="lib"><a href="print#p6.1.1">6.1.1. Команда CAPABILITY</a></li><li class="lib"><a href="print#p6.1.2">6.1.2. Команда NOOP</a></li><li class="lib"><a href="print#p6.1.3">6.1.3. Команда LOGOUT</a></li><li class="lia"><a href="print#p6.2">6.2. Клиентские команды — состояние Non-Authenticated</a></li><li class="lib"><a href="print#p6.2.1">6.2.1. Команда AUTHENTICATE</a></li><li class="lib"><a href="print#p6.2.2">6.2.2. Команда LOGIN</a></li><li class="lia"><a href="print#p6.3">6.3. Команды клиента — состояние Authenticated</a></li><li class="lib"><a href="print#p6.3.1">6.3.1. Команда SELECT</a></li><li class="lib"><a href="print#p6.3.2">6.3.2. Команда EXAMINE</a></li><li class="lib"><a href="print#p6.3.3">6.3.3. Команда CREATE</a></li><li class="lib"><a href="print#p6.3.4">6.3.4. Команда DELETE</a></li><li class="lib"><a href="print#p6.3.5">6.3.5. Команда RENAME</a></li><li class="lib"><a href="print#p6.3.6">6.3.6. Команда SUBSCRIBE</a></li><li class="lib"><a href="print#p6.3.7">6.3.7. Команда UNSUBSCRIBE</a></li><li class="lib"><a href="print#p6.3.8">6.3.8. Команда LIST</a></li><li class="lib"><a href="print#p6.3.9">6.3.9. Команда LSUB</a></li><li class="lib"><a href="print#p6.3.10">6.3.10. Команда STATUS</a></li><li class="lib"><a href="print#p6.3.11">6.3.11. Команда APPEND</a></li><li class="lia"><a href="print#p6.4">6.4. Команды клиента — состояние Selected</a></li><li class="lib"><a href="print#p6.4.1">6.4.1. Команда CHECK</a></li><li class="lib"><a href="print#p6.4.2">6.4.2. Команда CLOSE</a></li><li class="lib"><a href="print#p6.4.3">6.4.3. Команда EXPUNGE</a></li><li class="lib"><a href="print#p6.4.4">6.4.4. Команда SEARCH</a></li><li class="lib"><a href="print#p6.4.5">6.4.5. Команда FETCH</a></li><li class="lib"><a href="print#p6.4.6">6.4.6. Команда STORE</a></li><li class="lib"><a href="print#p6.4.7">6.4.7. Команда COPY</a></li><li class="lib"><a href="print#p6.4.8">6.4.8. Команда UID</a></li><li class="lia"><a href="print#p6.5">6.5. Команды клиента — экспериментальные/расширения</a></li><li class="lib"><a href="print#p6.5.1">6.5.1. Команда X&lt;atom&gt;</a></li><li><a href="print#p7">7. Отклики сервера</a></li><li class="lia"><a href="print#p7.1">7.1. Отклики сервера — состояние</a></li><li class="lib"><a href="print#p7.1.1">7.1.1. Отклик OK</a></li><li class="lib"><a href="print#p7.1.2">7.1.2. Отклик NO</a></li><li class="lib"><a href="print#p7.1.3">7.1.3. Отклик BAD</a></li><li class="lib"><a href="print#p7.1.4">7.1.4. Отклик PREAUTH</a></li><li class="lib"><a href="print#p7.1.5">7.1.5. Отклик BYE</a></li><li class="lia"><a href="print#p7.2">7.2. Отклики сервера — состояние сервера и почтового ящика</a></li><li class="lib"><a href="print#p7.2.1">7.2.1. Отклик CAPABILITY</a></li><li class="lib"><a href="print#p7.2.2">7.2.2. Отклик LIST</a></li><li class="lib"><a href="print#p7.2.3">7.2.3. Отклик LSUB</a></li><li class="lib"><a href="print#p7.2.4">7.2.4. Отклик STATUS</a></li><li class="lib"><a href="print#p7.2.5">7.2.5. Отклик SEARCH</a></li><li class="lib"><a href="print#p7.2.6">7.2.6. Отклик FLAGS</a></li><li class="lia"><a href="print#p7.3">7.3. Отклики сервера — размер почтового ящика</a></li><li class="lib"><a href="print#p7.3.1">7.3.1. Отклик EXISTS</a></li><li class="lib"><a href="print#p7.3.2">7.3.2. Отклик RECENT</a></li><li class="lia"><a href="print#p7.4">7.4. Отклики сервера — сообщение о состоянии</a></li><li class="lib"><a href="print#p7.4.1">7.4.1. Отклик EXPUNGE</a></li><li class="lib"><a href="print#p7.4.2">7.4.2. Отклик FETCH</a></li><li class="lia"><a href="print#p7.5">7.5. Отклики сервера — запрос продолжения команды</a></li><li><a href="print#p8">8. Пример соединения IMAP4rev1</a></li><li><a href="print#p9">9. Формальный синтаксис</a></li><li><a href="print#p10">10. Примечание автора</a></li><li><a href="print#p11">11. Вопросы безопасности</a></li><li><a href="print#p12">12. Адрес автора</a></li><li><a href="print#p.appendix">Приложения</a></li><li><a href="print#p.appendix.a">A. Литература</a></li><li><a href="print#p.appendix.b">B. Изменения по отношению к RFC 1730</a></li></ul><h2 id="p1">1. Как работать с документом</h2><h3 id="p1.1">1.1. Структура документа</h3><p>Этот документ представляет протокол с точки зрения разработчика клиента или сервера IMAP4rev1. Кроме обзора главе 2, документ не содержит каких-либо материалов, помогающих понять работу протокола. Главы 3 - 5 содержат общий контекст и определения, используемые IMAP4rev1.</p><p>В главах 6, 7 и 9 описаны команды, отклики и синтаксис, соответственно. Соотношения между ними таковы, что почти невозможно разобраться с протоколом, рассматривая команды, отклики и синтаксис по отдельности. В частности, не следует пытаться вывести синтаксис команд, прочтя лишь их описание — обратитесь к главе, описывающей синтаксис.</p><h3 id="p1.2">1.2. Используемые соглашения</h3><p>В примерах обозначения C: и S: показывают строки, передаваемые клиентом и сервером, соответственно. Термины, используемые для обозначения уровня требований, растолкованы ниже.</p><ol><li class="b">MUST — необходимо</li><li class="lib"><p>Это слово, а также термины требуется (обязательно) и нужно (SHALL) используется для требований, которые являются абсолютно необходимыми в данной спецификации.</p></li><li class="b">MUST NOT — недопустимо</li><li class="lib"><p>Эта фраза или слова SHALL NOT (не позволяется) означают абсолютный запрет в рамках спецификации.</p></li><li class="b">SHOULD — следует</li><li class="lib"><p>Это слово, а также глагол рекомендуется (RECOMMENDED) используется для обозначения требований, от выполнения которых можно отказаться при наличии разумных причин. Однако при таком отказе следует помнить о возможных проблемах в результате отказа и принимать взвешенное решение.</p></li><li class="b">SHOULD NOT — не следует</li><li class="lib"><p>Эта фраза и глагол не рекомендуется (NOT RECOMMENDED) используются применительно к особенностям или функциям, которые допустимы и могут быть полезными, но могут вызывать проблемы. При реализации таких опций следует учитывать возможность возникновения проблем и принимать взвешенное решение.</p></li><li class="b">MAY — возможно</li><li class="lib"><p>Это слово, а также прилагательное необязательный (дополнительно) обозначают элементы, реализация которых является необязательной. Одни разработчики могут включать такие опции в свою продукцию для расширения возможностей, а другие — опускать в целях упрощения. Реализация, не включающая ту или иную опцию, должна быть готова к работе с реализациями, которые используют эту опцию (возможно совместная работа будет обеспечиваться за счет некоторого ущерба функциональности). Включающие опцию реализации ДОЛЖНЫ быть готовы (естественно, без использования такой опции) к взаимодействию с реализациями, которые такую опцию не поддерживают.</p></li></ol><p>Термин «пользователь» (User) используется для обозначения человека, а слово «клиент» обозначает пользовательские программы.</p><p>Термин «соединение» (Connection) описывает всю последовательность операций взаимодействия между клиентом и сервером от момента организации связи и до ее завершения. Термины «сеанс» или «сессия» (Session) обозначают последовательность операций обмена между клиентом и сервером с момента выбора почтового ящика (команда SELECT или EXAMINE) и до отмены этого выбора (команда SELECT или EXAMINE для другого почтового ящика, команда CLOSE или разрыв соединения).</p><p>Символом будем называть 7-битовый символ из набора US-ASCII, если явно не указано иное. Другие символьные наборы обозначаются с использованием CHARSET, как описано в [MIME-IMT] и определено в [CHARSET]. Опция CHARSET имеет дополнительную семантику, описанную в вышеупомянутых работах.</p><h2 id="p2">2. Обзор</h2><h3 id="p2.1">2.1. Канальный уровень</h3><p>Протокол IMAP4rev1 предполагает наличие гарантированного потока данных (например, от TCP). При использовании транспортного протокола TCP сервер IMAP4rev1 прослушивает порт 143.</p><h3 id="p2.2">2.2. Команды и отклики</h3><p>Соединение IMAP4rev1 включает организацию связи между клиентом и сервером, стартовое приветствие сервера и операции взаимодействия между клиентом и сервером (команды клиента, данные от сервера, отклики сервера). Все взаимодействие между клиентом и сервером происходит в форме обмена текстовыми строками, завершающимися последовательностью CRLF. Получатель IMAP4rev1 (клиент или сервер) читает строку или последовательность из заданного числа октетов, следующих за ней.</p><h4 id="p2.2.1">2.2.1. Передатчик клиента и приемник сервера</h4><p>Взаимодействие начинается с команды клиента. Каждая команда начинается с префикса-идентификатора (обычно короткая последовательность букв и цифр типа A0001, A0002 и т. п.), называемого тегом (tag). Теги генерируются клиентом для каждой команды.</p><p>Существует два случая, когда строка от клиента не содержит полной команды — в одном случае сопровождаются счетчиком октетов (см. описание String в главе 4. Форматы данных ), в другом — аргументы команды требуют отклика от сервера (см. описание команды AUTHENTICATE). В обоих случаях сервер передает в ответ на команду соответствующий отклик с запросом продолжения команды (если сервер готов к приему имеющихся у клиента данных и оставшейся части команды). Эти отклики начинаются с префикса "+".</p><p>Приемник IMAP4rev1 на сервере читает строку команды от клиента, разбирает ее, отделяя команду от аргументов, и передает серверу, а тот генерирует отклик о завершении команды.</p><h4 id="p2.2.2">2.2.2. Приемник клиента и передатчик сервера</h4><p>Данные, передаваемые сервером клиенту и отклики о состоянии, не показывающие завершение команды, передаются с префиксом "*" и называются откликами без пометок (untagged).</p><p>Данные от сервера могут передаваться в результате клиентской команды, а могут генерироваться по инициативе сервера. Между этими данными нет никакой синтаксической разницы.</p><p>Отклик от сервера о завершении команды показывает результат операции. Он помечается тегом клиентской команды, послужившей началом операции. Таким образом, при одновременной обработке множества команд тег в отклике сервера позволяет идентифицировать команду, с которой связан отклик. Существуют три варианта откликов о завершении команды — OK (успешное завершение), NO (неудача) и BAD (ошибка протокола — например, нераспознанная команда или некорректный синтаксис).</p><p>Приемник IMAP4rev1 у клиента читает строку отклика от сервера и предпринимает в ответ на нее действия, в зависимости от префикса в отклике (тег, "*" или "+"). Клиент ДОЛЖЕН быть постоянно готов к восприятию любых откликов от сервера. Принятые от сервера данные следует записывать, чтобы впоследствии клиент мог обращаться к сохраненным данным, не запрашивая их у сервера повторно. В некоторых случаях данные ДОЛЖНЫ записываться. Этот вопрос более подробно рассматривается ниже (см. 7. Отклики сервера).</p><h3 id="p2.3">2.3. Атрибуты сообщения</h3><p>Кроме текста каждое сообщение содержит набор связанных с ним атрибутов. Эти атрибуты можно отыскивать вместе с текстом сообщения или независимо от него.</p><h4 id="p2.3.1">2.3.1. Номера сообщений</h4><p>Доступ к сообщениям IMAP4rev1 обеспечивается по одному из двух номеров — идентификатору сообщения или уникальному идентификатору.</p><h5 id="p2.3.1.1">2.3.1.1. Уникальный идентификатор сообщения (UID)</h5><p>32-битовый идентификатор, присваиваемый каждому сообщению и совместно с уникальным идентификатором корректности (см. ниже) образующий 64-битовое значение, для которого гарантируется уникальность в масштабе почтового ящика. Уникальные номера для каждого почтового ящика выделяются строго по нарастанию — каждое новое сообщение имеет значение UID, превышающее идентификаторы добавленных ранее сообщений. В отличие от порядковых номеров уникальные идентификаторы не обязаны следовать непрерывно и сохраняются только в течение одного сеанса. Это позволяет клиенту ресинхронизировать свое состояние по отношению к предыдущему сеансу (например, для отключенных или сеансовых клиентов). Вопросы синхронизации обсуждаются в работе [IMAPDISC].</p><p>С каждым почтовым ящиком связывается уникальный идентификатор корректности, который передается в коде UIDVALIDITY неотмеченных откликов OK при выборе почтового ящика. Если уникальные идентификаторы из предыдущего сеанса не могут использоваться в данной сессии, новое значение уникального идентификатора корректности должно быть больше, чем использованное в предыдущем сеансе значение.</p><p>Note: Значения уникальных идентификаторов для почтового ящика ДОЛЖНЫ строго возрастать. Если физически сообщения сохраняются агентом, отличным от IMAP, в ином порядке или неупорядочены, это требует регенерации уникальных идентификаторов для почтового ящика, поскольку прежние уникальные идентификаторы не будут идти строго по возрастанию в результате изменения порядка. Другим случаем регенерации уникальных идентификаторов являются системы, в которых при хранении сообщений не поддерживается механизм уникальной идентификации. Признавая, что это может быть неприемлемо для некоторых серверных сред, настоящая спецификация настоятельно рекомендует использовать системы хранения сообщений, позволяющие избежать этой проблемы.</p><p>Другой причиной невозможности использования прежних идентификаторов является случай, когда почтовый ящик удаляется и вместо него позднее создается новый ящик с таким же именем. Поскольку имена ящиков совпадают, клиент может не знать о том, что это новый ящик, если уникальные идентификаторы корректности не отличаются. Эффективным выходом будет использование в качестве уникальных идентификаторов корректности 32-битовое представление даты и времени создания почтовых ящиков. Можно использовать и константы (например, 1), если обеспечивается невозможность их повторного использования даже в случаях удалением или переименования почтовых ящиков с последующим созданием ящика с прежним именем.</p><p>Уникальный идентификатор сообщения НЕДОПУСТИМО изменять в течение сеанса и не следует менять между сессиями. Однако, если для следующего сеанса сохранение уникального идентификатора невозможно, новое значение должно быть больше предыдущего.</p><h5 id="p2.3.1.2">2.3.1.2. Порядковый номер сообщения</h5><p>Относительные номера сообщений (от 1 до текущего числа писем в ящике). Номера ДОЛЖНЫ упорядочиваться в соответствии с увеличением уникальных идентификаторов. При добавлении каждого нового сообщения ему присваивается следующий свободный номер (на 1 больше последнего из использованных номеров).</p><p>Порядковые номера сообщений могут изменяться в течение сеанса. Например, при полном удалении письма из ящика порядковые номера всех последующих сообщений уменьшаются.</p><p>Кроме идентификации сообщений в смысле доступа к ним, порядковые номера могут использоваться в расчетах. Например, при получении неотмеченного отклика EXISTS 11 после того, как был получен неотмеченный отклик 8 EXISTS, позволяет вычислить, что были получены три новых сообщения — 9, 10, 11. Другой пример: если сообщение с номером 287 в ящике, содержащем 523 письма, имеет UID 12345, значит 286 сообщений имеют меньшие значения UID, а 236 — большие UID.</p><h4 id="p2.3.2">2.3.2. Флаги сообщения</h4><p>С сообщением связывается список (возможно пустой) именованных маркеров (флагов). Установка флагов обеспечивается их включением в список, сброс — удалением из списка. Протокол IMAP4rev1 поддерживает два типа флагов — для сессии и постоянные.</p><p>Имена системных флагов определяются настоящей спецификацией (см. таблицу). Все системные флаги начинаются с
символа "\". Некоторые из системных флагов (\Deleted и \Seen) используют специальную семантику.</p><p>Если невозможно определить, является ли сеанс для данного сообщения первым, сообщение следует рассматривать как новое (установить флаг).</p><p>Если с одним почтовым ящиком одновременно организовано более одного соединения, невозможно определить для каких сеансов будет установлен флаг \Recent.</p><table><tr><td>\Seen</td><td>Сообщение было прочитано.</td></tr><tr><td>\Answered</td><td>На сообщение был отправлен ответ.</td></tr><tr><td>\Flagged</td><td>Флаг важности сообщения.</td></tr><tr><td>\Deleted</td><td>Сообщение «удалено» для последующего уничтожения с помощью EXPUNGE.</td></tr><tr><td>\Draft</td><td>Сообщение не закончено (помечено как черновик — draft).</td></tr><tr><td>\Recent</td><td><p>Сообщение недавно доставлено в почтовый ящик. Этот сеанс является первым, в котором это сообщение появилось. Следующие сеансы не будут устанавливать флаг \Recent для этого сообщения. Это флаг не может быть изменен клиентом.</p><p>Если невозможно определить, является ли сеанс для данного сообщения первым, сообщение следует рассматривать как новое (установить флаг).</p><p>Если с одним почтовым ящиком одновременно организовано более одного соединения, невозможно определить для каких сеансов будет установлен флаг \Recent.</p></td></tr></table><p>Имена флагов задаются разработчиками сервера и не ДОЛЖНЫ начинаться с символа "\". Серверы могут позволять клиенту определять новые имена флагов в почтовом ящике (см. описание отклика PERMANENTFLAGS).</p><p>Флаги могут быть постоянными или сеансовыми (для каждого флага это определяется независимо). К постоянным относятся те флаги, клиент сохраняются после завершения сеанса, т. е. в следующем сеансе они будут иметь те же значения. Изменения сеансовых флагов сохраняются только в течение сеанса. Флаг \Recent представляет собой специальный случай сеансового системного флага (этот флаг не может использоваться в качестве аргумента команды STORE).</p><h4 id="p2.3.3">2.3.3. Внутренняя дата сообщения</h4><p>Внутренние значения даты и времени сообщения на сервере. Это не дата и время заголовка [RFC-822], а дата и время приема сообщения. Для сообщений, доставленных по протоколу SMTP, в этот атрибут следует включать дату и время окончательной доставки сообщения, в соответствии с [SMTP]. Для сообщений, доставленных с помощью команды IMAP4rev1 COPY, в этот атрибут следует включать внутренние значения даты и времени отправителя. Для сообщений, поступивших в результате использования команды IMAP4rev1 APPEND, в этот атрибут следует включать дату и время, указанные в описании команды APPEND. Во всех других случаях значение атрибута определяется используемой реализацией.</p><h4 id="p2.3.4">2.3.4. Размер сообщения [RFC-822]</h4><p>Число октетов в сообщении, выраженное в формате [RFC-822].</p><h4 id="p2.3.5">2.3.5. Структура конверта</h4><p>Разобранное представление информации из конверта [RFC-822] (не следует путать с конвертом [SMTP] сообщения.</p><h4 id="p2.3.6">2.3.6. Структура тела сообщения (Body Structure)</h4><p>Разобранное представление структуры информации [MIME-IMB] в сообщении.</p><h3 id="p2.4">2.4. Текст сообщения</h3><p>Кроме извлечения полного текста сообщения [RFC-822] протокол IMAP4rev1 позволяет извлекать отдельные части
текста (в честности, заголовок [RFC-822], тело сообщения [RFC-822], часть тела [MIME-IMB] заголовок [MIME-IMB]).</p><h2 id="p3">3. Состояния сервера и команды</h2><p>Сервер IMAP4rev1 может находиться в одном из 4 состояний. Большая часть команд применима в любом из состояний
сервера. Если клиент пытается использовать недоступную в данном состоянии сервера команду, возникает протокольная
ошибка и сервер возвращает отклик BAD или NO (в зависимости от реализации сервера).</p><h3 id="p3.1">3.1. Состояние Non-Authenticated</h3><p>В этом состоянии клиент ДОЛЖЕН свои полномочия прежде, чем передавать какие-либо команды. Это состояние является
первым после организации соединения, если соединение не аутентифицировано заранее.</p><h3 id="p3.2">3.2. Состояние Authenticated</h3><p>В этом состоянии полномочия клиента уже проверены и клиент ДОЛЖЕН выбрать почтовый ящик для работы, прежде, чем подавать серверу какие-либо команды для работы с сообщениями. Это состояние возникает при организации сеанса клиентом с предварительной аутентификацией или после предъявления клиентом корректных полномочий, а также после ошибок при выборе почтового ящика.</p><h3 id="p3.3">3.3. Состояние Selected</h3><p>В этом состоянии уже выбран почтовый ящик для работы.</p><h3 id="p3.4">3.4. Состояние Logout</h3><p>В этом состоянии соединение завершается и сервер разрывает связь. Данное состояние может вводиться по запросу
клиента или по инициативе сервера.</p><pre>+--------------------------------------+
|    начало соединения и приветствие   |
+--------------------------------------+
          || (1)       ||  (2)       || (3)
          VV           ||            ||
+-----------------+    ||            ||
|non-authenticated|    ||            ||
+-----------------+    ||            ||
 || (7)   || (4)       ||            ||
 ||       VV           VV            ||
 ||     +----------------+           ||
 ||     | authenticated  |&lt;=++       ||
 ||     +----------------+  ||       ||
 ||       || (7)   || (5)   ||  (6)  ||
 ||       ||       VV       ||       ||
 ||       ||    +--------+  ||       ||
 ||       ||    |selected|==++       ||
 ||       ||    +--------+           ||
 ||       ||       || (7)            ||
 VV       VV       VV                VV
+--------------------------------------+
|   logout и завершение соединения     |
+--------------------------------------+</pre><ul><li>(1) Соединение без предварительной аутентификации (приветствие OK)</li><li>(2) Соединение с предварительной аутентификацией (приветствие PREAUTH)</li><li>(3) Отвергнутое соединение (приветствие BYE)</li><li>(4) Успешное выполнение команды LOGIN или AUTHENTICATE</li><li>(5) Успешное выполнение команды SELECT или EXAMINE</li><li>(6) Команда CLOSE или ошибка при выполнении команды SELECT или EXAMINE</li><li>(7) Команда LOGOUT, отключение (shutdown) сервера или разрыв соединения.</li></ul><h2 id="p4">4. Форматы данных</h2><p>Протокол IMAP4rev1 использует текстовые команды и отклики. Данные IMAP4rev1 могут передаваться в оной из описанных ниже форм: атом (atom), число, строка, список в скобках, NIL.</p><h3 id="p4.1">4.1. Атом (Atom)</h3><p>Атом состоит из одного или нескольких символов общего назначения.</p><h3 id="p4.2">4.2. Число</h3><p>Число содержит одну или более десятичных цифр, представляющих числовое значение.</p><h3 id="p4.3">4.3. Строка</h3><p>Строки могут использовать одну из двух возможных форм — литеральную (буквальную — literal) или квотированную (строка в кавычках — quoted string). Литеральная форма представляет собой общую форму представления строк. Квотированные строки позволяют упростить обработку за счет сужения используемого в них набора символов.</p><p>Литеральная строка представляет собой последовательность (возможно, пустую) октетов (включая символы CR и LF), начинающуюся со счетчика октетов в форме {число октетов} за которым следуют символы CRLF. Для строк, передаваемых сервером клиенту, октеты данных следуют сразу же после CRLF. Для строк, передаваемых от клиента к серверу, клиент ДОЛЖЕН сначала получить от сервера подтверждение с запросом на продолжение команды (эти запросы описаны ниже) и только после этого передавать данные и оставшуюся часть команды.</p><p>Квотированная строка представляет собой последовательность (возможно, пустую) 7-битовых символов, включая CR и LF, заключенную в кавычки (").</p><p>Пустые строки представляются как "" (только кавычки) или {0}CRLF (литеральная строка с 0 октетов).</p><h4 id="p4.3.1">4.3.1. 8-битовые и двоичные строки</h4><p>8-битовые текстовые и бинарные данные поддерживаются с помощью транспортного кодирования содержимого [MIMEIMB]. Реализации IMAP4rev1 могут передавать 8-битовые и мультиоктетные символы в литералах, но делать это следует только в случаях задания [CHARSET] (набор символов).</p><p>Хотя бинарные данные определены спецификацией, их некодированная передача не допускается. Бинарными называют строки с символами NUL. Реализации ДОЛЖНЫ преобразовывать бинарные данные в текстовый формат (например, BASE64) до их передачи. Строки с большим числом символов CTL, также могут считаться бинарными.</p><h3 id="p4.4">4.4. Список в скобках (Parenthesized List)</h3><p>Структуры данных представляются в форме заключенных в скобки списков (parenthesized list) — последовательность элементов, разделенных пробелами, ограничивается с обеих сторон скобками. Списки могут содержать внутри себя другие списки в скобках.</p><p>Пустой список представляется в виде ().</p><h3 id="p4.5">4.5. Пустой формат (NIL)</h3><p>Специальный атом NIL используется для представления несуществующих данных определенного типа, представляемых как строка или список в скобках, в отличие от пустой строки — "" или списка ().</p><h2 id="p5">5. Работа протокола</h2><h3 id="p5.1">5.1. Именование почтовых ящиков</h3><p>Интерпретация имен почтовых ящиков зависит от реализации. Однако почтовый ящик с независимым от регистра именем INBOX зарезервирован в качестве основного почтового ящика пользователя на данном сервере.</p><h4 id="p5.1.1">5.1.1. Иерархия имен</h4><p>Желательно экспортировать иерархические имена почтовых ящиков — имена ДОЛЖНЫ записываться со снижением уровня иерархии слева направо и односимвольным разделителем между иерархическими уровнями. Разделитель для всех переходов между уровнями ДОЛЖЕН быть один.</p><h4 id="p5.1.2">5.1.2. Соглашение о пространстве имен</h4><p>По этому соглашению первый иерархический элемент любого имени почтового ящика ДОЛЖЕН начинаться с символа #, идентифицирующего пространство имен (namespace) остальной части имени. Это позволяет различать разные типы почтовых хранилищ (mailbox store), каждый из которых имеет свое пространство имен. Например, реализация, предлагающая доступ к конференциям USENET может использовать пространство #news для отделения имен конференций USENET от других почтовых ящиков. В результате конференция comp.mail.misc будет иметь почтовый ящик #news.comp.mail.misc, а имя comp.mail.misc может указывать на иной объект (например, почтовый ящик пользователя).</p><h4 id="p5.1.3">5.1.3. Соглашение об использовании других языков в именах</h4><p>В соответствии с этим соглашение имена почтовых ящиков могут использовать символы других языков с обновленной версией кодирования UTF-7, описанной в работе [UTF-7]. Обновление было предпринято с целью разрешения перечисленных ниже проблем UTF-7:</p><ol><li>UTF-7 использует знак "+" для смещения (shifting), что не позволяет применять "+" в именах почтовых ящиков (в частности, с названиях конференций USENET.</li><li>UTF-7 использует кодирование BASE64, применение символа "/" в котором конфликтует с использованием "/" в качестве разделителя иерархических уровней.</li><li>UTF-7 запрещает некодированное представление символа "\", что не позволяет использовать его в качестве разделителя иерархических уровней.</li><li>UTF-7 запрещает некодированное представление символа "~", используемого в некоторых серверах в качестве индикатора домашнего каталога.</li><li>UTF-7 допускает множество альтернативных форм представления одной строки (в частности, печатные символы US-ASCII можно представлять в кодированной форме).</li></ol><p>В обновленном варианте UTF-7 печатные символы US-ASCII (за исключением "&") представляют себя, т. е., символы с кодами 0x20 - 0x25 и 0x27 - 0x7e. Символ "&" (0x26) представляется 2-октетной последовательностью "&-". Все прочие символы (0x00 - 0x1f, 0x7f - 0xff, 16-битовые символы Unicode) представляются с использованием модифицированного кода BASE64 (в соответствии с [UTF-7] "," используется взамен "/"). Обновленное кодирование BASE64 недопустимо использовать для представления любых печатных символов US-ASCII. Символ "&" используется для перехода к модифицированному кодированию BASE64, а "-" для перехода к US-ASCII. Все имена начинаются с символа US-ASCII и ДОЛЖНЫ заканчиваться символом US-ASCII (т. е., имя из символов Unicode должно завершаться знаком "- "). В качестве примера приведем имя, содержащее текст на английском, японском и китайском языках — ~peter/mail/&amp;ZeVnLIqe-/&amp;U,BTFw-</p><h3 id="p5.2">5.2. Обновление размеров и статуса сообщений</h3><p>В любой момент сервер может передать данные, которых клиент не запрашивал. Иногда такая передача может даже требоваться. Например, агенты (не сервер) могут добавлять сообщения в почтовый ящик (например, доставка новой почты), менять флаги сообщений в почтовых ящиках (например, одновременный доступ к почтовому ящику нескольких агентов) и даже удалять сообщения. Сервер ДОЛЖЕН передавать обновленные данные о размере почтового ящика, если таковые обнаружены в процессе обработки команды. Серверу следует автоматически передавать обновленную информацию о флагах без явного запроса на такое обновление со стороны клиента. Для передачи уведомлений об удалении почты существуют специальные правила, позволяющие избежать ошибок при синхронизации (см. 7.4.1. Отклик EXPUNGE).</p><p>Независимо от используемого в реализации клиента способа запоминания полученных от сервера данных, клиент должен записывать обновления размера почтового ящика. НЕДОПУСТИМО предполагать, что любая команда после начального выбора почтового ящика будет возвращать его размер.</p><h3 id="p5.3">5.3. Отклики при отсутствии обрабатываемых команд</h3><p>Серверу разрешается передавать непомеченные отклики (за исключением EXPUNGE) при отсутствии обрабатываемых команд. Реализации серверов, передающие такие отклики, ДОЛЖНЫ принимать во внимание вопросы управления потоком данных. В частности, сервер ДОЛЖЕН (1) убедиться, что размер передаваемых данных не превышает максимальный размер окна, доступный нижележащему транспортному уровню или (2) использовать запись без блокировки (non-blocking write).</p><h3 id="p5.4">5.4. Таймер автоматического отключения</h3><p>Если сервер использует автоматическое отключение по таймеру в случае отсутствия активности, значение таймера автоматического отключения должно быть не менее 30 минут. Получив от клиента любую команду, серверу следует сбросить таймер.</p><h3 id="p5.5">5.5. Обработка множества команд</h3><p>Клиент может передавать новые команды, не дожидаясь отклика о завершении обработки предыдущих команд, с учетом правил однозначности (см. ниже) и управления потоком данных на нижележащем уровне. Сервер может начать обработку новой команды до завершения обработки прежних, учитывая правила однозначности. Однако все отклики с запросами на продолжение команды и продолжения команд ДОЛЖНЫ быть согласованы до того, как будет передана следующая команда.</p><p>Правило однозначности связано с возможной зависимостью результатов выполнения команды от результатов завершения предшествующих команд. Для клиентов НЕДОПУСТИМО передавать команду без ожидания, если результаты могут быть неоднозначными. Если сервер видит возможность неоднозначности, он ДОЛЖЕН выполнять команды в заданном клиентом порядке.</p><p>Тривиальным случаем возникновения неоднозначности является ситуация, когда результаты выполнения одной команды напрямую воздействуют на результат другой (например, команды FETCH и STORE для флагов сообщения). Менее тривиальные ситуации, для которых допустимы непомеченные отклики EXPUNGE (все команды, за исключение FETCH, STORE, SEARCH), поскольку непомеченный отклик EXPUNGE может делать некорректными порядковые номера в следующей команде. Это не вызывает проблем для команд FETCH, STORE, SEARCH, поскольку для этих команд запрещена передача откликов EXPUNGE, пока не будет завершена обработка всех команд. Следовательно, если клиент передаст любую из команд, кроме FETCH, STORE, SEARCH, он ДОЛЖЕН дождаться отклика и только после этого может передавать команды с порядковыми номерами сообщений.</p><p>Ниже приведены несколько примеров некорректных последовательностей команд:</p><pre>FETCH + NOOP + STORE
STORE + COPY + FETCH
COPY  + COPY
CHECK + FETCH</pre><p>Приведенные ниже последовательности команд можно передавать, не дожидаясь откликов:</p><pre>FETCH + STORE + SEARCH + CHECK
STORE + COPY  + EXPUNGE</pre><h2 id="p6">6. Команды клиента</h2><p>В этой главе описаны команды протокола IMAP4rev1. Все команды организованы по состояниям, для которых возможно использование этих команд (например, команды, корректные для состояний authenticated и selected, перечислены в числе команд для состояния authenticated).</p><p>Аргументы команд указываются ключевым словом "Аргументы:" в описании команды и рассмотрены здесь только с функциональной точки зрения, а синтаксис аргументов описан в главе «Формальный синтаксис».</p><p>Некоторые команды ведут к генерации сервером специфического отклика — эти отклики помечены ключевым словом "Отклик:" в описании команды. Дополнительная информация об откликах содержится в глава «Отклики» и «Формальный синтаксис». По любой команде клиента сервер может передавать в ответ данные.</p><p>Ключевое слово "Результат:" в описании команды указывает на возможные помеченные (tagged) отклики о состоянии и специфическую интерпретацию таких откликов.</p><h3 id="p6.1">6.1. Команды клиента для любого состояния</h3><p>Команды CAPABILITY, NOOP и LOGOUT могут использоваться во всех состояниях.</p><h4 id="p6.1.1">6.1.1. Команда CAPABILITY</h4><table class="nobrd"><tr><td>Аргументы:</td><td>не используются</td></tr><tr><td>Отклик:</td><td>требуется непомеченный отклик CAPABILITY</td></tr><tr><td>Результат:</td><td>OK — успешное завершение<br />BAD — команда не поддерживается</td></tr></table><p>Команда CAPABILITY запрашивает у сервера список поддерживаемых возможностей. Сервер ДОЛЖЕН передавать один непомеченный отклик CAPABILITY, указывая в списке возможностей по крайней мере IMAP4rev1, и только поток возвращать помеченный отклик OK. Возвращаемый список возможностей не зависит от пользователя или состояния соединения, следовательно, не возникает необходимости использования команды CAPABILITY более одного раза в каждом соединении.</p><p>Имена возможностей, начинающихся с AUTH=, показывают, что сервер использует механизм аутентификации. Все такие имена, по определению, являются частью данной спецификации. Например, аутентификация с помощью экспериментального метода blurdybloop будет обозначаться возможностью AUTH=XBLURDYBLOOP, но не XAUTH=BLURDYBLOOP или XAUTH=XBLURDYBLOOP.</p><p>Имена других возможностей указывают на расширения, пересмотры или изменения данной спецификации. Дополнительная информация приведена ниже при описании откликов CAPABILITY. В данной спецификации не определяется никаких дополнительных возможностей сверх базовой возможности IMAP4rev1, поддерживаемой автоматически без каких-либо запросов со стороны клиента.</p><p>Информация о расширениях и экспериментальных возможностях приводится в параграфе 6.5.1. Команда X&lt;atom&gt;.</p><pre>Пример:  C: abcd CAPABILITY
         S: * CAPABILITY IMAP4rev1 AUTH=KERBEROS_V4
         S: abcd OK CAPABILITY completed</pre><h4 id="p6.1.2">6.1.2. Команда NOOP</h4><table class="nobrd"><tr><td>Аргументы:</td><td>не используются</td></tr><tr><td>Отклик:</td><td>для этой команды не существует специфических откликов (см. ниже)</td></tr><tr><td>Результат:</td><td>OK — команда выполнена<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда NOOP всегда завершается успешно, поскольку она не делает ничего. Поскольку любая команда может возвращать обновленное состояние как непомеченные данные, команду NOOP можно использовать для периодического получения обновлений во время бездействия клиента. Можно также использовать команду NOOP для сброса таймера бездействия на сервере.</p><pre>Пример:  C: a002 NOOP
         S: a002 OK NOOP completed
            . . .
         C: a047 NOOP
         S: * 22 EXPUNGE
         S: * 23 EXISTS
         S: * 3 RECENT
         S: * 14 FETCH (FLAGS (\Seen \Deleted))
         S: a047 OK NOOP completed</pre><h4 id="p6.1.3">6.1.3. Команда LOGOUT</h4><table class="nobrd"><tr><td>Аргументы:</td><td>не используются</td></tr><tr><td>Отклик:</td><td>Требуется непомеченный отклик BYE</td></tr><tr><td>Результат:</td><td>OK — команда выполнена<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда LOGOUT информирует сервер о намерении клиента закончить работу. Сервер ДОЛЖЕН передать непомеченный отклик BYE до передачи отмеченного отклика OK, а потом закрыть соединение.</p><pre>Пример:  C: A023 LOGOUT
         S: * BYE IMAP4rev1 Server logging out
         S: A023 OK LOGOUT completed</pre><p>Сервер и клиент закрыли соединение.</p><h2 id="p6.2">6.2. Клиентские команды — состояние Non-Authenticated</h2><p>В состоянии, когда аутентификация еще не произведена, команда AUTHENTICATE или LOGIN позволяет провести аутентификацию и перейти в состояние authenticated. Команда AUTHENTICATE обеспечивает общий механизм для различных методов аутентификации, а LOGIN использует традиционную пару «имя пользователя — пароль», передаваемую в виде текста.</p><p>Для некоторых почтовых ящиков сервер может позволять работу без аутентификации. По соглашения команда LOGIN может использоваться с именем пользователя anonymous (безымянный). Пароль является обязательным. Пароль и права доступа для анонимного пользователя зависят от реализации.</p><p>После аутентификации (включая анонимную) соединение не может быть переведено в состояние non-authenticated. В дополнение к универсальным командам (CAPABILITY, NOOP, LOGOUT), данное состояние поддерживает команды AUTHENTICATE и LOGIN.</p><h4 id="p6.2.1">6.2.1. Команда AUTHENTICATE</h4><table class="nobrd"><tr><td>Аргументы:</td><td>имя механизма аутентификации</td></tr><tr><td>Отклик:</td><td>могут быть запрошены дополнительные данные</td></tr><tr><td>Результат:</td><td>OK — аутентификация завершена успешно, текущее состояние authenticated<br />NO — неудача при аутентификации — неподдерживаемый механизм, нет полномочий<br />BAD — команда не поддерживается или некорректны аргументы, аутентификации не произошло</td></tr></table><p>Команд AUTHENTICATE показывает серверу механизм аутентификации (типа описанного в работе [IMAP-AUTH]). Если сервер поддерживает этот механизм, выполняется обмен данными для проверки полномочий (аутентификации клиента). Можно также согласовать дополнительный механизм защиты для последующего обмена данными. Если запрошенный метод аутентификации не поддерживается, серверу следует отвергать команду AUTHENTICATE, передавая помеченные отклик NO.</p><p>Процесс аутентификации включает в себя обмен данными, состоящими из вопросов сервера и ответов клиента, — набор вопросов зависит от реализации. Вопрос сервера включает запрос продолжения команды, состоящий из маркера "+", за которым следует строка в формате BASE64. Отклик клиента представляет собой строку в коде BASE64. Если клиент хочет прервать обмен данными аутентификации, он просто передает строку, содержащую один символ "*". Получив такой ответ, сервер ДОЛЖЕН отвергнуть команду AUTHENTICATE и передать отмеченный отклик BAD.</p><p>Механизм защиты обеспечивает целостность и конфиденциальность соединения. Если такой механизм согласован, он применяется ко всем данным, передаваемым через соединение. Механизм защиты начинает работать сразу после получения последовательности CRLF,завершающей аутентификацию клиента и последовательности CRLF, завершающей отклик OK. После включения механизма защиты поток октетов команд и откликов обрабатывается в буферах шифрования. Содержимое каждого буфера передается через соединение как поток октетов, которому предшествует 4-октетное поле размера. Максимальный размер шифрованного буфера определяется используемым механизмом.</p><p>Механизм аутентификации является необязательным. Механизм защиты также необязателен и аутентификация может быть реализована без дополнительной защиты. Если команда AUTHENTICATE завершается отказом с откликом NO, клиент может попытаться использовать иной механизм аутентификации в следующей команде AUTHENTICATE или может попытаться войти в систему по команде LOGIN. Иными словами, клиент может запрашивать механизмы аутентификации в порядке снижения уровня предпочтений вплоть до команды LOGIN, как последней попытки.</p><pre>Пример:  S: * OK KerberosV4 IMAP4rev1 Server
         C: A001 AUTHENTICATE KERBEROS_V4
         S: + AmFYig==
         C: BAcAQU5EUkVXLkNNVS5FRFUAOCAsho84kLN3/IJmrMG+25a4DT
            +nZImJjnTNHJUtxAA+o0KPKfHEcAFs9a3CL5Oebe/ydHJUwYFd
            WwuQ1MWiy6IesKvjL5rL9WjXUb9MwT9bpObYLGOKi1Qh
         S: + or//EoAADZI=
         C: DiAF5A4gA+oOIALuBkAAmw==
         S: A001 OK Kerberos V4 authentication successful</pre><h4 id="p6.2.2">6.2.2. Команда LOGIN</h4><table class="nobrd"><tr><td>Аргументы:</td><td>имя пользователя, пароль</td></tr><tr><td>Отклик:</td><td>для этой команды не существует специфических откликов</td></tr><tr><td>Результат:</td><td>OK — вход в системы завершен, состояние authenticated<br />NO — неудача — имя пользователя или пароль отвергнуты<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда LOGIN используется для представления клиента серверу и передачи пароля в виде открытого текста.</p><pre>Пример:  C: a001 LOGIN SMITH SESAME
         S: a001 OK LOGIN completed</pre><h3 id="p6.3">6.3. Команды клиента — состояние Authenticated</h3><p>После успешного завершения аутентификации становятся доступными команды для работы с почтовыми ящиками как атомами. Команды SELECT и EXAMINE позволяют выбирать почтовые ящики и переводят соединение в состояние selected.</p><p>В дополнение к универсальным командам (CAPABILITY, NOOP, LOGOUT) после успешной аутентификации поддерживаются команды SELECT, EXAMINE, CREATE, DELETE, RENAME, SUBSCRIBE, UNSUBSCRIBE, LIST, LSUB, STATUS, APPEND.</p><h4 id="p6.3.1">6.3.1. Команда SELECT</h4><table class="nobrd"><tr><td>Аргументы:</td><td>имя почтового ящика</td></tr><tr><td>Отклик:</td><td>ОБЯЗАТЕЛЬНО непомеченный отклик FLAGS, EXISTS, RECENT<br />ДОПОЛНИТЕЛЬНО OK непомеченный отклик UNSEEN, PERMANENTFLAGS</td></tr><tr><td>Результат:</td><td>OK — выбор завершено, состояние selected<br />NO — отказ при выборе, состояние authenticated (нет почтового ящика или доступа к нему)<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда SELECT выбирает почтовый ящик и обеспечивает доступ к хранящимся в нем сообщениям. До возврата клиенту отклика сервер ДОЛЖЕН передать клиенту следующие непомеченные данные для определения начального состояния почтового ящика:</p><table class="nobrd"><tr><td>FLAGS</td><td>определяет флаги почтового ящика (см. описание отклика FLAGS)</td></tr><tr><td>&lt;n&gt; EXISTS</td><td>число сообщений в почтовом ящике (см. описание отклика EXISTS)</td></tr><tr><td>&lt;n&gt; RECENT</td><td>число сообщений с установленным флагом \Recent (см. описание отклика RECENT)</td></tr><tr><td>OK [UIDVALIDITY &lt;n&gt;]</td><td>уникальный идентификатор корректности (см. описание отклика UID)</td></tr></table><p>Серверу следует также передать код UNSEEN в непомеченном отклике OK, показывающий порядковый номер первого непрочитанного сообщения в почтовом ящике.</p><p>Если клиенту не разрешается вносить постоянные изменения в те или иные флаги, указанные в непомеченном отклике FLAGS, серверу следует передать код PERMANENTFLAGS в непомеченном отклике OK, указывающий какие флаги клиент не может изменить.</p><p>В каждом соединении может быть выбран только один почтовый ящик и для работы с несколькими ящиками требуется соответствующее число соединений. При выборе нового почтового ящика команда SELECT автоматически отменяет текущий выбор. Следовательно, если выбран почтовый ящик, то после неудачного использования команды SELECT этот выбор будет отменен.</p><p>Если клиенту позволено изменять почтовый ящик, серверу следует перед текстом помеченного отклика OK помещать код [READ-WRITE]. Если клиенту не разрешено менять содержимое почтового ящика, но открыт доступ для чтения почты, почтовый ящик выбирается в режиме чтения (read-only) и сервер ДОЛЖЕН перед текстом отклика OK на команду SELECT поместить код [READ-ONLY]. Доступ для чтения по команде SELECT отличается от использования команды EXAMINE тем, что некоторые почтовые ящики read-only могут позволять изменение перманентного состояния отдельным пользователям (при наличии общего запрета. Новости, промаркированные в файле .newsrc на сервере, являются примером такой ситуации (некоторые пользователи могут менять состояние почтовых ящиков с атрибутом read-only).</p><pre>Пример:  C: A142 SELECT INBOX
         S: * 172 EXISTS
         S: * 1 RECENT
         S: * OK [UNSEEN 12] Message 12 is first unseen
         S: * OK [UIDVALIDITY 3857529045] UIDs valid
         S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
         S: * OK [PERMANENTFLAGS (\Deleted \Seen \*)] Limited
         S: A142 OK [READ-WRITE] SELECT completed</pre><h4 id="p6.3.2">6.3.2. Команда EXAMINE</h4><table class="nobrd"><tr><td>Аргументы:</td><td>имя почтового ящика</td></tr><tr><td>Отклик:</td><td>ОБЯЗАТЕЛЬНО непомеченный отклик FLAGS, EXISTS, RECENT<br />ДОПОЛНИТЕЛЬНО OK непомеченный отклик UNSEEN, PERMANENTFLAGS</td></tr><tr><td>Результат:</td><td>OK — проверка завершена, состояние selected<br />NO — неудачная проверка, состояние authenticated (нет почтового ящика или доступа к нему)<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда EXAMINE идентична команде SELECT и возвращает такие же результаты, однако открывает выбранный почтовый ящик только для чтения (read-only). Не допускается перманентного изменения состояния почтового ящика. Текст отмеченного отклика OK на команду EXAMINE ДОЛЖЕН начинаться с кода [READ-ONLY].</p><pre>Пример:  C: A932 EXAMINE blurdybloop
         S: * 17 EXISTS
         S: * 2 RECENT
         S: * OK [UNSEEN 8] Message 8 is first unseen
         S: * OK [UIDVALIDITY 3857529045] UIDs valid
         S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
         S: * OK [PERMANENTFLAGS ()] No permanent flags permitted
         S: A932 OK [READ-ONLY] EXAMINE completed</pre><h4 id="p6.3.3">6.3.3. Команда CREATE</h4><table class="nobrd"><tr><td>Аргументы:</td><td>имя почтового ящика</td></tr><tr><td>Отклик:</td><td>для этой команды не существует специфических откликов</td></tr><tr><td>Результат:</td><td>OK — успешное завершение<br />NO — невозможно создать почтовый ящик с указанным именем<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда CREATE создает почтовый ящик с заданным именем. Отклик OK возвращается только при успешном создании почтового ящика. При попытке создать почтовый ящик INBOX или с другим уже используемым именем возникает ошибка. В результате любой ошибки будет возвращаться помеченный отклик NO.</p><p>Если имя почтового ящика имеет суффикс с символом-разделителем уровней иерархии (сервер возвращает его по команде LIST), это означает попытку клиента создать почтовый ящик в иерархии имен. Реализации серверов, не требующие такого объявления, ДОЛЖНЫ игнорировать его.</p><p>При наличии в имени разделителя уровней иерархии, серверу следует создавать все вышележащие уровни иерархии, которые требуются для успешного завершения команды CREATE. Иными словами, при создании имени foo/bar/zap на сервере, использующем символ "/" в качестве разделителя, следует создать уровни foo/ и foo/bar/, если их еще нет. Если создается почтовый ящик с именем ранее удаленного ящика, его уникальные идентификаторы ДОЛЖНЫ быть больше уникальных идентификаторов, используемых в прежней инкарнации почтового ящика с таким именем, если новый ящик не имеет другого значения уникального идентификатора корректности (см. описание команды UID).</p><pre>Пример:  C: A003 CREATE owatagusiam/
         S: A003 OK CREATE completed
         C: A004 CREATE owatagusiam/blurdybloop
         S: A004 OK CREATE completed</pre><p>Отметим, что интерпретация приведенного примера зависит от того, возвращает ли сервер символ "/" по команде LIST. Если "/" служит разделителем, создается новый уровень с именем blurdybloop в иерархии owatagusiam. В противном случае создаются два почтовых ящика на одном уровне иерархии.</p><h4 id="p6.3.4">6.3.4. Команда DELETE</h4><table class="nobrd"><tr><td>Аргументы:</td><td>имя почтового ящика</td></tr><tr><td>Отклик:</td><td>для этой команды не существует специфических откликов</td></tr><tr><td>Результат:</td><td>OK — успешное удаление<br />NO — невозможно удалить почтовый ящик с указанным именем<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда DELETE навсегда удаляет указанный почтовый ящик. При попытке удаления ящика INBOX или отсутствующего почтового ящика возникает ошибка.</p><p>Недопустимо с помощью команды DELETE удалять внутренние уровни иерархии имен. Например, почтовый ящик foo является внутренним в иерархии foo.bar (предполагается, что "." служит разделителем уровней), удаление foo недопустимо следует удалять foo.bar. Ошибка произойдет и при попытке удаления имени, имеющего подчиненные уровни и атрибут \Noselect (см. описание отклика LIST). Допускается удалять имена с подчиненными уровнями, которые не имеют атрибута \Noselect. В таких случаях все сообщения из почтового ящика, а имя приобретает атрибут \Noselect. Максимальное значение уникального идентификатора для удаляемого ящика должно сохраняться, чтобы при создании нового ящика с этим именем не возникало повторного использования идентификаторов, если для нового ящика не задается другое значение уникального идентификатора корректности (см. описание команды UID).</p><pre>Пример:  C: A682 LIST "" *
         S: * LIST () "/" blurdybloop
         S: * LIST (\Noselect) "/" foo
         S: * LIST () "/" foo/bar
         S: A682 OK LIST completed
         C: A683 DELETE blurdybloop
         S: A683 OK DELETE completed
         C: A684 DELETE foo
         S: A684 NO Name "foo" has inferior hierarchical names
         C: A685 DELETE foo/bar
         S: A685 OK DELETE Completed
         C: A686 LIST "" *
         S: * LIST (\Noselect) "/" foo
         S: A686 OK LIST completed
         C: A687 DELETE foo
         S: A687 OK DELETE Completed


         C: A82 LIST "" *
         S: * LIST () "." blurdybloop
         S: * LIST () "." foo
         S: * LIST () "." foo.bar
         S: A82 OK LIST completed
         C: A83 DELETE blurdybloop
         S: A83 OK DELETE completed
         C: A84 DELETE foo
         S: A84 OK DELETE Completed
         C: A85 LIST "" *
         S: * LIST () "." foo.bar
         S: A85 OK LIST completed
         C: A86 LIST "" %
         S: * LIST (\Noselect) "." foo
         S: A86 OK LIST completed</pre><h4 id="p6.3.5">6.3.5. Команда RENAME</h4><table class="nobrd"><tr><td>Аргументы:</td><td>имя существующего почтового ящика, имя нового почтового ящика</td></tr><tr><td>Отклик:</td><td>для этой команды не существует специфических откликов</td></tr><tr><td>Результат:</td><td>OK — успешная смена имени<br />NO — не удалось изменить имя (нет такого почтового ящика или новое имя уже используется)<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда RENAME служит для изменения имени почтового ящика. Помеченный отклик OK возвращается только после успешного изменения имени. Попытка переименовать несуществующий почтовый ящик или задать в качестве нового уже используемое имя приводит к ошибке. В случае любой ошибки возвращается помеченный отклик NO.</p><p>При замене имени почтового ящика, имеющего нижележащие уровни, их имена также ДОЛЖНЫ изменяться. Например, при смене имени foo на zap имя foo/bar ("/" является разделителем уровней) должно стать zap/bar.</p><p>Максимальное значение уникального идентификатора для ящика, имя которого изменяется, должно сохраняться, чтобы при создании нового ящика с этим именем не возникало повторного использования идентификаторов, если для нового ящика не задается другое значение уникального идентификатора корректности (см. описание команды UID).</p><p>Допускается переименование почтового ящика INBOX при выполнении определенных условий — все сообщения из INBOX перемещаются в почтовый ящик с новым именем и создается заново пустой почтовый ящик INBOX. Если реализация сервера поддерживает иерархию имен в INBOX, на эту иерархию не действует переименование INBOX.</p><pre>Пример:  C: A682 LIST "" *
         S: * LIST () "/" blurdybloop
         S: * LIST (\Noselect) "/" foo
         S: * LIST () "/" foo/bar
         S: A682 OK LIST completed
         C: A683 RENAME blurdybloop sarasoop
         S: A683 OK RENAME completed
         C: A684 RENAME foo zowie
         S: A684 OK RENAME Completed
         C: A685 LIST "" *
         S: * LIST () "/" sarasoop
         S: * LIST (\Noselect) "/" zowie
         S: * LIST () "/" zowie/bar
         S: A685 OK LIST completed
         C: Z432 LIST "" *
         S: * LIST () "." INBOX
         S: * LIST () "." INBOX.bar
         S: Z432 OK LIST completed
         C: Z433 RENAME INBOX old-mail
         S: Z433 OK RENAME completed
         C: Z434 LIST "" *
         S: * LIST () "." INBOX
         S: * LIST () "." INBOX.bar
         S: * LIST () "." old-mail
         S: Z434 OK LIST completed</pre><h4 id="p6.3.6">6.3.6. Команда SUBSCRIBE</h4><table class="nobrd"><tr><td>Аргументы:</td><td>имя почтового ящика</td></tr><tr><td>Отклик:</td><td>для этой команды не существует специфических откликов</td></tr><tr><td>Результат:</td><td>OK — успешное завершение<br />NO — отказ — невозможна подписка для указанного имени<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда SUBSCRIBE добавляет указанное имя почтового ящика в число «активных» или «подписанных» ящиков, список которых возвращается по команде LSUB. Отмеченный отклик OK возвращается только при успешной подписке.</p><p>Сервер может проверять существование почтового ящика, указанного в команде SUBSCRIBE. Однако для сервера недопустимо по своей воле удалять имена почтовых ящиков из списка даже в тех случаях, когда ящика уже нет.</p><pre>Пример:  C: A002 SUBSCRIBE #news.comp.mail.mime
         S: A002 OK SUBSCRIBE completed</pre><h4 id="p6.3.7">6.3.7. Команда UNSUBSCRIBE</h4><table class="nobrd"><tr><td>Аргументы:</td><td>имя почтового ящика</td></tr><tr><td>Отклик:</td><td>для этой команды не существует специфических откликов</td></tr><tr><td>Результат:</td><td>OK — успешный отказ от подписки<br />NO — неудача<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда UNSUBSCRIBE служит для удаления указанного почтового ящика из числа «активных» или «подписанных» ящиков, список которых возвращается по команде LSUB. Отмеченный отклик OK возвращается только при успешном удалении из списка.</p><pre>Пример:  C: A002 UNSUBSCRIBE #news.comp.mail.mime
         S: A002 OK UNSUBSCRIBE completed</pre><h4 id="p6.3.8">6.3.8. Команда LIST</h4><table class="nobrd"><tr><td>Аргументы:</td><td>база, имя почтового ящика (возможны шаблоны)</td></tr><tr><td>Отклик:</td><td>непомеченный отклик LIST</td></tr><tr><td>Результат:</td><td>OK — список получен<br />NO — отказ — невозможно вернуть список с заданной базой или именем<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда LIST возвращает заданное подмножество полного набора имен, доступных клиенту. В ответ на команду возвращается некоторое число (возможно, 0) помеченных откликов LIST, содержащих атрибуты имени, разделитель уровней иерархии и имя (см. описание отклика LIST).</p><p>Данные по команде LIST следует возвращать быстро лишних задержек. Например, не следует выполнять расчет состояний \Marked или \Unmarked и выполнять другие действия — если каждое имя потребует 1 сек., то на обработку 1200 будет потрачено 20 минут!</p><p>Пустая база ("") reference name argument indicates that the имя почтового ящика is interpreted as by SELECT. Возвращаемые имена почтовых ящиков ДОЛЖНЫ соответствовать указанному шаблону имени. Непустая ссылка задает имя почтового ящика или уровень иерархии и контекст, в котором интерпретируется имя почтового ящика (в зависимости от реализации).</p><p>Пустое ("") имя почтового ящика задает специальный случай для возврата разделителя уровней иерархии и корневого имени для заданной базы. Возвращаемое корневое значение может быть пустым, если база не имеет корня или задана пустая база. Разделитель уровней возвращается в любом случае. Это позволяет клиенту определить разделитель даже при отсутствии почтового ящика с указанным именем.</p><p>База и имя почтового ящика преобразуются (в зависимости от реализации) в каноническую форму с однозначным представлением иерархии слева направо. Возвращаемое имя почтового ящика будет иметь эту форму.</p><p>Любую часть базы в преобразованной форме следует указывать как префикс, сохраняя указанную в аргументе команды форму базы для этого префикса. Это правило позволяет клиентам определять относится ли возвращенное имя почтового ящика к контексту базы и обнаружить пересечение имени с базой. Без этого правила клиент будет получать искаженную информацию о контексте имен. Для примера в таблице показано несколько вариантов интерпретации базы и имени почтового ящика серверами на основе UNIX.</p><p>Первые три строки показывают реализацию в контексте базы. Отметим, что ~smith/Mail не следует преобразовать во что-либо иное, типа /u2/users/smith/Mail, поскольку клиент не сможет определить, что интерпретация происходила в контексте базы.</p><table style="float:left"><tr><td>База</td><td>Имя почтового ящика</td><td>Интерпретация</td></tr><tr><td>~smith/Mail/</td><td>foo.*</td><td>~smith/Mail/foo.*</td></tr><tr><td>archive/</td><td>%</td><td>archive/%</td></tr><tr><td>#news.</td><td>comp.mail.*</td><td>#news.comp.mail.*</td></tr><tr><td>~smith/Mail/</td><td>/usr/doc/foo</td><td>/usr/doc/foo</td></tr><tr><td>archive/</td><td>~fred/Mail/*</td><td>~fred/Mail/*</td></tr></table><p>Символ "*" является шаблоном и соответствует любым символам (в произвольном количестве) в этой позиции. Символ "%" подобен "*", но не соответствует разделителям уровней иерархии. Если символ "%" указан последним в шаблоне имени почтового ящика, возвращаются также соответствующие уровни иерархии. Если эти уровни не являются почтовыми ящиками, которые можно выбрать, возвращается атрибут \Noselect (см. описание отклика LIST).</p><p>Серверам разрешается «прятать» доступные почтовые ящики при использовании шаблонов в некоторых ситуациях. Например, серверы на основе UNIX могут ограничивать действие шаблона "*" так, чтобы начальный символ "/" не давал соответствия.</p><p>Специальное имя INBOX включается в выходной список команды LIST, если ящик INBOX поддерживается сервером для данного пользователя и строка INBOX (в верхнем регистре) соответствует базе и имени почтового ящика с заданными в команде шаблонами. Критерием включения ящика INBOX является возможность его выбора по команде SELECT.</p><pre>Пример:  C: A101 LIST "" ""
         S: * LIST (\Noselect) "/" ""
         S: A101 OK LIST Completed
         C: A102 LIST #news.comp.mail.misc ""
         S: * LIST (\Noselect) "." #news.
         S: A102 OK LIST Completed
         C: A103 LIST /usr/staff/jones ""
         S: * LIST (\Noselect) "/" /
         S: A103 OK LIST Completed
         C: A202 LIST ~/Mail/ %
         S: * LIST (\Noselect) "/" ~/Mail/foo
         S: * LIST () "/" ~/Mail/meetings
         S: A202 OK LIST completed</pre><h4 id="p6.3.9">6.3.9. Команда LSUB</h4><table class="nobrd"><tr><td>Аргументы:</td><td>база, имя почтового ящика (возможны шаблоны)</td></tr><tr><td>Отклик:</td><td>непомеченный отклик LSUB</td></tr><tr><td>Результат:</td><td>OK — успешное завершение<br />NO — неудача<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда LSUB возвращает подмножество имен из набора, объявленного пользователем «активным» или «подписанным». LSUB возвращает 0 или больше помеченных откликов. Аргументы LSUB имеют такую же форму, как аргументы команды LIST.</p><p>Сервер может проверить существование подписанных имен. Если имя не существует, его следует возвращать с флагом \Noselect в отклике LSUB. Для серверов НЕДОПУСТИМО самовольное удаление имени почтового ящика из списка активных, даже если ящик больше не существует.</p><pre>Пример:  C: A002 LSUB "#news." "comp.mail.*"
         S: * LSUB () "." #news.comp.mail.mime
         S: * LSUB () "." #news.comp.mail.misc
         S: A002 OK LSUB completed</pre><h4 id="p6.3.10">6.3.10. Команда STATUS</h4><table class="nobrd"><tr><td>Аргументы:</td><td>имя почтового ящика, имена элементов состояния</td></tr><tr><td>Отклик:</td><td>непомеченный отклик STATUS</td></tr><tr><td>Результат:</td><td>OK — успешное завершение<br />NO — неудача — для заданного имени нет данных о состоянии<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда STATUS запрашивает сведения о состоянии указанного почтового ящика. Команда не меняет выбранный почтовый ящик и не влияет на состояние каких-либо сообщений в ящике, для которого запрашивается состояние (в частности, при использовании команды STATUS недопустим сброс флага \Recent).</p><p>Команда STATUS является альтернативой открытию второго соединения IMAP4rev1 и использованию команды EXAMINE, позволяя получать данные о состоянии без организации специального соединения IMAP4rev1.</p><p>В отличие от LIST команда STATUS не гарантирует быстрого отклика. В некоторых реализациях сервер ДОЛЖЕН открыть почтовый ящик в режиме read-only (только чтение) для получения некоторых данных о состоянии. Кроме того, в отличие от LIST команда STATUS не допускает использования шаблонов.</p><p>Определенные на сегодняшний день элементы состояния включают:</p><table class="nobrd"><tr><td>MESSAGES</td><td>число сообщений в почтовом ящике</td></tr><tr><td>RECENT</td><td>число сообщений с флагом \Recent</td></tr><tr><td>UIDNEXT</td><td>значение UID, которое будет использовано для следующего сообщения в почтовом ящике.<br />Гарантируется неизменность этого значения пока в ящик не будет добавлено новое сообщение.<br />Гарантируется также изменение значения при получении нового письма, даже если это сообщение будет потом исключено.</td></tr><tr><td>UIDVALIDITY</td><td>значение уникального идентификатора корректности для почтового ящика.</td></tr><tr><td>UNSEEN</td><td>число сообщений, для которых не установлен флаг \Seen.</td></tr></table><pre>Пример:  C: A042 STATUS blurdybloop (UIDNEXT MESSAGES)
         S: * STATUS blurdybloop (MESSAGES 231 UIDNEXT 44292)
         S: A042 OK STATUS completed</pre><h4 id="p6.3.11">6.3.11. Команда APPEND</h4><table class="nobrd"><tr><td>Аргументы:</td><td>имя почтового ящика, [заключенный в скобки список флагов], [строка даты/времени], сообщение</td></tr><tr><td>Отклик:</td><td>для этой команды не существует специфических откликов</td></tr><tr><td>Результат:</td><td>OK — успешное добавление<br />NO — ошибка — невозможно добавить сообщение в указанный ящик, ошибка в флагах, дате или тексте<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда APPEND добавляет переданный ей аргумент как новое сообщение в конце указанного почтового ящика. Для аргументов следует использовать синтаксис [RFC-822]. В сообщении допускаются 8-битовые символы. Серверы, неспособные корректно сохранять 8-битовые символы, ДОЛЖНЫ обеспечивать обратимое преобразование 8-битовых данных команды APPEND в 7-битовые с использованием транспортного кодирования содержимого [MIME-IMB]. Отметим, что эти правила могут иметь исключения — например, при использовании команды APPEND для сохранения черновиков сообщений можно опустить строки заголовка [RFC-822]. Однако использоваться такие исключения должны с осторожностью.</p><p>Если присутствует список флагов в скобках, в добавленном сообщении следует установить заданные флаги (по умолчанию флаги отсутствуют).</p><p>Если указана дата и время, для добавленного сообщения следует установить заданные значения даты и времени (по умолчанию устанавливаются текущая дата и время).</p><p>Если при добавлении произошла какая-то ошибка, почтовый ящик ДОЛЖЕН быть восстановлен в исходном виде (как до команды APPEND) — частичная добавка сообщения недопустима. Если указанного почтового ящика не существует, сервер ДОЛЖЕН возвратить сообщение об ошибке; автоматическое создание почтового ящика недопустимо. Кроме тех случаев, когда указанный почтовый ящик не может быть создан, сервер ДОЛЖЕН добавлять код [TRYCREATE] перед текстом помеченного отклика NO, намекая клиенту на возможность использования команды CREATE и повтора APPEND при удачном создании почтового ящика.</p><p>Если почтовый ящик в данный момент выбран, следует выполнить действия как при обычном получении нового сообщения. В частности, серверу следует незамедлительно уведомить клиента с помощью непомеченного отклика EXISTS. Если сервер не делает этого, клиент может ввести команду NOOP (или CHECK) после одной или нескольких команд APPEND.</p><pre>Пример:  C: A003 APPEND saved-messages (\Seen) {310}
         C: Date: Mon, 7 Feb 1994 21:52:25 -0800 (PST)
         C: From: Fred Foobar &lt;foobar@Blurdybloop.COM&gt;
         C: Subject: afternoon meeting
         C: To: mooch@owatagu.siam.edu
         C: Message-Id: &lt;B27397-0100000@Blurdybloop.COM&gt;
         C: MIME-Version: 1.0
         C: Content-Type: TEXT/PLAIN; CHARSET=US-ASCII
         C:
         C: Hello Joe, do you think we can meet at 3:30 tomorrow?
         C:
         S: A003 OK APPEND completed</pre><p>Отметим, что команда APPEND не используется для доставки почты, поскольку она не обеспечивает механизма передачи информации из конвертов [SMTP].</p><h3 id="p6.4">6.4. Команды клиента — состояние Selected</h3><p>В состоянии selected поддерживаются команды для работы с сообщениями в почтовом ящике.</p><p>В дополнение к универсальным командам (CAPABILITY, NOOP, LOGOUT), и командам после аутентификации (SELECT, EXAMINE, CREATE, DELETE, RENAME, SUBSCRIBE, UNSUBSCRIBE, LIST, LSUB, STATUS, APPEND) поддерживаются команды CHECK, CLOSE, EXPUNGE, SEARCH, FETCH, STORE, COPY, UID.</p><h4 id="p6.4.1">6.4.1. Команда CHECK</h4><table class="nobrd"><tr><td>Аргументы:</td><td>не используются</td></tr><tr><td>Отклик:</td><td>для этой команды не существует специфических откликов</td></tr><tr><td>Результат:</td><td>OK — проверка завершена успешно<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда CHECK запрашивает выполнение контрольной операции (checkpoint) для выбранного почтового ящика. Контрольная операция может быть любым действием, связанным с почтовым ящиком) и определяется используемой реализацией (примером такой контрольной операции может служить сброс содержимого почтового ящика из памяти сервера на диск). Выполнение контрольной операции может занимать достаточно много времени. Если сервер не поддерживает контрольных операций, команда CHECK становится эквивалентом команды NOOP.</p><p>Нет никакой гарантии, что после команды CHECK будет передаваться непомеченный отклик EXISTS — для гарантированного получения такого отклика следует использовать команду NOOP.</p><pre>Пример:  C: FXXZ CHECK
         S: FXXZ OK CHECK Completed</pre><h4 id="p6.4.2">6.4.2. Команда CLOSE</h4><table class="nobrd"><tr><td>Аргументы:</td><td>не используются</td></tr><tr><td>Отклик:</td><td>для этой команды не существует специфических откликов</td></tr><tr><td>Результат:</td><td>OK — выбор ящика отменен, текущее состояние authenticated<br />NO — отказ — не выбрано почтового ящика<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда CLOSE уничтожает в выбранном почтовом ящике все сообщения с установленным флагом \Deleted и обеспечивает возврат в состояние authenticated из состояния. В ответ на команду передается без тега отклик EXPUNGE. Сообщения не удаляются и сообщения об ошибке не возвращается, если почтовый ящик был выбран командой EXAMINE или открыт в режиме read-only (только чтение).</p><p>Если почтовый ящик выбран, команды SELECT, EXAMINE, LOGOUT могут вводиться без предшествующей команды CLOSE. Команды SELECT, EXAMINE и LOGOUT явно отменяют текущий выбор почтового ящика без удаления сообщений из него. Однако при наличии большого числа сообщений с флагом \Deleted последовательности CLOSELOGOUT и CLOSE-SELECT заметно быстрее, чем EXPUNGE-LOGOUT или EXPUNGE-SELECT, поскольку они не передают непомеченных откликов EXPUNGE (которые клиент обычно игнорирует).</p><pre>Пример:  C: A341 CLOSE
         S: A341 OK CLOSE completed</pre><h4 id="p6.4.3">6.4.3. Команда EXPUNGE</h4><table class="nobrd"><tr><td>Аргументы:</td><td>не используются</td></tr><tr><td>Отклик:</td><td>непомеченный отклик EXPUNGE</td></tr><tr><td>Результат:</td><td>OK — удаление завершено<br />NO — отказ при удалении (например, нет прав доступа)<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда EXPUNGE уничтожает из выбранного почтового ящика все сообщения с флагом \Deleted. Прежде, чем клиенту будет возвращен отклик OK, ему передается непомеченный отклик EXPUNGE для каждого удаленного письма.</p><pre>Пример:  C: A202 EXPUNGE
         S: * 3 EXPUNGE
         S: * 3 EXPUNGE
         S: * 5 EXPUNGE
         S: * 8 EXPUNGE
         S: A202 OK EXPUNGE completed</pre><p>В приведенном примере сообщения 3, 4, 7, 11 имеют флаг \Deleted (см. описание отклика EXPUNGE).</p><h4 id="p6.4.4">6.4.4. Команда SEARCH</h4><table class="nobrd"><tr><td>Аргументы:</td><td>[CHARSET], критерии поиска (один или несколько)</td></tr><tr><td>Отклик:</td><td>Обязательный непомеченный отклик SEARCH</td></tr><tr><td>Результат:</td><td>OK — удачное завершение поиска<br />NO — ошибка — невозможно : can't search that [CHARSET] or criteria<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда SEARCH обеспечивает поиск в почтовом ящике сообщений, удовлетворяющих заданным критериям. Критерий поиска содержит один или несколько ключей. Непомеченный отклик SEARCH от сервера содержит список порядковых номеров сообщений, которые соответствуют критерию поиска.</p><p>При использовании множества ключей поиска они комбинируются с помощью логической операции AND (и). Например, критерий DELETED FROM "SMITH" SINCE 1-Feb-1994 задает поиск всех удаленных сообщений от Smith, помещенных в ящик после 1 февраля 1994 года. При задании ключей поиска могут использоваться логические операции OR (или) и NOT (отрицание), а также скобки.</p><p>Сервер может исключать части [MIME-IMB] в теле сообщения с типами, отличными от TEXT или MESSAGE при выполнении команды SEARCH.</p><p>Необязательный параметр [CHARSET] состоит из ключевого слова CHARSET, за которым следует зарегистрированное значение [CHARSET]. Этот параметр задает набор символов в строке критерия поиска. Транспортное кодирование [MIME-IMB] и строки [MIME-HDRS] в заголовках [RFC-822]/[MIME-IMB] ДОЛЖНЫ декодироваться перед сравнением текста, если [CHARSET] отличается от US-ASCII. Кодировка US-ASCII должна поддерживаться, другие варианты [CHARSET] также можно поддерживать. Если сервер не поддерживает заданное значение [CHARSET], он должен возвращать помеченный отклик NO (а не BAD).</p><p>Во всех ключах поиска, содержащих строки текста, условие считается выполненным, если ключ поиска является частью строки в сообщении. Регистр символов при поиске не учитывается.</p><p>Ниже перечислен список поддерживаемых ключей, а их синтаксические определения приведены в главе 9. Формальный синтаксис.</p><table class="nobrd"><tr><td>&lt;message set&gt;</td><td>сообщения с порядковым номером, соответствующим указанному набору номеров.</td></tr><tr><td>ALL</td><td>все сообщения в почтовом ящике; принято по умолчанию как стартовый ключ для AND.</td></tr><tr><td>ANSWERED</td><td>сообщения с установленным флагом \Answered.</td></tr><tr><td>BCC &lt;string&gt;</td><td>сообщения, содержащие указанную строку в структуре поля BCC в конверте.</td></tr><tr><td>BEFORE &lt;date&gt;</td><td>сообщения, в которых внутренняя дата раньше указанной.</td></tr><tr><td>BODY &lt;string&gt;</td><td>сообщения, содержащие указанную строку в теле письма.</td></tr><tr><td>CC &lt;string&gt;</td><td>сообщения, содержащие указанную строку в структуре поля CC в конверте.</td></tr><tr><td>DELETED</td><td>сообщения с установленным флагом \Deleted.</td></tr><tr><td>DRAFT</td><td>сообщения с установленным флагом \Draft.</td></tr><tr><td>FLAGGED</td><td>сообщения с установленным флагом \Flagged.</td></tr><tr><td>FROM &lt;string&gt;</td><td>сообщения, содержащие указанную строку в структуре поля FROM в конверте.</td></tr><tr><td>HEADER &lt;field-name&gt; &lt;string&gt;</td><td>сообщения, в заголовке которых содержится поле с указанным именем (определено в [RFC-822]) и содержимым.</td></tr><tr><td>KEYWORD &lt;flag&gt;</td><td>сообщения с установленным флагом, который указан.</td></tr><tr><td>LARGER &lt;n&gt;</td><td>сообщения с размером [RFC-822], превышающим заданное число октетов.</td></tr><tr><td>NEW</td><td>сообщения с установленным флагом \Recent, но без флага \Seen (эквивалент RECENT UNSEEN — получено недавно и не прочитано)&quot;.</td></tr><tr><td>NOT &lt;search-key&gt;</td><td>сообщения, не соответствующие заданному ключу поиска.</td></tr><tr><td>OLD</td><td>сообщения без флага \Recent (функциональный эквивалент NOT RECENT).</td></tr><tr><td>ON &lt;date&gt;</td><td>сообщения, для которых внутренняя дата совпадает с заданной.</td></tr><tr><td>OR &lt;search-key1&gt; &lt;search-key2&gt;</td><td>сообщения, соответствующие хотя бы одному ключу поиска.</td></tr><tr><td>RECENT</td><td>сообщения с флагом \Recent.</td></tr><tr><td>SEEN</td><td>сообщения с флагом \Seen flag.</td></tr><tr><td>SENTBEFORE &lt;date&gt;</td><td>сообщения, для которых дата [RFC-822] Date: раньше указанной.</td></tr><tr><td>SENTON &lt;date&gt;</td><td>сообщения, для которых дата [RFC-822] Date: совпадает с указанной.</td></tr><tr><td>SENTSINCE &lt;date&gt;</td><td>сообщения, для которых дата [RFC-822] Date: совпадает с указанной или позже ее.</td></tr><tr><td>SINCE &lt;date&gt;</td><td>сообщения, для которых внутренняя дата совпадает с указанной или позже ее.</td></tr><tr><td>SMALLER &lt;n&gt;</td><td>сообщения размером [RFC-822] меньше указанного числа октетов.</td></tr><tr><td>SUBJECT &lt;string&gt;</td><td>сообщения, содержащие указанную строку в поле SUBJECT конверта.</td></tr><tr><td>TEXT &lt;string&gt;</td><td>сообщения, содержащие указанную строку в заголовке или теле письма.</td></tr><tr><td>TO &lt;string&gt;</td><td>сообщения, содержащие указанную строку в поле TO конверта.</td></tr><tr><td>UID &lt;message set&gt;</td><td>сообщения с уникальными идентификаторами, соответствующими указанному набору.</td></tr><tr><td>UNANSWERED</td><td>сообщения без флага \Answered.</td></tr><tr><td>UNDELETED</td><td>сообщения без флага \Deleted.</td></tr><tr><td>UNDRAFT</td><td>сообщения без флага \Draft.</td></tr><tr><td>UNFLAGGED</td><td>сообщения без флага \Flagged.</td></tr><tr><td>UNKEYWORD &lt;flag&gt;</td><td>сообщения без указанного ключом флага.</td></tr><tr><td>UNSEEN</td><td>сообщения без флага \Seen.</td></tr></table><pre>Пример:  C: A282 SEARCH FLAGGED SINCE 1-Feb-1994 NOT FROM "Smith"
         S: * SEARCH 2 84 882
         S: A282 OK SEARCH completed</pre><h4 id="p6.4.5">6.4.5. Команда FETCH</h4><table class="nobrd"><tr><td>Аргументы:</td><td>набор сообщений, имена элементов данных в сообщениях</td></tr><tr><td>Отклик:</td><td>непомеченный отклик FETCH</td></tr><tr><td>Результат:</td><td>OK — успешная выборка<br />NO — неудача при попытке выборки<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда FETCH отыскивает данные, связанные с сообщениями в почтовом ящике. Отыскиваемые данные могут задаваться с помощью атома или списка в скобках.</p><p>В настоящее время поддерживаются выборки для следующих типов данных:</p><table class="nobrd"><tr><td>ALL</td><td>Макроопределение для (FLAGS INTERNALDATE RFC822.SIZE ENVELOPE)</td></tr><tr><td>BODY</td><td>Нерасширяемая форма BODYSTRUCTURE</td></tr><tr><td>BODY[&lt;section&gt;]&lt;&lt;partial&gt;&gt;</td><td>Текст в конкретной секции тела сообщения. Спецификация секций сообщения (если она присутствует) задается номером или одним из идентификаторов: HEADER, HEADER.FIELDS, HEADER.FIELDS.NOT, MIME, TEXT. Пустая спецификация секции задает поиск по всему сообщению, включая заголовки.<p>Каждое сообщение имеет по крайней мере один номер секции (части сообщения). Сообщения, не относящиеся к [MIME-IMB], и сообщения [MIME-IMB] без инкапсуляции имеют только часть 1.</p><p>В многосекционных сообщениях каждая часть имеет порядковый номер (начиная с 1). Если отдельная часть имеет тип сообщения или содержит в себе отдельные части, нумерация должна задаваться двумя числами (через запятую) — сначала номер основной части, затем — вложенной. Части типа MESSAGE/RFC822 также имеют номера вложенных частей, указывающие на части тела сообщения.</p><p>Идентификаторы HEADER, HEADER.FIELDS, HEADER.FIELDS.NOT, TEXT могут указывать секцию сообщения сами по себе или использоваться с числовым префиксом, указывающим номер части типа MESSAGE/RFC822. Идентификатор MIME ДОЛЖЕН использоваться с одним или несколькими числовыми префиксами.</p><p>Идентификаторы HEADER, HEADER.FIELDS, HEADER.FIELDS.NOT указывают на заголовок сообщения [RFC-822] или инкапсулированного сообщения [MIME-IMT] MESSAGE/RFC822. Идентификаторы HEADER.FIELDS и HEADER.FIELDS.NOT сопровождаются списком имен полей (определены в [RFC-822]) и возвращают часть заголовка. Идентификатор HEADER.FIELDS задает возврат включены в список, а при использовании HEADER.FIELDS.NOT возвращаются поля, которые отсутствуют в списке. При сравнении имен полей регистр символов не учитывается, а в остальных случаях сравнение ведется с учетом регистра. Во всех случаях пустая строка между заголовком и телом сообщения включается в результат поиска.</p><p>Идентификатор MIME указывает на заголовок [MIME-IMB] для этой части.</p><p>Идентификатор TEXT указывает на текст тела сообщений без заголовка [RFC-822].</p><p>Ниже приведен пример сложного сообщения с указателями на его отдельные части:</p><pre>HEADER (заголовок [RFC-822] для сообщения)

TEXT        MULTIPART/MIXED
1           TEXT/PLAIN
2           APPLICATION/OCTET-STREAM
3           MESSAGE/RFC822
3.HEADER    (заголовок [RFC-822])
3.TEXT      (текст тела сообщения [RFC-822])
3.1         TEXT/PLAIN
3.2         APPLICATION/OCTET-STREAM
4           MULTIPART/MIXED
4.1         IMAGE/GIF
4.1.MIME    (заголовок [MIME-IMB] для IMAGE/GIF)
4.2         MESSAGE/RFC822
4.2.HEADER  (заголовок [RFC-822])
4.2.TEXT    (текст тела сообщения [RFC-822])
4.2.1       TEXT/PLAIN
4.2.2       MULTIPART/ALTERNATIVE
4.2.2.1     TEXT/PLAIN
4.2.2.2     TEXT/RICHTEXT</pre><p>Возможна выборка подстроки обозначенного текста, осуществляемая путем добавления конструкции &lt;позиция первого желаемого. максимальное число возвращаемых октетов&gt; к спецификатору выборки. Если стартовый октет указывает за пределы текста, возвращается пустая строка. Любая попытка частичной выборки за пределами текста усекается. Частичная выборка с позиции всегда дает результат, даже если происходит усекновение.</p><p>Отметим, что выборка подстроки для HEADER.FIELDS или HEADER.FIELDS.NOT рассчитывается после выделения из заголовка нужных полей. Флаг \Seen устанавливается явно; если это ведет к изменению флагов, их следует включать как часть откликов FETCH.</p></td></tr></table><table class="nobrd"><tr><td>BODY.PEEK[&lt;section&gt;]&lt;&lt;partial&gt;&gt;</td><td>Другая форма BODY[&lt;section&gt;], не устанавливающая явно флаг \Seen.</td></tr><tr><td>BODYSTRUCTURE</td><td>Структура [MIME-IMB] в теле сообщения, рассчитываемая сервером путем разбора полей заголовка [MIME-IMB] в заголовке [RFC-822] и заголовков [MIME-IMB].</td></tr><tr><td>ENVELOPE</td><td>Структура конверта в сообщении, рассчитываемая сервером путем разбора заголовка [RFC-822] на составные части с установкой при необходимости принятых по умолчанию значений полей.</td></tr><tr><td>FAST</td><td>Макроопределение для (FLAGS INTERNALDATE RFC822.SIZE)</td></tr><tr><td>FLAGS</td><td>Флаги, установленные для сообщения.</td></tr><tr><td>FULL</td><td>Макроопределение для (FLAGS INTERNALDATE RFC822.SIZE ENVELOPE BODY)</td></tr><tr><td>INTERNALDATE</td><td>Внутренняя дата сообщения.</td></tr><tr><td>RFC822</td><td>Функциональный эквивалент BODY[], отличающийся синтаксисом непомеченных данных FETCH (возвращается RFC822).</td></tr><tr><td>RFC822.HEADER</td><td>Функциональный эквивалент BODY.PEEK[HEADER], отличающийся синтаксисом непомеченных данных FETCH (возвращается RFC822.HEADER).</td></tr><tr><td>RFC822.SIZE</td><td>The [RFC-822] size of the message.</td></tr><tr><td>RFC822.TEXT</td><td>Функциональный эквивалент BODY[TEXT], отличающийся синтаксисом непомеченных данных FETCH (возвращается RFC822.TEXT).</td></tr><tr><td>UID</td><td>Уникальный идентификатор сообщения.</td></tr></table><pre>Пример:  C: A654 FETCH 2:4 (FLAGS BODY[HEADER.FIELDS (DATE FROM)])
         S: * 2 FETCH ....
         S: * 3 FETCH ....
         S: * 4 FETCH ....
         S: A654 OK FETCH completed</pre><h4 id="p6.4.6">6.4.6. Команда STORE</h4><table class="nobrd"><tr><td>Аргументы:</td><td>набор сообщений, значение для элемента данных сообщения</td></tr><tr><td>Отклик:</td><td>непомеченный отклик FETCH</td></tr><tr><td>Результат:</td><td>OK — успешная запись<br />NO — неудача<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда STORE изменяет данные для указанного сообщения в почтовом ящике. Обычно STORE возвращает измененное значение данных в непомеченном отклике FETCH. Суффикс ".SILENT" в имени элемента данных предотвращает возврат непомеченных откликов FETCH и серверу следует, что клиент способен сам определить обновленное значение или оно не требуется клиенту.</p><p>В настоящее время могут изменяться следующие данные:</p><table class="nobrd"><tr><td>FLAGS &lt;flag list&gt;</td><td>замена флагов сообщения; новые значения флагов возвращаются в непомеченном отклике FETCH.</td></tr><tr><td>FLAGS.SILENT &lt;flag list&gt;</td><td>эквивалент FLAGS, но без возврата новых флагов.</td></tr><tr><td>+FLAGS &lt;flag list&gt;</td><td>добавление флага; новые значения флагов возвращаются в непомеченном отклике FETCH.</td></tr><tr><td>+FLAGS.SILENT &lt;flag list&gt;</td><td>эквивалент +FLAGS, но без возврата новых флагов.</td></tr><tr><td>-FLAGS &lt;flag list&gt;</td><td>удаление флага для сообщения; новые значения флагов возвращаются в непомеченном отклике FETCH.</td></tr><tr><td>-FLAGS.SILENT &lt;flag list&gt;</td><td>эквивалент -FLAGS, но без возврата новых флагов.</td></tr></table><pre>Пример:  C: A003 STORE 2:4 +FLAGS (\Deleted)
         S: * 2 FETCH FLAGS (\Deleted \Seen)
         S: * 3 FETCH FLAGS (\Deleted)
         S: * 4 FETCH FLAGS (\Deleted \Flagged \Seen)
         S: A003 OK STORE completed</pre><h4 id="p6.4.7">6.4.7. Команда COPY</h4><table class="nobrd"><tr><td>Аргументы:</td><td>набор сообщений, имя почтового ящика</td></tr><tr><td>Отклик:</td><td>для этой команды не существует специфических откликов</td></tr><tr><td>Результат:</td><td>OK — успешное копирование<br />NO — неудача<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда COPY копирует указанные сообщения в конец заданного почтового ящика. Для копии следует сохранять внутреннюю дату и значения флагов.</p><p>Если указанного почтового ящика не существует, серверу следует возвращать сообщение об ошибке и не следует автоматически создавать почтовый ящик. Если нет очевидной невозможности создания почтового ящика с таким именем, сервер ДОЛЖЕН передавать код [TRYCREATE] в качестве префикса к тексту помеченного отклика NO. Это подсказывает клиенту возможность попытки создания почтового ящика с помощью команды CREATE и после этого использовать команду COPY, если почтовый ящик удалось создать.</p><p>При любой ошибке команды COPY сервер ДОЛЖЕН восстановить исходное состояние почтового ящика.</p><pre>Пример:  C: A003 COPY 2:4 MEETING
         S: A003 OK COPY completed</pre><h4 id="p6.4.8">6.4.8. Команда UID</h4><table class="nobrd"><tr><td>Аргументы:</td><td>имя команды, аргументы команды</td></tr><tr><td>Отклик:</td><td>непомеченный отклик FETCH, SEARCH</td></tr><tr><td>Результат:</td><td>OK — успешное завершение<br />NO — ошибка<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Команда UID имеет две формы. В первом варианте используются команды COPY, FETCH, STORE и аргументы соответствующей команды. Однако в качестве номеров при указании набора сообщений используются уникальные идентификаторы сообщений, а не их порядковые номера. Во второй форме команда UID использует команду SEARCH и ее набор аргументов. Интерпретация аргументов такая же, как для команды SEARCH, однако вместо порядковых номеров сообщений возвращаются их уникальные идентификаторы (UID). Например, команда UID SEARCH 1:100 UID 443:557 будет возвращать уникальные идентификаторы, соответствующие пересечению сообщений с порядковыми номерами от 1 до 100 и UID в диапазоне 443:557.</p><p>Допустимо включение диапазона сообщений, однако не гарантируется, что уникальные идентификаторы для диапазона образуют непрерывную последовательность. Несуществующие уникальные идентификаторы в заданном диапазоне будут игнорироваться без генерации сообщений об ошибках.</p><p>Число после "*" в непомеченном отклике FETCH всегда указывает порядковый номер сообщения, а не его уникальный идентификатор (даже в откликах на команду UID). Однако серверы ДОЛЖНЫ явно включать значения UID как часть откликов FETCH на команду UID, независимо от указания UID в качестве элемента данных для FETCH.</p><pre>Пример:  C: A999 UID FETCH 4827313:4828442 FLAGS
         S: * 23 FETCH (FLAGS (\Seen) UID 4827313)
         S: * 24 FETCH (FLAGS (\Seen) UID 4827943)
         S: * 25 FETCH (FLAGS (\Seen) UID 4828442)
         S: A999 UID FETCH completed</pre><h3 id="p6.5">6.5. Команды клиента — экспериментальные/расширения</h3><h4 id="p6.5.1">6.5.1. Команда X&lt;atom&gt;</h4><table class="nobrd"><tr><td>Аргументы:</td><td>зависит от реализации</td></tr><tr><td>Отклик:</td><td>зависит от реализации</td></tr><tr><td>Результат:</td><td>OK — успешное завершение<br />NO — неудача<br />BAD — команда не поддерживается или некорректны аргументы</td></tr></table><p>Все команды с префиксом X являются экспериментальными. Команды, которые не включены в данную спецификацию, ее расширения/пересмотры в стандартах и предложенных стандартах или одобренные IESG экспериментальные протоколы, ДОЛЖНЫ использовать префикс X.</p><p>Все добавляемые экспериментальными командами непомеченные отклики ДОЛЖНЫ начинаться с префикса X. Для серверов недопустима передача таких непомеченных откликов, если клиент не использует связанных экспериментальных команд.</p><pre>Пример:  C: a441 CAPABILITY
         S: * CAPABILITY IMAP4rev1 AUTH=KERBEROS_V4 XPIG-LATIN
         S: a441 OK CAPABILITY completed
         C: A442 XPIG-LATIN
         S: * XPIG-LATIN ow-nay eaking-spay ig-pay atin-lay
         S: A442 OK XPIG-LATIN ompleted-cay</pre><h2 id="p7">7. Отклики сервера</h2><p>Отклики сервера делятся на три типа — информация о состоянии, данные и запросы на продолжение команд. Информация, содержащаяся в откликах, помечена словом "Содержимое:" при описании отклика (но не его синтаксиса). Синтаксис откликов описан в главе 9. Формальный синтаксис.</p><p>Клиент ДОЛЖЕН сохранять постоянную готовность к получению откликов от сервера.</p><p>Статусные отклики могут быть отмеченными (tagged) или неотмеченными (untagged). Отмеченные отклики показывают результат (OK, NO, BAD) выполнения команды клиента и включают тег, соответствующий команде.</p><p>Все данные и некоторые статусные отклики передаются без тегов. Непомеченные отклики идентифицируются маркером "*" взамен тега. Непомеченные статусные отклики содержат приветствия сервера, или данные о состоянии, которые не показывают завершения команд (например, уведомление об отключении сервера — shutdown alert). В силу исторических причин неотмеченные статусные отклики сервера называют также unsolicited data (представленные без запроса данные), хотя, строго говоря, они не являются таковыми.</p><p>Некоторые данные от сервера ДОЛЖНЫ записываться клиентом — такие случаи явно указываются в описании данных. Данные этого типа содержат критически важную информацию, которая влияет на интерпретацию последующих команд и откликов (например, обновлений о создании или удалении сообщений).</p><p>Другие типы данных следует сохранять для использования в будущем; если клиенту не нужно записывать эти данные или смысл записи данных неясен (например, отклик SEARCH при отсутствии выполняемых команд SEARCH), такие данные следует игнорировать.</p><p>Непомеченные данные по инициативе сервера могут передаваться, когда соединение IMAP находится в состоянии selected. В этом состоянии сервер проверяет почтовый ящик на предмет появления в нем новых сообщений в результате выполнения команд. Обычно это является частью выполнения всех команд, следовательно, команда NOOP также инициирует проверку наличия новых сообщений. Если такие сообщения найдены, сервер передает непомеченные отклики EXISTS и RECENT, отражающие новый размер почтового ящика. Серверам, поддерживающим множественный доступ к почтовому ящику, следует также передавать подходящие непомеченные отклики FETCH и EXPUNGE, если другой агент изменяет состояние любого из флагов сообщений или удаляет какое-либо сообщение.</p><p>Запросы на продолжение команд используют маркер "+" взамен тега. Такие отклики передаются сервером для индикации восприятия сервером неполной команды клиента и готовности к получению оставшейся части команды.</p><h3 id="p7.1">7.1. Отклики сервера — состояние</h3><p>К статусным относятся отклики OK, NO, BAD, PREAUTH и BYE. Отклики OK, NO, BAD могут передаваться с тегами или без таковых, отклики PREAUTH и BYE всегда являются неотмеченными.</p><p>Статусные отклики могут включать дополнительно «код отклика» (response code), состоящий из данных в квадратных скобках в форме атома, за которыми может следовать пробел и аргументы. Код отклика содержит дополнительную информацию или коды состояния для клиентской программы (сверх результата OK/NO/BAD) и определяются для тех случаев, когда клиент на основе этой информации может предпринять дополнительные действия.</p><p>В настоящем документе определены следующие коды откликов:</p><table class="nobrd"><tr><td>ALERT</td><td>Текст для пользователя, содержащий специальное предупреждение, которое должно предостеречь пользователя понятным ему способом.</td></tr><tr><td>NEWNAME</td><td>С последующим именем нового почтового ящика. Команды SELECT и EXAMINE будут давать ошибку в связи с тем, что указанный почтовый ящик больше не существует в результате смены имени. Это является советом клиенту повторить операцию SELECT или EXAMINE с новым именем почтового ящика.</td></tr><tr><td>PARSE</td><td>Понятный пользователю текст, представляющий ошибку при разборе заголовка [RFC-822] или заголовков [MIME-IMB] в сообщении.</td></tr><tr><td>PERMANENTFLAGS</td><td>Вместе с последующим списком в скобках показывает какие из известных флагов клиент может поменять окончательно. Флаги, включенные в непомеченный отклик FLAGS, но отсутствующие в списке PERMANENTFLAGS нельзя изменить окончательно. Если клиент пытается сохранить с помощью команды STORE флаги, не указанные в списке PERMANENTFLAGS, сервер будет отвергать команду, возвращая отклик NO или сохранит флаги только до конца текущего сеанса. Список PERMANENTFLAGS может включать также специальный флаг \*, который показывает возможность создания новых ключевых слов за счет попытки сохранения этих флагов в почтовом ящике.</td></tr><tr><td>READ-ONLY</td><td>Почтовый ящик выбран в режиме «только для чтения» или доступ после выбора в режиме «чтения-записи» был изменен на read-only.</td></tr><tr><td>READ-WRITE</td><td>Почтовый ящик выбран для чтения и записи или после выбора в режиме «только чтение» доступ был изменен на read-write.</td></tr><tr><td>TRYCREATE</td><td>Неудачная попытка использования APPEND или COPY в результате отсутствия указанного почтового ящика (в отличие от других ошибок); этот отклик является советом клиенту сначала создать ящик с помощью команды CREATE, а потом повторить попытке.</td></tr><tr><td>UIDVALIDITY</td><td>Вместе со следующим десятичным числом показывает уникальный идентификатор корректности.</td></tr><tr><td>UNSEEN</td><td>Вместе со следующим десятичным числом показывает количество сообщений без флага \Seen.</td></tr></table><p>Дополнительные коды откликов, используемые клиентами и серверами, ДОЛЖНЫ начинаться с префикса "X", пока они не будут включены в новый вариант спецификации этого протокола. Клиентам следует игнорировать непонятные им коды откликов.</p><h4 id="p7.1.1">7.1.1. Отклик OK</h4><table class="nobrd"><tr><td>Содержимое:</td><td>НЕОБЯЗАТЕЛЬНЫЙ<br />текст для пользователя</td></tr></table><p>Отклик OK показывает информационное сообщение от сервера. Отклик с тегом говорит об успешном завершении указанной тегом команды. В отклик может дополнительно включаться текст, понятный пользователю. Отклик без тега указывает на информационное сообщение — природа информации может указываться кодом отклика. Отклики без тега используются также как одно из трех возможных приветствий при организации соединения, показывая, что аутентификации еще не прошла и требуется команда LOGIN.</p><pre>Пример:  S: * OK IMAP4rev1 server ready
         C: A001 LOGIN fred blurdybloop
         S: * OK [ALERT] System shutdown in 10 minutes
         S: A001 OK LOGIN Completed</pre><h4 id="p7.1.2">7.1.2. Отклик NO</h4><table class="nobrd"><tr><td>Содержимое:</td><td>НЕОБЯЗАТЕЛЬНЫЙ<br />текст для пользователя</td></tr></table><p>Отклик NO говорит о возникновении ошибки на сервере. Отклик с тегом говорит о неудачной попытке выполнения указанной тегом команды. Неотмеченная форма используется как предупреждение о том, что выполнение команды еще не завершено. В отклик может добавляться понятный пользователю текст.</p><pre>Пример:  C: A222 COPY 1:2 owatagusiam
         S: * NO Disk is 98% full, please delete unnecessary data
         S: A222 OK COPY completed
         C: A223 COPY 3:200 blurdybloop
         S: * NO Disk is 98% full, please delete unnecessary data
         S: * NO Disk is 99% full, please delete unnecessary data
         S: A223 NO COPY failed: disk is full</pre><h4 id="p7.1.3">7.1.3. Отклик BAD</h4><table class="nobrd"><tr><td>Содержимое:</td><td>НЕОБЯЗАТЕЛЬНЫЙ<br />текст для пользователя</td></tr></table><p>Отклик BAD говорит об ошибке на сервере. Отклики с тегом сообщают об ошибке протокольного уровня при обработке сервером указанной тегом команды. Непомеченные отклики показывают ошибки протокольного уровня, которые не удалась связать с определенной командой. Отклик может содержать текст, понятный пользователю.</p><pre>Пример:  C: ...very long command line...
         S: * BAD Command line too long
         C: ...empty line...
         S: * BAD Empty command line
         C: A443 EXPUNGE
         S: * BAD Disk crash, attempting salvage to a new disk!
         S: * OK Salvage successful, no data lost
         S: A443 OK Expunge completed</pre><h4 id="p7.1.4">7.1.4. Отклик PREAUTH</h4><table class="nobrd"><tr><td>Содержимое:</td><td>НЕОБЯЗАТЕЛЬНЫЙ<br />текст для пользователя</td></tr></table><p>Отклики PREAUTH всегда передаются без тега и служат в качестве одного из трех приветствий, передаваемых сервером при организации соединения. Отклик показывает, что аутентификация уже успешно проведена внешними силами и нет необходимости использовать команду LOGIN.</p><pre>Пример:  S: * PREAUTH IMAP4rev1 server logged in as Smith</pre><h4 id="p7.1.5">7.1.5. Отклик BYE</h4><table class="nobrd"><tr><td>Содержимое:</td><td>НЕОБЯЗАТЕЛЬНЫЙ<br />текст для пользователя</td></tr></table><p>Отклики BYE всегда передаются без тега и показывают, что сервер закрывает соединение. Для пользователя в отклик может добавляться текстовое сообщение. Отклик BYE может передаваться в четырех случаях:</p><ol><li>Часть нормальной процедуры завершения сеанса. Сервер будет закрывать соединение после передачи помеченного отклика OK для команды LOGOUT.</li><li>Часть анонса неожиданного завершения работы сервера (panic shutdown). Соединение закрывается незамедлительно.</li><li>Анонс завершения сеанса по тайм-ауту. Соединение закрывается незамедлительно.</li><li>Одно из трех возможных приветствий при организации соединения, показывающее, что сервер не желает открывать сеанс для данного клиента. Соединение закрывается незамедлительно.</li></ol><p>Различие между BYE при нормальной процедуре LOGOUT (случай 1) и в результате сбоя или отказа (остальные три ситуации) состоит в том, что в трех последних случаях сеанс закрывается немедленно.</p><pre>Пример:  S: * BYE Autologout; idle for too long</pre><h3 id="p7.2">7.2. Отклики сервера — состояние сервера и почтового ящика</h3><p>Эти отклики всегда передаются без тегов и служат для передачи клиенту данных о состоянии сервера и почтового ящика. Большинство этих откликов возвращается в результате вызова одноименных команд.</p><h4 id="p7.2.1">7.2.1. Отклик CAPABILITY</h4><table class="nobrd"><tr><td>Содержимое:</td><td>список возможностей</td></tr></table><p>Отклик CAPABILITY возвращается в результате использования команды CAPABILITY. Список возможностей содержит поддерживаемые сервером возможности с использованием пробела в качестве разделителя. Список возможностей должен включать атом IMAP4rev1.</p><p>Имена возможностей, начинающиеся с AUTH=, показывают, что сервер поддерживает тот или иной механизм аутентификации.</p><p>Другие имена возможностей показывают, что сервер поддерживает расширения, пересмотренные варианты или замену протокола IMAP4rev1. Отклики сервера ДОЛЖНЫ соответствовать данному документу, пока клиент не использует команд, связанных с соответствующими расширенными возможностями.</p><p>Имена возможностей ДОЛЖНЫ быть стандартными расширениями, пересмотрами или заменами протокола IMAP4rev1, зарегистрированными в IANA, если они не начинаются с префикса "X".</p><p>Клиентам не следует требовать поддержки имен, отличающихся от IMAP4rev1 и они ДОЛЖНЫ игнорировать неизвестные имена возможностей.</p><pre>Пример:  S: * CAPABILITY IMAP4rev1 AUTH=KERBEROS_V4 XPIG-LATIN</pre><h4 id="p7.2.2">7.2.2. Отклик LIST</h4><table class="nobrd"><tr><td>Содержимое:</td><td>атрибуты имени<br />разделитель уровней иерархии<br />имя</td></tr></table><p>Отклик LIST возвращается в результате вызова команды LIST и содержит одно имя, соответствующее спецификации в команде LIST. На одну команду LIST может возвращаться множество откликов LIST.</p><p>Определены 4 атрибута имен:</p><table class="nobrd"><tr><td>\Noinferiors</td><td>Для этого уровня иерархии невозможно существование любых дочерних уровней — их нет сейчас и не может быть в будущем.</td></tr><tr><td>\Noselect</td><td>Это имя нельзя использовать как выбранный почтовый ящик.</td></tr><tr><td>\Marked</td><td>Почтовый ящик отмечен сервером как «интересный» — возможно он содержит сообщения, добавленные с момента его предыдущего выбора.</td></tr><tr><td>\Unmarked</td><td>Почтовый ящик не содержит сообщений, добавленных после предыдущего обращение к нему.</td></tr></table><p>Если сервер не может определить «интересен» ли данный почтовый ящик, или имя имеет атрибут \Noselect, серверу не следует передавать атрибуты \Marked или \Unmarked.</p><p>Разделитель уровней иерархии представляет собой символ, используемый в качестве границы между соседними уровнями иерархии имен почтовых ящиков. Клиент может использовать разделитель для создания дочерних почтовых ящиков или поиска других уровней в иерархии имен. На всех уровнях иерархии ДОЛЖЕН использоваться одинаковый разделитель. Значение NIL в качестве разделителя уровней означает отсутствие иерархии (плоская модель именования). Имена представляются в иерархии слева направо и ДОЛЖНЫ быть приемлемы для использования в командах LIST и LSUB. Если не указан атрибут \Noselect имя также должно быть корректно как аргумент для команд, принимающих в качестве аргумента имя почтового ящика (например, SELECT).</p><pre>Пример:  S: * LIST (\Noselect) "/" ~/Mail/foo</pre><h4 id="p7.2.3">7.2.3. Отклик LSUB</h4><table class="nobrd"><tr><td>Содержимое:</td><td>атрибуты имени<br />разделитель уровней иерархии<br />имя</td></tr></table><p>Отклик LSUB возвращается в результате использования команды LSUB и содержит одно имя, соответствующее спецификации в команде LSUB. На одну команду LSUB может возвращаться множество откликов LSUB. Формат данных идентичен формату в откликах LIST.</p><pre>Пример:  S: * LSUB () "." #news.comp.mail.misc</pre><h4 id="p7.2.4">7.2.4. Отклик STATUS</h4><table class="nobrd"><tr><td>Содержимое:</td><td>имя<br />заключенный в скобки список состояний</td></tr></table><p>Отклик STATUS возвращается в результате вызова клиентом команды STATUS и содержит имя почтового ящика, соответствующее спецификации в команде STATUS, а также информацию о состоянии этого почтового ящика.</p><pre>Пример:  S: * STATUS blurdybloop (MESSAGES 231 UIDNEXT 44292)</pre><h4 id="p7.2.5">7.2.5. Отклик SEARCH</h4><table class="nobrd"><tr><td>Содержимое:</td><td>0 или более чисел</td></tr></table><p>Отклики SEARCH возвращаются в результате вызова команд SEARCH или UID SEARCH. Возвращаемые числа содержат порядковые номера (команда SEARCH) или уникальные идентификаторы (UID SEARCH) удовлетворяющих критериям поиска сообщений. В качестве разделителя используется символ пробела.</p><pre>Пример:  S: * SEARCH 2 3 6</pre><h4 id="p7.2.6">7.2.6. Отклик FLAGS</h4><table class="nobrd"><tr><td>Содержимое:</td><td>заключенный в скобки список флагов</td></tr></table><p>Отклики FLAGS возвращаются в результате использования клиентом команд SELECT или EXAMINE и содержат заключенный в скобки список флагов (как минимум, системные флаги), которые применимы к указанному почтовому ящику. Отличные от системных флаги используются в зависимости от реализации сервера. Обновления по сравнению с откликом FLAGS ДОЛЖНЫ записываться клиентом.</p><pre>Пример:  S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)</pre><h3 id="p7.3">7.3. Отклики сервера — размер почтового ящика</h3><p>Отклики этой группы всегда передаются без тегов и показывают клиенту изменения размера почтового ящика. Вслед за маркером "*" сразу же указывается число сообщений в почтовом ящике.</p><h4 id="p7.3.1">7.3.1. Отклик EXISTS</h4><table class="nobrd"><tr><td>Содержимое:</td><td>отсутствует</td></tr></table><p>Отклики EXISTS показывают число сообщений в почтовом ящике и передаются в результате использования команд SELECT и EXAMINE или при изменении почтового ящика (например, доставка нового письма). Обновления числа сообщений ДОЛЖНЫ записываться клиентом.</p><pre>Пример:  S: * 23 EXISTS</pre><h4 id="p7.3.2">7.3.2. Отклик RECENT</h4><table class="nobrd"><tr><td>Содержимое:</td><td>отсутствует</td></tr></table><p>Отклики RECENT говорят о числе сообщений с флагом \Recent и возвращаются в результате команд SELECT и EXAMINE или при изменении размера почтового ящика (например, в результате доставки нового письма).</p><p>Отметим, что непрерывность порядковых номеров свежих сообщений не гарантируется — они не обязательно занимают подряд n старших номеров в почтовом ящике (значение n возвращается откликом RECENT). Примером ситуации отсутствия такой непрерывности может быть одновременная работа множества клиентов работают с одним почтовым ящиком (первая уведомляемая сессия будет видеть свежие сообщения, остальные могут этого и не увидеть), а также случаи изменения порядка сообщений агентами, отличными от IMAP.</p><p>Надежными способами идентификации свежих сообщений являются только просмотр флагов и поиск или флага \Recent или использование команды SEARCH RECENT.</p><p>Обновление откликов RECENT должно записываться клиентом.</p><pre>Пример:  S: * 5 RECENT</pre><h3 id="p7.4">7.4. Отклики сервера — сообщение о состоянии</h3><p>Статусные отклики всегда передаются без тегов. Отклики часто передаются сервером в результате использования клиентом одноименной с откликом команды. Сразу после маркера "*" в откликах содержится число, указывающее порядковый номер сообщения.</p><h4 id="p7.4.1">7.4.1. Отклик EXPUNGE</h4><table class="nobrd"><tr><td>Содержимое:</td><td>отсутствует</td></tr></table><p>Отклик EXPUNGE информирует об уничтожении сообщения с указанным порядковым номером. Порядковый номер каждого следующего за уничтоженным сообщения уменьшается на 1 и это уменьшение отражается в нумерации для последующих откликов (включая и другие непомеченные отклики EXPUNGE).</p><p>Как результат правила немедленного уменьшения номеров, порядковые номера в последовательных откликах EXPUNGE зависят от порядка уничтожения сообщений (от старших номеров к младшим или наоборот). Например, при удалении последних 5 сообщений из ящика с 9 письмами, начиная с младшего номера, сервер будет передавать 5 последовательных непомеченных откликов EXPUNGE для сообщения с порядковым номером 5, тогда как при удалении со старшего номера отклики EXPUNGE будут возвращаться для сообщений 9, 8, 7, 6, 5.</p><p>Недопустимо передавать отклик EXPUNGE при отсутствии обрабатываемых команд или при обработке FETCH, STORE, SEARCH. Это правило позволяет избежать потери синхронизации порядковых номеров сообщений между клиентом и сервером.</p><p>Обновления откликов EXPUNGE ДОЛЖНЫ записываться клиентом.</p><pre>Пример:  S: * 44 EXPUNGE</pre><h4 id="p7.4.2">7.4.2. Отклик FETCH</h4><table class="nobrd"><tr><td>Содержимое:</td><td>данные сообщения</td></tr></table><p>Отклик FETCH возвращает клиенту данные о сообщении. Данные представляются в виде пар имя — значение, заключенных в скобки. Этот отклик возвращается по команде в результате команд FETCH и STORE или по инициативе сервера (например, в результате обновления флагов).</p><p>Настоящая спецификация определяет следующие типы данных:</p><table class="nobrd"><tr><td>BODY</td><td>форма BODYSTRUCTURE без расширения данных</td></tr><tr><td>BODY[&lt;section&gt;]&lt;&lt;origin_octet&gt;&gt;</td><td>Строковое выражение содержимого тела указанной части сообщения. Клиенту следует интерпретировать строку в соответствии с типом транспортного кодирования содержимого, типом и подтипом тела. Если указан начальный октет, эта строка является подстрокой всего содержимого тела, начиная с<p>начального октета. Это значит, что BODY[]&lt;0&gt; можно усечь, а BODY[] усекать недопустимо. Допустимо использование 8-битовых текстовых данных, если идентификатор [CHARSET] является частью заключенного в скобки списка параметров тела для этой секции. Отметим, что заголовки (спецификаторы частей HEADER и MIME или части заголовка MESSAGE/RFC822) ДОЛЖНЫ быть 7-битовыми (8-битовые символы недопустимы в заголовках). Отметим также, что в данные заголовка всегда включается пустая строка в конце.</p><p>Нетекстовые (бинарные) данные ДОЛЖНЫ передаваться с использованием преобразования в текст (например, BASE64) до передачи клиенту. Для восстановления исходных двоичных данных клиент должен декодировать строку транспортного кодирования.</p></td></tr><tr><td>BODYSTRUCTURE</td><td>Заключенный в скобки список, который описывает структуру тела сообщения [MIMEIMB]. Этот список создается сервером в результате разбора полей заголовка [MIME-IMB] и включения при необходимости принятых по умолчанию значений. Например, простое текстовое сообщение из 48 строк и 2279 октетов имеет структуру тела: ("TEXT" "PLAIN" ("CHARSET" "US-ASCII") NIL NIL "7BIT" 2279 48). При наличии множества частей они указываются вложенными списками в скобках. Вместо типа тела первого элемента заключенного в скобки списка помещается вложенное тело. Вторым элементов списка в скобках является подтип multipart (mixed, digest, parallel, alternative и т. п.). Например, сообщение из 2 частей, содержащее текст и данные в формате BASE64 может иметь структуру тела: (("TEXT" "PLAIN" ("CHARSET" "US-ASCII") NIL NIL "7BIT" 1152 23)("TEXT" "PLAIN" ("CHARSET" "US-ASCII" "NAME" "cc.diff") "&lt;960723163407.20117h@cac.washington.edu&gt;" "Compiler diff" "BASE64" 4554 73) "MIXED")) После подтипа multipart следует расширение данных. Это расширение никогда не возвращается в выборках BODY но может содержаться в выборках BODYSTRUCTURE. При наличии расширенных данных они должны размещаться в приведенном ниже порядке.<ul><li>body parameter parenthesized list</li><li class="lib">Заключенный в скобки список пар «атрибут-значение» (например, ("foo" "bar" "baz" "rag"), где "bar" является значением атрибута "foo", а "rag" — значением "baz") в соответствии с [MIME-IMB].</li><li>body disposition</li><li class="lib">Заключенный в скобки список, который содержит строку типа размещения, за которой следует заключенный в скобки список пар «атрибут размещения — значение». Типы размещения и имена атрибутов будут определены в будущей версии предложенного стандарта [DISPOSITION].</li><li>body language</li><li class="lib">Строка или заключенный в скобки список, указывающие язык тела в соответствии с [LANGUAGETAGS].</li></ul><p>Все последующие данные еще не определены в данной версии протокола. Такие расширения данных могут содержать 0 или более значений NIL, строк, чисел и потенциально вложенных заключенных в скобки списков таких данных. Реализации клиентов, использующие выборки BODYSTRUCTURE ДОЛЖНЫ быть готовы к восприятию расширенных данных такого типа. Для серверов недопустима передача таких расширений, пока они не будут определены при пересмотре данного протокола.</p><p>Базовые поля для тел, не содержащих множества частей (non-multipart body) имеют следующий порядок:</p><ul><li>body type</li><li class="lib">Строка, указывающая название типа среды в соответствии с [MIME-IMB].</li><li>body subtype</li><li class="lib">Строка, указывающая имя подтипа в соответствии с [MIME-IMB].</li><li>body parameter parenthesized list</li><li class="lib">Заключенный в скобки список пар «атрибут-значение» (например, ("foo" "bar" "baz" "rag"), где "bar" является значением атрибута "foo", а "rag" — значением "baz") в соответствии с [MIME-IMB].</li><li>body id</li><li class="lib">Строка, указывающая идентификатор содержимого в соответствии с [MIME-IMB].</li><li>body description</li><li class="lib">Строка, описывающая содержимое в соответствии с [MIME-IMB].</li><li>body encoding</li><li class="lib">Строка, указывающая транспортное кодирование в соответствии с [MIME-IMB].</li><li>body size</li><li class="lib">Число, показывающее размер тела в октетах. Отметим, что это число показывает размер для транспортного кодирования, а не размер после декодирования.</li></ul><p>Тело типа MESSAGE или подтипа RFC822 содержит сразу же после основных полей структуру конверта, структуру тела и размер текстовых строк инкапсулированного сообщения.</p><p>Тело типа TEXT содержит сразу же после основных полей размер и собственно тело в форме текстовых строк. Отметим, что поле размера задается для транспортного кодирования, а не для содержимого после декодирования.</p><p>После основных полей и перечисленных выше полей, связанных с конкретными типами сообщений, следуют поля расширения. Эти поля никогда не возвращаются в выборке BODY, но могут возвращаться выборкой BODYSTRUCTURE. При использовании расширенных данных они ДОЛЖНЫ размещаться в приведенном ниже порядке (для тел, не содержащих множества частей):</p><ul><li>body MD5</li><li class="lib">Строка, дающая значение MD5 в соответствии с определением [MD5].</li><li>body disposition</li><li class="lib">Список в скобках таким же содержимым и функциями, как расположение тела для multipart body part.</li><li>body language</li><li class="lib">Строка или заключенный в скобки список, указывающие язык тела сообщения в соответствии с [LANGUAGE-TAGS].</li></ul><p>Все последующие расширения данных еще не определены в этой версии протокола и описываются как данные multipart-расширений.</p></td></tr><tr><td>ENVELOPE</td><td>Заключенный в скобки список, описывающий структуру конверта в сообщении. Этот список создается сервером путем разбора заголовка [RFC-822] на составные части и включения при необходимости принятых по умолчанию значений. Поля в структуре конверта располагаются в следующем порядке: date, subject, from, sender, reply-to, to, cc, bcc, in-reply-to, and message-id. Поля date, subject, in-reply-to и message-id представляют собой текстовые строки, поля from, sender, reply-to, to, cc, bcc — заключенные в скобки списки адресных структур.<p>Адресная структура представляет собой заключенный в скобки список, который описывает адрес электронной почты. Поля структуры располагаются в следующем порядке: personal name, [SMTP] at-domainlist (source route), mailbox name, host name.</p><p>Групповой синтаксис [RFC-822] указывается специальной формой адресной структуры, в которой имя хоста имеет значение NIL. Если имя почтового ящика также имеет значение NIL, это говорит о маркере окончания группы (точка с запятой в синтаксисе RFC 822). Если имя почтового ящика отличается от NIL, это говорит о маркере начала группы и поле имени почтового ящика содержит имя группы.</p><p>Любые неприменимые поля конверта или адресной структуры содержат значение NIL. Отметим, что сервер должен по умолчанию брать значения полей reply-to и sender из поля from; предполагается, что клиент не обязан их знать.</p></td></tr><tr><td>FLAGS</td><td>Заключенный в скобки список флагов, установленных для сообщения.</td></tr><tr><td>INTERNALDATE</td><td>Строка, представляющая внутреннюю дату сообщения.</td></tr><tr><td>RFC822</td><td>Эквивалент BODY[].</td></tr><tr><td>RFC822.HEADER</td><td>Эквивалент BODY.PEEK[HEADER].</td></tr><tr><td>RFC822.SIZE</td><td>Число, выражающее размер [RFC-822] для сообщения.</td></tr><tr><td>RFC822.TEXT</td><td>Эквивалент BODY[TEXT].</td></tr><tr><td>UID</td><td>Число, выражающее уникальный идентификатор сообщения.</td></tr></table><pre>Пример:  S: * 23 FETCH (FLAGS (\Seen) RFC822.SIZE 44827)</pre><h3 id="p7.5">7.5. Отклики сервера — запрос продолжения команды</h3><p>Запросы на продолжение команды указываются маркером "+" взамен тега. Эта форма откликов показывает, что сервер готов воспринять от клиента продолжение команды. Остальная часть отклика представляет собой текстовую строку. Этот отклик используется в команде AUTHORIZATION для передачи сервером данных клиенту и запроса дополнительных данных от клиента. Этот же отклик применяется с любой командой, аргументом которой является литерал.</p><p>Клиенту не разрешается передавать октеты литералов, пока сервер не укажет готовность к их приему. Это позволяет серверу построчно обрабатывать команды и отвергать ошибки. Оставшаяся часть команды, включая завершающую последовательность CRLF передается в форме октетов. При наличии дополнительных аргументов они должны отделяться пробелом.</p><pre>Пример:  C: A001 LOGIN {11}
         S: + Ready for additional command text
         C: FRED FOOBAR {7}
         S: + Ready for additional command text
         C: fat man
         S: A001 OK LOGIN completed
         C: A044 BLURDYBLOOP {102856}
         S: A044 BAD No such command as "BLURDYBLOOP"</pre><h2 id="p8">8. Пример соединения IMAP4rev1</h2><p>Ниже приведен пример соединения IMAP4rev1 (длинные строки разделены на части только в целях форматирования).</p><pre>Пример:  S: * OK IMAP4rev1 Service Ready
         C: a001 login mrc secret
         S: a001 OK LOGIN completed
         C: a002 select inbox
         S: * 18 EXISTS
         S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
         S: * 2 RECENT
         S: * OK [UNSEEN 17] Message 17 is the first unseen message
         S: * OK [UIDVALIDITY 3857529045] UIDs valid
         S: a002 OK [READ-WRITE] SELECT completed
         C: a003 fetch 12 full
         S: * 12 FETCH (FLAGS (\Seen) INTERNALDATE &quot;17-Jul-1996 02:44:25 -0700&quot;
             RFC822.SIZE 4286 ENVELOPE (&quot;Wed, 17 Jul 1996 02:23:25 -0700 (PDT)&quot;
             &quot;IMAP4rev1 WG mtg summary and minutes&quot;
             ((&quot;Terry Gray&quot; NIL &quot;gray&quot; &quot;cac.washington.edu&quot;))
             ((&quot;Terry Gray&quot; NIL &quot;gray&quot; &quot;cac.washington.edu&quot;))
             ((&quot;Terry Gray&quot; NIL &quot;gray&quot; &quot;cac.washington.edu&quot;))
             ((NIL NIL &quot;imap&quot; &quot;cac.washington.edu&quot;))
             ((NIL NIL &quot;minutes&quot; &quot;CNRI.Reston.VA.US&quot;)
             (&quot;John Klensin&quot; NIL &quot;KLENSIN&quot; &quot;INFOODS.MIT.EDU&quot;)) NIL NIL
             &quot;&lt;B27397-0100000@cac.washington.edu&gt;&quot;)
             BODY (&quot;TEXT&quot; &quot;PLAIN&quot; (&quot;CHARSET&quot; &quot;US-ASCII&quot;) NIL NIL &quot;7BIT&quot; 3028 92))
         S: a003 OK FETCH completed
         C: a004 fetch 12 body[header]
         S: * 12 FETCH (BODY[HEADER] {350}
         S: Date: Wed, 17 Jul 1996 02:23:25 -0700 (PDT)
         S: From: Terry Gray &lt;gray@cac.washington.edu&gt;
         S: Subject: IMAP4rev1 WG mtg summary and minutes
         S: To: imap@cac.washington.edu
         S: cc: minutes@CNRI.Reston.VA.US, John Klensin &lt;KLENSIN@INFOODS.MIT.EDU&gt;
         S: Message-Id: &lt;B27397-0100000@cac.washington.edu&gt;
         S: MIME-Version: 1.0
         S: Content-Type: TEXT/PLAIN; CHARSET=US-ASCII
         S:
         S: )
         S: a004 OK FETCH completed
         C: a005 store 12 +flags \deleted
         S: * 12 FETCH (FLAGS (\Seen \Deleted))
         S: a005 OK +FLAGS completed
         C: a006 logout
         S: * BYE IMAP4rev1 server terminating connection
         S: a006 OK LOGOUT completed</pre><h2 id="p9">9. Формальный синтаксис</h2><p>В приведенной ниже спецификации синтаксиса используется расширенная форма Бэкуса-Наура (BNF), заданная в [RFC-822], с единственным исключением — символ-ограничитель (delimiter), используемый с "#" порождает один пробел (SPACE), а не одну или несколько запятых.</p><p>При наличии альтернативных или дополнительных правил, когда последующее правило отменяет действие указанного ранее правила, приоритет должно иметь правило, указанное раньше. Например, "\Seen" при рассмотрении флагов дает имя флага \Seen, а не расширение flag_extension, несмотря на возможность разборки "\Seen" как flag_extension. Некоторые (но не все) случаи использования этого правила отмечены ниже при описании синтаксиса. Если явно не указано иное, регистр символов не принимается во внимание. Строчные и прописные символы используются в описаниях синтаксиса для лучшего восприятия. Реализации ДОЛЖНЫ трактовать эти строки независимо от регистра символов.</p><pre>address         ::= &quot;(&quot; addr_name SPACE addr_adl SPACE addr_mailbox
                    SPACE addr_host &quot;)&quot;

addr_adl        ::= nstring
                    ;; Holds route from [RFC-822] route-addr if
                    ;; non-NIL

addr_host       ::= nstring
                    ;; NIL indicates [RFC-822] group syntax.
                    ;; Otherwise, holds [RFC-822] domain name

addr_mailbox    ::= nstring
                    ;; NIL indicates end of [RFC-822] group; if
                    ;; non-NIL and addr_host is NIL, holds
                    ;; [RFC-822] group name.
                    ;; Otherwise, holds [RFC-822] local-part

addr_name       ::= nstring
                    ;; Holds phrase from [RFC-822] mailbox if
                    ;; non-NIL

alpha           ::= &quot;A&quot; / &quot;B&quot; / &quot;C&quot; / &quot;D&quot; / &quot;E&quot; / &quot;F&quot; / &quot;G&quot; / &quot;H&quot; /
                    &quot;I&quot; / &quot;J&quot; / &quot;K&quot; / &quot;L&quot; / &quot;M&quot; / &quot;N&quot; / &quot;O&quot; / &quot;P&quot; /
                    &quot;Q&quot; / &quot;R&quot; / &quot;S&quot; / &quot;T&quot; / &quot;U&quot; / &quot;V&quot; / &quot;W&quot; / &quot;X&quot; /
                    &quot;Y&quot; / &quot;Z&quot; /
                    &quot;a&quot; / &quot;b&quot; / &quot;c&quot; / &quot;d&quot; / &quot;e&quot; / &quot;f&quot; / &quot;g&quot; / &quot;h&quot; /
                    &quot;i&quot; / &quot;j&quot; / &quot;k&quot; / &quot;l&quot; / &quot;m&quot; / &quot;n&quot; / &quot;o&quot; / &quot;p&quot; /
                    &quot;q&quot; / &quot;r&quot; / &quot;s&quot; / &quot;t&quot; / &quot;u&quot; / &quot;v&quot; / &quot;w&quot; / &quot;x&quot; /
                    &quot;y&quot; / &quot;z&quot;
                    ;; Case-sensitive

append          ::= &quot;APPEND&quot; SPACE mailbox [SPACE flag_list]
                    [SPACE date_time] SPACE literal

astring         ::= atom / string

atom            ::= 1*ATOM_CHAR

ATOM_CHAR       ::= &lt;any CHAR except atom_specials&gt;

atom_specials   ::= &quot;(&quot; / &quot;)&quot; / &quot;{&quot; / SPACE / CTL / list_wildcards /
                    quoted_specials

authenticate    ::= &quot;AUTHENTICATE&quot; SPACE auth_type *(CRLF base64)

auth_type       ::= atom
                    ;; Defined by [IMAP-AUTH]

base64          ::= *(4base64_char) [base64_terminal]

base64_char     ::= alpha / digit / &quot;+&quot; / &quot;/&quot;

base64_terminal ::= (2base64_char &quot;==&quot;) / (3base64_char &quot;=&quot;)

body            ::= &quot;(&quot; body_type_1part / body_type_mpart &quot;)&quot;

body_extension  ::= nstring / number / &quot;(&quot; 1#body_extension &quot;)&quot;
                    ;; Future expansion.  Client implementations
                    ;; MUST accept body_extension fields.  Server
                    ;; implementations MUST NOT generate
                    ;; body_extension fields except as defined by
                    ;; future standard or standards-track
                    ;; revisions of this specification.

body_ext_1part  ::= body_fld_md5 [SPACE body_fld_dsp
                    [SPACE body_fld_lang
                    [SPACE 1#body_extension]]]
                    ;; MUST NOT be returned on non-extensible
                    ;; &quot;BODY&quot; fetch

body_ext_mpart  ::= body_fld_param
                    [SPACE body_fld_dsp SPACE body_fld_lang
                    [SPACE 1#body_extension]]
                    ;; MUST NOT be returned on non-extensible
                    ;; &quot;BODY&quot; fetch

body_fields     ::= body_fld_param SPACE body_fld_id SPACE
                    body_fld_desc SPACE body_fld_enc SPACE
                    body_fld_octets

body_fld_desc   ::= nstring

body_fld_dsp    ::= &quot;(&quot; string SPACE body_fld_param &quot;)&quot; / nil

body_fld_enc    ::= (&lt;&quot;&gt; (&quot;7BIT&quot; / &quot;8BIT&quot; / &quot;BINARY&quot; / &quot;BASE64&quot;/
                    &quot;QUOTED-PRINTABLE&quot;) &lt;&quot;&gt;) / string

body_fld_id     ::= nstring

body_fld_lang   ::= nstring / &quot;(&quot; 1#string &quot;)&quot;

body_fld_lines  ::= number

body_fld_md5    ::= nstring

body_fld_octets ::= number

body_fld_param  ::= &quot;(&quot; 1#(string SPACE string) &quot;)&quot; / nil

body_type_1part ::= (body_type_basic / body_type_msg / body_type_text)
                    [SPACE body_ext_1part]

body_type_basic ::= media_basic SPACE body_fields
                    ;; MESSAGE subtype MUST NOT be &quot;RFC822&quot;

body_type_mpart ::= 1*body SPACE media_subtype
                    [SPACE body_ext_mpart]

body_type_msg   ::= media_message SPACE body_fields SPACE envelope
                    SPACE body SPACE body_fld_lines

body_type_text  ::= media_text SPACE body_fields SPACE body_fld_lines

capability      ::= &quot;AUTH=&quot; auth_type / atom
                    ;; New capabilities MUST begin with &quot;X&quot; or be
                    ;; registered with IANA as standard or
                    ;; standards-track

capability_data ::= &quot;CAPABILITY&quot; SPACE [1#capability SPACE] &quot;IMAP4rev1&quot;
                    [SPACE 1#capability]
                    ;; IMAP4rev1 servers which offer RFC 1730
                    ;; compatibility MUST list &quot;IMAP4&quot; as the first
                    ;; capability.

CHAR            ::= &lt;any 7-bit US-ASCII character except NUL,
                     0x01 - 0x7f&gt;

CHAR8           ::= &lt;any 8-bit octet except NUL, 0x01 - 0xff&gt;

command         ::= tag SPACE (command_any / command_auth /
                    command_nonauth / command_select) CRLF
                    ;; Modal based on state

command_any     ::= &quot;CAPABILITY&quot; / &quot;LOGOUT&quot; / &quot;NOOP&quot; / x_command
                    ;; Valid in all states

command_auth    ::= append / create / delete / examine / list / lsub /
                    rename / select / status / subscribe / unsubscribe
                    ;; Valid only in Authenticated or Selected state

command_nonauth ::= login / authenticate
                    ;; Valid only when in Non-Authenticated state

command_select  ::= &quot;CHECK&quot; / &quot;CLOSE&quot; / &quot;EXPUNGE&quot; /
                     copy / fetch / store / uid / search
                    ;; Valid only when in Selected state

continue_req    ::= &quot;+&quot; SPACE (resp_text / base64)

copy            ::= &quot;COPY&quot; SPACE set SPACE mailbox

CR              ::= &lt;ASCII CR, carriage return, 0x0D&gt;

create          ::= &quot;CREATE&quot; SPACE mailbox
                    ;; Use of INBOX gives a NO error

CRLF            ::= CR LF

CTL             ::= &lt;any ASCII control character and DEL,
                        0x00 - 0x1f, 0x7f&gt;

date            ::= date_text / &lt;&quot;&gt; date_text &lt;&quot;&gt;

date_day        ::= 1*2digit
                    ;; Day of month

date_day_fixed  ::= (SPACE digit) / 2digit
                    ;; Fixed-format version of date_day

date_month      ::= &quot;Jan&quot; / &quot;Feb&quot; / &quot;Mar&quot; / &quot;Apr&quot; / &quot;May&quot; / &quot;Jun&quot; /
                    &quot;Jul&quot; / &quot;Aug&quot; / &quot;Sep&quot; / &quot;Oct&quot; / &quot;Nov&quot; / &quot;Dec&quot;

date_text       ::= date_day &quot;-&quot; date_month &quot;-&quot; date_year

date_year       ::= 4digit

date_time       ::= &lt;&quot;&gt; date_day_fixed &quot;-&quot; date_month &quot;-&quot; date_year
                    SPACE time SPACE zone &lt;&quot;&gt;

delete          ::= &quot;DELETE&quot; SPACE mailbox
                    ;; Use of INBOX gives a NO error

digit           ::= &quot;0&quot; / digit_nz

digit_nz        ::= &quot;1&quot; / &quot;2&quot; / &quot;3&quot; / &quot;4&quot; / &quot;5&quot; / &quot;6&quot; / &quot;7&quot; / &quot;8&quot; /
                    &quot;9&quot;

envelope        ::= &quot;(&quot; env_date SPACE env_subject SPACE env_from
                    SPACE env_sender SPACE env_reply_to SPACE env_to
                    SPACE env_cc SPACE env_bcc SPACE env_in_reply_to
                    SPACE env_message_id &quot;)&quot;

env_bcc         ::= &quot;(&quot; 1*address &quot;)&quot; / nil

env_cc          ::= &quot;(&quot; 1*address &quot;)&quot; / nil

env_date        ::= nstring

env_from        ::= &quot;(&quot; 1*address &quot;)&quot; / nil

env_in_reply_to ::= nstring

env_message_id  ::= nstring

env_reply_to    ::= &quot;(&quot; 1*address &quot;)&quot; / nil

env_sender      ::= &quot;(&quot; 1*address &quot;)&quot; / nil

env_subject     ::= nstring

env_to          ::= &quot;(&quot; 1*address &quot;)&quot; / nil

examine         ::= &quot;EXAMINE&quot; SPACE mailbox

fetch           ::= &quot;FETCH&quot; SPACE set SPACE (&quot;ALL&quot; / &quot;FULL&quot; /
                    &quot;FAST&quot; / fetch_att / &quot;(&quot; 1#fetch_att &quot;)&quot;)

fetch_att       ::= &quot;ENVELOPE&quot; / &quot;FLAGS&quot; / &quot;INTERNALDATE&quot; /
                    &quot;RFC822&quot; [&quot;.HEADER&quot; / &quot;.SIZE&quot; / &quot;.TEXT&quot;] /
                    &quot;BODY&quot; [&quot;STRUCTURE&quot;] / &quot;UID&quot; /
                    &quot;BODY&quot; [&quot;.PEEK&quot;] section
                    [&quot;&lt;&quot; number &quot;.&quot; nz_number &quot;&gt;&quot;]

flag            ::= &quot;\Answered&quot; / &quot;\Flagged&quot; / &quot;\Deleted&quot; /
                    &quot;\Seen&quot; / &quot;\Draft&quot; / flag_keyword / flag_extension

flag_extension  ::= &quot;\&quot; atom
                    ;; Future expansion.  Client implementations
                    ;; MUST accept flag_extension flags.  Server
                    ;; implementations MUST NOT generate
                    ;; flag_extension flags except as defined by
                    ;; future standard or standards-track
                    ;; revisions of this specification.

flag_keyword    ::= atom

flag_list       ::= &quot;(&quot; #flag &quot;)&quot;

greeting        ::= &quot;*&quot; SPACE (resp_cond_auth / resp_cond_bye) CRLF

header_fld_name ::= astring

header_list     ::= &quot;(&quot; 1#header_fld_name &quot;)&quot;

LF              ::= &lt;ASCII LF, line feed, 0x0A&gt;

list            ::= &quot;LIST&quot; SPACE mailbox SPACE list_mailbox

list_mailbox    ::= 1*(ATOM_CHAR / list_wildcards) / string

list_wildcards  ::= &quot;%&quot; / &quot;*&quot;

literal         ::= &quot;{&quot; number &quot;}&quot; CRLF *CHAR8
                    ;; Number represents the number of CHAR8 octets

login           ::= &quot;LOGIN&quot; SPACE userid SPACE password

lsub            ::= &quot;LSUB&quot; SPACE mailbox SPACE list_mailbox

mailbox         ::= &quot;INBOX&quot; / astring
                    ;; INBOX is case-insensitive.  All case variants of
                    ;; INBOX (e.g. &quot;iNbOx&quot;) MUST be interpreted as INBOX
                    ;; not as an astring.  Refer to section 5.1 for
                    ;; further semantic details of mailbox names.

mailbox_data    ::=  &quot;FLAGS&quot; SPACE flag_list /
                     &quot;LIST&quot; SPACE mailbox_list /
                     &quot;LSUB&quot; SPACE mailbox_list /
                     &quot;MAILBOX&quot; SPACE text /
                     &quot;SEARCH&quot; [SPACE 1#nz_number] /
                     &quot;STATUS&quot; SPACE mailbox SPACE
                     &quot;(&quot; #&lt;status_att number &quot;)&quot; /
                     number SPACE &quot;EXISTS&quot; / number SPACE &quot;RECENT&quot;

mailbox_list    ::= &quot;(&quot; #(&quot;\Marked&quot; / &quot;\Noinferiors&quot; /
                    &quot;\Noselect&quot; / &quot;\Unmarked&quot; / flag_extension) &quot;)&quot;
                    SPACE (&lt;&quot;&gt; QUOTED_CHAR &lt;&quot;&gt; / nil) SPACE mailbox

media_basic     ::= (&lt;&quot;&gt; (&quot;APPLICATION&quot; / &quot;AUDIO&quot; / &quot;IMAGE&quot; /
                    &quot;MESSAGE&quot; / &quot;VIDEO&quot;) &lt;&quot;&gt;) / string)
                    SPACE media_subtype
                    ;; Defined in [MIME-IMT]

media_message   ::= &lt;&quot;&gt; &quot;MESSAGE&quot; &lt;&quot;&gt; SPACE &lt;&quot;&gt; &quot;RFC822&quot; &lt;&quot;&gt;
                    ;; Defined in [MIME-IMT]

media_subtype   ::= string
                    ;; Defined in [MIME-IMT]

media_text      ::= &lt;&quot;&gt; &quot;TEXT&quot; &lt;&quot;&gt; SPACE media_subtype
                    ;; Defined in [MIME-IMT]

message_data    ::= nz_number SPACE (&quot;EXPUNGE&quot; /
                                    (&quot;FETCH&quot; SPACE msg_att))

msg_att         ::= &quot;(&quot; 1#(&quot;ENVELOPE&quot; SPACE envelope /
                    &quot;FLAGS&quot; SPACE &quot;(&quot; #(flag / &quot;\Recent&quot;) &quot;)&quot; /
                    &quot;INTERNALDATE&quot; SPACE date_time /
                    &quot;RFC822&quot; [&quot;.HEADER&quot; / &quot;.TEXT&quot;] SPACE nstring /
                    &quot;RFC822.SIZE&quot; SPACE number /
                    &quot;BODY&quot; [&quot;STRUCTURE&quot;] SPACE body /
                    &quot;BODY&quot; section [&quot;&lt;&quot; number &quot;&gt;&quot;] SPACE nstring /
                    &quot;UID&quot; SPACE uniqueid) &quot;)&quot;

nil             ::= &quot;NIL&quot;

nstring         ::= string / nil

number          ::= 1*digit
                    ;; Unsigned 32-bit integer
                    ;; (0 &lt;= n &lt; 4,294,967,296)

nz_number       ::= digit_nz *digit
                    ;; Non-zero unsigned 32-bit integer
                    ;; (0 &lt; n &lt; 4,294,967,296)

password        ::= astring

quoted          ::= &lt;&quot;&gt; *QUOTED_CHAR &lt;&quot;&gt;

QUOTED_CHAR     ::= &lt;any TEXT_CHAR except quoted_specials&gt; /
                    &quot;\&quot; quoted_specials

quoted_specials ::= &lt;&quot;&gt; / &quot;\&quot;

rename          ::= &quot;RENAME&quot; SPACE mailbox SPACE mailbox
                    ;; Use of INBOX as a destination gives a NO error

response        ::= *(continue_req / response_data) response_done

response_data   ::= &quot;*&quot; SPACE (resp_cond_state / resp_cond_bye /
                    mailbox_data / message_data / capability_data)
                    CRLF

response_done   ::= response_tagged / response_fatal

response_fatal  ::= &quot;*&quot; SPACE resp_cond_bye CRLF
                    ;; Server closes connection immediately

response_tagged ::= tag SPACE resp_cond_state CRLF

resp_cond_auth  ::= (&quot;OK&quot; / &quot;PREAUTH&quot;) SPACE resp_text
                    ;; Authentication condition

resp_cond_bye   ::= &quot;BYE&quot; SPACE resp_text

resp_cond_state ::= (&quot;OK&quot; / &quot;NO&quot; / &quot;BAD&quot;) SPACE resp_text
                    ;; Status condition

resp_text       ::= [&quot;[&quot; resp_text_code &quot;]&quot; SPACE] (text_mime2 / text)
                    ;; text SHOULD NOT begin with &quot;[&quot; or &quot;=&quot;

resp_text_code  ::= &quot;ALERT&quot; / &quot;PARSE&quot; /
                    &quot;PERMANENTFLAGS&quot; SPACE &quot;(&quot; #(flag / &quot;\*&quot;) &quot;)&quot; /
                    &quot;READ-ONLY&quot; / &quot;READ-WRITE&quot; / &quot;TRYCREATE&quot; /
                    &quot;UIDVALIDITY&quot; SPACE nz_number /
                    &quot;UNSEEN&quot; SPACE nz_number /
                    atom [SPACE 1*&lt;any TEXT_CHAR except &quot;]&quot;&gt;]

search          ::= &quot;SEARCH&quot; SPACE [&quot;CHARSET&quot; SPACE astring SPACE]
                    1#search_key
                    ;; [CHARSET] MUST be registered with IANA

search_key      ::= &quot;ALL&quot; / &quot;ANSWERED&quot; / &quot;BCC&quot; SPACE astring /
                    &quot;BEFORE&quot; SPACE date / &quot;BODY&quot; SPACE astring /
                    &quot;CC&quot; SPACE astring / &quot;DELETED&quot; / &quot;FLAGGED&quot; /
                    &quot;FROM&quot; SPACE astring /
                    &quot;KEYWORD&quot; SPACE flag_keyword / &quot;NEW&quot; / &quot;OLD&quot; /
                    &quot;ON&quot; SPACE date / &quot;RECENT&quot; / &quot;SEEN&quot; /
                    &quot;SINCE&quot; SPACE date / &quot;SUBJECT&quot; SPACE astring /
                    &quot;TEXT&quot; SPACE astring / &quot;TO&quot; SPACE astring /
                    &quot;UNANSWERED&quot; / &quot;UNDELETED&quot; / &quot;UNFLAGGED&quot; /
                    &quot;UNKEYWORD&quot; SPACE flag_keyword / &quot;UNSEEN&quot; /
                    ;; Above this line were in [IMAP2]
                    &quot;DRAFT&quot; /
                    &quot;HEADER&quot; SPACE header_fld_name SPACE astring /
                    &quot;LARGER&quot; SPACE number / &quot;NOT&quot; SPACE search_key /
                    &quot;OR&quot; SPACE search_key SPACE search_key /
                    &quot;SENTBEFORE&quot; SPACE date / &quot;SENTON&quot; SPACE date /
                    &quot;SENTSINCE&quot; SPACE date / &quot;SMALLER&quot; SPACE number /
                    &quot;UID&quot; SPACE set / &quot;UNDRAFT&quot; / set /
                    &quot;(&quot; 1#search_key &quot;)&quot;

section         ::= &quot;[&quot; [section_text / (nz_number *[&quot;.&quot; nz_number]
                    [&quot;.&quot; (section_text / &quot;MIME&quot;)])] &quot;]&quot;

section_text    ::= &quot;HEADER&quot; / &quot;HEADER.FIELDS&quot; [&quot;.NOT&quot;]
                    SPACE header_list / &quot;TEXT&quot;

select          ::= &quot;SELECT&quot; SPACE mailbox

sequence_num    ::= nz_number / &quot;*&quot;
                    ;; * is the largest number in use.  For message
                    ;; sequence numbers, it is the number of messages
                    ;; in the mailbox.  For unique identifiers, it is
                    ;; the unique identifier of the last message in
                    ;; the mailbox.

set             ::= sequence_num / (sequence_num &quot;:&quot; sequence_num) /
                    (set &quot;,&quot; set)
                    ;; Identifies a set of messages.  For message
                    ;; sequence numbers, these are consecutive
                    ;; numbers from 1 to the number of messages in
                    ;; the mailbox
                    ;; Comma delimits individual numbers, colon
                    ;; delimits between two numbers inclusive.
                    ;; Example: 2,4:7,9,12:* is 2,4,5,6,7,9,12,13,
                    ;; 14,15 for a mailbox with 15 messages.

SPACE           ::= &lt;ASCII SP, space, 0x20&gt;

status          ::= &quot;STATUS&quot; SPACE mailbox SPACE &quot;(&quot; 1#status_att &quot;)&quot;

status_att      ::= &quot;MESSAGES&quot; / &quot;RECENT&quot; / &quot;UIDNEXT&quot; / &quot;UIDVALIDITY&quot; /
                    &quot;UNSEEN&quot;

store           ::= &quot;STORE&quot; SPACE set SPACE store_att_flags

store_att_flags ::= ([&quot;+&quot; / &quot;-&quot;] &quot;FLAGS&quot; [&quot;.SILENT&quot;]) SPACE
                    (flag_list / #flag)

string          ::= quoted / literal

subscribe       ::= &quot;SUBSCRIBE&quot; SPACE mailbox

tag             ::= 1*&lt;any ATOM_CHAR except &quot;+&quot;&gt;

text            ::= 1*TEXT_CHAR

text_mime2       ::= &quot;=?&quot; &lt;charset&gt; &quot;?&quot; &lt;encoding&gt; &quot;?&quot;
                     &lt;encoded-text&gt; &quot;?=&quot;
                     ;; Syntax defined in [MIME-HDRS]

TEXT_CHAR       ::= &lt;any CHAR except CR and LF&gt;

time            ::= 2digit &quot;:&quot; 2digit &quot;:&quot; 2digit
                    ;; Hours minutes seconds

uid             ::= &quot;UID&quot; SPACE (copy / fetch / search / store)
                    ;; Unique identifiers used instead of message
                    ;; sequence numbers

uniqueid        ::= nz_number
                    ;; Strictly ascending

unsubscribe     ::= &quot;UNSUBSCRIBE&quot; SPACE mailbox

userid          ::= astring

x_command       ::= &quot;X&quot; atom &lt;experimental command arguments&gt;

zone            ::= (&quot;+&quot; / &quot;-&quot;) 4digit
                    ;; Signed four-digit value of hhmm representing
                    ;; hours and minutes west of Greenwich (that is,
                    ;; (the amount that the given time differs from
                    ;; Universal Time).  Subtracting the timezone
                    ;; from the given time will give the UT form.
                    ;; The Universal Time zone is &quot;+0000&quot;.</pre><h2 id="p10">10. Примечание автора</h2><p>Этот документ является пересмотром предшествующих документов и переписывает спецификации протокола, включенные в эти документы — RFC 1730, неопубликованный документ IMAP2bis, RFC 1176, RFC 1064.</p><h2 id="p11">11. Вопросы безопасности</h2><p>Транзакции протокола IMAP4rev1, включая данные электронной почты, передаются через сеть в открытом виде, если с помощью команды AUTHENTICATE не согласована защита передаваемой информации.</p><p>В сообщение сервера об отказе при выполнении команды AUTHENTICATE, которая произошла вследствие передачи некорректных полномочий (credentials) не следует включать детали некорректности представленных полномочий. При использовании команды LOGIN пароль передается в открытом виде. Этого можно избежать путем использования команды AUTHENTICATE взамен LOGIN. Сообщение об отказе при выполнении команды LOGIN не следует указывать пару "имя пользователя — пароль", для которой получен отказ.</p><p>Дополнительные аспекты обеспечения безопасности рассмотрены в описании команд AUTHENTICATE и LOGIN.</p><h2 id="p12">12. Адрес автора</h2><p>Mark R. Crispin<br />Networks and Distributed Computing<br />University of Washington<br />4545 15th Aveneue NE<br />Seattle, WA 98105-4527<br />Phone: (206) 543-5762<br />EMail:  <bdo dir="rtl">&#117;&#100;&#101;&#46;&#110;&#111;&#116;&#103;&#110;&#105;&#104;&#115;&#97;&#119;&#46;&#99;&#97;&#99;&#64;&#99;&#114;&#109;</bdo></p><h2 id="p.appendix">Приложения</h2><h3 id="p.appendix.a">A. Литература</h3><table itemprop="references"><tr><td>[ACAP]</td><td>Myers, J. «ACAP — Application Configuration Access Protocol», Work in Progress.</td></tr><tr><td>[CHARSET]</td><td>Reynolds, J., and J. Postel, «Assigned Numbers», STD 2, RFC 1700, USC/Information Sciences Institute, October 1994.</td></tr><tr><td>[DISPOSITION]</td><td>Troost, R., and Dorner, S., «Communicating Presentation Information in Internet Messages: The Content-Disposition Header», RFC 1806, Июнь 1995.</td></tr><tr><td>[IMAP-AUTH]</td><td>Myers, J., «IMAP4 Authentication Mechanism», RFC 1731. Carnegie-Mellon University, Декабрь 1994.</td></tr><tr><td>[IMAP-COMPAT]</td><td>Crispin, M., «IMAP4 Compatibility with IMAP2bis», RFC 2061, University of Washington, Ноябрь 1996.</td></tr><tr><td>[IMAP-DISC]</td><td>Austein, R., «Synchronization Operations for Disconnected IMAP4 Clients», Work in Progress.</td></tr><tr><td class="nobr">[IMAP-HISTORICAL]</td><td>Crispin, M. «IMAP4 Compatibility with IMAP2 and IMAP2bis», RFC 1732, University of Washington, Декабрь 1994.</td></tr><tr><td>[IMAP-MODEL]</td><td>Crispin, M., «Distributed Electronic Mail Models in IMAP4», RFC 1733, University of Washington, Декабрь 1994.</td></tr><tr><td>[IMAP-OBSOLETE]</td><td>Crispin, M., «Internet Message Access Protocol — Obsolete Syntax», RFC 2062, University of Washington, Ноябрь 1996.</td></tr><tr><td>[IMAP2]</td><td>Crispin, M., «Interactive Mail Access Protocol — Version 2», RFC 1176, University of Washington, Август 1990.</td></tr><tr><td>[LANGUAGE-TAGS]</td><td>Alvestrand, H., «Tags for the Identification of Languages», RFC 1766, Март 1995.</td></tr><tr><td>[MD5]</td><td>Myers, J., and M. Rose, «The Content-MD5 Header Field», RFC 1864, October 1995.</td></tr><tr><td>[MIME-IMB]</td><td>Freed, N., and N. Borenstein, «MIME (Multipurpose Internet Mail Extensions) Part One: Format of Internet Message Bodies», RFC 2045, Ноябрь 1996.</td></tr><tr><td>[MIME-IMT]</td><td>Freed, N., and N. Borenstein, «MIME (Multipurpose Internet Mail Extensions) Part Two: Media Types», RFC 2046, Ноябрь 1996.</td></tr><tr><td>[MIME-HDRS]</td><td>Moore, K., «MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text», RFC 2047, Ноябрь 1996.</td></tr><tr><td>[RFC-822]</td><td>Crocker, D., «Standard for the Format of ARPA Internet Text Messages», STD 11, RFC 822, University of Delaware, Август 1982.</td></tr><tr><td>[SMTP]</td><td>Postel, J., «Simple Mail Transfer Protocol», STD 10, RFC 821, USC/Information Sciences Institute, Август 1982.</td></tr><tr><td>[UTF-7]</td><td>Goldsmith, D., and Davis, M., «UTF-7: A Mail-Safe Transformation Format of Unicode», RFC 1642, Июль 1994.</td></tr></table><h3 id="p.appendix.b">B. Изменения по отношению к RFC 1730</h3><ol><li>Добавлена команда STATUS.</li><li>Уточнен формальный синтаксис — "#" не может указывать на множественные символы пробела.</li><li>Устаревший синтаксис вынесен в отдельный документ.</li><li>Отменена команда PARTIAL.</li><li>Отменены атрибуты выборки RFC822.HEADER.LINES, RFC822.HEADER.LINES.NOT, RFC822.PEEK, RFC822.TEXT.PEEK.</li><li>Добавлены атрибуты "&lt;" "." size "&gt;" для текста BODY.</li><li>Добавлены идентификаторы частей HEADER, HEADER.FIELDS, HEADER.FIELDS.NOT, MIME, TEXT.</li><li>Добавлена поддержка Content-Disposition и Content-Language.</li><li>Снято ограничение для выборки во вложенных частях MULTIPART.</li><li>Отменено использование части тела с номером 0.</li><li>Поддерживаемые сервером способы аутентификации идентифицируются как возможности сервера.</li><li>Возможности протокола обозначаются как IMAP4rev1. Серверам, обеспечивающим совместимость с RFC 1730, следует возвращать также возможность IMAP4 (в дополнение к IMAP4rev1) в откликах CAPABILITY. Поскольку RFC-1730 требует указания IMAP4 как первой возможности, этот идентификатор ДОЛЖЕН указываться первым.</li><li>Добавлено описание соглашений для пространства имен почтовых ящиков.</li><li>Добавлено описание соглашения по использованию других языков в именах почтовых ящиков.</li><li>Элементы состояния UID-NEXT и UID-VALIDITY получили названия UIDNEXT и UIDVALIDITY (это изменение связано с незавершенной работой IMAP STATUS, а не с RFC-1730).</li><li>Добавление — пустое имя почтового ящика в аргументе команды LIST возвращает непомеченный отклик LIST с разделителем уровней иерархии и ссылкой на корень.</li><li>Определены термины MUST, SHOULD, MUST NOT.</li><li>Добавлен параграф, определяющий атрибуты сообщений и более тонкие детали семантики порядковых номеров, UID и флагов.</li><li>Разъяснены обстоятельства, когда клиент может передавать множество команд, не дожидаясь отклика, и возможные неоднозначности в таких случаях.</li><li>Добавлены рекомендации в части поведения сервера по отношению к командам DELETE и RENAME при существовании подчиненных уровней иерархии.</li><li>Уточнение — имя почтового ящика не может быть произвольно исключено из подписки сервером даже если это имя больше не существует.</li><li>Уточнение — отклик на команду LIST ДОЛЖЕН даваться максимально быстро.</li><li>Уточнение — аргумент date_time функции APPEND устанавливает для сообщения внутреннюю дату.</li><li>Уточнено описание поведения APPEND для операций с выбранным в данный момент почтовым ящиком.</li><li>Уточнение — внешние изменения флагов ДОЛЖНЫ всегда анонсироваться с помощью непомеченных откликов FETCH даже при использовании для аргументов команды STORE суффикса ".SILENT".</li><li>Уточнение — команда COPY копирует сообщения в указанный почтовый ящик.</li><li>Добавлен код отклика NEWNAME.</li><li>Переписано описание непомеченного отклика BYE с цель уточнения семантики.</li><li>Уточнены ссылки на RFC для тел MD5.</li><li>Уточнение — правила формального синтаксиса могут перекрываться и преимущество имеет первое правило из числа перекрывающихся.</li><li>Исправлено определение параметра body_fld_param.</li><li>Расширен формальный синтаксис для for capability_data.</li><li>Уточнение — любое написание "INBOX" должно трактоваться как INBOX (все буквы заглавные).</li><li>Уточнение — текст для пользователя в откликах resp_text не следует начинать с "[" или "=".</li><li>Изменены ссылки на черновые стандарты для MIME.</li><li>Уточнена семантика флагов \Recent.</li><li>Добавлены примеры.</li></ol></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 2060 - Протокол IMAP v.4, rev. 1",disqus_identifier="2060.rfc",disqus_url="http://rfc2.ru/2060.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>