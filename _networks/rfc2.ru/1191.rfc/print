<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../1191.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 1191 — Исследование MTU на пути следования сообщения</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../1191.rfc">RFC 1191 — Исследование MTU на пути следования сообщения</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 1191</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank"><span itemprop="alternativeHeadline">Path MTU Discovery</span></a></dd><dd><div class="icon i7"></div> Предыдущие версии: RFC 1063</dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Проект стандарта</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1990-11-01">Ноябрь 1990</time></dd><dd><div class="icon i5"></div> Авторы: <span itemprop="author">Jeffrey Mogul</span>, <span itemprop="author">Steve Deering</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Игорь Шеваров</span></dd></dl><div id="text" itemprop="articleBody"><h3>Статус этого документа</h3><p>Этот документ определяет стандарт IAB Standards Track для сообщества Internet, и требует обсуждения и внесения усовершенствований. Для выяснения состояния стандартизации и статуса данного протокола необходимо обратиться к "IAB Official Protocol Standards". Распространение данного документа не ограничено.</p><h3>Резюме</h3><p>Данный документ описывает методику определения Maximum Transmission Unit (MTU) на произвольном маршруте в Internet. Он определяет небольшие изменения для маршрутизаторов, генерирующих один тип ICMP сообщений. Для маршрута, пролегающего через маршрутизатор, который не был изменен, может методика может выдавать неверное значение MTU.</p><h3>Благодарности</h3><p>Это документ является продуктом IETF MTU Discovery Working Group. Предложенный здесь механизм был первоначально предложен Джефом Купером (Geoff Cooper) [2], который в двух коротких абзацах изложил все основные идеи, потребовавшие от рабочей группы месяцев работы.</p><h2>Содержание</h2><ul class="map"><li><a href="print#p1">1. Введение</a></li><li><a href="print#p2">2. Краткий обзор протокола</a></li><li><a href="print#p3">3. Требования к хосту</a></li><li class="lia"><a href="print#p3.1">3.1. Опция TCP MSS</a></li><li><a href="print#p4">4. Спецификация маршрутизатора</a></li><li><a href="print#p5">5. Обработка сообщений в старом стиле на хосте</a></li><li><a href="print#p6">6. Реализация хоста</a></li><li class="lia"><a href="print#p6.1">6.1. Иерархическое представление</a></li><li class="lia"><a href="print#p6.2">6.2. Сохранение информации PMTU</a></li><li class="lia"><a href="print#p6.3">6.3. Удаление устаревшей информации PMTU</a></li><li class="lia"><a href="print#p6.4">6.4. Действия уровня ТСP</a></li><li class="lia"><a href="print#p6.5">6.5. Проблемы для других транспортных протоколов</a></li><li class="lia"><a href="print#p6.6">6.6. Интерфейс управления</a></li><li><a href="print#p7">7. Вероятные значения для PMTU</a></li><li class="lia"><a href="print#p7.1">7.1. Наилучший способ определить увеличение PMTU</a></li><li><a href="print#p8">8. Соображения безопасности</a></li><li><a href="print#p.references">Ссылки</a></li></ul><h2 id="p1">1. Введение</h2><p>Когда один IP хост имеет большой объем данных, которые требуется отправить другому хосту, то данные передаются как серии IP датаграмм. Желательно, чтобы датаграммы были максимального размера, не требующего фрагментации и на одном из участков маршрута от отправителя к получателю. Данный размер датаграммы далее упоминается как Path MTU (PMTU), и равен наименьшему из MTU, используемых на каждом хопе маршрута. Недостатком IP является отсутствие стандартного механизма для определения PMTU на произвольном маршруте.</p><p>Замечание: Path MTU, это тоже, что в <a href="../1122.rfc" title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни">RFC 1122</a> именуется как «Эффективный MTU для отправки» ("Effective MTU for sending" (EMTU_S).) PMTU ассоциируется с маршрутом, который является специфической комбинацией IP адресов отправителя и получателя и возможно типом обслуживания Type-of-service (TOS).</p><p>В существующей практике (<a href="../1122.rfc" title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни">RFC 1122</a>) используется меньшее из 576 и MTU для первого хопа в качестве PMTU для любого адресата, который не подключен к той же сети или подсети, что и источник. Во многих случаях результатом является использование размеров датаграмм, меньших, чем необходимо, потому что в большинстве случаев маршруты имеют PMTU большее, чем 576. Хост, посылающий датаграммы намного меньшие, чем PMTU напрасно тратит ресурсы Internet и возможно достигает производительности, близкой к оптимальной. Кроме того, существующая практика не предотвращает полностью фрагментацию датаграмм, так как существуют тракты передачи с PMTU меньшим, чем 576.</p><p>Ожидается, что будущие протоколы маршрутизации будут способны предоставлять точную информацию о PMTU в пределах своей области маршрутизации, возможно за исключением многоуровневых маршрутизирующих иерархиях. Не понятно, насколько скоро они станут доступны, так что в течение следующих нескольких лет Internet нуждается в простом механизме определения PMTU без перерасхода ресурсов и до того, как все хосты и маршрутизаторы будут модернизированы.</p><h2 id="p2">2. Краткий обзор протокола</h2><p>В этом документе мы описываем технику, использующую бит Don't Fragment (DF) в заголовке IP датаграммы для динамического определения PMTU маршрута. Основная идея состоит в том, что хост использует в качестве PMTU значение MTU первого хопа для данного маршрута. Все датаграммы отправляются с установленным флагом DF. Если какая-то датаграмма слишком велика для того, чтобы быть отправленной одним из маршрутизаторов дальше без фрагментации, то данный маршрутизатор отбрасывает эту датаграмму и посылает ICMP сообщение Destination Unreachable с кодом «fragmentation needed and DF set» (<a href="../792.rfc" title="RFC 792 - Протокол ICMP">RFC 792</a>). Поле того, как хост получил такое сообщение (в дальнейшем называемое «датаграмма слишком большая»), хост уменьшает значение PMTU для этого маршрута.</p><p>Процесс определения PMTU заканчивается после того, как хост оценит PMTU достаточно маленьким, для того чтобы отправлять датаграммы без фрагментации.</p><p>Хост может закончить процесс определения PMTU, прекратив устанавливать флаг DF в заголовке датаграммы. Это может произойти, например, если хост считает допустимым отправлять фрагментированные датаграммы в данных обстоятельствах. В нормальных условиях хост должен отправлять все датаграммы с установленным флагом DF, так что если маршрут изменится и новый PMTU станет меньше, то это будет обнаружено.</p><p>К сожалению, сообщение «датаграмма слишком большая», в том виде, в каком она определена в настоящее время не сообщает MTU для того хопа, перед которым была отброшена датаграмма, являющаяся слишком большой. Таким образом хост отправитель датаграммы точно не может определить, на сколько следует уменьшит значения PMTU. Чтобы исправить это, мы предлагаем использовать неиспользуемое поле в заголовке сообщения «датаграмма слишком большая» для переноса значения MTU для следующего хопа. Это единственное требование к маршрутизаторам в поддержку определения PMTU.</p><p>PMTU может изменяться с течением времени, из-за изменений в топологии маршрутизации. Уменьшения PMTU детектируются с помощью сообщения «датаграмма слишком большая», за исключением тех случаев, когда хост прекратил устанавливать бит DF. Чтобы детектировать увеличение PMTU, хост периодически увеличивает значение MTU. В большинстве случаев результатом является отбрасывание датаграммы и отправка сообщения «датаграмма слишком большая», потому что в большинстве случаев значение PMTU не меняется.</p><p>Так как этот механизм по существу гарантирует, что хост не будет получать никаких фрагментов датаграмм от хоста осуществляющего определения PMTU, это может помогать во взаимодействии хостов, которые не могут производить сборку фрагментированных датаграмм.</p><h2 id="p3">3. Требования к хосту</h2><p>Когда хост получает сообщение «датаграмма слишком большая», он ДОЛЖЕН уменьшить значение PMTU в соответствии с полем Next-Hop MTU (см. п.4). Мы не определяем точное поведение хоста в этих обстоятельствах, так как различные приложения могут иметь различные требования и различные архитектурные реализации могут иметь различные полезные стратегии.</p><p>Мы требуем, чтобы после получения сообщения «датаграмма слишком большая» хост ДОЛЖЕН пытаться избегать появления большого количество таких сообщений в ближайшем будущем. Хост может или прекратить уменьшать размеры датаграмм или прекратить устанавливать флаг DF в заголовке датаграмм. Понятно, что формирователь стратегии может продолжать выявлять сообщения «датаграмма слишком большая», но каждое из этих сообщений (так же как и отброшенные датаграммы) потребляют ресурсы Internet, поэтому хост ДОЛЖЕН заставить процесс определения PMTU сходиться.</p><p>Хост, использующий определение MTU, ДОЛЖЕН реагировать на уменьшение MTU настолько быстро, насколько это возможно. Хост МОЖЕТ определять увеличение PMTU, но так как это требует посылки датаграмм большего размера, чем действующий PMTU, и потому что PMTU вероятнее всего не будет увеличиваться, то хост ДОЛЖЕН делать это не очень часто. Попытка детектировать увеличение PMTU (посылкой датаграммы большего размера, чем действующее значение PMTU) НЕ ДОЛЖНА быть раньше, чем через 5 минут после получения сообщения «датаграмма слишком большая» для данного адресата, или не раньше чем через 1 минуту после того, как было предпринято последнее успешное увеличение PMTU. Мы рекомендуем установить значения этих таймеров в два раза больше, чем эти минимальные значения (10 минут и 2 минуты соответственно).</p><p>Хост должен быть способен работать с сообщениями «датаграмма слишком большая» не содержащими информации об MTU на следующем хопе, в связи тем, что невозможно выполнить модернизацию всех маршрутизаторов Internet за конечное время. Сообщения «датаграмма слишком большая» от не модернизированного маршрутизатора должно определяться по наличию нуля в (новом) поле Next-Hop MTU. (Этого требует <a href="../792.rfc" title="RFC 792 - Протокол ICMP">спецификация протокола ICMP</a> [7] неиспользуемые поля должны быть заполнены нулями). В разделе 5 мы обсуждаем возможные стратегии для хоста, отрабатывающему сообщение «датаграмма слишком большая» в старом стиле (полученном от не модернизированного маршрутизатора).</p><p>Хост НИКОГДА НЕ ДОЛЖЕН принимать значение PMTU меньше чем 68 октетов.</p><p>Хост НЕ ДОЛЖЕН увеличивать значение PMTU в ответ на содержимое сообщения «датаграмма слишком большая». Сообщение, предполагающее увеличение PMTU является либо старой датаграммой, плавающей по Internet, либо фальшивый пакет, являющийся частью атаки на отказ в обслуживании, либо результатом множественности маршрутов до адресата.</p><h3 id="p3.1">3.1. Опция TCP MSS</h3><p>Хост, производящий определение PMTU должен придерживаться правила, что он не должен посылать датаграммы более 576 октетов, если он не имеет разрешения получателя на это. Для ТСР соединения это означает, что хост не должен посылать датаграммы больше чем 40 октетов плюс максимальный размер сегмента (Maximum Segment Size-MSS) посланный его партнером.</p><p>Замечание: ТСР MSS определен как допустимый размер датаграммы минус 40 (RFC 879). Значение по умолчанию 576 октетов как максимальный размер датаграммы определяет размер по умолчанию для ТСР MSS в 536 октетов.</p><p>Раздел 4.2.2.6 «Требования для хоста Internet-коммуникационный уровень» <a href="../1122.rfc" title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни">RFC 1122</a> говорит:</p><p>Некоторые реализации TCP посылают опцию MSS, только если хост получатель подключен к другой подсети. Конечно, в целом уровень ТСР может не иметь соответствующей информации для принятия этого решения, так что предпочтительно оставить уровню IP задачу определения подходящего MTU для маршрута.</p><p>Фактически, многие реализации ТСР всегда посылают опцию MSS, однако устанавливают это значение в 536, если адресат не является локальным. Это поведение было правильным, когда Интернет был полон хостов, не придерживавшихся данного правила, что датаграммы больше 576 октетов не должны отправляться на нелокальные компьютеры. Теперь, когда большинство хостов следуют этому правилу, ограничение опции ТСР MSS не является необходимым.</p><p>Кроме того, выполнение этого правила делает неспособным механизм PMTU Discovery определять PMTU более 576, так что хосты больше ДОЛЖНЫ умешать значение, посылаемое в опции MSS. Значение MSS должно быть на 40 байт меньше, чем размер самой большой датаграммы, которую хост способен пере собрать (MSS_R, как определено в <a href="../1122.rfc" title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни">RFC 1122</a>). Во многих случаях будет иметь место архитектурное ограничение в 65495 (65535-40). Хост может посылать значение MSS полученное из MTU присоединенной сети; это не должно вызывать проблемы с PMTU Discovery.</p><p>Замечание: В настоящее время мы не видим никаких причин посылать MSS больше, чем максимальный MTU присоединенной сети, и мы не рекомендуем использовать 65495. Весьма возможно, что некоторые реализации IP имеют ошибки со знаковым битом, что делает опасным использование такого большого MSS.</p><h2 id="p4">4. Спецификация маршрутизатора</h2><p>Когда маршрутизатор не может переслать датаграмму, потому что она превышает размеры MTU на следующем хопе и у нее в заголовке установлен бит Don't Fragment, он должен будет выслать источнику датаграммы ICMP сообщение «Адресат недостижим» с кодом, обозначающим «требуется фрагментация и установлен флаг DF». Для поддержки техники Path MTU Discovery, описываемой в данном документе, маршрутизатор ДОЛЖЕН вставить значение MTU сети на следующем хопе в младшие 16 бит поля ICMP заголовка, которое помечено как неиспользуемое.</p><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 3    |   Code = 4    |           Checksum            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           unused = 0          |         Next-Hop MTU          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Internet Header + 64 bits of Original Datagram Data      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><p>Значение, которое несет поле Next-Hop MTU это:</p><p>Размер в октетах самой большой датаграммы, которая может быть отправлена по пути оригинальной датаграммы, без фрагментации на этом маршрутизаторе. Размер включает IP заголовок и IP данные и не включает низкоуровневые заголовки.</p><p>Это поле никогда не будет содержать значение меньше чем 68, потому что каждый маршрутизатор «должен быть способен отправлять датаграммы длинной по 68 октетов без фрагментации» (<a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC 791</a>).</p><h2 id="p5">5. Обработка сообщений в старом стиле на хосте</h2><p>В этом разделе мы выделим несколько возможных стратегий для хоста, получающего сообщение «датаграмма слишком большая» от не модифицированного маршрутизатора (т.е. с нулевым полем Next-Hop MTU). Этот раздел не является частью описание протокола.</p><p>Самая простая вещь, которую может сделать хост в ответ на такое сообщение  это прекратить установку бита DF и принять, что это PMTU равно текущему PMTU или 576, в зависимости от того, что меньше. Таким образом, хост возвращается к тому же самому PMTU, как это делается в текущей практике (см. раздел 3.3.3. <a href="../1122.rfc" title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни">RFC 1122</a> «Рекомендации для хостов Internet — коммуникационные уровни»). Эта стратегия имеет преимущество, так как она отрабатывает быстро, что делает ее не хуже, чем там та, что используется в существующей практике. Она не работает, однако, для предотвращения фрагментации в некоторых случаях, и дает наиболее эффективное использование утилизации в других случаях.</p><p>Более сложные стратегии «ищут» точную оценку PMTU, посылая пакеты разного размера с установленным битом DF. Хорошей поисковой стратегией можно назвать ту стратегию, которая получает точную оценку PMTU при малом количестве потерянных пакетов в процессе поиска.</p><p>Некоторые стратегии применяют алгоритмические функции к предыдущей оценке PMTU для того чтобы получить следующую оценку PMTU. Например, старая оценка PMTU может быть умножена на константу (скажем, 0.75). Мы НЕ рекомендуем их; они сходятся слишком долго и могут недооценить правильное значение PMTU.</p><p>Более сложный подход делать бинарный поиск по размеру пакета. Он сходится несколько быстрее, хотя все еще требуется 4-5 шагов для того чтобы перейти от FDDI MTU к Ethernet MTU. Серьезный недостаток состоит в том, что требуется сложная реализация алгоритма индикации занижения текущей оценки PMTU. Мы так же не рекомендуем пользоваться этой стратегией.</p><p>Появилась одна стратегия, которая работает, кажется, весьма хорошо. Она стартует с обзора значений, которые практически в относительно небольшом количестве используются в Internet. Таким образом, вместо того, чтобы слепую проводить поиск среди произвольно выбранных значений, мы можем искать только среди тех, которые действительно могут использоваться. Более того, так как у разработчиков прослеживается тенденция выбирать MTU подобными путями, возможно накопление групп похожих значений MTU и использовать наименьшее значение в группе как наше поисковое «плато». (Понятно, что лучше недооценить значение MTU на несколько процентов, чем переоценить его на один октет).</p><p>В разделе 7, мы описываем, как мы пришли к таблице репрезентативных плато MTU (representative MTU plateaus) для использования при оценке MTU. Сходимость с этой таблицей такая же хорошая, как бинарный поиск в самом худшем случае и намного лучше в обычном случае (например, требуется только два шага для перехода от FDDI MTU к Ethernet MTU).</p><p>Любая поисковая стратегия должна иметь некоторую «память» о предыдущих оценках, чтобы делать следующие. Один подход должен использовать оценки PMTU, кэшированные в настоящее время, но фактически лучше информация, полученная из сообщения «датаграмма слишком большая». Все ICMP сообщения «адресат недоступен» содержат, включая упомянутое, IР заголовок оригинальной датаграммы, которая была слишком велика для передачи без фрагментации. Так как поле Total Length может быть меньше, чем текущее PMTU, но, тем не менее, больше, чем фактическое PMTU, то это может послужить входными данными методу, производящему следующую оценку PMTU.</p><p>Замечание: маршрутизаторы, основанные на 4.2BSD Unix, посылают неправильное значения поля Total Length оригинальной датаграммы. Значение, посылаемое этими маршрутизаторами, является суммой оригинального поля Total Length и Header Length (выраженное в октетах). Так как хост может получить такое сообщение «датаграмма слишком большая», зная, что датаграмма была получена от одного из таких маршрутизаторов, хост должен быть консервативен. Если возвращенное поле Total Length не меньше, чем текущая оценка PMTU, то оно должно быть уменьшено до четверти значения поля Header Length.</p><p>Стратегию, которую мы рекомендуем, состоит в том, чтобы использовать следующую оценку PMTU как наибольшее основное значение, которое меньше, чем то, что возвращается в поле Total Length (исправленное, если необходимо, в соответствии с замечанием выше).</p><h2 id="p6">6. Реализация хоста</h2><p>Этот раздел осуждает реализацию PMTU Discovery в программном обеспечении хоста. Это — не спецификация, а скорее набор предложений.</p><p>Раздел рассматривает следующие вопросы:</p><ul class="dot"><li>Какой уровень или уровни включают в себя реализацию PMTU Discovery;</li><li>Где информация PMTU будет кэширована?</li><li>Как устаревшая PMTU информация будет удаляться?</li><li>Что должны делать транспортный уровень и верхние уровни?</li></ul><h3 id="p6.1">6.1. Иерархическое представление</h3><p>В архитектуре протокола IP решение о том, какой должен быть размер отправляемого пакета производится протоколами, находящимися на уровне выше уровня IP. Мы будем называть такие протоколы протоколами пакетирования. Протоколы пакетирования обычно являются транспортными протоколами (например ТСР), но они могут быть протоколами более высокого уровня (например, протоколы построенные поверх UDP).</p><p>Реализация PMTU Discovery на уровне протоколов пакетирования упрощает решение некоторых межуровневых проблем, но имеет несколько недостатков: реализация возможно должна будет переделана для каждого реализации протокола, это усложнит совместное использование информации PMTU между разными уровнями пакетирования и состояние, ориентированное на соединение, поддерживаемое некоторыми уровнями пакетирования, могут с трудом расширяться для сохранения информации PMTU на длительные периоды.</p><p>По этой причине мы полагаем, что уровень IP должен хранить информацию PMTU и что уровень ICMP должен обрабатывать сообщения «датаграмма слишком большая». Уровни пакетирования должны оставаться способными реагировать на изменения PMTU, изменением размера датаграмм, которые они посылают и должны быть способны определить те датаграммы, которые посланы с установленным флагом DF. Мы не хотим, чтобы уровень IP просто установил DF бит в каждом пакете, так как возможно, что уровень пакетирования, возможно приложение UDP вне ядра, неспособно изменить этот размер датаграммы. Протоколы, вовлеченные во внутреннюю фрагментацию, пускай не элегантные, бывают иногда успешными (NFS будет первым примером) и мы не хотим нарушать их работу.</p><p>Для поддержки иерархического представления, протоколы пакетирования требуют расширения сервиса IP описанного в <a href="../1122.rfc" title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни">RFC 1122</a>:</p><p>Способ изучения изменений в значении MMS_S ("maximum send transport-message size") это вычитание из PMTU минимального размера IP заголовка.</p><h3 id="p6.2">6.2. Сохранение информации PMTU</h3><p>В общем, уровень IP должен ассоциировать каждое значение PMTU, которое было им получено, с определенным путем. Путь идентифицируется с адресом отправителя, адресом получателя и типом сервиса IP. (Некоторые реализации не записывают адрес источника, это применимо для хостов с одним интерфейсом, которые имеют только один возможный адрес отправителя).</p><p>Замечание: Некоторые пути могут быть далее отличены по различным классификациям защиты. Детали таких классификаций не рассматриваются в данном документе.</p><p>Очевидное место для хранения этой ассоциации — поле в таблице маршрутизации. Хост не будет иметь маршрута для любого возможного адресата, но он будет иметь возможность кэшировать маршрут на хост для каждого активного адресата. (Это требование уже налагает необходимость обрабатывать ICMP сообщения по перенаправлении).</p><p>Когда первый пакет послан на хост и отсутствует маршрут на хост (per-host route), то маршрут выбирается и маршрутов на сеть (per-network routes) или из набора маршрутов по умолчанию. Поля PMTU в этих маршрутах должны быть инициализированы значением MTU для первого хопа и не должны изменяться в процессе определения PMTU. (При определении PMTU создаются или изменяются маршруты на хост). До того, как получено сообщение «датаграмма слишком большая» значение, соответствующее изначально выбранному маршруту, является точным.</p><p>После того как получено сообщение «датаграмма слишком большая», уровень ICMP определяет новую оценку PMTU (или из ненулевого значения MTU следующего хопа или с помощью методов, описанных разделе 5). Если маршрут на хост для этого пути не существует, то он создается (почти как при обработке ICMP Redirect; новый маршрут использует тот же маршрутизатор, как и текущий маршрут). Если оценка PMTU ассоциированная с маршрутом на хост выше, чем новая оценка, то ее значение изменяется.</p><p>Уровни пакетирования должны быть извещены об уменьшении PMTU. Любой уровень пакетирования (например, ТСР соединение) который активно использует путь, должен быть уведомлен об уменьшении оценки PMTU.</p><p>Замечание: когда сообщение «датаграмма слишком большая» содержит заголовок исходной датаграммы, который ссылается на UDP пакет, уровень ТСР должен быть уведомлен, если любое из этих соединений использует этот путь.</p><p>Также, протокол, который послал датаграмму, вызвавшую появление сообщения «датаграмма слишком большая», должен быть уведомлен, что эта датаграмма была отброшена, даже если оценка PMTU не изменилась, так чтобы он мог вызвать повторную отправку отброшенной датаграммы.</p><p>Замечание: механизм уведомления должен быть аналогичен механизму, используемому для предоставления уведомлений ICMP Source Quench. В некоторых реализациях (таких как системы, построенные на основе BSD 4.2) существующий механизм уведомлений не способен идентифицировать вовлеченное ТСР соединение, что требует наличия дополнительного механизма.</p><p>В качестве альтернативы, реализация может избегать использования асинхронного механизма уведомления об уменьшении PMTU, откладывая уведомление до следующей попытки послать датаграмму большее, чем оценка PMTU. При таком подходе, когда сделана попытка ПОСЛАТЬ датаграмму с установленным битом DF, и датаграмма больше чем оценка PMTU, функция SEND должна закончиться сбоем и вернуть соответствующий признак ошибки. Этот подход может быть более подходящим для уровня пакетирования без установления соединения (какие как UDP), который (в некоторых реализациях) трудно «уведомлять» от уровня ICMP. В этом случае, обычные механизмы, основанные на таймаутах, использовались бы, чтобы восстановить отброшенные датаграммы.</p><p>Важно понять, что уведомление уровней пакетирования, использующих путь для изменения PMTU, отличается от уведомления специфичных уровней, о том, что пакет был отброшен. Последнее должно быть сделано только практически (т.е. асинхронно с точки зрения уровня пакетирования), в то время как первое может быть отсрочено до того момента, когда уровень пакетирования будет создавать пакет. Повторная передача должна быть сделана только для тех пакетов, о которых известно, что они отброшены, на что указывает сообщение «датаграмма слишком большая».</p><h3 id="p6.3">6.3. Удаление устаревшей информации PMTU</h3><p>Сетевая топология является динамической, маршруты меняются через некоторое время. PMTU, обнаруженный для данного адресата может быть неправилен, если начинает использоваться новый маршрут. Таким образом, PMTU информация, кэшируемая хостом, устаревает.</p><p>Сетевая топология является динамической, маршруты меняются через некоторое время. PMTU, обнаруженный для данного адресата может быть неправилен, если начинает использоваться новый маршрут. Таким образом, PMTU информация, кэшируемая хостом, устаревает.</p><p>Замечание: реализация должна предоставлять средства для изменения длительности таймаута, включая установку на «бесконечность». Например, хост, подключенный к сети FDDI, которая в свою очередь подключена к Internet через медленную последовательную линию, никогда не начнет процесс определения нового нелокального MTU, так что ему не придется сталкиваться с отброшенными датаграммами каждые 10 минут.</p><p>Верхний уровень не должен передавать датаграммы в ответ на увеличение оценки PMTU, так как это повышение никогда не вызовет отбрасывание датаграмм.</p><p>Один из подходов к реализации старения PMTU это добавление поля временной метки в таблицу маршрутизации. Это поле инициализируется «зарезервированным» значением, показывающим, что это значение PMTU никогда не изменялось. Всякий раз, когда значение PMTU было уменьшено в ответ на сообщения «датаграмма слишком большая» временная метка устанавливается на текущее время.</p><p>Спустя минуту, управляемая таймером процедура пробежит по таблице маршрутизации и для каждого маршрута значение временной метки, которого не является «резервным» и больше чем значение таймаута:</p><ul class="dot"><li>Установит значение PMTU разное значению PMTU на первом хопе.</li><li>Известит уровень пакетирования, использующий данный маршрут об увеличении.</li></ul><p>Оценка PMTU может исчезнуть из таблицы маршрутизации, если маршрут на хост был удален из таблицы; это может случиться в ответ на сообщение ICMP Redirect или потому, что некоторые демоны маршрутной таблицы удаляют старые маршруты после нескольких минут. Также, на хостах имеющих несколько интерфейсов изменения топологии может быть результатом использования разных интерфейсов. Когда это случается, если уровень пакетирования не оповещен, тогда может продолжиться использование кэшированных значений PMTU, которые теперь слишком малы. Одно решение состоит в том, чтобы уведомлять уровень пакетирования о возможном изменении значения PMTU, всякий раз, когда сообщение о перенаправлении вызывает изменение маршрута и всякий раз, когда маршрут просто удален из таблицы маршрутизации.</p><p>Замечание: более сложные методы для определения увеличения значения PMTU описаны в разделе 7.1.</p><h3 id="p6.4">6.4. Действия уровня ТСP</h3><p>Уровень ТСР должен отслеживать значение PMTU для адресата, он не должен посылать датаграммы размером больше PMTU. Простая реализация может узнавать это значение у уровня IP (используя интерфейс GET_MAXSIZES описанный в <a href="../1122.rfc" title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни">RFC 1122</a>) каждый раз, когда создает сегмент, но это было бы не эффективно. Кроме того, реализации ТСР, которые используют алгоритм медленного старта [4] обычно вычисляют и кэшируют несколько значений, полученных из PMTU.Может быть проще получить асинхронное уведомление, полученное при изменении PMTU, так, чтобы эти переменные могли быть модифицированы.</p><p>Реализации ТСР должны так же сохранять значение MSS (которое по умолчанию равно 536), и не посылать сегменты больше этого MSS, не зависимо от PMTU.</p><p>В реализациях, основанных на BSD 4.x это требует добавления дополнительного поля в запись состояния ТСР.</p><p>Наконец, когда получено сообщение «датаграмма слишком большая», подразумевается, что датаграмма была отброшена маршрутизатором, который послал это сообщение. Достаточно обработать это как любой другой отброшенный сегмент и ждать, пока таймер повторной передачи не истечет, чтобы вызвать повторную передачу сегмента. Если процесс определения PMTU требует несколько шагов для правильной оценки PMTU, это может задержать соединение во много раз.</p><p>С другой стороны, повторная передача могла быть сделана в непосредственном ответе на уведомление о том, что значение PMTU было изменено, но только для определенного подключения, указанного в сообщении «датаграмма слишком большая». Размер датаграммы используемый при повторной передаче должен быть, конечно, не больше чем новый PMTU.</p><p>Замечание: НЕЛЬЗЯ повторно передать в ответ на каждое сообщения «датаграмма слишком большая», так как выброс сегментов с завышенными размерами приведет к нескольким повторным передачам тех же самых данных. Если новая оценка PMTU все еще не верна, процесс повторится, что приведет к экспоненциальному росту числа отправленных лишних сегментов.</p><p>Это означает, что уровень ТСР должен быть способен распознать, когда сообщение «датаграмма слишком большая» действительно уменьшает PMTU, который уже был использован для отправки датаграмм на данном соединении и что нужно игнорировать другие уведомления.</p><p>Современные реализации ТСР используют алгоритмы «медленного старта» и «предотвращения скоплений» («congestion avoidance») для увеличения эффективности работы. [4]. В отличие от повторной передачи, вызванной истечением таймером повторной передачи, повторная передача, вызванная сообщением «датаграмма слишком большая» не должна менять окно накопления (congestion window). Это должно, однако, вызывать срабатывание механизма медленного старта (т.е. только один сегмент должен быть повторно передан, пока не подтверждения не начнут поступать снова).</p><p>Эффективность работы ТСР может быть уменьшена, если максимальное окно отправителя не кратно используемому размеру сегмента (это не размер окна накопления, который всегда является кратным размеру сегмента). Во многих системах, (например, основанных на BSD 4.2) размер сегмента обычно кратен 1024 октетам, так что надлежащие отношения ставятся по умолчанию. Если используется определение PMTU, то конечно размер сегмента может не быть кратен посылаемому пространству (may not be a submultiple of the send space) и он может изменяться в период существования соединения; это означает, что уровень ТСР может быть нуждается в изменении размера передающего окна, когда PMTU меняет свое значение. Максимальный размер окна должен быть установлен равным наибольшему кратному размеру сегмента (PMTU - 40), что должно быть меньше или равно размеру буфера пространства отправителя (sender's buffer space size).</p><p>Процесс определения PMTU не должен воздействовать на значение, отправляемое у опции MSS, потому что это значение используется на другом конце соединения, которое может использовать несвязанное значение PMTU.</p><h3 id="p6.5">6.5. Проблемы для других транспортных протоколов</h3><p>Некоторые транспортные протоколы (такие как ISO TP4 RFC 905) не позволяют перепакетирование (repacketize) во время повторной отправки. То есть, должна быть сделана попытка передачи датаграммы определенного размера, и ее содержимое не может быть разбито на маленькие датаграммы для повторное передачи. В таком случае, оригинальная датаграмма должна быть повторно передана без установленного бита DF, позволяющего фрагментировать датаграмму при необходимости для того, чтобы достичь адресата. Последующие датаграммы, когда они передаются в первый раз, должны быть не больше, чем PMTU и должны иметь установленный бит DF.</p><p>Sun Network File System (NFS) использует протокол вызова удаленных процедур (RPC: Remote Procedure Call Protocol) [11], во многих случаях посылающий датаграммы, которые должны быть фрагментированы даже на первом хопе. Это может улучшить эффективность работы в некоторых случаях, но, как известно, вызывает проблемы с надежностью и производительностью, особенно когда клиент и сервер разделены маршрутизаторами.</p><p>Мы рекомендуем использовать механизм определения PMTU в реализациях NFS всякий раз, когда в процесс обмена вовлечены маршрутизаторы. Большинство реализаций NSF позволяют изменять размер RPC датаграммы во время монтирования (mount-time) (косвенно изменяя эффективный размер блока файловой системы) но могут требовать некоторых модификаций для поддержки изменений в дальнейшем.</p><p>Также, поскольку одиночные операции NFS не могут быть разбиты на несколько UDP датаграмм, некоторые операции (прежде всего те, которые оперируют с именами файлов и директорий) требуют минимального размера датаграммы, который может быть больше, чем PMTU. Реализации NFS не должны уменьшать размер датаграмм ниже этого порога, даже если механизм определения PMTU предлагает меньшее значение. (Конечно, в этом случае датаграммы не должны быть посланы с установленным флагом DF).</p><h3 id="p6.6">6.6. Интерфейс управления</h3><p>Мы предлагаем, чтобы реализация предоставляла для системных утилит путь:</p><ul class="dot"><li>определять на каком маршруте будет выполняться определение PMTU;</li><li>изменять значение PMTU, ассоциированное с данным маршрутом.</li></ul><p>Формирователь может быть выполнен путем связывания флага с маршрутом, когда пакет передается через этот маршрут с установленным флагом, уровень IP оставляет бит DF скинутым не зависимо от того, что требует верхний уровень.</p><p>Эти особенности могут использоваться для работы через сеть с аномальной ситуацией или реализацией протокола маршрутизации, который способен получать значение PMTU.</p><p>Реализации должны также предоставлять путь для изменения таймаута старения информации PMTU.</p><h2 id="p7">7. Вероятные значения для PMTU</h2><p>Алгоритмы, рекомендованные в разделе 5 для «поиска» пространства PMTU основаны на таблице значений, которая строго ограничивает поисковое пространство. Мы описываем здесь таблицу значений PMTU, которые представляют все главные технологии, используемые в Internet.</p><p>В таблице 7-1, данные представлены в порядке уменьшения PMTU, и сгруппированы так, что каждый набор одинаковых MTU, ассоциирован с «плато», равному наименьшему MTU в группе. Когда плато представляет больше одного MTU, таблица показывает максимальное отклонение в процентах, связанное с этим плато.</p><p>Мы не ожидаем, что значения в таблице, особенно для верхних уровней MTU, будут правильными всегда. Значения, находящиеся в таблице являются предложением для разработчиков, а НЕ спецификацией или требованием. Разработчики должны использовать актуальные ссылки для сбора наборов плато, это важно, поскольку таблица не содержит слишком много значений и поэтому процесс поиска PMTU может тратить впустую ресурсы Internet. Для клиентов, не имеющих исходных текстов операционных систем, разработчики должны предусмотреть удобный метод обновления таблиц в из системах (например, в ядрах Unix, основанных на BSD, таблица может быть изменена с помощью новой команды «ioctl»).</p><p>Замечание: возможно, является хорошей идеей добавить несколько значений в таблицу равных малым степеням числа 2 плюс 40 (для IP и ТСР заголовка), если таких значений там не существует, так как кажется это резонный непроизвольный путь выбрать произвольные значения.</p><p>Эта таблица может также содержать записи для значений немного меньших, чем большие степени 2, в этом случае MTU определено около этих значений (в это случае для записей таблицы лучше быть маленькими, чем быть большими, иначе следующее самое маленькое плато будет выбрано вместо этого).</p><h3 id="p7.1">7.1. Наилучший способ определить увеличение PMTU</h3><p>Раздел 6.3 предлагает детектировать увеличение PMTU путем периодического повышения оценки PMTU до MTU на первом хопе. Вероятнее всего, этот процесс будет просто «переопределять» текущую оценку PMTU, ценой нескольких отброшенных датаграмм, поэтому это не должно выполняться часто.</p><p>Лучший подход это периодически повышать оценку PMTU до следующего самого высокого значения PMTU в таблице плато (или до MTU на первом хопе, если оно меньше). Если увеличенного значение не верно, то перед тем как будет найдено верное значение, будет затрачено время порядка времени прохождения пакета туда-обратно. Если увеличенное значение все еще слишком мало, то большее значение будет попробовано несколько позже.</p><p>Поскольку может требоваться несколько таких периодов для обнаружения существенного увеличения PMTU, мы рекомендуем этот короткий таймаут использовался после увеличения оценки, и более длинный таймаут использовался после ее уменьшения, произошедшего в результате получение сообщения «датаграмма слишком большая».</p><pre>Plateau    MTU    Comments                      Reference
------     ---    --------                      ---------
           65535  Official maximum MTU          <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC 791</a>
           65535  Hyperchannel                  RFC 1044
65535
32000             Just in case
           17914  16Mb IBM Token Ring           ref. [6]
17914
           8166   IEEE 802.4                    <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC 1042</a>
8166
           4464   IEEE 802.5 (4Mb max)          <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC 1042</a>
           4352   FDDI (Revised)                RFC 1188
4352 (1%)
           2048   Wideband Network              RFC 907
           2002   IEEE 802.5 (4Mb recommended)  <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC 1042</a>
2002 (2%)
           1536   Exp. Ethernet Nets            RFC 895
           1500   Ethernet Networks             <a href="../894.rfc" title="RFC 894 - Стандарт передачи дейтаграмм IP в сетях Ethernet">RFC 894</a>
           1500   Point-to-Point (default)      RFC 1134
           1492   IEEE 802.3                    <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC 1042</a>
1492 (3%)
           1006   SLIP                          RFC 1055
           1006   ARPANET                       BBN 1822
1006
           576    X.25 Networks                 RFC 877
           544    DEC IP Portal                 ref. [10]
           512    NETBIOS                       RFC 1088
           508    IEEE 802/Source-Rt Bridge     <a href="../1042.rfc" title="RFC 1042 - Стандарт передачи дейтаграмм IP в сетях IEEE 802">RFC 1042</a>
           508    ARCNET                        RFC 1051
508 (13%)
           296    Point-to-Point (low delay)    RFC 1144
296
68                Official minimum MTU          <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC 791</a>
---------  -----  ----------------------------  ---------

Таблица 7-1: Распространенные MTU</pre><p>Например, после того как оценка PMTU была уменьшена, таймаут должен быть установлен в 10 мин. После того как этот интервал истек и было попробовано большее значение, таймаут может быть установлен гораздо более короткий (скажем 2 минуты). Ни в коем случае таймаут не должен быть короче, чем время на пересылку пакета туда-обратно, если оно известно.</p><h2 id="p8">8. Соображения безопасности</h2><p>Механизм PMTU делает возможным два вида атак на отказ в обслуживании, оба основанные на посылке ложных сообщений «датаграмма слишком большая» злонамеренной стороной.</p><p>В первой атаке, фальшивые сообщения «датаграмма слишком большая» показывают, что PMTU намного меньше реальной. Это не должно полностью остановить весь поток данных, поскольку атакуемый хост никогда не будет использовать PMTU меньше абсолютного минимума, но 8 октетов данных на одну датаграмму замедлят обмен.</p><p>Во второй атаке фальшивые сообщения указывают PMTU больший, чем в реальности. Это может вызвать временную блокаду, так как датаграммы посылаемые атакуемым хостом будут отброшены одним из маршрутизаторов. В течение одного периода, равного по длительности, времени необходимому для пересылки пакета туда-обратно, хост будет исправлять ошибку (получив сообщение «датаграмма слишком большая» от этого маршрутизатора). Частое повторение этой атаки приведет к увеличению датаграмм, которые будут отброшены. Хост, конечно, не должен повышать оценку PMTU, основываясь на сообщении «датаграмма слишком большая», чтобы не быть подверженным данной атаке.</p><p>Злонамеренная сторона могла бы создавать проблемы, если бы могла остановить обработку истинных сообщений «датаграмма слишком большая», но имеются более простые атаки на отказ в обслуживании.</p><h2 id="p.references">Ссылки</h2><table itemprop="references"><tr><td>[1]</td><td>Robert Braden, <a href="../1122.rfc" title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни">«Требования к хостам Internet - Коммуникационные уровни», RFC 1122</a>, Октябрь 1989.</td></tr><tr><td>[2]</td><td>Geof Cooper. IP Datagram Sizes. Electronic distribution of the TCP-IP Discussion Group, Message-ID 8705240517.AA01407@apolling.imagen.uucp.</td></tr><tr><td>[3]</td><td>ISO. ISO Transport Protocol Specification: ISO DP 8073. RFC 905, SRI Network Information Center, April, 1984.</td></tr><tr><td>[4]</td><td>Van Jacobson. Congestion Avoidance and Control. In Proc. SIGCOMM '88 Symposium on Communications Architectures and Protocols, pages 314-329. Stanford, CA, August, 1988.</td></tr><tr><td>[5]</td><td>C. Kent and J. Mogul. Fragmentation Considered Harmful. In Proc. SIGCOMM '87 Workshop on Frontiers in Computer Communications Technology. August, 1987.</td></tr><tr><td>[6]</td><td>Drew Daniel Perkins. Private Communication.</td></tr><tr><td>[7]</td><td>J. Postel, <a href="../792.rfc" title="RFC 792 - Протокол ICMP">«Протокол ICMP», RFC 792</a>, Сентябрь 1981.</td></tr><tr><td>[8]</td><td>J. Postel, <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">«Протокол IP (Internet Protocol)», RFC 791</a>, Сентябрь 1981.</td></tr><tr><td>[9]</td><td>J. Postel. The TCP Maximum Segment Size and Related Topics. RFC 879, SRI Network Information Center, November, 1983.</td></tr><tr><td>[10]</td><td>Michael Reilly. Private Communication.</td></tr><tr><td>[11]</td><td>Sun Microsystems, Inc. RPC: Remote Procedure Call Protocol. RFC 1057, SRI Network Information Center, June, 1988.</td></tr></table><h2>Адреса авторов</h2><p>Jeffrey Mogul<br />Digital Equipment Corporation Western Research Laboratory 100 Hamilton Avenue<br />Palo Alto, CA 94301<br />Phone: (415) 853-6643<br />EMail: <bdo dir="rtl">&#109;&#111;&#99;&#46;&#99;&#101;&#100;&#46;&#108;&#114;&#119;&#99;&#101;&#100;&#64;&#108;&#117;&#103;&#111;&#109;</bdo></p><p>Steve Deering<br />Xerox Palo Alto Research Center<br />3333 Coyote Hill Road<br />Palo Alto, CA 94304<br />Phone: (415) 494-4839<br />EMail: <bdo dir="rtl">&#109;&#111;&#99;&#46;&#120;&#111;&#114;&#101;&#120;&#64;&#103;&#110;&#105;&#114;&#101;&#101;&#100;</bdo></p></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 1191 - Исследование MTU на пути следования сообщения",disqus_identifier="1191.rfc",disqus_url="http://rfc2.ru/1191.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>