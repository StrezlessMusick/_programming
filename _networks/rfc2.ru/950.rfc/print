<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../950.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 950 — Стандартные процедуры организации подсетей IP</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../950.rfc">RFC 950 — Стандартные процедуры организации подсетей IP</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 950</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank" rel="nofollow"><span itemprop="alternativeHeadline">Internet Standard Subnetting Procedure</span></a></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Стандарт Интернета</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1985-08-01">Август 1985</time></dd><dd><div class="icon i5"></div> Авторы: <span itemprop="author">J. Mogul</span>, <span itemprop="author">J. Postel</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div id="text" itemprop="articleBody"><h3>Статус документа</h3><p>Этот документ описывает стандартный протокол для сообщества ARPA-Internet. При использовании подсетей настоятельно рекомендуется следовать описанным здесь процедурам. Документ может распространяться свободно.</p><h3>Обзор</h3><p>В этом документе рассматривается разбиение сетей IP на подсети, являющиеся логическими фрагментами сетей IP. По административным и техническим соображениям многие организации предпочитают делить свои сети на несколько сетей вместо приобретения нескольких блоков адресов IP (номеров сетей). В этом документе описываются процедуры организации подсетей и работы с ними. Описанные здесь процедуры применяются на хостах (например, рабочих станциях). Процедуры используемые для работы с подсетями на маршрутизаторах (шлюзах), описаны лишь частично. Основой для создания настоящего стандарта послужила работа RFC-940 [7].</p><h3>Благодарности</h3><p>Данный документ основан на результатах работы <a href="../917.rfc" title="RFC 917 - Подсети Internet">RFC-917</a> [1]. В разработке описываемого здесь стандарта участвовало много людей и особо хочется отметить значительный вклад J. Noel Chiappa, Chris Kent и Tim Mann. Важный вклад в разработку стандарта внесли также Zaw-Sing Su, Mike Karels и рабочая группа GADS (Gateway Algorithms and Data Structures Task Force).</p><h2>1. Мотивация</h2><p>Исходное представление пространства Internet было двухуровневой иерархией — на верхнем уровне находилась сеть Internet в целом, а на нижнем уровне располагались отдельные сети, каждая из которых имела свой номер. В Internet не используется иерархической топологии и двухуровневая иерархия связана лишь с интерпретацией адресов. В 2- уровневой модели каждый хост видит свою сеть как единое целое, т. е., сеть можно трактовать как "черный ящик", к которому подключен набор хостов.</p><p>Хотя такое представление обеспечивает простоту и мощь, многие организации считают его неадекватным и добавляют третий уровень в иерархическую схему адресации Internet — в этом случае сеть IP рассматривается как набор подсетей. Трехуровневая иерархия удобна для больших организаций (например, университетов или компаний, сети которых располагаются в нескольких зданиях), где множество ЛВС может входить в одну "локальную область". В таких случаях удобно трактовать каждую ЛВС как подсеть.</p><p>Существует несколько причин, по которым в сети IP может использоваться несколько физических сетей:</p><ul class="dot"><li>Различные топологии — зачастую (особенно в исследовательских организациях) в сети может использоваться несколько ЛВС различных типов (например, Ethernet и сети с кольцевой топологией).</li><li>Присущие используемым технологиям ограничения — большинству топологий ЛВС присущи те или иные ограничения (электрические параметры, число хостов в ЛВС, общая протяженность кабеля). Использование подсетей позволяет достаточно просто преодолеть эти ограничения (особенно ограничение протяженности кабеля).</li><li>Насыщение сети — в локальных сетях могут возникать ситуации, когда небольшая группа хостов фактически монополизирует полосу пропускания сетевой среды. Общим решением таких проблем является сегментирование сети (разбиение на несколько фрагментов) с организацией раздельных кабельных систем.</li><li>Использование каналов "точка-точка" — иногда "локальная сеть" (например, кампусная сеть университета) разделена на несколько фрагментов (например, ЛВС отдельных зданий), соединенных между собой скоростными каналами "точка-точка".</li></ul><p>Организации, имеющие более одной ЛВС могут выбрать один из трех вариантов распределения адресов IP:</p><ol><li>Получить отдельный блок адресов для каждой локальной сети и не использовать подсетей.</li><li>Использовать для всей организации общий номер сети и распределять адреса независимо от расположения хостов (принадлежности хостов к ЛВС). Такой вариант получил название transparent subnets (прозрачные подсети).</li><li>Используя один номер сети, разделить адресное пространство на несколько подсетей в соответствии с имеющимися ЛВС. Такой вариант называется explicit subnets (явные подсети).</li></ol><p>Каждый из вариантов имеет свои преимущества и недостатки. Первый вариант не требует добавления или изменения протоколов, но ведет к разрастанию таблиц маршрутизации Internet. Информация о внутренней структуре сети распространяется повсюду, хотя она мало кому нужна и в большинстве случаев не используется. В некоторых реализациях шлюзов может возникнуть проблема нехватки пространства в таблице маршрутов, поэтому такой вариант лучше не использовать.</p><p>Второй вариант требует использования неких соглашений или протоколов, позволяющих объединить множество ЛВС в одну сеть IP. Например, этот вариант можно реализовать в ЛВС, где каждый адрес IP транслируется в аппаратный адрес с использованием протокола ARP, имея мосты между ЛВС, которые будут перехватывать запросы ARP для нелокальных адресатов (см. RFC-925 [2]). Однако такое решение возможно не для всех технологий ЛВС, особенно в тех случаях, когда технология не использует протокол ARP или ЛВС не поддерживает широковещания. Более сложная проблема состоит в том, что мосты должны узнавать к какой ЛВС принадлежит хост, возможно используя для этого широковещательные рассылки. По мере увеличения числа ЛВС расходы на поддержку такого широковещания будут быстро возрастать; расти будет и размер кэша трансляции, требуемого для преобразования адресов.</p><p>Третий вариант используется для явной поддержки подсетей. Он тоже имеет свои недостатки — в частности, требуется модификация протокола IP, которая влечет за собой необходимость изменения существующих реализаций IP (если планируется использовать их с подсетями). Однако требуемые изменения сравнительно невелики и после их внесения проблема будет эффективно решена. Кроме того, этот вариант не требует каких-либо изменений для обеспечения совместимости с существующими хостами и сетями, не поделенными на подсети.</p><p>После выбора одного из вариантов может оказаться, что хосты, которые предполагалось использовать в среде без подсетей, попадут в одну из подсетей (см. <a href="../917.rfc" title="RFC 917 - Подсети Internet">RFC-917</a> [1]). Такое решение может быть полезно в тех случаях, когда нет возможности явно поддерживать подсети или требуется постепенный переход.</p><h2>2. Стандарты для подсетей</h2><p>В этой главе сначала описаны предложения по интерпретации адресов IP для поддержки подсетей. После этого рассматриваются изменения программ на хостах, которые обеспечат поддержку подсетей. И, наконец, описаны процедуры определения способа интерпретации адресов, используемого в сети (т. е., значения маски).</p><h3>2.1. Интерпретация адресов Internet</h3><p>Предположим, что организация имеет сеть IP с зарегистрированным номером и планирует разделить свою сеть на несколько подсетей. Что в таких случаях нужно сделать.</p><p>Поскольку распределение битов локальной части адреса почти ничем не ограничено, для представления номеров подсетей может использоваться несколько вариантов:</p><ol><li>Поле переменной длины. Для нумерации подсетей используется произвольное число битов локальной части адреса. Размер поля номера подсети сохраняется в масштабе каждой подсети, но может различаться в разных подсетях. Если поле имеет нулевой размер, это говорит об отсутствии подсетей.</li><li>Поле фиксированной длины. Для нумерации подсетей используется фиксированное число битов (например, 8).</li><li>Поле переменной длины с автокодированием (Self-encoding variable-width field). Классы сетей (размер поля номера сети) определяются значениями старших битов адреса IP — аналогично этому старшие биты локальной части адреса могут задавать размер поля номера подсети.</li><li>Поле фиксированной длины с автокодированием (Self-encoding fixed-width field). Для нумерации подсетей используется заданное число битов.</li><li>Маскирование битов. Для идентификации битов номера сети используется битовая маска (address mask).</li></ol><p>Какие критерии могут использоваться для выбора одной из 5 предложенных схем. Следует ли использовать схемы с автокодированием. Должна ли обеспечиваться возможность обнаружить наличие подсетей по адресу IP без использования дополнительной информации.</p><p>Отличительной особенностью автокодирования является то, что оно позволяет разделить пространство адресов на подсети различных размеров (обычно одна подсеть размером в половину адресного пространства и группа подсетей меньших размеров). В качестве примера рассмотрим разбиение сети класса C с использованием схемы автокодирования. Старший бит показывает наличие (или отсутствие) большой подсети, а три следующих бита используются для идентификации подсетей меньших размеров. Если первый бит имеет нулевое значение, это указывает на большую подсеть (половина адресного пространства); 1 в старшем бите говорит о разбиении на более мелкие подсети. Поскольку для идентификации мелких подсетей используется 3 бита, такая схема позволяет создать 1 подсеть со 128 адресами и 8 подсетей по 16 адресов в каждой.</p><p>Для разработки стандарта параметров и реализации подсетей с автокодированием схема кодирования должна быть зафиксирована и сохраняться неизменной в масштабе Internet.</p><p>Можно предположить повсеместное использование подсетей — это позволяет интерпретировать адреса без использования дополнительной информации.</p><p>Возможность определения принадлежности двух хостов к одной сети без привлечения дополнительной информации является важным обстоятельством. Однако с таким решением связан и существенный недостаток — оно может порождать проблемы для существующих сетей, в которых при нумерации хостов используются произвольные (все) локальной части адреса. Иными словами, полезно иметь возможность управления использованием подсетей независимого от адресов хостов.</p><p>Альтернативный вариант обеспечивает независимое (от битов адреса) хранение информации о наличии подсетей (флага). Если флаг использования подсетей установлен, предполагается использование схемы с автокодированием. В противном случае считается, что сеть представляет собой единое целое.</p><p>Если автокодирование не применяется, нет смысла использовать схему с полем фиксированной длины, поскольку это требует для каждой сети использовать тот или иной "флаг", говорящий об использовании подсетей и размере поля. А необходимость использования целого числа (размер поля номера подсети) взамен логического значения (факт использования подсетей) только осложняет задачу. Преимущество использования схемы с адресными масками состоит в том, что она позволяет каждой организации выбрать оптимальный вариант распределения хостов по подсетям и обеспечивает экономное использование адресного пространства. Следовательно, мы выбираем схему на основе масок как наиболее гибкую, издержки, связанные с реализацией этой схемы, не превышают издержек для других вариантов. Например, адрес IP можно интерпретировать как:</p><pre>&lt;номер сети&gt;&lt;номер подсети&gt;&lt;номер хоста&gt;</pre><p>где поле &lt;номер сети&gt; определяется стандартом IP <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC-791</a> [3], поле &lt;номер хоста&gt; включает по крайней мере 1 бит, а поле &lt;номер подсети&gt; является постоянным для данной сети. Для полей &lt;номер подсети&gt; и &lt;номер хоста&gt; не требуется дополнительного структурирования. Если размер поля &lt;номер подсети&gt; равен 0, подсети не используются (адресация в соответствии с <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC-791</a> [3]).</p><p>Например, в сети класса B с 6-битовым номером подсети адрес будут интерпретироваться следующим образом:</p><pre>                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1 0|       Номер Сети          |  Подсеть  |    Номер Хоста    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><p>Поскольку биты, идентифицирующие подсеть, указываются маской, эти биты не обязаны составлять непрерывный массив. Однако рекомендуется использовать для нумерации подсетей старшие биты локальной части адреса.</p><h4>Специальные адреса</h4><p class="note">Из документа Assigned Numbers [9]: "В некоторых случаях полезно зафиксировать некоторые адреса для выполнения специальных функций, а не для обозначения конкретных хостов. Обычно поле, состоящее из одних нулей интерпретируется как "данная" (данная сеть или подсеть), а поле адреса, состоящее только из единиц, интерпретируется как "все" (все подсети, все хосты). Таким образом, запись 128.9.255.255 может интерпретироваться как "все хосты сети 128.9, а адрес 0.0.0.37 указывает на хост 37 в данной сети".</p><p>Полезно сохранить такую интерпретацию и для случаев использования подсетей. В соответствии с этим значения, состоящие только из нулей или единиц, не должны использоваться для нумерации реальных (физических) подсетей. В приведенном выше примере 6-битовое поле номера подсети позволяет использовать номера от 1 до 62 (0 и 63 используются как служебные)</p><p class="note">Отметим, что эти ограничения никак не относятся к сетям, не поделенным на подсети.</p><h3>2.2. Изменение программ на хостах для поддержки подсетей</h3><p>В большинстве реализаций IP имеется код, обслуживающий исходящие дейтаграммы и принимающий решение о передаче каждой дейтаграммы хосту локальной сети или пересылке ее на шлюз (маршрутизатор). В общем случае этот фрагмент кода работает так:</p><pre>IF ip_net_number(dg.ip_dest) = ip_net_number(my_ip_addr)
    THEN
        send_dg_locally(dg, dg.ip_dest)
    ELSE
        send_dg_locally(dg,
                         gateway_to(ip_net_number(dg.ip_dest)))</pre><p>(при обслуживании множество соединений, код становится более сложны, но в контексте данного документа это не имеет значения).</p><p>Для поддержки подсетей требуется сохранять одно или несколько 32-битовых значений, называемых масками. В этой битовой маске установлены (1) биты, соответствующие полям номера сети IP, и дополнительные биты, соответствующие полю номера подсети.</p><p>Соответствующий код будет иметь вид:</p><pre>IF bitwise_and(dg.ip_dest, my_ip_mask) = bitwise_and(my_ip_addr, my_ip_mask)
    THEN
        send_dg_locally(dg, dg.ip_dest)
    ELSE
        send_dg_locally(dg,
               gateway_to(bitwise_and(dg.ip_dest, my_ip_mask)))</pre><p>Часть выражений в условиях может быть вычислена заранее (известна). Может потребоваться изменение функции gateway_to так, чтобы она принимала во внимание биты номера подсети при выполнении операций сравнения.</p><p>Для поддержки хостов с множеством подключений (сетевых интерфейсов — прим. перев.) код может быть изменен та, чтобы значения my_ip_addr и my_ip_mask сохранялись для каждого интерфейса. Проверка условий должна выполняться для каждого интерфейса таких хостов.</p><h3>2.3. Определение адресной маски</h3><p>Как хост может определить, что в подсети, к которой подключен хост, используется адресная маска. Эта проблема аналогична некоторым проблемам сетевой загрузки (bootstrapping) хостов Internet — как хосту определить собственный адрес и как узнать адрес шлюза в локальной сети. Для всех трех случаев существуют два варианта решения — "аппаратная" (hardwired) информация или использование протоколов на базе широковещания.</p><p>К аппаратной информации относятся сведения, доступные хосту без подключения к сети (изолированному) — эти сведения могут быть включены в программный код (compiled-in) или (предпочтительно) сохранены в дисковом файле. Однако для случая бездисковых станций, загружаемых через ЛВС ни один из этих вариантов не подходит. Поскольку большинство технологий ЛВС поддерживают широковещание, лучшим вариантом для "свежезагруженного" хоста является широковещательная передача запроса на получение требуемой информации. Например, для определения адреса IP хост может использовать <a href="../903.rfc" title="RFC 903 - Протокол RARP">протокол RARP</a> [4].</p><p>Поскольку хосту после загрузки нужно собрать достаточно много информации (свой IP-адрес, аппаратный адрес шлюза, IP-адрес сервера доменных имен, маску подсети), более эффективно будет запросить всю требуемую информацию разом, нежели делать множество широковещательных запросов. Механизм, разработанный для загрузки бездисковых станций через сеть, хост может использовать и для загрузки конфигурационного файла, содержащего всю требуемую информацию (см., например, RFC-951 [8]). Возможно (и желательно) получить все сведения, требуемые для работы хоста, в результате передачи одного широковещательного сообщения.</p><p>В тех случаях, когда хосту требуется определить адресную маску, используя для это отдельную операцию, применяется следующий механизм:</p><blockquote><p>Для обеспечения сведений об адресных масках в <a href="../792.rfc" title="RFC 792 - Протокол ICMP">протокол ICMP</a> [5] добавлена пара новых типов сообщений ICMP — Address Mask Request (запрос маски) и Address Mask Reply (отклик на запрос маски), аналогичные сообщениям Information Request (запрос информации) и Information Reply (отклик на запрос информации. Эти типы сообщений описаны ниже (Приложение I. Сообщения ICMP Address Mask).</p><p>Новые сообщения ICMP используются следующим образом — хост при загрузке передает широковещательное сообщение Address Mask Request. Шлюз (или хост, действующий вместо шлюза), получив такое сообщение, будет передавать отклик Address Mask Reply. Если в запросе отправитель не был указан (поле IP Source Address имеет значение 0), отклик также передается в широковещательном сообщении. Запросивший информацию хост получит это сообщение и сможет определить адресную маску.</p><p>Поскольку для каждой конкретной ЛВС в сообщении Address Mask Reply может содержаться только одно значение, нет необходимости проверять соответствие отклика запросу. Даже при получении отклика от нескольких шлюзов, информация во всех сообщениях будет совпадать. Предполагается, что хосты перезагружаются достаточно редко, поэтому количество широковещательных сообщений для определения маски достаточно мало.</p></blockquote><p>Если хост подключен к нескольким ЛВС, он может определить маски для каждой под сети. Возможны ситуации, когда хосту не удается определить маску даже после нескольких попыток. Это может происходить в трех ситуациях:</p><ol><li>Локальная сеть изолирована от всех других сетей.</li><li>Подсети не используются и никакой из хостов не может сообщить адресную маску.</li><li>Все шлюзы локальной сети находятся (временно) в нерабочем состоянии (down).</li></ol><p>В первых двух случаях адресная маска идентична маске сети, а в третьем случае не существует способа определить значение маски и самым безопасным вариантом будет использование адресной маски, совпадающей с маской сети. Хотя позднее может обнаружиться некорректность такой маски, ее использование не порождает проблем при передаче. После того, как восстановится нормальная работа шлюза, он будет передать широковещательное сообщение Address Mask Reply; когда хост получит это сообщение, он может изменить адресную маску в соответствии с полученным от шлюза значением. Хостам и шлюзам не следует передавать сообщений Address Mask Reply с "приблизительной" маской. В заключение отметим, что хост не обязан использовать протокол ICMP для определения маски — параметры хоста могут сохраняться в энергонезависимой памяти.</p><h2>Приложение I. Сообщения ICMP Address Mask</h2><h4>Address Mask Request и Address Mask Reply</h4><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Тип      |      Код      |       Контрольная сумма       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Идентификатор         |       Порядковый номер        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Адресная маска                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><h4>Поля IP</h4><ul><li class="b">Адреса</li><li class="lia">Адрес отправителя в запросе адресной маски служит адресом получателя при передаче откликов. Для формирования отклика на запрос адресной маски адрес отправителя запроса помещается в поле адреса получателя, адрес отправителя отклика помещается в поле отправителя, тип заменяется на AM2, адресная маска помещается в поле Address Mask и вычисляется контрольная сумма. Если же в запросе адрес отправителя имеет нулевое значение, в поле получателя отклика должен указываться широковещательный адрес.</li></ul><h4>Поля ICMP</h4><ul><li class="b">Type (тип)</li><li class="lia">AM1 для запросов; ICMP</li><li class="lia">AM2 для откликов.</li><li class="b">Code (код)</li><li class="lia">0 — для запросов;</li><li class="lia">0 — для откликов.</li><li class="b">Checksum (контрольная сумма)</li><li class="lia">Контрольная сумма представляет собой 16-битовое поразрядное дополнение для полей сообщения ICMP, начиная с ICMP Type. При расчете контрольной суммы значение поля Checksum принимается равным 0. Алгоритм вычисления контрольной суммы в будущем может быть изменен.</li><li class="b">Identifier (идентификатор)</li><li class="lia">Идентификаторы служат для обнаружения соответствия между запросами и откликами. Это поле может иметь нулевое значение.</li><li class="b">Sequence Number (порядковый номер)</li><li class="lia">Порядковый номер служит для определения соответствия между запросами и откликами. Поле может иметь нулевое значение.</li><li class="b">Address Mask (адресная маска)</li><li class="lia">32-битовое значение маски.</li><li class="b">Description (описание)</li><li class="lia">Шлюзу, получившему запрос адресной маски, следует возвратить отклик, содержащий искомую маску, которая идентифицирует сеть и подсеть для подсети, из которой поступил запрос. Если запрашивающий хост не знает своего адреса IP, он может указать 0 в поле адреса отправителя — отклик в таких случаях передается в широковещательном режиме. По возможности следует избегать широковещательной передачи откликов, поскольку она достаточно сильно загружает сеть. Даже при широковещательной передаче откликов не требуется проверять соответствие между запросом и откликом, поскольку для каждой подсети может использоваться только одна адресная маска. Следовательно, поля Identifier и Sequence Number можно игнорировать. Пакеты типа AM1 могут приниматься от шлюзов и хостов, а пакеты типа AM2 — от шлюзов или хостов, действующих как шлюзы.</li></ul><h2>Приложение II. Примеры</h2><p>Приведенные здесь примеры показывают, как хост может определить адресную маску, используя сообщения ICMP Address Mask Request и Address Mask Reply. В примерах предполагается, что 255.255.255.255 означает широковещательный адрес для физической среды (см. <a href="../919.rfc" title="RFC 919 - Широковещательная рассылка дейтаграмм IP">RFC-919</a> [6]).</p><h3>Приложение II.1. Сеть класса A</h3><p>Предположим, что запрашивающий маску хост сети класса A 36.0.0.0 имеет адрес 36.40.0.123, адрес шлюза 36.40.0.62, а поле номера подсети имеет размер 8 битов, т.е., маска имеет значение 255.255.0.0.</p><p>Для хоста наиболее эффективно (рекомендуется поступать именно так) будет определить сначала свой адрес (например, с помощью <a href="../903.rfc" title="RFC 903 - Протокол RARP">RARP</a> [4]) и только после этого передавать запрос ICMP по адресу 255.255.255.255:</p><pre>Адрес отправителя:      36.40.0.123
Адрес получателя:       255.255.255.255
Протокол:               ICMP = 1
Тип:                    Address Mask Request = AM1
Код:                    0
Маска:                  0</pre><p>Шлюз может адресовать свой отклик непосредственно запрашивающему хосту.</p><pre>Адрес отправителя:      36.40.0.62
Адрес получателя:       36.40.0.123
Протокол:               ICMP = 1
Тип:                    Address Mask Reply = AM2
Код:                    0
Маска:                  255.255.0.0</pre><p>Предположим, что хост 36.40.0.123 является бездисковой станцией и не знает своего номера. В таком случае хост может передать следующую дейтаграмму:</p><pre>Адрес отправителя:      0.0.0.0
Адрес получателя:       255.255.255.255
Протокол:               ICMP = 1
Тип:                    Address Mask Request = AM1
Код:                    0
Маска:                  0</pre><p>Шлюз 36.40.0.62 получит эту дейтаграмму и передаст отклик:</p><pre>Адрес отправителя:      36.40.0.62
Адрес получателя:       255.255.255.255
Протокол:               ICMP = 1
Тип:                    Address Mask Reply = AM2
Код:                    0
Маска:                  255.255.0.0</pre><p>Отметим, что шлюз использует минимальную из возможных областей широковещания (физическую сеть) для передачи отклика. Но даже в таком случае использование широковещания приводит к росту нагрузки на все хосты подсети, поэтому использования анонимного адреса отправителя (0.0.0.0) следует избегать.</p><p>Если широковещание не поддерживается, мы предполагаем, что хост имеет "аппаратную" возможность определения соседнего шлюза. В таких случаях хост 36.40.0.123 может передать дейтаграмму:</p><pre>Адрес отправителя:      36.40.0.123
Адрес получателя:       36.40.0.62
Протокол:               ICMP = 1
Тип:                    Address Mask Request = AM1
Код:                    0
Маска:                  0</pre><p>Шлюз 36.40.0.62 будет отвечать точно так ж, как для предыдущего случая.</p><pre>Адрес отправителя:      36.40.0.62
Адрес получателя:       36.40.0.123
Протокол:               ICMP = 1
Тип:                    Address Mask Reply = AM2
Код:                    0
Маска:                  255.255.0.0</pre><h3>Приложение II.2. Сеть класса B</h3><p>Предположим, что запрашивающий маску хост сети класса B 128.99.0.0 имеет адрес 128.99.4.123, адрес шлюза 128.99.4.62, а для нумерации подсетей используется 6-битовое поле (маска 255.255.252.0).</p><p>Хост передает запрос ICMP по адресу 255.255.255.255:</p><pre>Адрес отправителя:      128.99.4.123
Адрес получателя:       255.255.255.255
Протокол:               ICMP = 1
Тип:                    Address Mask Request = AM1
Код:                    0
Маска:                  0</pre><p>Шлюз может адресовать отклик непосредственно хосту.</p><pre>Адрес отправителя:      128.99.4.62
Адрес получателя:       128.99.4.123
Протокол:               ICMP = 1
Тип:                    Address Mask Reply = AM2
Код:                    0
Маска:                  255.255.252.0</pre><p>Бездисковый хост будет передавать запрос:</p><pre>Адрес отправителя:      0.0.0.0
Адрес получателя:       255.255.255.255
Протокол:               ICMP = 1
Тип:                    Address Mask Request = AM1
Код:                    0
Маска:                  0</pre><p>Шлюз 128.99.4.62 получит эту дейтаграмму и должен передать отклик:</p><pre>Адрес отправителя:      128.99.4.62
Адрес получателя:       255.255.255.255
Протокол:               ICMP = 1
Тип:                    Address Mask Reply = AM2
Код:                    0
Маска:                  255.255.252.0</pre><p>Если в сети не поддерживается широковещание, хост 128.99.4.123 будет передавать дейтаграмму:</p><pre>Адрес отправителя:      128.99.4.123
Адрес получателя:       128.99.4.62
Протокол:               ICMP = 1
Тип:                    Address Mask Request = AM1
Код:                    0
Маска:                  0</pre><p>На которую шлюз 128.99.4.62 должен передать отклик, аналогичный предыдущему случаю.</p><pre>Адрес отправителя:      128.99.4.62
Адрес получателя:       128.99.4.123
Протокол:               ICMP = 1
Тип:                    Address Mask Reply = AM2
Код:                    0
Маска:                  255.255.252.0</pre><h3>Приложение II.3. Сеть класса C (с разрывным массивом битов нумерации подсети)</h3><p>Предположим, что запрашивающий хост сети класса C 192.1.127.0 имеет адрес 192.1.127.19, адрес шлюза 192.1.127.50, а для нумерации подсетей используется трехбитовое поле (01011000), т. е., маска равна 255.255.255.88.</p><p>Хост передает запрос ICMP по адресу 255.255.255.255:</p><pre>Адрес отправителя:      192.1.127.19
Адрес получателя:       255.255.255.255
Протокол:               ICMP = 1
Тип:                    Address Mask Request = AM1
Код:                    0
Маска:                  0</pre><p>Шлюз может адресовать отклик непосредственно хосту.</p><pre>Адрес отправителя:      192.1.127.50
Адрес получателя:       192.1.127.19
Протокол:               ICMP = 1
Тип:                    Address Mask Reply = AM2
Код:                    0
Маска:                  255.255.255.88.</pre><p>Бездисковый хост будет передавать запрос:</p><pre>Адрес отправителя:      0.0.0.0
Адрес получателя:       255.255.255.255
Протокол:               ICMP = 1
Тип:                    Address Mask Request = AM1
Код:                    0
Маска:                  0</pre><p>Шлюз 192.1.127.50 будет принимать запрос и должен ответить на него дейтаграммой:</p><pre>Адрес отправителя:      192.1.127.50
Адрес получателя:       255.255.255.255
Протокол:               ICMP = 1
Тип:                    Address Mask Reply = AM2
Код:                    0
Маска:                  255.255.255.88.</pre><p>Если широковещание не поддерживается, хост 192.1.127.19 будет передавать дейтаграмму:</p><pre>Адрес отправителя:      192.1.127.19
Адрес получателя:       192.1.127.50
Протокол:               ICMP = 1
Тип:                    Address Mask Request = AM1
Код:                    0
Маска:                  0</pre><p>на которую шлюз 192.1.127.50 должен отвечать, как в предыдущем случае, дейтаграммой:</p><pre>Адрес отправителя:      192.1.127.50
Адрес получателя:       192.1.127.19
Протокол:               ICMP = 1
Тип:                    Address Mask Reply = AM2
Код:                    0
Маска:                  255.255.255.88</pre><h2>Приложение III. Глоссарий</h2><ul><li class="b">Bridge — мост</li><li class="lia">Узел, соединяющий две или более сети, не различаемые административно (логически), но относящиеся к разным физическим подсетям, и автоматически пересылающий дейтаграммы между подсетями, когда это требуется. Другие хосты о существовании моста просто не знают. Иногда для обозначения мостов используют термин software repeater (программный повторитель).</li><li class="b">Host Field — поле хоста</li><li class="lia">Битовое поле в адресе IP, используемое для идентификации конкретного хоста.</li><li class="b">Internet</li><li class="lia">Множество связанных между собой сетей IP.</li><li class="b">Local Address — локальный адрес</li><li class="lia">Биты адреса IP, не используемые для задания номера сети (в соответствии с определением в работе <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">RFC-791</a> [3]).</li><li class="b">Network — сеть</li><li class="lia">Одна сеть IP, которая может представлять единое целое или состоять из множества подсетей.</li><li class="b">Network Number — номер сети</li><li class="lia">Поле идентификации сети в адресе IP.</li><li class="b">Subnet — подсеть</li><li class="lia">Одна или несколько физических сетей, формирующие подмножество сети IP. Подсеть явно задается в адресе IP.</li><li class="b">Subnet Fiel d — поле подсети</li><li class="lia">Битовое поле в адресе IP, содержащее номер подсети. Биты этого поля не обязаны быть непрерывными в адресе.</li><li class="b">Subnet Number — номер подсети</li><li class="lia">Номер, идентифицирующий подсеть внутри сети.</li></ul><h2>Приложение IV. Выделенные номера</h2><p>В качестве параметров протоколов, используемых для поддержки подсетей, были выделены специальные значения. Эти значения используются только протоколом <a href="../792.rfc" title="RFC 792 - Протокол ICMP">ICMP</a> [5].</p><h4>ICMP Message Type (типы сообщений)</h4><pre>AM1 = 17
AM2 = 18</pre><h2>Литература</h3><table itemprop="references"><tr><td>[1]</td><td>Jeffrey Mogul, <a href="../917.rfc" title="RFC 917 - Подсети Internet">«Подсети Internet», RFC 917</a>, Октябрь 1984.</td></tr><tr><td>[2]</td><td>Postel, J., «Multi-LAN Address Resolution», RFC 925, USC/Information Sciences Institute, October 1984.</td></tr><tr><td>[3]</td><td>J. Postel, <a href="../791.rfc" title="RFC 791 - Протокол IP (Internet Protocol)">«Протокол IP (Internet Protocol)», RFC 791</a>, Сентябрь 1981.</td></tr><tr><td>[4]</td><td>Finlayson, Mann, Mogul, и Theimer, <a href="../903.rfc" title="RFC 903 - Протокол RARP">«Протокол RARP», RFC 903</a>, Июнь 1984.</td></tr><tr><td>[5]</td><td>J. Postel, <a href="../792.rfc" title="RFC 792 - Протокол ICMP">«Протокол ICMP», RFC 792</a>, Сентябрь 1981.</td></tr><tr><td>[6]</td><td>Jeffrey Mogul, <a href="../919.rfc" title="RFC 919 - Широковещательная рассылка дейтаграмм IP">«Широковещательная рассылка дейтаграмм IP», RFC 919</a>, Октябрь 1984.</td></tr><tr><td>[7]</td><td>GADS, «Towards an Internet Standard Scheme for Subnetting», RFC 940, Network Information Center, SRI International, Апрель 1985.</td></tr><tr><td>[8]</td><td>Croft, B., and J. Gilmore, «BOOTP — UDP Bootstrap Protocol», RFC 951, Stanford University, Август 1985.</td></tr><tr><td>[9]</td><td>Reynolds, J., and J. Postel, «Assigned Numbers», RFC 943, USC/Information Sciences Institute, Апрель 1985.</td></tr></table></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 950 - Стандартные процедуры организации подсетей IP",disqus_identifier="950.rfc",disqus_url="http://rfc2.ru/950.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>