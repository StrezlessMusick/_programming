<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../2246.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 2246 — Протокол TLS 1.0</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../2246.rfc">RFC 2246 — Протокол TLS 1.0</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 2246</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank"><span itemprop="alternativeHeadline">The TLS Protocol Version 1.0</span></a></dd><dd><div class="icon i7"></div> Другие версии: <strong class="obsoleted_by">RFC 4346</strong></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Предложенный стандарт</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1999-01-02">Январь 1999</time></dd><dd><div class="icon i5"></div> Авторы: <span itemprop="author">Christopher Allen</span>, <span itemprop="author">Tim Dierks</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Семенов Юрий Алексеевич</span></dd></dl><div id="text" itemprop="articleBody"><h3>Статус документа</h3><p>Это документ содержит проект стандарта протокола Internet для Internet-сообщества и служит приглашением к дискуссии в целях развития и совершенствования протокола. Текущее состояние стандартизации и статус протокола можно узнать из текущей версии документа «Internet Official Protocol Standards» (STD 1). Допускается свободное распространение документа.</p><h2>Оглавление</h2><ul class="map"><li><a href="print#p1" title="Введение">1. Введение</a></li><li><a href="print#p2" title="Цели">2. Цели</a></li><li><a href="print#p3" title="Цели данного документа">3. Цели данного документа</a></li><li><a href="print#p4" title="Язык представления">4. Язык представления</a></li><li><a href="print#p5" title="HMAC и псевдослучайные функции">5. HMAC и псевдослучайные функции</a></li><li><a href="print#p6" title="Протокол записей TLS">6. Протокол записей TLS</a></li><li><a href="print#p7" title="Протокол диалога TLS">7. Протокол диалога TLS</a></li><li><a href="print#p8" title="Криптографические вычисления">8. Криптографические вычисления</a></li><li><a href="print#p9" title="Mandatory Cipher Suites">9. Mandatory Cipher Suites</a></li><li><a href="print#p10" title="Application data protocol">10. Application data protocol</a></li><li><a href="print#p.appendix.a" title="Значения протокольных констант">A. Значения протокольных констант</a></li><li><a href="print#p.appendix.b" title="Термины">B. Термины</a></li><li><a href="print#p.appendix.c" title="Определения CipherSuite">C. Определения CipherSuite</a></li><li><a href="print#p.appendix.d" title="Замечания о реализации">D. Замечания о реализации</a></li><li><a href="print#p.appendix.e" title="Совместимость с SSL">E. Совместимость с SSL</a></li><li><a href="print#p.appendix.f" title="Анализ безопасности">F. Анализ безопасности</a></li><li><a href="print#p.appendix.g" title="Патентное заявление">G. Патентное заявление</a></li></ul><h2 id="p1">1. Введение</h2><p>Первоначальной целью протокола TLS (Transport Layer Security) является обеспечение конфиденциальности и целостности данных при коммуникации двух приложений. Протокол имеет два уровня: протокол записей TLS и протокол диалога TLS. На нижнем уровне, работающем поверх надежного транспортного протокола (напр., TCP [<a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC793</a>]), размещается протокол записей TLS. Протокол TLS разработан IETF и является открытым для использования (нет лицензионных ограничений, и по этой причине предпочтительнее SSL 3.0, хотя по функциональности они очень близки, но не совместимы). Этот протокол обеспечивает безопасность соединений, которые имеют два основных свойства:</p><ul class="dot"><li><p>Соединение является конфиденциальным. Для шифрования данных используется симметричная криптография (напр., DES [DES], RC4 [RC4], и т.д.). Ключи для шифрования генерируются независимо для каждого соединения и базируются на секретном коде, получаемом с помощью другого протокола (такого как протокол диалога TLS). Протокол записей может использоваться и без шифрования.</p></li><li><p>Соединение является надежным. Процедура передачи сообщения включает в себя проверку целостности с помощью вычисления MAC. Для расчета MAC используются хэш-функции (напр., SHA, MD5 и т.д.). Протокол записей может работать и без MAC, но в этом режиме он применяется только в случае, когда другой протокол использует протокол записей в качестве транспортного при выяснении параметров безопасности.</p></li></ul><p>Протокол записей TLS используется для инкапсуляции различных протоколов высокого уровня. Один из таких инкапсулируемых объектов, протокол диалога TLS, позволяет серверу и клиенту аутентифицировать друг друга и согласовать алгоритм шифрования и крипто-ключи до того как приложение передаст или примет первый байт информации. Протокол диалога TLS обеспечивает безопасное соединение, которое имеет три базовых свойства:</p><ul class="dot"><li><p>Идентичность партнеров может быть выяснена с использованием асимметричной криптографии (напр., RSA [RSA], DSS [DSS] и т.д.). Эта аутентификация может быть сделана опционной, но она необходима, по крайней мере, для одного из партнеров.</p></li><li><p>Выявление общего секретного кода является безопасным: этот секретный код недоступен злоумышленнику, даже если он ухитрится подключиться к соединению.</p></li><li><p>Диалог надежен: атакующий не может модифицировать обсуждаемое соединение, без того чтобы быть обнаруженным партнерами обмена.</p></li><li><p>Одним из преимуществ TLS является то, что он не зависит от протокола приложения. Протоколы верхнего уровня могут размещаться поверх протокола TLS прозрачным образом. Стандарт TLS, однако, не специфицирует то, как протоколы увеличивают безопасность с помощью TLS; решение о том, как инициализировать TLS-диалог и как интерпретировать сертификаты аутентификации, оставляется на усмотрение разработчиков протоколов и программ, которые работают поверх TLS.</p></li></ul><h2 id="p2">2. Цели</h2><p>Целями протокола TLS в порядке приоритетности являются:</p><ol><li><p>Криптографическая безопасность. TLS должен использоваться для установления безопасного соединения между двумя партнерами.</p></li><li><p>Совместимость. Независимые программисты должны быть способны разрабатывать приложения, использующие TLS, которые будут способны успешно обмениваться криптографическими параметрами без знания особенностей программ друг друга.</p></li><li><p>Расширяемость. TLS ищет способ, как при необходимости встроить в систему новые ключи и методы шифрования. Здесь имеются две побочные цели: исключить необходимость создания нового протокола (что может быть сопряжено с введением новых слабых мест) и сделать ненужным внедрение новой библиотеки, обеспечивающей безопасность.</p></li><li><p>Относительная эффективность. Криптографические операции требуют больших мощностей ЦПУ, особенно этим славятся операции с открытыми ключами. По этой причине, протокол TLS имеет опционную схему кэширования сессии, что позволяет уменьшить число соединений, устанавливаемых с использованием новых временных буферов. Были приняты меры, чтобы уменьшить сетевую активность.</p></li></ol><h2 id="p3">3. Цели данного документа</h2><p>Этот документ и сам протокол TLS базируются на спецификации протокола SSL 3.0, опубликованного Netscape. Различие между этим протоколом и SSL 3.0 не значительны, но они вполне достаточны, чтобы сделать TLS 1.0 и SSL 3.0 не совместимыми (хотя TLS 1.0 имеет механизм, с помощью которого приложения могут поддерживать SSL 3.0). Этот документ предназначен, прежде всего, для читателей, которые будут создавать протокольные приложения, и осуществлять их криптографический анализ. Спецификация была написана именно с такими намерениями и именно для этих двух групп разработчиков. Для этой цели многие правила и структуры данных, зависимые от алгоритма, включены в текст (а не в приложение), обеспечивая более легкий к ним доступ.</p><h2 id="p4">4. Язык представления</h2><p>Представление данных в этом документе напоминает синтаксис языка Си и XDR [RFC1832], но эти параллели достаточно приблизительны и не имеют никакого отношения к самому протоколу TSL. эти представления применены лишь для целей упрощения восприятия материала.</p><h3>4.1. Базовый размер блока</h3><p>Базовым блоком данных считается один байт (т.e. 8 бит). Многобайтовые информационные элементы представляют собой объединение последовательности байтов слева направо и сверху вниз. Многобайтовые элементы извлекаются из байтового потока (используя нотацию Си) следующим образом:</p><pre>value = (byte[0] &lt;&lt; 8*(n-1)) | (byte[1] &lt;&lt; 8*(n-2)) |
        ... | byte[n-1];</pre><p>Этот порядок байтов для многобайтовых последовательностей является стандартным для сетей (big endian).</p><h3>4.2. Разное</h3><p>Комментарии начинаются с "/*" и завершаются "*/". Опционные компоненты выделяются с помощью помещения их в двойные квадратные скобки "[[ ]]". Однобайтовые объекты, содержащие не интерпретируемые данные, имеют 'непрозрачный' тип (opaque).</p><h3>4.3. Векторы</h3><p>Вектор (одномерный массив) является потоком однородных информационных элементов. Размер вектора может быть специфицирован во время документирования или оставаться не специфицированным вплоть до начала работы. В любом случае длина определяет число байтов, а не число элементов в векторе. Синтаксис спецификации нового типа T', который является вектором фиксированной длины типа T, имеет вид</p><pre>T T'[n];</pre><p>Здесь T' занимает в информационном потоке n байт, где &lt;n кратно размеру T. Длина вектора не включается в кодированный поток.</p><p>В следующем примере Datum определен, как три последовательные байта, которые не интерпретируются протоколом, в то время как Data представляет собой три вектора Datum, состоящие из девяти байт.</p><pre>opaque Datum[3];      /* три не интерпретируемые байта */
Datum Data[9];        /* 3 последовательных 3-байтовых вектора */</pre><p>Векторы переменной длины определяются путем спецификации субдиапазона легальных длин, используя нотацию &lt;floor..ceiling&gt;. При кодировании реальная длина предшествует потоку байтов, образующих вектор. Длина имеет форму числа, занимающего столько байт, сколько нужно, чтобы специфицировать максимально возможную длину вектора (ceiling). Вектор переменной длины с действительным полем длины равным нулю является пустым вектором.</p><pre>T T'&lt;floor..ceiling&gt;;</pre><p>В следующем примере, обязательным является вектор, который должен содержать от 300 до 400 байт непрозрачного типа. Он не должен быть пустым. Поле действительной длины занимает два байта, uint16, достаточных, чтобы представить значение 400 (смотри раздел 4.4). С другой стороны, longer может представить до 800 байт данных, или 400 uint16 элементов, и может быть пустым. Его кодовое представление будет включать два байта поля реальной длины, за которым будет следовать вектор. Длина закодированного вектора должна быть четной, кратной длине одиночного элемента (например: 17-байтовый вектор uint16 будет нелегальным).</p><pre>opaque mandatory&lt;300..400&gt;;
      /* поле длины имеет 2 байта, не может быть пустым */
uint16 longer&lt;0..800&gt;;
      /* 0 - 400 16-битовое целое число без знака */</pre><h3>4.4. Числа</h3><p>Базовый числовой тип данных представляет собой байт без знака (uint8). Все более длинные типы цифровых данных образуются из фиксированной последовательности байт без знака, объединенных вместе, как это описано в разделе 4.1,. Следующие числовые типы являются предопределенными.</p><pre>uint8 uint16[2];
uint8 uint24[3];
uint8 uint32[4];
uint8 uint64[8];</pre><p>Все значения здесь и в дальнейшем записываются в 'сетевом порядке' (big-endian); uint32 представленное шестнадцатеричными байтами 01 02 03 04 эквивалентно десятичному значению 16909060.</p><h3>4.5. Нумерованный тип</h3><p>Еще одним типом данных является enum (enumerated). Поле типа enum предполагает, что величина декларирована при определении. Каждое определение дает новый тип. Только нумерованные элементы того же типа могут присваиваться и сравниваться. Каждому нумерованному элементу должно быть присвоено значение, как это показано в следующем примере. Так как нумерованные элементы неупорядочены, им может быть присвоено любое уникальное значение в любом порядке.</p><pre>enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;</pre><p>Нумерованные элементы занимают в байтовом потоке столько места, сколько требует максимальное определенное порядковое значение. Следующее определение требует использования одного байта для поля типа Color (цвет).</p><pre>enum { red(3), blue(5), white(7) } Color;</pre><p>Можно опционно специфицировать значение без ассоциированной с ним метки, чтобы задать ширину без определения избыточного элемента. В следующем примере, Taste в потоке данных занимает два байта, но может предполагать значения 1, 2 или 4.</p><pre>enum { sweet(1), sour(2), bitter(4), (32000) } Taste;</pre><p>Имена элементов нумерации собраны в пределах определенного типа. В первом примере, полная ссылка на второй элемент будет выглядеть как Color.blue. Такое описание не требуется, если объект присвоения (target) хорошо специфицирован.</p><pre>Color color = Color.blue;     /* чрезмерная спецификация, допустимо */
Color color = blue;           /* правильно, тип задан неявно */</pre><p>Для нумерованных элементов, которые не преобразуются во внешнее представление, цифровая информация может быть опущена.</p><pre>enum { low, medium, high } Amount;</pre><h3>4.6. Сконструированные типы</h3><p>Типы структуры могут быть сформированы для удобства из примитивных типов. Каждая спецификация декларирует новый, уникальный тип. Синтаксис определения весьма похож на используемый в Си.</p><pre>struct {
  T1 f1;
  T2 f2;
  ...
  Tn fn;
} [[T]];</pre><p>Поля в структуре могут быть квалифицированы, используя имена типов, которые синтаксис подобный нумерованным элементам. Например, T.f2 относится ко второму полю предыдущей декларации. Структурные определения допускают вложения.</p><h4>4.6.1. Варианты</h4><p>Определенные структуры могут иметь варианты, базирующиеся на некотором знании того, что доступно в среде. Селектор должен иметь тип нумерованного элемента, который определяет возможные варианты структуры. Телу структуры варианта может быть присвоена метка для ссылок. Механизм, с помощью которого при работе выбирается вариант, языком презентации не определен.</p><pre>struct {
    T1 f1;
    T2 f2;
    ....
    Tn fn;
    select (E) {
        case e1: Te1;
        case e2: Te2;
        ....
        case en: Ten;
    } [[fv]];
} [[Tv]];</pre><p>Например:</p><pre>enum { apple, orange } VariantTag;
struct {
    uint16 number;
    opaque string&lt;0..10&gt;; /* переменная длина */
} V1;
struct {
    uint32 number;
    opaque string[10];    /* фиксированная длина */
} V2;
struct {
    select (VariantTag) { /* value of selector is implicit */
        case apple: V1;   /* VariantBody, tag = apple */
        case orange: V2;  /* VariantBody, tag = orange */
    } variant_body;       /* optional label on variant */
} VariantRecord;</pre><p>Структуры варианта могут быть подготовлены (сужены) путем спецификации значения селектора до спецификации типа. Например:</p><pre>orange VariantRecord</pre><p>является суженным типом для VariantRecord, содержащего variant_body типа V2.</p><h3>4.7. Криптографические атрибуты</h3><p>В TSL используются четыре криптографические операции: цифровая подпись, блочное и поточное шифрование и шифрование с помощью общедоступного ключа. Криптографические ключи соответствуют состоянию текущей сессии (смотри раздел 6.1).</p><p>Алгоритм цифровой подписи включает в себя однопроходные хэш-функции, служащие для преобразования подписываемого текста. Элемент с цифровой подписью кодируется как непрозрачный вектор &lt;0..2^16-1&gt;, где длина специфицируется алгоритмом подписи и ключом.</p><p>В подписи RSA, 36-байтовая структура двух хэшей (один SHA и один MD5) кодируется с помощью секретного ключа. Описание кодировки смотри в [PKCS1].</p><p>В DSS, 20 байтов хэша SHA передаются непосредственно алгоритму цифровой подписи DSA (Digital Signing Algorithm) без дополнительного хэширования. В результате получаются числа r и s. Подпись DSS представляет собой непрозрачный вектор, содержимое которого представляет собой результат DER-кодирования:</p><pre>Dss-Sig-Value  ::=  SEQUENCE  {
     r       INTEGER,
     s       INTEGER
}</pre><p>При поточном шифровании, исходный текст сначала объединяется с псевдослучайным кодом идентичной длины (формируется специальным генератором) с помощью операции исключающее ИЛИ.</p><p>При использовании блочного шифра, каждый блок исходного текста преобразуется в зашифрованный кодовый блок той же длины. Все блочные шифрования выполняются в режиме CBC (Cipher Block Chaining), и все зашифрованные блочные элементы будут иметь размер, кратный длине шифрового блока.</p><p>При шифровании с использованием общедоступного ключа, алгоритм открытого ключа используется для шифрования данных так, чтобы их можно было дешифровать только с помощью секретного ключа, который образует пару с открытым ключом. Элемент, зашифрованный с помощью открытого ключа, выглядит как непрозрачный вектор &lt;0..2^16-1&gt;, где длина определяется алгоритмом подписи и ключом.</p><p>В следующем примере:</p><pre>stream-ciphered struct {
    uint8 field1;
    uint8 field2;
    digitally-signed opaque hash[20];
} UserType;</pre><p>Содержимое хэша передается алгоритму подписи, затем вся структура шифруется с привлечением поточного шифра. Длина этой структуры в байтах будет равна 2 байтам для поля field1 и field2, плюс два байта для длины подписи, плюс длина выходных данных алгоритма подписи. Это известно благодаря тому факту, что алгоритм и ключ для подписи известны до кодирования или декодирования этой структуры.</p><h3>4.8. Константы</h3><p>Типофицированные константы могут быть определены для целей спецификации путем декларации символа нужного типа и присвоения ему определенных значений. Не полностью специфицированные типы (непрозрачные элементы, векторы переменной длины, и структуры, которые содержат непрозрачные элементы) не могут стать объектами присвоения. Нельзя опускать ни одно поле многоэлементной структуры или вектора.</p><p>Например,</p><pre>struct {
    uint8 f1;
    uint8 f2;
} Example1;

Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */</pre><h2 id="p5">5. HMAC и псевдослучайные функции</h2><p>Ряд операций на уровне записей и диалога требуют ключевого MAC; это дайджест определенных данных, защищенных секретным кодом. Фальсификация MAC невозможна без знания секретного кода. Конструкция, которая используется для этой операции, имеет название HMAC и описана в [RFC2104].</p><p>HMAC может использоваться с разными хэш-алгоритмами. TLS использует ее при диалоге с другими алгоритмами: MD5 и SHA-1, обозначая их как HMAC_MD5(secret, data) и HMAC_SHA(secret, data). Для других шифровых наборов и защищенных данных могут быть определены дополнительные хэш-алгоритмы, но в данной версии протокола для целей диалога жестко заданы MD5 и SHA-1.</p><p>Кроме того, необходима схема расширения применения секретных кодов (secret) на блоки данных с целью генерации ключей и валидации. Такая псевдослучайная функция (PRF) использует в качестве входной информации секретный код, порождающий код (seed) и идентификационную метку (label). При этом формируется выходной массив произвольной длины.</p><p>Для того чтобы сделать PRF максимально секретной, она использует два хэш-алгоритма так, чтобы гарантировать секретность при сохранении работоспособности хотя бы одного из них.</p><p>Сначала, определена функция разложения данных, P_hash(secret, data), которая использует одну хэш функция для распространения секретного кода на произвольное число выходов:</p><pre>P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
                       HMAC_hash(secret, A(2) + seed) +
                       HMAC_hash(secret, A(3) + seed) + ...</pre><p>где + обозначает объединение.</p><p>A() определено как:</p><pre>A(0) = seed
A(i) = HMAC_hash(secret, A(i-1))</pre><p>Для требуемого качества данных P_hash может итерироваться столько раз, сколько нужно. Например: если P_SHA-1 использовался для формирования 64 байт данных, его следует итерировать четыре раза (до A(4)), создавая 80 байт выходных данных; последние 16 байт последней итерации будут отброшены, оставляя 64 байта.</p><p>PRF TLS создана путем расщепления секретного кода на две части и использования одной половины для генерации данных с помощью P_MD5, а другой половины — для формирования данных посредством P_SHA-1, выходные данных этих двух процедур объединяются затем с помощью операции исключающего ИЛИ.</p><p>S1 и S2 являются двумя равными по длине половинами секретного кода. Их длина определяется путем округления результата деления исходного секретного кода на два. Таким образом, если исходный секретный код имеет длину в байтах, характеризуемую нечетным числом, то последний байт S1 будет тем же, что и первый байт S2.</p><pre>L_S = length in bytes of secret;
L_S1 = L_S2 = ceil(L_S / 2);</pre><p>PRF определяется как результат смешения двух псевдослучайных потоков с помощью операции исключающее ИЛИ.</p><pre>PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR
                           P_SHA-1(S2, label + seed);</pre><p>Метка представляет собой ASCII-строку. Она должна быть включена в исходном виде без байта длины или завершающего нуля. Например: метка «slithy toves» будет представлена в виде:</p><pre>73 6C 69 74 68 79 20 74 6F 76 65 73</pre><p>Заметим, что, так как MD5 выдает на выход 16 байт, а SHA-1 — 20 байт, границы их внутренних итераций не будут выровнены; чтобы сформировать на выходе 80 байт P_MD5 осуществит итерации до A(5), в то время как P_SHA-1 — до A(4).</p><h2 id="p6">6. Протокол записей TLS</h2><p>Протокол записей TLS является послойным. На каждом уровне, сообщения могут включать поля длины, описания и содержимого. Протокол записей берет сообщения, подлежащие пересылке, разбивает их на блоки, опционно сжимает данные, применяет MAC, шифрует и передает результат. Полученные данные дешифруются, верифицируются, декомпрессируются, восстанавливается их первоначальный вид, результат передается клиентам верхнего уровня.</p><p>Четыре протокола описаны в данном документе: протокол диалога, протокол уведомления, протокол спецификации изменения шифра, и прикладной информационный протокол. Для того чтобы позволить расширение протокола TLS, разрешена поддержка протоколом дополнительных типов записей. Любые новые типы записей должны размещать значения типа немедленно за величинами ContentType четырех типов, описанных здесь (смотри Приложение A.2). Если реализация TLS получает рекорд нераспознаваемого типа, она должна его игнорировать. Любой протокол, предназначенный для использования поверх TLS, должен быть тщательно сконфигурирован, для того чтобы противостоять любым атакам. Заметим, что из-за того, что тип и длина записи не защищены шифрованием, следует принимать меры, чтобы минимизировать трафик анализа этих величин.</p><h3>6.1. Состояния соединений</h3><p>Состояние соединения TLS является операционной средой протокола записей TLS. Оно специфицирует алгоритмы сжатия, шифрования и MAC. Кроме того, известны параметры этих алгоритмов: секретный код MAC, а также ключи шифрования и IV соединения для направлений чтения и записи. Логически существует четыре состояния соединения: текущие состояния чтения и записи, и отложенные состояния чтения и записи. Все записи обрабатываются в текущих состояниях чтения или записи. Параметры безопасности для отложенных состояний могут быть установлены протоколом диалога TLS. Протокол диалога может селективно переводить любое отложенное состояние в текущее, при этом соответствующее текущее состояние становится отложенным. Не допускается формировать состояние, которое не инициализировано с учетом параметров безопасности текущего состояния. Исходное текущее состояние всегда специфицировано без компрессии, шифрования или MAC. Параметры безопасности для состояния чтения и записи соединения TLS задаются путем определения следующих величин:</p><table><tr><td class="b">Конец соединения</td><td class="b">Клиент или сервер участник соединения</td></tr><tr><td>Алгоритм массового шифрования</td><td>Алгоритм, используемый для массового шифрования. Эта спецификация включает размер ключа алгоритма, степень секретности ключа, является ли этот шифр блочным или поточным, размер блока и является ли шифр экспортным.</td></tr><tr><td>Алгоритм MAC</td><td>Алгоритм аутентификации сообщений. Эта спецификация включает размер хэша, который возвращается алгоритмом MAC.</td></tr><tr><td>Алгоритм сжатия</td><td>Алгоритм сжатия данных. Эта спецификация должна включать всю информацию, необходимую для выполнения компрессии.</td></tr><tr><td>Секретный код сервера (master secret)</td><td>48 байтовый секретный код, общий для обоих партеров в соединении.</td></tr><tr><td>Случайный код клиента</td><td>32 байтный код, предоставляемый клиентом.</td></tr><tr><td>Случайный код сервера</td><td>32 байтный код, предоставляемый сервером.</td></tr></table><p>Эти параметры определены в языке представления в виде:</p><pre>enum { server, client } ConnectionEnd;

enum { null, rc4, rc2, des, 3des, des40 } BulkCipherAlgorithm;

enum { stream, block } CipherType;

enum { true, false } IsExportable;

enum { null, md5, sha } MACAlgorithm;

enum { null(0), (255) } CompressionMethod;

/* Алгоритмы, специфицированные в CompressionMethod,
   BulkCipherAlgorithm и MACAlgorithm могут быть добавлены. */

struct {
    ConnectionEnd          entity;
    BulkCipherAlgorithm    bulk_cipher_algorithm;
    CipherType             cipher_type;
    uint8                  key_size;
    uint8                  key_material_length;
    IsExportable           is_exportable;
    MACAlgorithm           mac_algorithm;
    uint8                  hash_size;
    CompressionMethod      compression_algorithm;
    opaque                 master_secret[48];
    opaque                 client_random[32];
    opaque                 server_random[32];
} SecurityParameters;</pre><p>Уровень записей будет использовать параметры безопасности для формирования следующих шести объектов:</p><ul><li>Секретный код MAC записи клиента</li><li>Секретный код MAC записи сервера</li><li>Ключ записи клиента</li><li>Ключ записи сервера</li><li>IV записи клиента (только для блочного шифра)</li><li>IV записи сервера (только для блочного шифра)</li></ul><p>Параметры записи клиента используются сервером при получении и обработке записей и наоборот. Алгоритм, использованный для генерирования этих объектов с помощью параметров безопасности, описан в разделе 6.3. Раз параметры безопасности определены и ключи сформированы, состояния соединения могут быть в любой момент реализованы путем перевода их в текущее состояние. Эти текущие состояния должны актуализоваться после обработки каждой записи. Каждое состояние соединения включает в себя следующие элементы:</p><ul><li class="b">Состояние сжатия</li><li class="lib">Текущее состояние алгоритма сжатия.</li><li class="b">Состояние шифра</li><li class="lib">Текущее состояние алгоритма шифрования. Оно состоит из текущего ключа для данного соединения. Кроме того, для блочного шифра, работающего в режиме CBC (единственный режим, специфицированный в TLS), оно в исходный момент содержит IV для данного состояния соединения и должно актуализоваться, чтобы содержать текст последнего шифрованного или дешифрованного блока. Для поточных шифров, оно содержит всю необходимую информацию для продолжения шифрования или дешифрования данных.</li><li class="b">Секретный код MAC</li><li class="lib">Секретный код MAC для данного соединения.</li><li class="b">Номер по порядку</li><li class="lib">Каждое состояние соединения содержит номер по порядку, который поддерживается независимо для состояний чтения и записи. Номер по порядку должен быть установлен равным нулю, как только соединение переведено в активное состояние. Номера по порядку имеют тип uint64 и не может превышать 2^64-1. Номер по порядку инкрементируется после прихода каждой записи: в частности, первая запись, передаваемая через некоторое соединение, имеет порядковый номер 0.</li></ul><h3>6.2. Уровень записей</h3><p>Уровень записей TLS получает не интерпретированные данные от верхних уровней в непустых блоках произвольного размера.</p><h4>6.2.1. Фрагментация</h4><p>Уровень записей фрагментирует информационные блоки и превращают их в записи TLSPlaintext, несущие данные в виде последовательностей длиной 2^14 байтов или меньше. Границы сообщения клиента на уровне записей не сохраняются (т.e., несколько сообщений клиента одного и того же ContentType могут быть объединены в одну запись TLSPlaintext, или одно сообщение может быть фрагментировано).</p><pre>struct {
    uint8 major, minor;
} ProtocolVersion;

enum {
    change_cipher_spec(20), alert(21), handshake(22),
    application_data(23), (255)
} ContentType;

struct {
    ContentType type;
    ProtocolVersion version;
    uint16 length;
    opaque fragment[TLSPlaintext.length];
} TLSPlaintext;</pre><ul><li class="b">type</li><li class="lib">Протокол верхнего уровня, использованный для обработки вложенного фрагмента.</li><li class="b">version</li><li class="lib">Версия примененного протокола. В данном документе описывается TLS версии 1.0, который использует версию { 3, 1 }. Значение версии 3.1 является исторической: TLS версии 1.0 является минимальной модификацией протокола SSL 3.0, который несет значение версии 3.0. (Смотри приложение A.1).</li><li class="b">length</li><li class="lib">Длина (в байтах) следующего TLSPlaintext.fragment. Длина не должна превосходить 2^14.</li><li class="b">Fragment</li><li class="lib">Прикладные данные. Эти данные прозрачны и обрабатываются как независимые блоки, с которыми должен работать протокол верхнего уровня, который специфицирован полем тип.</li></ul><p>Данные различных типов содержимого уровня записей TLS могут перекрываться. Прикладные данные вообще имеют более низкий приоритет при передаче, чем другие типы содержимого.</p><h4>6.2.2. Сжатие и восстановление записи</h4><p>Все записи сжаты с использованием алгоритма сжатия, определенным состоянием текущей сессии. Всегда имеется активный алгоритм сжатия; однако в исходный момент он определен как CompressionMethod.null. Алгоритм сжатия преобразует структуру TLSPlaintext в структуру TLSCompressed. Функции сжатия инициализируются информацией по умолчанию при переходе соединения в активное состояние.</p><p>Должно использоваться сжатие без потерь, а длина содержимого не может стать больше чем 1024 байт. Если функция восстановления встречает фрагмент TLSCompressed.fragment, длина которого окажется больше 2^14 байт, она должна выдать уведомление о фатальной ошибке преобразования.</p><pre>struct {
    ContentType type;       /* same as TLSPlaintext.type */
    ProtocolVersion version;/* same as TLSPlaintext.version */
    uint16 length;
    opaque fragment[TLSCompressed.length];
} TLSCompressed;</pre><ul><li class="b">length</li><li class="lib">Длина (в байтах) следующего TLSCompressed.fragment. Длина не должна превосходить 2^14 + 1024.</li><li class="b">Fragment</li><li class="lib">Сжатая форма TLSPlaintext.fragment.</li></ul><p>Операция CompressionMethod.null является идентификационной; ни одно из полей не изменено.</p><p>Функции декомпрессии (восстановления) отвечают за то, что внутренний буфер не будет переполнен при обработке сообщения.</p><h4>6.2.3. Защита поля данных записи</h4><p>Функции шифрования и MAC преобразуют структуру TLSCompressed в TLSCiphertext. Функции дешифрования выполняют обратную процедуру. MAC записи включает также номер по порядку, чтобы было можно детектировать лишние или повторные сообщения.</p><pre>
struct {
    ContentType type;
    ProtocolVersion version;
    uint16 length;
    select (CipherSpec.cipher_type) {
        case stream: GenericStreamCipher;
        case block: GenericBlockCipher;
    } fragment;
} TLSCiphertext;</pre><ul><li class="b">type</li><li class="lib">Поле тип идентично TLSCompressed.type.</li><li class="b">Version</li><li class="lib">Поле версия идентично TLSCompressed.version.</li><li class="b">length</li><li class="lib">Длина (в байтах) последующего TLSCiphertext.fragment. Длина не может превосходить 2^14 + 2048.</li><li class="b">Fragment</li><li class="lib">Зашифрованная форма TLSCompressed.fragment, с MAC.</li></ul><h5>6.2.3.1. Нуль или стандартный поточный шифр</h5><p>Поточные шифры (включая BulkCipherAlgorithm.null — смотри приложение A.6) преобразуют структуры TLSCompressed.fragment в (или из) структуры TLSCiphertext.fragment.</p><pre>stream-ciphered struct {
    opaque content[TLSCompressed.length];
    opaque MAC[CipherSpec.hash_size];
} GenericStreamCipher;</pre><p>MAC генерируется как:</p><pre>HMAC_hash(MAC_write_secret, seq_num + TLSCompressed.type +
              TLSCompressed.version + TLSCompressed.length +
              TLSCompressed.fragment));</pre><p>где "+" означает объединение (слияние).</p><ul><li class="b">seq_num</li><li class="lib">Номер по порядку для данной записи.</li><li class="b">hash</li><li class="lib">Алгоритм хэширования, специфицированный в SecurityParameters.mac_algorithm.</li></ul><p class="note">Заметим, что MAC вычисляется до шифрования. Поточный шифр преобразует весь блок, включая MAC. Для поточных шифров, которые не используют вектор синхронизации (такой как RC4), состояние шифра записи используется в последующих пакетах. Если CipherSuite равен TLS_NULL_WITH_NULL_NULL, шифрование представляет собой операцию идентичного преобразования (т.e., данные не шифруются, а размер MAC равен нулю, что говорит о том, что MAC не используется). TLSCiphertext.length равна TLSCompressed.length плюс CipherSpec.hash_size.</p><h5>6.2.3.2. Блочный шифр CBC</h5><p>Для блочных шифров (таких как RC2 или DES), функции шифрования и MAC преобразуют структуры TLSCompressed.fragment в блоки структур TLSCiphertext.fragment или обратно.</p><pre>block-ciphered struct {
    opaque content[TLSCompressed.length];
    opaque MAC[CipherSpec.hash_size];
    uint8 padding[GenericBlockCipher.padding_length];
    uint8 padding_length;
} GenericBlockCipher;</pre>

MAC генерируется, как это описано в разделе 6.2.3.1.<ul><li class="b">Padding</li><li class="lib">Заполнитель, который добавлен, чтобы сделать длину исходного текста целой кратной длине блока блочного шифра. Заполнитель может иметь длину вплоть до 255 байт. Длины больше необходимой могут оказаться желательными, для того чтобы блокировать атаки на протокол, базирующийся на анализе длин сообщений. Каждый uint8 в векторе заполняющих данных должен быть заполнен значением длины.</li><li class="b">padding_length</li><li class="lib">Длина заполнения должна быть такой, чтобы общий размер структуры GenericBlockCipher являлся кратным длине блока шифра. Диапазон легальных значений лежит в диапазоне 0-255, включительно. Эта длина специфицирует длину поля заполнителя, исключая само поле padding_length.</li></ul><p>Длина шифрованных данных (TLSCiphertext.length) на единицу больше чем сумма TLSCompressed.length, CipherSpec.hash_size и padding_length.</p><p class="note">Пример: Если длина блока равна 8 байт, длина содержимого (TLSCompressed.length) равна 61 байтов, а длина MAC равна 20 байтов, длина до заполнения составляет 82 байта. Таким образом, длина заполнения по модулю 8 должна быть равна 6, для того чтобы сделать полную длину четной, кратной 8 байтам (длина блока). Длина заполнения может быть 6, 14, 22 и т.д. до 254. Если бы длина заполнения была минимально необходимой (6), заполнитель имел бы 6 байтов, каждый из которых содержал число 6. Таким образом, последние 8 октетов GenericBlockCipher до блочного шифрования были бы xx 06 06 06 06 06 06 06, где xx последний октет MAC.</p><p>Для блочного шифра в режиме CBC (Cipher Block Chaining) вектор инициализации (IV) для первой записи генерируется с другими ключами и секретными кодами, когда параметры безопасности заданы. IV для последующих записей равен последнему блоку шифрованного текста предыдущей записи.</p><h3>6.3. Вычисление ключа</h3><p>Протокол записей требует алгоритма для генерации ключей, IV и секретных кодов MAC из параметров безопасности, поставляемых протоколом диалога.</p><p>Мастерный секретный код (master secret) хэшируется в последовательность байтов, которая присваивается секретным кодам MAC, ключам и IV, требуемых текущим состоянием соединения (смотри приложение A.6). CipherSpecs требует чтобы клиент записал секретный код MAC, чтобы сервер записал секретный код MAC, клиент и сервер записали ключ и IV, которые сформированы из мастерного секретного кода в указанном порядке. Не использованные значения остаются пустыми.</p><p>Для генерации ключей вычисляется</p><pre>key_block = PRF(SecurityParameters.master_secret,
                   "key expansion",
                   SecurityParameters.server_random +
                   SecurityParameters.client_random);</pre><p>до тех пор пока не будет сформирован выход. Затем key_block позиционируется следующим образом:</p><pre>client_write_MAC_secret[SecurityParameters.hash_size]
server_write_MAC_secret[SecurityParameters.hash_size]
client_write_key[SecurityParameters.key_material_length]
server_write_key[SecurityParameters.key_material_length]
client_write_IV[SecurityParameters.IV_size]
server_write_IV[SecurityParameters.IV_size]</pre><p>Значения client_write_IV и server_write_IV генерируются только для не экспортных блочных шифров. Для экспортируемых блочных шифров, векторы инициализации генерируются позже, как это описано ниже. Любой лишний материал key_block отбрасывается.</p><p class="note">Implementation note: Спецификация шифра, которая определена в данном документе, требует 2 x 24 байтовых ключей, 2 x 20 байтовых секретных кодов MAC, и 2 x 8 байтов IV, для 104 байтов материала ключей.</p><p>Алгоритмы экспортируемого шифрования (для которого CipherSpec.is_exportable равно 'истинно') требуют дополнительной обработки для получения ключей записи, как это показано ниже:</p><pre>final_client_write_key =
PRF(SecurityParameters.client_write_key,
                           "client write key",
                           SecurityParameters.client_random +
                           SecurityParameters.server_random);
final_server_write_key =
PRF(SecurityParameters.server_write_key,
                           "server write key",
                           SecurityParameters.client_random +
                           SecurityParameters.server_random);</pre><p>Алгоритмы экспортируемого шифрования получают свои IV исключительно из случайных кодов сообщений hello:</p><pre>iv_block = PRF("", "IV block", SecurityParameters.client_random +
               SecurityParameters.server_random);</pre><p>Блок iv_block делится на два инициализационных векторов, как это делалось выше для key_block:</p><pre>client_write_IV[SecurityParameters.IV_size]
server_write_IV[SecurityParameters.IV_size]</pre><p>Заметим, что PRF используется в этом случае без секретного кода: это означает, что секретный код имеет длину нуль байт и не вносит ничего в хэширование PRF.</p><h4>6.3.1. Пример генерации экспортного ключа</h4><p>TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 требует пяти случайных байт для каждого из двух ключей шифрования и 16 байт для каждого ключа MAC, что составляет 42 байта ключевого материала. Выход PRF запоминается в key_block. Блок key_block делится, а ключи записи запоминаются, так как это алгоритм экспортного шифрования.</p><pre>key_block               = PRF(master_secret,
                              "key expansion",
                              server_random +
                              client_random)[0..41]
client_write_MAC_secret = key_block[0..15]
server_write_MAC_secret = key_block[16..31]
client_write_key        = key_block[32..36]
server_write_key        = key_block[37..41]

final_client_write_key  = PRF(client_write_key,
                              "client write key",
                              client_random +
                              server_random)[0..15]
final_server_write_key  = PRF(server_write_key,
                              "server write key",
                              client_random +
                              server_random)[0..15]

iv_block                = PRF("", "IV block", client_random +
                              server_random)[0..15]
client_write_IV = iv_block[0..7]
server_write_IV = iv_block[8..15]</pre><h2 id="p7">7. Протокол диалога TLS</h2><p>Протокол диалога TLS содержит набор из трех суб-протоколов, которые используются, чтобы партнеры могли согласовать используемые параметры безопасности для уровня записи, аутентифицировать себя, и уведомлять друг друга об ошибках.</p><p>Протокол диалога ответственен за согласования характеристик сессии, куда входят следующие объекты:</p><ul><li class="b">идентификатор сессии</li><li class="lib">Произвольная последовательность байтов, выбранная сервером для идентификации состояния сессии (активная/ возобновляемая).</li><li class="b">сертификат партнера</li><li class="lib">X509v3 [X509] сертификат партнера. Этот элемент состояния может быть равен нулю.</li><li class="b">метод сжатия</li><li class="lib">Алгоритм, используемый для сжатия информации перед шифрованием.</li><li class="b">спецификация шифра</li><li class="lib">Специфицирует алгоритм массового шифрования (такой как нуль, DES, и т.д.) и алгоритм MAC (такой как MD5 или SHA). Она определяет также криптографические атрибуты, такие как hash_size. (Смотри приложение A.6)</li><li class="b">мастерный секретный код</li><li class="lib">48-байтовый секретный код, общий для сервера и клиента.</li><li class="b">'is resumable'</li><li class="lib">Флаг, указывающий, может ли сессия использоваться для инициализации нового соединения.</li></ul><p>Эти объекты используются затем для определения параметров безопасности для уровня записей при защите прикладных данных. Многие соединения могут реализоваться в рамках той же сессии с помощью процедуры возобновления (resumption) протокола диалога.</p><h3>7.1. Протокол изменения спецификации шифра</h3><p>Протокол изменения спецификации шифра предназначен для оповещения об изменении стратегии шифрования. Протокол использует одно сообщение, которое зашифровано и архивировано в рамках текущего состояния соединения. Сообщение состоит из одного байта со значением 1.</p><pre>struct {
    enum { change_cipher_spec(1), (255) } type;
} ChangeCipherSpec;</pre><p>Сообщение изменения спецификации шифра посылается как клиентом, так и сервером, для того чтобы уведомить партнера о том, что последующие записи будут защищены с помощью только что согласованных ключей и спецификации CipherSpec. Получение этого сообщения заставляет получателя на уровне записей немедленно скопировать состояние ожидания чтения в текущее состояние чтения. Сразу после посылки сообщения отправитель должен дать команду уровню записей преобразовать состояние ожидания записи в активное состояние записи. (Смотри раздел 6.1.) Сообщение изменения спецификации шифра посылается во время диалога после согласования набора параметров безопасности, но до посылки проверочного завершающего сообщения (смотри раздел 7.4.9).</p><h3>7.2. Протокол оповещения</h3><p>Одним из типов содержимого, поддерживаемого слоем записей TLS, является оповещение. Сообщения оповещения передают описание возникшей ситуации. Оповещения с аварийным уровнем вызывают немедленное прерывание соединения. В этом случае, другие соединения сессии могут оставаться в рабочем состоянии, но идентификатор сессии должен быть объявлен не действительным, блокируя установление новых соединений. Подобно другим сообщениям, оповещения шифруются и сжимаются, как это специфицировано состоянием текущего соединения.</p><pre>enum { warning(1), fatal(2), (255) } AlertLevel;

enum {
    close_notify(0),
    unexpected_message(10),
    bad_record_mac(20),
    decryption_failed(21),
    record_overflow(22),
    decompression_failure(30),
    handshake_failure(40),
    bad_certificate(42),
    unsupported_certificate(43),
    certificate_revoked(44),
    certificate_expired(45),
    certificate_unknown(46),
    illegal_parameter(47),
    unknown_ca(48),
    access_denied(49),
    decode_error(50),
    decrypt_error(51),
    export_restriction(60),
    protocol_version(70),
    insufficient_security(71),
    internal_error(80),
    user_canceled(90),
    no_renegotiation(100),
    (255)
} AlertDescription;

struct {
    AlertLevel level;
    AlertDescription description;
} Alert;</pre><h4>7.2.1. Оповещения закрытия</h4><p>Клиент и сервер должны оба знать, что соединение завершается, для того чтобы избежать атаки усечения (truncation). Оба партнера могут запустить обмен сообщениями закрытия.</p><ul><li class="b">close_notify</li><li class="lib">Это сообщение обращает внимание получателя, что отправитель не будет посылать более каких-либо данных через это соединение. Сессия становится не возобновляемой (unresumable), если любое соединение разорвано без соответствующих сообщений close_notify с уровнем равным предупреждению.</li></ul><p>Оба партнера могут инициализировать закрытие, послав уведомление close_notify. Любые данные, полученные после оповещения о закрытии, игнорируются.</p><p>Каждый из партнеров обязан послать уведомление close_notify, прежде чем разрывать соединение со стороны записи. Требуется, чтобы другой партнер реагировал своим уведомлением close_notify и закрывал соединение немедленно, аннулируя все не завершенные записи. Для инициатора закрытия не требуется ждать получения отклика close_notify, прежде чем закрыть соединение со стороны чтения. Если прикладной протокол, использующий TLS, гарантирует, что любые данные могут быть переданы через используемое TLS-соединение после его закрытия, реализация TLS должна получить уведомление-отклик close_notify до оповещения прикладного уровня о том, что соединение TLS завершает свою работу. Если прикладной протокол не передает никаких дополнительных данных, но лишь закрывает ниже лежащее транспортное соединение, тогда реализация может выбрать вариант закрытия транспорта, не дожидаясь отклика close_notify.</p><p>Предполагается, что закрытие соединения надежно доставляет все данные, ждущие передачи, прежде чем транспортная система будет блокирована.</p><h4>7.2.2. Оповещения об ошибках</h4><p>Обработка ошибок в протоколе диалога TLS очень проста. Когда обнаруживается ошибка, обнаруживший партнер посылает сообщение другому партнеру. При передаче или получении сообщения о фатальной ошибке, оба партнера немедленно закрывают соединение. Серверы и клиенты должны забыть любые идентификаторы сессии, ключи и секретные коды, связанные с неудачным соединением. Определены следующие оповещения об ошибках:</p><ul><li class="b">unexpected_message</li><li class="lib">Получено не предусмотренное сообщение. Это оповещение является всегда фатальным и не должно встречаться при обменах между корректными реализациями.</li><li class="b">bad_record_mac</li><li class="lib">Это оповещение присылается, если получена запись с неверным MAC. Это сообщение всегда вызывает фатальную ошибку.</li><li class="b">decryption_failed</li><li class="lib">TLSCiphertext дешифрован не верно: либо текст не имел длину четную и кратную размеру блока или их значения (заполнители) при проверке оказались некорректными. Это сообщение всегда вызывает фатальную ошибку.</li><li class="b">record_overflow</li><li class="lib">Получена запись TLSCiphertext, которая имеет длину больше 2^14+2048 байт, запись дешифрована TLSCompressed в запись с более чем 2^14+1024 байтов. Это сообщение всегда вызывает фатальную ошибку.</li><li class="b">decompression_failure</li><li class="lib">Функция декомпрессии получила неприемлемые данные (напр., данные, которые после восстановления будут иметь слишком большой объем). Это сообщение вызывает фатальную ошибку.</li><li class="b">handshake_failure</li><li class="lib">Получение сообщения оповещения handshake_failure указывает, что отправитель не мог согласовать приемлемый набор параметров безопасности из числа предлагаемых опций. Это фатальная ошибка.</li><li class="b">bad_certificate</li><li class="lib">Сертификат был поврежден, содержал подписи, которые не прошли проверку и т.д..</li><li class="b">unsupported_certificate</li><li class="lib">Сертификат имел не поддерживаемый тип.</li><li class="b">certificate_revoked</li><li class="lib">Сертификат был отозван его подписантом.</li><li class="b">certificate_expired</li><li class="lib">Сертификат имеет исчерпанный срок годности или не пригоден по другой причине.</li><li class="b">certificate_unknown</li><li class="lib">Некоторая другая, не специфицированная причина при обработке сертификата, делающая его неприемлемым.</li><li class="b">illegal_parameter</li><li class="lib">Поле при диалоге оказалось вне диапазона допустимых значений или не согласуется с другими полями. Это фатальная ошибка..</li><li class="b">unknown_ca</li><li class="lib">Получена корректная сертификатная последовательность или ее часть, но сертификат не был воспринят из-за того, что CA-сертификат не может быть обнаружен или не согласуется с известным проверенным CA. Это сообщение всегда вызывает фатальную ошибку.</li><li class="b">access_denied</li><li class="lib">Получен правильный сертификат, но при проверке доступа отправитель решил не продолжать согласование. Это сообщение всегда вызывает фатальную ошибку.</li><li class="b">decode_error</li><li class="lib">Сообщение не может быть дешифровано из-за того, что некоторое поле выходит за пределы допустимого или сообщение имеет не верный размер. Это сообщение всегда вызывает фатальную ошибку.</li><li class="b">decrypt_error</li><li class="lib">Диалог криптографической операции не прошел, это может включать неудачу проверки подписи, обмена ключами или контроль завершающего сообщения.</li><li class="b">export_restriction</li><li class="lib">Согласование параметров вошло в противоречие с экспортными регламентациями. Например: попытка передать 1024 битов ephemeral RSA-ключа для метода диалога RSA_EXPORT. Это сообщение всегда вызывает фатальную ошибку.</li><li class="b">protocol_version</li><li class="lib">Протокольная версия клиента распознана, но не поддерживается. (Например: старые версии протокола могут отвергаться по соображениям безопасности). Это сообщение всегда вызывает фатальную ошибку.</li><li class="b">insufficient_security</li><li class="lib">Возвращается вместо handshake_failure, когда согласование не прошло в частности из-за того, что сервер требует более секретного шифра, чем может поддержать клиент. Это сообщение всегда вызывает фатальную ошибку.</li><li class="b">internal_error</li><li class="lib">Внутренняя ошибка, не связанная с партнером, или требования протокола не допускают продолжения процедуры (например, ошибка при выделении памяти). Это сообщение всегда вызывает фатальную ошибку.</li><li class="b">user_canceled</li><li class="lib">Этот диалог аннулирован по какой-то причине, не связанной с протокольной ошибкой. Если пользователь аннулирует операцию после завершения диалога, закрытие соединения путем посылки close_notify является более приемлемым. За этим оповещением должно следовать close_notify. Это сообщения является предупреждением.</li><li class="b">no_renegotiation</li><li class="lib">Посылается клиентом в ответ на запрос hello или сервером — в ответ на hello клиента после стартового диалога. Любое из этих сообщений должно, в норме, вызывать повторное согласование параметров. Когда это не приемлемо, получатель должен реагировать посылкой этого уведомления (alert). В этой точке отправитель исходного запроса может решить, следует ли сохранять соединение. Случаем, когда это приемлемо, может оказаться ситуация, когда сервер запускает процесс, чтобы удовлетворить запросу. Процесс может получить параметры безопасности (длину ключа, аутентификацию и т.д.) при запуске, и может быть, трудно сообщить об изменении этих параметров в этой точке процесса. Это сообщение всегда является предупреждением.</li></ul><p>Для всех ошибок, где уровень оповещения не специфицирован явно, отправитель может сам определить, является ли ошибка фатальной. Если получено оповещение с уровнем предупреждения, получатель может сам решить, воспринимать ли ее как фатальную. Однако все сообщения, которые переданы с фатальным уровнем, должны рассматриваться как фатальные.</p><h3>7.3. Обзор протокола диалога</h3><p>Криптографические параметры состояния сессии формируются протоколом диалога TLS, который работает поверх уровня записей TLS. Когда клиент и сервер TLS впервые начинают взаимодействие, они согласуют версию протокола, выбирают криптографические алгоритмы, опционно аутентифицируют друг друга и используют методику с общедоступным ключом для формирования общего секретного кода. Протокол диалога TLS включает в себя следующие шаги:</p><ul class="dot"><li><p>Обмен сообщениями hello, чтобы согласовать алгоритмы, обмен случайными кодами, и проверка перезапуска сессии.</p></li><li><p>Обмен необходимыми криптографическими параметрами, чтобы позволить клиенту и серверу согласовать предмастерные секретные коды.</p></li><li><p>Обмен сертификатами и криптографической информацией, чтобы позволить клиенту и серверу аутентифицировать друг друга.</p></li><li><p>Генерация мастерного секретного кода из предмастерного и обмен случайными кодами.</p></li><li><p>Предоставление параметров безопасности уровню записей.</p></li><li><p>Разрешение клиенту и серверу проверить, что их партнер вычислил те же самые параметры безопасности и что диалог прошел без вмешательства хакера.</p></li></ul><p>Заметим, что верхние слои не должны слишком полагаться на TLS, всегда согласуя самые безопасные из возможных соединений между партнерами: существует много способов, с помощью которых злоумышленник, включившийся в разрыв соединения, может попытаться заставить партнеров принять наименее безопасный метод связи из числа поддерживаемых ими. Протокол был устроен так, чтобы минимизировать этот риск, но, тем не менее, существуют некоторые возможности атак. Например, хакер может блокировать доступ к порту, через который обеспечивается безопасное обслуживание, или попытаться заставить партнеров установить не аутентифицированное соединение. Фундаментальным правилом является то, что верхние уровни должны знать, каковы требования безопасности и никогда не передавать данные по каналам, которые менее безопасны, чем это предписано этими требованиями. Протокол TLS является безопасным, здесь любой шифровой набор предлагает свой уровень безопасности. Если вы согласуете использование 3DES с 1024-битовым RSA-ключом при связи с ЭВМ, чей сертификат вы проверили, вы можете быть уверены в безопасности. Однако вы никогда не должны посылать данные по каналу, где используется 40-битовая шифрование, если только вы не уверены, что данные не стоят того, чтобы кто-то тратил силы на их дешифрование.</p><p>Эти цели достигаются протоколом диалога, который может быть суммирован следующим образом. Клиент посылает сообщение hello, на которое сервер должен также откликнуться сообщением hello, в противном случае возникает ситуация фатальной ошибки и соединение разрывается. Сообщения client hello и server hello используются для установления более безопасного взаимодействия клиента и сервера. Сообщения client hello server hello устанавливают следующие атрибуты: версия протокола, ID-сессии, шифровой набор и метод сжатия. Кроме того, партнеры генерируют и пересылают друг другу два случайных числа: ClientHello.random и ServerHello.random.</p><p>Реальный обмен ключами использует до четырех сообщений: сертификат сервера, ключевой обмен сервера, сертификат клиента и ключевой обмен клиента. Новые методы ключевого обмена могут быть созданы с помощью спецификации формата для этих сообщений, чтобы позволить клиенту и серверу согласовать использование общего секретного кода. Этот секретный код должен быть достаточно длинным. Современные методы ключевого обмена пересылают коды длиной от 48 до 128 байт.</p><p>Вслед за сообщениями hello, сервер, если он должен быть аутентифицирован, посылает свой сертификат. Кроме того, если необходимо, может быть послано сообщение ключевого обмена (например, если сервер не имеет сертификата, или если его сертификат служит только для подписи). Если сервер аутентифицирован, он может затребовать сертификат от клиента, если выбран соответствующий шифровой набор. После этого сервер пошлет сообщение hello done, указывающее, что фаза диалога hello завершена. Сервер ждет отклика клиента. Если сервер послал сообщение сертификатного запроса, клиент должен послать сообщение сертификата. Сообщение ключевого обмена клиента послано, и его содержимое зависит от алгоритма с общедоступным ключом, который выбрали клиент и сервер при обмене сообщениями hello.</p><p>В этой точке клиентом посылается сообщение об изменении спецификации шифра, и клиент копирует записанную шифровую спецификацию в текущую спецификацию. После этого клиент немедленно посылает сообщение finished для новых алгоритмов, ключей и секретных кодов. В качестве отклика сервер пошлет свое сообщение об изменении шифровой спецификации, перенесет записанную шифровую спецификацию в текущую, и пошлет свое сообщение finished с использованием новой шифровой спецификации. В этой точке диалог завершается, а клиент и сервер могут начать обмен прикладными данными (смотри блок-схему обмена ниже на рис.1).</p><pre>Client                                               Server

ClientHello                  --------&gt;
                                                ServerHello
                                               Certificate*
                                         ServerKeyExchange*
                                        CertificateRequest*
                             &lt;--------      ServerHelloDone
Certificate*
ClientKeyExchange
CertificateVerify*
[ChangeCipherSpec]
Finished                     --------&gt;
                                         [ChangeCipherSpec]
                             &lt;--------             Finished
Application Data             &lt;-------&gt;     Application Data

Рисунок 1: Обмен сообщениями в процессе диалога</pre><p>* отмечает опционные или зависящие от ситуации сообщения, которые посылаются не всегда.</p><p>Когда клиент и сервер решают возобновить предыдущую сессию или задублировать существующую сессию (вместо согласования новых параметров безопасности), следует обмен следующими сообщениями:</p><p>Клиент посылает ClientHello, используя ID-сессии, которая должна быть возобновлена. Сервер проверяет свой кэш сессий на соответствие. Если соответствие имеется, а сервер желает возобновить соединение со специфицированным состоянием сессии, он посылает ServerHello с тем же значением ID-сессии. В этой точке, как клиент, так и сервер должны послать сообщения об изменении шифровой спецификации, после чего перейти к завершающим сообщениям finished. Раз восстановление сессии завершилось, клиент и сервер могут начать обмен прикладными данными. Смотри диаграмму на рис.2. Если соответствия с ID-сессии не найдено, сервер генерирует новый ID сессии, а клиент TLS и сервер осуществляют полный диалог.</p><pre>Client                                                Server

ClientHello                   --------&gt;
                                                 ServerHello
                                          [ChangeCipherSpec]
                              &lt;--------             Finished
[ChangeCipherSpec]
Finished                      --------&gt;
Application Data              &lt;-------&gt;     Application Data

Рисунок 2: Обмен сообщениями для упрощенного диалога</pre><h3>7.4. Протокол диалога</h3><p>Протокол диалога TLS представляет собой один из фиксированных клиентов высокого уровня протокола записей TLS. Этот протокол используется для согласования атрибутов безопасности сессии. Сообщения диалога передаются уровню записей TLS, где они инкапсулируются в одну или более структур TLSPlaintext, которые обрабатываются и передаются так, как это специфицировано текущим состоянием активной сессии.</p><pre>enum {
    hello_request(0), client_hello(1), server_hello(2),
    certificate(11), server_key_exchange (12),
    certificate_request(13), server_hello_done(14),
    certificate_verify(15), client_key_exchange(16),
    finished(20), (255)
} HandshakeType;

struct {
    HandshakeType msg_type;    /* handshake type */
    uint24 length;             /* bytes in message */
    select (HandshakeType) {
        case hello_request:       HelloRequest;
        case client_hello:        ClientHello;
        case server_hello:        ServerHello;
        case certificate:         Certificate;
        case server_key_exchange: ServerKeyExchange;
        case certificate_request: CertificateRequest;
        case server_hello_done:   ServerHelloDone;
        case certificate_verify:  CertificateVerify;
        case client_key_exchange: ClientKeyExchange;
        case finished:            Finished;
    } body;
} Handshake;</pre><p>Сообщения протокола диалога представлены ниже в порядке, в котором они должны быть посланы. Посылка сообщений диалога в неправильном порядке приведет к фатальной ошибке. Ненужные сообщения диалога могут быть опущены. Обратите внимание на одно исключение: сообщение сертификата используется в диалоге дважды (от клиента к серверу, а затем от сервера к клиенту), но оно описано лишь для первого случая его использования. Одно сообщение не привязано к этим правилам порядка обмена, это сообщение запроса Hello, которое может быть послано в любое время, но которое должно игнорироваться клиентом, если приходит в середине диалога.</p><h4>7.4.1. Сообщения Hello</h4><p>Сообщения фазы hello используются для выяснения возможностей клиента и сервера по повышению безопасности информационного обмена. Когда начинается новая сессия, состояние шифрования уровня записей, алгоритмы хэширования и сжатия инициализируются нулем. Текущее состояние соединения используется для сообщений согласования параметров.</p><h5>7.4.1.1. Запрос Hello</h5><ul><li class="b">When this message will be sent:</li><li class="lib">Сообщение-запрос hello может быть послано сервером в любое время.</li><li class="b">Значение этого сообщения:</li><li class="lib">Запрос Hello является простым уведомлением о том, что клиент должен начать согласование путем посылки сообщения client hello. Это сообщение будет проигнорировано клиентом, если он участвует в сессии согласования. Это сообщение может игнорироваться клиентом, если он не хочет заново согласовывать параметры сессии, или клиент может, если хочет, реагировать уведомлением no_renegotiation. Так как сообщения диалога предназначены для осуществления определенных действий над прикладными данными, ожидается, что согласование начнется до того, как будут получены новые записи от клиента. Если сервер посылает запрос hello, но не получает отклика client hello, он может разорвать соединение с фатальным уведомлением.</li></ul><p>После посылки запроса hello, серверы не должны повторять запрос до тех пор, пока диалог согласования не завершится.</p><ul><li class="b">Структура этого сообщения:</li><li class="lib">struct { } HelloRequest;</li></ul><p class="note">Это сообщение не должно никогда включаться в хэши сообщений и использоваться в завершающих сообщениях (finished), а также в сообщении верификации сертификатов.</p><h5>7.4.1.2. Hello клиента</h5><p>Когда клиент инициализирует соединение с сервером, первым должно быть послано сообщение client hello. Клиент может также послать client hello в качестве отклика на запрос hello или по своей собственной инициативе, для того чтобы заново согласовать параметры безопасности существующего соединения.</p><p>Сообщение hello клиента включает в себя случайную структуру, которая позднее используется протоколом.</p><pre>Structure of this message:
    The client hello message includes a random structure, which is
    used later in the protocol.

    struct {
       uint32 gmt_unix_time;
       opaque random_bytes[28];
    } Random;</pre><ul><li class="b">gmt_unix_time</li><li class="lib">Текущее время и дата согласно стандарта UNIX в 32-битовом формате (число секунд с момента полуночи 1-го января, 1970, GMT) согласно показаниям внутренних часов отправителя. Часы могут и не быть точно выверены на уровне протокола TLS. Прикладные протоколы могут накладывать дополнительные ограничения.</li><li class="b">random_bytes</li><li class="lib">28 байт сформированных безопасным генератором случайных чисел.</li></ul><p>Сообщение client hello включает в себя идентификатор сессии переменной длины. Если это поле не пусто, его значение идентифицирует сессию, чьи параметры безопасности клиент желает использовать повторно. Идентификатор сессии может соответствовать какому-то предшествующему соединению, текущему соединению, или другому активному соединению. Вторая опция полезна, если клиент хочет изменить случайные структуры и получить текущие значения параметров соединения, в то время как третья опция делает возможным установить несколько независимых безопасных соединений без повторения всей процедуры протоколы диалога. Эти независимые соединения могут существовать последовательно или одновременно; SessionID становится действенным, когда диалог согласования завершается обменом сообщениями Finished, и сохраняется до тех пор, пока не состарится или из-за фатальной ошибки в соединении данной сессии. Действительное содержимое SessionID определяется сервером.</p><pre>opaque SessionID&lt;0..32&gt;;</pre><p class="note">Так как SessionID передается без шифрования или MAC-защиты, серверы не должны помещать конфиденциальные данные в идентификаторы сессий, что могло бы привести к возрастанию уязвимости. Заметим, что содержимое диалога в целом, включая SessionID, защищено сообщениями Finished, пересылаемыми в конце диалога.</p><p>Список CipherSuite, передаваемый от клиента серверу в сообщении client hello, содержит комбинации криптографических алгоритмов, поддерживаемых клиентом в порядке их предпочтения (предпочтительный вариант — первый). Каждый CipherSuite определяет алгоритм пересылки ключей, алгоритм массового шифрования (включая длину секретного ключа) и алгоритм MAC. Сервер выберет шифровой набор или, если приемлемого варианта нет, пришлет уведомление об ошибке и прервет соединение.</p><pre>uint8 CipherSuite[2];    /* Cryptographic suite selector */</pre><p>Hello клиента включает в себя список алгоритмов сжатия, поддерживаемых клиентом, в порядке их предпочтения.</p><pre>enum { null(0), (255) } CompressionMethod;

struct {
    ProtocolVersion client_version;
    Random random;
    SessionID session_id;
    CipherSuite cipher_suites&lt;2..2^16-1&gt;;
    CompressionMethod compression_methods&lt;1..2^8-1&gt;;
} ClientHello;</pre><ul><li class="b">client_version</li><li class="lib">Версия протокола TLS, которой хочет воспользоваться клиент во время сессии. Это должна быть последняя версия (с наибольшим кодом), поддерживаемая клиентом. Для данной спецификации значение версии равно 3.1 (Смотри приложение E об обратной совместимости).</li><li class="b">Random</li><li class="lib">Псевдослучайная структура, генерируемая клиентом.</li><li class="b">session_id</li><li class="lib">ID-сессия, которую клиент хочет использовать для данного соединения. Это поле должно быть пустым, если нет ни одного session_id или клиент хочет выработать новые параметры безопасности.</li><li class="b">cipher_suites</li><li class="lib">Список криптографических опций, поддерживаемых клиентом в порядке предпочтения. Если поле session_id не пусто (запрос восстановления сессии), этот вектор должен включать по крайней мере cipher_suite данной сессии. Значения определены в приложении A.5.</li><li class="b">compression_methods</li><li class="lib">Список методов сжатия, поддерживаемых клиентом в порядке их предпочтения. Если поле session_id не пусто (запрос восстановления сессии) он должен включать compression_method данной сессии. Этот вектор должен содержать, а все реализации должны поддерживать CompressionMethod.null. Таким образом, клиент и сервер всегда могут согласовать метод сжатия информации.</li></ul><p>После посылки сообщения client hello, клиент ждет сообщения server hello. Любое другое сообщение диалога, присланное сервером, за исключением запроса hello, рассматривается как фатальная ошибка.</p><p>В интересах прямой совместимости, клиенту разрешено включать в сообщение client hello после методов сжатия дополнительные данные. Эти данные должны быть включены в хэши диалога, в противном случае они игнорируются. Это единственное сообщение диалога, для которого это допускается; для всех остальных сообщений, объем данных должен точно соответствовать описанию сообщения.</p><h5>7.4.1.3. Hello сервера</h5><p>Сервер посылает это сообщение в ответ на сообщение client hello, когда он может найти приемлемый набор алгоритмов. Если он не может сделать приемлемый выбор, он реагирует уведомлением об ошибке диалога.</p><p>Структура этого сообщения:</p><pre>struct {
    ProtocolVersion server_version;
    Random random;
    SessionID session_id;
    CipherSuite cipher_suite;
    CompressionMethod compression_method;
} ServerHello;</pre><ul><li class="b">server_version</li><li class="lib">Это поле будет содержать самое низкое значение, которое предлагается клиентом в client hello и наибольшее значение версии, поддерживаемое сервером. Значение версии данной спецификации равно 3.1 (по поводу обратной совместимости смотри Приложение E).</li><li class="b">Random</li><li class="lib">Эта структура генерируется сервером и должна быть отличной от ClientHello.random.</li><li class="b">session_id</li><li class="lib">Идентифицирует сессию, соответствующую данному соединению. Если ClientHello.session_id не пусто, сервер будет искать соответствие с содержимым своего кэша сессий. Если соответствие найдено и сервер хочет установить новое соединение, используя специфицированное состояние сессии, он откликнется тем же значением ID, что было прислано клиентом. Это индицирует возобновляемую сессию и диктует, что партнеры должны продолжить обмен сообщениями finished. В противном случае это поле будет содержать другое значение идентифицирующее новую сессию. Сервер может вернуть пустое поле session_id, чтобы индицировать, что сессия не будет кэшироваться и, следовательно, не может быть возобновлена. Если сессия возобновлена, она должна использовать тот же шифровой набор, который был согласован ранее.</li><li class="b">cipher_suite</li><li class="lib">Шифровой набор, выбранный сервером из списка в ClientHello.cipher_suites. Для возобновленных сессий это поле несет в себе значение, взятое из состояния возобновляемой сессии.</li><li class="b">compression_method</li><li class="lib">Алгоритм сжатия, выбранный сервером из списка в ClientHello.compression_methods. Для возобновляемых сессий это поле содержит значение из состояния возобновляемой сессии.</li></ul><h4>7.4.2. Сертификат сервера</h4><p>Сервер должен послать сертификат, всякий раз, когда согласованный метод обмена ключами не является анонимным. За этим сообщением всегда непосредственно следует сообщение server hello.</p><p>Тип сертификата должен соответствовать выбранному алгоритму обмена ключами шифров, обычно это сертификат X.509v3. Он должен содержать ключ, который соответствует методу обмена ключами. Если не специфицировано обратного, алгоритм подписи для сертификата должен быть тем же, что и алгоритм для ключа сертификата. Если не специфицировано обратного, общедоступный ключ может иметь любую длину.</p><ul><li class="b">Алгоритм обмена ключами</li><li class="lib">Тип сертификата ключа</li><li class="b">RSA</li><li class="lib">Общедоступный ключ RSA; сертификат должен допускать использование ключа для шифрования.</li><li class="b">RSA_EXPORT</li><li class="lib">Общедоступный ключ RSA с длиной больше чем 512 бит, который может быть использован для подписи, или ключ длиной 512 бит или короче, который может быть использован для шифрования или подписи.</li><li class="b">DHE_DSS</li><li class="lib">Общедоступный ключ DSS.</li><li class="b">DHE_DSS_EXPORT</li><li class="lib">Общедоступный ключ DSS.</li><li class="b">DHE_RSA</li><li class="lib">Общедоступный ключ RSA, который может использоваться для подписи.</li><li class="b">DHE_RSA_EXPORT</li><li class="lib">Общедоступный ключ RSA, который может использоваться для подписи.</li><li class="b">DH_DSS</li><li class="lib">Ключ Diffie-Hellman. Алгоритмом, используемым для подписи сертификата, должен быть DSS.</li><li class="b">DH_RSA</li><li class="lib">Ключ Diffie-Hellman. Алгоритмом, используемым для подписи сертификата, должен быть RSA.</li></ul><p>Все сертификатные профайлы, ключи и криптографические форматы определены рабочей группой IETF PKIX [RFC2459]. Когда присутствует расширение использования ключа, бит digitalSignature должен быть установлен для ключа выбранного для подписи, как это описано выше, а бит keyEncipherment должен присутствовать, чтобы разрешить шифрование, как это описано выше. Бит keyAgreement должен быть установлен для сертификатов Diffie-Hellman.</p><p>Так как CipherSuites, который специфицирует методы нового ключевого обмена, заданы для протокола TLS, они используют формат сертификата и необходимые ключевые данные.</p><p>Структура этого сообщения:</p><pre>opaque ASN.1Cert&lt;1..2^24-1&gt;;

struct {
    ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
} Certificate;</pre><ul><li class="b">certificate_list</li><li class="lib">Это последовательность (цепочка) сертификатов X.509v3. Сертификат отправителя должен быть записан в списке первым. Каждый следующий сертификат должен непосредственно сертифицировать предшествующий сертификат. Так как верификация сертификата требует, чтобы корневые ключи распределялись независимо, самоподписывающий сертификат, который специфицирует корневой источник сертификата, может быть опционно удален из цепочки, в предположении, что партнер должен уже иметь его, чтобы проверить его в любом случае.</li></ul><p>Тот же тип сообщения и структура будут использоваться для отклика клиента на сообщение запроса сертификата. Заметим, что клиент может не посылать сертификата, если он не имеет подходящего, чтобы послать его серверу в ответ на его аутентификационный запрос.</p><h4>7.4.3. Сообщение ключевого обмена сервера</h4><p>Это сообщение будет послано немедленно после сообщения сертификата сервера (или сообщения server hello, если это анонимное согласование параметров).</p><p>Сообщение ключевого обмена сервера посылается сервером только когда сообщение сертификата сервера (если послано) не содержит достаточно данных, чтобы позволить клиенту осуществлять обмен предмастерными секретными кодами (premaster secret). Это верно для следующих методов обмена ключами:</p><ul><li>RSA_EXPORT (если открытый ключ в сертификате длиннее, чем 512 бит)</li><li>DHE_DSS</li><li>DHE_DSS_EXPORT</li><li>DHE_RSA</li><li>DHE_RSA_EXPORT</li><li>DH_anon</li></ul><p>Нелегально посылать сообщение ключевого обмена сервера для следующих методов пересылки ключей:</p><ul><li>RSA</li><li>RSA_EXPORT (когда открытый ключ в сертификате сервера короче чем или равен 512 бит)</li><li>DH_DSS</li><li>DH_RSA</li></ul><p>Это сообщение передает криптографическую информацию, чтобы позволить клиенту оперировать с premaster секретным кодом: либо общедоступный ключ RSA, чтобы зашифровать предмастерный секретный код, либо общедоступный ключ Diffie-Hellman, с помощью которого клиент может завершить обмен ключами.</p><p>В качестве дополнительных определены наборы CipherSuites TLS, которые включают в себя новые алгоритмы обмена ключами. Сервер пошлет сообщение обмена ключами тогда и только тогда, когда тип сертификата, ассоциированный с алгоритмов обмена ключами, не предоставил достаточно информации клиенту, чтобы осуществить пересылку предмастерного секретного кода.</p><p class="note">Согласно настоящему закону США об экспорте, модули RSA больше 512 бит не могут использоваться для ключевого обмена в программах, экспортируемых из США. Более длинные ключи RSA, зашифрованные в сертификатах, могут быть использованы для подписи более коротких ключей RSA в случае метода ключевого обмена RSA_EXPORT.</p><p>Структура этого сообщения:</p><pre>enum { rsa, diffie_hellman } KeyExchangeAlgorithm;

struct {
    opaque rsa_modulus&lt;1..2^16-1&gt;;
    opaque rsa_exponent&lt;1..2^16-1&gt;;
} ServerRSAParams;</pre><ul><li class="b">rsa_modulus</li><li class="lib">The modulus of the server's temporary RSA key.</li><li class="b">rsa_exponent</li><li class="lib">The public exponent of the server's temporary RSA key.</li></ul><pre>struct {
    opaque dh_p&lt;1..2^16-1&gt;;
    opaque dh_g&lt;1..2^16-1&gt;;
    opaque dh_Ys&lt;1..2^16-1&gt;;
} ServerDHParams;     /* Ephemeral DH parameters */</pre><ul><li class="b">dh_p</li><li class="lib">Простой модуль, используемый для операции Diffie-Hellman.</li><li class="b">dh_g</li><li class="lib">Генератор, используемый для операции Diffie-Hellman.</li><li class="b">dh_Ys</li><li class="lib">Общедоступное значение (g^X mod p) метода Diffie-Hellman для сервера.</li></ul><pre>struct {
    select (KeyExchangeAlgorithm) {
        case diffie_hellman:
            ServerDHParams params;
            Signature signed_params;
        case rsa:
            ServerRSAParams params;
            Signature signed_params;
    };
} ServerKeyExchange;</pre><ul><li class="b">Params</li><li class="lib">Параметры ключевого обмена сервера.</li><li class="b">signed_params</li><li class="lib">Для не анонимных ключевых обменов, хэш соответствующих значений параметров с подписью, согласованной с примененным хэшем.</li><li class="b">md5_hash</li><li class="lib">MD5(ClientHello.random + ServerHello.random + ServerParams);</li><li class="b">sha_hash</li><li class="lib">SHA(ClientHello.random + ServerHello.random + ServerParams);</li></ul><pre>enum { anonymous, rsa, dsa } SignatureAlgorithm;

select (SignatureAlgorithm)
{   case anonymous: struct { };
    case rsa:
        digitally-signed struct {
            opaque md5_hash[16];
            opaque sha_hash[20];
        };
    case dsa:
        digitally-signed struct {
            opaque sha_hash[20];
        };
} Signature;</pre><h4>7.4.4. Запрос сертификата</h4><p>Не анонимный сервер может опционно запросить сертификат от клиента, если это возможно для выбранного шифрового набора. За этим сообщением, если оно послано, непосредственно следует сообщение ключевого обмена сервера (Server Key Exchange) (в противном случае, сообщение сертификата сервера).</p><p>Структура этого сообщения:</p><pre>enum {
    rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
    (255)
} ClientCertificateType;

opaque DistinguishedName&lt;1..2^16-1&gt;;

struct {
    ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
    DistinguishedName certificate_authorities&lt;3..2^16-1&gt;;
} CertificateRequest;</pre><ul><li class="b">certificate_types</li><li class="lib">Это поле представляет собой список типов запрошенных сертификатов, расположенных в порядке предпочтения сервера.</li><li class="b">certificate_authorities</li><li class="lib">Список имен приемлемых провайдеров сертификатов. Эти имена могут специфицировать уникальное имя корневого или подчиненного CA. Таким образом, это сообщение может быть использовано как для описания известных корней и желательного пространства авторизации.</li></ul><p class="note">DistinguishedName получается из [X509]. Считается фатальной ошибкой (оповещение handshake_failure), если анонимный сервер запрашивает идентификацию клиента.</p><h4>7.4.5. Hello done сервера</h4><p>Сообщение сервера hello done посылается сервером, чтобы индицировать конец hello сервера и связанных с ним сообщений. После отправки этого сообщения сервер ждет отклика клиента.</p><p>Это сообщение означает, что сервер завершил подготовку для ключевого обмена, и клиент может приступить к процедуре пересылки ключей.</p><p>По получении сообщения сервера hello done клиент должен проверить, что сервер предоставил корректный сертификат, если это требуется, и что параметры, присланные сервером приемлемы.</p><p>Структура этого сообщения:</p><pre>struct { } ServerHelloDone;</pre><h4>7.4.6. Сертификат клиента</h4><p>Это первое сообщение, которое может послать клиент после получения сообщения от сервера hello done. Это сообщение посылается только в случае запроса присылки сертификата со стороны сервера. Если приемлемого сертификата нет, клиент должен послать пустое сообщение сертификата. Если сервером для продолжения диалога требуется аутентификация клиента, он может откликнуться, послав уведомление о фатальной ошибке. Сертификаты клиента посылаются с использованием структуры сертификата, определенной в разделе 7.4.2.</p><p>Когда используется метод ключевого обмена, базирующийся на статическом методе Diffie-Hellman (DH_DSS или DH_RSA), если требуется аутентификация клиента, группа Diffie-Hellman и генератор закодированные в сертификате клиента должны соответствовать параметрам Diffie-Hellman'а, специфицированным сервером, если параметры клиента планируется использовать для ключевого обмена.</p><h4>7.4.7. Сообщение обмена ключами клиента</h4><p>Это сообщение посылается клиентом всегда. За ним непосредственно следует сообщение сертификата клиента, если оно посылается. В противном случае оно будет первым сообщением, посылаемым клиентом после получения сообщения сервера hello done.</p><p>С помощью этого сообщения устанавливается предмастерный секретный код, либо путем прямой передачи его, зашифровав с применением RSA, либо с помощью передачи параметров Diffie-Hellman, которые позволят каждой из сторон согласовать применение одного и того же предмастерного секретного кода. Когда в качестве метода передачи ключей использован DH_RSA или DH_DSS, запрашивается сертификация клиента, и клиент может откликаться посылкой сертификата, который содержит общедоступный ключ Diffie-Hellman, чьи параметры (группа и генератор) соответствуют, специфицированным в сертификате сервера. Это сообщение не содержит никаких других данных.</p><p>Структура этого сообщения:</p><p>Выбор сообщений зависит от выбранного метода ключевого обмена. Смотри раздел 7.4.3, где дано определение KeyExchangeAlgorithm.</p><pre>struct {
    select (KeyExchangeAlgorithm) {
        case rsa: EncryptedPreMasterSecret;
        case diffie_hellman: ClientDiffieHellmanPublic;
    } exchange_keys;
} ClientKeyExchange;</pre><h5>7.4.7.1. Сообщение зашифрованного RSA предмастерного секретного кода</h5><p>Если для согласования ключей и аутентификации применен алгоритм RSA, клиент генерирует 48-байтовый предмастерный секретный код, шифрует его с помощью общедоступного ключа из сертификата сервера или временного RSA-ключа, переданного в сообщении ключевого обмена сервера, и посылает результат в сообщении зашифрованного предмастерного секретного кода (encrypted premaster secret). Эта структура является вариантом сообщения ключевого обмена клиента.</p><p>Структура этого сообщения:</p><pre>struct {
    ProtocolVersion client_version;
    opaque random[46];
} PreMasterSecret;</pre><ul><li class="b">client_version</li><li class="lib">Последняя (новейшая) версия, поддерживаемая клиентом. Она используется для детектирования атак связанных с понижением номера версии. По получении предмастерного секретного кода сервер должен проверить, что данное значение согласуется с величиной, переданной клиентом в сообщении hello.</li><li class="b">random</li><li class="lib">46 байт псевдослучайного кода.</li></ul><pre>struct {
    public-key-encrypted PreMasterSecret pre_master_secret;
} EncryptedPreMasterSecret;</pre><p>Атака, рассмотренная Даниэлем Блайбенбахером (Daniel Bleichenbacher) [BLEI], может быть предпринята против TLS-сервера, который использует PKCS#1, закодированный с помощью RSA.</p><p>Наилучший способ избежать уязвимости от этой атаки является обработка некорректно форматированных сообщений точно также как и корректно сформатированные RSA-блоки. Таким образом, когда сервер получает некорректно сформатированный RSA-блок, он должен сформировать случайное 48-байтовое число и использовать его в дальнейшем в качестве предмастерного секретного кода. Таким образом, сервер будет действовать идентично вне зависимости оттого, является ли полученный RSA-блок корректным.</p><ul><li class="b">pre_master_secret</li><li class="lib">Это случайное число генерируется клиентом и используется для формирования мастерного секретного кода, как это специфицировано в разделе 8.1.</li></ul><h5>7.4.7.2. Общедоступный Diffie-Hellman-ключ клиента</h5><p>Эта структура передает общедоступную величину (Yc) Diffie-Hellman-алгоритма для клиента, если она не была уже включена в сертификат клиента. Шифрование, используемое для Yc, определяется нумерованным параметром PublicValueEncoding. Эта структура является вариантом сообщения ключевого обмена клиента.</p><p>Структура этого сообщения:</p><pre>enum { implicit, explicit } PublicValueEncoding;</pre><ul><li class="b">implicit</li><li class="lib">Если сертификат клиента уже содержит подходящий ключ алгоритма Diffie-Hellman, тогда Yc является неявным и не должно пересылаться снова. В этом случае будет послано сообщение ключевого обмена клиента (Client Key Exchange), но оно будет пустым.</li><li class="b">explicit</li><li class="lib">Yc должно быть послано.</li></ul><pre>struct {
    select (PublicValueEncoding) {
        case implicit: struct { };
        case explicit: opaque dh_Yc&lt;1..2^16-1&gt;;
    } dh_public;
} ClientDiffieHellmanPublic;</pre><ul><li class="b">dh_Yc</li><li class="lib">Общедоступный Diffie-Hellman-ключ клиента (Yc).</li></ul><h4>7.4.8. Верификация сертификата</h4><p>Это сообщение используется для осуществления в явной форме верификации сертификата клиента. Оно посылается вслед за сертификатом клиента, который имеет возможность подписи (т.e. все сертификаты кроме тех, которые содержат фиксированные параметры Diffie-Hellman). При посылке это сообщение следует немедленно за сообщением ключевого обмена клиента.</p><p>Структура этого сообщения имеет вид:</p><pre>struct {
     Signature signature;
} CertificateVerify;</pre><p>Тип подписи определен в 7.4.3.</p><pre>CertificateVerify.signature.md5_hash
    MD5(handshake_messages);

Certificate.signature.sha_hash
    SHA(handshake_messages);</pre><p>Здесь handshake_messages относятся ко всем сообщениям диалога, посланным или полученным, начиная с hello клиента, и вплоть до (но исключая) данное сообщение, содержащее поля типа и длины сообщений диалога. Это представляет собой соединение всех структур диалога, как это определено в 7.4.</p><h4>7.4.9. Сообщение Finished</h4><p>Сообщение finished всегда посылается немедленно после сообщения изменения шифровой спецификации, чтобы верифицировать процессы ключевого обмена и аутентификации. Существенно, чтобы сообщение об изменении шифровой спецификации было получено между другими сообщениями диалога и сообщением Finished.</p><p>Сообщение finished является первым, защищенным с использованием только что согласованных алгоритмов, ключей и секретных кодов. Получатели сообщений finished должны верифицировать корректность содержимого. Раз партнер послал свое сообщение Finished и получил корректное сообщение от другой стороны, он может начать посылать и получать через данное соединение прикладные данные.</p><pre>struct {
    opaque verify_data[12];
} Finished;</pre><ul><li class="b">verify_data</li><li class="lib">PRF(master_secret, finished_label, MD5(handshake_messages) + SHA1(handshake_messages)) [0..11];</li><li class="b">finished_label</li><li class="lib">Для сообщений Finished, посланных клиентом, это строка "client finished". Для сообщений Finished, посланных сервером, это строка "server finished".</li><li class="b">handshake_messages</li><li class="lib">Все данные от сообщений диалога до этого сообщение (но не включительно). Это единственные данные, видимые на уровне диалога, они не включают заголовки уровня записей. Это соединение всех структур диалога, определенных в 7.4.</li></ul><p>Если в соответствующей точке диалога за сообщением finished не следует сообщение об изменении шифровой спецификации, это считается фатальной ошибкой.</p><p>Хэши, содержащиеся в сообщениях finished, посланных серверам, включает в себя Sender.server; а посланные клиентом содержат Sender.client. Значение handshake_messages включает все сообщения диалога, начиная с hello клиента и вплоть до (но не включая) это сообщение finished. Здесь могут быть отличия от handshake_messages из раздела 7.4.8, так как сюда может входить сообщение верификации сертификата. Следует также иметь в виду, что, handshake_messages для сообщения finished, посланного клиентом, будет отличаться от посланного сервером, так как второе, включает первое.</p><p>Сообщения об изменении шифровой спецификации, уведомления и любые другие типы записей не являются сообщениями диалога и не включаются в вычисления хэшей. В хэши диалога не включаются также сообщения запроса Hello Request.</p><h2 id="p8">8. Криптографические вычисления</h2><p>Для того чтобы начать защиту соединения, протоколу записей TLS необходима спецификация набора алгоритмов, мастерный секретный код и случайные коды клиента и сервера. Алгоритмы аутентификации, шифрования и MAC определяются cipher_suite, выбранным сервером и указанным в сообщении server hello. Алгоритм сжатия согласуется в сообщениях hello, а случайные коды пересылаются в сообщениях hello. Все что остается — это вычислить мастерный секретный код.</p><h3>8.1. Вычисление мастерного секретного кода</h3><p>Для всех методов ключевого обмена используется один и тот же алгоритм преобразования pre_master_secret в master_secret. Значение pre_master_secret следует стереть из памяти, как только завершится вычисление master_secret.</p><pre>master_secret = PRF(pre_master_secret, "master secret",
                    ClientHello.random + ServerHello.random)
[0..47];</pre><p>Мастерный секретный код всегда имеет длину 48 байт. Длина предмастерного секретного кода варьируется в зависимости от метода ключевого обмена.</p><h4>8.1.1. RSA</h4><p>Когда для аутентификации сервера и ключевого обмена используется RSA, 48- байтовый pre_master_secret генерируется клиентом, шифруется с помощью общедоступного ключа сервера и посылается серверу. Сервер использует свой секретный ключ для дешифрования pre_master_secret. Оба партнера преобразуют затем pre_master_secret в master_secret, как это специфицировано выше.</p><p>Цифровые подписи RSA реализуются с помощью PKCS #1 [PKCS1] с типом блока 1. Шифрование RSA с использованием общедоступного ключа выполняется с помощью PKCS #1 с типом блока 2.</p><h4>8.1.2. Diffie-Hellman</h4><p>Выполняются обычные вычисления по алгоритму Diffie-Hellman. В качестве pre_master_secret используется согласованный ключ (Z), преобразование его в master_secret, описано выше.</p><p>Параметры Diffie-Hellman специфицируются сервером и могут быть одноразовыми или взятыми из сертификата сервера.</p><p>В отсутствии стандарта на прикладной профайл приложение TLS должно использовать шифровой набор TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA.</p><p>Сообщения прикладных данных вырабатываются уровнем записей, фрагментируются, сжимаются и шифруются на основе параметров состояния соединения. Сообщения рассматриваются как прозрачные данные уровня записей.</p><h2 id="p9">9. Mandatory Cipher Suites</h2><p>In the absence of an application profile standard specifying otherwise, a TLS compliant application MUST implement the cipher suite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA.</p><h2 id="p10">10. Application data protocol</h2><p>Application data messages are carried by the Record Layer and are fragmented, compressed and encrypted based on the current connection state. The messages are treated as transparent data to the record layer.</p><h2 id="p.appendix.a">A. Значения протокольных констант</h2><h3>A.1. Уровень записей</h3><pre>struct {
    uint8 major, minor;
} ProtocolVersion;

ProtocolVersion version = { 3, 1 };     /* TLS v1.0 */

enum {
    change_cipher_spec(20), alert(21), handshake(22),
    application_data(23), (255)
} ContentType;

struct {
    ContentType type;
    ProtocolVersion version;
    uint16 length;
    opaque fragment[TLSPlaintext.length];
} TLSPlaintext;

struct {
    ContentType type;
    ProtocolVersion version;
    uint16 length;
    opaque fragment[TLSCompressed.length];
} TLSCompressed;

struct {
    ContentType type;
    ProtocolVersion version;
    uint16 length;
    select (CipherSpec.cipher_type) {
        case stream: GenericStreamCipher;
        case block:  GenericBlockCipher;
    } fragment;
} TLSCiphertext;

stream-ciphered struct {
    opaque content[TLSCompressed.length];
    opaque MAC[CipherSpec.hash_size];
} GenericStreamCipher;

block-ciphered struct {
    opaque content[TLSCompressed.length];
    opaque MAC[CipherSpec.hash_size];
    uint8 padding[GenericBlockCipher.padding_length];
    uint8 padding_length;
} GenericBlockCipher;</pre><h3>A.2. Сообщение об изменении спецификации шифра</h3><pre>struct {
    enum { change_cipher_spec(1), (255) } type;
} ChangeCipherSpec;</pre><h3>A.3. Сообщения уведомления (Alert)</h3><pre>enum { warning(1), fatal(2), (255) } AlertLevel;

    enum {
        close_notify(0),
        unexpected_message(10),
        bad_record_mac(20),
        decryption_failed(21),
        record_overflow(22),
        decompression_failure(30),
        handshake_failure(40),
        bad_certificate(42),
        unsupported_certificate(43),
        certificate_revoked(44),
        certificate_expired(45),
        certificate_unknown(46),
        illegal_parameter(47),
        unknown_ca(48),
        access_denied(49),
        decode_error(50),
        decrypt_error(51),
        export_restriction(60),
        protocol_version(70),
        insufficient_security(71),
        internal_error(80),
        user_canceled(90),
        no_renegotiation(100),
        (255)
    } AlertDescription;

struct {
    AlertLevel level;
    AlertDescription description;
} Alert;</pre><h3>A.4. Протокол диалога</h3><pre>enum {
    hello_request(0), client_hello(1), server_hello(2),
    certificate(11), server_key_exchange (12),
    certificate_request(13), server_hello_done(14),
    certificate_verify(15), client_key_exchange(16),
    finished(20), (255)
} HandshakeType;

struct {
    HandshakeType msg_type;
    uint24 length;
    select (HandshakeType) {
        case hello_request:       HelloRequest;
        case client_hello:        ClientHello;
        case server_hello:        ServerHello;
        case certificate:         Certificate;
        case server_key_exchange: ServerKeyExchange;
        case certificate_request: CertificateRequest;
        case server_hello_done:   ServerHelloDone;
        case certificate_verify:  CertificateVerify;
        case client_key_exchange: ClientKeyExchange;
        case finished:            Finished;
    } body;
} Handshake;</pre><h4>A.4.1. Сообщения Hello</h4><pre>struct { } HelloRequest;

struct {
    uint32 gmt_unix_time;
    opaque random_bytes[28];
} Random;

opaque SessionID&lt;0..32&gt;;

uint8 CipherSuite[2];

enum { null(0), (255) } CompressionMethod;

struct {
    ProtocolVersion client_version;
    Random random;
    SessionID session_id;
    CipherSuite cipher_suites&lt;2..2^16-1&gt;;
    CompressionMethod compression_methods&lt;1..2^8-1&gt;;
} ClientHello;

struct {
    ProtocolVersion server_version;
    Random random;
    SessionID session_id;
    CipherSuite cipher_suite;
    CompressionMethod compression_method;
} ServerHello;</pre><h4>A.4.2. Аутентификация сервера и сообщения обмена ключами</h4><pre>opaque ASN.1Cert&lt;2^24-1&gt;;

struct {
    ASN.1Cert certificate_list&lt;1..2^24-1&gt;;
} Certificate;

enum { rsa, diffie_hellman } KeyExchangeAlgorithm;

struct {
    opaque RSA_modulus&lt;1..2^16-1&gt;;
    opaque RSA_exponent&lt;1..2^16-1&gt;;
} ServerRSAParams;

struct {
    opaque DH_p&lt;1..2^16-1&gt;;
    opaque DH_g&lt;1..2^16-1&gt;;
    opaque DH_Ys&lt;1..2^16-1&gt;;
} ServerDHParams;

struct {
    select (KeyExchangeAlgorithm) {
        case diffie_hellman:
            ServerDHParams params;
            Signature signed_params;
        case rsa:
            ServerRSAParams params;
            Signature signed_params;
    };
} ServerKeyExchange;

enum { anonymous, rsa, dsa } SignatureAlgorithm;

select (SignatureAlgorithm)
{   case anonymous: struct { };
    case rsa:
        digitally-signed struct {
            opaque md5_hash[16];
            opaque sha_hash[20];
        };
    case dsa:
        digitally-signed struct {
            opaque sha_hash[20];
        };
} Signature;

enum {
    rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
    (255)
} ClientCertificateType;

opaque DistinguishedName&lt;1..2^16-1&gt;;

struct {
    ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
    DistinguishedName certificate_authorities&lt;3..2^16-1&gt;;
} CertificateRequest;

struct { } ServerHelloDone;</pre><h4>A.4.3. Аутентификация клиента и сообщения обмена ключами</h4><pre>struct {
    select (KeyExchangeAlgorithm) {
        case rsa: EncryptedPreMasterSecret;
        case diffie_hellman: DiffieHellmanClientPublicValue;
    } exchange_keys;
} ClientKeyExchange;

struct {
    ProtocolVersion client_version;
    opaque random[46];

} PreMasterSecret;

struct {
    public-key-encrypted PreMasterSecret pre_master_secret;
} EncryptedPreMasterSecret;

enum { implicit, explicit } PublicValueEncoding;

struct {
    select (PublicValueEncoding) {
        case implicit: struct {};
        case explicit: opaque DH_Yc&lt;1..2^16-1&gt;;
    } dh_public;
} ClientDiffieHellmanPublic;

struct {
    Signature signature;
} CertificateVerify;</pre><h4>A.4.4. Завершающее сообщение диалога</h4><pre>struct {
    opaque verify_data[12];
} Finished;</pre><h3>A.5. Коды CipherSuite</h3><p>Следующие значения определены кодами CipherSuite, используемыми в сообщениях client hello и server hello.</p><p>CipherSuite определяет шифровую спецификацию, поддерживаемую в TLS версии 1.0.</p><p>TLS_NULL_WITH_NULL_NULL специфицировано и является исходным состоянием TLS-соединения во время начала диалога в канале, эта спецификация не согласуется, так как она предоставляет услуги незащищенного соединения.</p><pre>CipherSuite TLS_NULL_WITH_NULL_NULL                = { 0x00,0x00 };</pre><p>Следующие определения CipherSuite требуют, чтобы сервер предоставлял RSA-сертификат, который можно использовать для ключевого обмена. Сервер может потребовать присылки сертификата RSA или DSS, пригодного для цифровой подписи.</p><pre>CipherSuite TLS_RSA_WITH_NULL_MD5                  = { 0x00,0x01 };
CipherSuite TLS_RSA_WITH_NULL_SHA                  = { 0x00,0x02 };
CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5         = { 0x00,0x03 };
CipherSuite TLS_RSA_WITH_RC4_128_MD5               = { 0x00,0x04 };
CipherSuite TLS_RSA_WITH_RC4_128_SHA               = { 0x00,0x05 };
CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5     = { 0x00,0x06 };
CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA              = { 0x00,0x07 };
CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA      = { 0x00,0x08 };
CipherSuite TLS_RSA_WITH_DES_CBC_SHA               = { 0x00,0x09 };
CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA          = { 0x00,0x0A };</pre><p>Следующие определения CipherSuite используются для аутентифицированного сервером (и опционно клиентом) алгоритма Diffie-Hellman. DH обозначает шифровой набор, в котором сертификат сервера содержит параметры алгоритма Diffie-Hellman, подписанные провайдером сертификата CA (certificate authority). DHE обозначает временный Diffie-Hellman, где параметры Diffie-Hellman подписаны с помощью DSS- или RSA-сертификата, который подписан посредством CA. Используемый алгоритм подписи специфицирован согласно параметрам DH или DHE. Сервер может запросить от клиента сертификат RSA или DSS, пригодный для подписи, чтобы аутентифицировать клиента. Он может запросить также сертификат Diffie-Hellman. Любой сертификат Diffie-Hellman, предоставленный клиентом должен использовать параметры (группа и генератор), описанные сервером.</p><pre>CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0B };
CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA            = { 0x00,0x0C };
CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x0D };
CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0E };
CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA            = { 0x00,0x0F };
CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x10 };
CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x11 };
CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA           = { 0x00,0x12 };
CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x13 };
CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x14 };
CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA           = { 0x00,0x15 };
CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x16 };</pre><p>Следующие шифровые наборы используются для полностью анонимного обмена с применением алгоритма Diffie-Hellman, в котором ни один из партнеров не аутентифицирован. Заметим, что этот режим уязвим для атак 'посредника' (man-in-the-middle) и по этой причине неприемлем.</p><pre>CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5     = { 0x00,0x17 };
CipherSuite TLS_DH_anon_WITH_RC4_128_MD5           = { 0x00,0x18 };
CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x19 };
CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA           = { 0x00,0x1A };
CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x1B };</pre><p>Все шифровые наборы, чей первый байт равен 0xFF, рассматриваются частными и могут быть использованы для определения локальных/экспериментальных алгоритмов.</p><p>Дополнительные шрифтовые наборы могут быть зарегистрированы путем публикации документа RFC, который специфицирует этот набор, включая необходимую протокольную информацию TLS, кодировку сообщений, получение предмастерных секретных кодов, симметричного шифрования, MAC-вычисления и ссылки на описания используемых алгоритмов. Редакционная комиссия RFC по своему разумению может опубликовать и неполное описание шифрового набора, если сочтет, что данное описание представляет определенный интерес.</p><p>Коды шифровых наборов { 0x00, 0x1C } и { 0x00, 0x1D } зарезервированы, чтобы избежать конфликта с наборами, базирующимися на Fortezza в SSL 3.</p><h3>A.6. Параметры безопасности</h3><p>Эти параметры безопасности определены протоколом диалога TLS и передаются уровню записи TLS, для того чтобы инициализировать состояние соединения. SecurityParameters включают в себя:</p><pre>    enum { null(0), (255) } CompressionMethod;

    enum { server, client } ConnectionEnd;

    enum { null, rc4, rc2, des, 3des, des40, idea }
    BulkCipherAlgorithm;

    enum { stream, block } CipherType;

    enum { true, false } IsExportable;

    enum { null, md5, sha } MACAlgorithm;

/* The algorithms specified in CompressionMethod,
BulkCipherAlgorithm, and MACAlgorithm may be added to. */

    struct {
        ConnectionEnd entity;
        BulkCipherAlgorithm bulk_cipher_algorithm;
        CipherType cipher_type;
        uint8 key_size;
        uint8 key_material_length;
        IsExportable is_exportable;
        MACAlgorithm mac_algorithm;
        uint8 hash_size;
        CompressionMethod compression_algorithm;
        opaque master_secret[48];
        opaque client_random[32];
        opaque server_random[32];
    } SecurityParameters;</pre><h2 id="p.appendix.b">B. Термины</h2><ul><li class="b">Протокол приложения</li><li class="lib">Протокол приложения является протоколом, который функционирует поверх транспортного уровня (напр., TCP/IP). Среди примеров можно назвать HTTP, TELNET, FTP и SMTP.</li><li class="b">Асимметричный шифр</li><li class="lib">Смотри криптографию с общедоступным ключом</li><li class="b">Аутентификация</li><li class="lib">Аутентификация — это механизм, который предоставляет возможность одному партнеру идентифицировать другого партнера</li><li class="b">Блочный шифр</li><li class="lib">Блочный шифр — это алгоритм, который работает с фиксированными группами битов открытого текста, называемых блоками. 64 бита — обычный размер блока</li><li class="b">Массовый шифр</li><li class="lib">Алгоритм симметричного шифрования, используемый для кодирования больших объемов данных.</li><li class="b">Цепочный блок-шифр (CBC)</li><li class="lib">CBC является режимом, в котором каждый блок исходного текста закодированного блочным шифром сначала объединяется с предыдущим зашифрованным блоком с помощью исключающего ИЛИ (или в случае первого блока, с вектором инициализации). При дешифровании каждый блок сначала дешифруется, а затем объединяется с предыдущим зашифрованным блоком с помощью исключающего ИЛИ (или IV).</li><li class="b">Сертификат</li><li class="lib">В качестве части протокола X.509, сертификаты выдаются проверенным провайдером (Certificate Authority) и обеспечивают строгую связь между идентичностью партнера, содержат некоторые другие атрибуты, а также общедоступный ключ</li><li class="b">Клиент</li><li class="lib">Субъект, который инициирует TLS-соединение с сервером. Различие между сервером и клиентом заключается в том, что сервер обычно является аутентифицированным, в то время как клиент может быть аутентифицирован только опционно.</li><li class="b">Ключ записи клиента</li><li class="lib">Ключ, используемый клиентом для шифрования записываемых данных.</li><li class="b">Секретный код MAC записи клиента</li><li class="lib">Секретные данные, используемые для аутентификации информации, которую пишет клиент.</li><li class="b">Соединение</li><li class="lib">Соединение — это транспортная среда (согласно определению модели OSI), которая предоставляет приемлемый тип услуг. Для TLS, такие соединения служат для установления канала между партнерами. Соединения прозрачны. Каждое соединение сопряжено с одной сессией.</li><li class="b">Стандарт шифрования данных DES (Data Encryption Standard)</li><li class="lib">DES является широко используемым алгоритмом симметричного шифрования. DES представляет собой блочный шифр с 56 битным ключом и размером блока в 8 байтов. Заметим, что в TLS, для целей генерации ключей, DES рассматривается как имеющий 8-байтовую длину ключа (64 бита), но при этом обеспечивает безопасность на уровне 56 бит. (Младший бит каждого ключевого байта устанавливается с учетом формирования определенной четности каждого ключевого байта). DES может также работать в режиме, где используется три независимых ключа и три шифрования для каждого блока данных; при этом ключ имеет длину 168 бит (24 байта в методе генерации ключей TLS) и обеспечивает безопасность, соответствующую 112 битам. [DES], [3DES]</li><li class="b">Стандарт цифровой подписи DSS (Digital Signature Standard)</li><li class="lib">Стандарт цифровой подписи, включая алгоритм цифровой подписи DSA, одобренный национальным институтом стандартов и технологии США, определенный в NIST FIPS PUB 186, «Digital Signature Standard», май 1994. [DSS]</li><li class="b">Цифровая подпись</li><li class="lib">Цифровые подписи используют криптографию с общедоступным ключом и однопроходные хэш-функции, для того чтобы аутентифицировать подписанные данные и гарантировать их целостность.</li><li class="b">Диалог</li><li class="lib">Начальное согласование между клиентом и сервером, которое позволяет определить параметры транзакции.</li><li class="b">Вектор инициализации (IV)</li><li class="lib">Когда используется блочный шифр в режиме CBC, перед шифрованием вектор инициализации объединяется с первым блоком исходного текста с помощью операции исключающее ИЛИ.</li><li class="b">IDEA</li><li class="lib">64-битовый блочный шифр, разработанный Xuejia Lai и James Massey. [IDEA]</li><li class="b">Код аутентификации сообщения (MAC)</li><li class="lib">Код аутентификации сообщения представляет собой однопроходный хэш, вычисленный для сообщения и некоторых секретных данных. Его трудно взломать без знания секретных данных. Его целью является определение того, было ли сообщение модифицировано при транспортировке.</li><li class="b">Мастерный секретный код</li><li class="lib">Безопасные секретные данные, используемые для генерации ключей шифрования, секретных кодов MAC и IV.</li><li class="b">MD5</li><li class="lib">MD5 представляет собой безопасную хэш-функцию, которая преобразует поток данных произвольного размера в дайджест фиксированного размера (16 байт). [<a href="../1321.rfc" title="RFC 1321 - Алгоритм цифровых подписей MD5">RFC1321</a>]</li><li class="b">Криптография с общедоступным ключом</li><li class="lib">Класс криптографических методов, использующих двух-ключевой шифр. Сообщения, зашифрованные с помощью общедоступного ключа, могут быть дешифрованы посредством ассоциированного с ним секретного ключа. Сообщения, подписанные с помощью секретного ключа могут быть верифицированы посредством общедоступного ключа.</li><li class="b">Однопроходная хэш-функция</li><li class="lib">Однопроходное преобразование, которое конвертирует произвольное количество данных в хэш фиксированной длины. С вычислительной точки зрения трудно осуществить обратное преобразование. MD5 и SHA представляют собой примеры однопроходных хэш-функций.</li><li class="b">RC2</li><li class="lib">Блочный шифр, разработанный Ron Rivest в компании RSA Data Security, Inc. [RSADSI] и описанный в [RFC2268].</li><li class="b">RC4</li><li class="lib">Поточный шифр, лицензированный компанией RSA Data Security [RSADSI]. Совместимый шифр описан в [RC4].</li><li class="b">RSA</li><li class="lib">Очень широко используемый алгоритм шифрования с общедоступным ключом, который может быть использован для шифрования или цифровой подписи. [RSA]</li><li class="b">salt</li><li class="lib">Несекретные случайные данные, используемые для того, чтобы сделать передаваемые ключи шифрования более устойчивыми против атак.</li><li class="b">Сервер</li><li class="lib">Сервер — это субъект, который реагирует на запросы клиента по установлению соединения.</li><li class="b">Сессия</li><li class="lib">Сессия TLS — это ассоциация клиента и сервера. Сессия создается с помощью протокола диалога. Сессия определяет набор криптографических параметров, которые могут использоваться несколькими соединениями. Сессия служит для того, чтобы избежать издержек, связанных с согласованием параметров безопасности каждого соединения.</li><li class="b">Идентификатор сессии</li><li class="lib">Идентификатор сессии представляет собой код, генерируемый сервером для того, чтобы идентифицировать конкретную сессию.</li><li class="b">Ключ записи сервера</li><li class="lib">Ключ, используемый сервером для записи шифрованных данных.</li><li class="b">Секретный код MAC записи сервера</li><li class="lib">Секретные данные, используемые для аутентификации информации, записанной сервером.</li><li class="b">SHA (Secure Hash Algorithm)</li><li class="lib">Алгоритм SHA описан в FIPS PUB 180-1. Он формирует дайджест размером 20-байт. Заметим, что все ссылки на SHA в действительности содержат модифицированный алгоритм SHA-1. [SHA]</li><li class="b">SSL (Secure Socket Layer)</li><li class="lib">Протокол Netscape SSL [SSL3]. TLS базируется на версии SSL 3.0</li><li class="b">Поточный шифр</li><li class="lib">Алгоритм шифрования, который преобразует ключ в поток криптографически устойчивых данных, которые объединяются с исходным текстом с помощью операции исключающее ИЛИ</li><li class="b">Симметричный шифр</li><li class="lib">Смотри массовый шифр.</li><li class="b">Безопасность транспортного уровня TLS (Transport Layer Security)</li><li class="lib">Данный протокол; а также рабочая группа Transport Layer Security комиссии Internet Engineering Task Force (IETF).</li></ul><h2 id="p.appendix.c">C. Определения CipherSuite</h2><table><tr><td>TLS_NULL_WITH_NULL_NULL</td><td>* NULL</td><td>NULL</td><td>NULL</td></tr><tr><td>TLS_RSA_WITH_NULL_MD5</td><td>* RSA</td><td>NULL</td><td>MD5</td></tr><tr><td>TLS_RSA_WITH_NULL_SHA</td><td>* RSA</td><td>NULL</td><td>SHA</td></tr><tr><td>TLS_RSA_EXPORT_WITH_RC4_40_MD5</td><td>* RSA_EXPORT</td><td>RC4_40</td><td>MD5</td></tr><tr><td>TLS_RSA_WITH_RC4_128_MD5</td><td>RSA</td><td>RC4_128</td><td>MD5</td></tr><tr><td>TLS_RSA_WITH_RC4_128_SHA</td><td>RSA</td><td>RC4_128</td><td>SHA</td></tr><tr><td>TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5</td><td>* RSA_EXPORT</td><td>RC2_CBC_40</td><td>MD5</td></tr><tr><td>TLS_RSA_WITH_IDEA_CBC_SHA</td><td>RSA</td><td>IDEA_CBC</td><td>SHA</td></tr><tr><td>TLS_RSA_EXPORT_WITH_DES40_CBC_SHA</td><td>* RSA_EXPORT</td><td>DES40_CBC</td><td>SHA</td></tr><tr><td>TLS_RSA_WITH_DES_CBC_SHA</td><td>RSA</td><td>DES_CBC</td><td>SHA</td></tr><tr><td>TLS_RSA_WITH_3DES_EDE_CBC_SHA</td><td>RSA</td><td>3DES_EDE_CBC</td><td>SHA</td></tr><tr><td>TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA</td><td>* DH_DSS_EXPORT</td><td>DES40_CBC</td><td>SHA</td></tr><tr><td>TLS_DH_DSS_WITH_DES_CBC_SHA</td><td>DH_DSS</td><td>DES_CBC</td><td>SHA</td></tr><tr><td>TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA</td><td>DH_DSS</td><td>3DES_EDE_CBC</td><td>SHA</td></tr><tr><td>TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA</td><td>* DH_RSA_EXPORT</td><td>DES40_CBC</td><td>SHA</td></tr><tr><td>TLS_DH_RSA_WITH_DES_CBC_SHA</td><td>DH_RSA</td><td>DES_CBC</td><td>SHA</td></tr><tr><td>TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA</td><td>DH_RSA</td><td>3DES_EDE_CBC</td><td>SHA</td></tr><tr><td>TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA</td><td>* DHE_DSS_EXPORT</td><td>DES40_CBC</td><td>SHA</td></tr><tr><td>TLS_DHE_DSS_WITH_DES_CBC_SHA</td><td>DHE_DSS</td><td>DES_CBC</td><td>SHA</td></tr><tr><td>TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA</td><td>DHE_DSS</td><td>3DES_EDE_CBC</td><td>SHA</td></tr><tr><td>TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA</td><td>* DHE_RSA_EXPORT</td><td>DES40_CBC</td><td>SHA</td></tr><tr><td>TLS_DHE_RSA_WITH_DES_CBC_SHA</td><td>DHE_RSA</td><td>DES_CBC</td><td>SHA</td></tr><tr><td>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</td><td>DHE_RSA</td><td>3DES_EDE_CBC</td><td>SHA</td></tr><tr><td>TLS_DH_anon_EXPORT_WITH_RC4_40_MD5</td><td>* DH_anon_EXPORT</td><td>RC4_40</td><td>MD5</td></tr><tr><td>TLS_DH_anon_WITH_RC4_128_MD5</td><td>DH_anon</td><td>RC4_128</td><td>MD5</td></tr><tr><td>TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA</td><td>DH_anon</td><td>DES40_CBC</td><td>SHA</td></tr><tr><td>TLS_DH_anon_WITH_DES_CBC_SHA</td><td>DH_anon</td><td>DES_CBC</td><td>SHA</td></tr><tr><td>TLS_DH_anon_WITH_3DES_EDE_CBC_SHA</td><td>DH_anon</td><td>3DES_EDE_CBC</td><td>SHA</td></tr></table><p>* Указывает, что IsExportable = истинно</p><table><tr><td class="b">Алгоритм ключевого обмена</td><td class="b">Описание</td><td class="b">Ограничение на размер ключа</td></tr><tr><td>DHE_DSS</td><td>Ephemeral DH with DSS signatures</td><td>None</td></tr><tr><td>DHE_DSS_EXPORT</td><td>Ephemeral DH with DSS signatures</td><td>DH = 512 bits</td></tr><tr><td>DHE_RSA</td><td>Ephemeral DH with RSA signatures</td><td>None</td></tr><tr><td>DHE_RSA_EXPORT</td><td>Ephemeral DH with RSA signatures</td><td>DH = 512 bits, RSA = none</td></tr><tr><td>DH_anon</td><td>Anonymous DH, no signatures</td><td>None</td></tr><tr><td>DH_anon_EXPORT</td><td>Anonymous DH, no signatures</td><td>DH = 512 bits</td></tr><tr><td>DH_DSS</td><td>DH with DSS-based certificates</td><td>None</td></tr><tr><td>DH_DSS_EXPORT</td><td>DH with DSS-based certificates</td><td>DH = 512 bits</td></tr><tr><td>DH_RSA</td><td>DH with RSA-based certificates</td><td>None</td></tr><tr><td>DH_RSA_EXPORT</td><td>DH with RSA-based certificates</td><td>DH = 512 bits, RSA = none</td></tr><tr><td>NULL</td><td>Отсутствие ключевого обмена</td><td>N/A</td></tr><tr><td>RSA</td><td>Ключевой обмен RSA</td><td>None</td></tr><tr><td>RSA_EXPORT</td><td>Ключевой обмен RSA</td><td>RSA = 512 бит</td></tr></table><p>Ограничение на размер ключа характеризуют максимальную длину ключевого общедоступного кода, который может быть легально использован в экспортируемом шифровом наборе.</p><table><tr><td class="b">Шифр</td><td class="b">Тип</td><td class="b">Ключевой материал</td><td class="b">Расширенный ключевой материал</td><td class="b">Эффективное число бит в ключе</td><td class="b">Размер IV</td><td class="b">Размер блока</td></tr><tr><td>NULL *</td><td>Поток</td><td>0</td><td>0</td><td>0</td><td>0</td><td>N/A</td></tr><tr><td>IDEA_CBC</td><td>Блок</td><td>16</td><td>16</td><td>128</td><td>8</td><td>8</td></tr><tr><td>RC2_CBC_40 *</td><td>Блок</td><td>5</td><td>16</td><td>40</td><td>8</td><td>8</td></tr><tr><td>RC4_40 *</td><td>Поток</td><td>5</td><td>16</td><td>40</td><td>0</td><td>N/A</td></tr><tr><td>RC4_128</td><td>Поток</td><td>16</td><td>16</td><td>128</td><td>0</td><td>N/A</td></tr><tr><td>DES40_CBC *</td><td>Блок</td><td>5</td><td>8</td><td>40</td><td>8</td><td>8</td></tr><tr><td>DES_CBC</td><td>Блок</td><td>8</td><td>8</td><td>56</td><td>8</td><td>8</td></tr><tr><td>3DES_EDE_CBC</td><td>Блок</td><td>24</td><td>24</td><td>168</td><td>8</td><td>8</td></tr></table><p>* Указывает IsExportable = 'истинно'.</p><ul><li class="b">Тип</li><li class="lib">Указывает является ли шифр поточным или блочным, работающим в режиме CBC.</li><li class="b">Key Material</li><li class="lib">Число байтов из key_block, которые используются для генерации ключей записи.</li><li class="b">Expanded Key Material</li><li class="lib">Число байтов действительно передаваемых алгоритму шифрования</li><li class="b">Эффективные биты ключа</li><li class="lib">Сколько энтропийного материала, содержащегося в материале ключа, передается программам шифрования.</li><li class="b">Размер IV</li><li class="lib">Сколько данных нужно сгенерировать для вектора инициализации (initialization vector). Нуль — для поточных шифров; число, равное размеру блока для блочных шифров.</li><li class="b">Размер блока</li><li class="lib">Количество данных, которые блочный шифр преобразует за один раз; блочный шифр, работающий в режиме CBC, может переработать блок с размером четным кратным величине его блока.</li></ul><table><tr><td class="b">Хэш-функция</td><td class="b">Размер хэша</td><td class="b">Размер заполнителя</td></tr><tr><td>NULL</td><td>0</td><td>0</td></tr><tr><td>MD5</td><td>16</td><td>48</td></tr><tr><td>SHA</td><td>20</td><td>40</td></tr></table><h2 id="p.appendix.d">D. Замечания о реализации</h2><h3>D.1. Временные ключи RSA</h3><p>Экспортные ограничения США устанавливает верхний предел длины ключей RSA равный 512 битам, но не вводят ограничений на размер RSA ключей, используемых для цифровых подписей. Часто нужны сертификаты длиннее 512 бит, так как 512-битные RSA ключи не достаточно безопасны для особо важных транзакций или для приложений требующих долговременной безопасности. Некоторые сертификаты предназначены исключительно для цифровых подписей и не могут использоваться для ключевого обмена.</p><p>Когда общедоступный ключ в сертификате не может быть использован для шифрования, сервер подписывает временный RSA-ключ, который затем пересылается. В экспортируемых приложениях, временный RSA-ключ должен иметь максимально возможную длину (т.e., 512 бит). Так как 512-битовые RSA-ключи имеют относительно низкую безопасность, они должны часто заменяться. Для обычных коммерческих применений предлагается, чтобы ключи заменялись ежедневно или после каждых 500 транзакций, или даже чаще, если это возможно. Заметим, что, так как допускается многократное использование временного ключа, он должен каждый раз при использовании подписываться.</p><p>Генерация ключа RSA является трудоемким процессом. Во многих случаях, процессу формирования ключа может быть приписан низкий фоновый приоритет. Как только сформирован новый ключ, старый временный ключ может быть заменен.</p><h3>D.2. Генерация псевдослучайных чисел и стартовые коды (Seeding)</h3><p>TLS требует наличия криптографически безопасного генератора псевдослучайных чисел (PRNG). Должны быть приняты меры для формирования стартовых кодов такого PRNG. Доступны генераторы PRNG, базирующиеся на безопасных хэш операциях, например, MD5 и/или SHA, но они не могут предоставить большую безопасность, чем та, которая определяется размером псевдослучайного генерируемого числа. (Например: генератор, базирующийся на MD5 обычно гарантирует безопасность на уровне 128 бит.)</p><p>Чтобы оценить необходимую длину порождающего кода, следует добавить несколько битов непредсказуемой информации к каждому байту порождающего кода. Например: времена нажатия клавиш, полученные от стандартного 18.2 кГц PC таймера, может бать 1-2 безопасных бита, но в любом случае размер этого кода должен быть не менее 16 бит. В качестве порождающего кода для 128-битового генератора PRNG может потребоваться приблизительно 100 таких таймерных кодов.</p><p>Функции порождающих кодов в RSAREF и в версиях BSAFE до 3.0 не имеют порядковой зависимости. Например: если предоставлены 1000 бит порождающего кода, по одному за раз в результате 1000 обращений к этой функции, PRNG окажется в состоянии, которое зависит только от числа 0 или 1 в порождающем коде (т.e., имеется 1001 возможных конечных состояний). Приложения, использующие BSAFE или RSAREF должны предпринимать дополнительные меры для обеспечения нужных порождающих кодов. Это может быть осуществлено путем накопления битов порождающего кода в буфере и обработки их как целое. Нужно только учитывать, что такие меры могут создать автокорреляции кодов.</p><h3>D.3. Сертификаты и аутентификация</h3><p>За верификацию целостности сертификата отвечает приложение, оно должно также поддерживать аннулирование сообщений, содержащих сертификат. Сертификаты должны всегда верифицироваться, чтобы гарантировать корректность подписи (СА). Выбор и добавление доверительных провайдеров сертификатов (СА) следует делать осмотрительно. Пользователи должны иметь возможность просмотреть информацию о сертификате и корневом провайдере сертификатов (CA).</p><h3>D.4. Шифровые наборы</h3><p>TLS поддерживает широкий диапазон размеров ключей и уровней безопасности, включая те, которые предоставляют минимальную или никакой безопасности. Корректная реализация не будет поддерживать много шифровых наборов. Например: 40-битовое шифрование легко ломается, поэтому приложения, требующие надежной безопасности, не должны разрешать применение 40-битовых ключей. Аналогично, анонимный алгоритм Diffie-Hellman не надежен, так как уязвим для атак 'посредников' (man-in-the-middle). Приложения должны накладывать также ограничения на минимальный и максимальный размер ключей. Например: сертификатные цепочки, содержащие 512-битные ключи RSA или подписи не могут считаться удовлетворительными для задач, требующих высокой безопасности.</p><h2 id="p.appendix.e">E. Совместимость с SSL</h2><p>По историческим причинам и для того чтобы избежать использования резервных номеров портов, прикладные протоколы, безопасность которых обеспечивается с помощью TLS 1.0, SSL 3.0, и SSL 2.0 часто используют один и тот же порт. Например: протокол HTTPS (HTTP с обеспечением безопасности за счет SSL или TLS) использует порт 443 вне зависимости от того, какой протокол безопасности применен. Таким образом, должен быть определен некоторый механизм согласования применения тех или иных протоколов.</p><p>TLS версии 1.0 и SSL 3.0 очень схожи. Клиенты TLS, которые желают согласовать применение SSL 3.0, должны посылать серверу сообщения client hello, используя формат записей SSL 3.0 и посылая {3, 1} в поле версии (TLS 1.0). Если сервер поддерживает только SSL 3.0, он откликнется server hello SSL 3.0. Если же он поддерживает TLS, то пришлет отклик TLS server hello. Дальнейшее согласование будет продолжено согласно с выбранным протоколом.</p><p>Аналогично, TLS-сервер, который хочет работать с клиентами SSL 3.0, должен воспринимать сообщения SSL 3.0 client hello и реагировать на server hello, если получено SSL 3.0 client hello с полем версии равным {3, 0}, означающим, что клиент не поддерживает TLS.</p><p>Всякий раз, когда клиент уже знает верхний протокол, известный серверу (например, когда возобновляется сессия), он должен инициировать соединение в рамках этого протокола.</p><p>Клиенты TLS 1.0, которые поддерживают работу с серверами SSL версии 2.0, должны посылать сообщения client hello SSL версии 2.0 [SSL2]. Серверы TLS должны воспринимать любой формат client hello, если они хотят поддерживать работу с клиентами SSL 2.0, на том же порту соединения. Единственное отклонение спецификации от версии 2.0 является возможность специфицировать версию со значением три и поддерживать больше шифровых типов в CipherSpec.</p><p>Возможность посылать сообщения client hello версии 2.0 следует исключить из употребления так быстро, как это возможно. Разработчики должны предпринять все меры, чтобы ускорить эти работы. Версия 3.0 предоставляет лучшие механизмы для введения новых версий.</p><p>Следующие шифровые спецификации являются переходными от SSL версии 2.0. Они предполагают использования RSA для ключевого обмена и аутентификации.</p><pre>V2CipherSpec TLS_RC4_128_WITH_MD5          = { 0x01,0x00,0x80 };
V2CipherSpec TLS_RC4_128_EXPORT40_WITH_MD5 = { 0x02,0x00,0x80 };
V2CipherSpec TLS_RC2_CBC_128_CBC_WITH_MD5  = { 0x03,0x00,0x80 };
V2CipherSpec TLS_RC2_CBC_128_CBC_EXPORT40_WITH_MD5
                                           = { 0x04,0x00,0x80 };
V2CipherSpec TLS_IDEA_128_CBC_WITH_MD5     = { 0x05,0x00,0x80 };
V2CipherSpec TLS_DES_64_CBC_WITH_MD5       = { 0x06,0x00,0x40 };
V2CipherSpec TLS_DES_192_EDE3_CBC_WITH_MD5 = { 0x07,0x00,0xC0 };</pre><p>Шифровые спецификации совместимые с TLS могут быть включены в сообщения client hello версии 2.0, используя описанный ниже синтаксис. Любой элемент V2CipherSpec с первым байтом равным нулю будет игнорироваться серверами версии 2.0. Клиенты, посылающие любую из перечисленных выше спецификаций V2CipherSpecs должны также включать и TLS-эквивалент (смотри приложение A.5):</p><pre>V2CipherSpec (see TLS name) = { 0x00, CipherSuite };</pre><h3>E.1. Hello клиента версия 2</h3><p>Сообщение client hello версии 2.0 представлены ниже. Истинные определения предполагаются совпадающими со спецификацией SSL версии 2.0.</p><pre>uint8 V2CipherSpec[3];

struct {
    uint8 msg_type;
    Version version;
    uint16 cipher_spec_length;
    uint16 session_id_length;
    uint16 challenge_length;
    V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
    opaque session_id[V2ClientHello.session_id_length];
    Random challenge;
} V2ClientHello;</pre><ul><li class="b">msg_type</li><li class="lib">Это поле, в сочетании с полем версии, идентифицирует сообщение client hello версии 2. Значение поля должно быть равно единице (1).</li><li class="b">Version</li><li class="lib">Высшее значение версии протокола, поддерживаемое клиентом (равно ProtocolVersion.version, смотри приложение A.1).</li><li class="b">cipher_spec_length</li><li class="lib">Это поле равно полной длине поля cipher_specs. Оно не может быть равно нулю и должно быть кратным длине V2CipherSpec (3).</li><li class="b">session_id_length</li><li class="lib">Это поле должно иметь значение нуль или 16. Если равно нулю, клиент формирует новую сессию. Если равно 16, поле session_id будет содержать 16 байт идентификации сессии.</li><li class="b">challenge_length</li><li class="lib">Длина в байтах обращения клиента к серверу, чтобы аутентифицировать себя. Это значение должно равняться 32.</li><li class="b">cipher_specs</li><li class="lib">Это список всех CipherSpecs, которые клиент хочет и может использовать. Здесь должна быть по крайней мере одна спецификация CipherSpec, приемлемая для сервера.</li><li class="b">session_id</li><li class="lib">Если длина этого поля не равна нулю, оно будет содержать идентификатор сессии, которую клиент хочет возобновить.</li><li class="b">Challenge</li><li class="lib">Обращение клиента к серверу с целью идентификации самого себя. Его значение представляет собой псевдослучайное число произвольной длины. Сервер TLS проверяет обращение клиента, чтобы получить данные ClientHello.random (дополненные лидирующими нулями, если это нужно), как это специфицировано в данном протоколе. Если длина обращения больше чем 32 байта, то используются только последние 32 байта. Допускается (но не обязательно) для сервера V3 отклонять V2 ClientHello, которые имеют меньше 16 байтов обращения клиента.</li></ul><p>Запросы возобновления TLS-сессии должны использовать сообщение TLS client hello.</p><h3>E.2. Избежание атак понижения версии посредником (man-in-the-middle)</h3><p>Когда клиенты TLS возвращаются к режиму совместимости с версией 2.0, они должны использовать специальное форматирование блоков PKCS #1. Это сделано так, что TLS-серверы будут отклонять сессии версии 2.0 с совместимыми TLS-клиентами.</p><p>Когда клиенты TLS работают в режиме совместимости с версией 2.0, они устанавливают правые случайные 8 байт (менее значимые) заполнителя PKCS (исключая завершающий нулевой заполнитель) для RSA-шифрования поля ENCRYPTED-KEY-DATA CLIENT-MASTER-KEY, равными 0x03 (остальные байты заполнителя содержат произвольные случайные значения). После дешифрования поля ENCRYPTED-KEY-DATA, серверы, которые получают блоки, заполненные по такой схеме, продолжают свою работу обычным образом.</p><h2 id="p.appendix.f">F. Анализ безопасности</h2><p>Протокол TLS создан для того, чтобы установить безопасное соединение между клиентом и сервером через канал не гарантирующий безопасность. В данном документе делаются несколько традиционных предположений, включая то, что атакующие имеют достаточно большие вычислительные ресурсы и не могут получить секретную информацию из источников, помимо протокольных. Предполагается, что атакующий может перехватить, модифицировать, уничтожать и подменить сообщения, посланные по коммуникационному каналу.</p><h3>F.1. Протокол диалога</h3><p>Протокол диалога несет ответственность за выбор CipherSpec и генерацию мастерного секретного кода (Master Secret), которые вместе являются первичными криптографическими параметрами, сопряженными с безопасной сессией. Протокол диалога может также аутентифицировать партнеров, которые имеют сертификаты, подписанные пользующимся доверием провайдером сертификатов.</p><h4>F.1.1. Аутентификация и обмен ключами</h4><p>TLS поддерживает три режима аутентификации: аутентификация обоих партнеров, аутентификация сервера не аутентифицированным клиентом, и полностью анонимная. Всякий раз, когда сервер аутентифицирован, канал безопасен со стороны атак 'посредника' (man-in-the-middle), по анонимные сессии полностью беззащитны для такого рода атак. Анонимные серверы не могут аутентифицировать клиентов. Если сервер аутентифицирован, его сообщение сертификата должно предоставить корректную сертификационную цепочку, ведущую к приемлемому провайдеру сертификатов. Аналогично, аутентифицированные клиенты должны предоставить приемлемый сертификат серверу. Каждый партнер ответственен за верификацию сертификата противоположной стороны, за его пригодность.</p><p>Общей целью процесса ключевого обмена является формирование pre_master_secret, известного партнерами обмена, но неизвестного хакерам. Код pre_master_secret будет использован для генерации master_secret (смотри раздел 8.1). Код master_secret необходим, чтобы сформировать сообщения верификации сертификата, шифровальных ключей, секретных кодов MAC финального сообщения (смотри разделы 7.4.8, 7.4.9 и 6.3). Путем посылки корректного финального сообщения (finished) партнеры подтверждают то, что они знают правильное значение pre_master_secret.</p><h4>F.1.1.1. Анонимный обмен ключами</h4><p>Полностью анонимные сессии могут быть реализованы с помощью ключевого обмена на основе алгоритмов RSA или Diffie-Hellman. При анонимном RSA, клиент шифрует pre_master_secret с помощью не сертифицированного общедоступного ключа сервера, полученного из его сообщения ключевого обмена. Результат посылается в сообщении ключевого обмена клиента. Так как злоумышленники не знают секретного ключа сервера, практически не реально для них дешифровать pre_master_secret. Заметим, что анонимные шифровые RSA-наборы в данном документе не определены.</p><p>В случае алгоритма Diffie-Hellman, общедоступные параметры сервера содержатся в его сообщении ключевого обмена, а параметры клиента посылаются в его сообщении ключевого обмена. Злоумышленники, которые не знают секретных ключей, не способны выполнить вычисления согласно алгоритму Diffie-Hellman и получить правильный результат (т.e. pre_master_secret).</p><p>Полностью анонимные соединения предоставляют защиту только против пассивных видов атак. Если только не используется надежно защищенный канал, позволяющий проверку того, что финальное сообщение не подменено злоумышленником, в ситуациях, где возможна активная атака 'посредника' (man-in-the-middle) необходима аутентификация сервера.</p><h4>F.1.1.2. Обмен ключами по схеме RSA с аутентификацией</h4><p>В случае RSA, ключевой обмен и аутентификация сервера совмещаются. Общедоступный ключ может содержаться в сертификате сервера или быть временным RSA-ключом, посланным в сообщении ключевого обмена сервера. Когда используются временные RSA-ключи, они подписываются сертификатом сервера RSA или DSS. Подпись включает текущее значение ClientHello.random, поэтому старые подписи и временные ключи не могут быть повторно использованы. Серверы могут использовать одиночный временный RSA-ключ для нескольких сессий.</p><p>Опция временного ключа RSA полезна, если серверы нуждаются в больших сертификатах, но вынуждены соглашаться с правительственными регламентациями для размеров ключей при ключевом обмене.</p><p>После проверки сертификата сервера, клиент шифрует pre_master_secret с помощью общедоступного ключа сервера. В случае успешной дешифровки pre_master_secret и выработки корректного финального сообщения, сервер демонстрирует, что он знает секретный ключ, соответствующий его сертификату.</p><p>Когда RSA используется для ключевого обмена, клиенты аутентифицируются, используя сообщение верификации сертификата (смотри раздел 7.4.8). Клиент подписывает значение, полученное из master_secret и все предыдущие сообщения диалога. Эти сообщения диалога включают сертификат сервера, который связывает подпись с сервером, и ServerHello.random, связывающий подпись с текущим процессом диалога.</p><h4>F.1.1.3. Обмен ключами по схеме Diffie-Hellman с аутентификацией</h4><p>Когда используется пересылка ключей по схеме Diffie-Hellman, сервер может либо предоставить сертификат, содержащий фиксированные параметры Diffie-Hellman, либо использовать сообщение ключевого обмена сервера, чтобы послать набор временных параметров, подписанных сертификатом DSS или RSA. Временные параметры хэшируются со значениями hello.random до формирования подписи, чтобы гарантировать, что злоумышленник не сможет воспользоваться старыми параметрами. В любом случае клиент может проверить сертификат или подпись, чтобы убедиться в том, что параметры принадлежат серверу.</p><p>Если клиент имеет сертификат, содержащий фиксированные параметры Diffie-Hellman, его сертификат содержит информацию, необходимую для ключевого обмена. Заметим, что в этом случае клиент и сервер получат один и тот же результат (т.e., pre_master_secret) каждый раз, когда они обмениваются информацией. Чтобы предотвратить пребывание в памяти pre_master_secret дольше, чем это требуется, этот код должен быть, как можно быстрее преобразован в master_secret. Параметры клиента Diffie-Hellman должны быть совместимыми с теми, что поставляются сервером для ключевого обмена.</p><p>Если клиент имеет стандартный сертификат DSS или RSA или он не аутентифицирован, тогда клиент посылает набор временных параметров серверу в сообщении ключевого обмена клиента, затем опционно использует сообщение верификации сертификата, чтобы аутентифицировать себя.</p><h4>F.1.2. Атаки понижения версии</h4><p>Так как TLS содержит существенные улучшения по сравнению с SSL версии 2.0, атакующие могут попытаться создавать TLS-совместимых клиентов и серверов, чтобы вернуться к версии 2.0. Эта атака может произойти, если (и только если) два TLS-совместимых партнера используют диалог в SSL 2.0.</p><p>Хотя решение, использующее неслучайное заполнение сообщения блока PKCS #1 типа 2, не является красивым, оно предоставляет безопасный путь для серверов версии 3.0, чтобы заметить такую атаку. Это решение не безопасно по отношению злоумышленников, которые могут попытаться подсунуть ключ и осуществить подмену сообщения ENCRYPTED-KEY-DATA, содержащего тот же ключ (но с нормальным заполнителем) до момента истечения порога ожидания, заданного приложением. Партнеры, озабоченные атаками этого типа, никогда не должны использовать 40-битовые ключи шифрования. Вариация заполнителя младших 8 байт PKCS не увеличивает безопасности, так как это просто эквивалентно увеличению размера входного блока на 8 байт.</p><h4>F.1.3. Регистрация атак против протокола диалога</h4><p>Атакующий может попытаться повлиять на диалоговый обмен, чтобы заставить партнеров выбрать другой алгоритм шифрования, отличный от того, который бы они выбрали сами. Так как многие реализации будут поддерживать 40-битовое экспортное шифрование, а некоторые могут даже поддерживать отсутствие шифрования или алгоритмы MAC, возможность такой атаки должна всегда учитываться.</p><p>Для этой атаки злоумышленник должен активно изменить одно или более сообщений диалога. Если это произойдет, клиент и сервер вычислят разные значения для хэшей сообщения диалога. В результате, партнеры не воспримут друг от друга финальные сообщения. Без master_secret, злоумышленник не может восстановить финальные сообщения, таким образом, факт атаки будет раскрыт.</p><h4>F.1.4. Возобновляемые сессии</h4><p>Когда соединение установлено путем возобновления сессии, новые значения ClientHello.random и ServerHello.random хэшируются вместе с master_secret сессии. Если установлено, что код master_secret не поврежден и что хэш-операции, использованные для получения ключей и секретных кодов MAC также безопасны, то соединение можно считать безопасным и независимым от предыдущих соединений. Атакующие не могут использовать известные ключи шифрования или секретные коды MAC, для того, чтобы скомпрометировать master_secret без нарушения исполнения операций хэширования.</p><p>Сессии не могут возобновляться, если только клиент и сервер не хотят этого. Если любой из партнеров подозревает, что сессия скомпрометирована, или что сертификаты не действительны, он должен потребовать полного диалога. Для верхнего предела времени жизни идентификатора сессии предлагается значение 24 часа, так как атакующий, получивший значение master_secret может подменить скомпрометированного партнера пока сохраняется старое значение ID-сессии. Приложения, которые могут работать в относительно небезопасной среде не должны записывать ID-сессии в постоянную память.</p><h4>F.1.5. MD5 и SHA</h4><p>TLS использует хэш-функции весьма консервативно. Где возможно, как MD5, так и SHA используются вместе для того, чтобы не катастрофические дефекты в одном алгоритме не приводили к разрушения всего протокола.</p><h3>F.2. Защита прикладных данных</h3><p>Код master_secret кэшируется с помощью ClientHello.random и ServerHello.random, чтобы получить уникальные ключи для шифрования данных и секретные коды MAC для каждого соединения. Исходящие данные перед посылкой защищаются с помощью MAC. Для того чтобы исключить атаки, связанные с модификаций или воспроизведения сообщений, из секретного кода MAC вычисляется MAC, номер по порядку, длина сообщения, содержимое сообщения и две фиксированные символьные строки. Поле типа сообщения необходимо, чтобы гарантировать то, что сообщения, предназначенные для одного клиента слоя записи TLS, не будут переадресованы другому. Номер по порядку гарантирует, что попытки уничтожить или поменять порядок сообщений будут детектированы. Так как номера по порядку имеют 64 бита, они не могут быть переполнены. Сообщения от одного партнера не могут быть вставлены в выходные сообщения другого, так как они используют независимые секретные коды MAC. Аналогично, ключи записи сервера и клиента независимы, так что ключи поточных шифров используются только раз.</p><p>Если атакующий расколол ключ шифрования, все сообщения, зашифрованные этим ключом, могут быть прочитаны. Аналогично, раскрытие ключа MAC может сделать возможной атаку, сопряженную с модификацией передаваемых сообщений. Так как MAC зашифрован, атаки модификации сообщений требуют также взлома и алгоритма шифрования.</p><p>Секретные коды MAC могут быть больше, чем ключи шифрования, поэтому сообщения могут оставаться устойчивы против повреждений, даже если взломаны ключи шифрования.</p><h2 id="p.appendix.g">G. Патентное заявление</h2><p>Следует иметь в виду, что применение ряда алгоритмов ограничено действующими патентами. К их числу относятся, например, SSL (патент США No. 5,657,390; Netscape). Существуют ограничения на коммерческое использование алгоритма RSA (RSA Data Security, Inc.). Политика компании Netscape в этой области достаточно либеральна.</p><p>Многие приложения допускают как использование SSL, так и TLS протокола. SSL и TLS при работе предполагают следующие шаги:</p><ol><li><p>Согласование использования того или иного протокола между клиентом и сервером. На этом этапе определяется и тип шифра, который будет использован при последующем обмене данными. При этом может быть согласовано применение либо симметричного, либо ассимметричного криптографического алгоритма.</p></li><li><p>По завершении согласования применения шифра осуществляется аутентификация сервера и формируется симметричный ключ, поторый будет использован при последующем обмене. Это делается с применением открытого ключа и сертификатов X.509. Сертификат получается от соответствующего сертификационного центра (СА), который проверяет идентичность сервера.</p><p>Это односторонняя аутентификация является единственно обязательной процедурой. Пользователь должен убедиться, что он работает с подлинным сервером, который ему нужен. После этого производится аутентификация пользователя с привлечением его имени и пароля, возможна и мультифакторная аутентификация.</p></li><li><p>Симметричный ключ, зашифрованный с помощью открытого ключа, посылается серверу. Открытый ключ для сервера включается в сертификат проверенный сертификационным центром. После того как симметричные ключи получены, все последующие данные шифруются посредством симметричного ключа. Это делается потому, что алгоритм с симметричным ключом работает быстрее. Работа продолжается до конца сессии или до завершения времени пригодности ключа.</p></li></ol><h2>Литература</h2><table itemprop="references"><tr><td>[3DES]</td><td>W. Tuchman, «Hellman Presents No Shortcut Solutions To DES», IEEE Spectrum, v. 16, n. 7, Июль 1979, pp40-41.</td></tr><tr><td>[BLEI]</td><td>Bleichenbacher D., «Chosen Ciphertext Attacks against Protocols Based on RSA Encryption Standard PKCS #1» in Advances in Cryptology — CRYPTO'98, LNCS vol. 1462, pages: 1-12, 1998.</td></tr><tr><td>[DES]</td><td>ANSI X3.106, «American National Standard for Information Systems-Data Link Encryption», American National Standards Institute, 1983.</td></tr><tr><td>[DH1]</td><td>W. Diffie and M. E. Hellman, «New Directions in Cryptography», IEEE Transactions on Information Theory, V. IT-22, n. 6, Jun 1977, pp. 74-84.</td></tr><tr><td>[DSS]</td><td>NIST FIPS PUB 186, «Digital Signature Standard», National Institute of Standards and Technology, U.S. Department of Commerce, May 18, 1994.</td></tr><tr><td>[RFC959]</td><td>Postel J., and J. Reynolds, «File Transfer Protocol», STD-9, RFC-959, October 1985.</td></tr><tr><td>[RFC1945]</td><td>Berners-Lee, T., Fielding, R., and H. Frystyk, «Hypertext Transfer Protocol — HTTP/1.0», RFC-1945, Май 1996.</td></tr><tr><td>[RFC2104]</td><td>Krawczyk, H., Bellare, M., and R. Canetti, «HMAC: Keyed-Hashing for Message Authentication», RFC-2104, Февраль 1997.</td></tr><tr><td>[IDEA]</td><td>X. Lai, «On the Design and Security of Block Ciphers», ETH Series in Information Processing, v. 1, Konstanz: Hartung-Gorre Verlag, 1992.</td></tr><tr><td>[RFC1319]</td><td>Kaliski, B., «The MD2 Message Digest Algorithm», RFC-1319, Апрель 1992.</td></tr><tr><td>[RFC1321]</td><td>R. Rivest, <a href="../1321.rfc" title="RFC 1321 - Алгоритм цифровых подписей MD5">«Алгоритм цифровых подписей MD5», RFC 1321</a>, Апрель 1992.</td></tr><tr><td>[PKCS1]</td><td>RSA Laboratories, «PKCS #1: RSA Encryption Standard», version 1.5, Ноябрь 1993.</td></tr><tr><td>[PKCS6]</td><td>RSA Laboratories, «PKCS #6: RSA Extended Certificate Syntax Standard», version 1.5, Ноябрь 1993.</td></tr><tr><td>[PKCS7]</td><td>RSA Laboratories, «PKCS #7: RSA Cryptographic Message Syntax Standard», version 1.5, Ноябрь 1993.</td></tr><tr><td>[RFC2459]</td><td>Housley, R., Ford, W., Polk, W. и D. Solo, «Internet Public Key Infrastructure: Part I: X.509 Certificate and CRL Profile», RFC-2459, Январь 1999.</td></tr><tr><td>[RFC2268]</td><td>Rivest, R., «A Description of the RC2(r) Encryption Algorithm», RFC 2268, Январь 1998.</td></tr><tr><td>[RC4]</td><td>Thayer, R. и K. Kaukonen, A Stream Cipher Encryption Algorithm, Work in Progress.</td></tr><tr><td>[RSA]</td><td>R. Rivest, A. Shamir, and L. M. Adleman, «A Method for Obtaining Digital Signatures and Public-Key Cryptosystems», Communications of the ACM, v. 21, n. 2, Feb 1978, pp. 120-126.</td></tr><tr><td>[RSADSI]</td><td>Contact RSA Data Security, Inc., Tel: 415-595-8782</td></tr><tr><td>[SCH]</td><td>B. Schneier. Applied Cryptography: Protocols, Algorithms, and Source Code in C, Published by John Wiley & Sons, Inc. 1994.</td></tr><tr><td>[SHA]</td><td>NIST FIPS PUB 180-1, «Secure Hash Standard», National Institute of Standards and Technology, U.S. Department of Commerce, Work in Progress, May 31, 1994.</td></tr><tr><td>[SSL2]</td><td>Hickman, Kipp, «The SSL Protocol», Netscape Communications Corp., Feb 9, 1995.</td></tr><tr><td>[SSL3]</td><td>A. Frier, P. Karlton, and P. Kocher, «The SSL 3.0 Protocol», Netscape Communications Corp., Nov 18, 1996.</td></tr><tr><td>[RFC793]</td><td>J. Postel, <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">«Протокол управления передачей (TCP)», RFC 793</a>, Сентябрь 1981.</td></tr><tr><td>[RFC854]</td><td>Postel J., and J. Reynolds, «Telnet Protocol Specifications», STD-8, RFC-854, Май 1993.</td></tr><tr><td>[RFC855]</td><td>Postel J., and J. Reynolds, «Telnet Option Specifications», STD-8, RFC-855, Май 1993.</td></tr><tr><td>[X509]</td><td>CCITT. Recommendation X.509: «The Directory — Authentication Framework». 1988.</td></tr><tr><td>[RFC1832]</td><td>R. Srinivansan, Sun Microsystems, RFC-1832: XDR: External Data Representation Standard, Август 1995.</td></tr></table><p>Архивы по рассматриваемой тематике смотрите на сервере: http://www.imc.org/ietf-tls/mail-archive/</p><h2>Адреса авторов</h2><p>Christopher Allen<br />Certicom<br />EMail: <bdo dir="rtl">&#109;&#111;&#99;&#46;&#109;&#111;&#99;&#105;&#116;&#114;&#101;&#99;&#64;&#110;&#101;&#108;&#108;&#97;&#99;</bdo></p><p>Tim Dierks<br />Certicom<br />EMail: <bdo dir="rtl">&#109;&#111;&#99;&#46;&#109;&#111;&#99;&#105;&#116;&#114;&#101;&#99;&#64;&#115;&#107;&#114;&#101;&#105;&#100;&#116;</bdo></p></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 2246 - Протокол TLS 1.0",disqus_identifier="2246.rfc",disqus_url="http://rfc2.ru/2246.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>