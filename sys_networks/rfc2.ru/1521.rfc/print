<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../1521.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 1521 — Почтовый стандарт MIME</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../1521.rfc">RFC 1521 — Почтовый стандарт MIME</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 1521</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank"><span itemprop="alternativeHeadline">MIME - Multipurpose Internet Mail Extensions</span></a></dd><dd><div class="icon i7"></div> Другие версии: RFC 1341, <strong class="obsoleted_by">RFC 2045</strong>, <strong class="obsoleted_by">RFC 2046</strong>, <strong class="obsoleted_by">RFC 2047</strong>, <strong class="obsoleted_by">RFC 2048</strong>, <strong class="obsoleted_by">RFC 2049</strong></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Проект стандарта</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1993-09-01">Сентябрь 1993</time></dd><dd><div class="icon i5"></div> Авторы: <span itemprop="author">N. Borenstein</span>, <span itemprop="author">N. Freed</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Антон Воронин</span></dd></dl><div id="text" itemprop="articleBody"><p>Документ предсталяет собой неполный русский перевод спецификации RFC 1521 "MIME — Multipurpose Internet Mail Extensions. Part one. Mechanismes for Specifying and Describing the Format of Internet Message Bodies", а также конспект некоторых других документов, касающихся применения стандарта MIME.</p><p>MIME означает "Multipurpose Internet Mail Extensions" (Многоцелевые расширения почтового стандарта Internet). Этот стандарт описывает как пересылать по электронной почте исполняемые, графические, мультимедийные, смешаные данные. Типичные применения MIME — пересылка графических изображений, аудио, документов Word, программ и даже просто текстовых файлов, то есть, когда важно, чтобы входе пересылки не производилось никаких преобразований над данными. MIME также позволяет размечать письмо на части различных типов так, чтобы получатель (почтовая программа) мог определить, что делать с каждой из частей письма.</p><p>Как читать письма в стандарте MIME? Т.к. MIME используется всего несколько лет, еще существуют старые почтовые программы, которые не понимают MIME. Однако, растет число почтовых программ, имеющих встроенную поддержку MIME (одна из самых популярных — "Pine", разработанная в Вашингтонском университете и реализованная для платформ UNIX, VMS, DOS, Windows). К тому же в некоторых почтовых системах имеются специальные шлюзы, обеспечивающие MIME-трансляцию. Но даже если у вас нет возможности использовать MIME-совместимую почтовую программу и нет доступа к подобному шлюзу, то можно также воспользоваться рядом программ, способных интерпретировать письма в MIME, сохраненные рпочтовой программой в файле. Например, програма "munpack", созданная в университете Carnegie Mellon. Существуют ее версии для Unix, PC, Macintosh, Amiga.</p><p>Долгое время для кодирования бинарных файлов в 7-битный формат (чтобы обеспечить их пересылку по почтовой системе Internet) использовалась кодировка UUENCODE, имеющая ряд технических ограничений. Стандарт MIME предполагает использовние более устойчивой кодировки "Base64", которая специально разработана для обеспечения сохранности данных, пересылаемых по email, при различных преобразованиях, имиеющих место в ходе прохождения почтовых шлюзов.</p><h2>Оглавление</h2><ul class="map"><a href="print#p"><li><a href="print#p1">1. Введение</a></li><li><a href="print#p2">2. Замечания, соглашения и обобщения</a></li><li><a href="print#p3">3. Поле заголовка 'MIME-Version'</a></li><li><a href="print#p4">4. Поле заголовка 'Content-Type'</a></li><li><a href="print#p5">5. Поле заголовка 'Content-Transfer-Encoding'</a></li><li class="lia"><a href="print#p5.1">5.1. Механизм конвертации "Quoted-Printable"</a></li><li class="lia"><a href="print#p5.2">5.2. Механизм конвертации Base64</a></li><li><a href="print#p6">6. Дополнительные поля 'Content-'</a></li><li class="lia"><a href="print#p6.1">6.1. Необязательное поле заголовка 'Content-ID'</a></li><li class="lia"><a href="print#p6.2">6.2. Необязательное поле заголовка 'Content-Description'</a></li><li><a href="print#p7">7. Предопределенные значения поля 'Content-Type'</a></li><li class="lia"><a href="print#p7.1">7.1. Тип 'Text'</a></li><li class="lib"><a href="print#p7.1.1">7.1.1. Параметр 'charset'</a></li><li class="lib"><a href="print#p7.1.2">7.1.2. Подтип 'Text/plain'</a></li><li class="lia"><a href="print#p7.2">7.2. Тип 'Multipart'</a></li><li class="lib"><a href="print#p7.2.1">7.2.1. Тип Multipart: общий синтаксис</a></li><li class="lib"><a href="print#p7.2.2">7.2.2. Подтип 'Multipart/mixed' (основной)</a></li><li class="lib"><a href="print#p7.2.3">7.2.3. Подтип 'Multipart/alternative'</a></li><li class="lib"><a href="print#p7.2.4">7.2.4. Подтип 'Multipart/digest'</a></li><li class="lib"><a href="print#p7.2.5">7.2.5. Подтип 'Multipart/parallel'</a></li><li class="lib"><a href="print#p7.2.6">7.2.6. Друтие подтипы типа 'Multipart'</a></li><li class="lia"><a href="print#p7.3">7.3. Тип 'Message'</a></li><li class="lib"><a href="print#p7.3.1">7.3.1. Подтип 'Message/rfc822' (основной)</a></li><li class="lib"><a href="print#p7.3.2">7.3.2. Подтип 'Message/Partial'</a></li><li class="lib"><a href="print#p7.3.3">7.3.3. Подтип 'Message/External-Body'</a></li><li class="lic"><a href="print#p7.3.3.1">7.3.3.1. Способы доступа "ftp" и "tftp"</a></li><li class="lic"><a href="print#p7.3.3.2">7.3.3.2. Способ доступа "anon-ftp"</a></li><li class="lic"><a href="print#p7.3.3.3">7.3.3.3. Способы доступа "local-file" и "afs"</a></li><li class="lic"><a href="print#p7.3.3.4">7.3.3.4. Способ доступа "mail-server"</a></li><li class="lic"><a href="print#p7.3.3.5">7.3.3.5. Примеры и дополнительные пояснения</a></li><li class="lia"><a href="print#p7.4">7.4. Тип 'Application'</a></li><li class="lib"><a href="print#p7.4.1">7.4.1. Подтип 'Application/Octet-Stream' (основной)</a></li><li class="lib"><a href="print#p7.4.2">7.4.2. Подтип 'Application/PostScript'</a></li><li class="lib"><a href="print#p7.4.3">7.4.3. Другие подтипы типа 'Application'</a></li><li class="lia"><a href="print#p7.5">7.5. Тип 'Image'</a></li><li class="lia"><a href="print#p7.6">7.6. Тип 'Audio'</a></li><li class="lia"><a href="print#p7.7">7.7. Тип 'Video'</a></li><li class="lia"><a href="print#p7.8">7.8. Экспериментальные значения поля 'Content-Type'</a></li><li><a href="print#p.ii">II. Применение возможностей MIME в транспортных почтовых системах</a></li><li class="lia"><a href="print#p.ii.1">II.1. Непринятая почта</a></li><li class="lia"><a href="print#p.ii.2">II.2. Разбиение (фрагментация) и сборка больших писем</a></li><li class="lia"><a href="print#p.ii.3">II.3. Использование или удаление указателей External-Body (внешнего тела)</a></li><li class="lia"><a href="print#p.ii.4">II.4. Преобразование графических и других форматов</a></li><li class="lia"><a href="print#p.ii.5">II.5. Надежное кодирование данных</a></li><li><a href="print#p.references">Ссылки</a></li></ul><h2 id="p1">1. Введение</h2><p>Со времени опубликования в 1982 г., стандарт RFC 822 определил и полностью или частично внедрил формат текстовых писем в почтовой системе Internet. Но с расширением его использования, обнаружился ряд ограничений, заметно ограничивающих удовлетворение пользовательских потребностей. В частности, возможность пересылки нетекстовых данных, например, аудио и графики, посто не была упомянута в RFC 822, описывавшем лишь формат текстовых сообщеий. И даже в случае текста, RFC 822 обошел вниманием нужды пользователей, использующих расширенный набор символов, что характерно для азиатских и большинства европейских языков. Итак, требовалась дополнительная спецификация. Основное ограничение RFC 822 — относительно короткие строки и 7-битная символьная таблица. Пользователям дляотправки нетекстовых данных приходилось конвертировать тело своего письма в 7-битную форму с помощью UUENCODE, BINHEX и др.</p><p>Более очевидными стали ограничения RFC 822 при разработке почтовых шлюзов между хостами, использующими стандарт RFC 822 и хостами, использующими стандарт X.400. X.400 имеет механизмы для включения нетекстовых данных в тело письма. В настоящее время стандарты для перевода почтовых сообщений из X.400 в RFC 822 предполагают, что нетекстовые части тела письма должны быть сконвертированы (но не закодированы) в ASCII формат, либо должны быть "выброшены" из письма с уведомлением об этом получателя. А потеря информации крайне не желательна для пользователя.</p><p>MIME разработан как расширяемый механизм с расчетом на то, что набор пар content-type/subtype будет расти со временем. Некоторые другие поля заголовка MIMЕ, включая имена наборов символов, также, вероятно, получат большее число возможных значений. С этой целью MIME определяет процесс регистрации через Internet Assigned Numbers Authority (IANA), как центр регистрации этих значений. Описание процесса регистрации можно найти в приложении E RFC 1521.</p><h2 id="p2">2. Замечания, соглашения и обобщения</h2><p>Термины "сообщение" и "письмо" являются синонимами. Термин "часть письма" или "часть тела письма" подразумевает одну из частей письма, разбитого на части разных типов данных. Часть тела письма, в свою очередь, имеет тело и заголовок, так что имеет смысл говорить о теле части тела письма. В дальнейшем, при отсутствии оговорок, "телом" будем называть тело рассматриваемого в данный момент объекта — части письма либо всего письма. Как уже ясно, формат MIME-сообщения, в общем случае, рекурсивен.</p><h2 id="p3">3. Поле заголовка "MIME-Version"</h2><p>Поскольку старый стандарт RFC 822 все еще используется, а MIME возможно, изменится и дополнится в будущем, почтовой программе необходимо знать, применен ли новый стандарт в конкретном письме или нет. Поэтому в заголовок ввелено новое поле "MIME-Version", объявляющее версию стандарта, в соответствии с которым написано данное письмо.</p><p>Все почтовые сообщения, составленные в соответствии с MIME-стандартом, должны иметь это поле в своем заголовке, напрмер:</p><pre>MIME-Version: 1.0</pre><p>Так как возможно, в будущем формат заголовка письма может расшириться, формально содержание поля "MIME-version" дается следующим образом:</p><pre>версия := "MIME-Version" ":" 1*DIGIT "." 1*DIGIT</pre><p>Т.о., будущие значения версии формата, коорые могут заменить "1.0", должны быть целыми числами, разделенными точкой. Если письмо получено со значением версии MIME, отличным от "1.0", оно не будет рассматриваться почтовой программой, как соответствующее данной спецификации.</p><p>Важно, что поле заголовка "MIME-Version", должно располагаться в самам начале письма. Это не обязательно для каждой из частей тела письма в случае многочастевого письма, но обязательно для заголовков частей типа "message", если и только если эта часть сама по себе декларирована как соответствующая спецификации MIME.</p><p>Не возможно полностью определить как почтовая программа, поддерживающая MIME, должна интерпретировать письмо, имеющее значение MIME-version, отличное от "1.0". Но, как минимум, почтовая программа должна предупредить пользователя о том, что письмо написано в незнакомом ей формате.</p><p>Все поля заголовка, включая MIME-Version, Content-type, и т.д., должны соответствовать общим синтаксическим правилам, определенным в RFC 822. В частности, допускается включение комментариев (т.е., следующие 2 примера эквивалентны):</p><pre>MIME-Version: 1.0
MIME-Version: 1.0 (Generated by GBD-killer 3.7)</pre><h2 id="p4">4. Поле заголовка "Content-Type"</h2><p>Назначение этого поля — наиболее полное описание данных, содержащихся в теле, с тем, чтобы почтовый агент (программа) получателя могла выбрать соответствующий механизм для их обаботки. Впервые это поле было определено в RFC 1049, но имело более простой синтаксис.</p><p>Данное поле включает в себя идентификаторы типа и подтипа, а также может содержать некоторую вспомогательную информацию, которая может потребоваться для конкретного типа данных. После идентификаторов типа и подтипа оставшаяся часть поля — просто набор парамеров, заданных в порядке "атрибут/значение". Набор параметров зависит от типа данных. (В частности, не может быть глобально-значимых параметров, справедливых сразу для всех типов содержимого ьела письма. Глобальные механизмы в MIME-модели реализованы с помощью введения дополнительных полей "Content-*"). Очередность параметров значения не имеет. В числе определенных параметров — "charset", декларирующий символьный набор (кодировку, кодовую страницу — это все синонимы) тела письма. Комментарии допускаются.</p><p>Вообще, поле Content-Type самого верхнего уровня используется для объявления общего типа данных, в то время как подтип определяет специальный формат для данных этого типа. Так, значение "image/xyz" поля Content-Type сообщает пользовательской программе, что данные являются графическим изображением (image), даже если эта почтовая программа не имеет понятия о специальном формате "xyz" этой картинки. Но эта информация может быть использована программой, например, чтобы решить, показывать ли пользователю строкоые данные неизвестного подтипа — показ таких данных может быть оправдан для незнакомых подтипов текста, но не для незнакомых подтипов графики, аудио или видео. По этой причине, данные зарегистрированного подтипа аудио, графики, текста или видео не должны содержать внутри себя части другого подтипа — для содержания в письме данных одного типа, но разных подтипов следует использовать тип "multipart" или "application".</p><p>Хотя многие параметры (модификаторы подтипов) имеют смысл лишь для конкретного типа, некоторые все же являются глобальными в том смысле. что они применимы ко всем типам (например, параметр "boundary" применим только с типом "multipart", а параметр "charset" может использоваться с несколькими типами).</p><p>Пока имен типов только семь, и пока этого достаточно. Кроме того, предполагается, что расширение существующего набора поддерживаемых типов данных будет производиться засчет введения новых подтипов этих изначально определенных типов данных. В будущем добавление имен типов верхнего уровня может быть произведено только при принятии новой версии стандарта MIME. Если по какой-либо другой причине в существующей версии используется незарегестрированный тип содежимого, ему должно быть дано имя, начинающееся с "X-", чтобы подчеркнуть его нестандартный статус и заранее предупредить конфликт с официальным именем типа, которое может быть введено позднее.</p><p>Правильное заполнение поля Content-Type:</p><pre>содержимое := "Content-Type"  ":"  тип  "/"  подтип  *(";" параметр)
             ; нечувствительное к регистру букв задание типа и подтипа

тип :=     "application"     / "audio"
         / "image"           / "message"
         / "multipart"       / "text"
         / "video"           / признак нестандартного типа
         ; Все значения нечувствительны к регистру букв

признак нестандартного типа :=  x- / iana-

iana- := &lt;общепринятый признак расширения, зарегистрированный соответ-
          ственно приложению "E" RFC 1521>

x- := &lt;Два последовательных символа "X-" или "x-", без пробела
       или другого символа между ними&gt;

подтип := слово    ; регистр безразличен

параметр := атрибут "=" значение

атрибут := слово   ; регистр безразличен

значение := слово / строка в кавычках

слово := любые ASCII-символы кроме  пробелов,  Ctrl-последова-
тельностей и специальных символов

Специальные символы:=  "(" / ")" / "&lt;" / "&gt;" / "@"
                    /  "," / ";" / ":" / "\" / &lt;"&gt;
                    /  "/" / "[" / "]" / "?" / "="
; Эти символы используются в строке значений параметров</pre><p>Здесь набор специальных символов отличается от набора, определенного в RFC 822 только наличием символов "/", "?", "=" и отсутствием символа ".".</p><p>Указание подтипа в данном поле является обязательным, т.к. нет подтипов по умолчанию. В отличие от имен типов, подтипов и параметров, значения параметров в общем случае являются чувствительными к регистру букв, но могут быть и нечувствительными — в зависимости от параметра. Например, значения границ multipart-письма являются чувствительными, а значение "access-type" для message/External-body не является.</p><p>Существует два приемлимых механизма для введения новых подтипов для поля Content-Type:</p><ol><li>Нестандартные значения (начинающиеся с "X-") могут быть опредлены по договоренности для двух или более общающихся друг с другом почтовых агентов (программ) без какой-либо внешней регистрации и стандартизации.</li><li>Новые стандартные значения подтипов должны быть документированы, зарегистрированы и опробованы в IANA, как описано в приложении "E" RFC 1521. Если новй подтип предлагается для широкого использования, формат, описываемый им, должен быть описан в опубликованной спецификации и, возможно, предложен к стандартизации.</li></ol><p>Семь предопределенных типов верхнего уровня, более детально, представляют собой следующее:</p><p><strong>text</strong> — текстовая информация. Основой подтип — "plain" — соответствует обычному неформатировнному тексту и не требует специального программного обеспечения для отображения этого текста за исключением поддержки национальных кодировок. Другие подтипы используются в случае размеченного текста, когда с помощью специальной программы можно улучшить его визуалзацию, но для понимания идеи содержания можно обойтись и без дполнительного ПО. Возможные подтипы могут описывать легкочитаемые форматы различных текстовых процессоров.</p><p><strong>multipart</strong> — содержимое письма состоит из некоторого множества частей, содержащих данные различных взаимонезависимых типов. Изначально определено четыре подтипа:</p><ol><li><strong>"mixed"</strong> — основной;</li><li><strong>"alternative"</strong> — для представления одних и тех же данных в разных форматах;</li><li><strong>"parallel"</strong> — если разные части документа должны просматриваться одновременно;</li><li><strong>"digest"</strong> — если каждая из частей тела письма имеет тип "message".</li></ol><p><strong>message</strong> — письмо в письме. Тело, содержащее данные типа "message", само является письмом или частью письма, полностью отформатированного в соответствии со стандартом RFC 822, которое, в свою очередь, может содержать свое собственное поле заголовка "Content-Type".<br />Подтипы:</p><ol><li><strong>"rfc822"</strong> — основной;</li><li><strong>"partial"</strong> — определен для частично-цитируемых писем для предотвращения фрагментирования тел содержащихся писем в случае слишком большой их общей длины для возможностей почтового транспорта;</li><li><strong>"External-body"</strong> — используется, чтобы указать, что тело письма очень большое и находится вне письма.</li></ol><p><strong>image</strong> — графические данные. Графика требует соответствующего устройства вывода (графический дисплей, принтер, факс) для отображения своей информации. Изначально определены два подтипа для наиболее распространенных графических форматов — jpeg и gif.</p><p><strong>audio</strong> — звуковая информация. Требует звуковое устройство (динамик или наушники) для вывода информации. Основной подтип — "basic".</p><p><strong>video</strong> — видео. Требует специальных аппаратных и программных возможностей для отображения видео-информации. Единстванный изначально определенный подтип — "mpeg".</p><p><strong>application</strong> — как правило, неинтерпретируемый двоичный код либо информация, предназначенная для обработки почтовой программой.<br />Подтипы:</p><ul><li><strong>"octet-stream"</strong> — основной подтип; предназначен для неинтерпретируемых двоичных данных, для которых рекомендуемым действием является предложение пользователю сохранить в файл на диске.</li><li><strong>"PostScript"</strong> — дополнительный подтип; применяется при пересылке PostScript-документов в теле письма.</li></ul><p>По умолчанию, письма, как и в стандарте RFC 822 пишутся простым (неразмеченным) текстом в языковой кодировке US-ASCII, что по спецификации MIME может быть описано как "Content-type: text/plain; charset=us-ascii". Это значение полагается, если поле Content-type не определено. Поэтому почтовая программа получателя может неверно истолковать содержимое письма, если при отправке не было указано поле Content-type, но на самом деле текст письма имеет другую кодировку или даже тип.</p><p>При отсутствии поля Content-type или поля MIME-Version в заголовке MIME-письма нельзя быть точно уверенным, что письмо имеет языковую кодировку именно US-ASCII, поскольку могут еще встречаться почтовые программы, не использующие соглашения MIME. Но хотя возможно, что письмо, не содержащее в заголовке полей MIME-Version и Content-Type, может содержать все, что угодно, например, юниксовский tar-архив, сжатый gzip'ом и обработаный uuencode, все же, создателям почтовых программ рекомендуется оставлять этот факт без внимания и ориентироваться на значение по умолчанию, т.е. "text/plain; charset=us-ascii".</p><p>Необходимо учесть, что в будущем ожидается заметное увеличение числа регистрированных типов и особенно подтипов содержимого писем. Если почтовая программа встретит неизвестное ей значение поля Content-type, она должна интерпретировать содержимое этого письма как "application/octet-stream" (см.выше).</p><h2 id="p5">5. Поле заголовка Content-Transfer-Encoding</h2><p>Многие типы данных, пересылаемых через email требуют "натурального" представления, то есть, 8-битный набор символов либо двоичный код (что для машины — одно и то же, только представимо для пользователя по-разному). В таком виде данные не могут быть пересланы по 7-битным почтовым протоколам, например, RFC 821, который, к тому же, ограничивает длину строки 1000 символами.</p><p>Стандартные механизмы конвертирования почты в 7-битный короткострочный формат, приемлимый для почтового транспорта, описывает поле заголовка Content-Transfer-Encoding.</p><p>В отличие от типов содержимого, увеличение множества значений Content-Transfer-Encoding не является необходимым и даже нежелательно. Но установление единого механизма конвертирования не представляется возможным. Существует противоречие между желанием эффективно "ужать" бинарные данные и желанием трансформировать данные, которые, хотя бы частично являются 7-битным текстом, так, чтобы их все-таки можно было читать. По этой причине необходимы по крайней мере 2 механизма конвертации: "читабельный" и "плотно ужимающий".</p><p>Данное поле не было определено в предыдущих стандартах. Его значение должно быть строкой без пробелов, определяющей тип конвертации, как показано ниже:</p><pre>конвертация := "Content-Transfer-Encoding" ":" механизм

механизм :=     "7bit"  ;
               / "quoted-printable"
               / "base64"
               / "8bit"
               / "binary"
               / x-token</pre><p>Значения не чувствительны к регистру букв, то есть, Base64, BASE64 и bAsE64 — одно и то же. Значение "7BIT" означает, что тело письма уже имеет 7-битный формат и не тренбует дополнительной обработки для пересылки по почте. Это значение полагается по умолчанию, если поле заголовка Content-Transfer-Encoding отсутствует.</p><p>Значения "8bit", "7bit" и "binary" означают, что никакой трансформации содержимого не производится. Однако, они сделаны различными для индикации того, что из себя представляет содержимое письма, и, соответственно, способа обработки, который может потребоваться для данной транспортной системы. В частности:</p><p><strong>"7bit"</strong> означает, что данные являются текстом, имеют короткие строки и языковую кодировку US-ASCII.</p><p><strong>"8bit"</strong> означает короткие строки, но в них могут содержаться не-ASCII символы (128-255).</p><p><strong>"Binary"</strong> означает, что тело письма может содержать не-ASCII символы, но строки могут быть произвольной длины, т.е. слишком длинными для SMTP-транспорта, и может несоблюдаться соглашение по признаку конца строки (CRLF), принятое в SMTP-транспорте.</p><p>Хотя на первый взгляд разница в значениях Content-Transfer-Encoding может показатся неважной — ведь все они означают, что никакого преобразования нет, но четкая разметка важна для почтовых шлюзов между разными почтовыми системами, имеющими разные возможности и особенности работы, число которых со временем растет.</p><p>Спецификация на почтовый транспорт для пересылки некодированных 8-битных данных дана в RFC-1426. Однако, нет стандартизованных транспортов рочты Internet, для которых является приемлимым включение в тело письма некодированных двоичных данных. Таким образом, значение "binary" фактически не является легальным в Internet. Но в соответствии с MIME, при использовании почтовой системой транспорта, умеющего работать с двоичными данными, в случае, когда необходимо послать двоичные данные по e-mail, необходимо указать это в заголовке в поле Content-Transfer-Encoding.</p><p>Пять значений, определенных для поля Content-Transfer-Encoding, ничего не говорят о типе содержимого кроме указания алгоритма кодирования либо требований к почтовому транспорту в случае некодированных данных.</p><p>Производители почтового ПО, если необходимо, могут определить новые значения поля Content-Transfer-Encoding, но эти значения должны иметь префикс "X-" ("x-"), чтобы подчеркнуть их нестандартный характер. Однако, в отличие от типов и подтипов поля Content-Type, введение новых значений Content-Transfer-Encoding настоятельно не рекомендуется, так как может оказаться помехой для взаимосовместимости почтовых систем. Использование X-значений позволяется только как результат взаимосоглашения между взаимодействующими системами.</p><p>Если поле Content-Transfer-Encoding появляеися в заголовке тела какой-то части письма, оно применяется только к содержимому этой части. Если письмо (часть письма) имеет тип "multipart" или "message", то поле Content-Transfer-Encoding может иметь в качестве своего значения только длину символа ("7bit", "8bit" и т.д.) или "binary".</p><p>Необходимо заметить. что электронная почта является символьно-ориентированной, так что механизмы конвертации работают с данными как с потоком символов, а не битов. Если битовый поток должен быть кодирован посредством какого-либо из этих механизмов, сначала он должен быть конвертирован в 8-битный поток байтов, используя порядок битов, стандартный для сетей (старшие разряды в конце). То есть, передние биты в потоке становятся битами высшего порядка в байте. Если битовый поток оканчивается неполным байтом, недостающие разряды заполняются нулями.</p><p>Все кодирующие механизмы, определенные в спецификации MIME, кодируют любые данные в символьную форму. Так, к примеру, полагая, что тело письма (части письма) имеет поля заголовка вроде:</p><pre>Content-Type: text/plain; charset=ISO-8859-1
Content-transfer-encoding: base64</pre><p>то это означает, что тело письма представляет собой ASCII-код base64 текстовых данных, которые в нормальном виде имеют языковую кодировку ISO-8859-1, и будут в этой языковой кодировке после декодирования.</p><p>Все множество определенных значений поля content-transfer-encoding кроме начинающихся с префикса "X-", зарезервировано в IANA для будущего использования. Частные соглашения по значениям content-transfer-encoding также настоятельно не рекомендуются.</p><p>Некоторые значения Content-transfer-encoding могут использоваться только с определенными типами (поле Content-Type). В частности, запрещено использовать любые значения кроме "7bit", "8bit", или "binary" с любым типом, рекурсивно включающим заголовки с полем Content-Type (как правило, это типы "multipart" и "message"). Все кодирования, необходимые для содержимого тел многочастного письма должны быть произведены на более низком уровне.</p><p class="note">Замечания по ограничениям конвертации: Необходимо предотвращать случаи вложенного кодирования, когда данные проходят через алгоритм конвертации несколько раз и должны столько же раз быть декодированы, чтобы быть читаемыми. Вложенное кодирование добавляет сложностей пользовательским почтовым программам: кроме очевидных проблем с множественной конвертацией, они могут скрыть основную структуру письма. В частности, они могут привести к тому, что несколько операций по декодированию могут потребоваться только для того, чтобы определить, объекты каких типов находятся в письме. Запрещение вложенного кодирования может осложнить работу некоторых почтовых шлюзов, но это будет меньшей проблемой по сравнению с трудностями для пользовательских почтовых программ.</p><p class="note">Замечание по переводу кодов: Конверторы quoted-printable и base64 разработаны так, что данные после их применения легко взаимоконвертируемы. Единственный нюанс, возникающий в подобной ретрансляции — признак конца строки. При конвертации из quoted-printable в base64 перевод строки должен быть заменен последовательностью CRLF. Соответственно и наоборот, но ТОЛЬКО при конвертации текстовых данных.</p><h3 id="p5.1">5.1. Механизм конвертации "Quoted-Printable"</h3><p>Этот механизм предназначен для представления данных, в основном состоящих из байтов, соответствующих символам, имеющим изображение в символьном наборе ASCII. В результате данного кодирования все байты будут иметь такие значения, гарантированные от дальнейшей модификации почтовым транспортом. Если конвертируемые данные в основном представляют собой ASCII-текст, то конечная их форма остается узнаваемой и читаемой для человека. Тело, полностью состоящее из ASCII-символов, также может быть конвертироавано в Quoted-Printable, что гарантирует его содержимому целостность при прохождении через всякие шлюзы, в которых происходит языковая перекодировка символов или преобразование концов строк и т.д.</p><p>В Quoted-Printable байты должны быть рпедставлены в соответствии со следующими правилами:</p><div class="note"><p>Правило №1 (обычное 8-битное представление): Каждый байт, кроме тех, которые используются для обозначения конца строки, может быть представлен с помощью двух шестнадцатиричных цифр, предворяемых знаком "=". При написании шестнадцатиричных цифр с A по F должны использоваться заглавные буквы. Кроме тех случаев, когда нижеследующие правила позволяют альтернативное кодирование, данное правило является обязательным.</p><p>Правило №2 (Буквенное представление): Байты с десятичным значением с 33 по 60 и с 62 по 126 МОГУТ быть представлены ASCII-символами, соответствующими этим значениям (с '!' по '&lt;' и с '&gt;' по '~').</p><p>Правило №3 (Пробелы): Байты со значениями 9 и 32 МОГУТ быть представлены как ASCII-символы "Табуляция" и "Пробел", но НЕ ДОЛЖНЫ быть представлены так в конце строки. Везде, где они представлены соответствующими ASCII-символами, за ними должен следовать символ, имеющий графическое изображение (печатный символ). В конце же строки символы табуляции и пробела должны быть представлены в соответствии с правилом #1, так как некоторые почтовые транспорты могут убирать пробелы в конце строки.</p><p>Правило №4 (Конец строки): Конец строки в тексте письма должен быть представлен (в соответствии с RFC 822) последовательностью CRLF. Так как в каноническом представлении текста не требуется визуального отображения символов конца строки, в Quoted-Printable не используется видимых символов для обозначения конца строки. Для представления бинарных данных более предпочтительной является кодировка base64.</p></div><p>Необходимо заметить, что многие реализации почтовых программ могут кодировать по-своему. В частности, при представлеии текста в системах, использующих другие соглашения по обозначению конца строки (отличные от CRLF). Такие реализации недопустимы, и генерация концов строки должна быть стандартизована везде, чтобы не требовалось распознавать, используется ли какое-либо альтернативное представление.</p><p>ПРАВИЛО #5: (Мягкий конец строки): В соответствии с Quoted-Printable длина строки не должна превышать 76 символов. В противном случае используется 'мягкий' перевод строки, представимый знаком равенства. Например, если исходная строка имела вид:</p><pre>Now's the time for all folk to come to the aid of
their country.</pre><p>то в Quoted-Printable encoding он может быть представлена следующим образом:</p><pre>Now's the time =
for all folk to come=
 to the aid of their country.</pre><p>Это обеспечивает механизм восстановления исходной длины строки пользовательским почтовыи агентом.</p><p>Поскольку символ дефиса ("-") представляется в Quoted-Printable в обычном виде, особую осторожность нужно соблюдать при заключении тела в Quoted-Printable в многочастное письмо, чтобы удостовериться, что граница этого включения не проявляется нигде внутри этого включения (лучше всего выбрать обозначение границы в виде последовательности символов "=_", которая никогда не появляется в теле, закодированном в Quoted-Printable. См. определение многочастного письма далее.)</p><p class="note">Замечание: Quoted-Printable представляет собой нечто вроде компромисса между читабельностью и сохранностью при пересылке. Тела в Quoted-Printable будут надежно защищены при прохождении многих почтовых шлюзов, но могут быть не очень хорошо переданы через некоторые шлюзы, использующие трансляцию в EBCDIC. (Теоретически, EBCDIC-шлюз должен кодировать тело из quoted-printable в base64 и затем декодировать обратно, но таких шлюзов пока не существует). Единственный способ добится действительно надежной транспортировки через EBCDIC-шлюз — экранировать ASCII-символы.</p><pre>!"#$@[\]^`{|}~</pre><p>в соответствии с правилом #1.</p><p>Так как данные в quoted-printable являются строчно-ориентированными, можно ожидать, что представление концов строки в Quoted-Printable будет изменено почтовым транспортом таким же образом, как и обычный текст может измениться при пересылке по Internet-почте между системами с разными соглашениями по представлению концов строки. Если подобные изменения могут нарушить целостность данных, то имеет смысл пользоваться кодировкой base64, а не Quoted-Printable.</p><p>Вниманию создателей ПО: Если двоичные данные пересылаются в Quoted-Printable, то надо соблюдать осторожность при кодировании символов CR и LF. В частности, последовательность CRLF должна быть представлена как "=0D=0A", в противном случае, если CRLF означает конец строки, то она может быть неверно интерпретирована в платформах с другими соглашениями по концу строки.</p><p>Синтаксис данных в quoted-printable описывается следующим образом:</p><pre>quoted-printable := ([*(простой текст / ПРОБЕЛ / ТАБУЛЯЦИЯ) простой текст]
                     ["="] CRLF)
     ; Максимальная длина строки — 76 символов, включая CRLF

 простой текст := байт /&lt;любой ASCII-символ "=", ПРОБЕЛ или ТАБУЛЯЦИЯ>
     ; символы, не перечисленные в приложении B к RFC 1521 как  безопас-
     ; ные для почты, также не рекомендуются к использованию

байт := "=" 2(ФИФРА / "A" / "B" / "C" / "D" / "E" / "F")
     ; байт используется для символов > 127, =, ПРОБЕЛ, или ТАБУЛЯЦИЯ,
     ; и рекомендуется для представления любых символов, не  перечислен-
     ; ных в приложении B к RFC 1521 как безопасные для почты</pre><h3 id="p5.2">5.2. Механизм конвертации Base64</h3><p>Этот алгоритм разработан для представления произвольных последовательностей байтов в форму, читаемую для человека. Кодирующий и декодирующий алгоритмы очень просты, но закодированные данные примерно на 33% больше, чем некодированные. этот метод идентичен тому, который используется в приложениях PEM (Privacy Enhanced Mail), описанной в RFC 1421 с одним отличием: base64 не приемлит встроенного "чистого" текста.</p><p>Base64 использует 65-символьный поднабор из US-ASCII, выделяя 6 бит на каждый печатный символ. (65-й символ "=" используется для обозначения функции спец. обработки).</p><p class="note">Примечание: этот поднабор имеет важное свойство: он идентичен всем версиям языковой кодировки ISO 646, включая US ASCII, а также всем версиям EBCDIC. Другие популярные механизмы кодирования (uuencode, base85 — часть уровня 2 PostScript) не разделяют этих свойств и поэтому не удовлетворяют требованиям переносимости для двоичных данных электронной почты.</p><p>Процесс кодирования преобразует 4 входных символа в виде 24-битной группы, обрабатывая их слева направо. Эти группы затем рассматриваются как 4 соединенные 6-битные группы, каждая из которых транслируется в одиночную цифру алфавита base64. При кодировании base64, входной поток байтов должен быть упорядочен старшими битами вперед.</p><p>Каждая 6-битная группа используется как индекс для массива 64-х печатных символов. Символ, на который указывает значение индекса, помещается в выходную строку. Эти символы выбраны так, чтобы быть универсально представимыми и исключают символы, имеющие специальное значение для SMTP-транспорта (".", CR, LF) и для синтаксиса вложенных тел MIME ("-").</p><pre>                    Таблица 1: Алфавит Base64

Значение Код    Значение Код    Значение Код    Значение Код
       0 A            17 R            34 i            51 z
       1 B            18 S            35 j            52 0
       2 C            19 T            36 k            53 1
       3 D            20 U            37 l            54 2
       4 E            21 V            38 m            55 3
       5 F            22 W            39 n            56 4
       6 G            23 X            40 o            57 5
       7 H            24 Y            41 p            58 6
       8 I            25 Z            42 q            59 7
       9 J            26 a            43 r            60 8
      10 K            27 b            44 s            61 9
      11 L            28 c            45 t            62 +
      12 M            29 d            46 u            63 /
      13 N            30 e            47 v
      14 O            31 f            48 w            = (заполнитель)
      15 P            32 g            49 x
      16 Q            33 h            50 y</pre><p>Выходной поток (закодированные бфайты) должен иметь длину строк не более 76 символов. Все признаки перевода строки и другие символы, отсутствующие в таблице 1, должны быть проигнорированы декодером base64. Среди данных в Base64 символы, не перечисленные в табл. 1, переводы строки и т.п. должны говорить об ошибке передачи данных, и, соответственно, почтовая программа должна оповестить пользователя о ней.</p><p>Если в хвосте потока кодируемых данных осталось меньше, чем 24 бита, справа добавляются нулевые биты до образования целого числа 6-битных групп. А до конца 24-битной группы остается от 0 до 3-х недостающих 6-битных групп, вместо каждой из которых ставится символ-заполнитель '='. Поскольку весь входной поток представляет собой целое число 8-битных групп (т.е., просто байтных значений), то возможны лишь следующие случаи: (1) входной поток как раз оканчивается 24-битной группой. В таком случае, выходной поток будет оканчиваться четырьмя символами Base64 без символа '='; (2) хвост входного потока имеет длину 8 бит. Тогда в конце выходного кода быдут два символа Base64, с добавлением двух символов '='; (3) хвост входного потока имеет длину 16 бит. Тогда в конце выходного будут стоять три символа Base64 и один символ '='.</p><p>Т.к. символ '=' является хвостовым заполнителем, его появление в теле письма может означать только то, что конец данных достигнут. Но такой гарантии нет, если число переданных битов кратно 24.</p><p>Любые бессмысленные последовательности в коде Base64 вроде "=====" должны быть игнорированы.</p><p>Если кодируемый текст не находится в канонической форме. то перед конвертацией в Base64 необходимо сначала все концы строк заменить стандартной последовательностью CRLF. Предпочтительнее эту функцию встроить в кодировщик Base64, нежели заставлять пользователя производить предварительную канонизацию текста другими средствами.</p><p>Нет нужды экранировать вложенные тела внутри многочастного тела (multipart) при кодировании его в Base64, так как в коде Base64 отсутствует символ '-'.</p><h2 id="p6">6. Дополнительные Content- поля заголовка</h2><h3 id="p6.1">6.1. Необязательное поле Content-ID</h3><p>При создании почтового агента верхнего уровня может быть желательно позволить одному телу иметь ссылку на другое. Для этого поля могут быть помечены с помощью поля заголовка "Content-ID", синтаксически идентичного полю "Message-ID":</p><pre>идентификатор :=  "Content-ID" ":" идентификатор письма</pre><p>Как и значения поля Message-ID, значения поля Content-ID должны быть абсолютно уникальными (для всего мира).</p><p>Такой идентификатор может быть использован для идентификации тела письма (части письма) в нескольких контекстах, в часности, для кэширования данных, указываемых с помощью механизма message/external-body. Хотя поле Content-ID является необязательным в общем случае, его использование необходимо в реализациях, генерирующих данные, имеющие дополнительный тип "message/external-body" (поле Content-type). Каждое тело такого типа должно обязательно иметь в своем заголовке поле Content-ID для обеспечения ссылки на такие данные.</p><p>Значение поля Content-ID имеет специальную семантику в случае типа multipart/alternative. (См. соотв. пункт).</p><h3 id="p6.2">6.2. Необязательное поле Content-Description</h3><p>Возможность ассоциировать некоторую описательную информацию с данными часто очень желательна. например, может быть полезным описать тело, содержащее графическое изображение, как "a picture of the Space Shuttle Endeavor." Этот текст и может быть помещен в поле заголовка Content-Description.</p><pre>описание := "Content-Description" ":" *текст</pre><p>Описание должно иметь языковую кодировку US-ASCII, хотя механизм, определенный в RFC-1522 может быть использован для не-US-ASCII значений.</p><h2 id="p7">7. Предопределенные значения поля Content-Type</h2><h3 id="p7.1">7.1. Тип 'Text'</h3><p>Тип 'text' предназначен для пересылки текстовых материалов. Это значение поля — по умолчанию. Для обозначения языковой кодировки текста используется параметр "charset" для некоторых подтипов, включая основной подтип, "text/plain", соответствующий простому (неформатированному) тексту. В Internet'овской почте значением Content-Type по умолчанию является следующее: "text/plain; charset=us-ascii". Если текст является размеченным и нет соответствующего ПО для корректного визуального представления этого текста пользователю, имеет смысл сообщить ему подтип этих текстовых данных.</p><h4 id="p7.1.1">7.1.1. Параметр 'charset'</h4><p>В отличие от других значений, значения этого параметра не являются чувствительными к регистру букв.</p><p>Спецификации любых новых подтипов типа 'text' должны определять, будет ли этот новый подтип использовать параметр "charset" либо наоборот, будет запрещать его использование. Любое тело, не содержащее внутри себя других, должно целиеом быть в одной языковой кодировке. В частности, создатели новых подтипов должны уделить внимание многбайтным символьным наборам.</p><p>Дополнительно к предопределенным новые языковые кодировки могут быть зарегистрированы через IANA, хотя стандартизация их использования требует опробирования IESG (см. RFC-1340). Если используется 8-битная языковая кодировка (например, koi8 или cp866), то необходимо наличие поля заголовка Content-Transfer-Encoding для обеспечения передачи через ряд протоколов, в частности, SMTP.</p><p>Необходимо заметить, что управляющие символы (0-31, 127), включая DEL, не имеют определенного значения за исключением последовательности CRLF (13,10), означающей конец строки. Два символа де-факто широко употребляются: FormFeed (12), означающий, что следующий за ним текст должен начинаться на новой странице; и TAB (9), часто, но не всегда означающий "перевести курсор на следующий ближайший столбец после данной позиции, где номер столбца кратен воьсми". Любое другое использование управляющих символов или DEL в теле должно быть в рамках частного соглашения между отправителем и получателем. Но такие соглашения крайне не рекомендуются и по возможности должны быть заменены другими возможностями MIME.</p><p>Существует огромное количество языковых кодировок, что не является положительным фактом. В дальнейшем предполагается ввести универсальную многобитную языковую кодировку, поддерживающую все языки мира. К сожалению, существующая практика говорит о том, что возможно, еще долгое время электронной почте придется иметь дело с многими кодировками. По этой причине предопределены имена для наиболее распространенных языковых кодировок:</p><ul><li>US-ASCII</li><li>ISO-8859-X — где "X" — цифра от 1 до 9 включительно, означающая номер версии кодировки ISO-8859</li></ul><p>Параметр "charset" был определен в основном для текстовых данных, но возможно, для бинарных данных тоже может потребоваться указать языковую кодировку, в этом случае должен использоваться тот же синтаксис те же значения.</p><p>Почтовое программное обеспечение должно руководствоваться принципом наименьшего набора символов, то есть, если письмо пишется как-бы в восьмибитной ISO-8859-1, но в письме используются символы лишь некоторого поднабора, например, семибитного US-ASCII, то почтовая программа должна автоматически определить имя символьной кодировки как US-ASCII. В этом случае уменьшится нагрузка в сети и увеличаися шансы, что получатель прочтет письмо без искажений.</p><h4 id="p7.1.2">7.1.2. Подтип 'Text/plain'</h4><p>Это основной подтип, соответствующий простому (неформатированному) тексту. Значение поля Content-Type для почты Internet по умолчанию — "text/plain; charset=us-ascii". Это тип данных, соответствующий RFC 822.</p><p>Других предопределенных подтипов для типа 'text' нет.</p><p>Формальный синтаксис для типа 'text':</p><pre>тип := "text" "/" подтип [";" "charset" "=" имя языковой кодировки]

подтип := "plain" / расширение (не предопределенный подтип)

имя языковой кодировки:= "us-ascii"/ "iso-8859-1"/ "iso-8859-2"
       / "iso-8859-3" / "iso-8859-4"/ "iso-8859-5"/ "iso-8859-6"
       / "iso-8859-7" / "iso-8859-8" / "iso-8859-9" / расширение
       (не предопределенная кодировка)</pre><h3 id="p7.2">7.2. Тип 'multipart'</h3><p>Этот тип используется, если один или более различных наборов данных заключены в одном письме. Каждая часть тела должна иметь синтакс письма RFC 822 (то есть, иметь заголовок,ь пустую строку и тело), но должна иметь открывающую и закрывающую границы.</p><p>Часть письма не должна интерпретироваться как настоящее письмо RFC 822. Вообще, для части письма наличие заголовка не обязательно, так что она может начинаться и с пустой строки, но при этом, все признаки, описываемые в заголовке, имеют значение по умолчанию. Для частей письма имеют смысл только поля, описывающие содержимое, то есть. начтинающиеся с "Content-". Все остальные поля, необходимые в заголовке верхнего уровня, обычно игнорируются в частях письма при обработке почты, более того, в некоторых почтовых шлюзах они могут быть просто удалены. Для экспериментальных и частных целей могут использоваться "X-" поля, но информация, в них заложенная, может быть потеряна при прохождении некоторых почтовых шлюзов.</p><p class="note">Замечание: Различие между письмом RFC 822 и частью письма MIME является маленькой, но важной. Шлюз между почтой Internet и X.400, например, должен иметь возможность отличить часть письма, содержащую графическое изображение, от части письма, содежащей вложенное письмо, телом которого является графическое изображение. Для представления последнего соответствующая часть письма должна иметь "Content-Type: message" и ее тело после пустой строки должно являться вложенным письмом со своим собственным полем заголовка "Content-Type: image". Схожесть синтаксиса обеспечивает легкость конверсии от письма к части письма, но различие между ними должно быть усвоено производителями ПО.</p><p>Граница части письма не должна появляться внутри самой части письма.</p><p>Все существующие и будущие подтипы типа "multipart" должны иметь идентичный синтаксис. Они могут различаться своей семантикой. Это требование гарантирует, что совместимые пользовательские агенты смогут по крайней мере распознать и разделить части многочастного письма, даже имеющего неизвестный им подтип.</p><p>Как упомянуто в определении поля Content-Transfer-Encoding, использование других значений кроме "7bit", "8bit" или "binary" запрещено для типа "multipart". Почтовые шлюзы и другие почтовые агенты часто вносят изменения в заголовки верхнего уровня. В частности, они могут добавлять, убирать, переупорядочивать определенные поля. Такие изменения запрещены для заголовков частей письма, находяшихся внутри тела типа "multipart".</p><h4 id="p7.2.1">7.2.1. Multipart: общий синтаксис</h4><p>Поле Content-Type многочастного письма требует одного параметра, "boundary", который определяет границы вложения. Границей является строка, состоящая из двух символов "-" (десятичный код 45) и значения параметра 'boundary' из поля заголовка Content-Type.</p><p class="note">Замечание: Два символа "-" используются для совместимости с более ранним методом вложения писем, описанным в RFC 934 и для облегчения поиска границ. Однако, многочастные письма MIME не полностью совместимы с RFC 934; в частности, они не подчиняются соглашению RFC 934 по экранированию строк символом "-", так как с каждым новым уровнем экранирования длина строк увеличивается. А поскольку SMTP-транспорты часто обрезают длинные строки, этот механизм становится неприменимым в случае многоуровневой структуры письма типа 'multipart'.</p><p class="note">Вниманию производителей ПО: синтаксис параметров поля Content-Type таков, что зачастую необходимо значения границ в параметре 'boundary' заключать в кавычки. Это не всегда требуется, но никогда не повредит. Программистам следует изучить синтаксис внимательно, чтобы не допустить ошибок в поле Content-Type. Типичное поле Content-Type для типа 'multipart' может выглядеть следующим образом:</p><pre>Content-Type: multipart/mixed;
     boundary=gc0p4Jq0M2Yt08jU534c0p</pre><p>Но в следующем примере содержится ошибка:</p><pre>Content-Type: multipart/mixed;
     boundary=gc0p4Jq0M:2Yt08jU534c0p</pre><p>(из-за двоеточия), которая может быть исправлена следующим образом:</p><pre>Content-Type: multipart/mixed;
     boundary="gc0p4Jq0M:2Yt08jU534c0p"</pre><p>Это означает, что тело письма состоит из нескольких частей, каждая из которых соответствует синтаксису письма RFC 822, за исключением того. что область заголовка может быть абсолютно пустой и начальная граница каждой части отмечена последовательностью:</p><pre>--gc0p4Jq0M:2Yt08jU534c0p</pre><p>Нужно обратить внимание, что метка границы части письма должна располагаться в начале строки, то есть, сразу же после признака конца строки CRLF. Причем, последовательность CRLF полагается элементом метки границы, а не последним элементом тела предыдущей части (так как тело предыдущей части может неоканчиваться концом строки, что принципиально важно в случае бинарных данных. Если же тело предыдущей части оканчивается концом строки, то метке границы соответственно должны предшествовать два конца строки). Сразу за меткой границы должен следовать конец строки (CRLF), или при отсутствии заголовка следующей части письма, два конца строки.</p><p>Метка границы не должна иметь длину более 70 символов, не считая два начальных дефиса.</p><p>Метка границы, следующая за последней частью письма, должна отличаться от предыдущих меток, чтобы показать, что далее не последует другой части письма. Отличие последней метки состоит в добавлении двух дефисов в конец:</p><pre>--gc0p4Jq0M2Yt08jU534c0p--</pre><p>Обычно оставляется пространство для дополнительной информации перед первой меткой границы и после последней. Обычно его следует оставлять пустым, и обработчики почты должны игнорировать все, что в этом пространстве содержится.</p><div class="note"><p>Замечание: Эти области приамбулы и эпилога обычно не используются из-за отсутствия точной семантики для обработки этих областей почтовыми шлюзами, однако, многие программные MIME-продукты считают удобным помещать туда пояснительную информацию для получателей, которые пользуются до-MIME'овским ПО. По этой причине, MIME-совместимые программы должны игнорировать эти области.</p><p>Поскольку метки границы не должны появляться внутри тел частей письма, почтовая программа, создающая письмо, должна иметь алгоритм, позволяющий автоматически подобрать уникальную последовательность, не встречающуюся в теле ни одной из частей, либо имеющую минимальную вероятность появления, если данные предварительно не сканируются на наличие таковой.</p></div><p>В качестве простого примера предлагается двухчастное письмо, вторая часть которого оканчивается признаком конца строки, а первая нет:</p><pre>From: Nathaniel Borenstein
To:  Ned Freed
Subject: Sample message
MIME-Version: 1.0
Content-type: multipart/mixed; boundary="simple
boundary"

Это приамбула. Должна быть игнорирована
--simple boundary

Это простой ASCII-текст.
Он НЕ оканчивается признаком конца строки.
--simple boundary
Content-type: text/plain; charset=us-ascii

Это простой ASCII-текст.
Он оканчивается признаком конца строки.

--simple boundary--
Это эпилог. Тоже должен игнорироваться MIME-программами.</pre><p>Часть письма, в свою очередь, также может иметь тип 'multipart', то есть. быть многочастным телом, но при этом метки границ, использующиеся во внешнем и во внутреннем multipart-телах, должны отличаться друг от друга.</p><p>Использование типа 'multipart' в одночастном письме может быть полезно в некоторых контекстах и не запрещено.</p><p>Единственным обязательным параметром для типа 'multipart' является параметр 'boundary', состоящий из 1-70 символов без хвостовых пробелов (которые могут быть удалены в процессе пересылки, и тогда почтовая программа получателя не сможет разделить вложенные части).</p><pre>граница := 0*69&lt;символов границы&gt; символ_границы_кроме_пробела

символ границы := символ_границы_кроме_пробела / " "

символ_границы_кроме_пробела := ЦИФРА / БУКВА ЛАТИНСКОГО АЛФАВИТА / "'"
              / "(" / ")" / "+" /"_" / "," / "-"
              / "." / "/" / ":" / "=" / "?"</pre><p>Общий вид многочастного тела — следующий:</p><pre>многочастное тело := приамбула  вложения  признак_конца  эпилог

вложение := разделитель  часть_тела  CRLF

разделитель := "--"  метка_границы  CRLF
               ; метка границы должна браться из поля Content-Type.
               ; Не должно быть пробелов между "--" и меткой границы.

признак конца := "--"  метка_границы  "--"  CRLF
               ; Опять, без пробела перед "--",

приамбула := игнорируемый текст

эпилог := игнорируемый текст

игнорируемый текст := *(*текст CRLF)

часть_тела := &lt;письмо RFC 822, со всеми необязательными полями
              заголовка&gt;</pre><p>ЗАМЕЧАННИЕ: В некоторых транспортах такие ограничения RFC 822, как использование тольеко печатных символов в теле, могут не действовать. Ослабления таких ограничений должны быть истолкованы как локальные расширения определения тела письма настолько, насколько они поддерживаются почтовым транспортом и адекватно документированы в поле заголовка Content-Transfer-Encoding. Однако, ни при каких обстоятельствах в заголовках как письма, так и его частей, не должно содержаться каких-либо символов, кроме US-ASCII.</p><h4 id="p7.2.2">7.2.2. Основной подтип "multipart/mixed"</h4><p>Это основной подтип для типа 'multipart', он предназначен для случая, когда части письма взаимонезависимы. Любые новые подтипы, неизвестные почтовой программе, должны быть истолкованы аналогично подтипу 'mixed'.</p><h4 id="p7.2.3">7.2.3. Подтип "multipart/alternative"</h4><p>Этот подтип синтаксически идентичен предыдущему, но имеет несколько другую семантику.</p><p>Почтовые системы должны распознавать, что данные из разных частей взаимозаменяемы. Системы должны выбрать наиболее подходящий вариант для локальной платформы и других условий, в некоторых случаях, с согласия пользователя. Как и в предыдущем случае, порядок частей в письме существенен. В этом случае альтернативы располагаются в порядке уменьшения отличия от оригинала. Обычно, выбирается последняя часть (альтернатива) из тех, которые имеют тип, поддерживаемый локальной системой получателя.</p><p>Multipart/alternative может быть использована, к примеру, для пересылки текста в некотором гипотетическом формате:</p><pre>From:  Nathaniel Borenstein
To: Ned Freed
Subject: Formatted text mail
MIME-Version: 1.0
Content-Type: multipart/alternative; boundary=boundary42

--boundary42

Content-Type: text/plain; charset=us-ascii

   ... Здесь содержится версия простым текстом ....
--boundary42
Content-Type: text/richtext

   .... Здесь содержится версия с разметкой RFC 1341 ...
--boundary42
Content-Type: text/x-whatever

   .... Здесь содержится версия в гипотетическом формате ...
--boundary42--</pre><p>В этом примере пользователь, чья система понимает этот гипотетический формат, увидят именно эту версию, в то время как остальные будут видеть размеченный либо простой текст в зависимости от возможностей их системы.</p><p>Обычно пользовательский агент, создающий письмо в multipart/alternative, должны располагать альтернативные части в порядке увеличения предпочтительности формата, то есть, предполагая, что наш гипотетический формат является самым удобным для конкретных данных (иначе зачем было бы его изобретать?), пользовательский агент должен располагать альтернативу в простейшем формате первой, а самую размеченную последней. Агент получателя должен отобразить последнюю из понимаемых им альтернатив. В случае, если одна из альтернатив сама имеет тип 'multipart' и содержит подчасти неизвестных типов, пользовательский агент может выбрать, показывать ли эту альтернативу, предыдущую или обе.</p><p class="note">Замечание: С точки зрения программиста, может показаться более удобным располагать альтернативы в обратном порядке, но данный порядок позволяет устаревшим не-MIME'овским почтовым программам отобразить в первую очередь наиболее понятный вариант.</p><p class="note">Замечание по семантике поля 'content-id' в письме multipart/alternative: Рекомендуется, чтобы каждая часть имела уникальное значение поля Content-ID в случае, если содержимое этих частей не является идентичным. Однако, там, где содержащаяся информация идентична (например, если несколько частей типа "application/external- body" определяют альтернативные пути доступа к одним и тем же внешним по отношению к письму данным), должно использоваться одно и то же значение Content-ID, чтобы оптимизировать работу кэширующего механизма на системе получателя. Однако, не рекомендуется, чтобы значения Content-ID, использующиеся для частей, отличались от значения Content-ID, использующегося в заголовке верхнего уровня, если такое поле в нем присутствует.</p><h4 id="p7.2.4">7.2.4. Подтип "multipart/digest"</h4><p>Этот подтип идентичен подтипу 'multipart/mixed', но имеет другую семантику. Например, для 'digest' значением по умолчанию является не "text/plane", а "message/rfc822".</p><p>В соответствии с этим подтипом, письмо-дайджест может выглядеть следующим образом:</p><pre>From: Moderator-Address
To: Recipient-List
MIME-Version: 1.0
Subject:  Internet Digest, volume 42
Content-Type: multipart/digest;
     boundary="---- next message ----"

------ next message ----

From: someone-else
Subject: my opinion

   ... тело вложенного письма ...

------ next message ----

From: someone-else-again
Subject: my different opinion

   ... тело другого вложенного письма ...

------ next message ------</pre><h4 id="p7.2.5">7.2.5. Подтип "multipart/parallel"</h4><p>Отличие этого подтипа от "multipart/mixed", в частности, состоит в том, что порядок расположения частей письма не принципиален.</p><p>Данные этого подтипа должны отображаться одновременно, если платформа получателя обладает соответствующими возможностями. Однако, почтовый агент отправителя должен сознавать, что программа получателя может не иметь подобных возможностей и отобразить все части письма последовательно.</p><h4 id="p7.2.6">7.2.6. Другие подтипы типа "multipart"</h4><p>В будущем ожидается введение новых подтипов. Программистам рекомендуется интерпретировать незнакомые подтипы типа 'multipart' аналогично "multipart/mixed".</p><p>Формальный синтаксис поля Content-Type для данных типа "multipart":</p><pre>multipart-тип := "multipart" "/" multipart-подтип
                 ";" "boundary" "=" метка_границы

multipart-подтип := "mixed" / "parallel" / "digest"
               / "alternative" / подтип-расширение</pre><h4>Полный пример Multipart-письма</h4><p>Данный пример иллюстрирует письмо из пяти частей: две — простой текст, одна — вложенное multipart-письмо, одна — размеченный текст и одна — вложенное письмо, содержащее текст в не-US-ASCII языковой кодировке. Третья часть (вложенное multipart-письмо) состоит из двух частей, требующих параллельного представления пользователю, — графическое изображение и звуковой фрагмент.</p><pre>MIME-Version: 1.0
From: Nathaniel Borenstein
To: Ned Freed
Subject: A multipart example
Content-Type: multipart/mixed;
     boundary=unique-boundary-1

Это область преамбулы multipart-письма. Почтовые программы, понимающие
формат multipart, должны игнорировать все, что в ней  находится.  Если
же вы при получении подобного письма видите этот текст на экране,  вам
следует сменить почтовую программу.
--unique-boundary-1

   ...Здесь находится некоторый текст...
[Обратите внимание, что предшествующая  пустая  строка  означает,  что
поля заголовка не были заданы,  и  это — простой  текст  в  языковой
кодировке US ASCII.]

--unique-boundary-1
Content-type: text/plain; charset=US-ASCII

Это  часть  предыдущей  части,  но  иллюстрирующая   ясную,    а    не
подразумеваемую типизацию содержимого.

--unique-boundary-1
Content-Type: multipart/parallel;
     boundary=unique-boundary-2

--unique-boundary-2
Content-Type: audio/basic
Content-Transfer-Encoding: base64

   ... кодированный в base64 одноканальный звуковой фрагмент для час-
       тоты 8000 Hz в формате mu-law....

--unique-boundary-2
Content-Type: image/gif
Content-Transfer-Encoding: base64

   ... здесь  находится    кодированное    в    base64    графическое
       изображение....

--unique-boundary-2--

--unique-boundary-1
Content-type: text/richtext

Это текст с разметкой
в соответствии с определением RFC 1341
Неправда ли, он крут?

--unique-boundary-1
Content-Type: message/rfc822

From: (имя отправителя в US-ASCII)
To: (адрес в US-ASCII)
Subject: (subject в US-ASCII)
Content-Type: Text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: Quoted-printable

   ... Некоторый текст в ISO-8859-1 ...

--unique-boundary-1--</pre><h3 id="p7.3">7.3. Тип 'message'</h3><p>При пересылке почты часто возникает необходимость включить внутрь письма другое письмо. Для этого и используется тип 'message'.</p><p>Основной подтип — "rfc822" — не требует параметров в поле Content-Type. Дополнительные подтипы — "partial" и "External-body" — предполагают наличие параметров.</p><p class="note">Замечание: Для перенаправляемой и возвращаемой почты можно было бы определить отдельные подтипы, однако, такая почта может пересылаться как multipart-письмо, в котором первая часть содержит некоторую пояснительную текстовую информацию, а другая, имеющая тип 'message/rfc822', содержит перенаправляемое/возвращаемое письмо. Подобный способ перенаправления/возвращения почты сохраняет информацию о типе оригинального письма и позволяет ему быть корректно представленным получателю, и поэтому настоятельно рекомендуется.</p><h4 id="p7.3.1">7.3.1. Основной подтип 'message/rfc822'</h4><p>Этот подтип указывает, что тело письма содержит вложенное письмо в стандарте RFC 822, однако, в отличие от заголовка RFC 822 верхнего уровня, для каждой части, являющейся письмом RFC 822, не требуется наличия полей "From", "Subject" и, по крайней мере, одного поля "To".</p><p>Не смотря на использование числа "822", тело, имеющее подтип 'message/rfc822', может включать дополнительную информацию в соответствии со стандартом MIME. Другими словами, письмо 'message/rfc822' может быть MIME-письмом.</p><h4 id="p7.3.2">7.3.2. Подтип 'message/partial'</h4><p>Этот подтип определен с целью обеспечения возможности пересылки очень больших объектов в виде нескольких раздельных частей, автоматичски "склеиваемых" почтовой программой получателя. Этот механизм может пригодиться, когда промежуточные почтовые шлюзы ограничивают индивидуальный размер пересылаемых писем. Т.о., этот подтип говорит о том, что письмо содержит лишь часть большого послания.</p><p>Для этого подтипа необходимо указание трех параметров:</p><ol><li><strong>"id"</strong> — уникальный идентификатор, позволяющий обнаружить остальные части послания.</li><li><strong>"number"</strong> — целое число, означающее номер части послания.</li><li><strong>"total"</strong> — целое число, означающее общее количество частей. Требуется лишь в последней части и не обязателен (хотя рекомендуется) для предыдущих частей. Эти параметры могут следовать в произвольном порядке.</li></ol><p>Пример: часть 2 3-х частного послания имеет следующие варианты заголовка:</p><pre>Content-Type: Message/Partial;
     number=2; total=3;
     id="oc=jpbe0M2Yt4s@thumper.bellcore.com"

Content-Type: Message/Partial;
     id="oc=jpbe0M2Yt4s@thumper.bellcore.com";
     number=2</pre><p>Но часть 3 обязательно должна содержать параметр "total":</p><pre>Content-Type: Message/Partial;
     number=3; total=3;
     id="oc=jpbe0M2Yt4s@thumper.bellcore.com"</pre><p>Необходимо заметить, что нумирация частей начинается с 1, а не с 0.</p><p>Когда подобным образом разбитые части собираются вместе, они образуют полное MIME-письмо, содержимое которого может иметь любой другой тип и, соответственно, свое поле заголовка Content-Type, описывающее этот тип.</p><p>Семантика partial-письма должна быть та же, как в обычном письме с содержимым данного типа, а не как в письме, содержащем "внутреннее" письмо. Это позволяет, например, переслать большой аудио-файл ввиде нескольких более мелких, остающихся, тем не менее, видимыми получателю как обычные аудио-письма, а не как вложенные аудио-письма.</p><p>При "сборке" таких посланий в пункте назначения должны учитываться следующие правила:</p><ol><li>Все поля заголовка части 1, кроме начинающихся с "Content-" и специальных "Message-ID", "Encrypted" и "MIME-Version" должны быть скопированы в заголовок нового (общего) письма.</li><li>Только поля заголовка ВЛОЖЕННОГО письма, начинающиеся с "Content-", а также поля "Message-ID", "Encrypted" и "MIME-Version", должны быть добавлены к заголовку нового общего письма, все остальные поля должны игнорироваться.</li><li>Заголовки второй и последующих частей целиком игнорируются.</li></ol><p>Например, если письмо с аудио-данными было разбито на две части, первая из них может выглядеть следующим образом:</p><pre>   X-Weird-Header-1: Foo
   From: Bill@host.com
   To: joe@otherhost.com
   Subject: Audio mail
   Message-ID:
   MIME-Version: 1.0
   Content-type: message/partial;
        id="ABC@host.com";
        number=1; total=2

   X-Weird-Header-1: Bar
   X-Weird-Header-2: Hello
   Message-ID:
   MIME-Version: 1.0
   Content-type: audio/basic
   Content-transfer-encoding: base64

... здесь имеет место быть первая часть закодированных аудио-данных ...</pre><p>А вторая может выглядеть так:</p><p>From: Bill@host.com To: joe@otherhost.com Subject: Audio mail MIME-Version: 1.0 Message-ID: Content-type: message/partial; id="ABC@host.com"; number=2; total=2 ... здесь имеет место быть вторая часть закодированных аудио-данных ...</p><p>После того, как расколотое послание воссоздано заново для отображения получателю, оно должно выглядеть следующим образом:</p><pre>   X-Weird-Header-1: Foo
   From: Bill@host.com
   To: joe@otherhost.com
   Subject: Audio mail
   Message-ID:
   MIME-Version: 1.0
   Content-type: audio/basic
   Content-transfer-encoding: base64

... первая часть закодированных аудио-данных ...
... вторая часть закодированных аудио-данных ...</pre><p>Замечание по кодированию тела MIME-письма, заключенного внутри тела message/partial: так как данные типа "message" никогда не могут быть кодированы в Base64 или Quoted-Printable, следующая проблема может возникнуть в случае, если тела писем типа message/partial созданы в системе, поддерживающей 8-битный транспорт. Двоичные данные будут разбиты на несколько message/partial-объектов, каждому из которых требуется транспортировка в двоичном виде. Если бы таким объектам пришлось пройти через шлюз в 7-битную транспортную среду, их невозможно было бы перекодировать в сеимбитную форму без ожидания прибытия всех частей послания, собирания их воедино и затем кодирования целого послания в 7-битную кодировку (base64 или quoted-printable). Поскльку существует вероятность, что разные части пойдут разными путями (через различные шлюзы), то подобное решение не приемлимо. Поэтому MIME определяет, что письма типа message/partial должны иметь 7-битную кодировку и соответствующее ей значение поля content-transfer-encoding. Даже для систем с транспортом, поддерживающим "8-бит" и "binary", запрещается их использование для данных message/partial.</p><p>Многие почтовые агенты могут автоматически фрагментировать большие письма.</p><p>Включение поля "References" в заголовки второй и последующих частей, ссылающегося на идентификатор предыдущей части, может оказаться полезным для почтовых программ, понимающих и обрабатывающих ссылки. Однако, наличие этого поля не обязательно.</p><p>Поле заголовка "Encrypted" вышло из употребления, но вышеприведенные правила обеспечивают корректную его интерпретацию, если оно встречается при обработке фрагментов типа message/partial.</p><h4 id="p7.3.3">7.3.3. Подтип 'Message/External-Body'</h4><p>Этот подтип указывает на то, что тело не содержится в самом письме, а на него есть ссылка. Параметры подтипа описывают способ доступа к данным тела письма.</p><p>Письмо (часть письма) этого подтипа состоит из заголовка, двух последовательных концов строки и заголовка вложенного письма. Если встречается другая пара концов строки, она означает конец заголовка вложенного письма. Однако, поскольку тело вложенного письма является внешним, оно не следует за концом заголовка. Например,</p><pre>Content-type: message/external-body; access-
type=local-file;

     name="/u/nsb/Me.gif"

Content-type:  image/gif
Content-ID:
Content-Transfer-Encoding: binary

ТЕЛА НЕТ!</pre><p>Область в конце, которую можно назвать "призрачным телом", игнорируется для большинства писем подтипа 'external-body'. Однако, в нее можно помещать дополнительную информацию, как например, в случае, когда параметр 'access-type' равен "mail-server". Во всех остальных случаях призрачное тело игнорируется.</p><p>Единственный всегда обязательный параметр для 'message/external-body' — "access-type". Остальные параметры могут быть или не быть обязательными в зависимости от значения параметра "access-type".</p><p>Значение этого параметра — слово, нечувствительное к регистру букв, означающее механизм доступа, с помощью которого файл или данные могут быть получены. Значения могут быть следующими (но не ограничиваются этим рядом): "FTP", "ANON-FTP", "TFTP", "AFS", "LOCAL-FILE" и "MAIL-SERVER". Будущие возможные значения, кроме экспериментальных, начинающихся с "X-", должны быть зарегистрированы в IANA.</p><p>Дополнительно, следующие три параметра являются необязательными для всех способов доступа:</p><p><strong>EXPIRATION</strong> — Дата (RFC 822 "date-time" синтаксис допускает 4 цифры в этом поле), после которой существование внешних данных не гарантируется.</p><p><strong>SIZE</strong> — размер (в байтах) данных. Позволяет получателю решить, расходовать ли ресурсы на считывание внешних данных. Размер указывается для канонической формы данных (то есть, до применения каких-либо преобразований).</p><p><strong>PERMISSION</strong> — нечувствительное к регистру букв поле, говорящее о том, ожидается или нет, что клиент может перезаписывать данные. По умолчанию или когда этот параметр имеет значение "read", полагается, что клиент не имеет на это права, и что если данные однажды считаны, то больше они не понадобятся. Если PERMISSION имеет значение "read-write", любая локальная копия может рассматриваться не более как кэш. "read" и "write" — единственные предопределенные значения для PERMISSION.</p><p>Вложенные заголовки во ВСЕХ телах типа message/external-body ДОЛЖНЫ включать поле заголовка Content-ID для задания уникального идентификатора, указывающего на внешние данные.</p><p>Обозначения, описывающие данные типа external-body, такие как имена файлов или команды mail-сервера, должны быть в символьном наборе US-ASCII.</p><p>Как и для типа message/partial, тело типа message/external-body должно иметь значение content-transfer-encoding "7-bit" (по умолчанию). В частности, даже в системах, поддержиавющих 8-битный транспорт, применение content-transfer-encoding "8-bit" и "binary" запрещено для данных типа message/external-body.</p><h5 id="p7.3.3.1">7.3.3.1. Типы доступа "ftp" и "tftp"</h5><p>Тип доступа по FTP или TFTP означает, что тело сообщения доступно как внешний файл по протоколу FTP [RFC-959] или TFTP [RFC-783] соответственно. Для этих типов доступа обязательны следующие дополнительные параметры:</p><p><strong>NAME</strong> — Имя файла, содержащего данные тела письма.</p><p><strong>SITE</strong> — Полный доменный адрес или псевдоним компьютера, с которого файл может быть получен по указанному протоколу.</p><p>Перед тем, как начнется считывание данных по FTP, пользователь обычно должен быть спрошен на предмет логина и пароля для машины, указанной в параметре 'site'. По причинам безопасности логин и пароль не указываются как параметры Content-Type и должны быть получены от получателя письма.</p><p>Дополнительно определены следующие необязательные параметры:</p><p><strong>DIRECTORY</strong> — каталог, содержащий тело письма на удаленной машине.</p><p><strong>MODE</strong> — Нечувствительное к регистру букв строка, указывающая режим передачи данных. Допустимые эначения для типа доступа TFTP:</p><p><strong>NETASCII</strong>, <strong>OCTET</strong> и MAIL. Для типа доступа FTP: <strong>ASCII</strong>, <strong>EBCDIC</strong>, <strong>IMAGE</strong> и <strong>LOCALn</strong>, где <strong>n</strong> — десятичное целое число, обычно 8. Эти значения соответствуют типам представления <strong>A</strong>, <strong>E</strong>, <strong>I</strong> и <strong>Ln</strong>, определенным FTP-протоколом. Заметьте, что "BINARY" и "TENEX" не являются допустимыми значениями для параметра MODE. Вместо них должны использоваться "OCTET", "IMAGE" или "LOCAL8". Если параметр MODE отсутствует, значением по умолчанию является "NETASCII" для TFTP и "ASCII" для FTP.</p><h5 id="p7.3.3.2">7.3.3.2. Способ досупа "anon-ftp"</h5><p>Этот способ доступа идентичен "ftp", за исключением того, что пользователю не требуется указывать свой логин и пароль для удаленной машины. FTP-протокол будет использоваться с логином "anonymous" и email-адресом получателя вместо пароля.</p><h5 id="p7.3.3.3">7.3.3.3. Способы доступа "local-file" и "afs"</h5><p>Способ доступа "local-file" означает, что тело письма доступно как файл на локальной машине. "afs" означает, что тело доступно как файл через общую файловую систему AFS. В обоих случаях требуется единственный обязательный параметр:</p><p><strong>NAME</strong> — Имя файла, содержащего данные тела письма.</p><p>Следующий необязательный параметр может быть использован для локализации ссылки на файл и содержит адрес сайта или сайтов, на которых данный файл виден:</p><p><strong>SITE</strong> — Доменный адрес машины или машин, на которых возможен доступ к файлу данных. Допускаются маски с использованием звездочки вместо части доменного имени, например, "*.bellcore.com", для обозначения набора машин, на которых файл виден напрямую. Единственная звездочка вместо всего доменного имени может означать, что файл, где би он ни был, виден через глобальную файловую систему.</p><h5 id="p7.3.3.4">7.3.3.4. Способ доступа "mail-server"</h5><p>Применяется, когда тело письма доступно через почтовый сервер. Обязательный параметр для этого способа доступа:</p><p><strong>SERVER</strong> — email-адрес mail-сервера, с которого могут быть запрошены данные тела письма.</p><p>Так как почтовые серверы предполагают множество различных синтаксисов, некоторые из них могут быть многострочными, полная команда, которую нужно послать на mail-сервер, не включается как параметр в однострочное поле 'content-type'. Вместо этого она помещается в мнимое тело, когда значением поля 'content-type' является 'message/external-body', и параметр 'access-tyoe' имеет значение 'mail-server'.</p><p>Необязательный параметр для этого способа доступа:</p><p><strong>SUBJECT</strong> — Subject, который будет использован в заголовке письма-запроса, которое почторый клиент получателя пошлет на указанный почтовый сервер для получения данных тела письма. Заметьте, что помещение адреса сервера в subject не рекомендуется, однако, известны mail-серверы, требующие этого.</p><p>MIME-стандарт не определяет синтаксиса обращения к почтовому серверу. Поэтому он допускает включение полной команды для mail-сервера в мнимое тело.</p><p>В отличие от других способов доступа, доступ через mail-сервер не синхронен, и данные могут быть получены в непредсказуемый момент в будущем. По этой причине важно иметь механизм, обеспечивающий вставку полученных от mail-сервера данных в исходное письмо. Mail-сервер при отправке запрошенных данных должен использовать то же самое значение поля Content-ID в заголовке письма с возвращаемыми данными, какое было в первоначальном "бестелесном" письме, чтобы облегчить работу этого механизма.</p><h5 id="p7.3.3.5">7.3.3.5. Примеры и дополнительные пояснения</h5><p>С появлением возможности очень широких (протяженных) файловых систем стало непредсказуемым, на каком наборе машин файловой системы данный файл будет доступен напрямую, а на каком — нет. Поэтому, имеет смысл указывать как имя файла, так и сетевой адрес (адреса) машин, на которых файл доступен.</p><p>Если внешнее тела письма доступно посредством нескольких различных механизмов, отправитель может включить несколько частей типа message/external-body в письмо типа multipart/alternative.</p><p>Однако, механизм external-body не должен быть ограничен получением удаленных файлов. Например, можно представить использование видеосервера с внешними ссылками на видеофрагменты.</p><p>Если письмо / часть письма имеет тип "message/external-body", то оно / она будет содержать поля заголовка вложенного письма. Тело само по себе неходится где-либо во вне. Это значит, что если тело типа "message/external-body" содержит два последовательных конца строки (CRLF), то все, что идет далее, не является чстью сообщения и просто должно игнорироваться. Однако, этот "хвост" — удобное место для каких-либо дополнительных данных, которые не могут быть помещены в поле заголовка Content-Type. В частности, если значение "access-type" есть "mail-server", то "хвост" может содержать команды, посылаемые затем mail-серверу по адресу, на который указывает параметр SERVER.</p><p>Поля заголовка вложенного письма, которые на самом деле являются телом общего письма типа "message/external-body", должны нести информацию о типе содержимого внешнего (удаленного) тела, если оно не является простым ASCII-текстом (что подразумевается по умолчанию), поскольку эти внешние данные сами по себе не имеют заголовка, опрпеделяющего их тип. Также, необходимо указывать Content-transfer-encoding, если он имеет значение, отличное от "7-bit". Так, полное письмо типа message/external-body, ссылающееся на документ в формате PostScript, может выглядеть следующим образом:</p><pre>From: Whomever
To: Someone
Subject: whatever
MIME-Version: 1.0
Message-ID:
Content-Type: multipart/alternative; boundary=42
Content-ID:

--42
Content-Type: message/external-body;
     name="BodyFormats.ps";
     site="thumper.bellcore.com";
     access-type=ANON-FTP;
     directory="pub";
     mode="image";
     expiration="Fri, 14 Jun 1991 19:13:14 -0400 (EDT)"

Content-type: application/postscript
Content-ID:

--42
Content-Type: message/external-body;
     name="/u/nsb/writing/rfcs/RFC-MIME.ps";
     site="thumper.bellcore.com";
     access-type=AFS
     expiration="Fri, 14 Jun 1991 19:13:14 -0400 (EDT)"

Content-type: application/postscript
Content-ID:

--42
Content-Type: message/external-body;
     access-type=mail-server
     server="listserv@bogus.bitnet";
     expiration="Fri, 14 Jun 1991 19:13:14 -0400 (EDT)"

Content-type: application/postscript
Content-ID:

get RFC-MIME.DOC

--42--</pre><p>В приведенных примерах значение Content-transfer-encoding для внешних данных в формате postscript полагается по умолчанию как "7bit".</p><p>Заголовки общего и вложенного(их) писем (имеющих внешнее тело) должны удовлетворять тем же правилам, что и для типа message/partial во избежание путаницы.</p><p>Поскольку внешнее тело не пересылается в виде почты, то оно не обязано удовлетворять требованиям длины строк и иметь 7-битную форму, оно может быть просто бинарным файлом. Поэтому поле Content-Transfer-Encoding не является необходимым, хотя его наличие допускается.</p><p>Тело письма типа "message/external-body" обрабатывается в сответствии с основным синтаксисом стандарта RFC 822, в частности, все, что идет до первой последовательной пары концов строки (CRLF), является заголовком письма, а все, что идет после, является "мнимым" телом письма, которое игнорируется для большинства типов доступа.</p><p>Формальный синтаксис поля заголовка 'content-type' для данных типа 'message' — следующий:</p><pre>message_тип := "message" "/" message_подтип

message_подтип := "rfc822"
                / "partial" 2-3 partial_параметра
                / "external-body" 1 external_параметр
                / расширение (не предопределенный подтип)

partial_параметр := (";" "id" "=" значение)
                 /  (";" "number" "=" 1*ЦИФРА)
                 /  (";" "total" "=" 1*ЦИФРА)
; id и number требуются всегда; total требуется для последнего  фрагмен-
; та послания.

external_параметр := (";" "access-type" "=" тип_доступа)
                   / (";" "expiration" "=" дата-время)
             ; Дата-время должны быть экранированы кавычками
                   / (";" "size" "=" 1*Цифра)
                   / (";"  "permission"  "="  ("read"  /  "read-write"))
             ; Значение permission нечувствительно к регистру букв
                   / (";" "name" "=" значение)
                   / (";" "site" "=" значение)
                   / (";" "dir" "=" значение)
                   / (";" "mode" "=" значение)
                   / (";" "server" "=" значение)
                   / (";" "subject" "=" значение)
; access-type требуется всегда; все остальное — в зависимости от  значе-
; ния access-type

тип_доступа := "ftp" / "anon-ftp" / "tftp" / "local-file"
               / "afs" / "mail-server" /
               / расширение (непредопределенный параметр)
; Нечувствителен к регистру букв</pre><h3 id="p7.4">7.4. Тип 'Application'</h3><p>Этот тип используется для данных, неподпадающих под остальные категории, в частности, для данных, обрабатываемых прикладными почтовыми программами. Это информация, которая должна быть обработана соответствующим приложением для того, чтобы принять наглядную либо исполняемую для получателя форму. Предполагаемое использование для этого типа включает в себя пересылку файлов по почте, таблицы, данные для почтовых систем расписания, языки для "активной" (вычислительной) почты. (Последняя, в частности, может поднять проблемы безопасности, которые должны быть поняты разработчиками ПО и рассмотрены ниже в параграфе "Application/PostScript").</p><p>Например, тот, кто занимается расписанием встреч, может определить стандартное представление информации о датах запланированных встреч. "Умный" пользовательский почтовый агент может использовать эту информацию для проведения диалога с пользователем, и может затем посылать в дальнейшем почту, основанную на том диалоге. Вообще, существует несколько "активных" почтовых языков, разработанных для специализированных программ, которые посылаются по почте и автоматчески запускаются в системе получателя.</p><p>Подобные приложения могут быть определены как подтипы для типа "application". Изначально предопределено два подтипа: "octet-stream" и "PostScript".</p><p>В общем, подтип для 'application' зачастую может быть именем приложения, для которого предназначены пересылаемые данные. Однако, это не означает, что любое имя прикладной программы может свободно использоваться как подтип для 'application'. Такие употребления (кроме подтипов, начинающихся с "x-") должны быть зарегестрированы в IANA.</p><h4 id="p7.4.1">7.4.1. Основной подтип 'Application/Octet-Stream'</h4><p>Используется для обозначения того, что тело содержит бинарные данные. Набор возможных параметров включает следующие (но не ограничивается ими):</p><p><strong>TYPE</strong> — обобщенный тип или категория двоичных данных, эта информация больше предназначена для получателя, чем для автоматической обработки.</p><p><strong>PADDING</strong> — число заполняющих битов, добавленных к битовому потоку, содержащему данные, для формирования байтно-ориентированных данных. Полезно при заключении в тело битового потока, когда общее число битов не кратно восьми, то есть, размеру байта.</p><p>Дополнительный параметр, "conversions", определенный в [RFC-1341], был исключен в последствии.</p><p>В RFC 1341 также определен параметр <strong>"NAME"</strong>, указывающего имя файла, которое должно быть использовано при сохранении данных на диск. Но он опять же был отменен в ожидании введения отдельного поля заголовка Content-Disposition, которое будет определено в ближайшем будущем.</p><p>Рекомендуемое действие для почтовой программы, получившей почту типа application/octet-stream, — просто предложить записать данные в файл без какого-либо преобразования, или. возможно, произвести его в соответствии с указанием пользователя.</p><p>Для уменьшения опасности передачи вирусных и других намеренно разрушающих систему программ по почте, строго рекомендуется, чтобы почтовая программа получателя не производила запуск программы, заданной в параметре поля "Content-Type" (например, в параметре "interpreter="), использующей в качестве входных данных тело письма.</p><h4 id="p7.4.2">7.4.2. Подтип 'Application/PostScript'</h4><p>Тип "application/postscript" означает, что пересылается PostScript-документ и требует специальной программы для его обработки. В настоящий момент используются два языка — level 1 и более поздний — level 2.</p><p>PostScript-документы представляют собой интерпретируемые программы, которые могут содержать операторы обращения к диску и действий с файлами. Поэтому PostScript-документы представляют потенциальную опасность для системы получателя.</p><p>В некоторых интерпретаторах PostScript могут иметь место ошибки, которые могут быть использованы хакерами для несанкционированного доступа к системе получателя, и нельзя предложить какого-либо специфического действия для предотвращения подобной возможности, кроме исправления со временем подобных ошибок (если они, конечно, есть) производителями соответствующего ПО.</p><h4 id="p7.4.3">7.4.3. Другие подтипы типа Application</h4><p>Ожидается, что многие подтипы типа 'Application' будут введены в будущем. MIME-совместимые почтовые программы должны интерпретировать любой незнакомый им подтип как эквивалент 'application/octet-stream'.</p><p>Формальный синтаксис дла поля 'content-type' для данных типа 'application' дается следующим образом.</p><pre>application_тип :=  "application" "/" application_подтип

application_подтип := ("octet-stream" *stream_параметр)
                    / "postscript" / расширение (непредопределенный под-
                    тип)

stream_параметр :=  (";" "type" "=" значение)
                    / (";" "padding" "=" число_дополняющих_битов)

число_дополняющих_битов := "0" / "1" /  "2" /  "3" / "4" / "5" / "6" /
                           / "7"</pre><h3 id="p7.5">7.5. Тип 'Image'</h3><p>Этот тип означает, что тело письма содержит графический объект. Его подтипы соответствуют конкретным графическим форматам. Их значения нечувствительны к регистру букв. Два предопределенных подтипа — "jpeg" для формата JPEG с кодированием JFIF, и "gif" — для формата GIF.</p><p>Формальный синтаксис поля 'Content-Type':</p><pre>image_тип := "image" "/" ("gif" / "jpeg" / подтип-расширение)</pre><h3 id="p7.6">7.6. Тип 'Audio'</h3><p>Этот подтип означает, что тело содержит аудио-данные. Хотя пока еще нет консенсуса по "идеальному" аудио-формату для компьютеров, сейчас имеется сильная потребность в универсальном формате.</p><p>Предопределенный подтип — "basic" введен в ответ на это требование, обеспечивая минимальный примитивный аудио-формат. Ожидается определение в дальнейшем более "богатых" форматов, обеспечивающих более высокое качество воспроизведения.</p><p>Содержимое тела, имеющего подтип "audio/basic", — аудио-данные в 8-битной форме, кодированные с использованием ISDN mu-law. Формат, соответствующий этому подтипу, предполагает максимальную частоту звучания 8000 Hz и единственный канал.</p><p>Формальный синтаксис для поля 'Content-Type':</p><pre>audio_тип := "audio" "/" ("basic" / подтип-расширение)</pre><h3 id="p7.7">7.7. Тип 'Video'</h3><p>Этот тип означает, что в теле письма содержится анимационное изображение, возможно, со звуком и цветом. Термин "video" используется безотносительно к технологии получения подвижного во времени изображения. Подтип "mpeg" указывает на видео, кодированное в соответствии со стандартом MPEG.</p><p>Хотя MIME-стандарт запрещает смешение разнородных мультимедийных данных в одном теле (письма или части письма), многие так называемые "video"-форматы включают синхронизированный звук, что допускается для подтипов типа "video".</p><p>Формальный синтаксис для поля 'Content-Type':</p><pre>video-type := "video" "/" ("mpeg" / подтип-расширение)</pre><h3 id="p7.8">7.8. Экспериментальные значения поля 'Content-Type'</h3><p>Значение типа, начинающееся с "X-", считается частным, предназначенным для использования по договоренности между двумя или более почтовыми системами. Публично определенные (регестрированные) значения никогда не должны начинаться с префикса "X-".</p><p>В общем, использование X-типов верхнего уровня не рекомендуется. Производители почтового ПО должны по возможности обходиться использованием X-подтипов для предопределенных типов. Во многих случаях использование экспериментального подтипа более приемлимо, нежели типа верхнего уровня.</p><h4>Все определенные на сегодняшний день типы и подтипы</h4><table><tr><th>text</th><th>multipart</th><th>message</th><th>application</th><th>image</th><th>audio</th><th>video</th></tr><tr><td>plain</td><td>mixed</td><td>rfc822</td><td>octet-stream</td><td>jpeg</td><td>basic</td><td>mpeg</td></tr><tr><td>richtext</td><td>alternative</td><td>partial</td><td>postscript</td><td>gif</td><td></td><td>quicktime</td></tr><tr><td>enriched</td><td>digest</td><td>external-body</td><td>oda</td><td>ief</td><td></td><td></td></tr><tr><td>tab-separated-values</td><td>parallel</td><td>news</td><td>atomicmail</td><td>tiff</td><td></td><td></td></tr><tr><td></td><td>appledouble</td><td></td><td>andrew-inset</td><td></td><td></td><td></td></tr><tr><td></td><td>header-set</td><td></td><td>slate</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>wita</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>dec-dx</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>dca-rft</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>activemessage</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>rtf</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>applefile</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>mac-binhex40</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>news-message-id</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>news-transmission</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>wordperfect5.1</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>pdf</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>zip</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>macwriteii</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>msword</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>remote-printing</td><td></td><td></td><td></td></tr></table><p>Значения полей Content-Type и subtype, а также другие параметры заголовка являются чувствительными к регистру букв, если только не оговорены исключения для конкретного значения параметра.</p><h2 id="p.ii">II. Применение возможностей MIME в транспортных почтовых системах</h2><p>Хотя новые возможности, предоставляемые MIME, ориентированы в основном на пользовательские почтовые программы, однако, транспортные системы тоже могут воспользоваться преимуществами MIME.</p><p>Усилия создателей MIME были максимально сфокусированы на том, чтобы не требовать абсолютно никаких изменений на уровне транспортировки сообщений. Потому почта в MIME-формате проходит прозрачно на всех интернет- и интернет-подобных системах. То есть, при разработке и установке почтовых транспортов можно (хотя и не обязательно) полностью игнорировать существование MIME. Однако, MIME предоставляет некоторые возможности, которые могут быть полезными ответственным за транспортные услуги лицам. Используя эти возможности, транспортные системы могут обеспечить дополнительные виды услуг, недоступных в настоящее время недоступных, но могущих смягчить существующие проблемы.</p><p>Чтобы заниматься реализацией любого из механизмов, описанных ниже, необходимо ознакомиться с отличием между службой почтового транспорта и шлюзовой службой. В основном, почтовый транспорт ответственен за перемещение почтовых сообщений в пределах пространства почтовых сетей, подобных друг другу. С другой стороны, почтовые шлюзы совершают обмен почтой между двумя принципиально отличными почтовыми пространствами, в том числе и через неэлекторнные службы (как бумажная почта, например).</p><p>Общеполагается для почтовых транспортных систем неприемлимым изменять содержимое сообщений. В случае почтовых шлюзов, изменения зачастую неизбежно. Таким образом, многие из механизмов, описаных ниже, применяются только к шлюзам, и не должны использоваться в простых транспортных системах. Однако, возможно, что в некоторых специфических ситуациях (таких как в случае SMTP-соединений через межконтинентальную связь) может потребоваться изменять содержимое для обеспечения приемлимого обслуживания для таких ситуаций, и потому такой почтовый транспорт должен считаться уже фактически шлюзом. То есть, почтовые транспорты, которые намерены использовать описанные ниже функции, должны переклассифицировать себя как шлюзы.</p><h3 id="p.ii.1">II.1. Непринятая почта</h3><p>К сожалению частой обязанностью транспортных служб является отсылка почты обратно отправителю. Такое может произойти, если почту невозможно доставить или если она не удовлетворяет требованиям шлюза (слишком большой объем, например).</p><p>Раньше не было стандартных правил для отказа от принятия почтовых сообщений. Это было досадной, но не главной проблемой для текстовых сообщений. Для нетекстовых, однако, недостаток в стандартном формате отказа от приема является более критичным, потому что типично возвращенные пиьсма представляются их отправителю как текст, и пользователь, просматривающий картинку или звук, как если бы они были текстом, редко бывает счастлив от этого.</p><p>MIME позволяет легко инкапсулировать письма в том смысле, что полностью сохраняется их семантика. Простейший путь добиться этого — каждое возвращаемое письмо помещать в тело письма с типом "multipart/mixed", которое содержало бы две части — текстовую, содержащую пояснение причины отказа в принятии оригинального письма и вложение самого этого письма.</p><p>Подчеркивается, что транспорные программы вообще не нуждаются в распознавании структуры возвращаемого письма. От них лишь требуется правильно вложить его. Следующий пример показывает, как любое MIME-письмо может быть вложено (инкапсулировано) в письмо возврата так, что вся информация в нем будет корректно воспроизведена, если получатель (он же первый отправитель) будет читать его с помощью MIME-ориентированной почтовой программы:</p><pre>From: Mailer-Daemon
Subject: Rejected Message
Content-type: multipart/mixed; boundary=unique-boundary

--unique-boundary
Content-type: text/plain; charset=us-ascii

Посланное Вами письмо не принято. Детали отказа следующие:

From: Nathainel Borenstein
Message-ID: &lt;12345@bellcore.com&gt;
To: bush@whitehouse.gov
Subject: I know my rights!
Rejection-reason: Прием почты из Вашей организации  запре-
    щен.

Оригинальное письмо прилагается ниже.
--unique-boundary
Content-type: message/rfc822

Здесь находится ВОЗВРЩАЕМОЕ ПИСЬМО  ПОЛНОСТЬЮ,  начиная  с
заголовка.

--unique-boundary--</pre><p>В данном примере единственная вещь, которая не берется из стандартного набора фраз, это выбор метки границы. Фраза "unique-boundary" должна быть заменена строкой, не появляющейся ни в одной из частей сообщения.</p><p>ВАЖНО: Формат, приведенный выше, — лишь один из возможных путей отсылки непринятых писем с использованием MIME.</p><h3 id="p.ii.2">II.2. Разбиение (фрагментация) и сборка больших писем</h3><p>Одна из проблем, встречающихся все чаще и чаще в Internet-почте, возврат писем из-за ограничений по их объему. Особенный рост этой проблемы обусловлен расширением использования MIME, так как MIME позволяет посылать очень большие объекты, такие как звук, видео, графику. К счастью, MIME также обеспечивает механизмы, которые могут помочь ослабить эту проблему.</p><p>В частности, к ним относится MIME-тип "message/partial", который можно использовать для автоматического разбиения и сборки больших писем. Эта функция может поддерживаться полностью как на уровне пользовательских почтовых агентов, так и транспортными службами, которые могут его использовать для обеспечения полее разумного поведения при шлюзовании почты.</p><p>Ниже приводится пример, показывающий, как простое коротенькое письмо может быть разбито на два письма типа "message/partial". На практике, конечно, данное свойство разумно применять лишь для очень больших писем.</p><p>Первоначальное письмо:</p><pre>From:  Nathaniel Borenstein
To: Ned Freed:
Subject: a test message
Content-type: image/gif
Content-Transfer-Encoding: base64

R0lGODdhQAGMAbMAAAAAAP/u7swzIu6ZiLsiEd1EM+5VRGaI3WYAAO67qkRV
uwARd6q7/ywAAAAAQAGMAUME/hDISau9OOvNu/9gKI6kRJwoUa5s675wLM90l
XW5YKxqPyKRygxv2dr4czwlMCZrQLFTYHBJ2hlyQYFiaz+i0WWBou7fOq1x8vXWfU
qU1fJ2qEhYaHGjhZQmJ2QT1xBW1ak1xUdV0/VjtsbpUEDaEJCQOIpqeoNV+LXo5W
fVN3dZKceAQPvgyhwQ2lqcXGxx5wja59eJIGUNCszF90sYp50CoqFZ4DoqMMo6M</pre><p>может быть обратимо преобразовано в следующие два message/partial- -письма:</p><pre>From:  Nathaniel Borenstein


To: Ned Freed
Subject: a test message
Content-type: message/partial; id="xyx@host.com";
     number=1; total=2

Content-type: image/gif
Content-Transfer-Encoding: base64

R0lGODdhQAGMAbMAAAAAAP/u7swzIu6ZiLsiEd1EM+5VRGaI3WYAAO67qkRV</pre><p>и</p><pre>From:  Nathaniel Borenstein
To: Ned Freed
Subject: a test message
Content-type: message/partial; id="xyx@host.com";
     number=2; total=2

uwARd6q7/ywAAAAAQAGMAUME/hDISau9OOvNu/9gKI6kRJwoUa5s675wLM90l
XW5YKxqPyKRygxv2dr4czwlMCZrQLFTYHBJ2hlyQYFiaz+i0WWBou7fOq1x8vXWfU
qU1fJ2qEhYaHGjhZQmJ2QT1xBW1ak1xUdV0/VjtsbpUEDaEJCQOIpqeoNV+LXo5W
fVN3dZKceAQPvgyhwQ2lqcXGxx5wja59eJIGUNCszF90sYp50CoqFZ4DoqMMo6M</pre><p>Фрагментирование таких писем, вместо их отсылки обратно, было бы вполне обусловлено для применения шлюзовыми службами. Конечно, шлюзу часто неизвестны ограничения по размеру в другой системе, но разумные предположения всегда возможны.</p><p>Фрагментирование и сборка писем могут быть выполнены, в зависимости от обстоятелств, как отправляющей, так и принимающей системой, в зависимости от того, какая из них знает больше о способностях другой.</p><h3 id="p.ii.3">II.3. Использование или удаление указателей External-Body (внешнего тела)</h3><p>Другой MIME-тип, ориентированный на слишком большие письма, это "message/external-body". Он обеспечивает почтовым транспортным службам, оптимизировать почтовый траффик в своей системе. Однако, когда почта пересекает медленный и дорогой участок, например, звено спутниковой связи через Тихий океан, может иметь смысл считать указываемые данные и передать их в качестве действительного тела письма, либо скопировать в новое, более доступное место, соответствующим образом изменив ссылку в заголовке письма. Поскольку спецификация данного типа допускает наличие даты аннулирования ресурса, почтовый транспорт может идти на компромисс между пропускной способностью своей системы и ее дисковым пространством, отданным под хранение внешних данных писем, чтобы оптимизировать использование этих внешних данных.</p><p>Такое поведение требует осторожного анализа соотношения затрат и выгоды. Однако, потенциальные выгоды очевидны, так что разумное использование таких возможностей не повредит.</p><p>Например, приведенное ниже письмо содержит ссылку на внешние PostScript-данные:</p><pre>From:  Nathaniel Borenstein
To: Ned Freed
Subject: The latest MIME draft
Content-Type: message/external-body;
     name="BodyFormats.ps";
     site="thumper.bellcore.com";
     access-type=ANON-FTP;
     directory="pub";
     mode="image";
     expiration="Fri, 14 Jun 1991 19:13:14 -0400 (EDT)"

Content-type: application/postscript</pre><p>Шлюз  в  Австралию  может  выбрать — скопировать  ли  файл   в    какой-либо австралийский  FTP-архив,  изменив  соответствующие  параметры  в  заголовке письма, или оставить все без изменений, или считать данные и  вложить  их  в письмо целиком:</p><pre>From:  Nathaniel Borenstein
To: Ned Freed
Subject: The latest MIME draft
Content-type: application/postscript

%!PS-Adobe-1.0
%%Creator: greenbush:nsb (Nathaniel Borenstein,MRE 2A-
274,4270,9938586,21462)
и так далее...</pre><p>Этот  пример  предполагает  как  выгоду  (немедленно  доступные   получателю данные), так и возможные затраты (если  список  рассылки  велик,  то  письмо придется разослать всем, хотя только некотоые из получателей  обратились  бы за данными письма в ближайшее время).</p><p>Кроме того, вместо замены ссылки на внешние данные их натуральным включением в  письмо,  можно  трансформировать  оригинальное  письмо  в  письмо    типа "multipart/alternative", содержащее как ссылку  на  внешние  данные,  так  и копию этих данных. Это означает,  что  при  перенаправлении  письма  другому пользователю перенаправлена будет только та часть, которая содержит  ссылку. Кроме того, получатель, хоть и получит данные сразу целиком,  все  равно  не потеряет  информацию  о  местоположении  оригинального  ресурса,    и    при необходимости  сможет  скачать  более  новую  его  версию  в  будущем.   Это иллюстрируется следующим примером:</p><pre>From:  Nathaniel Borenstein
To: Ned Freed
Subject: The latest MIME draft
Content-type: multipart/alternative; boundary=foo

--foo
Content-Type: message/external-body;
     name="BodyFormats.ps";
     site="thumper.bellcore.com";
     access-type=ANON-FTP;
     directory="pub";
     mode="image";
     expiration="Fri, 14 Jun 1991 19:13:14 -0400 (EDT)"

Content-type: application/postscript
--foo
Content-type: application/postscript

%!PS-Adobe-1.0
%%Creator: greenbush:nsb (Nathaniel Borenstein,MRE 2A-
274,4270,9938586,21462)
etc...
--foo--</pre><p>Аналогично, в случае, когда внешние данные копируются транспортной  системой на локальный FTP, можно сделать в письме две части типа 'external-body', что позволит получателю выбрать, с какого из FTP предпочтительнее забирать  тело письма.</p><h3 id="p.ii.4">II.4. Преобразование графических и других форматов</h3><p>В настоящее время MIME определяет два  графических  формата — image/gif  и image/jpeg. Первый — более удобен для многих пользователей,  понятен  многим системам, и отображается довольно быстро. Последний гораздо более  компактен и потому менее сказывается на увеличении траффика.</p><p>Почтовые транспортные системы могут оптимизировать  и  траффик,  и  удобства получателей разумной трансляцией этих  форматов  (а  также  других,  которые могут быть добавлены в будущем). Если письмо типа image/gif пересылается  на длинную дистанцию, оно может быть перетранслировано в image/jpeg.  Когда  же данные типа image/jpeg получены системой, в  которой  находится  получатель, для конечной доставки, они снова могут  быть  перетранслированы  в  GIF  для удобств получателя.</p><p>Подобные преобразования форматов также рекомендуются и для аудио-данных.</p><p>Если  преобразование  выполнено,  настоятельно    рекомендуется    добавлять каким-либо образом (например,  в  поле  заголовка  Received)  информацию  об истории преобразований документа, в письме содержащегося.</p><p>Однако, трансляция форматов обычно ограничивается шлюзовыми службами и менее предпочтительна для обычных транспортных служб. Причем, те  службы,  которые выполняют преобразования, должны распознавать поле  Conterent-Conversion,  в котором отправитель может  разрешить  либо  запретить  любые  преобразования форматов данных,  поскольку  многие  пользователи  принципиально  неприемлют преобразования, так как считают, что при некоторые из них могут  привести  к ухудшению качества документа:</p><pre>Content-Conversion: prohibited</pre><p>или:</p><pre>Content-Conversion: permitted</pre><p>По  умолчанию  (если  это  поле  отсутствует)    предполагается    значение
'permitted'.</p><h3 id="p.ii.5">II.5. Надежное кодирование данных</h3><p>В некоторых случаях при прохождении через шлюз  данные  могут  не  сохранить своего вида к следующему шагу транспортировки. К примеру,  почта  проходящая через шлюз ASCII -> EBCDIC, может потерять информацию, содержащую  некоторые спецсимволы. В подобных случаях шлюз может  обеспечить  данным  сохранность, применив один из MIME-алгоритмов — base64 или quoted-printable к телу письма или его части. Это, как правило, трансформация  без  потерь,  но  необходимо добиться, чтобы результирующее письмо целиком отвечало стандарту MIME,  даже если изначально оно таковым не было (в частности, должно быть добавлено поле заголовка MIME-Version).</p><h2 id="p.references">Ссылки</h2><table itemprop="references"><tr><td>[US-ASCII]</td><td>Coded Character Set — 7-Bit American Standard Code for Information Interchange, ANSI X3.4-1986.</td></tr><tr><td>[ATK]</td><td>Borenstein, Nathaniel S., Multimedia Applications Development with the Andrew Toolkit, Prentice-Hall, 1990.</td></tr><tr><td>[GIF]</td><td>Graphics Interchange Format (Version 89a), Compuserve, Inc., Columbus, Ohio, 1990.</td></tr><tr><td>[ISO-2022]</td><td>International Standard — Information Processing — ISO 7-bit and 8-bit coded character sets — Code extension techniques, ISO 2022:1986.</td></tr><tr><td>[ISO-8859]</td><td>Information Processing — 8-bit Single-Byte Coded Graphic Character Sets — Part 1: Latin Alphabet No. 1, ISO 8859-1:1987. Part 2: Latin alphabet No. 2, ISO 8859-2, 1987. Part 3: Latin alphabet No. 3, ISO 8859-3, 1988. Part 4: Latin alphabet No. 4, ISO 8859-4, 1988. Part 5: Latin/Cyrillic alphabet, ISO 8859-5, 1988. Part 6: Latin/Arabic alphabet, ISO 8859-6, 1987. Part 7: Latin/Greek alphabet, ISO 8859-7, 1987. Part 8: Latin/Hebrew alphabet, ISO 8859-8, 1988. Part 9: Latin alphabet No. 5, ISO 8859-9, 1990.</td></tr><tr><td>[ISO-646]</td><td>International Standard — Information Processing — ISO 7-bit coded character set for information interchange, ISO 646:1983.</td></tr><tr><td>[MPEG]</td><td>Video Coding Draft Standard ISO 11172 CD, ISO IEC/TJC1/SC2/WG11 (Motion Picture Experts Group), May, 1991.</td></tr><tr><td>[PCM]</td><td>CCITT, Fascicle III.4 — Recommendation G.711, Geneva, 1972, «Pulse Code Modulation (PCM) of Voice Frequencies».</td></tr><tr><td>[POSTSCRIPT]</td><td>Adobe Systems, Inc., PostScript Language Reference Manual, Addison-Wesley, 1985.</td></tr><tr><td>[POSTSCRIPT2]</td><td>Adobe Systems, Inc., PostScript Language Reference Manual, Addison-Wesley, Second Edition, 1990.</td></tr><tr><td>[X400]</td><td>Schicker, Pietro, «Message Handling Systems, X.400», Message Handling Systems and Distributed Applications, E. Stefferud, O-j. Jacobsen, and P. Schicker, eds., North-Holland, 1989, pp. 3-41.</td></tr><tr><td>[RFC-783]</td><td>Sollins, K., «TFTP Protocol (revision 2)», RFC 783, MIT, Июнь 1981.</td></tr><tr><td>[RFC-821]</td><td>Postel, J., «Simple Mail Transfer Protocol», STD 10, RFC 821, USC/Information Sciences Institute, Август 1982.</td></tr><tr><td>[RFC-822]</td><td>Crocker, D., «Standard for the Format of ARPA Internet Text Messages», STD 11, RFC 822, UDEL, Август 1982.</td></tr><tr><td>[RFC-934]</td><td>Rose, M., and E. Stefferud, «Proposed Standard for Message Encapsulation», RFC 934, Delaware and NMA, Январь 1985.</td></tr><tr><td>[RFC-959]</td><td>Postel, J. и J. Reynolds, «File Transfer Protocol», STD 9, RFC 959, USC/Information Sciences Institute, October 1985.</td></tr><tr><td>[RFC-1049]</td><td>Sirbu, M., «Content-Type Header Field for Internet Messages», STD 11, RFC 1049, CMU, Март 1988.</td></tr><tr><td>[RFC-1421]</td><td>Linn, J., «Privacy Enhancement for Internet Electronic Mail: Part I — Message Encryption and Authentication Procedures», RFC 1421, IAB IRTF PSRG, IETF PEM WG, Февраль 1993.</td></tr><tr><td>[RFC-1154]</td><td>Robinson, D. и R. Ullmann, «Encoding Header Field for Internet Messages», RFC 1154, Prime Computer, Inc., Апрель 1990.</td></tr><tr><td>[RFC-1341]</td><td>Borenstein, N., and N. Freed, «MIME (Multipurpose Internet Mail Extensions): Mechanisms for Specifying and Describing the Format of Internet Message Bodies», RFC 1341, Bellcore, Innosoft, Июнь 1992.</td></tr><tr><td>[RFC-1342]</td><td>Moore, K., «Representation of Non-Ascii Text in Internet Message Headers», RFC 1342, University of Tennessee, Июнь 1992.</td></tr><tr><td>[RFC-1343]</td><td>Borenstein, N., «A User Agent Configuration Mechanism for Multimedia Mail Format Information», RFC 1343, Bellcore, Июнь 1992.</td></tr><tr><td>[RFC-1344]</td><td>Borenstein, N., «Implications of MIME for Internet Mail Gateways», RFC 1344, Bellcore, Июнь 1992.</td></tr><tr><td>[RFC-1345]</td><td>Simonsen, K., «Character Mnemonics & Character Sets», RFC 1345, Rationel Almen Planlaegning, Июнь 1992.</td></tr><tr><td>[RFC-1426]</td><td>Klensin, J., (WG Chair), Freed, N., (Editor), Rose, M., Stefferud, E., and D. Crocker, «SMTP Service Extension for 8bit-MIME transport», RFC 1426, United Nations Universit, Innosoft, Dover Beach Consulting, Inc., Network Management Associates, Inc., The Branch Office, Февраль 1993.</td></tr><tr><td>[RFC-1522]</td><td>Moore, K., «Representation of Non-Ascii Text in Internet Message Headers» RFC 1522, University of Tennessee, Сентябрь 1993.</td></tr><tr><td>[RFC-1340]</td><td>Reynolds, J., and J. Postel, «Assigned Numbers», STD 2, RFC 1340, USC/Information Sciences Institute, Июль 1992.</td></tr></table></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 1521 - Почтовый стандарт MIME",disqus_identifier="1521.rfc",disqus_url="http://rfc2.ru/1521.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>