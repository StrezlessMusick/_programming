<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../3031.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 3031 — Архитектура многопротокольной коммутации на основе маркеров потока (MPLS)</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../3031.rfc">RFC 3031 — Архитектура многопротокольной коммутации на основе маркеров потока (MPLS)</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 3031</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank" rel="nofollow"><span itemprop="alternativeHeadline">Multiprotocol Label Switching Architecture</span></a></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Предложенный стандарт</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="2001-01-02">Январь 2001</time></dd><dd><div class="icon i5"></div> Авторы: <span itemprop="author">E. Rosen</span>, <span itemprop="author">A. Viswanathan</span>, <span itemprop="author">R. Callon</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Мельников Дмитрий Анатольевич</span></dd></dl><div id="text" itemprop="articleBody"><h2 id="p1">Оглавление</h2><ul class="map"><li><a href="print#p1">1. RFC 3031</a></li><li><a href="print#p2">2. Введение в MPLS</a></li><li class="lia"><a href="print#p2.1">2.1. Общие вопросы</a></li><li class="lia"><a href="print#p2.2">2.2. Термины и определения</a></li><li class="lia"><a href="print#p2.3">2.3. Сокращения и аббревиатуры</a></li><li><a href="print#p3">3. Концептуальные основы MPLS-систем</a></li><li class="lia"><a href="print#p3.1">3.1. Маркеры</a></li><li class="lia"><a href="print#p3.2">3.2. LSR-маршрутизаторы нисходящего и восходящего потоков</a></li><li class="lia"><a href="print#p3.3">3.3. Промаркированный (помеченный) IP-пакет</a></li><li class="lia"><a href="print#p3.4">3.4. Назначение и распределение маркеров потока</a></li><li class="lia"><a href="print#p3.5">3.5. Атрибуты для процедуры привязки маркеров потока</a></li><li class="lia"><a href="print#p3.6">3.6. Протоколы доставки (распределения) маркеров потока</a></li><li class="lia"><a href="print#p3.7">3.7. Незапрашиваемый или нисходящий поток по требованию</a></li><li class="lia"><a href="print#p3.8">3.8. Режим сохранения маркера потока</a></li><li class="lia"><a href="print#p3.9">3.9. Набор маркеров потока</a></li><li class="lia"><a href="print#p3.10">3.10. Запись о доставке маркера на следующий ретрансляционный участок</a></li><li class="lia"><a href="print#p3.11">3.11. Отображение входящего маркера</a></li><li class="lia"><a href="print#p3.12">3.12. Отображение FEC-класса в совокупность NHLFE-записей</a></li><li class="lia"><a href="print#p3.13">3.13. Замена маркеров</a></li><li class="lia"><a href="print#p3.14">3.14. Назначение и уникальность маркеров</a></li><li class="lia"><a href="print#p3.15">3.15. LSP-маршрут, вход LSP-маршрута, выход LSP-маршрута</a></li><li class="lia"><a href="print#p3.16">3.16. «Выталкивание» на предпоследнем ретрансляционном участке</a></li><li class="lia"><a href="print#p3.17">3.17. Следующий ретрансляционный участок LSP-маршрута</a></li><li class="lia"><a href="print#p3.18">3.18. Недействительные входящие маркеры потоков</a></li><li class="lia"><a href="print#p3.19">3.19. Управление LSP-маршрутом: регулируемое или независимое</a></li><li class="lia"><a href="print#p3.20">3.20. Агрегирование</a></li><li class="lia"><a href="print#p3.21">3.21. Выбор маршрута</a></li><li class="lia"><a href="print#p3.22">3.22. Отсутствие исходящего маркера</a></li><li class="lia"><a href="print#p3.23">3.23. Время жизни IP-пакета (Time-to-Live, TTL)</a></li><li class="lia"><a href="print#p3.24">3.24. Контроль возникновения петлевого маршрута</a></li><li class="lia"><a href="print#p3.25">3.25. Кодирование маркеров потоков</a></li><li class="lia"><a href="print#p3.26">3.26. Процедура слияния маркеров потоков</a></li><li class="lia"><a href="print#p3.27">3.27. Туннели и иерархия</a></li><li class="lia"><a href="print#p3.28">3.28. Доставка данных о LDP-протоколе</a></li><li class="lia"><a href="print#p3.29">3.29. Один или несколько LDP-протоколов?</a></li><li><a href="print#p4">4. Реализационные аспекты MPLS-архитектуры</a></li><li class="lia"><a href="print#p4.1">4.1. MPLS-архитектура и трафик с поузловой маршрутизацией</a></li><li class="lia"><a href="print#p4.2">4.2. MPLS-архитектура и точно настраиваемый LSP-маршруты</a></li><li class="lia"><a href="print#p4.3">4.3. Наборы маркеров и процедура неявного информационного обмена маркерами</a></li><li class="lia"><a href="print#p4.4">4.4. MPLS-архитектура и многонаправленная маршрутизация</a></li><li class="lia"><a href="print#p4.5">4.5. Сходящиеся деревья из LSP-маршрутов</a></li><li class="lia"><a href="print#p4.6">4.6. Формирование LSP-туннелей между граничными BGP-маршрутизаторами</a></li><li class="lia"><a href="print#p4.7">4.7. Другие варианты применения LSP-туннелей с поузловой маршрутизацией</a></li><li class="lia"><a href="print#p4.8">4.8. MPLS-архитектура и системы с групповой адресацией</a></li><li><a href="print#p5">5. Процедуры распределения (доставки) маркеров (при поузловой маршрутизации)</a></li><li class="lia"><a href="print#p5.1">5.1. Процедуры для оповещения о маркерах и для использования маркеров</a></li><li class="lia"><a href="print#p5.2">5.2. MPLS-схемы: допустимые комбинации процедур</a></li><li><a href="print#p6">6. Вопросы информационной безопасности</a></li><li><a href="print#p.references">Ссылки</a></li></ul><h2 id="p2">2. Введение в MPLS</h2><p>Этот стандарт определяет архитектуру многопротокольной коммутации на основе маркеров потока (Multiprotocol Label Switching — MPLS). Данный стандарт не рассматривает системы с групповой адресаций (multicast).</p><h3 id="p2.1">2.1. Общие вопросы</h3><p>Так как пакет сетевого уровня (IP-пакет) доставляется в дейтаграммном режиме от одного маршрутизатора к другому (следующему), каждый маршрутизатор независимо принимает решение о дальнейшей доставке такого пакета. Т.е. каждый маршрутизатор анализирует заголовок IP-пакета (IP-заголовок), и каждый маршрутизатор реализует алгоритм маршрутизации на сетевом уровне. Каждый маршрутизатор независимо выбирает следующий ретрансляционный участок для IP-пакета, основываясь на анализе IP-заголовка и результатов выполнения алгоритма маршрутизации.</p><p>IP-заголовки содержат значительно больше информации, чем это необходимо для простого выбора следующего ретрансляционного участка. Процедура выбора следующего ретрансляционного участка можно представить как выполнение композиции из двух функций. Первая функция разбивает (по заданному критерию) всю совокупность возможных IP-пакетов на множество эквивалентных классов доставки (Forwarding Equivalence Class — FEC). Вторая функция заключается в отображении каждого FEC-класса в следующий ретрансляционный участок. Так как это касается решения о доставке, различные IP-пакеты, подлежащие отображение в один и тот же FEC-класс, являются неразличимыми. Все IP-пакеты, принадлежащие соответствующему FEC-классу и которые поступают из соответствующего сетевого узла, затем будут следовать по одному и тому же ретрансляционному маршруту (или если используются некоторые типы многонаправленной маршрутизации, то они все будут следовать по одному из совокупности маршрутов, которые относятся к FEC-классу).</p><p>Как правило, при стандартной доставке IP-пакетов соответствующий маршрутизатор будет рассматривать два IP-пакета, как принадлежащие одному и тому же FEC-классу, если в маршрутной таблице этого маршрутизатора имеет место некоторый префикс <em>Х</em> IP-адреса, обладающий «наиболее длинным совпадением» (по числу следующих друг за другом бит IP-адреса) при сравнении его с IP-адресом получателя в каждом IP-пакете. Так как IP-пакеты перемещаются по сети, то на каждом очередном ретрансляционном участке осуществляется «переоценка» IP-пакета и «отнесение» его к определённому FEC-классу.</p><p>В MPLS-системах «отнесение» соответствующего IP-пакета к определённому FEC-классу выполняется только один раз, т.е. сразу после того, как IP-пакет поступил в сеть. FEC-класс, к которому был «приписан» IP-пакет, кодируется с помощью величины, имеющей небольшой фиксированный размер (длину), который именуется как «маркер потока» (или просто «маркер»). Когда IP-пакет доставляется на следующий ретрансляционный участок, то маркер передаётся вместе с ним. Т.е. IP-пакеты помечаются (маркируются) ещё до начала их доставки.</p><p>На последующих ретрансляционных участках анализ IP-заголовков не проводится. Более того, маркер используется в качестве индекса в таблице, по которому определяется следующий ретрансляционный участок и новый маркер. Старый маркер заменяется новым, а IP-пакет доставляется на свой следующий ретрансляционный участок.</p><p>Парадигмой доставки данных в MPLS-системах является то, что после «приписки» IP-пакета к FEC-классу все последующие маршрутизаторы больше не обрабатывают IP-заголовок. Вся доставка осуществляется на основе маркеров. Такой способ обладает рядом следующих преимуществ по сравнению с обычной доставкой данных (коммутацией пакетов на сетевом уровне):</p><ul class="list lia"><li><p>Доставка данных в MPLS-системах может быть осуществлена с помощью коммутаторов, которые способны проанализировать и обновить (заменить) поступивший маркер, но которые, либо вообще не способны анализировать IP-заголовки (заголовки сетевого уровня), либо не способны анализировать IP-заголовки (заголовки сетевого уровня) с необходимой скоростью обработки.</p></li><li><p>После того, как поступивший в сеть IP-пакет был отнесён к соответствующему FEC-классу, входной маршрутизатор (маршрутизатор доступа, ingress router), при определении принадлежности к FEC-классу, может использовать любую информацию о IP-пакете, которой он обладает, даже если эта информация не могла быть извлечена из IP-заголовка (заголовка сетевого уровня). Например, IP-пакеты, поступающие на вход через различные канальные интерфейсы, могут быть отнесены к различным FEC-классам. В то время как при стандартной коммутации и доставке IP-пакетов можно анализировать только ту информацию, которая содержится в IP-заголовках пакетов сетевого уровня.</p></li><li><p>IP-пакет (сетевого уровня), поступивший в сеть на соответствующий маршрутизатор, может получить маркер потока, который будет отличаться от того, который бы он получил, если бы поступил в сеть на другой маршрутизатор. В результате — решения о доставке, которые зависят от функциональности входного маршрутизатора, могли бы приниматься более легко. Это невозможно обеспечить при стандартной коммутации и доставке IP-пакетов, так как уникальный идентификатор (УИД) входного маршрутизатора не перемещается вместе с IP-пакетом.</p></li></ul><ul class="list lia"><li><p>Анализ, на основе которого определяется FEC-класс IP-пакета, может становиться всё более и более сложным, но без каких-либо последствий для всех тех маршрутизаторов, которые доставляют только маркированные IP-пакеты.</p></li><li><p>Иногда весьма желательно «принуждать» IP-пакет следовать по соответствующему маршруту, который был однозначно выбран в момент поступления IP-пакета в сеть или раньше, точнее ещё до того, как стандартный алгоритм динамической маршрутизации «сделает свой выбор» относительно продвижения IP-пакета по сети. Такое решение может основываться на положениях сетевой политики (например, доставки или безопасности), либо зависеть от стратегии управления потоками (трафиком) в сети. При стандартной коммутации и доставке IP-пакетов это означает, что IP-пакет должен быть снабжён кодом, определяющим его маршрут доставки (так называемый «маршрут, определяемый источником»). При MPLS-коммутации маркер потока может использоваться для указания маршрута, и при этом нет необходимости указывать в IP-пакете УИД точного маршрута доставки.</p></li></ul><p>Некоторые маршрутизаторы анализируют IP-заголовок (заголовок сетевого уровня) не только для определения следующего ретрансляционного участка доставки пакета, но и для определения приоритета (precedence) или категории обслуживания (class of service) IP-пакета. Более того, они могут использовать различные правила обслуживания или пороговые значения для уничтожения разных IP-пакетов. MPLS-системы позволяют (но не требуют) определять приоритет или категорию обслуживания IP-пакета полностью или частично из самого маркера потока. В этом случае говорят, что маркер потока представляет собой сочетание FEC-класса и приоритет или категорию обслуживания IP-пакета.</p><p>Аббревиатура «MPLS» означает «Multiprotocol Label Switching» — многопротокольная коммутация на основе маркеров потока. Термин «многопротокольный» (multiprotocol) означает, что этот вариант способа коммутации пакетов приемлем для любого протокола сетевого уровня. В данном стандарте речь пойдёт о IP-протоколе (Internetworking Protocol — протокол межсетевого взаимодействия), как протоколе сетевого уровня. Маршрутизатор, который поддерживает MPLS-коммутацию, именуется как «Label Switching Router» или LSR-маршрутизатор.</p><h3 id="p2.2">2.2. Термины и определения</h3><p>Рассмотрим наиболее общие термины и определения. В дальнейшем некоторые из них будут описаны более подробно.</p><ul class="lia list"><li><p class="b">Идентификатор канала передачи данных (DLCI — Data Link Connection Identifier)</p><p class="lia">Используется сетях ретрансляции кадров (Frame Relay) для идентификации соединений канального уровня.</p></li><li><p class="b">Эквивалентный класс доставки (Forwarding Equivalence Class — FEC)</p><p class="lia">Группа (последовательность) IP-пакетов, которые доставляются одним и тем же способом (например, доставляются по одному и тому же маршруту и обрабатываются одним и тем же способом).</p></li><li><p class="b">Слияние идентификаторов канала передачи данных (frame merge)</p><p class="lia">Слияние маркеров, когда MPLS-маркер представляет собой поле, содержащее идентификатор канала передачи данных при доставке данных по сети c ретрансляцией кадров (Frame Relay), и при этом проблема чередования ячеек не возникает.</p></li><li><p class="b">Маркер потока (маркер) (label)</p><p class="lia">Идентификатор, как правило, локального значения, связанный с физической средой передачи, имеющий небольшую фиксированную длину (размер) и который используется для обозначения FEC-класса.</p></li><li><p class="b">Слияние маркеров (label merging)</p><p class="lia">Замена нескольких входящих маркеров соответствующего FEC-класса на один исходящий маркер.</p></li><li><p class="b">Замена маркера (label swap)</p><p class="lia">Основная процедура доставки, включающая анализ входящего маркера с целью определения исходящего маркера, повторное обрамление, определение транспортного порта и анализа другой управляющей информации для доставки данных.</p></li><li><p class="b">Процедура замены маркера (label swapping)</p><p class="lia">Парадигма доставки данных, позволяющая структурировать поток данных на основе использования маркеров потока с целью идентификации классов IP-пакетов (с данными), обработка которых одинакова в течение всего периода их доставки.</p></li><li><p class="b">Ретрансляционный участок с MPLS-коммутацией (label switched hop)</p><p class="lia">Ретрансляционный участок между двумя MPLS-узлами, по которому доставляются данные с использованием маркеров потока.</p></li><li><p class="b">Маршрут с MPLS-коммутацией (label switched path — LSP-маршрут)</p><p class="lia">Маршрут через один или несколько LSR-маршрутизаторов одного уровня иерархии, по которому доставляются IP-пакеты соответствующего FEC-класса.</p></li><li><p class="b">Маршрутизатор с MPLS-коммутацией (Label Switching Router — LSR-маршрутизатор)</p><p class="lia">MPLS-узел, который обеспечивает доставку реальных IP-пакетов (сетевого уровня).</p></li><li><p class="b">Уровень 2 (layer 2)</p><p class="lia">Канальный уровень ЭМВОС или Интернет-архитектуры, расположенный под сетевым (3-им) уровнем, и соответствующий протокол этого уровня. Доставка осуществляется на канальном уровне, невзирая на то, является ли анализируемый маркер потока АТМ-идентификатором (VPI/VCI), FR-идентификатором (DLCI) или MPLS-маркером. При этом в процессе доставки реализуется процедура замены маркеров, имеющих небольшую фиксированную длину.</p></li><li><p class="b">Уровень 3 (layer 3)</p><p class="lia">Сетевой уровень ЭМВОС или Интернет-архитектуры и соответствующий протокол этого уровня. На этом уровне функционируют IP-протокол и соответствующие протоколы маршрутизации, которые инициализируют функционирование канального (2-го) уровня.</p></li><li><p class="b">Выявление петлевого маршрута (loop detection)</p><p class="lia">Способ, обеспечивающий определение петлевых маршрутов. Данные могут транслироваться по петлевому маршруту, который в последствие будет выявлен.</p></li></ul><ul class="list lia"><li><p class="b">Блокировка петлевого маршрута (loop prevention)</p><p class="lia">Способ, обеспечивающий запрет на доставку данных по петлевому маршруту (данные по такому маршруту никогда не транслируются).</p></li><li><p class="b">Набор маркеров потока (label stack)</p><p class="lia">Упорядоченная совокупность маркеров потока.</p></li><li><p class="b">Точка слияния (merge point)</p><p class="lia">Узел, в котором осуществляется слияние маркеров потока.</p></li><li><p class="b">MPLS-сегмент (MPLS domain)</p><p class="lia">Совокупность смежных узлов, которые осуществляют MPLS-маршрутизацию и доставку, и которые входят в один маршрутизационный или административный сетевой сегмент.</p></li><li><p class="b">Граничный MPLS-узел (MPLS edge node)</p><p class="lia">MPLS-узел, который соединяет MPLS-сегмент с сетевым узлом, расположенным за пределами MPLS-сегмента, либо по тому, что он не является MPLS-узлом, либо по тому, что он расположен в другом сетевом сегменте. Заметим, что если LSR-маршрутизатор имеет связь с ближайшим соседним IP-узлом, который не является MPLS-узлом, то этот LSR-маршрутизатор является граничным MPLS-узлом.</p></li><li><p class="b">Выходной MPLS-узел (MPLS egress node)</p><p class="lia">Граничный MPLS-узел, роль которого заключается в управлении трафиком, когда последний «покидает» MPLS-сегмент.</p></li><li><p class="b">Входной MPLS-узел (MPLS ingress node)</p><p class="lia">Граничный MPLS-узел, роль которого заключается в управлении трафиком, когда последний «поступает» в MPLS-сегмент.</p></li><li><p class="b">MPLS-маркер (MPLS label)</p><p class="lia">Маркер, который содержится в заголовке транслируемого IP-пакета, и который определяет FEC-класс этого IP-пакета.</p></li><li><p class="b">MPLS-узел (MPLS node)</p><p class="lia">Сетевой узел, который реализует MPLS-коммутацию. MPLS-узел способен реализовать несколько протоколов управления MPLS-коммутацией, один или несколько протоколов маршрутизации сетевого уровня и доставлять IP-пакеты на основе маркеров потока. Дополнительно MPLS-узел способен реализовать доставку простых IP-пакетов (сетевого уровня).</p></li><li><p class="b">Виртуальное соединение (virtual circuit)</p><p class="lia">Соединение протокола канального уровня, ориентированного на установление соединения, например, АТМ-протокол или FR-протокол, требующие обмена информацией о состоянии соединения между коммутаторами канального уровня.</p></li><li><p class="b">Слияние маркеров виртуального соединения (VC merge)</p><p class="lia">Слияние маркеров, когда MPLS-маркер представляет собой поле, содержащее идентификатор виртуального соединения, АТМ-протокола (либо комбинацию идентификатор виртуального соединения/маршрута), которое позволяет объединить несколько идентификаторов виртуального соединения в один единственный идентификатор виртуального соединения.</p></li><li><p class="b">Слияние маркеров в рамках виртуального маршрута (VP merge)</p><p class="lia">Слияние маркеров, когда MPLS-маркер представляет собой поле, содержащее повторяющийся идентификатор виртуального маршрута, АТМ-протокола, которое позволяет объединить несколько идентификаторов виртуального маршрута в один единственный идентификатор виртуального маршрута. В таком случае, две АТМ-ячейки могли бы иметь один и тот же идентификатор виртуального соединения, если они были отправлены только одним и тем же сетевым узлом. Это позволяет промаркировать АТМ-ячейки различных источников с помощью одного идентификатора виртуального соединения.</p></li><li><p class="b">Идентификатор виртуального соединения/маршрута (VPI/VCI)</p><p class="lia">Идентификатор, используемый в АТМ-сетях для обозначения виртуальных соединений.</p></li></ul><h3 id="p2.3">2.3. Сокращения и аббревиатуры</h3><table><tr><td>ATM</td><td>Asynchronous Transfer Mode (асинхронный режим доставки)</td></tr><tr><td>BGP</td><td>Border Gateway Protocol</td></tr><tr><td>DLCI</td><td>Data Link Circuit Identifier</td></tr><tr><td>FEC</td><td>Forwarding Equivalence Class</td></tr><tr><td>FTN</td><td>FEC to NHLFE Map</td></tr><tr><td>IGP</td><td>Interior Gateway Protocol</td></tr><tr><td>ILM</td><td>Incoming Label Map</td></tr><tr><td>IP</td><td>Internet Protocol</td></tr><tr><td>LDP</td><td>Label Distribution Protocol</td></tr><tr><td>L2</td><td>Layer 2 (канальный уровень)</td></tr><tr><td>L3</td><td>Layer 3 (сетевой уровень)</td></tr><tr><td>LSP</td><td>Label Switched Path</td></tr><tr><td>LSR</td><td>Label Switching Router</td></tr><tr><td>MPLS</td><td>MultiProtocol Label Switching</td></tr><tr><td>NHLFE</td><td>Next Hop Label Forwarding Entry</td></tr><tr><td>SVC</td><td>Switched Virtual Circuit</td></tr><tr><td>SVP</td><td>Switched Virtual Path</td></tr><tr><td>TTL</td><td>Time-To-Live</td></tr><tr><td>VC</td><td>Virtual Circuit</td></tr><tr><td>VCI</td><td>Virtual Circuit Identifier</td></tr><tr><td>VP</td><td>Virtual Path</td></tr><tr><td>VPI</td><td>Virtual Path Identifier</td></tr></table><h2 id="p3">3. Концептуальные основы MPLS-систем</h2><p>Далее рассматриваются основные концепции (концептуальные понятия) и принципы использования MPLS-систем.</p><h3 id="p3.1">3.1. Маркеры</h3><p>Маркер представляет собой идентификатор локального значения, имеющий небольшую фиксированную длину и используемый для обозначения FEC-класса. Маркер, размещённый в соответствующем IP-пакете, представляет собой FEC-класс (эквивалентный класс доставки), к которому «приписан» этот IP-пакет.</p><p>Как правило, IP-пакет приписывается к FEC-классу (полностью или частично) на основе имеющегося в его заголовке адреса получателя сетевого уровня (IP-адреса). Однако сам маркер никогда не кодируется (формируется) на основе этого адрес.</p><p>Обозначим два LSR-маршрутизатора как «<em>R<sub>u</sub></em>» и «<em>R<sub>d</sub></em>», тогда они могут согласовать параметры доставки следующим образом: когда <em>R<sub>u</sub></em> транслирует IP-пакет <em>R<sub>d</sub></em>, первый будет маркировать IP-пакет, используя величину <em>L</em>, только в том случае, если IP-пакет принадлежит соответствующему FEC-классу <em>F</em>. Т.е. они могут согласовать «связку» маркера <em>L</em> с FEC-классом <em>F</em> только для тех IP-пакетов, которые транслируются от <em>R<sub>u</sub></em> к <em>R<sub>d</sub></em>. В результате такого согласования маркер <em>L</em> становится «исходящим маркером» для <em>R<sub>u</sub></em>, и «входящим маркером» для <em>R<sub>d</sub></em>, отображая, таким образом, FEC-класс <em>F</em>.</p><p>Следует заметить, что маркер <em>L</em> не обязательно представляет FEC-класс <em>F</em> в каких-либо других IP-пакетах, которые отличаются от IP-пакетов, транслируемых от <em>R<sub>u</sub></em> к <em>R<sub>d</sub></em>. Маркер <em>L</em> является произвольно выбранным значением, «связываемым» с <em>F</em>, которое, в свою очередь, является локальным по отношению к <em>R<sub>u</sub></em> и <em>R<sub>d</sub></em>.</p><p>Когда речь идёт о «доставке» IP-пакетов от <em>R<sub>u</sub></em> к <em>R<sub>d</sub></em>, это совсем не означает, что <em>R<sub>u</sub></em> является источником IP-пакета или <em>R<sub>d</sub></em> является его конечным получателем. В дальнейшем предполагается, что все IP-пакеты, являющиеся «транзитными», также относятся к IP-пакетам, обрабатываемым одним или обоими LSR-маршрутизаторами.</p><p>Иногда весьма трудно или почти невозможно сказать, что в IP-пакет, поступивший в <em>R<sub>d</sub></em> и содержащий маркер <em>L</em>, последний был помещён именно <em>R<sub>u</sub></em>, а никаким другим LSR-маршрутизатором. (Это типичный случай, когда <em>R<sub>u</sub></em> и <em>R<sub>d</sub></em> не являются напрямую связанными соседями.) В таких ситуациях <em>R<sub>d</sub></em> должен гарантировать, что привязка маркера к FEC-классу является взаимно однозначной. Т.е., <em>R<sub>d</sub></em> обязан не согласовывать с <em>R</em><sub><em>u</em>1</sub> привязку маркера <em>L</em> к FEC-классу <em>F</em><sub>1</sub>, а также — привязку маркера <em>L</em> к другому FEC-классу <em>F</em><sub>2</sub> с некоторым другим LSR-маршрутизатором <em>R</em><sub><em>u</em>2</sub>, но до тех пор, пока <em>R<sub>d</sub></em> не сможет в любой момент сказать, когда он получил IP-пакет с входящим маркером <em>L</em>, и был ли маркер помещён в IP-пакет <em>R</em><sub><em>u</em>1</sub> или был ли помещён <em>R</em><sub>u2</sub>.</p><p>Каждый LSR-маршрутизатор несёт ответственность за предоставление гарантий того, что он может однозначно интерпретировать свои входящие маркеры.</p><h3 id="p3.2">3.2. LSR-маршрутизаторы нисходящего и восходящего потоков</h3><p>Предположим, что <em>R<sub>u</sub></em> и <em>R<sub>d</sub></em> согласовали привязку маркера <em>L</em> к FEC-классу <em>F</em> для пакетов, передаваемых от <em>R<sub>u</sub></em> к <em>R<sub>d</sub></em>. Тогда, в соответствие с указанной привязкой, маршрутизатор <em>R<sub>u</sub></em> — «LSR-маршрутизатор восходящего потока» (LSR<sub>ВП</sub>), а <em>R<sub>d</sub></em> — «LSR-маршрутизатор нисходящего потока» (LSR<sub>НП</sub>).</p><p>Принято говорить, что один узел является восходящим, а другой — нисходящим, в соответствие с принятой привязкой. А это означает лишь то, что соответствующий маркер отображает определённый FEC-класс только в тех IP-пакетах, которые доставляются от LSR<sub>ВП</sub> к LSR<sub>НП</sub>. Но это вовсе не означает, что IP-пакеты, принадлежащие такому FEC-классу, не могли бы в действительности пройти стандартную процедуру маршрутизации и затем направлены по маршруту от LSR<sub>ВП</sub> к LSR<sub>НП</sub>.</p><h3 id="p3.3">3.3. Промаркированный (помеченный) IP-пакет</h3><p>«Промаркированный (помеченный) IP-пакет» представляет собой IP-пакет, в котором размещён закодированный маркер потока. В отдельных случаях маркер постоянно размещается в специально предназначенном для него субзаголовке, который добавляется к IP-заголовку. В других случаях, маркер может постоянно размещаться в уже существующих заголовках канального или сетевого уровней, вплоть до того, что в них существует специальное поле, предназначенное именно для этих целей. Используемый способ кодирования обязательно должен быть предварительно согласован обеими взаимодействующими сторонами, и той, которая кодирует маркер, и той, которая декодирует маркер.</p><h3 id="p3.4">3.4. Назначение и распределение маркеров потока</h3><p>В MPLS-архитектуре решение о привязке определённого маркера <em>L</em> к соответствующему FEC-классу <em>F</em> принимается LSR-маршрутизатором, который является LSR<sub>НП</sub> относительно данной привязки. Затем, LSR<sub>НП</sub> информирует LSR<sub>ВП</sub> о наличии привязки. Таким образом, маркеры потоков назначаются LSR<sub>НП</sub>, а информация о привязке маркеров распространяется в направлении «LSR<sub>НП</sub> &rArr; LSR<sub>ВП</sub>». Если LSR-маршрутизатор имеет «полномочия» только для поиска маркеров, которые попадают в некоторый численный диапазон, то ему следует просто гарантировать, что он только «привязывает» маркеры из указанного диапазона.</p><h3 id="p3.5">3.5. Атрибуты для процедуры привязки маркеров потока</h3><p>Соответствующая процедура привязки маркера <em>L</em> к FEC-классу <em>F</em>, который доставляется от <em>R<sub>d</sub></em> к <em>R<sub>u</sub></em>, может быть связана с использованием определённых «атрибутов». Если <em>R<sub>u</sub></em> выступает в роли LSR<sub>НП</sub>, который также доставляет данные о привязке маркера <em>L</em> к FEC-классу <em>F</em>, то при определённых условиях он может быть востребован и для доставки соответствующего атрибута, полученного им от <em>R<sub>d</sub></em>.</p><h3 id="p3.6">3.6. Протоколы доставки (распределения) маркеров потока</h3><p>Протокол доставки (распределения) маркеров потока (label distribution protocol, LDP-протокол) представляет собой совокупность процедур (правил проведения информационного обмена), с помощью которых один LSR-маршрутизатор информирует другого о проведённой им процедуре привязки «маркер/FEC-класс». Два LSR-маршрутизатора, использующие LDP-протокол для обмена информацией о привязке «маркер/FEC-класс», называются «сторонами доставки маркеров потока» (label distribution peers),что соответствует обмену между ними информацией о процедуре привязки. Если два LSR-маршрутизатора являются «сторонами доставки маркеров потока», то говорят, что они являются «смежными (соседями) относительно доставки маркеров потока».</p><p class="note">Примечание. Два LSR-маршрутизатора могут быть «смежными сторонами доставки маркеров потока» только по отношению к определённой совокупности данных о привязках, но не могут быть по отношению к какой-либо другой совокупности данных о привязках.</p><p>LDP-протокол охватывает также любое другое взаимодействие сторон по доставке маркеров потока, при котором одна из сторон запрашивает данные у другой стороны с целью «изучения» MPLS-характеристик последней.</p><p>В рамках MPLS-архитектуры рассматриваются несколько возможных LDP-протоколов, которые в настоящее время стандартизированы.</p><p>Тем не менее, в данном документе речь пойдёт о стандарте LDP-протокола, представленного в RFC-3036 (RFC-5036).</p><h3 id="p3.7">3.7. Незапрашиваемый или нисходящий поток по требованию</h3><p>MPLS-архитектура рассматривает использование LSR-маршрутизатором подробного запроса маркера, привязанного к определённому FEC-классу, со стороны его следующего ретрансляционного участка для этого FEC-класса. Этот способ доставки маркеров именуется как «нисходящий поток по требованию».</p><p>Вместе с тем, MPLS-архитектура также рассматривает доставку маркеров LSR-маршрутизатором другим LSR-маршрутизаторам, которые напрямую не запрашивали эту процедуру. Этот способ доставки маркеров именуется как «незапрашиваемый нисходящий поток».</p><p>Сказанное выше означает, что некоторые программные MPLS-модули будут функционировать на основе способа доставки маркеров, именуемого как «нисходящий поток по требованию», некоторые — на основе способа доставки маркеров, именуемого как «незапрашиваемый нисходящий поток», а некоторые — на основе того и другого. Реализация одного из возможных вариантов функционирования будет зависеть от параметров интерфейсов, встроенных в соответствующий программный MPLS-модуль. Тем не менее, оба способа доставки маркеров потока могут использоваться в одной и той же сети, и в одно и то же время. Если LSR<sub>НП</sub> и LSR<sub>ВП</sub> являются смежными относительно доставки маркеров потока, то они обязаны согласовать используемый способ доставки маркеров.</p><h3 id="p3.8">3.8. Режим сохранения маркера потока</h3><p>LSR-маршрутизатор <em>R<sub>u</sub></em>, может получить (или уже получил) от LSR-маршрутизатор <em>R<sub>d</sub></em> маркер потока, привязанный к определённому FEC-классу, даже если <em>R<sub>d</sub></em> не расположен на следующем ретрансляционном участке по отношению к <em>R<sub>u</sub></em> (или не является его продолжением) для этого FEC-класса. После этого <em>R<sub>u</sub></em> осуществляет процедуру выбора: сохранить или удалить полученные данные о привязке. Если <em>R<sub>u</sub></em> сохранит полученные данные о привязке, то он может сразу начать использовать эти данные повторно, если конечно <em>R<sub>d</sub></em> располагается на следующем ретрансляционном участке по отношению к <em>R<sub>u</sub></em> для FEC-класса, о котором идёт речь. Если <em>R<sub>u</sub></em> удалит полученные данные о привязке, то данные о привязке должны быть получены повторно, если конечно в дальнейшем <em>R<sub>d</sub></em> будет располагаться на следующем ретрансляционном участке по отношению к <em>R<sub>u</sub></em>.</p><p>Если LSR-маршрутизатор поддерживает «свободный режим сохранения маркера потока» (liberal label retention mode), то он сохраняет данные о привязках «маркер/FEC-класс», которые получил от других LSR-маршрутизаторов, не расположенных на следующем ретрансляционном участке по отношению к нему для конкретного FEC-класса. Если же LSR-маршрутизатор поддерживает «консервативный режим сохранения маркера потока» (conservative label retention mode), то он удаляет данные о привязках «маркер/FEC-класс».</p><p>Свободный режим сохранения маркера потока обеспечивает быструю адаптацию к любым маршрутным изменениям, в то время как консервативный режим сохранения маркера потока требует хранить в LSR-маршрутизаторе намного меньше маркеров.</p><h3 id="p3.9">3.9. Набор маркеров потока</h3><p>До сих пор речь шла о помеченных IP-пакетах, которые доставляли только один маркер потока (в каждом). Однако в дальнейшем речь пойдёт о более общей модели, в которой помеченные IP-пакетах доставляют несколько маркеров потока (в каждом). При этом маркеры структурированы в «набор магазинного типа» (last-in, first-out stack — LIFO). В дальнейшем такая структура будет именоваться «набором маркеров потока» (label stack).</p><p>Несмотря на то, что MPLS-архитектура определяет некоторую логическую и процедурную иерархии, обработка помеченных IP-пакетов совершенно не зависит от уровня иерархии. Обработка всегда начинается с самого верхнего маркера (top label), невзирая на возможность того, что, либо в прошлом некоторое количество других маркеров могло располагаться «выше его» («above it»), либо в настоящий момент некоторое количество других маркеров может располагаться ниже его.</p><p>Непомеченный IP-пакет может рассматриваться как IP-пакет, содержащий «пустой» набор маркеров потока (т.е. «глубина» набора маркеров равна нулю).</p><p>Если набор маркеров потока, содержащийся в IP-пакете, имеет глубину <em>m</em>, то самый нижний маркер в наборе является маркером первого уровня (level 1), маркер, расположенный над ним (если конечно такой существует), является маркером второго уровня (level 2), а самый верхний маркер в наборе является маркером уровня <em>m</em> (level m).</p><h3 id="p3.10">3.10. Запись о доставке маркера на следующий ретрансляционный участок</h3><p>Такая запись («Next Hop Label Forwarding Entry» — NHLFE) используется тогда, когда доставляется помеченный IP-пакет. NHLFE-запись содержит следующую информацию:</p><ol class="lia"><li><p>Следующий ретрансляционный участок IP-пакета.</p></li><li><p>Процедура обработки набора маркеров потока из IP-пакета. Т.е. одна из следующих:</p><ol class="lat lia"><li><p>Замена маркера самого верхнего уровня набора на новый указанный маркер.</p></li><li><p>«Выталкивание» (удаление) набора маркеров (или самого верхнего маркера в наборе маркеров).</p></li><li><p>Замена маркера самого верхнего уровня набора на новый указанный маркер с последующей вставкой («проталкиванием») одного или более новых указанных маркеров в набор маркеров потока.</p></li><li><p>(Дополнительно) Повторное обрамление на канальном уровне, используемое при передаче IP-пакета.</p></li><li><p>(Дополнительно) Способ кодирования набора маркеров потока при передаче IP-пакета.</p></li><li><p>(Дополнительно) Любая другая необходимая информация для корректной обработки IP-пакета.</p></li></ol></li></ol><p class="note">Примечание. Конкретный LSR-маршрутизатор может сам оказаться LSR-маршрутизатором «расположенным на следующем ретрансляционном участке», который был указан в обрабатываемом IP-пакете. В этом случае LSR-маршрутизатору может понадобиться «вытолкнуть» (удалить) маркер высшего уровня (или весь набор маркеров) и затем доставить сформированный таким образом IP-пакет самому себе. В дальнейшем он может принять иное решение по доставке, основываясь на том, что осталось после удаления маркера из набора. Это попрежнему может быть помеченный IP-пакет, или это может быть местный IP-пакет.</p><p>Это говорит о том, что в отдельных случаях LSR-маршрутизатору может понадобиться обрабатывать IP-заголовок с целью доставки IP-пакета.</p><p>Если в обрабатываемом IP-пакете указан LSR-маршрутизатор, «расположенный на следующем ретрансляционном участке», и который является текущим LSR-маршрутизатором, то далее должна следовать процедура обработки набора маркеров потока, заключающаяся в «выталкивании» (удалении) маркера или всего набора маркеров (pop the stack).</p><h3 id="p3.11">3.11. Отображение входящего маркера</h3><p>Эта процедура («Incoming Label Map» — ILM) обеспечивает отображение входного (входящего) маркера в совокупность NHLFE-записей. ILM-процедура используется при доставке IP-пакетов, которые поступают как помеченные IP-пакеты.</p><p>Если ILM-процедура отображает определённый маркер в совокупность NHLFE-записей, которая включает более одного элемента, то перед отправкой IP-пакета из набора маркеров должен быть выбран ровно один элемент. Сами процедуры выбора элемента из набора в данном стандарте не рассматриваются. Наличие ILM-процедуры отображения маркера в совокупность из более чем одной NHLFE-записи может быть весьма полезным, если, например, необходимо сбалансировать нагрузку между несколькими эквивалентными, с точки зрения затрат, маршрутами.</p><h3 id="p3.12">3.12. Отображение FEC-класса в совокупность NHLFE-записей</h3><p>Эта процедура («FEC-to-NHLFE» — FTN) обеспечивает отображение FEC-класса в совокупность NHLFE-записей. FTN-процедура используется при доставке IP-пакетов, которые поступают непомеченными, но которые должны быть помечены перед их дальнейшей отправкой.</p><p>Если FTN-процедура отображает определённый маркер в совокупность NHLFE-записей, которая включает более одного элемента, то перед отправкой IP-пакета из набора маркеров должен быть выбран ровно один элемент. Сами процедуры выбора элемента из набора в данном стандарте не рассматриваются. Наличие FTN-процедуры отображения маркера в совокупность более чем из одной NHLFE-записи может быть весьма полезным, если, например, необходимо сбалансировать нагрузку между несколькими эквивалентными, с точки зрения затрат, маршрутами.</p><h3 id="p3.13">3.13. Замена маркеров</h3><p>Замена маркеров (label swapping) предполагает использование следующих процедур при доставке IP-пакета:</p><ol class="lia"><li><p class="b">При доставке помеченного IP-пакета.</p><p>LSR-маршрутизатор проверяет самый верхний маркер в наборе маркеров. Он использует ILM-процедуру для отображения этого набора маркеров в совокупность NHLFE-записей. Используя информацию в NHLFE-записях, он определяет, куда направить IP-пакет, и обрабатывает набор маркеров для IP-пакета. Затем он кодирует и размещает новый набор маркеров в IP-пакете, а потом транслирует итоговый IP-пакет.</p></li><li><p class="b">При доставке не помеченного IP-пакета.</p><p>LSR-маршрутизатор анализирует заголовок сетевого уровня с целью определения FEC-класса. После этого он использует FTN-процедуру для отображения FEC-класса в совокупность NHLFE-записей. Используя информацию в NHLFE-записях, он определяет, куда направить IP-пакет, и обрабатывает набор маркеров для IP-пакета. (В данной ситуации вполне возможно, что процедура «выталкивания» (popping) маркера или набора маркеров будет недопустимой.) Затем он кодирует и размещает новый набор маркеров в IP-пакете, а потом транслирует итоговый IP-пакет.</p></li></ol><p class="note">Примечание. Необходимо отметить, что при использовании процедуры замены маркеров, следующий ретрансляционный участок всегда выбирается из совокупности NHLFE-записей. В отдельных случаях, при таком подходе, следующий ретрансляционный участок может отличаться от того, который был бы выбран системой, в которой MPLS-коммутация не используется.</p><h3 id="p3.14">3.14. Назначение и уникальность маркеров</h3><p>Положим, что LSR-маршрутизатор <em>R<sub>d</sub></em> может связать маркер <em>L</em><sub>1</sub> с FEC-классом <em>F</em> и отправить данные об этой связке субъекту распределения маркеров <em>R</em><sub><em>u</em>1</sub>. <em>R<sub>d</sub></em> также может связать маркер <em>L</em><sub>2</sub> с FEC-классом <em>F</em> и отправить данные об этой связке субъекту распределения маркеров <em>R</em><sub><em>u</em>2</sub>. MPLS-архитектура не определяет должны ли такие маркеры <em>L</em><sub>1</sub> и <em>L</em><sub>2</sub> быть одинаковыми. Эта задача должна решаться локально.</p><p>Положим, что LSR-маршрутизатор <em>R<sub>d</sub></em> может связать маркер <em>L</em> с FEC-классом <em>F</em><sub>1</sub> и отправить данные об этой связке субъекту распределения маркеров <em>R</em><sub><em>u</em>1</sub>. <em>R<sub>d</sub></em> также может связать маркер <em>L</em> с FEC-классом <em>F</em><sub>2</sub> и отправить данные об этой связке субъекту распределения маркеров <em>R</em><sub><em>u</em>2</sub>. Если (и только если) <em>R<sub>d</sub></em> после получения IP-пакета, в котором самый высший маркер является маркером <em>L</em>, может определить какой из субъектов <em>R</em><sub><em>u</em>1</sub> или <em>R</em><sub><em>u</em>2</sub> разместил маркер в этом IP-пакете, то MPLS-архитектура не требует, чтобы FEC-классы <em>F</em><sub>1</sub> и <em>F</em><sub>2</sub> были одинаковыми. В таких случаях говорят, что <em>R<sub>d</sub></em> использует различные «диапазоны (пространства) маркеров» для тех маркеров, которые он транслирует субъекту <em>R</em><sub><em>u</em>1</sub>, и для тех, которые он транслирует субъекту <em>R</em><sub><em>u</em>2</sub>.</p><p>Обобщая сказанное выше, <em>R<sub>d</sub></em> может определить, какой из субъектов <em>R</em><sub><em>u</em>1</sub> или <em>R</em><sub><em>u</em>2</sub> разместил соответствующий маркер <em>L</em> на самом верхнем уровне набора маркеров только при соблюдении следующих условий:</p><ul class="list lia"><li><p><em>R</em><sub><em>u</em>1</sub> и <em>R</em><sub><em>u</em>2</sub> являются лишь субъектами распределения маркеров, которым <em>R<sub>d</sub></em> транслирует данные о привязке маркера <em>L</em>;</p></li><li><p><em>R</em><sub><em>u</em>1</sub> и <em>R</em><sub><em>u</em>2</sub> напрямую соединены с <em>R<sub>d</sub></em> через сквозной интерфейс (point-to-point interface).</p></li></ul><p>Если эти условия соблюдены, то LSR-маршрутизатор может использовать маркеры, которые предназначены для обозначения конкретного интерфейса (per interface), т.е. каждый маркер соответствует только одному уникальному интерфейсу. В этом случае говорят, что LSR-маршрутизатор использует пространство маркеров, предназначенных для обозначения конкретного интерфейса (per-interface label space).</p><p>Если эти условия не соблюдены, то маркеры должны быть уникальны по отношению LSR-маршрутизатору, за которым они закреплены. В этом случае говорят, что LSR-маршрутизатор использует пространство маркеров, предназначенных для обозначения конкретного сетевого объекта (per-platform label space).</p><p>Если определённый LSR-маршрутизатор <em>R<sub>d</sub></em> присоединён к соответствующему LSR-маршрутизатору <em>R<sub>u</sub></em> с помощью двух сквозных интерфейсов, то <em>R<sub>d</sub></em> может отправить <em>R<sub>u</sub></em> данные о привязке маркера <em>L</em> к FEC-классу <em>F</em><sub>1</sub>, а также данные о привязке маркера <em>L</em> к FEC-классу <em>F</em><sub>2</sub>. При этом FEC-классы <em>F</em><sub>1</sub> и <em>F</em><sub>2</sub> считаются эквивалентными, но только тогда (и только тогда), если каждый элемент данных о привязке может быть доставлен только в тех IP-пакетах, которые <em>R<sub>u</sub></em> транслирует <em>R<sub>d</sub></em> через один из двух сквозных интерфейсов. Во всех других случаях <em>R<sub>d</sub></em> не должен транслировать <em>R<sub>u</sub></em> данные о привязке маркера с одним и тем же значением к двум различным FEC-классам.</p><p>Такой запрет налагается и в том случае, когда данные о привязках рассматриваются как данные, расположенные на различных уровнях иерархии. MPLS-архитектура вообще не рассматривает наличие различных пространств (диапазонов) маркеров для разных уровней иерархии. При определении маркера, уровень маркера вообще не имеет какого смысла.</p><p>Вопрос заключается как раз в том, может ли LSR-маршрутизатор для одного и того же интерфейса использовать несколько диапазонов маркеров, предназначенных для обозначения конкретного, либо сетевого объекта, либо интерфейса. MPLS-архитектура этого не запрещает. Тем не менее, в таких случаях LSR-маршрутизатор обязан иметь специализированные средства (которые MPLS-архитектурой не стандартизованы), позволяющие определить, к какому диапазону маркеров принадлежит соответствующий входящий маркер. Например, в стандарте RFC-3032 установлено, что для однонаправленных и IP-пакетов с групповой адресацией должны использоваться различные диапазоны маркеров. Более того, в стандарте RFC-3032 вводится специализированный код канального уровня, предназначенный для разграничения этих двух диапазонов маркеров.</p><h3 id="p3.15">3.15. LSP-маршрут, вход LSP-маршрута, выход LSP-маршрута</h3><p>LSP-маршрут <em>m</em>-уровня иерархии (LSP<em><sub>m</sub></em>) по отношению к определённому IP-пакету P представляет собой последовательность маршрутизаторов &lt;<em>R</em><sub>1</sub>,...,<em>R<sub>n</sub></em>&gt; обладающих следующими свойствами:</p><ol class="lia"><li><p><em>R</em><sub>1</sub>, вход LSP-маршрута (LSP Ingress), представляет собой LSR-маршрутизатор, который вставляет маркер в набор маркеров IP-пакета <em>P</em>, формируя таким образом набор маркеров глубины <em>m</em>;</p></li><li><p>Если LSR-маршрутизатор получает IP-пакет <em>P</em>, то последний содержит набор маркеров глубины <em>m</em> для всех <em>i</em>, 1 &lt; <em>i</em> &lt; <em>n</em>;</p></li><li><p>В период времени, когда IP-пакет <em>P</em> не передаётся от <em>R</em><sub>1</sub> к <em>R</em><sub><em>n</em>-1</sub>, <em>P</em> уже имеет набор маркеров с глубиной менее <em>m</em>;</p></li><li><p>Для всех <em>i</em>, 1 &lt; <em>i</em> &lt; <em>n</em>: <em>R<sub>i</sub></em> отправляет IP-пакет <em>P</em> <em>R</em><sub><em>i</em>+1</sub> с помощью средств MPLS-коммутации, т.е. с помощью маркера самого верхнего уровня в наборе маркеров (маркер <em>m</em>-уровня), аналогичного индексу в ILM-процедуре;</p></li><li><p>Для всех <em>i</em>, 1 &lt; <em>i</em> &lt; <em>n</em>: если система <em>S</em> принимает и ретранслирует IP-пакет <em>P</em> после его передачи LSR-маршрутизатором <em>R<sub>i</sub></em>, но ещё до того, как IP-пакет <em>P</em> будет принят <em>R</em><sub><em>i</em>+1</sub> (например, <em>R<sub>i</sub></em> и <em>R</em><sub><em>i</em>+1</sub> могут быть связаны через подсеть с коммутацией кадров (коммутация на канальном уровне), а <em>S</em> может быть одним из коммутаторов канального уровня), то система <em>S</em> принимает решение о доставке, не основываясь на маркере <em>m</em>-уровня или заголовке сетевого уровня. Это может быть следствием того, что:</p><ol class="lat lia"><li><p>Принимаемое решение вообще не основывается на наборе маркеров или заголовке сетевого уровня;</p></li><li><p>Принимаемое решение основывается на наборе маркеров, в который могут быть вставлены дополнительные маркеры (т.е. маркер на (<em>m</em>+<em>k</em>)-уровне, где <em>k</em> &gt; 0).</p></li></ol></li></ol><p>Другими словами, LSP<em><sub>m</sub></em> при доставке IP-пакет <em>P</em> представляет собой последовательность маршрутизаторов:</p><ol class="lia"><li><p>Которая начинается с LSR-маршрутизатора (вход LSP-маршрута), вставляющего маркер <em>m</em>-уровня;</p></li><li><p>В которой все промежуточные LSR-маршрутизаторы принимают решение о доставке с помощью процедуры коммутации маркеров, расположенных на <em>m</em>-уровне;</p></li><li><p>Которая заканчивается (выход LSP-маршрута, LSP Egress) тогда, когда решение о доставке принимается, либо с помощью процедуры коммутации маркеров, расположенных на (<em>m</em> - <em>k</em>)-уровне (где <em>k</em> &gt; 0), либо «стандартным» образом, когда при доставке не используется MPLS-коммутация.</p></li></ol><p>Следствием сказанного выше является то (или можно предположить), что LSR-маршрутизатор всегда вставляет маркер в уже (ранее) помеченный IP-пакет. Это необходимо для обеспечения гарантий того, что новый маркер соответствует FEC-классу, у которого выходом LSP-маршрута является LSR-маршрутизатор с закреплённым за ним маркером, являющимся в настоящий момент вторым в наборе маркеров.</p><p>Последовательность LSR-маршрутизаторов называется LSP-маршрутом определённого FEC-класса <em>F</em> (LSP for a particular FEC F), если она представляет собой LSP<em><sub>m</sub></em> для соответствующего IP-пакета <em>P</em>, в котором маркер <em>m</em>-уровня является маркером, отображающий FEC-класс <em>F</em>.</p><p>Предположим, что имеет место совокупность узлов, которые могут быть узлами входа LSP-маршрута для FEC-класса <em>F</em>. Тогда существует LSP-маршрут для FEC-класса <em>F</em>, который начинается в каждом из указанных узлов. Если все такие LSP-маршруты имеют один и тот же выход LSP-маршрута, то можно предположить, что совокупность таких LSP-маршрутов образует дерево, корнем которого является выход LSP-маршрута. (Так как данные транслируются по этому дереву маршрутов, которое сходится в один корневой узел, то такое дерево называется «сходящимся» (multipoint-to-point tree).) Таким образом, можно говорить о «дереве LSP-маршрутов» относительно определённого FEC-класса <em>F</em>.</p><h3 id="p3.16">3.16. «Выталкивание» на предпоследнем ретрансляционном участке</h3><p>Если последовательность маршрутизаторов &lt;<em>R</em><sub>1</sub>, …,<em>R<sub>n</sub></em>&gt; является LSP<em><sub>m</sub></em> для IP-пакета <em>P</em>, последний может быть доставлен из <em>R</em><sub><em>n</em>-1</sub> в <em>R<sub>n</sub></em>, имея в своём составе набор маркеров с (<em>m</em>-1)-глубиной. Т.е., скорее всего набор маркеров может быть «вытолкнут» в предпоследнем (penultimate) LSR-маршрутизаторе LSP-маршрута, чем на выходе LSP-маршрута.</p><p>С точки зрения архитектуры, это вполне приемлемо. Целевое назначение маркера <em>m</em>-уровня является получение IP-пакета LSR-маршрутизатором <em>R<sub>n</sub></em>. После того, как <em>R</em><sub><em>n</em>-1</sub> примет решение о передаче IP-пакета <em>R<sub>n</sub></em>, маркер больше не выполняет никакой функции, и поэтому нет смысла доставлять его дальше.</p><p>Существует только одно реальное преимущество реализации «выталкивания» на предпоследнем ретрансляционном участке. Если предпоследний LSR-маршрутизатор не сделает этого, то после того, как на выходе LSP-маршрута будет получен IP-пакет, выходной LSR-маршрутизатор проанализирует маркер самого верхнего уровня и в результате этого анализа установит, что он действительно является выходом LSP-маршрута. После этого он должен «вытолкнуть» (удалить) маркер самого верхнего уровня из набора маркеров и проверить, что осталось в IP-пакете. Если в наборе существует другой маркер, выходной LSR-маршрутизатор обнаружит его и отправит IP-пакет, основываясь на результате этой проверки. (В таком случае, выходом LSP<em><sub>m</sub></em> для IP-пакета также будет являться промежуточный сетевой узел по отношению к своему LSP<sub><em>m</em>-1</sub>.) Если же в наборе нет другого маркера, то IP-пакет доставляется в соответствие с IP-адресом получателя (адресом сетевого уровня).</p><p>Если, с другой стороны, «выталкивание» на предпоследнем ретрансляционном участке осуществляется, то после того, как предпоследний LSR-маршрутизатор проанализирует маркер самого верхнего уровня, он установит:</p><ul class="list lia"><li>что он «является» предпоследним ретрансляционным участком;</li><li>и какой следующий ретрансляционный участок.</li></ul><p>Затем предпоследний сетевой узел «выталкивает» (удаляет) маркер самого верхнего уровня из набора маркеров и транслирует IP-пакет, основываясь на информации, полученной при анализе маркера, который был прежде на самом верхнем уровне набора маркеров. Когда выходной LSR-маршрутизатор получает IP-пакет, то маркер, располагающийся теперь на самом верхнем уровне набора маркеров, будет тем маркером, который следует проанализировать, чтобы принять решение о дальнейшей доставке IP-пакета. Или, если выходной LSR-маршрутизатор получает IP-пакет с одним маркером, то ему просто следует проанализировать сам IP-пакет (пакет сетевого уровня), чтобы принять решение о дальнейшей его доставке.</p><p>Этот способ позволяет выходному LSR-маршрутизатору провести только одну проверку, а также требует и от предпоследнего сетевого узла проведения всего лишь одной проверки.</p><p>Формирование «быстрейшего маршрута» (fast path) доставки в результате обработки маркера MPLS-коммутации может быть весьма эффективной «помощью», если известно, что всегда требуется только одна процедура анализа, а именно:</p><ul class="list lia"><li><p>Код (листинг) программы может быть значительно упрощён, если можно предположить, что всегда необходима только одна процедура анализа.</p></li><li><p>Код (листинг) программы может основываться на «ресурсе времени» (time budget), что предполагает необходимость всего лишь одной процедуры анализа.</p></li></ul><p>Фактически, когда на предпоследнем ретрансляционном участке проводится процедура «выталкивания», то выходом LSP-маршрута не обязательно должен быть LSR-маршрутизатор.</p><p>Однако некоторые аппаратные коммутаторы могут не обладать способностью «выталкивания» (удаления) маркера самого верхнего уровня из набора маркеров, так что сказанное выше не может быть «повсеместным» требованием. Кроме того, могут возникнуть ситуации, при которых процедура «выталкивания» маркера на предпоследнем ретрансляционном участке вообще не желательна. Вследствие этого предпоследний сетевой узел «выталкивает» маркер (или весь набор маркеров) только тогда, когда:</p><ul class="list lia"><li>это специально востребовано выходным сетевым узлом;</li><li>следующий сетевой узел в LSP-маршруте не реализует функции MPLS-коммутации.</li></ul><p>(Если следующий сетевой узел в LSP-маршруте реализует функции MPLS-коммутации, но не запрашивает выполнение «выталкивания» маркера или всего набора маркеров, то предпоследний сетевой узел не способен узнать, что он фактически является предпоследним сетевым узлом.)</p><p>LSR-маршрутизатор, который способен «выталкивать» весь набор маркеров, обязан выполнить такое «выталкивание» на предпоследнем ретрансляционном участке в случае, когда эта процедура затребована взаимодействующей с ним стороной доставки маркера, являющейся LSR<sub>НП</sub>.</p><p>Процедура предварительного согласования LDP-протокола должна предоставить каждому LSR-маршрутизатору возможность определить, способны ли соседние LSR-маршрутизаторы удалять набор маркеров. LSR-маршрутизатор не должен требовать от противоположной стороны выполнения процедуры удаления набора маркеров до тех пор, пока она не будет способна её выполнить.</p><p>Очевиден вопрос: а всегда ли выходной сетевой узел может соответствующим образом интерпретировать маркер самого верхнего уровня в принятом IP-пакете в том случае, если используется процедура «выталкивания» на предпоследнем ретрансляционном участке? Ответ прост: до тех пор, пока выполняются правила уникальности и применения маркеров, представленные в параграфе <a href="print#p3.14" title="параграф 3.14 - Назначение и уникальность маркеров">3.14</a>, выходной сетевой узел всегда может интерпретировать маркер самого верхнего уровня в принятом IP-пакете корректно и однозначно.</p><h3 id="p3.17">3.17. Следующий ретрансляционный участок LSP-маршрута</h3><p>Следующий ретрансляционный участок LSP-маршрута для соответствующего IP-пакета, помеченного определённым LSR-маршрутизатором, представляет собой LSR-маршрутизатор, расположенный в конце следующего ретрансляционного участка, который был выбран с помощью NHLFE-записи, используемой в период доставки этого IP-пакета.</p><p>Следующий ретрансляционный участок LSP-маршрута для соответствующего FEC-класса представляет собой следующий ретрансляционный участок, который был выбран с помощью NHLFE-записи, помеченной маркером потока, соответствующим этому FEC-классу.</p><p class="note">Примечание. Следующий ретрансляционный участок LSP-маршрута может отличаться от следующего ретрансляционного участка, который мог быть выбран алгоритмом маршрутизации сетевого (3-го) уровня. Если в дальнейшем пойдёт речь о таком алгоритме, то будет использоваться термин «следующий ретрансляционный участок сетевого (3-го) уровня» («L<sub>3</sub> next hop»).</p><h3 id="p3.18">3.18. Недействительные входящие маркеры потоков</h3><p>Что должен делать LSR-маршрутизатор, если он получил помеченный IP-пакет с соответствующим входящим маркером потока, но который не имеет привязки к этому маркеру? Первое, что «приходит на ум»: такие маркеры могут быть просто удалены, а сам IP-пакет может доставляться далее, как непомеченный. Однако, в некоторых случаях, это может привести к петлевому маршруту доставки. Если LSR<sub>ВП</sub> «думает», что маркер был привязан к явному маршруту (explicit route), а LSR<sub>НП</sub> «не думает», что маркер был привязан к чему-либо другому, и если ретрансляционный маршрут непомеченного IP-пакета «доставил» его обратно в LSR<sub>ВП</sub>, то очевидно, что сформировался петлевой маршрут.</p><p>Также возможен случай, когда маркер был предназначен для отображения маршрута, который не может быть «выявлен» из IP-заголовка.</p><p>По этой причине, когда помеченный IP-пакет был принят с недействительным входящим маркером, он должен быть удалён, за исключением тех случаев, когда он будет распознан некоторыми средствами (в данном стандарте не рассматриваются), которые доставляют его не помеченным без каких-либо негативных последствий.</p><h3 id="p3.19">3.19. Управление LSP-маршрутом: регулируемое или независимое</h3><p>Некоторые FEC-классы соответствуют префиксам IP-адресов, которые распределяются с помощью алгоритма динамической маршрутизации. Определение LSP-маршрутов для таких FEC-классов может быть осуществлено одним из следующих способов:</p><ul class="list lia"><li>независимое управление LSP-маршрутом;</li><li>регулируемое управление LSP-маршрутом.</li></ul><p>При независимом управлении LSP-маршрутом каждый LSR-маршрутизатор, после объявления того, что он определил соответствующий FEC-класс, принимает независимое решение о привязке маркера к этому FEC-классу и о доставке этой привязки своим взаимодействующим сторонам по доставке маркеров. Это соответствует стандартному способу маршрутизации IP-пакетов, т.е. каждый узел принимает независимое решение о том,«как обходиться» с каждым IP-пакетом, и «уверен» в том, что алгоритм маршрутизации является «быстро сходимым», а это, в свою очередь, гарантирует, что каждый IP-пакет будет доставлен корректно.</p><p>При регулируемом управлении LSP-маршрутом каждый LSR-маршрутизатор только привязывает маркер к определённому FEC-классу, если он является выходным LSR-маршрутизатором, или если он уже получил маркер, привязанный к этому FEC-классу, от взаимодействующей стороны следующего ретрансляционного участка для этого FEC-класса.</p><p>Если есть необходимость гарантировать прохождение трафика соответствующего FEC-класса по маршруту с некоторыми специфическими свойствами (например, чтобы трафик не проходил через какой-либо сетевой узел дважды, чтобы для обработки трафика привлекался некоторый определённый объем ресурсов, чтобы трафик проходил по строго определённому маршруту), то должно использоваться регулируемое управление. При независимом управлении некоторые LSR-маршрутизаторы могут начать коммутировать трафик на основе маркеров потока в соответствие с некоторым FEC-классом ещё до того, как LSP-маршрут будет полностью установлен, и таким образом, некоторая часть трафика, соответствующая определённому FEC-классу, будет следовать по маршруту, который не обладает требуемыми свойствами. Регулируемое управление следует использовать и в том случае, когда распознавание FEC-класса представляет собой результат установки соответствующего LSP-маршрута.</p><p>Регулируемое управление может быть установлено по инициативе, либо входного сетевого узла, либо выходного сетевого узла.</p><p>Регулируемое управление и независимое управление являются полностью функционально совместимыми. Тем не менее, если все LSR-маршрутизаторы LSP-маршрута используют регулируемое управление, то общее функционирование сети гораздо эффективнее, чем при независимом управлении, так как никто не может уверенным в том, что LSP-маршрут не используется, пока он полностью не установлен.</p><p>Такой подход позволяет делать выбор между независимым управлением и регулируемым управлением, который, в свою очередь, имеет только локальное значение. Несмотря на то, что предложены два метода межсетевого взаимодействия, конкретному LSR-маршрутизатору следует поддерживать только один из двух. Вообще говоря, выбор между независимым и регулируемым управлением не принесёт какого-либо положительного эффекта, пока не будут определены способы доставки маркеров.</p><h3 id="p3.20">3.20. Агрегирование</h3><p>Один из способов разбиения трафика на FEC-классы заключается в формировании отдельного FEC-класса для каждого префикса IP-адреса, который представлен в маршрутной таблице. Однако в пределах сетевого MPLS-сегмента разбиение трафика на FEC-классы может привести к тому, что весь трафик всех этих FEC-классов будет следовать по одному и тому же маршруту. Например, в совокупности префиксов выделенных адресов последние могут иметь один и тот же выходной сетевой узел, а процедура замены маркера может использоваться только для приема трафика в выходном сетевом узле. В таком случае, в границах сетевого MPLS-сегмента, результатом слияния (объединения) таких FEC-классов будет этот же FEC-класс. И здесь появляется выбор: либо выделенный маркер потока должен быть привязан к каждому составному FEC-классу, либо одиночный маркер должен быть привязан к объединению FEC-классов, чтобы маркер использовался для всего трафика, принадлежащего такому объединению?</p><p>Процедура привязки одиночного маркера к объединению FEC-классов, которое является этим же FEC-классом (в пределах некоторого сетевого сегмента), а также применения этого маркера ко всему трафику, принадлежащего объединению FEC-классов, называется процедурой агрегирования (aggregation). MPLS-архитектура предусматривает процедуру агрегирования. Процедура агрегирования может значительно снизить количество используемых маркеров, которые необходимы для обработки соответствующей совокупности IP-пакетов, а также может снизить объем управляющего трафика необходимый для доставки (распределения) маркеров.</p><p>Пусть имеет место совокупность FEC-классов, которая может быть агрегирована в один FEC-класс, тогда возможно:</p><ol class="lat lia"><li>агрегировать их в один FEC-класс;</li><li>агрегировать их в совокупности FEC-классов;</li><li>никак их не агрегировать.</li></ol><p>Таким образом, можно говорить об «уровне разделения» агрегированных FEC-классов, т.е. «разделение на самые крупные (по числу FEC-классов) подгруппы» (coarsest granularity) и «разделение на самые маленькие (по числу FEC-классов) подгруппы» (finest granularity).</p><p>При регулируемом управлении, каждый LSR-маршрутизатор должен адаптировать (для конкретного набора FEC-классов) уровень разделения агрегированных FEC-классов, которые используются на следующем ретрансляционном участке.</p><p>При независимом управлении, возможна ситуация, при которой два смежных (соседних) LSR-маршрутизатора, <em>R<sub>u</sub></em> и <em>R<sub>d</sub></em>, будут проводить процедуру агрегирования некоторой совокупности FEC-классов по-разному.</p><p>Если <em>R<sub>u</sub></em> имеет более мелкий уровень разделения по сравнению с <em>R<sub>d</sub></em>, то проблем не возникнет. <em>R<sub>u</sub></em> распределяет (доставляет) больше маркеров для данной совокупности FEC-классов, чем это делает <em>R<sub>d</sub></em>. Это означает следующее. Если <em>R<sub>u</sub></em> необходимо доставить <em>R<sub>d</sub></em> помеченные IP-пакеты, относящиеся к указанным FEC-классам, то ему может понадобиться провести процедуру отображения <sub>n</sub> маркеров в <em>m</em> маркеров, где <em>n</em> &gt; <em>m</em>. Очевидно, что <em>R<sub>u</sub></em> может изъять (аннулировать) распределённые им <em>n</em> маркеров, а затем распределить набор из <em>m</em> маркеров, что соответствует уровню разделения <em>R<sub>d</sub></em>. Нет необходимости обеспечения каких-либо гарантий корректности указанной операции, а вот её результат приведёт к уменьшению числа маркеров, распределённых <em>R<sub>u</sub></em>, и сам <em>R<sub>u</sub></em> не получит каких-либо преимуществ от распределения большего числа маркеров. Решение о проведении или не проведении такой операции принимается на локальном уровне.</p><p>Если <em>R<sub>u</sub></em> имеет более крупный уровень разделения по сравнению с <em>R<sub>d</sub></em> (т.е. <em>R<sub>d</sub></em> распределил <em>n</em> маркеров для некоторой совокупности FEC-классов, а <em>R<sub>u</sub></em> распределил <em>m</em> маркеров, где <em>n</em> &gt; <em>m</em>), то возникает дилемма:</p><ul class="list lia"><li><p>Можно адаптировать более мелкий уровень разделения у <em>R<sub>d</sub></em>. Это могло бы потребовать от него изъятия распределённых им <em>m</em> маркеров, и распределения <em>n</em> маркеров. Такой подход наиболее предпочтителен;</p></li><li><p>Можно просто отобразить <em>m</em> маркеров в подмножество nмаркеров у <em>R<sub>d</sub></em>, если, конечно, последний сможет определить, что такая процедура приведёт к одному и тому же маршруту. Например, предположим, что <em>R<sub>u</sub></em> использует один маркер для всего трафика, который необходимо доставить через определённый выходной LSR-маршрутизатор, в то время как <em>R<sub>d</sub></em> привязал несколько различных маркеров к этому же трафику, основываясь только на индивидуальных адресах получателей в IP-пакетах. Если <em>R<sub>u</sub></em> знает адрес выходного маршрутизатора, и если <em>R<sub>d</sub></em> привязал маркер к FEC-классу, который идентифицируется с помощью этого адреса, то <em>R<sub>u</sub></em> может просто использовать этот маркер.</p></li></ul><p>В любом случае, каждому LSR-маршрутизатору необходимо знать (с помощью процедуры настойки), какой уровень разделения агрегированных FEC-классов следует использовать по отношению к маркерам, которые он им присваивает (к ним привязывает). Если используется регулируемое управление, то необходимо, чтобы каждый сетевой узел знал уровень разделения только для тех агрегированных FEC-классов, которые «покидают» MPLS-сеть в данном узле. При независимом управлении наилучший результат может быть достигнут только путём обеспечения гарантий того, что все LSR-маршрутизаторы настроены соответствующим образом и знают уровень разделения для каждого FEC-класса. Тем не менее, во многих случаях этого можно достичь путём использования «поэкземплярного» уровня разделения, который применяется ко всем FEC-классам (например, «один маркер на каждый префикс IP-адреса», или «один маркер на каждый выходной узел»).</p><h3 id="p3.21">3.21. Выбор маршрута</h3><p>Выбор маршрута означает метод, который используется для выбора LSP-маршрута в интересах определённого FEC-класса. MPLS-архитектура устанавливает два варианта выбора маршрута:</p><ol class="lia"><li>«поузловая» маршрутизация (hop by hop routing);</li><li>«явная (точная)» маршрутизация (explicit routing).</li></ol><p>Поузловая маршрутизация позволяет каждому сетевому узлу независимо выбирать следующий ретрансляционный участок для каждого FEC-класса. На сегодня этот вариант маршрутизации является наиболее распространенным в существующих IP-сетях. «LSP-маршрут на основе поузловой маршрутизации» (hop by hop routed LSP) представляет собой LSP-маршрут, который «прокладывается» с использованием поузловой маршрутизации.</p><p>В случае «LSP-маршрута на основе явной маршрутизации» (explicitly routed LSP) каждый LSR-маршрутизатор не может независимо выбирать следующий ретрансляционный участок. Как правило, одиночный LSR-маршрутизатор, обычно выходной или выходной LSP-маршрута, определяет несколько или все LSR-маршрутизаторы на LSP-маршруте. Если одиночный LSR-маршрутизатор определяет весь LSP-маршрут, то такой LSP-маршрут представляет собой «точно» (strictly) проложенный маршрут на основе явной маршрутизации. Если одиночный LSR-маршрутизатор определяет только часть некоторого LSP-маршрут, то такой LSP-маршрут представляет собой «неточно» (loosely) проложенный маршрут на основе явной маршрутизации.</p><p>Последовательность LSR-маршрутизаторов, составляющая LSP-маршрут на основе явной маршрутизации, может быть определена с помощью процедуры настройки, или может быть выбрана одиночным сетевым узлом в динамическом режиме. Например, выходной сетевой узел может использовать топологическую информацию, полученную из базы данных о состоянии каналов/линий связи с целью вычисления всего маршрута по дереву кратчайших маршрутов, заканчивающемся в этом выходном сетевом узле.</p><p>Явная маршрутизация может быть полезна во многих случаях, например, при использовании политики маршрутизации или при регулировании трафика (traffic engineering). В MPLS-системах явный маршрут должен быть определен в момент времени, когда устанавливаются маркеры потока, но, с другой стороны, явный маршрут не должен устанавливаться для каждого IP-пакета. Такой подход делает явную маршрутизацию в MPLS-системах гораздо более эффективной по сравнению с маршрутизацией от источника IP-пакета.</p><p>Процедуры выбора «точно» или «неточно» прокладываемого маршрута на основе явной маршрутизации в данном стандарте не рассматриваются.</p><h3 id="p3.22">3.22. Отсутствие исходящего маркера</h3><p>Когда помеченный IP-пакет следует по LSP-маршруту, неожиданно может возникнуть ситуация, при которой IP-пакет достиг LSR-маршрутизатора, не выполняющего ILM-процедуру отображения входного маркера из этого IP-пакета в NHLFE-запись, даже если входящий маркер является корректным. Такая ситуация может возникнуть, либо вследствие условий переходного процесса, либо вследствие ошибки в LSR-маршрутизаторе, который должен быть на следующем ретрансляционном участке для IP-пакета.</p><p>В таких случаях весьма заманчивой становится процедура удаления набор меток и попытка доставить IP-пакет дальше с помощью традиционной процедуры ретрансляции, основываясь при этом только на заголовок сетевого уровня (IP-заголовок). Однако, такая процедура, в общем, не безопасна, так как:</p><ul class="list lia"><li><p>Если IP-пакет следует по LSP-маршруту на основе явной маршрутизации, то в результате мог бы образоваться петлевой маршрут;</p></li><li><p>IP-заголовок может содержать не достаточно информации для его обработки соответствующим LSR-маршрутизатором, чтобы IP-пакет был ретранслирован корректно.</p></li></ul><p>До тех пор, пока не определено, что делать в указанных ситуациях (а это в данном документе не рассматривается), самым надёжным и безопасным способом является удаление IP-пакета.</p><h3 id="p3.23">3.23. Время жизни IP-пакета (Time-to-Live, TTL)</h3><p>При обычной ретрансляции IP-пакета, последний содержит в IP-заголовке поле «Time-To-Live» (время жизни) с некоторым значением. Всякий раз, когда IP-пакет «проходит» через маршрутизатор, значение в TTL-поле IP-заголовка этого пакета уменьшается на единицу. Если TTL-поле обнулилось ещё до того, как IP-пакет достиг своего получателя, то IP-пакет уничтожается.</p><p>Такой подход обеспечивает некоторый уровень защиты от возникновения петлевых маршрутов, которые могут появиться, либо вследствие ошибочных настроек, либо вследствие ошибки в алгоритме маршрутизации, либо вследствие медленной сходимости последнего. Иногда TTL-поле используется и в других целях, например, в целях применения групповой IP-адресации и поддержки управляющей команды «traceroute» (трассировка (прокладка) маршрута). Из этого следует, что существуют две проблемы, связанные с использованием TTL-поля, которые необходимо решить в рамках MPLS-архитектуры:</p><ol class="roman lia"><li><p>TTL-поле используется для предотвращения петлевых маршрутов;</p></li><li><p>TTL-поле используется для реализации других функций, например, ограничение времени существования IP-пакета.</p></li></ol><p>Когда IP-пакет «продвигается» по LSP-маршруту, тогда необходимо сохранять именно то значение в TTL-поле, которое могло быть в IP-заголовке, если бы IP-пакет доставлялся через ту же самую последовательность маршрутизаторов, но без MPLS-коммутации. Если IP-пакет «продвигается» по иерархической последовательности из LSP-маршрутов, то общее число промежуточных («встречающихся на маршруте») LSR-маршрутизаторов должно отражаться в TTL-поле этого IP-пакета, когда первоначальное значение в этом TTL-поле было выбрано на основе иерархической последовательности из LSP-маршрутов.</p><p>Способ контроля значения в TTL-поле может варьироваться в зависимости от того, каким образом доставляется значение MPLS-маркера, либо с помощью специализированного подзаголовка MPLS-коммутации («shim», RFC-3032), либо с помощью заголовка канального уровня (например, ATM-заголовок, RFC-3035, или FR-заголовок, RFC-3034).</p><p>Если значения маркеров потока закодированы и размещены в специализированном MPLS-подзаголовке, находящемся между заголовками канального и сетевого уровней, то в MPLS-подзаголовке должно содержаться TTL-поле, значение которого должно быть первоначально установлено путём копирования значения из TTL-поля заголовка сетевого уровня, должно уменьшаться на единицу при прохождении каждого ретрансляционного (промежуточного) LSR-маршрутизатора, и должно копироваться в TTL-поле заголовка сетевого уровня, когда IP-пакет «покидает» свой LSP-маршрут.</p><p>Если значения маркеров потока закодированы и размещены в заголовке канального уровня (например, в поле «VPI/VCI» ATM-заголовка адаптации, «AAL5»), и помеченные IP-пакеты транслируются коммутатором канального уровня (например, АТМ-коммутатор), а модуль канального уровня (например, АТМ-модуль) не предусматривает обработку TTL-поля, то исключается возможность уменьшения значения в этом TTL-поле на единицу при прохождении каждого промежуточного LSR-маршрутизатора. Интервал LSP-маршрута, включающий последовательность LSR-маршрутизаторов, которые не могут уменьшать значение в TTL-поле на единицу, будем называть «интервалом (сегментом/участком) LSP-маршрута без обработки TTL-поля».</p><p>Когда IP-пакет покидает интервал LSP-маршрута без обработки TTL-поля, тогда, тем не менее, целесообразно, чтобы TTL-поле присутствовало, а его значение отображало число пройденных IP-пакетом LSR-маршрутизаторов. В случае однонаправленной адресации, это может быть обеспечено за счёт распространения протяжённости основного LSP-маршрута тем входным сетевым узлам, которые позволяют снизить значение в TTL-поле еще до того, как транслируемые IP-пакеты «попадут» в сегмент LSP-маршрута без обработки TTL-поля.</p><p>Иногда указанное требование (число LSR-маршрутизаторов, пройденных IP-пакетом) может быть обеспечено и после поступления IP-пакета в сегмент LSP-маршрута без обработки TTL-поля, в котором значение TTL-поля истечёт ещё до того, как IP-пакет достигнет выхода из этого сегмента. В таком случае, LSR-маршрутизатор на входе участка LSP-маршрута без обработки TTL-поля обязан не осуществлять коммутацию IP-пакета на основе маркеров потока. Это означает, что должны быть разработаны специализированные процедуры для реализации функции трассировки маршрута, например, IP-пакеты для прокладки маршрута могут доставляться с помощью традиционной поузловой коммутации и доставки.</p><h3 id="p3.24">3.24. Контроль возникновения петлевого маршрута</h3><p>В пределах участка LSP-маршрута без обработки TTL-поля, по определению, TTL-поле не может использоваться для защиты от возникновения петлевых маршрутов доставки. Значимость контроля возникновения петлевого маршрута может зависеть от соответствующего программно-аппаратного комплексов (ПАК), используемых для реализации функций LSR-маршрутизаторов, и расположенных на участке LSP-маршрута без обработки TTL-поля.</p><p>Предположим, например, что ПАК АТМ-коммутации используется для реализации функций MPLS-коммутации с одновременной доставкой маркеров потока в VPI/VCI-поле. Так как ПАК АТМ-коммутации не способен уменьшать значение в TTL-поле, соответственно не существует защита от возникновения петлевых маршрутов. Если ПАК АТМ-коммутации способен обеспечить беспрепятственный доступ к буферной памяти, используемой для хранения входящих АТМ-ячеек, содержащих VPI/VCI-поля с различными значениями, то возникновение петлевых маршрутов не способно нанести какой-либо вред другому трафику. Если же ПАК АТМ-коммутации не способен обеспечить такой беспрепятственный доступ к буферной памяти, то, несмотря ни на что, даже быстро изменяющиеся петлевые маршруты могут стать причиной общего серьёзного ухудшения функционирования LSR-маршрутизаторов.</p><p>И даже если можно обеспечить беспрепятственный доступ к буферной памяти, то всё равно следует иметь определённые средства обнаружения петлевых маршрутов, которые «явно длиннее допустимых». Более того, даже если применение TTL-поля и/или соблюдение очерёдности для каждого виртуального соединения предоставляют средства обнаружения оставшихся циклических маршрутов, то по-прежнему такое обнаружение не возможно даже там, где специально запрещена настройка LSP-маршрутов, которые являются петлевыми. Все LSR-маршрутизаторы, которые могут быть связаны с участком LSP-маршрута без обработки TTL-поля, всё равно будут запрашивать необходимую системную поддержку для обнаружения петлевых маршрутов. Тем не менее, применение определённого способа выявления петлевых маршрутов является не обязательным (дополнительным). Такой способ представлен в стандартах RFC-3035 и RFC-3036 (RFC-5036).</p><h3 id="p3.25">3.25. Кодирование маркеров потоков</h3><p>С целью транспортировки набора маркеров совместно с IP-пакетом, к которому и относится этот набор маркеров, необходимо определить конкретное кодирование набора маркеров. MPLS-архитектура включает несколько различных способов кодирования. Выбор определённого способа зависит от соответствующего типа устройства, используемого для доставки помеченных IP-пакетов.</p><h4>3.25.1. ПАК (или программный комплекс) для MPLS-коммутации</h4><p>Если ПАК (или программный комплекс) для MPLS-коммутации обеспечивает доставку помеченных IP-пакетов, то наиболее приемлемым способом кодирования набора маркеров является использование «вставки» (shim<sup><abbr title="Дословно «клин» или «прокладка»">[?]</abbr></sup>) между заголовками канального и сетевого уровней. Такой способ мог быть описан независимым протоколом, а сама вставка могла использоваться на любом сетевом уровне. В последующем будет использоваться термин «универсальная MPLS-вставка» (generic MPLS encapsulation).</p><p>В свою очередь, само размещение универсальной MPLS-вставки могло бы осуществляться на канальном уровне. Использование универсальной MPLS-вставки представлено в стандарте RFC-3032.</p><h4 id="p3.25.2">3.25.2. АТМ-коммутаторы как LSR-маршрутизаторы</h4><p>Следует отметить, что процедуры MPLS-доставки аналогичны тем существующим коммутаторам, которые реализуют процедуры «смены маркеров» (label swapping), например, АТМ-коммутаторы. Последние используют входной физический интерфейс и значение входного идентификатора VPI/VCI (идентификатор виртуального соединения/маршрута) в качестве индекса в таблице связности (cross-connect), по которой они определяют выходной физический интерфейс и значение выходного идентификатора VPI/VCI. Более того, если один или более маркеров могут быть непосредственно закодированы в полях заголовков протокольных сообщений, и которые будут доступны для обработки ныне существующими коммутаторами, то последние (с необходимым программным обеспечением) могут использоваться в качестве LSR-маршрутизаторов. В дальнейшем такие ПАК будут именоваться ATM/LSR-маршрутизаторы (ATM-LSR).</p><p>Существуют три очевидных способов кодирования маркеров в заголовке АТМ-ячейки (ATM cell header), полагая использование АТМ-уровня адаптации «AAL5», а именно:</p><ol class="lia"><li><p class="b">Кодирование коммутируемого виртуального соединения (SVC encoding).</p><p class="lia">Этот способ предусматривает использование VPI/VCI-поля для кодирования маркера, который является самым верхним в наборе маркеров. Такой способ может использоваться в любой сети. При использовании этого способа кодирования каждый LSP-маршрут представляет собой АТМ/SVC-соединение, а протоколом доставки (распределения) маркеров выступает протокол ATM-сигнализации (signaling). Если используется этот способ, то ATM/LSR-маршрутизаторы не могут реализовать функции «проталкивания» или «удаления» (выталкивания) набора маркеров.</p></li><li><p class="b">Кодирование коммутируемого виртуального маршрута (SVP encoding).</p><p class="lia">Этот способ предусматривает использование VPI-поля для кодирования маркера, который является самым верхним в наборе маркеров и VCI-поля для кодирования второго маркера из набора, если конечно он представлен. Этот способ имеет ряд преимуществ по сравнению с первым, рассмотренным выше, в частности, он позволяет использовать коммутацию виртуального АТМ-маршрута. Т.е. LSP-маршруты настраиваются как коммутируемые виртуальные АТМ-маршруты на основе применения протокола доставки (распределения) маркеров, а именно протокола ATM-сигнализации.</p><p class="lia">Тем не менее, этот способ нельзя использовать всегда. Если сеть включает виртуальный АТМ-маршрут, проходящий через АТМ-сеть, в которой отдельный сегмент этой сети не применяет MPLS-коммутацию, то VPI-поле использовать для MPLS-коммутации бесполезно. Если этот способ кодирования используется, то ATM/LSR-маршрутизатор на выходе виртуального маршрута способен эффективно осуществлять процедуру «удаления» (выталкивания) маркера.</p></li><li><p class="b">Многоузловое кодирование коммутируемого виртуального маршрута (SVP multipoint encoding).</p><p class="lia">Этот способ предусматривает использование VPI-поля для кодирования маркера, который является самым верхним в наборе маркеров, VCI-поля для кодирования второго маркера из набора, если конечно он представлен, и оставшуюся часть VCI-поля для идентификации начала LSP-маршрута. Если используется данный способ, то стандартные свойства коммутируемых виртуальных АТМ-маршрутов могут применяться для многоузловых виртуальных маршрутов. Ячейки, формируемые на основе заголовков различных IP-пакетов, будут включать различные значения VCI-идентификаторов. Как мы увидим в дальнейшем, такой подход позволяет осуществлять процедуру слияния маркеров АТМ-коммутаторами (причём без каких-либо проблем, связанных с «чередованием» ячеек), которые могут поддерживать многоузловые виртуальные маршруты, но которые не способны совмещать виртуальные соединения. Данный способ зависит от наличия процедуры присвоения 16-битового значения VCI-идентификатора каждому АТМ-коммутатору, причём такого, чтобы ни одно такое значение не было присвоено двум разным коммутаторам. (Если требуемого числа таких идентификаторов не достаточно для присвоения каждому коммутатору, то можно использовать значение VCI-идентификатора в качестве второго маркера в наборе.)</p></li></ol><p>Если на практике используется гораздо больше маркеров в наборе, чем можно закодировать с использованием АТМ-заголовка, то АТМ-кодирование должно дополняться (или комбинироваться с) универсальной MPLS-вставкой.</p><h4>3.25.3. Обеспечение функциональной совместимости способов кодирования</h4><p>Если &lt;<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, <em>R</em><sub>3</sub>&gt; представляет собой участок LSP-маршрута, то существует возможность того, что <em>R</em><sub>1</sub> будет использовать один способ кодирования набора маркеров при передаче IP-пакета <em>P</em> <em>R</em><sub>2</sub>, в то время как <em>R</em><sub>2</sub> будет использовать другой способ кодирования при передаче IP-пакета <em>P</em> <em>R</em><sub>3</sub>. Вообще, MPLS-архитектура рассматривает LSP-маршруты с различными способами кодирования наборов маркеров, используемыми на разных ретрансляционных участках. Более того, когда рассматриваются процедуры обработки помеченного IP-пакета, то используются абстрактные термины для описания применения набора маркеров при доставке IP-пакета. После получения помеченного IP-пакета LSR-маршрутизатор должен декодировать его, чтобы определить текущее значение набора маркеров, затем он должен обработать сам набор маркеров, чтобы определить новое значение набора, и затем закодировать соответствующим образом новое значение, и только после этого отправить помеченный IP-пакет на его следующий ретрансляционный участок.</p><p>К сожалению, АТМ-коммутаторы не способны преобразовывать один способ кодирования в другой. Более того, MPLS-архитектура требует, чтобы два АТМ-коммутатора, там, где возможно, корректно выполняли функции LSR-маршрутизаторов по доставке некоторого IP-пакета по LSP-маршруту с уровнем <em>m</em>, также необходимо, чтобы эти два АТМ-коммутатора применяли один и тот же способ кодирования.</p><p>Естественно, что будут существовать MPLS-сети, которые будут сочетать в себе АТМ-коммутаторы, функционирующие как LSR-маршрутизаторы, и другие LSR-маршрутизаторы, которые функционируют на основе использования заголовка с универсальной MPLS-вставкой. В таких сетях может быть несколько LSR-маршрутизаторов, имеющих АТМ-адаптеры (АТМ-интерфейсы), а также адаптеры/интерфейсы для обработки заголовков с универсальной MPLS-вставкой («MPLS shim» interfaces). Это является одним из примеров LSR-маршрутизатора, который функционирует с различными способами кодирования набора меток на разных ретрансляционных участках. Такой LSR-маршрутизатор может удалить набор маркеров с кодированием для АТМ-коммутации на входном интерфейсе, а на выходном интерфейсе может заменить его на заголовок с универсальной MPLS-вставкой, содержащей набор маркеров.</p><h3 id="p3.26">3.26. Процедура слияния маркеров потоков</h3><p>Предположим, что LSR-маршрутизатор привязал к соответствующему FEC-классу несколько входящих маркеров. При доставке IP-пакетов, принадлежащих одному FEC-классу, последний мог бы иметь один исходящий маркер, который применялся бы ко всем таким IP-пакетам. Факт получения двух разных IP-пакетов, относящихся к одному FEC-классу, с различными входными маркерами вообще не рассматривается, он просто неуместен. Желательно, чтобы такие IP-пакеты доставлялись с одним и тем же исходящим маркером. Процедура, обеспечивающая сказанное выше, называется «слиянием (объединением) маркеров» (label merging).</p><p>Будем говорить, что LSR-маршрутизатор способен реализовывать процедуру слияния маркеров, если он может принять два разных IP-пакета из двух разных интерфейсов и/или с различными маркерами и отправить эти оба IP-пакета по одному и тому же выходному интерфейсу и с одним и тем же маркером. Так как IP-пакеты ретранслируются, то информация, которую они доставляют по различным интерфейсам и/или с различными входящими маркерами, пропадает.</p><p>Будем говорить, что LSR-маршрутизатор не способен реализовывать процедуру слияния маркеров, если им были получены любые два IP-пакета из разных входных интерфейсов или с различными маркерами, то он должен отправить их по разным интерфейсам или с различными маркерами. ATM/LSR-маршрутизаторы, использующие кодирование коммутируемых виртуальных соединений или маршрутов, не способны осуществить процедуру слияния маркеров.</p><p>Если некоторый ATM/LSR-маршрутизатор не способен осуществить процедуру слияния маркеров, то при получении двух IP-пакетов, принадлежащих одному и тому же FEC-классу, но с различными маркерами, они должны быть ретранслированы с использованием двух различных исходящих маркеров. При слиянии маркеров, на один FEC-класс необходим только один исходящий маркер. В противном случае, число исходящих маркеров на один FEC-класс может быть огромно и соответствовать числу сетевых узлов.</p><p>Если процедура слияния маркеров используется, то число входящих маркеров на один FEC-класс, которое необходимо соответствующему LSR-маршрутизатору, никогда не превысит число соседей (смежных маршрутизаторов), которым доставлялись маркеры. Если же процедура слияния маркеров не используется, то число входящих маркеров на один FEC-класс, которое необходимо соответствующему LSR-маршрутизатору, огромно и соответствует числу сетевых узлов восходящих потоков, которые транслируют трафик определённого FEC-класса по запросу этого LSR-маршрутизатора. На самом деле, LSR-маршрутизатору весьма трудно установить, как много таких входящих маркеров он должен поддерживать для конкретного FEC-класса.</p><p>MPLS-архитектура предусматривает применение LSR-маршрутизаторов, которые реализуют и не реализуют процедуру слияния маркеров, и, фактически, допускает, что могут быть LSR-маршрутизаторы, которые вообще не способны осуществить процедуру слияния маркеров. Это порождает проблему надёжной и корректной функциональной совместимости LSR-маршрутизаторов, которые реализуют и не реализуют процедуру слияния маркеров. Эта проблема в некоторой степени зависит от способа доставки и типа среды передачи трафика.</p><h4>3.26.1. LSR-маршрутизаторы с функцией и без функции слияния маркеров</h4><p>MPLS-процедуры доставки очень похожи на процедуры доставки, которые реализуются в АТМ- и FR-сетях. Т.е., при поступлении протокольного элемента данных осуществляется поиск маркера (VPI/VCI- или DLCI-идентификатора) в таблице связности («cross-connect table»), по итогам такого поиска выбирается выходной интерфейс и перезаписывается значение маркера. Фактически, такие способы доставки данных можно использовать в MPLS-системах. А LDP-протокол можно использовать в качестве протокола сигнализации (signaling protocol) в процедуре настройки таблиц связности.</p><p>К сожалению, эти способы делают не нужной процедуру слияния маркеров. Если в АТМ-сетях попытаться осуществить слияние маркеров, то в результате может последовать чередование ячеек с различными IP-пакетами. А если ячейки с различными IP-пакетами стали чередоваться, то в такой ситуации просто невозможно осуществить повторную сборку IP-пакетов. Некоторые FR-коммутаторы совмещают FR- и АТМ-коммутацию (коммутацию ячеек) на основе своих объединённых плат (задних панелей, backplane). Такие коммутаторы могут быть также не способны реализовывать процедуру слияния маркеров, причём по той же самой причине — чередование ячеек с различными IP-пакетами и отсутствие, в таких условиях, способа повторной сборки IP-пакетов.</p><p>Предлагается два решения данной проблемы. Во-первых, MPLS-система будет реализовывать процедуры, которые позволяют использовать LSR-маршрутизаторы без функции слияния маркеров. Во-вторых, MPLS-система будет реализовывать процедуры, которые позволяют использовать определённые АТМ-коммутаторы, функционирующие как LSR-маршрутизаторы.</p><p>Так как MPLS-система использует оба типа LSR-маршрутизаторов (с функцией и без функции слияния маркеров), то она обязана реализовывать процедуры, которые бы гарантировали корректную функциональную совместимость между LSR-маршрутизаторами разных типов.</p><h4>3.26.2. Маркеры для LSR-маршрутизаторов с функцией и без функции слияния маркеров</h4><p>LSR<sub>ВП</sub> с функцией слияния маркеров требует, чтобы ему был передан всего лишь один маркер для одного FEC-класса. Соседний LSR<sub>ВП</sub> без функции слияния маркеров требует, чтобы ему был передано несколько маркеров для одного FEC-класса. Однако не существует способа предварительного определения числа маркеров, которые ему необходимы. Это зависит от числа LSR-маршрутизаторов, являющихся LSR<sub>ВП</sub>, которые обрабатывают трафик соответствующего FEC-класса.</p><p>MPLS-архитектура устанавливает, что если некоторый соседний LSR<sub>ВП</sub> не реализует процедуру слияния маркеров, то ему не будут передаваться какие-либо маркеры соответствующего FEC-класса до тех пор, пока он недвусмысленно запросит маркер для этого FEC-класса. Соседний LSR<sub>ВП</sub> может направить несколько таких запросов, и при этом каждый раз получать новый маркер. Когда соседний LSR<sub>НП</sub> получает такой запрос от LSR<sub>ВП</sub>, и при этом соседний LSR<sub>НП</sub> не обладает функцией, то он должен в свою очередь запросить свой соседний LSR<sub>НП</sub> относительно другого маркера для соответствующего FEC-класса.</p><p>Возможна ситуация, при которой функционируют несколько сетевых узлов, реализующих процедуру слияния маркеров, но они могут объединять только ограниченное число входящих маркеров в один исходящий. Предположим, например, что вследствие некоторых аппаратных ограничений сетевой узел может объединить четыре входящих маркера в один исходящий. Несмотря на это, предположим, что этот конкретный сетевой узел получил шесть входящих маркеров, относящихся к одному FEC-классу. В таком случае, данный сетевой узел может объединить поступившие маркеры в два исходящих.</p><p>Является ли процедура слияния маркеров применимой к LSP-маршруту на основе явной маршрутизации? Этот вопрос требует дальнейшего исследования.</p><h4>3.26.3. Процедура слияния маркеров в АТМ-сетях</h4><h5>3.26.3.1. Методы предотвращения чередования ячеек</h5><p>Существует несколько методов решения проблемы чередования ячеек в АТМ-системах, которые позволяют АТМ-коммутаторам реализовать процедуру слияния маркеров:</p><ol class="lia"><li><p class="b">Слияние маркеров в рамках виртуального маршрута с использованием кодирования коммутируемого виртуального маршрута с групповой адресацией.</p><p class="lia">Если используется слияние маркеров в рамках виртуального маршрута, то несколько виртуальных объединяются в один виртуальный маршрут, но при этом IP-пакеты из различных источников распознаются на основе проверки различных значений VCI-идентификаторов в пределах конкретного виртуального маршрута.</p></li><li><p class="b">Слияние маркеров виртуальных соединений.</p><p class="lia">Если используется слияние маркеров виртуальных соединений, то необходимы маршрутизаторы, которые накапливают ячейки для одного IP-пакета, причём до тех пор, пока не будет получен весь IP-пакет (это можно определить, используя процедуру поиска индикатора окончания кадра на AAL5-уровне адаптации).</p></li></ol><p>Слияние маркеров в рамках виртуального маршрута имеет преимущество, которое заключается в том, что данный метод совместим с большинством существующих ПАК/АТМ-коммутации. Это позволяет с высокой вероятностью говорить о том, что метод слияния маркеров в рамках виртуального маршрута применим в существующих сетях. В отличие от слияния маркеров виртуальных соединений, метод слияния маркеров в рамках виртуального маршрута не приводит к каким-либо задержкам в точках проведения процедуры слияния маркеров, а также не предъявляет каких-либо требований к буферной памяти. Тем не менее, этот метод имеет и недостаток, который заключается в том, что он требует согласования пространства VCI-идентификаторов в пределах каждого виртуального маршрута. Существует несколько способов, как это можно преодолеть. Выбор того или иного метода подлежит дальнейшему изучению.</p><p>Компромиссное решение между функциональной совместимостью с существующим сетевым оборудованием и сложностью протокола и масштабируемостью предполагает отказ от одновременной поддержки обоих методов слияния маркеров MPLS-сетью. Для того чтобы каждый АТМ-коммутатор соответствовал условиям функционирования MPLS-сети, необходимо знать реализуют ли его ближайшие «АТМ-соседи» процедуру слияния маркеров, либо в рамках виртуального маршрута, либо виртуальных маршрутов, или вообще не реализуют.</p><h5>3.26.3.2. Функциональная совместимость: реализуется процедура слияния маркеров, либо в рамках виртуального маршрута, либо виртуальных соединений, или процедура не реализуется</h5><p>Функциональная совместимость при использовании различных процедур слияния маркеров в АТМ-сети определяется весьма просто, во-первых, путём определения совместимости режима использования процедуры слияния маркеров виртуальных соединений с режимом отсутствия такой процедуры.</p><p>Если сетевые узлы, использующие и не использующие процедуру слияния маркеров виртуальных соединений, взаимосвязаны, то во всех случаях доставка АТМ-ячеек основана организации виртуальных соединений (т.е. VPI- и VCI-идентификаторы используются в режиме «сцепления», concatenation). Для каждого сетевого узла, если соседний АТМ/LSR<sub>ВП</sub> реализует процедуру слияния маркеров виртуальных соединений, то данный «сосед» запрашивает только одиночную пару VPI/VCI-идентификаторов для соответствующего потока (т.е. по аналогии с запросом одиночного маркера потока в случае FR-сети). Если же соседний АТМ/LSR<sub>ВП</sub> не реализует процедуру слияния маркеров, то он запрашивает только одну пару VPI/VCI-идентификаторов для каждого потока в собственных интересах, и дополнительно — необходимое число VPI/VCI-идентификаторов для передачи своим соседним АТМ/LSR<sub>ВП</sub>. Требуемое число VPI/VCI-идентификаторов будет определяться количеством АТМ/LSR<sub>ВП</sub>, которым разрешено запрашивать дополнительные VPI/VCI-идентификаторы от своих соседних АТМ/LSR<sub>НП</sub> (т.е. опять аналогично методу, используемому при слиянии маркеров в FR-сетях).</p><p>Аналогичный метод может использоваться и сетевыми узлами, которые реализуют процедуру слияния маркеров в рамках виртуального маршрута. В этом случае сетевой узел, реализующий процедуру слияния маркеров в рамках виртуального маршрута, скорее всего, затребует одиночный виртуальный маршрут (определяемый своим VPI-идентификатором) вместо нескольких VCI-идентификаторов в рамках виртуального маршрута, и не будет запрашивать одиночный или несколько VPI/VCI-идентификаторов от своих соседних АТМ/LSR<sub>НП</sub>. Более того, предположим, что сетевой узел, не реализующий процедуру слияния маркеров, является нисходящим узлом относительно двух разных узлов, реализующих процедуру слияния маркеров в рамках виртуального маршрута. Такому сетевому узлу может понадобиться запросить один VPI/VCI-идентификатор (для трафика, отправляемого им самим) и два VPI-идентификатора (по одному для каждого АТМ/LSR<sub>ВП</sub>), каждый из которых связан с определённым набором VCI-идентификаторов (так как запрашиваются АТМ/LSR<sub>ВП</sub>).</p><p>Для того, что бы обеспечить одновременное функционирование всех режимов работы (слияние маркеров в рамках виртуального маршрута, виртуальных соединений и без слияния маркеров), дополнительно следует разрешить АТМ/LSR<sub>ВП</sub> запрашивать совокупность (от нуля и более) VCI-идентификаторов (состоящих из VPI/VCI-идентификаторов), совокупность (от нуля и более) виртуальных маршрутов (определяемых VPI-идентификаторами), причём каждый будет включать определённое число виртуальных соединений (определяемых совокупностью VCI-идентификаторов, которые, в свою очередь, указывают на виртуальный маршрут). Более того, сетевые узлы, реализующие процедуру слияния маркеров в рамках виртуального маршрута, могли бы запросить один виртуальный маршрут, содержащий VCI-идентификатор, по которому транслируется трафик (если необходимо), а также VCI-идентификатор для каждого виртуального соединения, запрошенных «сверху» (не обращая внимания на то, является или не является виртуальное соединение частью виртуального маршрута). Сетевой узел, реализующий процедуру слияния маркеров виртуальных соединений, мог бы запросить только один VPI/VCI-идентификатор (так как такие узлы могут реализовать процедуру слияния маркеров всего восходящего трафика в одно виртуальное соединение). Сетевые узлы, не реализующие процедуру слияния маркеров, могли бы направить любые запросы, которые они получат «сверху», а также запрос VPI/VCI-идентификатора трафика, который они ретранслируют (если необходимо).</p><h3 id="p3.27">3.27. Туннели и иерархия</h3><p>Иногда маршрутизатор <em>R<sub>u</sub></em> выполняет вполне конкретную процедуру по определению, какой IP-пакет должен быть доставлен на другой маршрутизатор <em>R<sub>d</sub></em>, даже если <em>R<sub>u</sub></em> и <em>R<sub>d</sub></em> не являются следующими друг за другом маршрутизаторами на поузловом маршруте доставки этого IP-пакета, а <em>R<sub>d</sub></em> не является конечным пунктом назначения этого IP-пакета. Например, это можно сделать путём вставки транслируемого пакета в IP-пакет сетевого уровня, у которого адрес получателя является IP-адресом этого маршрутизатора <em>R<sub>d</sub></em>. Такая процедура формирует «туннель» (tunnel) от <em>R<sub>u</sub></em> до <em>R<sub>d</sub></em>. В дальнейшем любой пакет, прошедший такую процедуру обработки, именуется «туннелированным» (tunneled packet).</p><h4>3.27.1. Туннель с поузловой маршрутизацией</h4><p>Если туннелированный пакет (ТП) следует по поузловому маршруту от <em>R<sub>u</sub></em> до <em>R<sub>d</sub></em>, то такой маршрут называется «туннелем с поузловой маршрутизацией» (hop-by-hop routed tunnel), в котором <em>R<sub>u</sub></em> — «крайняя точка передачи» (transmit endpoint), а <em>R<sub>d</sub></em> — «крайняя точка приёма» (receive endpoint).</p><h4>3.27.2. Туннель с точной (явной) маршрутизацией</h4><p>Если ТП следует по маршруту от <em>R<sub>u</sub></em> до <em>R<sub>d</sub></em>, но отличному от поузлового маршрута, то такой маршрут называется «туннелем с точной маршрутизацией» (explicitly routed tunnel), в котором <em>R<sub>u</sub></em> — «крайняя точка передачи» (transmit endpoint), а <em>R<sub>d</sub></em> — «крайняя точка приёма» (receive endpoint). Пакет сетевого уровня можно передать по туннелю с точной маршрутизацией путём его размещения (вставки) в пакет, который был передан источником.</p><h4>3.27.3. Туннели на основе LSP-маршрутов</h4><p>Туннель можно представить как LSP-маршрут, и лучше всего использовать коммутацию на основе маркеров потока, чем размещать IP-пакет в кадре канального уровня и, таким образом, транслировать его по туннелю. Пусть туннелем будет LSP-маршрут &lt;<em>R</em><sub>1</sub>, ..., <em>R<sub>n</sub></em>&gt;, в котором <em>R</em><sub>1</sub>, — крайняя точка передачи в туннеле, а <em>R<sub>n</sub></em> — крайняя точка приёма в туннеле. Такой маршрут называется «LSP-туннель».</p><p>Совокупность IP-пакетов, которая транслируется по LSP-туннелю, образует FEC-класс, а каждый LSR-маршрутизатор в туннеле обязан присваивать маркер такому FEC-классу (т.е. обязан присваивать маркер к туннелю). Выбор критерия, по которому соответствующий IP-пакет «закрепляется» за LSP-туннелем, определяется локально в крайней точке передачи туннеля. Для того, чтобы доставить IP-пакет по LSP-туннелю, в крайней точке передачи вставляется маркер туннеля в набор маркеров, а затем помеченный IP-пакет доставляется по следующему ретрансляционному участку туннеля.</p><p>Если в крайней точке приёма туннеля нет необходимости в определении того, какой IP-пакет транслировался по туннелю, то, как было рассмотрено ранее, набор маркеров может быть полностью удалён предпоследним LSR-маршрутизатором в туннеле.</p><p>«LSP-туннель, сформированный на основе поузловой маршрутизации» (hop-by-hop routed LSP tunnel), представляет собой туннель, сформированный как LSP-маршрут с поузловой маршрутизацией между крайней точкой передачи и крайней точкой приёма.</p><p>«LSP-туннель, сформированный на основе точной маршрутизации» (explicitly routed LSP tunnel), представляет собой туннель, сформированный как LSP-маршрут на основе точной маршрутизацией.</p><h4>3.27.4. Иерархия: LSP-туннели в рамках LSP-маршрутов</h4><p>Пусть имеет место LSP-маршрут &lt;<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, <em>R</em><sub>3</sub>, <em>R</em><sub>4</sub>&gt;. Теперь предположим, что <em>R</em><sub>1</sub> принял непомеченный IP-пакет <em>P</em> и поместил в его набор маркеров свой маркер, чтобы направить его по данному маршруту. Фактически, такой маршрут является поузловым. Однако в дальнейшем полагаем, что <em>R</em><sub>2</sub> и <em>R</em><sub>3</sub> не имеют прямого соединения между собой, но считаются «соседями» в силу того, что являются оконечными (крайними) точками LSP-туннеля. Таким образом, реальной последовательностью LSR-маршрутизаторов, по которым доставляется IP-пакет <em>P</em>, является &lt;<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, <em>R</em><sub>21</sub>, <em>R</em><sub>22</sub>, <em>R</em><sub>23</sub>, <em>R</em><sub>3</sub>, <em>R</em><sub>4</sub>&gt;.</p><p>Когда <em>P</em> следует по маршруту от <em>R</em><sub>1</sub> до <em>R</em><sub>2</sub>, он имеет глубину набора маркеров равную 1. <em>R</em><sub>2</sub>, осуществляющий коммутацию по маркеру, определяет, что <em>P</em> должен следовать далее по туннелю. <em>R</em><sub>2</sub> первым заменяет входящий маркер на маркер, который является значимым для <em>R</em><sub>3</sub>. Затем он «заталкивает» новый маркер. Этот маркер второго уровня имеет значение, которое является значимым для <em>R</em><sub>21</sub>. Далее коммутация осуществляется <em>R</em><sub>21</sub>, <em>R</em><sub>22</sub> и <em>R</em><sub>23</sub>, с использованием маркера второго уровня. <em>R</em><sub>23</sub>, который является предпоследним коммутатором в туннеле <em>R</em><sub>2</sub> &rArr; <em>R</em><sub>3</sub>, перед тем, как отправить IP-пакет <em>R</em><sub>3</sub>, выталкивает набор маркеров. Когда <em>R</em><sub>3</sub> проанализирует IP-пакет <em>P</em>, он установит, что в <em>P</em> содержится только один маркер первого уровня, что указывает на выход из туннеля. Так как <em>R</em><sub>3</sub> является предпоследним коммутатором в LSP-маршруте первого уровня при доставке IP-пакет <em>P</em>, он выталкивает набор маркеров, а <em>R</em><sub>4</sub> принимает <em>P</em> непомеченным.</p><p>Использование набора маркеров позволяет формировать LSP-туннели любой глубины.</p><h4>3.27.5. Информационный обмен при доставке маркеров и иерархия</h4><p>Предположим, что IP-пакет <em>P</em> доставляется по LSP-маршруту первого уровня &lt;<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, <em>R</em><sub>3</sub>, <em>R</em><sub>4</sub>&gt;, а когда он будет доставляться от <em>R</em><sub>2</sub> до <em>R</em><sub>3</sub>, то будет следовать по LSP-маршруту второго уровня &lt;<em>R</em><sub>2</sub>, <em>R</em><sub>21</sub>, <em>R</em><sub>22</sub>, <em>R</em><sub>3</sub>&gt;. С точки зрения LSP-маршрута второго уровня, противоположной стороной доставки (распределения) маркеров для <em>R</em><sub>2</sub> является <em>R</em><sub>21</sub>. С точки зрения LSP-маршрута первого уровня, противоположными сторонами доставки (распределения) маркеров для <em>R</em><sub>2</sub> являются <em>R</em><sub>1</sub> и <em>R</em><sub>3</sub>. <em>R</em><sub>2</sub> может проводить процедуры распределения маркеров с соседними коммутаторами на любом уровне иерархии. В дальнейшем будут рассмотрены некоторые способы использования такой иерархии. Следует заметить, что в представленном выше примере коммутаторы <em>R</em><sub>2</sub> и <em>R</em><sub>21</sub> должны быть соседями с точки зрения IGP-протокола, в то время как для коммутаторов <em>R</em><sub>2</sub> и <em>R</em><sub>3</sub> такое требование не обязательно.</p><p>Когда два LSR-маршрутизатора являются соседями с точки зрения IGP-протокола, то говорят, что они являются «взаимодействующими сторонами локальной процедуры распределения маркеров» (local label distribution peers). Когда два LSR-маршрутизатора не являются соседями с точки зрения IGP-протокола, то говорят, что они являются «взаимодействующими сторонами при проведении удалённой процедуры распределения маркеров» (remote label distribution peers). В рассмотренном ранее примере коммутаторы <em>R</em><sub>2</sub> и <em>R</em><sub>21</sub> являются взаимодействующими сторонами локальной процедуры распределения маркеров, а коммутаторы <em>R</em><sub>2</sub> и <em>R</em><sub>3</sub> — взаимодействующими сторонами удалённой процедуры распределения маркеров.</p><p>MPLS-архитектура рассматривает два способа распределения (доставки) маркеров на различных уровнях иерархии: явная (точная) процедура доставки маркеров (explicit peering) и неявная процедура доставки маркеров (implicit peering).</p><p>Коммутатор (сетевой узел) проводит процедуру распределения (доставки) маркеров с другой взаимодействующей стороной (другим коммутатором, сетевым узлом) путём передачи сообщений LDP-протокола, которые адресованы этой стороне. Коммутатор (сетевой узел) может организовать распределение (доставку) маркеров с удалённой взаимодействующей стороной (другим коммутатором, сетевым узлом) одним из следующих двух способов:</p><ol class="lia"><li><p class="b">Явная (точная) процедура доставки маркеров.</p><p class="lia">При реализации этой процедуры коммутатор (сетевой узел) доставляет маркеры взаимодействующей с ним стороне путём передачи сообщений LDP-протокола, которые адресованы данной стороне, причём точно так же, как если бы они были сторонами локального обмена маркерами (local label distribution peers). Этот способ наиболее приемлем там, где число удаленных сторон, которые обмениваются маркерами, — мало, или тогда, когда число привязок маркеров верхнего уровня — большое, или тогда, когда удаленные стороны, которые обмениваются маркерами, расположены в определённых маршрутизационных областях или сегментах. Естественно, коммутатору необходимо знать, какие маркеры и каким сторонам следует доставлять.</p></li><li><p class="b">Неявная процедура доставки маркеров.</p><p class="lia">При реализации этой процедуры коммутатор (сетевой узел) не передаёт взаимодействующей с ним стороне сообщения LDP-протокола, которые адресованы данной стороне. Вероятнее всего, для доставки маркеров верхнего уровня другим удалённым сторонам обмена маркерами, коммутатор (сетевой узел) кодирует маркер верхнего уровня как атрибут маркера нижнего уровня, и затем транслирует маркер нижнего уровня, вместе с атрибутом, другим взаимодействующим с ним локальным сторонам обмена маркерами. После этого, локальные стороны (коммутаторы и/или сетевые узлы) обмена маркерами распространяют информацию о своих локальных сторонах обмена маркерами. Этот процесс продолжается до тех пор, пока информация не достигнет удалённой стороны обмена маркерами.</p><p class="lia">Этот способ наиболее приемлем там, где число удалённых сторон обмена маркерами очень велико. Неявная доставка маркеров не требует <em>n</em>-связной сети информационного обмена для доставки маркеров удалённым сторонам обмена маркерами, так как информация распространяется в дуплексном режиме с помощью локальных процедур обмена маркерами. Однако неявная доставка маркеров требует наличия промежуточных сетевых узлов для хранения информации, в которой они напрямую могут быть не заинтересованы.</p></li></ol><h3 id="p3.28">3.28. Доставка данных о LDP-протоколе</h3><p>LDP-протокол используется между узлами MPLS-сети для формирования и обработки привязок маркеров. Для корректного функционирования MPLS-сети информация о доставке маркеров должна передаваться надёжно, а сообщения LDP-протокола, принадлежащие определённому FEC-классу, должны транслироваться последовательно. Также для этого необходимо обеспечить управление потоком, так как оно обеспечит доставку сообщений с несколькими маркерами в одной дейтаграмме.</p><p>Одним из решений указанных выше проблем является использование протокола транспортного уровня с установлением соединения, в частности ТСР-протокола (RFC-3107 / <a href="../4271.rfc" title="RFC 4271 — Протокол BGP-4">RFC-4271</a>), RFC-3036 / RFC-5036).</p><h3 id="p3.29">3.29. Один или несколько LDP-протоколов?</h3><p>Данный стандарт MPLS-архитектуры не устанавливает строгих и оптимальных правил выбора конкретного LDP-протокола, используемого в конкретных условиях. Тем не менее, можно определить некоторые условия такого выбора.</p><h4>3.29.1. BGP- и LDP-протоколы</h4><p>Во многих случаях желательно привязывать маркеры к тем FEC-классам, которые могут быть идентифицированы по маршрутам, указанным в префиксах IP-адресов. Но если имеет место стандарт широко распространённого (используемого) алгоритма маршрутизации, который устанавливает такие маршруты, то весьма сомнительно, что доставка маркеров на основе дуплексной передачи по этим же маршрутам будет самой эффективной.</p><p>Например, такие маршруты устанавливает BGP-протокол, и если активному программному BGP-модулю (BGP-серверу) также необходимо доставить маркеры своим «BGP-коллегам», то применение BGP-протокола для доставки маркеров имеет ряд несомненных преимуществ. Соответственно, BGP-протокол допускает использование аналогичных BGP-маршрутов для доставки (распределения) маркеров, обеспечивая, таким образом, преимущество необходимого масштабирования по сравнению LDP-протоколом, если бы последний использовался для распределения маркеров между BGP-серверами.</p><h4>3.29.2. Описание маркеров для RSVP-протокола, регулирующего трафик</h4><p>Когда используется RSVP-протокол в целях резервирования ресурсов для определённых потоков данных, то может быть желательна процедура маркирования IP-пакетов в таких потоках, и при этом нет необходимости применять средство распознавания сообщений RSVP-протокола на каждом ретрансляционном участке. И, тем не менее, весьма сомнительно, что наличие процедуры распределения маркеров в рамках функционирования RSVP-процесса по резервированию ресурса или определению резервного маршрута является самым эффективным методом доставки маркеров в данном случае.</p><h4>3.29.3. Описание маркеров для явно устанавливаемых LSP-маршрутов</h4><p>В некоторых MPLS-сетях, в которых применяются соответствующий системы управления трафикам, весьма желательно устанавливать точный маршрут от входного до выходного коммутаторов. Кроме того, рекомендуется использовать резервирование ресурсов на протяжении всего маршрута.</p><p>Для реализации указанных рекомендаций можно использовать следующие два способа:</p><ul class="list lia"><li><p>Начать с существующего протокола и использовать его для проведения резервирования ресурсов, а затем применить его для установления точного маршрута и распределения маркеров (RFC-3209, -3210);</p></li><li><p>Начать с существующего протокола, используемого для распределения маркеров, а затем применить его для установления точного маршрута и проведения резервирования ресурсов (RFC-3212).</p></li></ul><h2 id="p4">4. Реализационные аспекты MPLS-архитектуры</h2><h3 id="p4.1">4.1. MPLS-архитектура и трафик с поузловой маршрутизацией</h3><p>Часть эксплуатируемых MPLS-систем требует, чтобы IP-пакеты с соответствующим маркером доставлялись по одном и тому же маршруту с поузловой маршрутизацией, который бы одновременно использовался и для трансляции IP-пакета с определённым адресом сетевого уровня, содержащимся в поле адреса получателя.</p><h4>4.1.1. Маркеры для префиксов адресов</h4><p>Как правило, маршрутизатор <em>R</em> определяет следующий ретрансляционный участок для пакета <em>P</em> путём поиска в своей маршрутной таблице префикса адреса <em>Х</em>, который максимально (с точки зрения длины в битах) совпадает с адресом получателя в <em>Р</em>. Т.е., к пакетам определённого FEC-класса относятся только те пакеты, у которых адрес (часть адреса) совпадает префиксом адреса, указанного в маршрутной таблице <em>R</em>. В данном случае FEC-класс может идентифицироваться префиксом адреса.</p><p>Следует заметить, что пакет <em>P</em> может быть отнесён в FEC-классу <em>F</em>, а FEC-класс <em>F</em> может быть идентифицирован префиксом адреса <em>X</em>, даже если адрес получателя в пакете <em>P</em> не совпадает с <em>X</em>.</p><h4 id="p4.1.2">4.1.2. Распределение (доставка) маркеров для префиксов адресов</h4><h5>4.1.2.1. Взаимодействующие стороны при распределении маркеров для префиксов адресов</h5><p>LSR-маршрутизаторы <em>R</em><sub>1</sub> и <em>R</em><sub>2</sub> рассматриваются как взаимодействующие стороны при распределении маркеров для префикса адреса <em>X</em> тогда и только тога, когда выполняется одно из следующий условий:</p><ol class="lia"><li><p>Маршрут от <em>R</em><sub>1</sub> до <em>X</em> является маршрутом, который стал известен, в частности, при проведения процедуры информационного обмена с использованием IGP-протокола (Interior Gateway Protocol), а <em>R</em><sub>2</sub> является соседом <em>R</em><sub>1</sub> и также использует данный протокол при взаимодействии с тем же сетевым объектом;</p></li><li><p>Маршрут от <em>R</em><sub>1</sub> до <em>X</em> является маршрутом, который стал известен после проведения процедуры информационного обмена при реализации некоторого алгоритма маршрутизации <em>A</em><sub>1</sub>, и этот маршрут был перенаправлен к иному сетевому объекту, использующего другой алгоритм маршрутизации <em>A</em><sub>2</sub>, а <em>R</em><sub>2</sub> является соседом <em>R</em><sub>1</sub> и также использует алгоритм маршрутизации <em>A</em><sub>2</sub>;</p></li><li><p><em>R</em><sub>1</sub> является оконечной точной приёма LSP-туннеля, который располагается внутри другого LSP-маршрута, а <em>R</em><sub>2</sub> является крайней точкой передачи этого же туннеля, и <em>R</em><sub>1</sub> и <em>R</em><sub>2</sub> являются участниками единого информационного взаимодействия с использованием IGP-протокола, а также входят в один сетевой IGP-сегмент (если конечно такой сегмент существует), и маршрут от <em>R</em><sub>1</sub> до <em>X</em> стал известен с помощью проведения процедуры информационного обмена с использованием IGP-протокола или этот маршрут был перенаправлен <em>R</em><sub>1</sub> в указанный сетевой IGP-сегмент;</p></li><li><p>Маршрут от <em>R</em><sub>1</sub> до <em>X</em> является маршрутом, который стал известен после проведения процедуры информационного обмена с использованием BGP-протокола (Border Gateway Protocol), а <em>R</em><sub>2</sub> взаимодействует с <em>R</em><sub>1</sub> на основе данного протокола.</p></li></ol><p>В целом, эти правила гарантируют, что, если маршрут до объекта, имеющего некоторый префикс адреса, был установлен с помощью процедуры информационного обмена на основе IGP-протокола, то взаимодействующие стороны при распределении маркеров для данного префикса адреса являются соседями с точки зрения IGP-протокола. Если же маршрут до объекта, имеющего некоторый префикс адреса, был установлен с помощью процедуры информационного обмена на основе BGP-протокола, то взаимодействующие стороны при распределении маркеров для данного префикса адреса являются соседями с точки зрения BGP-протокола. В других же случаях LSP-туннелирования крайние точки туннеля являются взаимодействующими сторонами при распределении маркеров.</p><h5>4.1.2.2. Распределение (доставка) маркеров</h5><p>В целях обеспечения функционирования MPLS-коммутации при доставке IP-пакетов по маршруту с поузловой маршрутизацией до сетевого объекта, имеющего какой-либо префикс адреса, каждый LSR-маршрутизатор обязан:</p><ol class="lia"><li><p>Прикреплять один или несколько маркеров к префиксу каждого адреса, который представлен в его маршрутной таблице;</p></li><li><p>Для префикса <em>X</em> каждого такого адреса, использовать LDP-протокол для доставки каждой взаимодействующей с ним при распределении маркеров стороне привязки маркера к <em>X</em>;</p></li></ol><p>Кроме того, имеет место случай, когда LSR-маршрутизатор обязан доставлять привязку маркера для префикса адреса, даже если отсутствует LSR-маршрутизатор, который «привязал» этот маркер к данному префиксу адреса:</p><ol class="lia" start="3"><li><p>Если <em>R</em><sub>1</sub> применяет BGP-протокол для установления маршрута до <em>X</em>, именуя некоторый другой LSR-маршрутизатор <em>R</em><sub>2</sub> как следующий ретрансляционный BGP-участок до <em>X</em>, и если <em>R</em><sub>1</sub> знает, что <em>R</em><sub>2</sub> «привязал» маркер <em>L</em> к <em>X</em>, то <em>R</em><sub>1</sub> обязан доставить связку между <em>L</em> и <em>X</em> каждой взаимодействующей с ним на основе BGP-протокола стороне, через которую проложен данный маршрут.</p></li></ol><p>Эти правила гарантируют то, что маркеры, соответствующие префиксам адресов, которые, в свою очередь, соответствуют BGP-маршрутам, будут доставлены IGP-соседям тогда и только тогда, когда BGP-маршруты будут доставлены в зону действия IGP-протокола. В противном случае, маркеры, привязанные к BGP-маршрутам, будут доставлены только другим активным BGP-модулям (серверам).</p><p>Эти правила предназначены только для определения, какие привязки маркеров и каким другим LSR-маршрутизаторам должны быть доставлены конкретным LSR-маршрутизатором.</p><h4>4.1.3. Использование маршрута с поузловой маршрутизацией в качестве LSP-маршрута</h4><p>Если маршрут с поузловой маршрутизацией, по которому должен проследовать IP-пакет <em>P</em>, представляет собой &lt;<em>R</em><sub>1</sub>, ..., <em>R<sub>n</sub></em>&gt;, то &lt;<em>R</em><sub>1</sub>, ..., <em>R<sub>n</sub></em>&gt; может быть LSP-маршрутом до тех пор, пока:</p><ol class="lia"><li><p>Существует одиночный префикс адреса <em>X</em>, причём такой, что для всех <em>i</em>, 1 ≤ <em>i</em> &lt; <em>n</em>, <em>X</em> является самым длинным совпадением (с точки зрения длины в битах) при сравнении значения префикса адреса из маршрутной таблицы с IP-адресом получателя из заголовка IP-пакета;</p></li><li><p>Для всех <em>i</em>, 1 &lt; <em>i</em> &lt; <em>n</em>, <em>R</em><sub>1</sub> присвоил маркер к <em>X</em> и доставил этот маркер <em>R</em><sub><em>i</em>-1</sub>.</p></li></ol><p>Следует заметить, что LSP-маршрут, по которому доставляются IP-пакеты, может быть продлён только до тех пор, пока он «не столкнётся» с маршрутизатором, маршрутные таблицы которого содержат префикс адреса, имеющий более длинное совпадение с IP-адресом получателя из заголовка IP-пакета. В таком случае, LSP-маршрут должен закончится, и затем снова должна быть запущена процедура поиска максимально длинного совпадения (по определённому алгоритму).</p><p>Предположим, например, что IP-пакет <em>P</em> с IP-адресом получателя «10.2.153.178» необходимо доставить от <em>R</em><sub>1</sub> до <em>R</em><sub>2</sub> и до <em>R</em><sub>3</sub>. Также предположим, что <em>R</em><sub>2</sub> извещает <em>R</em><sub>1</sub> о префиксе адреса «10.2/16», а <em>R</em><sub>3</sub> извещает <em>R</em><sub>2</sub> о «10.2.153/23», «10.2.154/23» и «10.2/16». Т.е., <em>R</em><sub>2</sub> извещает <em>R</em><sub>1</sub> об «агрегированном маршруте». В такой ситуации транслируемый IP-пакет <em>P</em> может коммутироваться на основе маркера, но до тех пор, пока он не достигнет <em>R</em><sub>2</sub>, а так как <em>R</em><sub>2</sub> осуществил агрегирование маршрута, то он обязан запустить процедуру поиска максимально длинного совпадения (по определённому алгоритму) с целью определения FEC-класса <em>P</em>.</p><h4>4.1.4. Выход LSP-маршрута и уполномоченный узел выхода LSP-маршрута</h4><p>LSR-маршрутизатор <em>R</em> считается «выходом LSP-маршрута» (LSP egress) для префикса адреса <em>X</em> тогда и только тогда, когда выполняется одно из следующих условий:</p><ol class="lia"><li><p><em>R</em> имеет IP-адрес <em>Y</em>, причем такой, что <em>X</em>, являясь префиксом адреса, указанным в маршрутной таблице <em>R</em>, максимально совпадает (с точки зрения длины в битах) с <em>Y</em>;</p></li><li><p><em>R</em> содержит в своей маршрутной таблице один или несколько префиксов адресов <em>Y</em>, причём таких, что <em>X</em> является характерной начальной субпоследовательностью <em>Y</em>, но, в то же время, предшествующие ретрансляционные участки LSP-маршрута до <em>R</em> и относительно <em>X</em> не содержат каких-либо префиксов адресов <em>Y</em>. Т.е., <em>R</em> является «узлом (точкой) деагрегации» (deaggregation point) по отношению к префиксу адреса <em>X</em>.</p></li></ol><p>LSR-маршрутизатор <em>R</em><sub>1</sub> считается «уполномоченным узлом выхода <em>R</em><sub>1</sub>» (LSP proxy egress) для префикса адреса <em>X</em>, если:</p><ol class="lia"><li><p>Следующим ретрансляционным участком от <em>R</em><sub>1</sub> относительно <em>X</em> является <em>R</em><sub>2</sub>, а <em>R</em><sub>1</sub> и <em>R</em><sub>2</sub> не являются взаимодействующими сторонами при распределении (доставке) маркеров, что касается <em>X</em> (возможно из-за того, что <em>R</em><sub>2</sub> не поддерживает MPLS-коммутацию);</p></li><li><p><em>R</em><sub>1</sub> был настроен в качестве уполномоченного узла выхода LSP-маршрута относительно <em>X</em>.</p></li></ol><p>Данное описание LSP-маршрута позволяет уполномоченному узлу выхода LSP-маршрута не поддерживать MPLS-коммутацию. В таком случае предпоследний узел LSP-маршрута является уполномоченным узлом выхода LSP-маршрута.</p><h4>4.1.5. Неявно выраженный нулевой маркер</h4><p>Такой маркер (implicit NULL label) представляет собой маркер со специальным семантическим содержанием, который может быть привязан LSR-маршрутизатором к префиксу адреса. Если LSR-маршрутизатор <em>R<sub>u</sub></em>, после проведённой им ILM-процедуры, установит, что помеченный IP-пакет <em>P</em> должен быть доставлен по следующему ретрансляционному участку до <em>R<sub>d</sub></em>, а последний распространил информацию о привязке неявно выраженного нулевого маркера к соответствующему префиксу адреса, то вместо перемещения маркера на самый верх набора маркеров, <em>R<sub>u</sub></em> удаляет набор маркеров и после этого транслирует скорректированный IP-пакет <em>R<sub>d</sub></em>.</p><p>LSR-маршрутизатор <em>R<sub>d</sub></em> передаёт информацию о привязке не явно выраженного нулевого маркера к префиксу адреса <em>X</em> LSR-маршрутизатору <em>R<sub>u</sub></em> тогда и только тогда, когда:</p><ol class="lia"><li><p>Правила, представленные в параграфе <a href="print#p4.1.2" title="параграф 4.1.2 - Распределение (доставка) маркеров для префиксов адресов">4.1.2</a>, указывают на то, что <em>R<sub>d</sub></em> передаёт <em>R<sub>u</sub></em> информацию о привязке маркера к <em>X</em>;</p></li><li><p><em>R<sub>d</sub></em> знает, что <em>R<sub>u</sub></em> может обработать не явно выраженный нулевой маркер (т.е., что он может удалить («вытолкнуть») набор маркеров);</p></li><li><p><em>R<sub>d</sub></em> является выходом LSP-маршрута (а не уполномоченным узлом выхода LSP-маршрута) по отношению к <em>X</em>.</p></li></ol><p>Сказанное выше означает, что предпоследний LSR-маршрутизатор на LSP-маршруте будет удалять набор маркеров. Такой подход вполне приемлем по следующим соображениям. Если выходом LSP-маршрута является выход MPLS-соединения для <em>X</em>, и если предпоследний LSR-маршрутизатор не удаляет набор маркеров, то на выходе LSP-маршрута надо будет найти маркер, удалить набор маркеров, а затем найти следующий маркер (или найти адрес третьего (сетевого) уровня, если, конечно, больше маркеров не представлено). Наличие предпоследнего LSR-маршрутизатора, который «выталкивает» набор маркеров, избавляет узел на выходе LSP-маршрута от процедуры поиска двух маркеров, необходимых для принятия решения о последующей ретрансляции IP-пакета.</p><p>Тем не менее, если предпоследний LSR-маршрутизатор является ATM-коммутатором, то он может быть не способен удалить набор маркеров. Следовательно, данные о привязке не явно выраженного нулевого маркера могут доставляться только LSR-маршрутизаторам, которые могут реализовать такую функцию.</p><p>Если предпоследний LSR-маршрутизатор на LSP-маршруте по отношению к префиксу адреса <em>X</em> является уполномоченным узлом выхода LSP-маршрута, то он функционирует только так, как если бы узел выхода LSP-маршрута распространил данные о привязке не явно выраженного нулевого маркера к <em>X</em>.</p><h4>4.1.6. Дополнительная функция: назначение целевого маркера выхода</h4><p>Существуют ситуации, когда входной узел LSP-маршрута <em>R<sub>i</sub></em> (вход LSP-маршрута) знает, что все IP-пакеты, причём нескольких различных FEC-классов, должны следовать по одному и тому же LSP-маршруту, который прерывается на <em>R<sub>e</sub></em>, являющимся выходом LSP-маршрута. В таком случае, соответствующая процедура маршрутизации может быть реализована на основе применения только одного маркера, но используемого для всех различных FEC-классов. Т.е., нет необходимости иметь индивидуальный маркер для каждого FEC-класса. Когда (и только когда) выполняются следующие условия:</p><ol class="lia"><li>Сам адрес LSR-маршрутизатора <em>R<sub>e</sub></em> представлен в маршрутной таблице в качестве «главного маршрута» (host route);</li><li><p>Существует некоторый способ, с помощью которого <em>R<sub>i</sub></em> может определить, что <em>R<sub>e</sub></em> является выходом LSP-маршрута для всех IP-пакетов, относящихся к некоторой совокупности FEC-классов.</p></li></ol><p>Тогда <em>R<sub>i</sub></em> может установить привязку одного маркера ко всей совокупности FEC-классов. Такая процедура называется «назначение целевого маркера выхода» (egress-targeted label assignment).</p><p>Возникает справедливый вопрос: «А как LSR-маршрутизатор <em>R<sub>i</sub></em> может определить, что <em>R<sub>e</sub></em> является выходом LSP-маршрута для всех IP-пакетов соответствующего FEC-класса?». Существует несколько возможных способов, а именно:</p><ul class="list lia"><li><p>Если сеть функционирует с использованием алгоритма маршрутизации на основе состояния линий (каналов) связи, и все узлы этой сетевой зоны поддерживают MPLS-коммутацию, то алгоритм маршрутизации предоставляет <em>R<sub>i</sub></em> достаточно информации для определения маршрутизаторов, через которые IP-пакеты, относящиеся к определённому FEC-классу, должны покидать сетевой маршрутизационный сегмент (или зону).</p></li><li><p>Если функционирует с использованием BGP-протокола, то <em>R<sub>i</sub></em> имеет возможность определить, что IP-пакеты, относящиеся к определённому FEC-классу, должны покинуть сеть через конкретный маршрутизатор, который является началом следующего ретрансляционного участка с точки зрения BGP-протокола (BGP next hop) для данного FEC-класса.</p></li><li><p>Если допускается применение LDP-протокола для доставки информации о тех префиксах адресов, которые «закреплены» за конкретными выходными LSR-маршрутизаторами. Этот метод имеет преимущество, так как не зависит от наличия протоколов маршрутизации на основе состояния линий (каналов) связи.</p></li></ul><p>Если используется процедура назначения целевого маркера выхода, то число маркеров, которое необходимо для обеспечения доставки через сеть, может быть на много снижено. Такая процедура может быть вполне востребована, если в MPLS-системе используется устаревшее коммутационное оборудование, которое способно поддерживать только ограниченное число маркеров.</p><p>Одним из возможных способов сетевой реализации назначения целевого маркера выхода может быть настройка на использование этой процедуры в режиме «по-умолчанию» (by default), но одновременно с этим следует настроить соответствующие LSR-маршрутизаторы так, чтобы они не использовали указанную процедуру по отношению к одному или нескольким префиксам адресов, которые соответствуют выходу LSP-маршрута. В таких случаях существует следующее правило:</p><ul class="list lia"><li><p>Если некоторый LSR-маршрутизатор не является выходным узлом LSP-маршрута по отношению к некоторой совокупности префиксов адресов, то он должен назначать маркеры префиксам адресов тем же самым способом, как если бы он это делал в случае следующего ретрансляционного участка LSP-маршрута по отношению к этим же префиксам адресов. Т.е., предположим, что <em>R<sub>d</sub></em> является следующим ретрансляционным участком LSP-маршрута для <em>R<sub>u</sub></em> по отношению к префиксам адреса <em>X</em><sub>1</sub> и <em>X</em><sub>2</sub>. Если <em>R<sub>d</sub></em> назначил один и тот же маркер префиксам адреса <em>X</em><sub>1</sub> и <em>X</em><sub>2</sub>, то <em>R<sub>u</sub></em> должен сделать также. Если <em>R<sub>d</sub></em> назначил разные маркеры <em>X</em><sub>1</sub> и <em>X</em><sub>2</sub>, то <em>R<sub>u</sub></em> должен сделать также.</p></li></ul><p>Например, предположим, что «некто» хочет настроить процедуру назначения целевого маркера выхода в режиме «по-умолчанию», но одновременно с этим назначить индивидуальные маркеры тем префиксам адресов, относительно которых существует несколько возможных выходов LSP-маршрута (т.е., для тех префиксов адресов, которые идентифицируют многоадресные интерфейсы сетевых узлов). В таком случае можно настроить все LSR-маршрутизаторы на режим использования процедуры назначения целевого маркера выхода, а после этого настроить некоторую часть LSR-маршрутизаторов на режим назначения индивидуальных маркеров тем префиксам адресов, которые идентифицируют многоадресные интерфейсы. Для некоторого префикса адреса <em>X</em>, идентифицирующего многоадресный интерфейс, рассмотренная выше настройка может понадобиться только в тех LSR-маршрутизаторах, которые, по отношению к <em>X</em>, являются, либо выходными узлами LSP-маршрута, либо уполномоченными узлами выхода LSP-маршрута.</p><p>Очень важно отметить, что если <em>R<sub>u</sub></em> и <em>R<sub>d</sub></em> являются соседними LSR-маршрутизаторами в LSP-маршруте по отношению к <em>X</em><sub>1</sub> и <em>X</em><sub>2</sub>, и <em>R<sub>u</sub></em> присваивает индивидуальные маркеры <em>X</em><sub>1</sub> и <em>X</em><sub>2</sub>, в то время как <em>R<sub>d</sub></em> присваивает только один маркер обоим этим префиксам адресов, то доставка IP-пакетов будет по-прежнему корректной. Это означает лишь только то, что <em>R<sub>d</sub></em> будет отображать входящие маркеры в один и тот же исходящий маркер, т.е. самая заурядная ситуация.</p><p>Аналогично, если <em>R<sub>d</sub></em> присваивает индивидуальные маркеры <em>X</em><sub>1</sub> и <em>X</em><sub>2</sub>, а <em>R<sub>u</sub></em> присваивает им обоим только один маркер, соответствующий адресу их выходного узла LSP-маршрута или уполномоченного узла выхода LSP-маршрута, то доставка IP-пакетов будет по-прежнему корректной. <em>R<sub>u</sub></em> будет только отображать входящий маркер в другой маркер, который <em>R<sub>d</sub></em> присвоил адресу этому выходному узлу LSP-маршрута.</p><h3 id="p4.2">4.2. MPLS-архитектура и точно настраиваемый LSP-маршруты</h3><p>Существует несколько причин, по которым может быть не приемлемо использование явной маршрутизации вместо поузловой маршрутизации. Например, явная маршрутизация позволяет настраивать маршруты, основываясь на административных политиках, а также — маршруты, которые являются тщательно проложенными LSP-маршрутами, обеспечивающими регулирование трафика (RFC-2702).</p><h4>4.2.1. Точно настраиваемые LSP-туннели</h4><p>В некоторых ситуациях сетевые администраторы могут изъявить желание, чтобы определённые классы трафика доставлялись по конкретным предварительно установленным маршрутам, и при этом такие маршруты будут отличаться от маршрутов с поузловой маршрутизацией, по которым обычно мог бы транслироваться трафик. Это может быть сделано исходя из политики маршрутизации или политики регулирования трафика. Явный маршрут может быть настроен вручную, или может определять динамически, исходя из конкретных условий, например, маршрутизация на основе имеющихся ограничений.</p><p>В рамках MPLS-архитектуры это легко выполнимо с помощью точно настраиваемых LSP-туннелей. Всё, что необходимо для этого, следующее:</p><ol class="lia"><li><p>Средства селектирования IP-пакетов, которые должны быть доставлены по точно настраиваемому LSP-туннелю;</p></li><li><p>Средства установки точно настраиваемого LSP-туннеля;</p></li><li><p>Средства, гарантирующие, что IP-пакеты, транслируемые по туннелю, не попадут на петлевой маршрут, т.е. из крайней точки приёма — обратно в крайнюю точку передачи.</p></li></ol><p>Если крайняя точка передачи в туннеле «желает» направить помеченный IP-пакет в туннель, она обязана, во-первых, заменить значение самого верхнего маркера в наборе маркеров на значение маркера, которое было передано ей крайней точкой приёма в туннеле. Затем она обязана вставить маркер, который соответствует её месту в туннеле, и который был ей передан с противоположной точки следующего ретрансляционного участка, входящего в туннель. Чтобы реализовать всё сказанное выше крайние точки туннеля должны быть непосредственно взаимодействующими сторонами при проведении процедуры доставки (распределения) маркеров. Данные о привязках маркеров, которые им необходимы для обмена, не входят в круг интересов LSR-маршрутизаторов, расположенных вдоль туннеля.</p><h3 id="p4.3">4.3. Наборы маркеров и процедура неявного информационного обмена маркерами</h3><p>Предположим, что некоторый LSR-маршрутизатор <em>R<sub>e</sub></em> является уполномоченным узлом выхода LSP-маршрута по отношению к 10 префиксам адресов, и он связан с каждым префиксом адреса через индивидуальный интерфейс.</p><p>С одной стороны, можно присвоить одиночный маркер всем 10 префиксам адресов. После этого <em>R<sub>e</sub></em> стал бы выходным узлом LSP-маршрута. А это гарантирует, что IP-пакеты с любым из этих 10 префиксов адресов будут доставлены в <em>R<sub>e</sub></em>. Тем не менее, <em>R<sub>e</sub></em> мог бы затем проанализировать адрес сетевого уровня каждого такого IP-пакета с целью выбора подходящего интерфейса для передачи через него IP-пакета.</p><p>С другой стороны, можно присвоить индивидуальный маркер каждому интерфейсу. После этого <em>R<sub>e</sub></em> стал бы уполномоченным узлом выхода LSP-маршрута по отношению к 10 префиксам адресов. А это устраняет необходимость просмотра адресов сетевого уровня в целях последующей доставки IP-пакетов. Тем не менее, это может привести к использованию большого числа маркеров.</p><p>Альтернативой всему сказанному выше может быть привязка всех 10 префиксов адресов к одному и тому же маркеру 1-го уровня (который также связан с адресом самого LSR-маршрутизатора), а затем — привязка каждого префикса адреса к индивидуальному маркеру 2-го уровня. Маркер 2-го уровня можно рассматривать как атрибут привязки маркера 1-го уровня, который именуется «атрибутом набора (маркеров)» (stack attribute). Для таких случаев существуют следующие правила:</p><ul class="list lia"><li><p>Когда LSR-маршрутизатор <em>R<sub>u</sub></em> в начальной стадии помечает всё ещё не помеченный IP-пакет, и если максимально длинная битовая последовательность, совпавшая с адресом получателя заголовка IP-пакета, является <em>X</em>, и если противоположным узлом следующего ретрансляционного участка LSP-маршрута для <em>R<sub>u</sub></em> по отношению к <em>X</em> является <em>R<sub>d</sub></em>, и если <em>R<sub>d</sub></em> передал <em>R<sub>u</sub></em> данные о привязке маркера <em>L</em><sub>1</sub> к <em>X</em> и атрибуте набора маркеров <em>L</em><sub>2</sub>, тогда:</p><ol class="lia"><li><p><em>R<sub>u</sub></em> обязан вставить <em>L</em><sub>2</sub>, а затем <em>L</em><sub>1</sub> в набор маркеров IP-пакета, и после этого ретранслировать IP-пакет <em>R<sub>d</sub></em>.</p></li><li><p>Когда <em>R<sub>u</sub></em> распространяет информацию о привязках маркера к <em>X</em> среди взаимодействующих с ним сторон по доставке маркеров, он обязан включить в эти данные <em>L</em><sub>2</sub>, как атрибут набора маркеров.</p></li><li><p>Всякий раз, когда атрибут набора маркеров изменяется (возможно, в результате изменения на следующем ретрансляционном участке LSP-маршрута для <em>R<sub>u</sub></em> по отношению к <em>X</em>), <em>R<sub>u</sub></em> обязан распространить информацию о новом атрибуте набора маркеров.</p></li></ol></li></ul><p class="note">Примечание. Несмотря на то, что значение маркера, привязанного к <em>X</em>, может отличаться на каждом ретрансляционном участке по всему LSP-маршруту, значение атрибута набора маркеров остаётся неизменным и устанавливается уполномоченным узлом выхода LSP-маршрута.</p><p>Таким образом, уполномоченный узел выхода LSP-маршрута по отношению к <em>X</em> становится взаимодействующей стороной процедуры неявного информационного обмена маркерами с каждым другим LSR-маршрутизатором, входящим в одну маршрутизационную зону или сетевой сегмент. В таком случае, процедуры неявного информационного обмена маркерами могут стать слишком громоздкими, так как число взаимодействующих сторон процедур неявного информационного обмена маркерами может стать слишком большим.</p><h3 id="p4.4">4.4. MPLS-архитектура и многонаправленная маршрутизация</h3><p>Если LSR-маршрутизатор «предоставляет» несколько маршрутов для некоторого потока, то он может присвоить несколько маркеров к потоку, т.е. по одному на каждый маршрут. Соответственно, получение от определённого соседа привязки второго маркера к некоторому префиксу адреса должно рассматриваться следующим образом: тот или иной маркер может использоваться для представления этого префикса адреса.</p><p>Если для некоторого префикса адреса установлено несколько привязок маркеров, то они могут иметь индивидуальные атрибуты.</p><h3 id="p4.5">4.5. Сходящиеся деревья из LSP-маршрутов</h3><p>Рассмотрим случай доставки двух IP-пакетов <em>P</em><sub>1</sub> и <em>P</em><sub>2</sub>, каждый из которых имеет адрес получателя, а в соответствующем сегменте маршрутизации эти адреса имеют максимально длинную одинаковую битовую последовательность, образующую префикс адреса <em>X</em>. Предположим, что для <em>P</em><sub>1</sub> маршрутом с поузловой маршрутизацией является &lt;<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, <em>R</em><sub>3</sub>&gt;, а для <em>P</em><sub>2</sub> — &lt;<em>R</em><sub>4</sub>, <em>R</em><sub>2</sub>, <em>R</em><sub>3</sub>&gt;. Теперь предположим, что <em>R</em><sub>3</sub> привязывает маркер <em>L</em><sub>3</sub> к <em>X</em>, и сообщает об этой привязке <em>R</em><sub>2</sub>. <em>R</em><sub>2</sub> привязывает маркер <em>L</em><sub>2</sub> к <em>X</em>, и сообщает об этой привязке <em>R</em><sub>1</sub> и <em>R</em><sub>4</sub>. Когда <em>R</em><sub>2</sub> получает IP-пакет <em>P</em><sub>1</sub>, его входящим маркером будет <em>L</em><sub>2</sub>. <em>R</em><sub>2</sub> заменит <em>L</em><sub>2</sub> на <em>L</em><sub>3</sub> и отправит <em>P</em><sub>1</sub> в <em>R</em><sub>3</sub>. Когда <em>R</em><sub>2</sub> получает IP-пакет <em>P</em><sub>2</sub>, его входящим маркером снова будет <em>L</em><sub>2</sub>. И <em>R</em><sub>2</sub> опять заменит <em>L</em><sub>2</sub> на <em>L</em><sub>3</sub> и отправит <em>P</em><sub>2</sub> в <em>R</em><sub>3</sub>.</p><p>Заметим, что когда <em>P</em><sub>1</sub> и <em>P</em><sub>2</sub> транслируются от <em>R</em><sub>2</sub> в <em>R</em><sub>3</sub>, то они содержат один и тот же маркер, причём так долго, насколько продолжительна MPLS-система, и поэтому их невозможно различить. Таким образом, вместо анализа двух индивидуальных LSP-маршрутов &lt;<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, <em>R</em><sub>3</sub>&gt; и &lt;<em>R</em><sub>4</sub>, <em>R</em><sub>2</sub>, <em>R</em><sub>3</sub>&gt; можно рассмотреть одно «сходящееся дерево из LSP-маршрутов (сходящийся граф)» (multipoint-to-point LSP tree), и обозначить его как &lt;{<em>R</em><sub>1</sub>, <em>R</em><sub>4</sub>}, <em>R</em><sub>2</sub>, <em>R</em><sub>3</sub>&gt;.</p><p>Такой подход создаёт определённые трудности, особенно при использовании стандартных ATM-коммутаторов в качестве LSR-маршрутизаторов. Так как обычные ATM-коммутаторы на поддерживают сходящиеся виртуальные соединения (multipoint-to-point connections), должны существовать процедуры, которые гарантируют, что каждый LSP-маршрут представляет собой сквозное виртуальной соединение (point-to-point VC). Тем не менее, если используются ATM-коммутаторы, которые поддерживают сходящиеся виртуальные соединения, то LSP-маршруты могут быть более эффективно реализованы как сходящиеся виртуальные соединения. С другой стороны, если можно использовать многоузловое кодирование коммутируемого виртуального маршрута (параграф <a href="print#p3.25.2" title="параграф 3.25.2 - АТМ-коммутаторы как LSR-маршрутизаторы">3.25.2</a>, SVP multipoint encoding), то LSP-маршруты могут быть реализованы как сходящиеся коммутируемые виртуальные маршруты (multipoint-to-point SVP).</p><h3 id="p4.6">4.6. Формирование LSP-туннелей между граничными BGP-маршрутизаторами</h3><p>Рассмотрим случай функционирования автономной системы <em>A</em> (autonomous system), которая транслирует трафик между другими автономными системами. Автономная система <em>A</em> будет несколько граничных BGP-маршрутизаторов и совокупность BGP-соединений между ними, а на основе этих BGP-соединений формируются BGP-маршруты. Во многих подобных ситуациях весьма нежелательно прокладывать BGP-маршруты до маршрутизаторов, которые не являются граничными BGP-маршрутизаторами. Если всё-таки это можно избежать, то объём данных о распределённых маршрутах, хранящихся в памяти таких маршрутизаторов, значительно снижается. Тем не менее, должны предусматриваться средства, которые бы гарантировали, что транзитный трафик будет доставлен от одного граничного маршрутизатора к другому граничному маршрутизатору с помощью внутренних маршрутизаторов.</p><p>Это легко осуществимо посредством LSP-туннелей. Предположим, что BGP-маршруты проложены только до граничных BGP-маршрутизаторов, а не до внутренних маршрутизаторов, которые расположены вдоль маршрута с поузловой маршрутизацией от одного граничного маршрутизатора до другого граничного маршрутизатора. Тогда туннели могут использоваться следующим образом:</p><ol class="lia"><li><p>Каждый граничный BGP-маршрутизатор транслирует (каждому другому граничному BGP-маршрутизатору в рамках одной автономной система) маркер для каждого префикса адреса, которые он передал каждому такому маршрутизатору с помощью BGP-протокола;</p></li><li><p>IGP-протокол в интересах всей автономной системы устанавливает главный маршрут до каждого граничного BGP-маршрутизатора. Каждый внутренний маршрутизатор транслирует свои маркеры по этим главным маршрутам каждому своему IGP-соседу;</p></li><li><p>Предположим, что:</p><ol class="lat lia"><li><p>граничный BGP-маршрутизатор <em>B</em><sub>1</sub> получает непомеченный IP-пакет <em>P</em>;</p></li><li><p>префикс адреса <em>X</em> в маршрутной таблице <em>B</em><sub>1</sub> является максимально длинной последовательностью, совпадающей с адресом получателя <em>P</em>;</p></li><li><p>маршрут до <em>X</em> является BGP-маршрутом;</p></li><li><p>следующий ретрансляционный участок BGP-маршрута по отношению к <em>X</em> является <em>B</em><sub>2</sub>;</p></li><li><p><em>B</em><sub>2</sub> «привязал» маркер <em>L</em><sub>1</sub> к <em>X</em>, а также передал <em>B</em><sub>1</sub> данные об этой привязке;</p></li><li><p>следующий ретрансляционный участок IGP-маршрута по отношению к адресу <em>B</em><sub>2</sub> является <em>I</em><sub>1</sub>;</p></li><li><p>адрес <em>B</em><sub>2</sub> указан в IGP-маршрутных таблицах <em>B</em><sub>1</sub> и <em>I</em><sub>1</sub> как главный маршрут;</p></li><li><p><em>I</em><sub>1</sub> «привязал» маркер <em>L</em><sub>2</sub> к адресу <em>B</em><sub>2</sub>, а также передал <em>B</em><sub>1</sub> данные об этой привязке.</p></li></ol><p>Затем, перед отправкой IP-пакета <em>P</em> в <em>I</em><sub>1</sub>, <em>B</em><sub>1</sub> обязан сформировать набор маркеров для <em>P</em>, и после этого вставить поочередно вначале маркер <em>L</em><sub>1</sub> и потом маркер <em>L</em><sub>2</sub>;</p></li><li><p>Предположим, что граничный BGP-маршрутизатор <em>B</em><sub>1</sub> получил маркированный IP-пакет <em>P</em>, в котором маркер верхнего уровня в наборе маркеров соответствует префиксу адреса <em>X</em>, и который следует по BGP-маршруту, и что выполняются все условия 3.b), 3.c), 3.d), и 3.e). Затем, перед отправкой IP-пакета <em>P</em> в <em>I</em><sub>1</sub>, <em>B</em><sub>1</sub> обязан заменить самый верхний маркер в наборе маркеров на <em>L</em><sub>1</sub> и потом вставить маркер <em>L</em><sub>2</sub>.</p></li></ol><p>После всех описанных процедур данный IP-пакет <em>P</em> следует по LSP-маршруту 1-го уровня, все узлы которого являются граничными BGP-маршрутизаторами, а между каждой парой граничных BGP-маршрутизаторов, расположенных на LSP-маршруте 1-го уровня, этот IP-пакет <em>P</em> следует по LSP-маршруту 2-го уровня.</p><p>Рассмотренные процедуры позволяют эффективно сформировать LSP-туннель с поузловой маршрутизацией между граничными BGP-маршрутизаторами. Так как граничные BGP-маршрутизаторы обмениваются данными о привязках маркеров к префиксам адресов, которые остаются неизвестными при IGP-маршрутизации, BGP-маршрутизаторы должны переходить в режим прямого двустороннего информационного обмена маркерами, причём каждый с каждым.</p><p>Иногда бывает, что можно сформировать LSP-туннели с поузловой маршрутизацией между двумя граничными BGP-маршрутизаторами, даже если они не входят в одну и ту же автономную систему. Предположим, например, что <em>B</em><sub>1</sub> и <em>B</em><sub>2</sub> принадлежат одной автономной системе <em>AS</em><sub>1</sub>. Также считаем, что <em>B</em><sub>3</sub> является EBGP-соседом <em>B</em><sub>2</sub>. И последнее, полагаем, что <em>B</em><sub>2</sub> и <em>B</em><sub>3</sub> входят в некоторую сеть, которая является общей для обеих автономных систем (так называемая демилитаризованная зона, demilitarized zone). В этом случае LSP-туннель может быть установлен между <em>B</em><sub>1</sub> и <em>B</em><sub>3</sub> напрямую следующим образом:</p><ul class="list lia"><li><p><em>B</em><sub>3</sub> прокладывает маршруты до <em>B</em><sub>2</sub> (используя EBGP-протокол), и дополнительно назначает маркеры префиксам адресов;</p></li><li><p><em>B</em><sub>2</sub> продлевает эти маршруты до <em>B</em><sub>1</sub> (используя IBGP-протокол), указывая на то, что следующим ретрансляционным участком для каждого такого BGP-маршрута является <em>B</em><sub>3</sub>. Если <em>B</em><sub>3</sub> присваивает маркеры префиксам адресов, то <em>B</em><sub>2</sub> транслирует дальше эти маркеры до <em>B</em><sub>1</sub> без изменений;</p></li><li><p><em>AS</em><sub>1</sub>, реализующей IGP-протокол, известен главный маршрут до <em>B</em><sub>3</sub>.</p></li></ul><h3 id="p4.7">4.7. Другие варианты применения LSP-туннелей с поузловой маршрутизацией</h3><p>Применение LSP-туннелей с поузловой маршрутизацией не ограничивается только туннелями между следующими ретрансляционными участками BGP-маршрутов. Любой другой ситуацией, в которой можно использовать туннель с повторным обрамлением IP-пакетов иным способом, является ситуация в которой приемлемо использование LSP-туннелей с поузловой маршрутизацией. Вместо повторного обрамления IP-пакета с одновременным формированием нового заголовка, содержащим адрес получателя, являющийся крайней точкой приема туннеля, в набор маркеров IP-пакета вставляется маркер, соответствующий префиксу адреса, который максимально совпадает (побитно) с адресом крайней точки приема туннеля. IP-пакет, который был направлен в туннель, уже мог быть предварительно помечен или нет.</p><p>Если в крайней точке передачи туннеля необходимо отправить помеченный IP-пакет по туннелю, то следует, во-первых, заменить значение самого верхнего маркера в наборе маркеров на полученное в этой точке значение маркера, которое было передано крайней точкой приёма туннеля. Далее, в крайней точке передачи туннеля необходимо вставить маркер, соответствующий самому туннелю, и который был передан противоположной стороной следующего ретрансляционного участка туннеля. Чтобы осуществить сказанное выше, крайние точки туннеля должны быть взаимодействующими сторонами открытой процедуры обмена маркерами. Данные о привязках маркеров, которыми должны обменяться крайние точки туннеля, не входят сферу интересов LSR-маршрутизаторов, которые расположены по маршруту туннеля.</p><h3 id="p4.8">4.8. MPLS-архитектура и системы с групповой адресацией</h3><p>Маршрутизация с групповой адресацией основывается на формировании многоадресных «деревьев» (trees) или графов. Дерево (граф), по которому должен быть доставлен некоторый IP-пакет с групповым адресом, зависит, в целом, от содержащихся в нём адресов получателя и отправителя. Даже если некоторый LSR-маршрутизатор является узлом (вершиной) соответствующего многоадресного дерева (графа), то он, всё равно, «привязывает» маркер к этому дереву. После этого LSR-маршрутизатор транслирует данные об этой привязке своему корневому узлу многоадресного дерева. (Если узел, о котором шла речь выше, является узлом ЛВС, а в самой ЛВС имеется несколько таких узлов (вершин дерева), то указанный узел также обязан направить данные об этой привязке всем вершинам дерева. Это позволит корневому узлу дерева (ЛВС) использовать только одно значение маркера при передаче IP-пакетов с групповой адресацией на вершины дерева (дочерние узлы ЛВС).)</p><p>Когда прибывает помеченный IP-пакет с групповой адресацией, то соответствующая входному маркеру NHLFE-запись содержит набор выходных интерфейсов для этого IP-пакета, а также исходящий маркер. Если для кодирования всех выходных интерфейсов используется один и тот же способ, то такой</p><p>IP-пакет может быть передан на все вершины дерева (графа).</p><h2 id="p5">5. Процедуры распределения (доставки) маркеров (при поузловой маршрутизации)</h2><p>Далее рассматриваются только те привязки маркеров, которые используются для маркирования коммутируемого трафика, который транслируется по маршруту с поузловой маршрутизацией. В таких случаях, маркер, упомянутый выше, будет соответствовать префиксу адреса в маршрутной таблице.</p><h3 id="p5.1">5.1. Процедуры для оповещения о маркерах и для использования маркеров</h3><p>Существует несколько процедур, которые можно использовать для доставки (распределения) данных о привязках маркеров. Некоторые процедуры используются LSR<sub>НП</sub>, а некоторые используются LSR<sub>ВП</sub>.</p><p>LSR<sub>НП</sub> обязаны выполнять следующие процедуры:</p><ul class="list lia"><li>процедура «доставки/распределения» (distribution procedure);</li><li>процедура «изъятия» (withdrawal procedure).</li></ul><p>LSR<sub>ВП</sub> обязаны выполнять следующие процедуры:</p><ul class="list lia"><li>процедура «запроса» (request procedure);</li><li>процедура «недопустимо» (not available procedure);</li><li>процедура «расцепления» (release procedure);</li><li>процедура «использования маркера» (label use procedure).</li></ul><p>MPLS-архитектура включает несколько вариантов каждой из процедур.</p><p>Тем не менее, MPLS-архитектура не допускает все возможные комбинации всех возможных вариантов процедур. В дальнейшем будут рассмотрены все допустимые комбинации, а также функциональная совместимость различных допустимых комбинаций.</p><h4>5.1.1. LSR-маршрутизатор нисходящего потока: процедура «доставки/распределения»</h4><p>Процедура доставки/распределения используется LSR<sub>НП</sub> с целью определения, когда ему целесообразно доставить данные о привязке маркера по отношению к некоторому префиксу адреса своим сторонам информационного обмена маркерами. MPLS-архитектура включает четыре варианта процедуры (субпроцедуры) доставки/распределения.</p><p>Независимо от того, какая процедура используется, если информация о привязке маркера по отношению к некоторому префиксу адреса был направлена LSR<sub>НП</sub> <em>R<sub>d</sub></em> в LSR<sub>ВП</sub> <em>R<sub>u</sub></em>, и если в какой-то момент времени атрибуты (как было сказано выше) этой привязки изменились, то <em>R<sub>d</sub></em> обязан сообщить <em>R<sub>u</sub></em> новые атрибуты.</p><p>Если LSR-маршрутизатор формирует несколько маршрутов для некоторого префикса адреса, то он должен сам решать, как выполнять соответствующую локальную процедуру привязки нескольких маркеров к префиксу адреса (по одному на маршрут), и, следовательно, как доставлять данные об этих нескольких привязках.</p><h5>5.1.1.1. Субпроцедура «безусловная вставка» (PushUnconditional)</h5><p>Пусть <em>R<sub>d</sub></em> будет LSR-маршрутизатором. Предположим, что:</p><ol class="lia"><li><p><sub>X</sub> представляет собой префикс адреса в маршрутной таблице <em>R<sub>d</sub></em>;</p></li><li><p><em>R<sub>u</sub></em> является взаимодействующей с <em>R<sub>d</sub></em> стороной в процедуре обмена маркерами, что касается <em>X</em>.</p></li></ol><p>Всякий раз, когда эти условия соблюдены, <em>R<sub>d</sub></em> обязан привязать маркер к <em>X</em> и направить данные об этой привязке <em>R<sub>u</sub></em>. <em>R<sub>d</sub></em> несёт ответственность за хранение переданных <em>R<sub>u</sub></em> данных (записи) об этой привязке, а также за обеспечение гарантий того, что <em>R<sub>u</sub></em> всегда будет имеет данные о новых привязках.</p><p>Данной субпроцедурой могут воспользоваться LSR-маршрутизаторы, которые осуществляют анализ невостребованных маркеров нисходящего потока в режиме независимого контроля LSP-маршрута (independent LSP control mode).</p><h5>5.1.1.2. Субпроцедура «условная вставка» (PushConditional)</h5><p>Пусть <em>R<sub>d</sub></em> будет LSR-маршрутизатором. Предположим, что:</p><ol class="lia"><li><p><em>X</em> представляет собой префикс адреса в маршрутной таблице <em>R<sub>d</sub></em>;</p></li><li><p><em>R<sub>u</sub></em> является взаимодействующей с <em>R<sub>d</sub></em> стороной в процедуре обмена маркерами, что касается <em>X</em>;</p></li><li><p><em>R<sub>d</sub></em> является, либо входом, либо выходом LSP-маршрута по отношению к <em>X</em>, или противоположной стороной следующего ретрансляционного участка на 3-м (сетевом) уровне для <em>R<sub>d</sub></em> по отношению к <em>X</em> является <em>R<sub>n</sub></em>, а последний привязал маркер к <em>X</em> и отправил данные об этой привязке <em>R<sub>d</sub></em>.</p></li></ol><p>Далее, как только все эти условия выполнены, <em>R<sub>d</sub></em> обязан привязать маркер к <em>X</em> и направить данные об этой привязке <em>R<sub>u</sub></em>.</p><p>Если следствием субпроцедуры «безусловная вставка» является доставка данных о привязках маркеров по отношению ко всем префиксам адресов, содержащихся в маршрутной таблице, то следствием субпроцедуры «условная вставка» является доставка данных о привязка маркеров по отношению только тех префиксов адресов, в интересах которых были получены данные о привязках маркеров от противоположной стороны следующего ретрансляционного участка LSP-маршрута, или для которых противоположная сторона следующего ретрансляционного участка на 3-м (сетевом) уровне не способна выполнять MPLS-функции.</p><p>Данной субпроцедурой могут воспользоваться LSR-маршрутизаторы, которые осуществляют анализ невостребованных маркеров нисходящего потока в режиме независимого контроля LSP-маршрута.</p><h5>5.1.1.3. Субпроцедура «безусловное извлечение» (PulledUnconditional)</h5><p>Пусть <em>R<sub>d</sub></em> будет LSR-маршрутизатором. Предположим, что:</p><ol class="lia"><li><p><em>X</em> представляет собой префикс адреса в маршрутной таблице <em>R<sub>d</sub></em>;</p></li><li><p><em>R<sub>u</sub></em> является взаимодействующей с <em>R<sub>d</sub></em> стороной в процедуре обмена маркерами, что касается <em>X</em>;</p></li><li><p><em>R<sub>u</sub></em> в явной форме затребовал, чтобы <em>R<sub>d</sub></em> привязал маркер к <em>X</em> и передал данные об это привязке <em>R<sub>u</sub></em>.</p></li></ol><p>Затем, <em>R<sub>d</sub></em> должен привязать маркер к <em>X</em> и направить данные об этой привязке <em>R<sub>u</sub></em>. Следует отметить, что если <em>X</em> отсутствует в маршрутной таблице <em>R<sub>d</sub></em>, или если <em>R<sub>d</sub></em> не является взаимодействующей с <em>R<sub>u</sub></em> стороной в процедуре обмена маркерами, что касается <em>X</em>, то <em>R<sub>d</sub></em> обязан проинформировать <em>R<sub>u</sub></em> о том, что он не может обеспечить привязку в настоящее время.</p><p>Если <em>R<sub>d</sub></em> уже передал <em>R<sub>u</sub></em> данные о привязке по отношению к префиксу адреса <em>X</em>, и он получил от <em>R<sub>u</sub></em> новый запрос на привязку по отношению к префиксу адреса <em>X</em>, то он выполнить привязку второго маркера и направит <em>R<sub>u</sub></em> данные о новой привязке. Привязка первого маркера остаётся в действии.</p><p>Данной субпроцедурой могут воспользоваться LSR-маршрутизаторы, которые осуществляют доставку востребованных маркеров нисходящего потока в режиме независимого контроля LSP-маршрута.</p><h5>5.1.1.4. Субпроцедура «условное извлечение» (PulledConditional)</h5><p>Пусть <em>R<sub>d</sub></em> будет LSR-маршрутизатором. Предположим, что:</p><ol class="lia"><li><p><em>X</em> представляет собой префикс адреса в маршрутной таблице <em>R<sub>d</sub></em>;</p></li><li><p><em>R<sub>u</sub></em> является взаимодействующей с <em>R<sub>d</sub></em> стороной в процедуре обмена маркерами, что касается <em>X</em>;</p></li><li><p><em>R<sub>u</sub></em> в явной форме затребовал, чтобы <em>R<sub>d</sub></em> привязал маркер к <em>X</em> и передал данные об это привязке <em>R<sub>u</sub></em>;</p></li><li><p><em>R<sub>d</sub></em> является, либо входом, либо выходом LSP-маршрута по отношению к <em>X</em>, или противоположной стороной следующего ретрансляционного участка на 3-м (сетевом) уровне для <em>R<sub>d</sub></em> по отношению к <em>X</em> является <em>R<sub>n</sub></em>, а последний отличается от <em>R<sub>u</sub></em>, и <em>R<sub>n</sub></em> привязал маркер к <em>X</em> и отправил данные об этой привязке <em>R<sub>d</sub></em>.</p></li></ol><p>Далее, как только все эти условия выполнены, <em>R<sub>d</sub></em> должен привязать маркер к <em>X</em> и направить данные об этой привязке <em>R<sub>u</sub></em>. Следует заметить, что если в маршрутной таблице <em>R<sub>d</sub></em> отсутствует <em>X</em>, а данные о привязке к <em>X</em> не доступны со стороны следующего ретрансляционного участка по отношению к <em>X</em>, или если <em>R<sub>d</sub></em> не является взаимодействующей с <em>R<sub>u</sub></em> стороной в процедуре обмена маркерами, что касается <em>X</em>, то <em>R<sub>d</sub></em> обязан проинформировать <em>R<sub>u</sub></em>, что в настоящий момент он не способен обеспечить привязку. Тем не менее, если только какое-либо условие не выполнимо, и это привело к тому, что <em>R<sub>n</sub></em> всё ещё не может предоставить маркер <em>R<sub>d</sub></em>, то последний обязан отложить передачу <em>R<sub>u</sub></em> какого-либо ответа до тех пор, пока он не получит данные о привязке от <em>R<sub>n</sub></em>.</p><p>Если <em>R<sub>d</sub></em> отправил <em>R<sub>u</sub></em> данные о привязке маркера к префиксу адреса <em>X</em>, а через некоторое время изменился какой-либо атрибут привязки маркера, то <em>R<sub>d</sub></em> обязан повторно направить <em>R<sub>u</sub></em> данные о привязке маркера с новым атрибутом. Он должен это сделать даже тогда, когда <em>R<sub>u</sub></em> не направил новый запрос.</p><p>Данной субпроцедурой могут воспользоваться LSR-маршрутизаторы, которые осуществляют распределение востребованных маркеров нисходящего потока в режиме упорядоченного контроля LSP-маршрута.</p><h4>5.1.2. LSR-маршрутизатор восходящего потока: процедура «запроса»</h4><p>Процедура «запроса» используется LSR<sub>ВП</sub> с целью определения префикса адреса, т.е. когда следует направить запрос в явной форме, чтобы LSR<sub>НП</sub> привязал маркер к этому префиксу и передал данные об этой привязке. Существуют три субпроцедуры, которые могут быть использованы.</p><h5>5.1.2.1. Субпроцедура «никогда не направлять запрос» (RequestNever)</h5><p>Процедура «никогда не направлять запрос» полезна тогда, когда LSR<sub>НП</sub> использует субпроцедуру «условная вставка» или «безусловная вставка», но не допустима тогда, когда LSR<sub>НП</sub> использует субпроцедуру «безусловное извлечение» или «условное извлечение».</p><p>Данной субпроцедурой могут воспользоваться LSR-маршрутизаторы, когда используются доставка/распределение невостребованных маркеров нисходящего потока и свободный режим сохранения маркеров.</p><h5 id="p5.1.2.2">5.1.2.2. Субпроцедура «направлять запрос, когда необходимо» (RequestWhenNeeded)</h5><p>Следует направлять запрос всякий раз, когда изменился следующий ретрансляционный участок 3-го уровня по отношению к префиксу адреса, или когда стал известен новый префикс адреса, и уже невозможно получить данные о привязке маркера от противоположной стороны следующего ретрансляционного участка относительно имеющегося префикса адреса.</p><p>Данной субпроцедурой могут воспользоваться LSR-маршрутизаторы, когда используется консервативный режим сохранения маркеров.</p><h5>5.1.2.3. Субпроцедура «направление запроса в ответ на запрос» (RequestOnRequest)</h5><p>Следует направлять запрос всякий раз, когда получен запрос, в дополнение к запросу, отправленному при необходимости (параграф <a href="print#p5.1.2.2" title="параграф 5.1.2.2 - Субпроцедура «направлять запрос, когда необходимо» (RequestWhenNeeded)">5.1.2.2</a>). Если <em>R<sub>u</sub></em> не способен выполнять функции входа LSP-маршрута, то он может направить запрос только тогда, когда он получит запрос от LSR<sub>ВП</sub>.</p><p>Если <em>R<sub>d</sub></em> получил такой запрос от <em>R<sub>u</sub></em> относительно префикса адреса, для которого <em>R<sub>d</sub></em> уже направил маркер <em>R<sub>u</sub></em>, то <em>R<sub>d</sub></em> должен выделить новый (индивидуальный) маркер и привязать последний к <em>X</em>, а затем распространить данные об этой привязке. (Либо <em>R<sub>d</sub></em> может направить данные о такой привязке непосредственно <em>R<sub>u</sub></em>, либо независимо от того, используется или нет процедура доставки/распределения.)</p><p>Данной субпроцедурой могут воспользоваться LSR-маршрутизаторы, которые осуществляют распространение запрашиваемых маркеров нисходящего потока, но которые не выполняют процедуру слияния маркеров, например, ATM-коммутаторы в качестве LSR-маршрутизаторов, которые не способны объединять виртуальные соединения.</p><h4>5.1.3. LSR-маршрутизатор восходящего потока: процедура «недопустимо» (NotAvailable)</h4><p>Если <em>R<sub>u</sub></em> и <em>R<sub>d</sub></em> являются LSR<sub>ВП</sub> и LSR<sub>НП</sub>, соответственно, и взаимодействующими сторонами при обмене маркерами относительно префикса адреса <em>X</em>, и <em>R<sub>d</sub></em> является для <em>R<sub>u</sub></em> противоположной стороной следующего ретрансляционного участка относительно <em>X</em>, а <em>R<sub>u</sub></em> запрашивает от <em>R<sub>d</sub></em> данные о привязке к <em>X</em>, но <em>R<sub>d</sub></em> отвечает, что в настоящий момент не может сформировать привязку, так как не обладает информацией о следующем ретрансляционном участке относительно <em>X</em>, то процедура «недопустимо» позволяет определить, как <em>R<sub>u</sub></em> следует ответить. Существуют две возможные субпроцедуры, которые определяют дальнейшее поведение <em>R<sub>u</sub></em>.</p><h5>5.1.3.1. Субпроцедура «повторение запроса» (RequestRetry)</h5><p><em>R<sub>u</sub></em> должен отправить запрос снова в более поздний момент времени. Т.е., сторона, направившая первый запрос, несёт ответственность за повторную попытку получить необходимые данные о привязке. Данной субпроцедурой можно воспользоваться тогда, когда реализуется процедура распространения запрашиваемых маркеров нисходящего потока.</p><h5>5.1.3.2. Субпроцедура «не повторять запрос» (RequestNoRetry)</h5><p><em>R<sub>u</sub></em> никогда не должен отправлять повторный запрос, а должен предполагать, что <em>R<sub>d</sub></em> предоставит данные о привязке автоматически, когда это будет возможно. Эта субпроцедура весьма полезна тогда, когда <em>R<sub>d</sub></em> использует субпроцедуру «безусловная вставка» или «условная вставка», т.е., если используется распространение невостребованных маркеров нисходящего потока.</p><p>Следует отметить, что если <em>R<sub>d</sub></em> повторно сообщает <em>R<sub>u</sub></em>, что он не может предоставить данные о привязке, то это будет, скорее всего, следствием какой-либо нештатной ситуации, а не следствием того, что <em>R<sub>d</sub></em> не знает следующий ретрансляционный участок. В таком случае, функционирование <em>R<sub>u</sub></em>, скорее всего, будет определяться процедурами LDP-протокола по выходу из нештатной ситуации, а не процедурой «недопустимо».</p><h4>5.1.4. LSR-маршрутизатор восходящего потока: процедура «расцепления»</h4><p>Предположим, что <em>R<sub>d</sub></em> является LSR-маршрутизатором, который привязал маркер к префиксу адреса <em>X</em> и направил LSR-маршрутизатору <em>R<sub>u</sub></em> данные об этой привязке. Если <em>R<sub>d</sub></em> не является или перестал быть для <em>R<sub>u</sub></em> следующим ретрансляционным участком 3-го уровня относительно префикса адреса <em>X</em>, то <em>R<sub>u</sub></em> не будет использовать маркер. Процедура «расцепления» определяет, как действовать <em>R<sub>u</sub></em> в таком случае. Существуют две возможных субпроцедуры, которые определяют поведение <em>R<sub>u</sub></em>.</p><h5>5.1.4.1. Субпроцедура «расцепление при изменениях» (ReleaseOnChange)</h5><p><em>R<sub>u</sub></em> должен удалить («расцепить») привязку и проинформировать <em>R<sub>d</sub></em> о том, что он это осуществил. Данной субпроцедурой можно воспользоваться при реализации «консервативного режима сохранения маркера потока».</p><h5>5.1.4.2. Субпроцедура «не удалять привязку при изменениях» (NoReleaseOnChange)</h5><p><em>R<sub>u</sub></em> должен сформировать привязку, причём такую, чтобы он смог её использовать повторно и сразу после того, как <em>R<sub>d</sub></em> станет для <em>R<sub>u</sub></em> следующим ретрансляционным участком 3-го уровня относительно префикса адреса <em>X</em>. Данной субпроцедурой можно воспользоваться при реализации «свободного режима сохранения маркера потока».</p><h4>5.1.5. LSR-маршрутизатор восходящего потока: процедура «использования маркера»</h4><p>Предположим, что <sub>R<em>u</em></sub> является LSR-маршрутизатором, который получил от LSR-маршрутизатора <em>R<sub>d</sub></em> данные о привязке маркера <em>L</em> к префиксу адреса <em>X</em>, а <em>R<sub>u</sub></em> является LSR<sub>ВП</sub> по отношению к R<em><sub>d</sub></em>, что касается <em>X</em>, и, фактически, <em>R<sub>d</sub></em> является для <em>R<sub>u</sub></em> следующим ретрансляционным участком 3-го уровня относительно префикса адреса <em>X</em>.</p><p><em>R<sub>u</sub></em> будет использовать привязку, если <em>R<sub>d</sub></em> является для <em>R<sub>u</sub></em> следующим ретрансляционным участком 3-го уровня относительно префикса адреса <em>X</em>. Если в некоторый момент времени <em>R<sub>u</sub></em> получает привязку, а <em>R<sub>d</sub></em> не является для <em>R<sub>u</sub></em> следующим ретрансляционным участком 3-го уровня относительно префикса адреса <em>X</em>, то в это время <em>R<sub>u</sub></em> не использует каким-либо образом привязку. Тем не менее, по прошествии некоторого времени <em>R<sub>u</sub></em> может начать использование привязки, если <em>R<sub>d</sub></em> станет для <em>R<sub>u</sub></em> следующим ретрансляционным участком 3-го уровня относительно префикса адреса <em>X</em>.</p><p>Процедура «использование маркера» определяет только, как <em>R<sub>u</sub></em> использует привязку <em>R<sub>d</sub></em>.</p><p>Существуют только две субпроцедуры, которые может использовать <em>R<sub>u</sub></em>.</p><h5>5.1.5.1. Субпроцедура «незамедлительное использование» (UseImmediate)</h5><p><em>R<sub>u</sub></em> может сразу начать использование привязки. В любой момент времени, когда <em>R<sub>u</sub></em> получил от <em>R<sub>d</sub></em> привязку к <em>X</em>, а <em>R<sub>d</sub></em> является для <em>R<sub>u</sub></em> следующим ретрансляционным участком 3-го уровня относительно <em>X</em>, тогда <em>R<sub>d</sub></em> будет также для <em>R<sub>u</sub></em> следующим ретрансляционным участком LSP-маршрута относительно <em>X</em>. Эта субпроцедура используется тогда, когда не используется процедура выявления петлевого маршрута.</p><h5>5.1.5.2. Субпроцедура «использование, если не выявлен петлевой маршрут» (UseIfLoopNotDetected)</h5><p>Эта субпроцедура аналогична субпроцедуре «незамедлительное использование», но до тех пор, пока <em>R<sub>u</sub></em> не обнаружит «петлю» в LSP-маршруте. Если петлевой маршрут обнаружен, то <em>R<sub>u</sub></em> приостанавливает использование маркера <em>L</em> для доставки IP-пакетов до <em>R<sub>d</sub></em>. Эта субпроцедура используется тогда, когда используется процедура выявления петлевого маршрута. Приостановка использования маркера будет продолжаться до тех пор, пока не изменится следующий ретрансляционный участок относительно <em>X</em>, или до тех пор, пока не будет выявлено отсутствие петлевого маршрута.</p><h4>5.1.6. LSR-маршрутизатор нисходящего потока: процедура «изъятия»</h4><p>В данном случае, существует только одна процедура.</p><p>Когда LSR-маршрутизатор <em>R<sub>d</sub></em> принимает решение об аннулировании привязки маркера <em>L</em> к префиксу адреса <em>X</em>, то данные об изъятии привязки должны быть направлены всем LSR-маршрутизаторам, которым были ранее направлены данные о сформировании привязки.</p><p>Это требует, чтобы данные об изъятии привязки <em>L</em> к <em>X</em> были направлены <em>R<sub>d</sub></em> LSR-маршрутизатору <em>R<sub>u</sub></em> ещё до того, как <em>R<sub>d</sub></em> направит <em>R<sub>u</sub></em> данные о какойлибо новой привязке <em>L</em> к любому другому префиксу адреса <em>Y</em> (где <em>X</em> ≠ <em>Y</em>). Если <em>R<sub>u</sub></em> был бы оповещён о новой привязке <em>L</em> к <em>Y</em> ещё до того, как он узнал об изъятии привязки <em>L</em> к <em>X</em>, и если бы адреса IP-пакетов совпадали, и с <em>X</em>, и с <em>Y</em>, то на протяжении некоторого периода времени <em>R<sub>u</sub></em> мог бы помечать, и IP-пакеты, адреса которых совпадают с <em>X</em>, и IP-пакеты, адреса которых совпадают <em>Y</em>, с помощью маркера <em>L</em>.</p><p>Распределение и изъятие привязок маркеров осуществляется с помощью LDP-протокола. Все LDP-протоколы требуют, чтобы две стороны обмена маркерами были смежными (соседями) при доставке/распределении маркеров (за исключением, сторон неявной процедуры обмена маркерами). Если LSR-маршрутизатор <em>R</em><sub>1</sub> и LSR-маршрутизатор <em>R</em><sub>2</sub> являются соседями (смежными узлами) при распределении маркеров между собой, и <em>R</em><sub>1</sub> получил от <em>R</em><sub>2</sub> данные о привязках маркеров, используя «соседство» с ним, и если затем такое «соседство» будет нарушено (разорвано вследствие, либо нештатной ситуации, либо выполнения штатной процедуры, предусматривающей такой разрыв) одной из сторон (одним из LSR-маршрутизаторов), то все полученные за счёт «соседства» данные о привязках должны рассматриваться как изъятые.</p><p>До тех пор, пока соответствующее «соседство» при распределении маркеров сохраняется, привязки маркеров, которые подлежат изъятию, должны всегда «изыматься» в явном виде. Если к префиксу адреса привязан второй маркер, то в результате первый маркер не будет изыматься в неявном виде, а будут привязаны оба маркера, а это необходимо для обеспечения многомаршрутной маршрутизации. Если к маркеру привязан второй префикс адреса, то в результате привязка этого маркера к первому префиксу адреса не будет изыматься в неявном виде, а данный маркер будет использоваться в интересах обоих префиксов адресов.</p><h3 id="p5.2">5.2. MPLS-схемы: допустимые комбинации процедур</h3><p>Рассмотрим два LSR-маршрутизатора <em>R<sub>u</sub></em> и <em>R<sub>d</sub></em>, которые являются взаимодействующими сторонами в процедуре обмена маркерами относительно некоторой совокупности префиксов, и при этом <em>R<sub>u</sub></em> является LSR<sub>ВП</sub>, а и <em>R<sub>d</sub></em> — LSR<em>НП</em>.</p><p>MPLS-схема, которая управляет взаимодействием <em>R<sub>u</sub></em> и <em>R<sub>d</sub></em>, может быть определена как кортеж из пяти процедур: &lt;DistributionProcedure, RequestProcedure, NotAvailableProcedure, ReleaseProcedure, LabelUseProcedure&gt; (&lt;доставка/распределение, запрос, недопустимо, расцепление, использование маркера&gt;). (Так как существует только одна процедура «изъятия» (WithdrawProcedure), то нет необходимости её указывать.) Символ «*», расположенный на одной из позиций, является универсальным свободно замещаемым символом (wild-card), означающий, что в этом месте может быть представлена любая субпроцедура из этой категории. Символ «N/A», расположенный на соответствующей позиции, указывает на то, что субпроцедура в данной категории не нужна.</p><p>MPLS-архитектура рассматривает только следующие MPLS-схемы.</p><h4>5.2.1. Схемы для LSR-маршрутизаторов, которые реализуют слияние маркеров</h4><p>Если <em>R<sub>u</sub></em> и <em>R<sub>d</sub></em> являются взаимодействующими сторонами в процедуре обмена маркерами, и оба реализуют функцию слияния маркеров, то должна использоваться одна из следующих MPLS-схем:</p><ol class="lia"><li><p class="b">&lt;PushUnconditional, RequestNever, N/A, NoReleaseOnChange, UseImmediate&gt;</p><p class="lia">Данная схема представляет собой распределение невостребованных маркеров нисходящего потока с независимым контролем (анализом), при реализации «свободного режима сохранения маркера потока» и без процедуры выявления петлевого маршрута.</p></li><li><p class="b">&lt;PushUnconditional, RequestNever, N/A, NoReleaseOnChange, UseIfLoopNotDetected&gt;</p><p class="lia">Данная схема представляет собой распределение невостребованных маркеров нисходящего потока с независимым контролем (анализом), при реализации «свободного режима сохранения маркера потока» и процедуры выявления петлевого маршрута.</p></li><li><p class="b">&lt;PushConditional, RequestWhenNeeded, RequestNoRetry, ReleaseOnChange, *&gt;</p><p class="lia">Данная схема представляет собой распределение невостребованных маркеров нисходящего потока с упорядоченным контролем (со стороны выхода маршрута), при реализации «консервативного режима сохранения маркера потока». Процедура выявления петлевого маршрута является дополнительной.</p></li><li><p class="b">&lt;PushConditional, RequestNever, N/A, NoReleaseOnChange, *&gt;</p><p class="lia">Данная схема представляет собой распределение невостребованных маркеров нисходящего потока с упорядоченным контролем (со стороны выхода маршрута), при реализации «свободного режима сохранения маркера потока». Процедура выявления петлевого маршрута является дополнительной.</p></li><li><p class="b">&lt;PulledConditional, RequestWhenNeeded, RequestRetry, ReleaseOnChange, *&gt;</p><p class="lia">Данная схема представляет собой распределение востребованных маркеров нисходящего потока с упорядоченным контролем (инициируемым со стороны входа маршрута), при реализации «консервативного режима сохранения маркера потока». Процедура выявления петлевого маршрута является дополнительной.</p></li><li><p class="b">&lt;PulledUnconditional, RequestWhenNeeded, N/A, ReleaseOnChange, UseImmediate&gt;</p><p class="lia">Данная схема представляет собой распределение востребованных маркеров нисходящего потока с независимым контролем, при реализации «консервативного режима сохранения маркера потока» и без процедуры выявления петлевого маршрута.</p></li><li><p class="b">&lt;PulledUnconditional, RequestWhenNeeded, N/A, ReleaseOnChange, UseIfLoopNotDetected &gt;</p><p class="lia">Данная схема представляет собой распределение востребованных маркеров нисходящего потока с независимым контролем, при реализации «консервативного режима сохранения маркера потока» и процедуры выявления петлевого маршрута.</p></li></ol><h4>5.2.2. Схемы для LSR-маршрутизаторов, которые не реализуют слияние маркеров</h4><p>Предположим, что <em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, <em>R</em><sub>3</sub> и <em>R</em><sub>4</sub> являются ATM-коммутаторами, которые не реализуют слияние маркеров, но используются в качестве LSR-маршрутизаторов. В дальнейшем будем считать, что &lt;<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, <em>R</em><sub>3</sub>, <em>R</em><sub>4</sub>&gt; является маршрутом с поузловой маршрутизацией 3-го уровня относительно префикса адреса <em>X</em>, и что IP-пакеты, предназначенные для <em>X</em>, могут поступить в сеть через любой из этих LSR-маршрутизаторов. Так как не существует предпосылок для появления сходящихся маршрутов, LSP-маршруты должны представлять собой сквозные виртуальные соединения, а это означает, в сети должны три таких виртуальных маршрута относительно префикса адреса X: &lt;<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, <em>R</em><sub>3</sub>, <em>R</em><sub>4</sub>&gt;, &lt;<em>R</em><sub>2</sub>, <em>R</em><sub>3</sub>, <em>R</em><sub>4</sub>&gt;, и &lt;<em>R</em><sub>3</sub>, <em>R</em><sub>4</sub>&gt;.</p><p>Более того, если <em>R</em><sub>1</sub> и <em>R</em><sub>2</sub> являются MPLS-узлами, а также один из них является LSR-маршрутизатором, который встроен в стандартный программно-аппаратный ATM-коммутатор (т.е., в котором не блокируется перемежение ячеек), или по какой-либо другой причине не возможно реализовать функцию слияния маркеров, то между <em>R</em><sub>1</sub> и <em>R</em><sub>2</sub> должна использоваться одна из следующих MPLS-схем:</p><ol class="lia"><li><p class="b">&lt;PulledConditional, RequestOnRequest, RequestRetry, ReleaseOnChange, *&gt;</p><p class="lia">Данная схема представляет собой распределение востребованных маркеров нисходящего потока с упорядоченным контролем (инициируемым со стороны входа маршрута), при реализации «консервативного режима сохранения маркера потока» и дополнительной процедуры выявления петлевого маршрута.</p><p class="lia">В результате использования субпроцедуры «направление запроса в ответ на запрос» (RequestOnRequest) <em>R</em><sub>4</sub> направит <em>R</em><sub>3</sub> три маркера относительно <em>X</em>, <em>R</em><sub>3</sub> направит <em>R</em><sub>2</sub> два маркера относительно <em>X</em> и <em>R</em><sub>2</sub> направит <em>R</em><sub>1</sub> один маркер относительно <em>X</em>.</p></li><li><p class="b">&lt;PulledUnconditional, RequestOnRequest, N/A, ReleaseOnChange, UseImmediate&gt;</p><p class="lia">Данная схема представляет собой распределение востребованных маркеров нисходящего потока с независимым контролем, при реализации «консервативного режима сохранения маркера потока» и без процедуры выявления петлевого маршрута.</p></li><li><p class="b">&lt;PulledUnconditional, RequestOnRequest, N/A, ReleaseOnChange, UseIfLoopNotDetected&gt;</p><p class="lia">Данная схема представляет собой распределение востребованных маркеров нисходящего потока с независимым контролем, при реализации «консервативного режима сохранения маркера потока» и процедуры выявления петлевого маршрута.</p></li></ol><h4>5.2.3. Условия функциональной совместимости</h4><p>Легко заметить, что некоторые кортежи из пяти процедур не являются работоспособными MPLS-схемами. Например:</p><ul class="list lia"><li><p class="b">&lt;PulledUnconditional, RequestNever, *, *, *&gt; и &lt;PulledConditional, RequestNever, *, *, *&gt;</p><p class="lia">В данных MPLS-схемах LSR<sub>НП</sub> <em>R<sub>d</sub></em> направляет LSR<sub>ВП</sub> <em>R<sub>u</sub></em> данные о привязках маркеров только по запросу <em>R<sub>u</sub></em>, но <em>R<sub>u</sub></em> никогда не направляет такие запросы. Очевидно, что эти схемы не жизнеспособны, так как они не обеспечат надлежащую доставку данных о привязках маркеров.</p></li><li><p class="b">&lt;*, RequestNever, *, *, ReleaseOnChange&gt;</p><p class="lia">В данных MPLS-схемах <em>R<sub>d</sub></em> отцепляет привязки, когда он их не использует, но в тоже время, он никогда не запросит информацию о них снова, если даже они ему понадобятся в дальнейшем. Таким образом, подобные схемы не гарантируют того, что данные о привязках маркеров будут получены в случае их корректного распределения.</p></li></ul><p>Далее рассматриваются правила, целью которых является защита взаимодействующих сторон при обмене маркерами от использования процедур, которые приводят к недопустимым MPLS-схемам. Следующие далее правила требуют, либо обмена информацией между взаимодействующими сторонами в течении начальной фазы установления соединения для обмена маркерами, либо предварительного знания информации:</p><ol class="lia"><li><p>Каждый обязан явно продемонстрировать свою способность осуществлять слияние маркеров.</p></li><li><p>Если <em>R<sub>d</sub></em> не обеспечивает слияние маркеров, то он обязан выбрать одну из двух субпроцедур, либо «безусловное извлечение» (PulledUnconditional), либо «условное извлечение» (PulledConditional). Если <em>R<sub>d</sub></em> выбрал субпроцедуру «условное извлечение», то он вынужден использовать субпроцедуру «повторение запроса» (RequestRetry). Т.е., если LSR<sub>НП</sub> не поддерживает слияние маркеров, то его предпочтения являются приоритетными при выборе MPLS-схемы.</p></li><li><p>Если <em>R<sub>u</sub></em> не обеспечивает слияние маркеров, а <em>R<sub>d</sub></em> обеспечивает, то <em>R<sub>u</sub></em> обязан выбрать одну из двух субпроцедур, либо «повторение запроса» (RequestRetry), либо «не повторять запрос» (RequestNoRetry). Это вынуждает <em>R<sub>d</sub></em> использовать из двух субпроцедур, либо «условное извлечение» (PulledConditional), либо «безусловное извлечение» (PulledUnconditional), соответственно. Т.е., если только один из LSR-маршрутизаторов не поддерживает слияние маркеров, то его предпочтения являются приоритетными при выборе MPLS-схемы.</p></li><li><p>Если оба, <em>R<sub>d</sub></em> и <em>R<sub>u</sub></em>, реализуют процедуру слияния маркеров, выбор одного их двух режимов сохранения маркеров, свободного или консервативного режима, принадлежит <em>R<sub>u</sub></em>. Т.е., <em>R<sub>u</sub></em> предоставляется выбор использования субпроцедур, либо «RequestWhenNeeded/ReleaseOnChange» (консервативный режим), либо «RequestNever/NoReleaseOnChange» (свободный режим). Однако, право выбора «вставка» или «извлечение» и «условный» или «безусловный» принадлежит <em>R<sub>d</sub></em>. Если <em>R<sub>u</sub></em> выбирает свободный режим сохранения маркеров, то <em>R<sub>d</sub></em> может выбрать одну из двух субпроцедур, либо «безусловная вставка», либо «условная вставка». Если <em>R<sub>u</sub></em> выбирает консервативный режим сохранения маркеров, то <em>R<sub>d</sub></em> может выбрать одну из трёх субпроцедур, либо «условная вставка», либо «условное извлечение», либо «безусловное извлечение». Все вместе эти варианты выбора определяют используемую MPLS-схему.</p></li></ol><h2 id="p6">6. Вопросы информационной безопасности</h2><p>Некоторые маршрутизаторы могут использовать специализированные процедуры обеспечения информационной безопасности (ИБ), которые зависят заголовка сетевого уровня, который размещается в конкретном месте, связанным с заголовком канального уровня. Универсальная MPLS-процедура повторного обрамления подразумевает размещение дополнительного поля между заголовками канального и сетевого уровней. Такая вставка может повлечь за собой нарушение процедур обеспечения ИБ.</p><p>MPLS-маркер имеет собственное значение на основе действующего соглашения между LSR-маршрутизатором, который вставляет маркер в набор маркеров («автор маркера», label writer), и LSR-маршрутизатором, который интерпретирует этот маркер («считыватель маркер», label reader). Если помеченные IP-пакеты поступают из ненадёжных источников, или если некоторый входящий маркер был получен от LSR-маршрутизатора, который, в свою очередь, такой маркер не получал, то такие IP-пакеты могут ретранслированы нелегитимным способом.</p><h2 id="p.references">Ссылки</h2><table itemprop="references"><tr><td>[MPLS-ATM]</td><td>Davie, B., Lawrence, J., McCloghrie, K., Rekhter, Y., Rosen, E., Swallow, G. и P. Doolan, <a href="../3035.rfc" title="RFC 3035 — Применение MPLS-коммутации в сетях с асинхронным режимом доставки">«Применение MPLS-коммутации в сетях с асинхронным режимом доставки», RFC 3035</a>, Январь 2001.</td></tr><tr><td>[MPLS-BGP]</td><td>«Carrying Label Information in BGP-4», Rekhter, Rosen, Work in Progress.</td></tr><tr><td>[MPLS-CR-LDP]</td><td>«Constraint-Based LSP Setup using LDP», Jamoussi, Editor, Work in Progress.</td></tr><tr><td>[MPLS-FRMRLY]</td><td>Conta, A., Doolan, P. и A. Malis, <a href="../3034.rfc" title="RFC 3034 — Применение MPLS-коммутации в сетях с ретрансляцией кадров">«Применение MPLS-коммутации в сетях с ретрансляцией кадров», RFC 3034</a>, Январь 2001.</td></tr><tr><td>[MPLS-LDP]</td><td>Andersson, L., Doolan, P., Feldman, N., Fredette, A. и B. Thomas, «LDP Specification», RFC 3036, Январь 2001.</td></tr><tr><td class="nobr">[MPLS-RSVP-TUNNELS]</td><td>«Extensions to RSVP for LSP Tunnels», Awduche, Berger, Gan, Li, Swallow, Srinvasan, Work in Progress.</td></tr><tr><td>[MPLS-SHIM]</td><td>Rosen, E., Rekhter, Y., Tappan, D., Fedorkow, G., Farinacci, D. и A. Conta, <a href="../3032.rfc" title="RFC 3032 — Кодирование набора маркеров в MPLS-системах">«Кодирование набора маркеров в MPLS-системах», RFC 3032</a>, Январь 2001.</td></tr><tr><td>[MPLS-TRFENG]</td><td>Awduche, D., Malcolm, J., Agogbua, J., O'Dell, M. и J. McManus, «Requirements for Traffic Engineering Over MPLS», RFC 2702, Сентябрь 1999.</td></tr></table></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 3031 - Архитектура многопротокольной коммутации на основе маркеров потока (MPLS)",disqus_identifier="3031.rfc",disqus_url="http://rfc2.ru/3031.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>