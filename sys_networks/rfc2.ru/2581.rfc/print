<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../2581.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 2581 — Контроль насыщения в TCP</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../2581.rfc">RFC 2581 — Контроль насыщения в TCP</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 2581</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank" rel="nofollow"><span itemprop="alternativeHeadline">TCP Congestion Control</span></a></dd><dd><div class="icon i7"></div> Другие версии: RFC 2001, <strong class="obsoleted_by">RFC 5681</strong></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Предложенный стандарт</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1999-04-01">Апрель 1999</time></dd><dd><div class="icon i5"></div> Авторы: <span itemprop="author">M. Allman</span>, <span itemprop="author">V. Paxson</span>, <span itemprop="author">W. Stevens</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div id="text" itemprop="articleBody"><h3>Статус документа</h3><p>Документ содержит спецификацию стандартного протокола для сообщества Internet и является приглашением к дискуссии в целях развития и совершенствования протокола. Сведения о стандартизации и состоянии данного протокола можно найти в документе "Internet Official Protocol Standards" (STD 1). Допускается свободное распространение данного документа.</p><h3>Тезисы</h3><p>В этом документе определены 4 связанных между собой алгоритма контроля насыщения для протокола TCP - slow start, congestion avoidance, fast retransmit и fast recovery. Кроме того в документе указано как протоколу TCP следует начинать передачу после сравнительно долгого периода бездействия, а также рассмотрены различные методы генерации подтверждений.</p><h3>1. Введение</h3><p>В этом документе даны спецификации четырех алгоритмов контроля насыщения для протокола TCP [<a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC793</a>]: slow start, congestion avoidance, fast retransmit и fast recovery. Эти алгоритмы были опубликованы в документах [Jac88] и [Jac90]. Использование алгоритмов с протоколом TCP стандартизовано в [<a href="../1122.rfc" title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни">RFC1122</a>].</p><p>Данный документ является обновлением [<a href="../2001.rfc" title="RFC 2001 - Алгоритмы Slow Start, Congestion Avoidance, Fast Retransmit, и Fast Recovery для протокола TCP">RFC2001</a>]. В дополнение к спецификациям алгоритмов контроля насыщения документ указывает, как должны себя вести соединения TCP после сравнительно долгого периода бездействия, а также разъясняет некоторые вопросы, касающиеся генерации TCP ACK.</p><p>Отметим, что в документе [Ste94] приводятся прим еры реального использования описанных здесь алгоритмов, а [WS95] содержит пояснения к исходному коду реализации этих алгоритмов в BSD.</p><p>Глава данного документа 2 содержит определения используемых в документе терминов. В главе 3 приведены спецификации алгоритмов контроля насыщения. Глава 4 посвящена ситуациям, связанным с алгоритмами контроля насыщения, а в главе 5 обсуждаются вопросы безопасности.</p><p>Ключевые слова "MUST" (необходимо), "MUST NOT" (недопустимо), "REQUIRED" (требуется), "SHALL" (следует), "SHALL NOT" (не следует), "SHOULD" (следует), "SHOULD NOT" (не следует), "RECOMMENDED" (рекомендуется), "MAY" (возможно) и "OPTIONAL" (необязательно) в данном документе трактуются в соответствии с [<a href="../2119.rfc" title="RFC 2119 - Ключевые слова для обозначения уровня требований в RFC">RFC2119</a>].</p><h3>2. Определения</h3><p>В этой главе приводятся определения некоторых терминов, которые будут использованы в документе.</p><ul><li class="b">SEGMENT - сегмент</li><li class="lib">Сегментом является любой пакет данных или подтверждение TCP/IP.</li><li class="b">SENDER MAXIMUM SEGMENT SIZE (SMSS) - максимальный размер сегмента для отправителя</li><li class="lib">SMSS представляет собой размер самого большого сегмента, который может быть передан отправителем. Это значение может определяться на основе максимального блока данных, передаваемого через сеть, алгоритма path MTU [<a href="../1191.rfc" title="RFC 1191 - Исследование MTU на пути следования сообщения">RFC1191</a>], RMSS (см. следующее определение) и других факторов. Размер не включает заголовков и опций TCP/IP.</li><li class="b">RECEIVER MAXIMUM SEGMENT SIZE (RMSS) - максимальный размер сегмента для получателя</li><li class="lib">RMSS - размер максимального сегмента, который желает принимать получатель. Это значение задается в опции MSS, передаваемой хостом при организации соединения. Если опция MSS при организ ации соединения не была задана, используется значение 536 байтов [<a href="../1122.rfc" title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни">RFC1122</a>]. Размер не включает заголовков и опций TCP/IP.</li><li class="b">FULL-SIZED SEGMENT - полноразмерный сегмент</li><li class="lib">Сегмент, максимально допустимое количество данных (т. е., SMSS байтов).</li><li class="b">RECEIVER WINDOW (rwnd) - размер окна принимающей стороны</li><li class="lib">Анонсированное последним значение размера окна принимающей стороны.</li><li class="b">CONGESTION WINDOW (cwnd) - размер окна насыщения</li><li class="lib">Переменная состояния TCP, которая ограничивает количество данных, разрешенных протоколу для передачи. В любой момент для TCP недопустима передача данных с порядковыми номерами, превышающими значение суммы наибольшего из подтвержденных порядковых номеров и меньшего из двух значений cwnd и rwnd.</li><li class="b">INITIAL WINDOW (IW) - начальный размер окна</li><li class="lib">Начальным размером окна является размер окна насыщения отправителя после завершения трехэтапного согласования параметров.</li><li class="b">LOSS WINDOW (LW) - размер окна потерь</li><li class="lib">Размер окна насыщения после того, как отправитель TCP обнаружит потерю, используя свой таймер повтора передачи.</li><li class="b">RESTART WINDOW (RW) - размер окна перезапуска</li><li class="lib">Размер окна насыщения после того, как TCP возобновит передачу из состояния бездействия (для случая использования алгоритма slow start см. параграф 4.1).</li><li class="b">FLIGHT SIZE - размер "звена"</li><li class="lib">Количество данных, которые уже переданы, но еще не подтверждены.</li></ul><h3>3. Алгоритмы контроля насыщения</h3><p>В этой главе определены четыре алгоритма контроля насыщения - slow start, congestion avoidance, fast retransmit и fast recovery, разработанные в [Jac88] и [Jac90]. В некоторых случаях для отправителя TCP предпочтительно быть более консервативным, нежели позволяют алгоритмы, но для TCP недопустимо быть более агрессивным, чем позволяют алгоритмы (т. е., недопустимо передавать данные, когда рассчитанное с помощью алгоритмов значение cwnd не разрешает передачу).</p><h3>3.1 Алгоритмы Slow Start и Congestion Avoidance</h3><p>Алгоритмы замедленного старта (slow start) и предотвращения перегрузки (congestion avoidance) должны использоваться отправителем TCP для контроля за передачей в сеть остающихся неотправленными данных. Для реализации этих алгоритмов в состояние соединения TCP добавлены две переменных. Размер окна насыщения (cwnd) - задаваемый на стороне отправителя предел для количества данных, которые отправитель может передать в сеть до получения подтверждения (ACK), а анонсируемое получателем окно (rwnd) определяет установленный на приемной стороне предел размера остающихся данных. Передачей управляет меньшее из двух значений cwnd и rwnd.</p><p>Еще одна переменная состояния ssthresh используется для определения момента, когда следует использовать алгоритм замедленного старта или предотвращения перегрузки в соответствии с приведенными ниже описаниями.</p><p>Начало передачи в сеть с неизвестными условиями требует от TCP достаточно медленной проверки сети с целью определения доступной "емкости" для того, чтобы избежать насыщения сети избыточным потоком данных. Алгоритм slow start используется для решения этой задачи на начальном этапе передачи или после восстановления в результате потери пакетов, обнаруженной с помощью таймера повторной передачи.</p><p>IW - начальное значение cwnd - должно быть не более 2*SMSS байтов и недопустимо делать это значение более 2 сегментов.</p><p class="note">Отметим, что нестандартные экспериментальные реализации TCP могут разрешать использование начального окна IW большего размера, как определено в уравнении (1) [RFC2414]:</p><pre>IW = min (4*SMSS, max (2*SMSS, 4380 bytes)) (1)</pre><p>В таких случаях отправитель TCP может использовать начальное окно размером в 3 или 4 сегмента, если суммарный размер этих сегментов не превышает 4380 байтов. Данный документ не разрешает использование таких расширений. Однако далее в этом документе обсуждается использование выражения (1) как направления для экспериментов в части изменений параметров (но не как часть данной спецификации алгоритмов контроля насыщения).</p><p>Начальное значение ssthresh может быть сколь угодно высоким (например, некоторые реализации используют в качестве порога размер анонсируемого окна), но значение порога может быть уменьшено при возникновении насыщения. Алгоритм замедленного старта используется в тех случаях, когда cwnd &lt; ssthresh, а при cwnd &gt; ssthresh применяется алгоритм предотвращения перегрузки. Если cwnd = ssthresh отправитель может использовать любой из этих алгоритмов.</p><p>При замедленном старте TCP увеличивает размер окна cwnd не более, чем на SMSS байтов для каждого пакета ACK, подтверждающего доставку новой порции данных. Замедленный старт завершается, когда размер окна насыщения cwnd превышает порог ssthresh (или становится равным этому порогу).</p><p>В процессе предотвращения перегрузки размер окна cwnd увеличивается на 1 полноразмерный сегмент за каждый период кругового обхода RTT. Предотвращение насыщения продолжается до тех пор, пока насыщение наблюдается. Для обновления значений cwnd в процессе предотвращения перегрузки обычно используется выражение:</p><pre>cwnd += SMSS*SMSS/cwnd (2)</pre><p>Такое увеличение окна выполняется при каждом входящем пакете ACK, не являющемся дубликатом. Выражение (2) обеспечивает допустимое приближение для описанного выше увеличения окна cwnd на 1 полноразмерный сегмент для каждого периода RTT. Отметим, что для соединения, в котором получатель подтверждает прием каждого сегмента данных, выражение (2) задает несколько более агрессивный подход, нежели добавление размера 1 сегмента на каждый период RTT, а для получателей, подтверждающих каждый второй пакет, выражение (2) задает менее агрессивный подход по сравнению с добавлением 1 сегмента.</p><div class="note"><p>Примечание для разработчиков: Поскольку в реализациях TCP обычно используется целочисленная арифметика, выражение (2) может не приводить к увеличению размера окна cwnd, когда окно насыщения очень велико (больше, чем SMSS*SMSS). Если выражение (2) дает нулевой результат, его следует "округлять" до 1 байта.</p><p>В старых реализациях используется дополнительная положительная константа в правой части выражения (2). Такой подход некорректен и может вести к снижению производительности [RFC2525].</p></div><p>Другим подходящим способом увеличения окна cwnd в процессе предотвращения перегрузки является подсчет числа байтов новых данных, которые были подтверждены пакетами ACK (недостатком этого метода является необходимость поддержки дополнительной переменной состояния). Когда число подтвержденных байтов достигнет значения cwnd, размер окна cwnd может быть увеличен на величину до SMSS байтов. Отметим, что в процессе предотвращения перегрузки размер окна cwnd недопустимо увеличивать более, чем на размер одного полноразмерного сегмента в течение периода RTT или на величину, вычисляемую с помощью выражения 2.</p><p class="note">Примечание для разработчиков: Некоторые реализации поддерживают размер окна cwnd в байтах, а другие - в полноразмерных сегментах. В последнем случае использование выражения (2) становится затруднительным и может оказаться предпочтительным механизм, рассмотренный в предыдущем абзаце.</p><p>Когда отправитель TCP обнаруживает потерю сегмента с помощью таймера повтора передачи, для переменной ssthresh должно устанавливаться значение, не превышающее значение выражения 3:</p><pre>ssthresh = max (FlightSize / 2, 2*SMSS) (3)</pre><p>Как было отмечено выше, FlightSize показывает количество данных, которые еще находятся в сети (переданы, но не подтверждены).</p><p class="note">Примечание для разработчиков: Легко ошибиться и использовать cwnd вместо FlightSize, что может в некоторых реализациях приводить к увеличению порога до значений, превышающих rwnd.</p><p>Более того, при возникновении тайм-аута необходимо устанавлив ать для размера окна насыщения cwnd значение, не превышающее размер окна потерь LW, которое равно 1 полноразмерному сегменту (независимо от значения IW). Следовательно, после повтора передачи отброшенного сегмента отправитель TCP использует замедленный старт для увеличения окна от 1 полноразмерного сегмента до нового значения ssthresh, после чего снова включается механизм предотвращения перегрузки.</p><h3>3.2 Fast Retransmit/Fast Recovery</h3><p>Получателю TCP следует незамедлительно передавать дубликат ACK при получении сегмента с нарушением порядка доставки. Это делается для того, чтобы с помощью пакета ACK информировать отправителя о том, что сегмент был получен с нарушением порядка и указать порядковый номер ожидаемого сегмента. С точки зрения отправителя дубликат ACK может быть вызван различными проблемами в сети. Во-первых, причиной может служить отбрасывание сегментов. В этом случае все сегменты после отброшенного будут порождать дубликаты ACK. Во-вторых, дубликаты ACK могут быть обусловлены нарушением порядка доставки сегментов (например, при доставке по разным путям [Pax97]). Наконец, причиной дубликатов ACK может быть репликация пакетов ACK или сегментов данных в сети. В дополнение к сказанному получателю TCP следует незамедлительно передавать подтверждение ACK при получении сегмента, который полностью или частично заполняет пропуски в порядковых номерах. Это позволит предоставить своевременную информ ацию отправителю, выполняющему восстановление после потери с использованием тайм-аута повторной передачи (retransmission timeout), быстрого повтора (fast retransmit) или экспериментального алгоритма восстановления (loss recovery) типа NewReno [RFC2582].</p><p>Отправителю TCP следует использовать алгоритм быстрого повтора для детектирования потери и исправления ошибки с использованием входящих дубликатов ACK. Алгоритм быстрого повтора использует прибытие 3 дубликатов ACK (4 идентичных подтверждения ACK без доставки между ними каких-то других пакетов) как индикацию потери сегмента. После получения 3 дубликатов ACK протокол TCP выполняет повторную передачу сегмента, который представляется потерянным, без ожидания завершения отсчета по таймеру повтора передачи.</p><p>После того, как алгоритм быстрого повтора передаст те данные, которые представляются включенными в отсутствующий сегмент, алгоритм "быстрого восстановления ("fast recovery") регулирует передачу новых данных, пока не будет получено подтверждение ACK, не являющееся дубликатом. Алгоритм замедленного старта не используется по той причине, что получение дубликатов ACK не только указывает на потерю сегмента, но и говорит о высокой вероятности того, что сегменты покинули сеть (хотя массированное дублирование сегментов в сети может сделать такое допущение некорректным). Иными словами, поскольку получатель может генерировать дубликат ACK только при получении сегмента, этот сегмент покинул сеть и находится в приемном буфере, более не потребляя ресурсов сети. Более того, поскольку "синхронизация" ACK сохраняется [Jac88], отправитель TCP может продолжать передачу новых сегментов (хотя и со сниженным значением cwnd).</p><p>Алгоритмы быстрого повтора и быстрого восстановления обычно реализуются вместе, как описано ниже.</p><ol><li>При получении третьего дубликата ACK устанавливается значение ssthresh, которое не превышает значения выражения 3.</li><li>Повторяется передача потерянного сегмента и устанавливается cwnd = ssthresh + 3*SMSS. Это искусственно "увеличивает" размер окна насыщения на число сегментов (три), которые покинули сеть и буферизованы получателем.</li><li>Для каждого принятого дополнительного дубликата ACK значение cwnd увеличивается на SMS S. Это искусственно увеличивает окно насыщения для того, чтобы отразить выход из сети дополнительных сегментов.</li><li>Передается новый сегмент, если это разрешено значениями cwnd и окна, анонсируемого получателем.</li><li>При получении следующего пакета ACK, подтверждающего новые данные, устанавливается cwnd = ssthresh (значение порога, заданное в п. 1). Это приводит к "уменьшению" размера окна насыщения.</li></ol><blockquote><p>Этому пакету ACK следует быть подтверждением, вызванным повтором с п. 1 в течение одного периода RTT после повтора (хотя подтверждение может прийти быстрей при наличии существенного нарушения порядка доставки сегментов данных на приемной стороне). Кроме того, этому пакету ACK следует подтверждать все промежуточные сегменты, переданные между потерянным сегментом и получением третьего дубликата ACK, если ни один из этих сегментов не был потерян.</p></blockquote><p class="note">Примечание: Известно, что этот алгоритм в общем случае не обеспечивает достаточно эффективного восстановления при множественных потерях в одном "звене" пакетов [FF96]. Один из вариантов решения этой проблемы описан в документе [RFC2582].</p><h3>4. Дополнительные вопросы</h3><h3>4.1 Восстановление передаче после бездействия</h3><p>Хорошо известной проблемой, связанной с описанными выше алгоритмами контроля насыщения TCP, является потенциальная возможность возникновения недопустимых уровней трафика, передаваемого через соединение TCP после сравнительно долгого простоя. После завершения периода бездействия TCP не может использовать ACK-синхронизацию для передачи новых сегментов в сеть, поскольку все подтверждения ACK уже получены из сети. Следовательно, как было сказано ранее, TCP после продолжительного простоя потенциально может передать блок данных размером cwnd со скоростью среды.</p><p>Документ [Jac88] рекомендует использовать замедленный старт для восстановления передачи после сравнительно долгого простоя. Замедленный старт позволяет восстановить ACK-синхронизацию как это делается на начальном этапе работы соединения. Этот механизм довольно широко распространен и работает следующим образом. Когда TCP не получает сегмент в течение времени, превышающего тайм-аут повторной передачи, размер окна насыщения cwnd уменьшается до значения RW перед началом передачи.</p><p>В данном стандарте мы определяем RW = IW.</p><p>Отметим, что нестандартные экспериментальные расширения TCP, определенные в [RFC2414], используют RW = min(IW, cwnd), определяя значение IW в соответствии с приведенным выше уравнением (1).</p><p>Использование принятого последним сегмента для решения вопроса об уменьшении cwnd не приводит к снижению размера окна насыщения cwnd в распространенном случае для продолжительных (persistent) соединений HTTP [HTH98]. В таких случаях сервер WWW получает запрос до того, как данные будут переданы браузеру. Получение запроса ведет к отрицательному результату при проверке бездействия соединения и позволяет TCP начать передачу со значением cwnd, которое может оказаться недопустимо большим.</p><p>Поэтому протоколу TCP следует устанавливать перед началом передачи для окна cwnd значение, не превышающее RW, если протокол TCP не передавал данных в течение времени, превышающего тайм-аут повтора передачи.</p><h3>4.2 Генерация подтверждений</h3><p>На приемной стороне следует использовать алгоритм задержки подтверждений (delayed ACK), описанный в [<a href="../1122.rfc" title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни">RFC1122</a>]. При использовании этого алгоритма для получателя недопустима избыточная задержка генерации подтверждений. В частности, пакеты ACK следует генерировать по крайней мере для каждого второго полноразмерного сегмента и генерация подтверждения должна происходить в течение не более 500 мсек с момента доставки первого неподтвержденного пакета.</p><p>Требование, в соответствии с которым пакеты ACK следует генерировать по крайней мере для каждого второго полноразмерного пакета в документе [<a href="../1122.rfc" title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни">RFC1122</a>] указано в одном месте как "следует", в в другом - как "должно". Ввиду неоднозначности мы будет использовать трактовку "следует". Подчеркнем также, что уровень следует означает, что разработчик может отказаться от выполнения этого требования лишь после тщательной оценки возможных последствий. Обсуждение проблем, связанных с невыполнением требования генерации подтверждений не реже, чем для каждого второго полноразмероного сегмента, приводится в параграфе "Stretch ACK violation" документа [RFC2525].</p><p>В некоторых случаях между отправителем и получателем может отсутствовать согласие по поводу того, что собой представляет полноразм ерный сегмент. Реализация протокола считается совместимой с требованиями этого параграфа, если она передает по крайней мере одно подтверждение каждый раз по получении 2*RMSS байтов новых данных от отправителя (RMSS - максимальный размер сегмента, указанный получателем отправителю, или принятое по умолчанию значение 536 байтов [<a href="../1122.rfc" title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни">RFC1122</a>], если получатель не указал опцию MSS при организации соединения). Отправитель может быть вынужден использовать сегменты меньшего, чем RMSS размера в результате ограничения MTU, path MTU или воздействия иных факторов. В качестве примера рассмотрим случай когда получатель анонсирует RMSS = X байтов, но отправитель использует сегменты меньшего размера Y байтов (Y &lt; X) вследствие ограничения path MTU или значения MTU на стороне отправителя. Получатель будет генерировать подтверждения ACK более редко, если он будет дожидаться доставки 2*X перед генерацией ACK. Очевидно, что подтверждения для 2 сегментов по Y байтов передавались бы чаще. Следовательно, несмотря на то, что не определен специфический алгоритм, для получателя желательно попытаться предотвратить подобные ситуации (например, путем подтверждения каждого второго сегмента независимо от их размера). Повторим еще раз, что недопустима задержка передачи ACK более чем на 500 мсек в результате ожидания доставки второго полноразмерного сегмента.</p><p>Сегменты, доставленные с нарушением порядка, следует подтверждать незамедлительно для того, чтобы ускорить процесс восстановления (loss recovery). Для включения алгоритма ускоренного повтора (fast retransmit) получателю следует незамедлительно передать дубликат ACK при получении сегмента данных после пропуска порядковых номеров. Для обеспечения обратной связи с отправ ителем, выполняющим процедуру восстановления, получателю следует незамедлительно передать подтверждение ACK при получении сегмента, который полностью или частично заполняет пропуски в порядковых номерах.</p><p>Для получателя TCP недопустимо генерировать более одного подтверждения ACK для каждого входящего сегмента, если это подтверждение не является обновлением предлагаемого размера окна в тех случаях, когда принимающее приложение забирает новые данные [RFC813], [<a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">RFC793</a>].</p><h3>4.3 Механизмы восстановления при потере</h3><p>Исследователями TCP было предложено множество алгоритмов восстановления при потере сегментов (loss recovery), повышающих эффективность работы алгоритмов fast retransmit и fast recovery. Некоторые из таких алгоритмов (например, [FF96], [MM96a], [MM96b]) основаны на использовании опции избирательных подтверждений (TCP selective acknowledgment или SACK) [RFC2018], а для других SACK не требуется [FF96], [RFC2582], [Hoe96]. Алгоритмы, работающие без SACK, используют "частичные подтверждения" (пакеты ACK, которые подтверждают новые данные, но не подтверждают пропущенные при наличии потерь) для включения механизма повтора передачи. Хотя данный документ не стандартизует ни один из алгоритмов, которые могут повышать эффективность fast retransmit/fast recovery, такие алгоритмы неявно разрешены, если они соответствуют общим принципам базовых алгоритмов, описанных выше.</p><p>Следовательно, при обнаружении первой потери данных в окне, для ssthresh должно быть установлено значение, не превышающее значение выражения (3). Далее, пока все сегменты в окне данных не будут восстановлены, число сегментов, передаваемых в течение каждого периода RTT должно быть не более половины от числа остававшихся на момент обнаружения потери сегментов. И, наконец, после успешной передачи всех потерянных сегментов в данном окне для параметра cwnd должно быть установлено значение, не превышающее ssthresh, и для дальнейшего увеличения cwnd должен использоваться механизм предотвращения перегрузки. Потери в двух последовательных окнах данных или потерю при повторе передачи следует трактовать как двухкратную индикацию насыщения и, следовательно, значения cwnd и ssthresh должны в таких случаях уменьшаться дважды.</p><p>Алгоритмы, описанные в [FF96], [Hoe96], [MM96a], [MM96b], соответствуют принципам четырех базовых алгоритмов контроля насыщения, определенных в данном документе.</p><h3>5. Вопросы безопасности</h3><p>Данный документ требует от реализации TCP снижать скорость передачи при возникновении тайм-аутов повтора (retransmission timeout) и доставке дубликатов подтверждений. Атакующий может оказывать негативное влияние на работу соединений TCP, организуя потерю пакетов данных или подтверждений, а также путем фабрикации избыточных дубликатов подтверждений. Таким способом можно добиться снижения ssthresh до миним ального значения 2*SMSS, заставляющего соединение незамедлительно переходить в фазу предотвращения перегрузки с соответствующим снижением скорости передачи данных.</p><p>Работа Internet в значительной степени основана на корректности реализации этих алгоритмов, обеспечивающих стабильность сети и предотвращение коллапса в результате насыщения. Атакующий может заставить конечные точки TCP отвечать более агрессивно на угрозу насыщения путем фабрикации избыточных дубликатов подтверждений или избыточных подтверждений для новых данных. Концептуально такая атака может привести к связанному с насыщением коллапсу для части сети.</p><h3>6. Изменения по сравнению с RFC 2001</h3><p>Данный документ существенно отличается по тексту от своего предшественника и задача создания списка различий трудно разрешима. Назначение данного документа заключается не в изменении рекомендаций <a href="../2001.rfc" title="RFC 2001 - Алгоритмы Slow Start, Congestion Avoidance, Fast Retransmit, и Fast Recovery для протокола TCP">RFC 2001</a>, а в дальнейшем прояснении ситуаций, которые не были детально рассмотрены в <a href="../2001.rfc" title="RFC 2001 - Алгоритмы Slow Start, Congestion Avoidance, Fast Retransmit, и Fast Recovery для протокола TCP">RFC 2001</a>. В частности, данный документ предлагает реализациям TCP способ выхода из сравнительно продолжительного простоя, а также оговаривает и уточняет некоторые вопросы генерации подтверждений TCP ACK. И, наконец, значение начального размера окна насыщения увеличено в данной спецификации с одного сегмента до двух.</p><h3>Благодарности</h3><p>Описанные здесь алгоритмы разработал Ван Якобсон (Van Jacobson).</p><p>Часть текста данного документа заимствована из книг "TCP/IP Illustrated, Volume 1: The Protocols" Ричарда Стивенса (W. Richard Stevens) (Addison-Wesley, 1994) и "TCP/IP Illustrated, Volume 2: The Implementation" Гери Райта (Gary R. Wright) и Ричарда Стивенса (Addison-Wesley, 1995). Этот материал включен с разрешения издательства Addison-Wesley.</p><p>Neal Cardwell, Sally Floyd, Craig Partridge и Joe Touch внесли множество полезных предложений.</p><h3>Литература</h3><table itemprop="references"><tr><td>[RFC2414]</td><td>Allman, M., Floyd, S. and C. Partridge, «Increasing TCP's Initial Window Size», RFC 2414, September 1998.</td></tr><tr><td>[RFC1122]</td><td>Robert Braden, <a href="../1122.rfc" title="RFC 1122 - Требования к хостам Internet - Коммуникационные уровни">«Требования к хостам Internet - Коммуникационные уровни», RFC 1122</a>, Октябрь 1989.</td></tr><tr><td>[RFC2119]</td><td>Scott Bradner, <a href="../2119.rfc" title="RFC 2119 - Ключевые слова для обозначения уровня требований в RFC">«Ключевые слова для обозначения уровня требований в RFC», RFC 2119</a>, Март 1997.</td></tr><tr><td>[RFC813]</td><td>Clark, D., «Window and Acknowledgment Strategy in TCP», RFC 813, July 1982.</td></tr><tr><td>[FF96]</td><td>Fall, K. and S. Floyd, «Simulation-based Comparisons of Tahoe, Reno and SACK TCP», Computer Communication Review, July 1996. ftp://ftp.ee.lbl.gov/papers/sacks.ps.Z.</td></tr><tr><td>[RFC2582]</td><td>Floyd, S. and T. Henderson, «The NewReno Modification to TCP's Fast Recovery Algorithm», RFC 2582, April 1999.</td></tr><tr><td>[Flo94]</td><td>Floyd, S., «TCP and Successive Fast Retransmits. Technical report», October 1994. ftp://ftp.ee.lbl.gov/papers/fastretrans.ps.</td></tr><tr><td>[Hoe96]</td><td>Hoe, J., «Improving the Start-up Behavior of a Congestion Control Scheme for TCP», In ACM SIGCOMM, August 1996.</td></tr><tr><td>[HTH98]</td><td>Hughes, A., Touch, J. and J. Heidemann, «Issues in TCP Slow-Start Restart After Idle», Work in Progress.</td></tr><tr><td>[Jac88]</td><td>Jacobson, V., «Congestion Avoidance and Control», Computer Communication Review, vol. 18, no. 4, pp. 314-329, Aug. 1988. ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z.</td></tr><tr><td>[Jac90]</td><td>Jacobson, V., «Modified TCP Congestion Avoidance Algorithm», end2end-interest mailing list, April 30, 1990. ftp://ftp.isi.edu/end2end/end2end-interest-1990.mail.</td></tr><tr><td>[RFC1191]</td><td> Jeffrey Mogul и Steve Deering, <a href="../1191.rfc" title="RFC 1191 - Исследование MTU на пути следования сообщения">«Исследование MTU на пути следования сообщения», RFC 1191</a>, Ноябрь 1990.</td></tr><tr><td>[MM96a]</td><td>Mathis, M. and J. Mahdavi, «Forward Acknowledgment: Refining TCP Congestion Control», Proceedings of SIGCOMM'96, August, 1996, Stanford, CA. Available fromhttp://www.psc.edu/networking/papers/papers.html</td></tr><tr><td>[MM96b]</td><td>Mathis, M. and J. Mahdavi, «TCP Rate-Halving with Bounding Parameters», Technical report. Available from http://www.psc.edu/networking/papers/FACKnotes/current.</td></tr><tr><td>[RFC2018]</td><td>Mathis, M., Mahdavi, J., Floyd, S. and A. Romanow, «TCP Selective Acknowledgement Options», RFC 2018, October 1996.</td></tr><tr><td>[RFC2525]</td><td>Paxson, V., Allman, M., Dawson, S., Fenner, W., Griner, J., Heavens, I., Lahey, K., Semke, J. and B. Volz, «Known TCP Implementation Problems», RFC 2525, March 1999.</td></tr><tr><td>[Pax97]</td><td>Paxson, V., «End-to-End Internet Packet Dynamics», Proceedings of SIGCOMM '97, Cannes, France, Sep. 1997.</td></tr><tr><td>[RFC793]</td><td>J. Postel, <a href="../793.rfc" title="RFC 793 - Протокол управления передачей (TCP)">«Протокол управления передачей (TCP)», RFC 793</a>, Сентябрь 1981.</td></tr><tr><td>[Ste94]</td><td>Stevens, W., «TCP/IP Illustrated, Volume 1: The Protocols», Addison-Wesley, 1994.</td></tr><tr><td>[RFC2001]</td><td>W. Stevens, <a href="../2001.rfc" title="RFC 2001 - Алгоритмы Slow Start, Congestion Avoidance, Fast Retransmit, и Fast Recovery для протокола TCP">«Алгоритмы Slow Start, Congestion Avoidance, Fast Retransmit, и Fast Recovery для протокола TCP», RFC 2001</a>, Январь 1997.</td></tr><tr><td>[WS95]</td><td>Wright, G. and W. Stevens, «TCP/IP Illustrated, Volume 2: The Implementation», Addison-Wesley, 1995.</td></tr></table><h3>Адреса авторов</h3><p>Mark Allman<br />NASA Glenn Research Center/Sterling Software<br />Lewis Field<br />21000 Brookpark Rd. MS 54-2<br />Cleveland, OH 44135<br />216-433-6586<br />EMail: <bdo dir="rtl">&#118;&#111;&#103;&#46;&#97;&#115;&#97;&#110;&#46;&#99;&#114;&#103;&#64;&#110;&#97;&#109;&#108;&#108;&#97;&#109;</bdo><br />http://roland.grc.nasa.gov/~mallman</p><p>Vern Paxson<br />ACIRI / ICSI<br />1947 Center Street<br />Suite 600<br />Berkeley, CA 94704-1198<br />Phone: +1 510/642-4274 x302<br />EMail: <bdo dir="rtl">&#103;&#114;&#111;&#46;&#105;&#114;&#105;&#99;&#97;&#64;&#110;&#114;&#101;&#118;</bdo></p><p>W. Richard Stevens<br />1202 E. Paseo del Zorro<br />Tucson, AZ 85718<br />520-297-9416<br />EMail: <bdo dir="rtl">&#109;&#111;&#99;&#46;&#97;&#108;&#97;&#104;&#111;&#107;&#64;&#115;&#110;&#101;&#118;&#101;&#116;&#115;&#114;</bdo><br />http://www.kohala.com/~rstevens</p></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 2581 - Контроль насыщения в TCP",disqus_identifier="2581.rfc",disqus_url="http://rfc2.ru/2581.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>