<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="../tpl/style.css@f4e332aa" type="text/css" /><link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /><style type="text/css">h1,h2,h3,h4{font-family:'Open Sans',sans-serif}</style><link rel="canonical" href="../903.rfc" /><meta name="Robots" content="noindex, nofollow" /><title>Перевод RFC 903 — Протокол RARP</title><link rel="alternate" type="application/rss+xml" title="RFC2.ru - Русские Переводы RFC" href="../rss.xml"></head><body><div id="content"><div id="nav"><div class="icon i0"></div> <a href="../index.html" accesskey="`">На Главную</a></div><div id="search" class="ya-site-form ya-site-form_inited_no"><form action="http://yandex.ru/sitesearch" method="get" target="_blank"><input type="hidden" name="searchid" value="2154295"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="hidden" name="submit" value="Найти"/><input type="search" value="" name="text" placeholder="Поиск по RFC2.ru" /></form></div><div itemscope itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="inLanguage" content="ru" /><meta itemprop="editor" content="ru" /><div id="header"><h1><a itemprop="headline" href="../903.rfc">RFC 903 — Протокол RARP</a></h1></div><dl class="mute"><dt></dt><dd><div class="icon i1"></div> RFC: 903</dd><dd><div class="icon i3"></div> Оригинал: <a href="original" target="_blank" rel="nofollow"><span itemprop="alternativeHeadline">A Reverse Address Resolution Protocol</span></a></dd><dd><div class="icon i2"></div> Категория: <span itemprop="articleSection">Стандарт Интернета</span></dd><dd><div class="icon i4"></div> Дата публикации: <time itemprop="datePublished" datetime="1984-06-01">Июнь 1984</time></dd><dd><div class="icon i5"></div> Авторы: <span itemprop="author">Finlayson</span>, <span itemprop="author">Mann</span>, <span itemprop="author">Mogul</span>, <span itemprop="author">Theimer</span></dd><dd><div class="icon i6"></div> Перевод: <span itemprop="editor">Николай Малых</span></dd></dl><div id="text" itemprop="articleBody"><h3>Статус документа</h3><p>В этом документе описывается метод, позволяющий станциям динамически определять свой адрес протокольного уровня (например, IP) по известному аппаратному адресу.</p><p>Документ содержит спецификацию стандарта, предложенного сообществу ARPA Internet и является приглашением к дискуссии в целях развития стандарта.</p><h2>I. Введение</h2><p>Хосты типа бездисковых станций зачастую не знают свой протокольный адрес в момент загрузки, но им обычно известен аппаратный адрес сетевого интерфейса. Для взаимодействия с протоколами вышележащих уровней (например, IP) хост должен узнать свой протокольный адрес из некого внешнего источника. Проблема заключается в отсутствии стандартного механизма получения адреса.</p><p>Разработанный Пламмером (Plummer) протокол ARP [<a href="../826.rfc" title="RFC 826 - Протокол преобразования адресов Ethernet (ARP)">RFC826</a>] предназначен для решения обратной задачи — определения аппаратного адреса хоста по его протокольному адресу. В данном документе описывается протокол обратного преобразования адресов RARP. Как м в случае ARP, предполагается широковещательная сетевая среда, подобная Ethernet.</p><h2>II. Вопросы реализации протокола</h2><p>Ниже приведены рекомендации по реализации протокола RARP.</p><ul class="dot"><li>Преобразования ARP и RARP отличаются одно от другого. ARP предполагает, что каждый хост знает связь между своими аппаратными протокольными адресами. Информация о связях между аппаратными и протокольными адресами других хостов собирается в специальном кэше. Все хосты сети с точки зрения ARP имеют одинаковый статус (не требуется деление на серверы и клиентов). Для преобразования RARP требуется один или несколько серверов, поддерживающих базу данных о связях между аппаратными и протокольными адресами хостов и отвечающих на запросы адресов от клиентских хостов.</li><li>Как было отмечено, преобразование RARP требует наличия серверов, поддерживающих большие базы данных. Нежелательно, а в некоторых случаях просто невозможно поддерживать такие базы данный в ядре операционной системы хостов. Таким образом, большинство реализаций будут требовать того или иного взаимодействия с программой, не входящей в ядро.</li><li>Для протокола важна простота реализации и минимальное воздействие на существующие программы. Было бы ошибкой предлагать протокол, который потребует модификации программ каждого хоста, независимо от того, будет ли этот протокол использоваться на данном хосте.</li><li>Желательно использование фрагментов кода существующих программ в целях минимизации усилий по разработке и нижения расходов.</li></ul><h2>III. Предлагаемый протокол</h2><p>Предлагается выполнять преобразование RARP с помощью отдельного протокола канального уровня. Например, для сред Ethernet пакеты RARP будут иметь значение поля Ethertype (которое будет выделено для этого протокола), отличающееся от ARP. Это будет указывать, что преобразования ARP и RARP различаются фундаментально и поддерживаются хостами по-разному. Воздействие на существующие системы минимально — существующие серверы ARP не будут вводиться в заблуждение пакетами RARP. Этот делает RARP самостоятельным протоколом, который может применяться для отображения аппаратных адресов на адреса любых протоколов вышележащего уровня.</p><p>Это приближение обеспечивает простоту реализации клиентской части RARP, но разработка RARP-серверов потребует более значительный усилий. Однако, эти трудности не являются непреодолимыми, как показано в Приложении A, где даны наброски двух вариантов реализации протокола для 4.2BSD Unix.</p><p>RARP использует такой же формат пакетов, как протокол ARP, а именно:</p><pre>ar$hrd  (пространство аппаратных адресов) - 16 битов
ar$pro  (пространство протокольных адресов) - 16 битов
ar$hln  (размер аппаратного адреса) - 8 битов
ar$pln  (размер протокольного адреса) - 8 битов
ar$op   (код операции) - 16 битов
ar$sha  (аппаратный адрес отправителя) - n байтов
ar$spa  (протокольный адрес отправителя) - m байтов
ar$tha  (аппаратный адрес получателя) - n байтов
ar$tpa  (протокольный адрес получателя) - m байтов</pre><p>Поля ar$hrd, ar$pro, ar$hln и ar$pln имеют такой же смысл, как для протокола ARP (см. [<a href="../826.rfc" title="RFC 826 - Протокол преобразования адресов Ethernet (ARP)">RFC826</a>]).</p><p>Предположим, что в качестве аппаратного используется 48-битовый адрес Ethernet, а в качестве протокольного — 32-битовый адрес IP. Нам требуется определить адрес IP, соответствующий известному адресу Ethernet. В этом случае для каждого пакета RARP выполняются равенства ar$hrd = 1 (Ethernet), ar$pro = 2048 (Ethertype для пакетов IP), ar$hln = 6, ar$pln = 4.</p><p>Протокол использует два кода операций: 3 (request reverse — запрос обратного преобразования) и 4 (reply reverse — отклик на запрос обратного преобразования). Коды операций 1 и 2 имеют такой же смысл, как указано в [<a href="../826.rfc" title="RFC 826 - Протокол преобразования адресов Ethernet (ARP)">RFC826</a>] — пакеты с такими кодами могут передаваться с использованием обычных программ ARP. Пакеты с любыми другими кодами операций являются ошибочными. Как и ARP, данный протокол не использует пакетов not found (не найдено) или error (ошибка), поскольку серверы RARP не обязаны отвечать на полученные запросы. Отправитель запроса RARP должен задавать для себя время ожидания (timeout) отклика на переданный запрос.</p><p>Поля ar$sha, ar$spa, $ar$tha и ar$tpa в пакетах RARP интерпретируются следующим образом:</p><p>Для пакетов с кодом операции 3 (request reverse):</p><pre>ar$sha — аппаратный адрес отправителя пакета.
ar$spa — не определено.
ar$tha — аппаратный адрес получателя.
ar$tpa — не определено.</pre><p>Для пакетов с кодом операции 4 (reply reverse):</p><pre>ar$sha — аппаратный адрес отвечающего хоста.
ar$spa — протокольный адрес отвечающего хоста.
ar$tha — аппаратный адрес получателя.
ar$tpa — протокольный адрес получатель (то, что было запрошено).</pre><h2>IV. Литература</h2><table itemprop="references"><tr><td>[RFC826]</td><td>David C. Plummer, <a href="../826.rfc" title="RFC 826 - Протокол преобразования адресов Ethernet (ARP)">«Протокол преобразования адресов Ethernet (ARP)», RFC 826</a>, Ноябрь 1982.</td></tr></table><h2>Приложение A. Два примера реализации протокола для 4.2BSD Unix</h2><p>Ниже приведены два наброска различных вариантов реализации сервера RARP для 4.2BSD.</p><ul class="dot"><li><p>Обеспечивается доступ к пакетам канального уровня за пределами ядра. Сервер RARP полностью реализуется за пределами ядра и взаимодействует с ядром только для приема или передачи пакетов RARP. Ядро изменяется так, чтобы обеспечивался требуемый доступ к пакетам RARP; в настоящее время ядро 4.2 обеспечивает доступ только для пакетов IP. Одним из существующих механизмов, которые обеспечивают возможность доступа к пакетам является псевдо-драйвер пакетного фильтра CMU. Этот драйвер успешно используется в CMU и Стэнфорде (Stanford) для реализации подобных серверов в пользовательском пространстве.</p></li><li><p>Создается кэш записей базы данных внутри ядра. Полная база данных сервера RARP поддерживается пользовательским процессом за пределами ядра. Сам сервер RARP реализуется в ядре и использует в откликах содержимое кэша записей. Кэш может быть таким же, какой используется для пересылки ARP. Кэш заполняется записями из базы данных с использованием двух новых операций ioctl (они подобны SIOCIFADDR в том, что реально не связываются с конкретным сокетом). Одна из операций обеспечивает нахождение в «спящем» режиме при отсутствии транзакций, а при появлении запросов передает их пользовательскому процессу, а вторая заносит запись этой транзакции в таблицу ядра. Таким образом, если ядро не может найти запись в кэше, оно помещает запрос в (глобальную) очередь и вызывает функцию wakeup(). Реализация первой операции ioctl включает вызов sleep(), считывание из очереди первого объекта т возврата его пользовательскому процессу. Поскольку ядро не может находится в состоянии ожидания на уровне прерывания, пока пользовательский процесс ответит, оно может отказаться от обработки запроса (в предположении, что клиент повторит запрос) или, если вторая операция ioctl передаст копию запроса обратно в ядро, сформировать и передать отклик на этот запрос.</p></li></ul></div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname="rfc2",disqus_title="RFC 903 - Протокол RARP",disqus_identifier="903.rfc",disqus_url="http://rfc2.ru/903.rfc";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src = "//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><div class="bubble">2007 - 2014 © <a href="../index.html" title="Русские переводы RFC">Русские переводы RFC</a>, IETF, ISOC.</div></div><div id="bottom" style="position:static !important;bottom:auto !important"><div class="bubble"><ul><li><!--723572853672--></li></ul></div></div><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter4680559 = new Ya.Metrika({id:4680559, webvisor:true, clickmap:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="http://mc.yandex.ru/watch/4680559?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>