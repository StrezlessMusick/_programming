>> conguestion - затор
>> beneficial - выгодный

1. введение
>> enhancement - усиление, усовершенствование
>> remain - оставаться
>> avoid - избегать
>> avoidance - уклонение

2. EFSM/SDL notation
>> augment - расширять

3. TCP SDL model
>> compartment - отсек, отделение
>> precedence - приоритет
>> smooth - гладкий

4. другие варианты TCP

>> conclude - заключать
5. заключение
====================================================
=== состояния ===
CLOSED 			Начальное состояние узла. Фактически фиктивное
LISTEN 			Сервер ожидает запросов установления соединения от клиента
SYN-SENT 		Клиент отправил запрос серверу на установление соединения и ожидает ответа
SYN-RECEIVED 	Сервер получил запрос на соединение, отправил ответный запрос и ожидает подтверждения

ESTABLISHED 	Соединение установлено, идёт передача данных

FIN-WAIT-1 		Одна из сторон (назовём её узел-1) завершает соединение, отправив сегмент с флагом FIN
CLOSE-WAIT 		Другая сторона (узел-2) переходит в это состояние, отправив, в свою очередь сегмент ACK и продолжает одностороннюю передачу
FIN-WAIT-2 		Узел-1 получает ACK, продолжает чтение и ждёт получения сегмента с флагом FIN
LAST-ACK 		Узел-2 заканчивает передачу и отправляет сегмент с флагом FIN
TIME-WAIT 		Узел-1 получил сегмент с флагом FIN, отправил сегмент с флагом ACK и ждёт 2*MSL секунд, перед окончательным закрытием соединения
CLOSING 		Обе стороны инициировали закрытие соединения одновременно: 
					после отправки сегмента с флагом FIN узел-1 также получает сегмент FIN, 
					отправляет ACK и находится в ожидании сегмента ACK (подтверждения на свой запрос о разъединении)
.
=== события ===
от пользователя:
	ActiveOPEN	активно открыть
	PassiveOPEN	пассивно открыть
	SEND		послать
	RECEIVE		принять
	CLOSE		закрыть
	ABORT		прервать
получение сегментов:
	SYN
	ACK
	RST
	FIN
от таймеров (внутренние):
	таймер передачи
	TIME-WAIT таймер
	пользовательский аймер
.
=== выходные сигналы ===
	вернуть (сообщение)
	вернуть ошибку (сообщение об ошибке)
	сигнал пользователю (сообщение)
	сегмент (SEG)
.
=== переменные ===
сегмента
	SEG.SEQ		номер сегмента в последовательности
	SEG.ACK		номер подтверждения в последовательности
	SEG.LEN		длина сегмента
	SEG.WND		окно сегментов (сообщается приемником)
	SEG.CTL		биты контроля (ACK,RST,SYN,FIN)
переменные посылаемой последовательности
	SND.UNA		(unack) посланное - неподтвержденное
	SND.NXT		следующая посылка (?)
	SND.WND		окно посылки
	ISS			init. send seq. num. 	стартовый номер в посылаемой последовательности
переменные принимаемой последовательности
	RCV.NXT		следующий прием. (?)
	RCV.WND		принимамое окно
	IRS			init. receiv sec.num 	стартовый номер в принимаемой последовательности
таймеры
	RETR-TIMEOUT		таймер передачи
	TIMEWAIT-TIMEOUT	
	USERTIME-TIMEOUT
счетчики
	dACK		счетчик дубликатов подтверждений
	>> backoff - отсрочка
	ExpBoff		exponential backoff counter
прочие
	CurrState	текущее		состояние
	PrevState	предыдущее 	состояние
	RTO			Retransmission TimeOut - переменная таймера передачи
	RTT			Round Trip Time - время путешествия аокруг - используется для вычисления RTO
	SRTT		Smoothed RTT - сглаженное RTT
	CWND		conguestion WND - окно затора
	MSS			Maximum segment size - максимальный размер сегмента
	>> threshold - порог
	SSTrash		Slow Start Threshold - порог медленного старта
	MSL			Maximum Segment Lifetime - максимальное время жизни сегмента
буфера
	...
.
=== предположения ===
текущее и предыдущее состояние запоминается в переменных CurrState & PrevState
размер буферов неограничен
в любом состоянии, когда сегмент послан, сегмент добавляется в "очередь передачи", и стартует RETR таймер
событие RETR-TIMEOUT может произойти в любом сотоянии за исключением (FIN-WAIT-2, FIM-WAIT, CLOSED)
	т.к. в этих состояниях endpoint уже принял ACK его FIN сегмента (т.е. больше не ожидается прием сегментов)
событие TIME-WAIT-TIMEOUT присутствует только в состоянии TIME_WAIT
.
=== не замоделированное ===
безопасность/отсекание и приоритеты
пользовательский вызов STATUS
механизм проталкивания - PUSH, PSH-bit
и механизм срочности - URGENT, URG-bit
.
=== МОДЕЛЬ ===
TCB - блок управления передачей, содержащий информацию о соединении
сегмент<номер,номер подтверждения,б|и|т|ы>
макро: проверка SEQ семента
макро: обработка бита FIN
макро: обновление окна
ЛЮБОЕ-СОСТОЯНИЕ 
	->USRTIME-TIMEOUT
		если есть выдающиеся (?) события															//???
		то 	СИГНАЛ пользователю: ошибка, соединение прервано всвязи с пользовательским таймером
		послать/выдать (flush) все очереди
		удалить TCB
		ПЕРЕЙТИ в состояние CLOSED
CLOSED
	->пользователь хочет OPEN
		если открыть активно
		то	если сокет абонета (с которым связываемся) задан
			то	создать и инициализировать TCB
				выбрать новый ISS
				ПОСЛАТЬ сегмент <ISS,,SYN>
				SND.UNA=ISS
				SND.NXT=ISS+1
				ПЕРЕЙТИ в состояние SYN-SEND
			иначе	
				ОШИБКА пользователю: сокет не задан
		иначе
			создать и инциализовать TCB
			//пассивное открытие не требует задания сокета абонента
			//он может быть заполнен приходящим сообщением SYN
	->ПРИНЯТ сегмент
		если SEG.ACK
		то	ПОСЛАТЬ сегмент <SEG.SEQ+SEG.LEN,,RST|ACK>
		иначе
			ПОСЛАТЬ сегмент <,,ACK|RST>
	->пользователь хочет CALL
		ОШИБКА пользователю: соединение отсутствует
	->пользователь хочет RECEIVE
		ОШИБКА пользователю: соединение отсутствует
	->пользователь хочет CLOSE
		ОШИБКА пользователю: соединение отсутствует
	->пользователь хочет ABORT
		ОШИБКА пользователю: соединение отсутствует
	->пользователь хочет SEND
		???
LISTEN
	-> пользователь хочет OPEN
		если внешний сокет задан
		то	//смена соединения с пассивного на активное
			создать и инициализировать TCB
			выбрать новый ISS
			ПОСЛАТЬ сегмент <ISS,,SYN>
			SND.UNA=ISS
			SND.NXT=ISS+1
			ПЕРЕЙТИ в состояние SYN-SEND
		иначе
			ОШИБКА пользователю: сокет абонента не задан
	-> пользователь хочет SEND
		если внешний сокет задан
		то	//смена соединения с пассивного на активное
			создать и инициализировать TCB
			поместить данные (если меются) в очередь отправителя //для передачи через состояние ESTABLISHED
			выбрать новый ISS
			ПОСЛАТЬ сегмент <ISS,,SYN>
			SND.UNA=ISS
			SND.NXT=ISS+1
			ПЕРЕЙТИ в состояние SYN-SEND
		иначе
			ОШИБКА пользователю: сокет абонента не задан
	-> пользователь хочет RECEIVE
		в очередь для обработки после входа в состояние ESTABLISHED
	-> пользователь хочет CLOSE
		если есть что-то принятое в очереди
		то	ОШИБКА пользователю: connection closed
		удалить TCB
		ПЕРЕЙТИ в состояние CLOSED
	

















