<HTML><HEAD>
<TITLE>Калашников.ru - Ассемблер? Это просто!.. (Выпуск № 010)</TITLE>
<BODY aLink=#000000 bgColor=#ebd2a5 link=#660000 text=#000000 vLink=#000000>

<P align=center><A 
href="http://ad.ir.ru/bb.cgi?cmd=go&pubid=128269&pg=2&vbn=10001&nocache=77524" 
target=_top><IMG alt="InterReklama " border=0 
src="http://ad.ir.ru/bb.cgi?cmd=ad&pubid=128269&pg=2&vbn=10001&nocache=77524"></A></P>
<P align=center><A href="http://www.ir.ru" target=_top><FONT size=1>InterReklama 
Advertising</FONT></A> </P>
<HR>

<div align="center"><center>

<table border="3" cellpadding="2" cellspacing="3" width="100%"
bgcolor="#8FD0DA" bordercolor="#000080">
<tr>
<td><table border="4" width="100%" bgcolor="#28756D">
<tr>
<td><p align="center"><font size="5"><strong>Здравствуйте,
дорогие любители
Ассемблера!</strong></font></p>
<hr>
<p align="center"><font size="4"><strong>Выпуск
№ 010</strong></font></p>
</td>
</tr>
</table>
<p align="right"><font size="2"><em>Пей пиво на
заре, пей пиво перед сном,</em></font></p>
<p align="right"><font size="2"><em>Пей пиво на
траве, пей пиво за столом,</em></font></p>
<p align="right"><font size="2"><em>Пей пиво натощак, пей пиво со хмеля,</em></font></p>
<p align="right"><font size="2"><em>Пей пиво
просто так, пей как
&quot;Авария&quot;!</em></font></p>
<p align="right"><font size="2"><em><strong>Пей
пиво!</strong></em></font></p>
<p align="right"><strong>&quot;Дискотека
&quot;Авария&quot;.</strong></p>
<hr>
<p align="center"><font color="#000040" size="5"><strong>Что
у нас сегодня?</strong></font></p>
<ul>
<li><p align="left"><a href="#hello"><font
color="#800040" size="3"><strong>Приветствие</strong></font></a></p>
</li>
<li><p align="left"><a href="#letters"><font
color="#800040" size="3"><strong>Ваши
письма</strong></font></a></p>
</li>
<li><p align="left"><a href="#prevprog"><font
color="#800040" size="3"><strong>Программа
из прошлого выпуска</strong></font></a></p>
</li>
<li><p align="left"><a href="#voting"><font
color="#800040" size="3"><strong>Голосование</strong></font></a></p>
</li>
<li><p align="left"><a href="#virus"><font
color="#800040" size="3"><strong>Вирус</strong></font></a></p>
</li>
<li><p align="left"><a href="#resident"><font
color="#800040" size="3"><strong>Резидент</strong></font></a></p>
</li>
<li><p align="left"><a href="#questions"><font
color="#800040" size="3"><strong>Блиц-опрос</strong></font></a></p>
</li>
</ul>
<hr>
<p align="center"><a name="hello"><font color="#000040"
size="5"><strong>Привет, друзья мои!</strong></font></a></p>
<p>Почему я с пива-то начал? Да
вот почему: в настоящий момент
есть <em><strong><u>четыре</u></strong></em>
хорошие новости:</p>
<p><font size="5"><strong>1.</strong></font><strong> В
позапрошлый понедельник (то
бишь, </strong><font color="#800040"><strong>18
сентября 2000 года</strong></font><strong>)
у меня родился сын! С чем вы и
можете меня и мою жену </strong><a
href="oleg77@beep.ru?Subject=Поздравляю"><strong>поздравить</strong></a><strong>.
Одним Калашниковым стало
больше. Ну, и, естественно, это
дело отмечалось &quot;по полной
программе&quot;. Пиво текло рекой
(особенно мое любимое - &quot;</strong><a
href="http://www.baltika.ru"><strong>девятка</strong></a><strong>&quot;)...</strong></p>
<p><font size="5"><strong>2.</strong></font> Наша
рассылка продолжает выходить.
Всем спасибо еще раз, кто
проголосовал на сайте <a
href="http://www.Kalashnikoff.ru">www.Kalashnikoff.ru</a>.
Меня очень <u>умиляет</u> Ваше
общение в форуме. С громадным
удовольствием я читал
сообщения. Очень порадовали некоторые решения предыдущей
программы. Просто Супер-8! Но об
этом ниже...</p>
<p><font size="5"><strong>3.</strong></font> Я
нашел классную работу. Теперь
Интернет у меня постоянный (по
световому кабелю). Мне нет
смысла пользоваться услугами
провайдера <a href="http://www.online.ru">России-Он-Лайн</a>.
В связи с этим у меня меняется
адрес электронной почты.
Большая просьба: кто присылал
мне предыдущие сообщения на
адрес oleg77@online.ru, переслать их по
адресу <a href="mailto:oleg77@beep.ru">oleg77@beep.ru</a>.
Спасибо!</p>
<p>Я также благодарю всех, кто
присылал мне предложения по
поводу трудоустройства.
Дорогие мои! <strong>Низкий вам
поклон и море благодарности!!!</strong></p>
<p><font size="5"><strong>4.</strong></font> Наша
рассылка соответствует всем
требованиям, предъявляемым к
рассылкам класса <font color="#FF8040"><em><strong>&quot;золотых&quot;</strong></em></font>.
Так что, я надеюсь, что скоро мы
будем в соответствующем
разряде. Огромное спасибо всем,
кто оставался с нами (т.е. вам
всем).</p>
<hr>
<p align="center"><a name="letters"><font size="5"><strong>Ваши
письма.</strong></font></a></p>
<p align="left">Огромное спасибо всем,
кто прислал мне адреса
бесплатных почтовых серверов.
Поверьте, проверил все, которые
можно. Решил остановиться на <a
href="http://www.beep.ru">www.beep.ru</a> .
Посмотрим, что получится...</p>
<p align="left">___________________</p>
<p align="left">Сообщаю несколько
адресов подписчиков, которые
пожелали разместить e-mail в
рассылке:</p>
<p align="left"><a href="mailto:baddy@fregat.mk.ua">baddy@fregat.mk.ua</a>
- Peter</p>
<p align="left"><a href="mailto:den_nik@ukr.net">den_nik@ukr.net</a>
- Denis</p>
<p align="left">___________________</p>
<p align="left">А вот ниже письмо от
Леонида. Подобных писем пришло
много, поэтому я отвечу на одно
как всем:</p>
<p align="left"><font size="2" face="Arial Cyr"><em>Добрый
день, Олег!</em></font></p>
<p align="left"><font size="2" face="Arial Cyr"><em>Хотелось
бы заняться ассемблером, но не
знаю с чего.</em></font><em> </em><font size="2"
face="Arial Cyr"><em>Подскажи с чего
начать (с нуля); если есть что-то
в электронном виде, то, если не
трудно, вышли.</em></font></p>
<p align="left"><font size="2" face="Arial Cyr"><em>С
уважением Леонид.</em></font></p>
<p align="left">__________________</p>
<p align="left">Уважаемый Леонид!</p>
<p align="left">На нашем сайте ( <a
href="http://www.Kalashnikoff.ru">http://www.Kalashnikoff.ru</a>
) есть некоторые книги в
электронном виде (например,
книга Роберта Джордейна).
Скачайте ее и попробуйте
разобраться. Также прочтите
внимательно ВСЕ предыдущие
выпуски рассылки. Там много
полезной и интересной (я
надеюсь) информации.</p>
<p align="left">_________________</p>
<p align="left">Еще многие спрашивают,
почему я не рекомендую
пользоваться каким-нибудь
специальным текстовым
редактором. Друзья мои!
Текстовых редакторов
существует великое множество.
Я все же настоятельно советую
пользоваться DOS Navigator'ом,
который можно взять на нашем
сайте, т.к. эти спецредакторы
имеют кучу ошибок и недоделок.
Скачивайте, кому нужно!</p>
<hr>
<p align="center"><a name="prevprog"><font size="5"><strong>Программа
из прошлого выпуска.</strong></font></a></p>
<p>Теперь по поводу предыдущего
выпуска. Что у нас была за
программа? Да! Она загружала
саму себя в память. Т.е. поверх
себя (поверх своего кода). Я не
зря просил Вас назвать ее
именно <em>less009.asm</em>. Т.к. если
программа не найдет файл с
данным именем (*.com), то она
просто выйдет, при этом выдаст
звуковой сигнал. Одна девушка,
которая интересуется
программированием на
Ассемблере (да-да, дорогие мои!
В наших рядах есть женщины,
чему я очень рад!), назвала
работу программы
&quot;чертовщиной&quot;. На самом
деле, ничего сложного в ней нет.
Надеюсь, Вы поняли, что в
Ассемблере можно вытворять
невероятные вещи, которые на
языках высокого уровня (Бейсик,
С, Паскаль) недоступны.</p>
<p>Мне очень понравилось
объяснение Александра на
форуме. Я опубликовываю (с
некоторыми добавлениями. Очень
надеюсь, что Александр за это
не будет меня бить ногами):</p>
<p>&nbsp;</p>
<p>; Программа выполняет запись
самой себя в то место памяти,
куда она</p>
<p>; уже загружена. </p>
<p>CSEG segment</p>
<p>assume CS:CSEG, DS:CSEG, ES:CSEG, SS:CSEG</p>
<p>org 100h</p>
<p>Begin:</p>
<p>mov dx,offset File_name ; Открываем файл</p>
<p>call Open_file ; с помощью спецпроцедуры
(см. ниже).</p>
<p>jc Error_file ; Переход на метку
Error_file при неудаче.</p>
<p>mov bx,ax ; Сохраняем
идентификатор файла и</p>
<p>mov ah,3Fh ; начинаем его читать <font
color="#804040"><strong>(то бишь файл).</strong></font></p>
<p>mov cx,offset Finish-100h ; Записываем
длину нашей программы (кол-во
читаемых байт),</p>
<p>mov dx,offset Begin ; и читаем файл в
память,</p>
<p>int 21h ; начиная с указанного
адреса. <font color="#804040"><strong>ВЕРНО!!!!!
(прим. - О. К.)</strong></font></p>
<p>call Close_file ; Закрываем файл с
помощью спецпроцедуры (см.
ниже).</p>
<p>mov ah,9 ; Выводим сообщение об
удачном завершении.</p>
<p>mov dx,offset Mess_ok</p>
<p>int 21h</p>
<p>ret</p>
<p><font color="#804040"><strong></strong></font>&nbsp;</p>
<p><font color="#804040"><strong>; Если файл с
указанным именем не нашли </strong><em><strong>(File_name
db 'less009.com',0)</strong></em><strong>, то
пищим и выходим. (прим. - О. К.)</strong></font></p>
<p>Error_file:</p>
<p>mov ah,2</p>
<p>mov dl,7</p>
<p>int 21h</p>
<p>ret </p>
<p>Open_file proc ; Процедура открытия
файла для чтения,</p>
<p>cmp Handle,0FFFFh ; в которой
выясняется открыт ли файл,</p>
<p>jne Quit_open ; и если не открыт -
открываем его.</p>
<p>mov ax,3D00h</p>
<p>int 21h</p>
<p>mov Handle,ax</p>
<p>ret</p>
<p>Quit_open:</p>
<p>stc ; Устанавливаем флаг
переноса в 1, необходимый</p>
<p>ret ; для подтверждения факта
открытия файла (для jc).</p>
<p>Handle dw 0FFFFh</p>
<p>Open_file endp </p>
<p>&nbsp;</p>
<p>Close_file proc ; Процедура закрытия
файла,</p>
<p>cmp Handle,0FFFFh ; при условии, что он
был открыт.</p>
<p>je No_close</p>
<p>mov ah,3Eh</p>
<p>mov bx,Handle</p>
<p>int 21h</p>
<p>mov Handle,0FFFFh</p>
<p>No_close:</p>
<p>ret</p>
<p>Close_file endp </p>
<p>File_name db 'less009.com',0</p>
<p>Mess_ok db 'Всё нормально!',0Ah,0Dh,'$' ;
0Ah,0Dh - переход в начало
следующей строки,</p>
<p>; типа writeln или puts().</p>
<p>Finish equ $ ; Признак (адрес) конца
кода программы. </p>
<p>&nbsp;</p>
<p>CSEG ends</p>
<p>end Begin</p>
<p>&nbsp;</p>
<p>Подробнее мы рассмотрим
принцип работы подобных
программ позже.</p>
<hr>
<p align="center"><a name="voting"><font size="5"><strong>Голосование.</strong></font></a></p>
<p>Большинство из вас
проголосовало за изучение
Ассемблера таким образом:</p>
<p><em><strong>быстро DOS, а затем Windows</strong></em>.
Я полагаю, что это интереснее и
целесообразнее будет, чем
просто изучить DOS, либо сразу
перейти к Windows. Таким образом,
мы начинаем изучать DOS.</p>
<p>Что же касается программы,
которую мы будем писать,
параллельно изучая Ассемблер,
то результаты такие:</p>
<p>1. Оболочка типа Norton Commander;</p>
<p>2. Вирус;</p>
<p>3. Резидент.</p>
<p>На первое место все же вышла
оболочка, но не на много
обогнав вирус.</p>
<p>Сегодня же у нас экспериментальный выпуск.
Попробуем проходить тему
быстрее положенного. Если
что-то не усвоите - пишите.
Заходите на форум на сайте.
Пишите мне. В конце рассылки я
специально провожу опрос.</p>
<p>Итак, начнем.</p>
<hr>
<p align="center"><a name="virus"><font size="5"><strong>Вирус.</strong></font></a></p>
<p><strong>Что такое вирус?</strong>
Вирус - это программа,
написанная, как правило, на
Ассемблере (хотя есть вирусы,
написанные на Pascal, С и Visual Basic).
Эта программа может сама
размножаться, заражая другие
программы без участия
программиста, который сам же и
написал этот вирус. Как так
может быть? Элементарно!</p>
<p>Писать вирус на Ассемблере -
милое дело. В свое время я писал
вирусы как резидентные
(постоянно находящиеся в
памяти), так и нерезидентные.
Более того, я писал и
антивирусы (против своих же
вирусов, естественно).</p>
<p>Прежде чем перейти к изучению
структуры вируса, я хотел бы
предупредить Вас об <strong><u>уголовной
ответственности</u></strong> за
распространение
вирусоподобных программ. Если
Вы напишите вирус, а затем
выпустите его &quot;в свет&quot;, то
Вас смогут отправить в
&quot;места не столь
отдаленные&quot; (по Российским
законам); например, на Колыму.</p>
<p><strong>Кто пишет вирусы?</strong> Да
все кому не лень! Прежде всего -
это программисты, которые
только-только изучили
Ассемблер, и не видят иной
возможности, как только
написать какой-нибудь вирус и
напакостить своему другу,
соседу и т.д., тем самым проявив
себя. Например, у знакомого
стоит большой Пень-433, а у Вас -
маленькая &quot;тройка&quot;. И Вы
горите желанием его Пень
&quot;заломать&quot;.</p>
<p>Теперь представим другую
ситуацию: у фирмы X есть
конкурент - фирма Y. Как сделать
так, чтобы на время фирме Y
доставить хлопот? А почему бы
их компьютеры не заразить
вирусом &quot;собственного
производства&quot;, который
такого-то числа или при
таких-то обстоятельствах
удалял бы всю информацию на
винчестере? Пишется вирус
сотрудником фирмы X, а затем он
(вирус) заносится в компьютер к
конкуренту. И все! Как правило
заражаются компьютеры не
только фирмы Y, но и другие
(сотрудник переписал
зараженный файл и приес к себе
домой; у него переписал этот же
файл знакомый и т.д.).</p>
<p>Естественно, есть т.н.
антивирусы (DrWeb, Aidstest, Norton Antivirus,
Microsoft Antivirus и пр.). Однако, они
пишутся <strong><u>только</u></strong>
для тех вирусов, котрые знакомы
автору данного антивируса.
Если, допустим, я напишу свой
вирус, то уверяю Вас, что ни
один антивирус его не
обнаружит (максимум, что может
быть - это то, что антивирус
напишет сообщение о <strong><u>возможном</u></strong>
заражении файла, но вылечить
его не сможет!).</p>
<p>Теперь рассмотрим структуру
вируса и принцип его работы.
Цель всего этого - научить Вас
распознавать вирусы и развеять
страх перед ними.</p>
<p><strong>Что должен делать вирус?</strong>
Прежде всего - определить,
загружен ли он с какого-нибудь
файла или это его первая
загрузка (дальше Вы поймете, о
чем идет речь). Затем найти
первый попавшийся файл,
проверить его, заражен ли уже
он или нет, если да, то искать
следующий, а если нет, то
заразить его. Все это
происходит очень быстро и для
пользователя практически
незаметно.</p>
<p><strong>Сколько занимает вирус в
памяти?</strong> Все зависит от
фантазии программиста (что он
хочет сделать с компьютером/файлами). Средний
размер вируса - 500 - 600 байт. Хотя
есть умельцы, у которых вирус
занимает 100 - 150 байт, а есть и
такие, у которых простейший
вирус занимает 1,5 - 3 и более
килобайт.</p>
<p><strong>Что может вирус?</strong> Все,
что угодно! Например, удалить
всю информацию с винчестера за
0,5 - 1 секунду (по принципу
работы Fdisk), спалить монитор,
физически испортить винчестер
и даже убить пользователя (хотя
такого не встречал пока)! Все
зависит от фантазии
программиста...</p>
<p><strong>Какой вирус мы будем
изучать?</strong> Мы будем
рассматривать нерезидентный вирус, заражающий *.com-файлы
(самый простой). Что он будет
делать? Я думаю, ничего
особенного, кроме как
размножения и создания
какой-либо незначительной
помехи для пользователя.</p>
<p><strong>Как оформить вирус?</strong>
Обычно:</p>
<p>CSEG segment</p>
<p>assume cs:CSEG, ds:CSEG, es:CSEG, ss:CSEG</p>
<p>org 100h</p>
<p>Start:</p>
<p>... <em>;здесь находится тело
вируса.</em></p>
<p>CSEG ends</p>
<p>end Start</p>
<p>Т.е. формат обычного *.com-файла,
который Вам уже известен. Можно
создать и *.exe-файл, однако, его
размер будет больше.</p>
<p>Я думаю, что на сегодня с
вирусом хватит. Тем более, что
по результатам ваших опросов,
вирус - это не то, на что бы Вы
хотели сделать акцент при
изучении Ассемблера.</p>
<hr>
<p align="center"><a name="resident"><font size="5"><strong>Резидент.</strong></font></a></p>
<p align="left"><strong>Приступаем к
самому сложному разделу. Будет
действительно сложно. Кто
сможет разобраться - будет
настоящим героем!</strong></p>
<p align="left"><strong>Резидентная
программа (резидент)</strong> -
программа, которая постоянно
находится в памяти. Примером
резидента является драйвер
мыши, Norton Guide, всевозможные
антивирусы, которые следят за
тем, что делает та или иная
программа и сообщают о ее
действиях пользователю и пр.</p>
<p align="left">Как правило,
резидентная программа должна
перехватывать то или иное
прерывание, с тем чтобы
программист или другие
программы могли обратиться к
ней. Давайте поподробнее
рассмотрим прерывания (немного
мы изучали их в предыдущих
выпусках).</p>
<p align="left"><strong>Прерывание</strong> -
это своего рода процедура
(подпрограмма), которая имеет
не название (например, print_string),
а номер. В компьютере есть 256
различных номеров прерываний.
Некоторые номера
зарезервированы BIOS (ПЗУ)
компьютера (например, 16h;
помните: mov ah,10h / int 16h?) или
операционной системой (MS-DOS,
PC-DOS, OS/2) (например, 21h: mov ah,9 / mov
dx,offset String / int 21h).</p>
<p align="left">Тем не менее, ничего не
мешает программисту
перехватить, скажем, 21h
прерывание, тем самым
контролировать кто и что
делает с ним.</p>
<p align="left">Ну например. Выведем
на экран строку:</p>
<p align="left">mov ah,9</p>
<p align="left">mov dx,offset Our_string</p>
<p align="left">int 21h</p>
<p align="left">...</p>
<p align="left">Our_string db 'Привет!$'</p>
<p align="left">Процессор (MS-DOS)
выведет на экран сообщение
&quot;Привет&quot;. А мы можем
перехватить 21h прерывание и,
проследив, что кто-то пытается
вывести строку (не важно,
какую), мы заносим в DX адрес
нашей строки. В таком случае,
все, что бы не выводилось на
экран путем вызова функции 09
прерывания 21h, на экране будет
появляться наша и только наша
строка. Это можно сделать так:</p>
<p align="left">;представим, что это
кусок нашего обработчика 21h
прерывания.</p>
<p align="left">...</p>
<p align="left">cmp ah,9</p>
<p align="left">je Out_str</p>
<p align="left">Go_21h:</p>
<p align="left">; здесь передаем
управление &quot;настоящему&quot;
21h.</p>
<p align="left">Out_str:</p>
<p align="left">mov dx,offset My_string</p>
<p align="left">jmp Go_21h</p>
<p align="left">...</p>
<p align="left">Здесь мы проверяем,
вызывается ли функция вывода
строки на экран (09) или
какая-либо другая. Если
вызывается другая функция
(например, 3Dh), то мы просто
предаем управление
оригинальному обработчику.</p>
<p align="left">Что же такое <strong>обработчик
прерывания</strong>? Это процедура,
постоянно (или на время)
находящаяся в памяти, которая
принимает управление первой,
делает что хочет, а затем
передает управление
оригинальному обработчику (т.е.
процедуре, которая уже
находилась в памяти до
загрузки нашего обработчика).
Та может также выполнить
некоторые действия, а затем
передать управление другому
обработчику и т.д.</p>
<p align="left">Вообще оригинальные
(скажем так, первичные)
обработчики MS-DOS 20h - 28h
прерываний находятся в файле
io.sys / msdos.sys. До того момента
(пока они не загрузились) эти
прерывания, грубо говоря,
пустые. Почему Microsoft решила
выбрать именно эти адреса -
смотрите здесь: <a
href="http://www.microsoft.ru">http://www.microsoft.ru</a>
. Возможно, там есть ответ. Я,
честно говоря, не знаю.</p>
<p align="left">Если что-либо не
понятно - не отчаивайтесь! Это
действительно очень сложно!
Очень скоро все станет на свои
места.</p>
<p align="left">Теперь перейдем к
обработчику (читайте
внимательно описания после
точки с запятой):</p>
<p align="center">_______________</p>
<p align="left"><a name="prog01"><em><strong>Программа
N 01</strong></em></a></p>
<p align="left">CSEG segment</p>
<p align="left">assume cs:CSEG, ds:CSEG, es:CSEG, ss:CSEG</p>
<p align="left">org 100h</p>
<p align="left">Start:</p>
<p align="left"><em>;Переходим на метку
инициализации. Нам нужно будет
перехватить прерывание 21h, а
также оставить программу
резидентной в памяти</em></p>
<p align="left">jmp Init</p>
<p align="left"><em>; Ниже идет,
собственно, обработчик 21h
прерывания (он будет
резидентный). После того, как
программа выйдет, процедура
Int_21h_proc останется в памяти и
будет контролировать функцию 09
прерывания 21h. Он у нас будет
жирным.</em></p>
<p align="left"><strong>Int_21h_proc proc</strong></p>
<p align="left"><strong>pushf </strong><em><strong>;сохраним
в стеке регистр флагов</strong></em></p>
<p align="left"><strong>cmp ah,9 </strong><em><strong>;проверим:
это функция 09h?</strong></em></p>
<p align="left"><strong>je Ok_09</strong></p>
<p align="left"><strong>popf </strong><em><strong>;восстановим
регистр флагов</strong></em></p>
<p align="left"><strong>jmp dword ptr cs:[Int_21h_vect] </strong><em><strong>;Если
нет, прейдем на оригинальный
обработчик прерывания 21h. Все.
На метку Ok_09 программа уже не
вернется</strong></em></p>
<p align="left"><strong>Ok_09:</strong></p>
<p align="left"><strong>push ds</strong><em><strong>
;Сохраним регистры</strong></em></p>
<p align="left"><strong>push dx</strong></p>
<p align="left"><strong>push cs </strong><em><strong>;Адрес
троки должен быть DS:DX</strong></em></p>
<p align="left"><strong>pop ds</strong></p>
<p align="left"><strong>mov dx,offset My_string</strong></p>
<p align="left"><strong>pushf </strong><em><strong>;так
надо! Позже рассмотрим</strong></em></p>
<p align="left"><strong>call dword ptr cs:[Int_21h_vect] </strong><em><strong>;Вывели
нашу строку вместо той, которую
надо было</strong></em></p>
<p align="left"><strong>pop dx </strong><em><strong>;восстановим
использованные регистры</strong></em></p>
<p align="left"><strong>pop ds</strong></p>
<p align="left"><strong>popf</strong></p>
<p align="left"><strong>iret </strong><em><strong>;продолжим
работу (выйдем из прерывания)</strong></em></p>
<p align="left"><strong>Int_21h_vect dd ? </strong><em><strong>;переменная
для хранения оригинального адреса обработчика 21h</strong></em></p>
<p align="left"><strong>My_string db 'Моя
строка!$'</strong></p>
<p align="left"><strong>int_21h_proc endp</strong></p>
<p align="left"><em>;Со следующей метки
нашей программы уже не будет в
памяти (это нерезидентная
часть). Она затрется сразу
после выхода.</em></p>
<p align="left">Init:</p>
<p align="left"><em>;установим наш
обработчик (Int_21h_proc) (адрес
нашего обработчика, если быть
точнее) на 21h прерывание. Это позволяет сделать функция 25h
прерывания 21h. Но прежде нам
нужно запомнить оригинальный
адрес этого прерывания. Для
этого используется функция 35h
прерывания 21h:</em></p>
<p align="left">mov ah,35h <em>;AH содержит
номер функции (это понятно)</em></p>
<p align="left">mov al,21h <em>;AL указывает
номер прерывания, адрес (или
вектор) которого нужно
получить</em></p>
<p align="left">int 21h <em>;тепрь в ES:BX
адрес (вектор) 21h прерывания (ES -
сегмент, BX - смещение)</em></p>
<p align="left">mov word ptr Int_21h_vect,bx</p>
<p align="left">mov word ptr Int_21h_vect+2,es <em>;обратите
внимание на запись</em></p>
<p align="left"><em>;итак, адрес
сохранили. Теперь
перехватываем прерывание:</em></p>
<p align="left">mov ax,2521h</p>
<p align="left">mov dx,offset Int_21h_proc <em>;DX
должен указывать на наш
обработчик (т.е. Int_21h_proc)</em></p>
<p align="left">int 21h</p>
<p align="left"><em>;Все! Теперь, если
какая-либо программа вызовет
21h, то вначале компьютер попадет
на наш обработчик (Int_21h_proc). Что
осталось? Завершить программу,
оставив ее резидентной в
памяти (чтобы никто не затер
наш обработчик. Иначе
компьютер просто зависнет!)</em></p>
<p align="left">mov dx,offset Init</p>
<p align="left">int 27h</p>
<p align="left"><em>; Функция 27h
прерывания 21h выходит в DOS (как
20h), при этом оставив нашу
программу резидентной. DX
должен указывать на последний
байт, остающийся в памяти (это
как раз метка Init).</em></p>
<p align="left">CSEG ends</p>
<p align="left">end Start</p>
<p align="center">_______________</p>
<p align="left">Рассмотрим должным
образом новые прерывания и
операторы.</p>
<p align="left"><font color="#800040"><strong>Функция
35h прерывания 21h: получить адрес
(вектор) прерывания:</strong></font></p>
<table border="3" cellspacing="1" width="65%"
bordercolor="#000080">
<tr>
<td valign="top"><strong>Вход:</strong></td>
<td>AH =35h</td>
</tr>
<tr>
<td valign="top"><strong>Выход:</strong></td>
<td>ES = сегментный адрес
вектора прерывания<p>BX=смещение</p>
</td>
</tr>
</table>
<p align="center"><font color="#800040"><strong>_________</strong></font></p>
<p align="left"><font color="#800040"><strong>Функция
25h прерывания 21h: установить
вектор прерывания:</strong></font></p>
<table border="3" cellspacing="1" width="65%"
bordercolor="#000080">
<tr>
<td valign="top"><strong>Вход:</strong></td>
<td>AH =25h<p>DS=сегмент нашего
обработчика</p>
<p>DX=его смещение</p>
</td>
</tr>
<tr>
<td valign="top"><strong>Выход:</strong></td>
<td>Ничего</td>
</tr>
</table>
<p align="center"><font color="#800040"><strong>_________</strong></font></p>
<p align="left"><font color="#800040"><strong>Прерывание
27h: оставить программу
резидентной в памяти:</strong></font></p>
<table border="3" cellspacing="1" width="65%"
bordercolor="#000080">
<tr>
<td valign="top"><strong>Вход:</strong></td>
<td>DX=последний байт,
оставляемый в памяти</td>
</tr>
<tr>
<td valign="top"><strong>Выход:</strong></td>
<td>Ничего (выход в DOS)</td>
</tr>
</table>
<p align="center"><font color="#800040"><strong>_________</strong></font></p>
<table border="3" cellspacing="1" bordercolor="#800000">
<tr>
<td align="center"><strong>Название</strong></td>
<td align="center"><strong>Перевод</strong></td>
<td align="center"><strong>Команда</strong></td>
<td align="center"><strong>Процессор</strong></td>
</tr>
<tr>
<td><font size="4"><strong>Pushf</strong></font></td>
<td>Push Flags (втолкнуть флаги)</td>
<td>Сохранить флаги</td>
<td>8086</td>
</tr>
</table>
<p align="center"><font color="#800040"><strong>_________</strong></font></p>
<table border="3" cellspacing="1" bordercolor="#800000">
<tr>
<td align="center"><strong>Название</strong></td>
<td align="center"><strong>Перевод</strong></td>
<td align="center"><strong>Команда</strong></td>
<td align="center"><strong>Процессор</strong></td>
</tr>
<tr>
<td><font size="4"><strong>Popf</strong></font></td>
<td>Pop Flags (вытолкнуть флаги)</td>
<td>Восстановить флаги</td>
<td>8086</td>
</tr>
</table>
<p align="center"><font color="#800040"><strong>_________</strong></font></p>
<p align="left">Что такое флаги вы
помните? На всякий случай
рассмотрим кратко на примере
еще раз:</p>
<p align="left">...</p>
<p align="left">(1) cmp ax,23</p>
<p align="left">(2) je Ok_ax</p>
<p align="left">...</p>
<p align="left">Здесь после
выполнения строки (1)
установится/сбросится флаг
нуля. В строке (2) проверяем этот
самый флаг. Если он установлен,
значит команда сравнения верна
(т.е. AX=23). Если же не установлен,
то AX &lt;&gt; (не равен) 23.</p>
<p align="left">Теперь обратите
внимание на самое начало
процедуры Int_21h_proc. Что мы видим:</p>
<p align="left">cmp ah,9</p>
<p align="left">je Ok_09</p>
<p align="left">Мы нарушаем работу
программы (изменяем флаг нуля).
Это может привести к
довольно-таки серьезным
изменениям в ходе работы
программы, которая вызвала 21h
прерывание. Для этого,
собственно, мы и сохраняем
флаги в стеке. Надеюсь, вы
поняли, что в обработчике
прерывания (в нашем случае -
Int_21h_proc) необходимо сохранять <strong>ВСЕ</strong>
используемые регистры, включая
регистр флагов.</p>
<p align="center">_______</p>
<p align="left">Теперь рассмотрим
следующую строку:</p>
<p align="left"><strong>Int_21h_vect dd ? </strong><em><strong>;переменная
для хранения оргинального
адреса обработчика 21h</strong></em></p>
<p align="left">Данная переменная
может хранить двойное слово (<strong><u>D</u></strong>efine
<strong><u>D</u></strong>ouble word -
определить двойное слово)
(четыре байта). Вспоминаем, что
один 16-и разрядный занимает 2
байта (одно слово) (DX, AX, ES, SS и
т.д., но не AH, DL, BH - это 8-и
разрядные регистры, которые
занимают один байт!).</p>
<p align="left">Если мы хотим
загрузить в данную переменную
слово (два байта), то нам
необходимо указать это таким
образом:</p>
<p align="left">mov <strong><u>word ptr</u></strong>
Int_21h_vect,ax</p>
<p align="left">Если же мы хотим
загрузить один байт, то пишем
так:</p>
<p align="left">mov <strong><u>byte ptr</u></strong>
Int_21h_vect,ah</p>
<p align="left">Вспоминаем, что <em>word</em>
- это слово, а <em>byte</em> - это байт.
Что-нибудь прояснилось?</p>
<p align="center">______</p>
<p align="left">Как проверить работу
программы? В данном случае нам
понадобится отладчик, который
способен заходить внутрь
прерываний. Например, AFD и пр.,
но не как не CodeView. То, что нам
сейчас нужно! Если у вас нет AFD,
то возьмите, пожалуйста, на
нашем сайте: <a
href="http://www.Kalashnikoff.ru">http://www.Kalashnikoff.ru</a></p>
<p align="left">Затем создайте
простейшую программу, которая
будет выводить на экран
некоторую строку путем вызова
09 функции 21h прерывания.
Например, так:</p>
<p align="left"><a name="prog02"><em><strong>Программа
N 02</strong></em></a></p>
<p align="left">CSEG segment</p>
<p align="left">assume CS:CSEG, DS:CSEG, ES:CSEG, SS:CSEG</p>
<p align="left">org 100h</p>
<p align="left">Begin:</p>
<p align="left">mov ah,9</p>
<p align="left">mov dx,offset String</p>
<p align="left">int 21h</p>
<p align="left">int 20h</p>
<p align="left">String db 'My string.$'</p>
<p align="left">end Begin</p>
<p align="left">CSEG ends</p>
<p align="left">Запускаем сперва <a
href="#prog01"><font color="#800040">Программу N
01</font></a>. После того, как он
вернется в DOS (в Norton Commander, DOS
Navigator, Far и пр. оболочки),
запускайте <a href="#prog02"><font
color="#800040">Программу N 02</font></a>.
Что вы увидите?</p>
<p align="left">Теперь запустите <a
href="#prog02"><font color="#800040">Программу N
02</font></a> в отладчике. Заходите
смело &quot;внутрь&quot; 21h-ого
прерывание. Что вы видите
теперь?</p>
<hr>
<p align="center"><a name="questions"><font size="5"><strong>Блиц-опрос.</strong></font></a></p>
<p align="left"><em>Ну что, дорогие мои!
Сложно?</em></p>
<p align="left"><strong>1. Все внимательно
прочитал несколько раз, но
ничего не понял.</strong></p>
<p align="left"><a href="mailto:oleg77@beep.ru?Subject=1">oleg77@beep.ru?Subject=1</a></p>
<p align="left">______</p>
<p align="left"><strong>2. Плохо
объясняешь. &quot;Дошло&quot; на
третьи сутки.</strong></p>
<p align="left"><a href="mailto:oleg77@beep.ru?Subject=2">oleg77@beep.ru?Subject=2</a></p>
<p align="left">______</p>
<p align="left"><strong>3. &quot;Дошло&quot; с
трудом. Желательно объяснять
поподробнее. А так все
нормально.</strong></p>
<p align="left"><a href="mailto:oleg77@beep.ru?Subject=3">oleg77@beep.ru?Subject=3</a></p>
<p align="left">______</p>
<p align="left"><strong>4. Тяжело, но
интересно. Продолжай в том же
духе!</strong></p>
<p align="left"><a href="mailto:oleg77@beep.ru?Subject=4">oleg77@beep.ru?Subject=4</a></p>
<p align="left">______</p>
<p align="left"><strong>5. Все отлично!
Классно объясняешь!</strong></p>
<p align="left"><a href="mailto:oleg77@beep.ru?Subject=5">oleg77@beep.ru?Subject=5</a></p>
<p align="left">______</p>
<p align="left"><strong>6. Элементарщина!
Скорее бы к Windows перейти...</strong></p>
<p align="left"><a href="mailto:oleg77@beep.ru?Subject=6">oleg77@beep.ru?Subject=6</a></p>
<hr>
<p align="left">На сегодня все!
Оболочку рассмотрим на
следующей неделе (байт не
хватит). <font size="4"><strong>Удачного
программирования вам!</strong></font></p>
<div align="left"><table border="4" bgcolor="#369A86">
<tr>
<td><p align="center"><font size="4"><strong><u>Автор
рассылки:</u></strong><u>
Калашников Олег</u></font></p>
<p><strong>E-mail:</strong> <a
href="mailto:oleg77@beep.ru?Subject=Assembler">oleg77@beep.ru?Subject=Assembler</a></p>
<p><strong>URL:</strong> <a
href="http://www.Kalashnikoff.ru">http://www.Kalashnikoff.ru</a></p>
<p><strong>UIN (Тетя Ася): 68951340</strong></p>
</td>
</tr>
</table>
</div></td>
</tr>
</table>
</center></div>

<hr>

<p align="center">[<a href="011.htm">Следующий выпуск</a>] [<a target=_BLANK href="http://www.Kalashnikoff.ru/">На главную страницу</a>]</p>


<HR NOSHADE><CENTER>
<!-- SpyLOG v2 f:0211 --><script language="javascript">  
u="u496.71.spylog.com";d=document;nv=navigator;na=nv.appName;p=1;  
bv=Math.round(parseFloat(nv.appVersion)*100);  
n=(na.substring(0,2)=="Mi")?0:1;rn=Math.random();z="p="+p+"&rn="+rn;y="";  
y+="<a href='http://"+u+"/cnt?f=3&p="+p+"&rn="+rn+"' target=_blank>";  
y+="<img src='http://"+u+"/cnt?"+z+  
"&r="+escape(d.referrer)+"&pg="+escape(window.location.href)+"' border=0 width=88 height=31 alt='SpyLOG'>";  
y+="</a>"; d.write(y);if(!n) { d.write("<"+"!--"); }//--></script><noscript><p align="center"><a 
href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" 
target="_blank"><img src="http://u496.71.spylog.com/cnt?p=1" alt="SpyLOG" align="middle" border="0"></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"></noscript></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"> 
<script language="javascript1.2"><!-- if(!n) { d.write("--"+">"); }//--></script></a> 
<!-- SpyLOG --> 
 
 <a target=_top href="http://www.one.ru"><img src="http://cnt.one.ru/cgi-bin/cnt.cgi?id=16871&t=9" width=88 height=31 alt="be number one" border=0></a> 
 
 <script language="JavaScript"><!-- 
d=document;a='';a+=';r='+escape(d.referrer) 
js=10//--></script><script language="JavaScript1.1"><!-- 
a+=';j='+navigator.javaEnabled() 
js=11//--></script><script language="JavaScript1.2"><!-- 
s=screen;a+=';s='+s.width+'*'+s.height 
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth) 
js=12//--></script><script language="JavaScript1.3"><!-- 
js=13//--></script><script language="JavaScript"><!-- 
d.write('<a href="http://top.list.ru/jump?from=87856"'+ 
' target=_top><img src="http://top.list.ru/counter'+ 
'?id=87856;t=54;js='+js+a+';rand='+Math.random()+ 
'" alt="TopList"'+' border=0 height=31 width=88></a>') 
if(js>11)d.write('<'+'!-- ')//--></script><noscript><a 
target=_top href="http://top.list.ru/jump?from=87856"><img 
src="http://top.list.ru/counter?js=na;id=87856;t=54" 
border=0 height=31 width=88 
alt="TopList"></a></noscript><script language="JavaScript"><!-- 
if(js>11)d.write('--'+'>')//--></script> 
 
<br><br> 

</BODY></HTML>
