<HTML><HEAD>
<TITLE>Калашников.ru - Ассемблер? Это просто!.. (Выпуск № 012)</TITLE>
<BODY aLink=#000000 bgColor=#ebd2a5 link=#660000 text=#000000 vLink=#000000>

<P align=center><A 
href="http://ad.ir.ru/bb.cgi?cmd=go&amp;pubid=128269&amp;pg=2&amp;vbn=10001&amp;nocache=77524" 
target=_top><IMG alt="InterReklama " border=0 
src="http://ad.ir.ru/bb.cgi?cmd=ad&amp;pubid=128269&amp;pg=2&amp;vbn=10001&amp;nocache=77524"></A></P>
<P align=center><A href="http://www.ir.ru" target=_top><FONT size=1>InterReklama 
Advertising</FONT></A> </P>
<HR>

<CENTER></CENTER>
<DIV align=center>
<CENTER>
<TABLE bgColor=#8dc7c7 border=3 borderColor=#000040 cellPadding=3 cellSpacing=3 
width="100%">
<TBODY>
<TR>
<TD width="100%">
<DIV align=center>
<CENTER>
<TABLE bgColor=#009797 border=3 borderColor=#000040 cellPadding=3 
cellSpacing=3 width="100%">
<TBODY>
<TR>
<TD width="100%">
<P align=center><FONT size=5><STRONG>Здравствуйте, здравствуйте, 
дорогие мои!</STRONG></FONT></P>
<HR>

<P align=center><FONT size=4><EM><STRONG>Выпуск N 
012</STRONG></EM></FONT></P></TD></TR></TBODY></TABLE></CENTER></DIV>
<P align=right><EM>Кваса. Снова кваса глоток хлебану.</EM></P>
<P align=right><EM>Знаю, что рассылку сейчас получу.</EM></P>
<P align=right><EM>Нужно побыстрее мне в Сеть лишь войти.</EM></P>
<P align=right><EM>Чтоб там новый выпуск найти.</EM></P>
<P align=right><EM>________</EM></P>
<P align=right><EM>Где ж ты моя, долгожданная, где?</EM></P>
<P align=right><EM>Слюни текут уже по бороде.</EM></P>
<P align=right><EM>Вот ты! Ща тебя я прочту.</EM></P>
<HR>

<P align=center><FONT size=4><EM><STRONG>Что у нас 
сегодня?</STRONG></EM></FONT></P>
<UL>
<LI><A href="#new"><FONT color=#800040>Новость</FONT></A> 
<LI><A href="#letters"><FONT color=#800040>Ваши письма</FONT></A> 
<LI><A href="#resident"><FONT color=#800040>Резидент</FONT></A> </LI></UL>
<HR>

<P align=center><A name=new><FONT 
size=4><STRONG>Новость</STRONG></FONT></A></P>
<P>Друзья мои! У нас существенно изменился внешний вид сайта. В этом мне 
помог <A href="http://var.agava.ru/"><FONT color=#0000ff>BoB</FONT></A>, 
за что ему огромное спасибо, а также море благодарности.</P>
<P>Теперь там есть Гостевая книга, где вы можете лично оставить свое 
впечатление, пожелание, критику и прочее.</P>
<P>Появился также раздел писем, которые вы можете отправлять сами на сайт 
(например, решение программы, мысли, заметки и прочее).</P>
<P>Единственная проблема: закачать все это дело на сайт <A 
href="http://www.Kalashnikoff.ru">www.Kalashnikoff.ru</A> . Думаю, что на 
этой неделе я все сделаю...</P>
<P>Если вам интересно, то можете попозже посмотреть одним глазком. Все 
ваши отклики принимаются тут: <A 
href="mailto:assembler@beep.ru?Subject=Сайтик">assembler@beep.ru?Subject=Сайтик</A></P>
<HR>

<P align=center><A name=letters><FONT size=4><STRONG>Ваши 
письма</STRONG></FONT></A></P>
<P>Я уже не раз писал, что ко мне очень много приходит писем. Если бы в 
сутках было 124 часа, то я, возможно, смог бы всем ответить. Я прошу 
прощения, если кто-то не получил ответ. У меня действительно нет времени 
отвечать на все письма.</P>
<P>Так как рассылка уже выходит относительно давно, то у меня сложилась 
определенная система ответа на ваши письма.</P>
<P>Итак, <STRONG>в первую очередь</STRONG> я отвечаю на письма:</P>
<UL>
<LI>с просьбой выслать предыдущие выпуски рассылки; </LI></UL>
<UL>
<LI>с просьбой выслать shell.asm, virus.asm, resident.asm и прочие 
программы на Ассемблере, которые необходимы для работы; </LI></UL>
<UL>
<LI>с просьбой выслать программное обеспечение
  небольшого объема (afd, hiew и пр.). 
</LI></UL>
<P><STRONG>Во вторую очередь</STRONG> я отвечаю на следующие письма:</P>
<UL>
<LI>"написал программу из выпуска Х, а она не работает. Я делал так-то и 
так-то, у меня такой-то компьютер (386, Pentium...), такой-то ассемблер 
(MASM, TASM версии х.хх), такая-то ОС (MS-DOS, Windows 95/98). Набранную 
мной программу прилагаю. Найдите и исправьте мои ошибки." </LI></UL>
<UL>
<LI>"Не работает MASM (TASM, AFD, HIEW). Пишет то-то и то-то. Я запускаю 
его так-то и так-то. Что делать?" </LI></UL>
<P><STRONG>Я НЕ отвечаю на письма такого плана:</STRONG></P>
<UL>
<LI>"Я сам тракторист. В глаза компьютер никогда не видел. Неделю назад 
мне достался в наследство от прабабушки Pentium-III 800. Пожалуйста, 
напишите подробно, что нужно сделать, чтобы он заработал (какие провода 
куда повтыкать, какую кнопку нажать, какие программы установить и пр.). 
Прошу также выслать на e-mail моему другу ВСЁ необходимое программное 
обеспечение (Windows 2000, MS Office 2000 и прочее). С уважением, Изя 
Абдулаев. <STRONG>P.S.</STRONG> Где купить еще один винчестер, и - 
главное - как его вставить в компьютер? У моего деда есть один, но он 
ходит с ним на охоту каждый день и мне не дает." </LI></UL>
<UL>
<LI>"Я подписался на вашу рассылку недавно. Одна беда: никогда не 
работал с DOS. Напишите подробно, как мне загрузить Norton Commander 
(DOS Navigator), как в нем создавать и удалять файлы, как их 
редактировать. И вообще, что такое командная строка? С уважением, ученик 
3-го класса, Чайников Т." </LI></UL>
<UL>
<LI>"Я пишу программу по управлению спутниками. Пожалуйста, напишите мне 
процедуру, которая бы выводила спутник на орбиту. А то что-то у меня 
ничего не получается. С уважением, космонавт Невесомов." </LI></UL>
<UL>
<LI>"Здорово, братан! Помоги мне хакнуть банк "Кидалово". Хочу перевести 
бабки одного мужика на свой счет. Жду ответ! Вован Безбазаров." </LI></UL>
<P>Подобные письма приходят пачками. Я просто физически не могу ответь на 
все. Еще не забывайте, что у меня работа, учеба, сын и куча проблем. 
Пожалуйста, не обижайтесь, если я кому-нибудь не отвечу.</P>
<P>Единственное, что могу посоветовать: купите книгу по DOS и читайте. 
Ничего сложного там нет.</P>
<P>Еще один момент. Т.к. я пользуюсь бесплатными ящиками (beep.ru, 
hotmail.ru), которые не несут ответственность за предоставляемые услуги, 
то, возможно, что ваше письмо не дойдет до меня. Если я не отвечу в 
течение 3 дней, то вышлите его повторно, пожалуйста.</P>
<P>______________</P>
<P><STRONG>ВНИМАНИЕ!</STRONG> У меня довольно-таки много адресов находится 
в моей адресной книге Outlook'а. Не исключено, что у меня может появиться 
вирус, который я сразу и не замечу. Пожалуйста, не открывайте письма, 
которые могут прийти от моего имени с таким содержанием в поле "Тема" (или 
примерно таким):</P>
<P><EM>"Вышлите мне стольник и получите лимон!"</EM></P>
<P><EM>"Все козлы, а я - Д'Артаньян!"</EM></P>
<P><EM>"Посмотри мои фотки в приложении!"</EM></P>
<P><EM>"Предлагаю крутую работу за сумасшедшие деньги! Подробности в 
приложении."</EM></P>
<P>и прочее. Я таких писем не отправляю и их не читаю, чего и вам советую. 
Если же все-таки к вам пришло подобное письмо от моего имени, то, 
пожалуйста, <STRONG><U>НЕМЕДЛЕННО</U></STRONG> сообщите мне об этом. Буду 
очень признателен.</P>
<P>_____________</P>
<P>Я получил письмо от одного из подписчиков на позапрошлой неделе, 
который указал на ошибку в выпуске N 009 (когда читали сами себя в 
память). Эх, какую я допустил досадную логическую ошибку! А заметил-то 
всего один подписчик, который мне долго объяснял ее суть. Ай-да, молодец, 
Серега! Итак, вот оно, это письмо:</P>
<P><EM>Здравствуйте, Олег! Простите за назойливость, но....</EM></P>
<P><EM>Боюсь, что я не очень правильно поставил вопрос. Попробую 
сначала.</EM></P>
<P><EM>Thursday, October 05, 2000, 1:24:51 PM, you wrote:</EM></P>
<P><EM>КО&gt; | Open_File proc</EM></P>
<P><EM>КО&gt; | cmp Handle, 0FFFFh ;Если в Hanlde не 0FFFFh (см. ниже) то 
снова открывать не надо.<BR>КО&gt; | jne Quit_open<BR>КО&gt; | mov ax, 
3D00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; открываем на чтение<BR>КО&gt; | int 
21h<BR>КО&gt; | mov Handle, ax&nbsp;&nbsp;&nbsp;&nbsp; ;спасаем 
handle<BR><BR>КО&gt; Теперь-то Handle у нас не 0FFFFh!!! Поэтому, если мы 
попытаемся закрыть файл, то прежде проверим, открыт ли он был (равно ли 
Handle 0FFFFh; если да, то закрывать нечего!!!!)<BR>Согласен. Трудно не 
согласиться.<BR><BR>КО&gt; Вот здесь проверяем на то, содержит ли Handle 
0FFFFh. Т.е. окрыт ли файл на самом деле или нет.<BR>Да, но между вызовами 
процедуры open_file и close_file мы перечитываем<BR>файл и это-то и меняет 
handle!<BR>А именно, по-моему, события происходят 
так<BR>Действие&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Handle 
(после)<BR>---------------------------------------------------<BR>начало&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
FFFF<BR>open_file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
1 (не важно что, главное что не FFFF)<BR>чтение 
файла&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
FFFF! Вот про это я и говорю! См. 
ниже<BR>close_file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp; FFFF<BR><BR>Попробуйте заменить процедуру закрытия на следующую 
(просто добавить вывод 2х строк) - то, что я добавил
справа помечено 
';///':<BR><BR>Close_File 
proc<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp Handle, 
0FFFFh<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; je 
No_Close<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 
3Eh<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 
Handle<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 
21h<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov Handle, 
0FFFFh<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 
9h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
;///<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dx, offset 
Mess_Close_ok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
;///<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 
21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
;///<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
No_Close:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 
9h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
;///<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dx, offset 
Mess_Close_Nok&nbsp;&nbsp;&nbsp;&nbsp; 
;///<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 
21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
;///<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret<BR>Close_File 
endp<BR><BR>Если все работает нормально (как Вы говорите) то сначала 
выводится строка Mess_Close_ok, а затем Mess_Close_Nok. Но реально строка 
Mess_Close_ok не выводится (а вроде должно, коли Handle не FFFF)!! А 
выводится сразу Mess_Close_Nok<BR><BR>То есть имеем - команда 'je 
No_Close' в этой процедуре выполняется и идет на метку No_Close. На всякий 
случай я приложил asm-файлик (мало ли Вы стерли этот пример, да и чтобы не 
править руками), где процедура закрытия именно такая и этот эффект можно 
пронаблюдать.</EM></P>
<P><EM>Именно об этом эффекте я и говорил. А ведь после открытия файла 
Handle точно не FFFF (по крайней мере в дебаггере). А вот перед закрытием 
- FFFF. То есть остается предположить, что когда мы перечитываем файл, 
Handle становится FFFF. Почему так - я пытался описать раньше.</EM></P>
<P><EM>Best regards, Sergey</EM></P>
<P><A href="mailto:s_kessel@mail.ru">mailto:s_kessel@mail.ru</A></P>
<P>______________</P>
<P>Вот еще одно предложение:</P>
<P><EM>Привет, Олег!</EM></P>
<P><EM>Хочу подсказать одну нуууууу очень хорошую книгу: П.Абель 
"Програмирование на языке Ассемблера". Можешь стянуть ее по адресу </EM><A 
href="http://www.chat.ru/~rusdoc"><EM>www.chat.ru/~rusdoc</EM></A></P>
<P><EM>По моему она в 2 раза лучше Жордейна. Я в свое время на ней 
учился</EM>.</P>
<P>______________</P>
<P>Ну и еще одно письмецо. Нужна помощь одному из наших подписчиков. 
Может, кто подскажет чего:</P>
<P><EM>И вот еще - обращаюсь с просьбой о помощи (хотелось бы чтобы оно 
было опубликовано в рассылке)! Мне срочно нужно описание BIOS (Сетапа) как 
и что там делать - от этого зависит моя "жизни". Дело в том , что наш 
системный администратор "слинял" а на свое место некого не поставил! И Все 
проблемы свалились на меня! </EM><A 
href="mailto:solomaxa@rambler.ru"><EM>solomaxa@rambler.ru</EM></A></P>
<HR>

<P align=center><A name=resident><FONT 
size=4><STRONG>Резидент</STRONG></FONT></A></P>
<P><STRONG>Теперь к делу.</STRONG></P>
<P>Возьмите, пожалуйста, файл здесь: <A 
href="http://www.Kalashnikoff.ru/Assembler/Programs/Lessons/Resid12.rar">http://www.Kalashnikoff.ru/Assembler/Programs/Lessons/Resid12.rar</A></P>
<P>Если у вас нет выхода в Сеть, то напишите мне письмо с просьбой 
выслать. Я также включу ваш адрес в базу данных. Затем перед выходом 
очередной рассылки вы получите этот файл по почте.</P>
<P>Сегодня рассмотрим один из вариантов применения резидента. Сперва 
посмотрите файлы resid12.asm и test12.asm.</P>
<P>Что делает программа? Сначала загрузим файл resid12.com в память. Затем 
запустим файл test12.com. Что мы видим?</P>
<P>Resid12.com оставляет в памяти процедуру, которая выводит на экран 
строку ASCIZ (строка, заканчивающаяся символом 0). Причем, процедура 
Int_10h_proc "вешается" на 10h прерывание (это прерывание BIOS (ПЗУ), как 
вы уже знаете). Нечто похожее мы рассматривали в позапрошлом выпуске. В 
данном случае мы как бы добавляем еще одну функцию (88h) к прерыванию 10h. 
Для того, чтобы она отработала, нам нужно вызвать 10h прерывание, а в 
регистры загрузить необходимые числа (данные). Это:</P>
<P>AH=88h - номер нашей функции;</P>
<P>DS:SI = адрес строки, которую нужно вывести на экран (DS - сегмент, SI 
- смещение).</P>
<P>Обратите еще раз внимание, что мы в DS (сегмент) ничего не загружаем, 
только в SI (смещение). Если вы забыли, то напомню: при старте любого 
*.com-файла, сегментные регистры CS, DS, ES, SS равны нашему единственному 
сегменту, в который загрузилась программа. Сегмент может быть любым. Все 
зависит от того, сколько резидентных программ загружено.</P>
<P>Итак, давайте подробно рассмотрим программу resid12.asm.</P>
<P>Сперва переходим на метку инициализации. При инициализации обычно 
настраиваются необходимые регистры, перехватываются прерывания и пр. Т.е. 
происходит "подготовительный процесс".</P>
<P>Перво-наперво проверим, загружен ли наш резидент в память или нет. Как 
это делается? Т.к. мы перехватили прерывание, то можем из него сделать 
отклик. Вот мы и делаем. Вызываем 10h прерывание, занеся в регистр AX 
"магическое число": 8899h (можно любое другое. Главное - чтобы не 
конфликтовало с какой-нибудь функцией данного прерывания). Понятно, что в 
AH заносится 88h, а в AL - 99h. Функции 88h у 10h прерывания не существует 
(не дошли пока разработчики до этого числа). Это можно с уверенностью 
предположить на 99,9%. Т.к. такой функции не существует, то произойдет 
немедленный выход из 10h прерывания <STRONG>(регистры не 
меняются!)</STRONG>, что легко проверить в отладчике. Следовательно, 
вызвав 10h прерывание с числом 8899h в AX и получив в ответ 8899h в том же 
AX, мы уверены, что наш резидент еще не загружен. Сейчас все будет 
понятно.</P>
<P>Если мы уже находимся в памяти, перехватив 10h прерывание, то прежде 
всего проверим, вызывают ли его с числом 8899h в AX. Если так, то нужно 
будет послать какой-нибудь ответ. Какой? В нашем примере мы меняем местами 
содержимое регистров AH и AL и немедленно выходим из прерывания. Проще 
говоря, возвращаемся в нашу программу, которая, в свою очередь, проверяет, 
вернулось ли число 8899h или 9988h (помните, что если нашего резидента нет 
в памяти, то вернется 8899h в AX. BIOS регистры не изменит, т.к. такой 
функции просто нет!). Если же вернулось 9988h, то значит мы в памяти! Т.е. 
кусочек нашей процедуры Int_10h_proc поменял местами регистры (а кто еще 
может это сделать?). Смотрите первые строки процедуры (часть нашего 
резидента):</P>
<P>pushf ;сохраним флаги</P>
<P>cmp ax,8899h ;проверим на "магическое число"</P>
<P>jne Next_test ;если не оно, то работаем дальше</P>
<P>xchg ah,al ;иначе меняем местами AH/AL</P>
<P>popf ;восстановим флаги</P>
<P>iret ;и выйдем</P>
<P>Итак, новая инструкция: xchg</P>
<DIV align=left>
<TABLE border=1 cellSpacing=1>
<TBODY>
<TR>
<TD width="25%"><STRONG>Название</STRONG></TD>
<TD width="25%"><STRONG>Перевод</STRONG></TD>
<TD width="20%"><STRONG>Применение</STRONG></TD>
<TD width="20%"><STRONG>Процессор</STRONG></TD></TR>
<TR>
<TD width="25%">xchg источник, приемник</TD>
<TD width="25%">eXCHanGe - обменять</TD>
<TD width="20%">Обмен регистров</TD>
<TD width="20%">8086</TD></TR></TBODY></TABLE></DIV>
<P>Пример:</P>
<P>mov ax,10h</P>
<P>mov bx,15h</P>
<P>xchg ax,bx</P>
<P>Теперь AX=15h, BX=10h. Все элементарно!</P>
<P>Мы сейчас рассматриваем одну из самых сложных тем: механизм работы 
прерываний. Я понимаю, что для многих из вас это очень трудно (особенно 
для тех, кто не знаком ни с одним языком программирования). Поэтому я 
постараюсь как можно проще объяснить принцип работы прерываний:</P>
<P>Как уже вам известно, сегментный регистр CS (Code Segemt - сегмент 
кода) всегда содержит номер сегмента, в котором находится наша программа, 
а IP (Instruction Pointer - указатель инструкций) - смещение.</P>
<P>Допустим, вектор (адрес) 10h прерывания находится по адресу 0010:0400h, 
а наша программа загрузилась по адресу 1234:0100h. Тогда сразу после 
загрузки:</P>
<P>CS:IP = 1234:0100h</P>
<P>1234:0100 mov ax,8899h --- теперь (после выполнения данной инструкции) 
CS:IP=1234:0103h</P>
<P>1234:0103 int 10h --- теперь CS:IP = сегменту/смещению адреса (вектора) 
10h прерывания, т.е. 0010:0400h.</P>
<P>1234:0105 mov bx,10</P>
<P>Остальные регистны не изменятся (кроме SP, т.к. перед вызовом 
прерывания компьютер кладет в стек адрес следующей команды, чтобы потом на 
нее вернуться. Примерно, как при вызове процедуры, с той лишь разницей, 
что при вызове процедуры в стек кладется только смещение (а зачем сегмент, 
если и так в одном сегменте с программой находится процедура?). При вызове 
же прерывания меняется как сегмент (CS), так и смещение (IP), которые 
компьютер и кладет в стек. Поэтому инструкция выхода из подпрограммы и из 
прерывания разные: ret и iret соответственно. Ret достает со стека только 
слово (два байта - смещение - IP), а iret достает еще и сегмент 
(CS+IP)).</P>
<P>Что дальше? А дальше все просто: выполняется 10h прерывание до тех пор, 
пока не встретится инструкция iret, которая вытащит из стека 
сегмент/смещение инструкции на которую нужно вернуться, в нашем случае - 
это 1234h (CS - сегмент) и 0105h (IP - смещение). Проще говоря, в CS:IP 
загружаются из стека данные значения, при этом SP увеличивается на 4 байта 
(стек-то снизу вверх растет!).</P>
<P><STRONG><U>Очень просто все смотрится на практике.</U></STRONG> 
Попробуйте запустить наш резидент (который скачали) в отладчика. 
Внимательно следите за состоянием регистров CS:IP. Вы заметите, что они 
постоянно меняются. Обратите внимание, какие значения принимают они при 
вызове прерываний (для этого нужно зайти внутрь прерываний; в AFD - F1, в 
CV - F8). Ну что, сложно?</P>
<P>Теперь рассмотрим некоторые новые инструкции, встречающиеся в нашем 
резиденте: stos, lods, rep. Это очень мощные и быстрые команды Ассемблера. 
Они предназначены для работы с массивами данных (строки, данные любого 
типа, числа и пр.).</P>
<P>Инструкция lods загружает в регистр AX/AL число, которое находится по 
адресу, указанному в регистрах DS:SI, при этом SI увеличивается на 1 или 
на 2. Почему я написал AX/AL? Дело в том, что эта инструкция имеет две 
разновидности: lodsb и lodsw. Lodsb (B - byte) загружает в AL, а stosw (W 
- word - слово) - в AX.</P>
<P><EM><STRONG>Пример:</STRONG></EM></P>
<P>...</P>
<P>mov si,offset String ;SI указывает на начало String, т.е. на '1'</P>
<P>lodsb ;теперь в AL - символ '1' (31h); SI=SI+1, т.е. SI теперь 
указывает не на '1', а на '2'</P>
<P>lodsw ;теперь AX содержит '32' (3332h); SI=SI+2, SI указывает на 
'45'</P>
<P>...</P>
<P>String db '12345'</P>
<P>Поняли принцип? Если последний символ в инструкции lods 'b' - то 
загружается один байт в AL, и SI увеличивается на 1. Если же последний 
символ 'w', то загружается два байта (слово) в AX, и SI увеличивается на 
два.</P>
<P>Здесь возникает два вопроса:</P>
<P>1. Почему не загружаем ничего в DS?</P>
<P>2. Почему после команды lodsw в AX содержится '32', а не '23', что было 
бы вполне логичней? Когда указывается число в кавычках ('32'), то это 
значит, что оно занимает два байта. Т.е. один байт - '3', а второй - 
'2'.</P>
<P><STRONG>Превый вопрос</STRONG> уже ясен для многих: если String 
находится в том же сегменте, в котором наша программа, и он не менялся в 
процессе работы, то в него ничего загружать не надо (в нем и так находится 
нужный сегмент. Ведь при запуске *-com программы все сегментные регистры 
равны нашему единственному сегменту).</P>
<P><STRONG>Второй вопрос</STRONG> заслуживает подробного рассмотрения.</P>
<P>Дело в том, что компьютере двух- и более байтовые числа
хранятся в 
обратном порядке. Путаницы не возникает, если к двухбайтовому числу (к 
слову) мы обращаемся как к двухбайтовому, а к четырехбайтовому (к двойному 
слову) мы обращаемся как к четырехбайтовому. Вот примеры:</P>
<P>Handle dw 1234h <EM>--- изначально присваиваем переменной значение 
1234h. В памяти это число расположится в таком порядке: 3412h. Проверьте в 
отладчике...</EM></P>
<P>mov ax,Handle <EM>--- AX=1234h</EM></P>
<P>mov al,byte ptr Handle <EM>--- AL=34h</EM></P>
<P>mov al,byte ptr Handle+1<EM> --- AL=12h</EM></P>
<P>Byte ptr, как вы уже знаете, обозначает то, что мы хотим загрузить один 
байт с переменной двухбайтового типа (Handle dw 1234h - DW - Define Word - 
определить слово (два байта)).</P>
<P>Но повторю еще раз: путаницы, как правило, не возникает. И вы поймете 
это скоро.</P>
<P>Исходя из вышесказанного, рассмотрим, почему мы при сохранении вектора 
прерывания 10h заносим вначале смещение, а затем сегмент, хотя логичнее 
было бы наоборот:</P>
<P>...</P>
<P>mov ax,3510h <EM>;получим адрес (вектор) 10h прерывания.</EM></P>
<P>int 21h <EM>;теперь ES содержит сегмент, а BX - смещение...</EM></P>
<P>mov word ptr Int_10h_vect,bx <EM>;сохраним сперва смещение</EM></P>
<P>mov word ptr Int_10h_vect+2,es <EM>;а затем сегмент, учитывая, что 
данные хранятся </EM><EM><STRONG>в обратном порядке</STRONG></EM></P>
<P>...</P>
<P>Int_10h_vect <STRONG>dd</STRONG> ? <EM>;переменная на два слова (четыре 
байта)</EM></P>
<P>Word ptr указывает на то, что нужно занести слово в переменную 
Int_10h_vect. Обратите внимание, что данная переменная имеет тип DD - 
Define Double word - определить двойное слово. Но мы-то заносим одно слово 
(ES или BX)! Для этого и указываем ассемблеру на то, что заносится только 
слово, иначе он "не поймет".</P>
<P>Уфф!!! Перекусим и поедем дальше...</P>
<P>Выяснили, что команда lodsb загружает в AL однобайтовое число, 
находящееся по адресу DS (сегиент):SI (смещение). В принципе, данная 
команда аналогична следующей паре инструкций:</P>
<P>mov al,ds:[si]</P>
<P>inc si (или add si,1)</P>
<P>только работает она гораздо быстрее, да и занимает меньше байт.</P>
<P>По аналогии: команда lodsw загружает в AX двухбайтовое число, 
расположенное также по адресу DS:SI. Она эквивалентна паре инструкций:</P>
<P>mov ax,ds:[si]</P>
<P>add si,2</P>
<P>Как правило такие команды (lodsb / lodsw) работают в цикле для чтения 
значений из строки (или другого массива данных). Массив данных - цепочка 
символов, расположенных последовательно друг за другом. Например, 
следующая строка является своего рода массивом данных:</P>
<P>Data_array db 'Это массив данных'</P>
<P>Рассмотрим еще пару подобных команд, которые используются в нашем 
резиденте: stosb / stosw.</P>
<P>Stosb заносит однобайтовое число из AL по адресу ES:DI, а stosw - 
двухбайтовое число по тому же адресу.</P>
<P>Пример:</P>
<P>mov si,offset Data_array</P>
<P>mov ax,2030h</P>
<P>stosw</P>
<P>...</P>
<P>Data_array dw ? ;теперь в этой переменной находится число 2030h</P>
<P>что равносильно команде:</P>
<P>mov Data_array,2030h</P>
<P>Например, занесем в верхний левый угол экрана нашу известную "рожицу", 
используя данные команды. Вот как это выглядит:</P>
<P>...</P>
<P>mov ax,0B800h</P>
<P>mov es,ax</P>
<P>mov di,0</P>
<P>mov ah,07h ;атрибут символа (белый на черном)</P>
<P>mov al,01h ;(сам символ - "рожица")</P>
<P>stosw ;заносим, что эквивалентно: mov es:[di],ax</P>
<P>Насколько мы знаем, видеобуфер имеет следующую структуру:</P>
<P>символ:атрибут символ:атрибут и т.д.</P>
<P>Если внимательно присмотреться, то можно заметить, что в AH мы 
загружаем атрибут, а в AL - символ. Получается, что сперва заносится 
атрибут (т.к. AH - старшая (левая) половинка), а затем символ. Что-то не 
так...</P>
<P>Стоит вспомнить с сегодняшнего урока, что в компьютере двух и более 
байтовые данные (а AX - два байта) хранятся в обратном порядке. Получится, 
что при переносе AX в сегмент видеобуфера, символ и атрибут поменяются 
местами! Понятно это?</P>
<P>Далее. Рассмотрим т.н. префикс rep. Что он делает?</P>
<P>Допустим, нам надо очистить экран. Это можно сделать, используя команду 
stosw (просто забьем экран пробелами):</P>
<P>...</P>
<P>mov ax,0B800h</P>
<P>mov es,ax</P>
<P>mov di,0 <EM>;как обычно с верхнего левого угла</EM></P>
<P>mov cx,2000 <EM>;80х25=2000 символов на экране</EM></P>
<P>mov ax,0720h <EM>;07 - атрибут, 20h - пробел</EM></P>
<P>Next_sym: <EM>;заносим посимвольно</EM></P>
<P>stosw</P>
<P>loop Next_sym</P>
<P><EM>;теперь экран чистый</EM></P>
<P>Неуклюже немного. Да и работать будет не так быстро, хотя на глаз и не 
заметно. Попробуем воспользоваться префиксом rep. Вот, что у нас 
получится:</P>
<P>...</P>
<P>mov ax,0B800h</P>
<P>mov es,ax</P>
<P>mov di,0</P>
<P>mov cx,2000 <EM>;CX - counter - счетчик</EM></P>
<P>mov ax,0720h <EM>;атрибуты / символ</EM></P>
<P>rep stosw <EM>;выводим пробел столько раз, сколько указано в 
CX.</EM></P>
<P>...</P>
<P>Все! Экран чистый. Очистка происходит мгновенно. Можете 
попробовать...</P>
<P>После выполнения последней команды (rep stosw) CX будет содержать 0. 
<STRONG>REP (REPeat - повтор) от CX неразделимы, как LOOP от 
CX!</STRONG></P>
<P><FONT size=4><STRONG><U>Подведем итог:</U></STRONG></FONT></P>
<P>одна команда stosw запишет только два символа, находящихся в AX по 
адресу ES:DI.</P>
<P>команда rep stosw запишет два символа, находящихся в AX по адресу ES:DI 
столько раз, сколько находится в регистре CX.</P>
<P>Просто? Да элементарно! <FONT size=4><STRONG><U>Пробуйте в отладчике. 
Там все видно, как на ладони...</U></STRONG></FONT></P>
<P>Еще покажу вам одну маленькую "фишку". Для того, чтобы обнулить 
регистр, можно воспользоваться такой командой, которая выполняется 
быстрее:</P>
<P>xor ax,ax <EM>;равносильно mov ax,0</EM></P>
<P>А можно и так:</P>
<P>sub ax,ax <EM>;вычтем из AX AX.</EM></P>
<P>Например, AX=23. Что будет, если мы сделаем так: AX = AX - AX? Если 
правильно посчитал мой калькулятор, то будет 0.</P>
<P>Обычно эти команды (xor ax,ax / sub ax,ax) выполняются быстрее mov 
ax,0. Поэтому не удивляйтесь, если где-то в программе встретите нечто 
подобное.</P>
<P>XOR - исключающее ИЛИ. Это логическая команда. Подобные инструкции мы 
рассмотрим позже. Пока что вам нужно уяснить, что XOR'ом и SUB'ом можно 
аннулировать регистры.</P>
<P>Ну что? Загрузил я вас сегодня? Думаю, что вирус мы рассмотрим на 
следующей неделе.</P>
<P><FONT size=4><STRONG>Нескучной вам ночи!!!</STRONG></FONT></P>
<P><FONT color=#008000 size=4><STRONG>P.S. Домашнее 
задание.</STRONG></FONT></P>
<P><FONT color=#008000 size=3><STRONG>Исследовать программы RESID12.ASM и 
TEST12.ASM </STRONG></FONT><FONT color=#008000 size=4><STRONG><U>в 
отладчике</U></STRONG></FONT><FONT color=#008000 size=3><STRONG> (лучше в 
AFD) "от корки до корки".</STRONG></FONT></P>
<HR>

<P><FONT size=5><STRONG>С уважением,</STRONG></FONT></P>
<DIV align=left>
<TABLE bgColor=#369a86 border=4>
<TBODY>
<TR>
<TD>
<P align=center><FONT size=4><STRONG><U>Автор рассылки:</U></STRONG> 
<U>Калашников Олег</U></FONT></P>
<P><STRONG>E-mail:</STRONG> <A 
href="mailto:assembler@beep.ru">assembler@beep.ru</A></P>
<P><STRONG>URL:</STRONG> <A 
href="http://www.Kalashnikoff.ru">http://www.Kalashnikoff.ru</A></P>
<P><STRONG>UIN (Тетя Ася): </STRONG><FONT 
color=#0000ff><STRONG>68951340</STRONG></FONT></P></TD></TR></TBODY></TABLE></DIV></TD></TR></TBODY></TABLE></CENTER></DIV><!--noindex-->

<hr>

<p align="center">[<a href="013.htm">Следующий выпуск</a>] [<a target=_BLANK href="http://www.Kalashnikoff.ru/">На главную страницу</a>]</p>

<HR NOSHADE><CENTER>
<!-- SpyLOG v2 f:0211 --><script language="javascript">  
u="u496.71.spylog.com";d=document;nv=navigator;na=nv.appName;p=1;  
bv=Math.round(parseFloat(nv.appVersion)*100);  
n=(na.substring(0,2)=="Mi")?0:1;rn=Math.random();z="p="+p+"&rn="+rn;y="";  
y+="<a href='http://"+u+"/cnt?f=3&p="+p+"&rn="+rn+"' target=_blank>";  
y+="<img src='http://"+u+"/cnt?"+z+  
"&r="+escape(d.referrer)+"&pg="+escape(window.location.href)+"' border=0 width=88 height=31 alt='SpyLOG'>";  
y+="</a>"; d.write(y);if(!n) { d.write("<"+"!--"); }//--></script><noscript><p align="center"><a 
href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" 
target="_blank"><img src="http://u496.71.spylog.com/cnt?p=1" alt="SpyLOG" align="middle" border="0"></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"></noscript></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"> 
<script language="javascript1.2"><!-- if(!n) { d.write("--"+">"); }//--></script></a> 
<!-- SpyLOG --> 
 
 <a target=_top href="http://www.one.ru"><img src="http://cnt.one.ru/cgi-bin/cnt.cgi?id=16871&t=9" width=88 height=31 alt="be number one" border=0></a> 
 
 <script language="JavaScript"><!-- 
d=document;a='';a+=';r='+escape(d.referrer) 
js=10//--></script><script language="JavaScript1.1"><!-- 
a+=';j='+navigator.javaEnabled() 
js=11//--></script><script language="JavaScript1.2"><!-- 
s=screen;a+=';s='+s.width+'*'+s.height 
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth) 
js=12//--></script><script language="JavaScript1.3"><!-- 
js=13//--></script><script language="JavaScript"><!-- 
d.write('<a href="http://top.list.ru/jump?from=87856"'+ 
' target=_top><img src="http://top.list.ru/counter'+ 
'?id=87856;t=54;js='+js+a+';rand='+Math.random()+ 
'" alt="TopList"'+' border=0 height=31 width=88></a>') 
if(js>11)d.write('<'+'!-- ')//--></script><noscript><a 
target=_top href="http://top.list.ru/jump?from=87856"><img 
src="http://top.list.ru/counter?js=na;id=87856;t=54" 
border=0 height=31 width=88 
alt="TopList"></a></noscript><script language="JavaScript"><!-- 
if(js>11)d.write('--'+'>')//--></script> 
 
<br><br> 

</BODY></HTML>
