<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>Калашников.ru - Ассемблер? Это просто!.. (Выпуск № 021)</title>
<STYLE>
<!-- a:link, a:visited, a:active { text-decoration: none; color: #226622} 
a:hover { text-decoration: bold; color: #662266; } 
 .ff { 
font-family : Arial, helvetica, sans-serif; 
font-style : normal; 
font-variant : normal; 
} -->
</STYLE>
</head>

<body bgcolor="#CFE7E7" body>

<P align=center><A 
href="http://ad.ir.ru/bb.cgi?cmd=go&pubid=128269&pg=2&vbn=10001&nocache=77524" 
target=_top><IMG alt="InterReklama " border=0 
src="http://ad.ir.ru/bb.cgi?cmd=ad&pubid=128269&pg=2&vbn=10001&nocache=77524"></A></P>
<P align=center><A href="http://www.ir.ru" target=_top><FONT size=1>InterReklama 
Advertising</FONT></A> </P>
<HR>

<div align="center"><center>

<table border="1" cellpadding="0" cellspacing="0" width="100%"
bgcolor="#CDCD9C">
<tr>
<td colspan="3" width="100%"><p align="center"><font
color="#004080" size="5"><em><strong>Ассемблер?
Это просто! Учимся
программировать</strong></em></font><font
color="#000000" size="2"><br>
______________________________________</font></p>
<p align="center"><font size="4">Выпуск N 021 (</font><a
href="#shell"><font size="4">Оболочка</font></a><font
size="4">)</font></p>
</td>
</tr>
</table>
</center></div>

<p align="left"><font color="#000000" size="4"><strong>Сегодня
в рассылке:</strong></font></p>

<dir type="disc">
<li><p align="left"><a href="#news"><font size="4"><strong>Организационные
вопросы</strong></font></a></p>
</li>
<li><p align="left"><a href="#letters">Ваши письма</a></p>
</li>
<li><p align="left"><a href="#shell">Оболочка</a></p>
</li>
</dir>

<hr>

<br>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="100%"
bgcolor="#9CCDCD">
<tr>
<td align="center" width="100%"><a name="news"><font
color="#004080" size="5"><strong>Организационные
вопросы</strong></font></a></td>
</tr>
</table>
</center></div>

<p><font color="#000000" size="3">Дорогие мои
подписчики! Нас уже очень много
(более 8200 человек). Народ постоянно
подписывается. Естественно, что мне
одному становится тяжело вести
нашу рассылку. В связи с этим я
хотел бы навести небольшой порядок
с тем, что у нас происходит, а также
хочу попросить помощи у энтузиастов.</font></p>

<p><font color="#000000" size="3">С момента
прошлого выпуска произошли многие
перемены. Прошу вас, дорогие мои, <strong>внимательно</strong>
прочитать весь данный раздел.</font></p>

<p><font color="#000000" size="3">Итак, начнем по порядку.</font></p>

<p align="center"><font color="#000000" size="3">___________</font></p>

<p><font color="#000000" size="4"><strong>1.
Приглашаются помощники:</strong></font></p>

<ul>
<li><font color="#000000" size="3">для перевода
текста с формата HTML в формат MS
Word;</font></li>
<li><font color="#000000" size="3">для перевода
текста с формата *.txt (Windows) в
формат MS Word (вопросы и ответы
экспертов).</font></li>
</ul>

<p><font color="#000000" size="3">Если у вас есть
время и возможность, то, пожалуйста,
напишите мне. Буду рад рассмотреть
ваши предложения. Более подробную информацию можно получить в письме,
которое следует направить по
адресу </font><a href="mailto:Assembler@Kalashnikoff.ru"><font
color="#000000" size="3">Assembler@Kalashnikoff.ru</font></a><font
color="#000000" size="3">. В теле письма,
пожалуйста, укажите, чем вы можете
помочь. Буду очень признателен...</font></p>

<p align="center"><font color="#000000" size="3">___________</font></p>

<p><font color="#000000" size="4"><strong>2. Требуются
ведущие рубрики &quot;Ваши письма&quot;.</strong></font></p>

<p><font color="#000000" size="3">Необходимо
качественно перевести письма
подписчиков в формат HTML из
текстового файла и оформить это
соответствующим образом (как во
всех наших выпусках оформлялась
данная рубрика). <strong>Что я могу
предложить?</strong> Предоставить вам
полное ведение рубрики &quot;Ваши
письма&quot; (с моими поправками, если
понадобится). Ваше имя, e-mail, URL будут
указаны в рассылке. Письма
подписчиков будут высылаться вам
по почте от моего имени, но без
указания электронных адресов
подписчиков. Ваша задача: отобрать
наиболее интересные для
подписчиков письма, исправить по
мере необходимости
орфографические ошибки, оформить
письма в формате HTML и выслать мне
готовый вариант до выхода
следующего номера рассылки
(примерно за 2-5 дней). Вот,
собственно, и все!</font></p>

<p align="center"><font color="#000000" size="3">___________</font></p>

<p><font color="#000000" size="4"><strong>3. Экспертные
группы (следует внимательно
прочесть экспертам и подписчикам,
задающим вопросы!).</strong></font></p>

<p><font color="#000000" size="3">К сожалению, мне
пришлось закрыть три экспертные
группы в связи с тем, что данным
экспертам практически не приходит
вопросов. Закрыты следующие группы:</font></p>

<ol>
<li><font color="#000000" size="3">Эксперты по
работе с Turbo Debugger;</font></li>
<li><font color="#000000" size="3">Эксперты по
работе с AFD;</font></li>
<li><font color="#000000" size="3">Эксперты по
работе с CodeView.</font></li>
</ol>

<p><font color="#000000" size="3">Как показало
время, большинство вопросов
задается группе &quot;</font><a
href="mailto:ExpertGeneralAssm@eGroups.com"><font color="#000000"
size="3">Эксперты по общим вопросам
программирования на Ассемблере под
DOS</font></a><font color="#000000" size="3">&quot;.
Безусловно, лидирует по количеству
отвеченных вопросов эксперт <strong>Slava
V</strong>. Четкие ответы, лаконичное
содержание, простой стиль
изложения, оперативность ответов -
все это делает Slav'у незаменимым
помощником для меня и для всех
подписчиков. Те из вас, кто получил
ответ от Slav'ы, подтвердят мои слова.
Как ему это удается - ума не приложу!
В связи с этим хочу повторно
выразить благодарность Slav'е за
оказанную помощь как мне, так и всем
вам, дорогие подписчики.</font></p>

<p><font color="#000000" size="3">Однако, кто-то из
экспертов старается изо всех сил
отвечать на ваши вопросы, а кто-то
зарегистрировался и за все
существование экспертных групп не
ответил ни на один вопрос! Это
особенно относится к указанной
выше группе. Экспертов в данный
момент довольно-таки много.
Отбирать вручную и искать
&quot;сачков&quot; нет времени. Поэтому
мне придется поступить не очень
хорошо, попросив вас, уважаемые
эксперты, <strong>пройти т.н.
перерегистрацию</strong>. Для этого
необходимо направить мне пустое
письмо до 31 января 2001 года
включительно по адресу: </font><a
href="mailto:Registration@Kalashnikoff.ru"><font color="#000000"
size="3">Registration@Kalashnikoff.ru</font></a><font
color="#000000" size="3">, <strong>указав в теле
письма ваш электронный адрес по
которому вы зарегистрированы в
экспертной группе</strong>. В ответ на
ваше письмо придут новые правила
работы экспертных групп. <strong><u>Эксперты,
от которых я НЕ получу писем до
указанной даты, исключаются из
числа экспертов</u></strong>. Сурово?
Зато на мой взгляд справедливо по
отношению к тем подписчикам,
которые хотели бы стать экспертами,
да группы уже укомплектованы, и мне
с горечью в сердце приходится
отказывать всем желающим. В
последующих выпусках я напишу о
том, сколько мест освободилось в
той или иной группе. Надеюсь, что со
временем мы соберем отличную
экспертную группу в помощь вам,
дорогие мои читатели.</font></p>

<p><font color="#000000" size="3">Подписчики,
желающие задать вопросы экспертам,
должны ознакомиться с новыми
правилами (установленными 15 января
2001 года), которые можно найти на
нашем сайте. Если у вас проблемы с
Интернетом, то напишите мне письмо
по адресу </font><a
href="mailto:AssmExperts@Kalashnikoff.ru"><font color="#000000"
size="3">AssmExperts@Kalashnikoff.ru</font></a><font
color="#000000" size="3">. Данная информация
будет выслана вам в течение двух
рабочих дней. Подписчикам,
получившим или ознакомившимся на
сайте с новыми правилами и адресами
экспертов после 15.01.2001, волноваться
не стоит! Данные правила
упорядочивают работу экспертных
групп, а также вносят определенные
требования для подписчиков
задающих вопросы, с тем, чтобы у нас
не возник хаос, беспорядок и пр. Я
также постарался оградить
экспертов от вопросов, которые
задают &quot;ленивые&quot; подписчики,
т.е. те, кто столкнувшись с
&quot;малюпасенькой&quot; проблемкой,
сразу же задает вопрос экспертам.
Дорогие мои! Так ведь не интересно!
Уверяю вас, что пасуя перед
сложностями (или обращаясь с мелкой
проблемой к помощникам), вы мало
чего добьетесь как в изучении
Ассемблера, так и во всем остальном.
Постарайтесь приложить максимум усилий для решения возникшей
проблемы. Если же ничего не выходит,
то - пожалуйста. Эксперты <strong>с
огромным удовольствием</strong>
ответят на ваш вопрос(ы). По
содержимому вопроса ведь сразу
видно, думали вы или нет, прежде, чем
написали экспертам...</font></p>

<p><font color="#000000" size="3"><strong>Все вопросы,
поступившие в адрес экспертов, но
противоречащие новым правилам,
игнорируются экспертами!</strong></font></p>

<p align="center"><font color="#000000" size="3">___________</font></p>

<p><font color="#000000" size="4"><strong>4. Обсуждение
книги.</strong></font></p>

<p><font color="#000000" size="3">Что можно
сказать по этому поводу. Поступило
ко мне несколько отзывов и не более
того. Причем, все были
положительные (к моему великому
удивлению), что воодушевило меня на
продолжение осуществления моих
сумасшедших планов. Я так понимаю,
что книга, которая будет издана (по
крайней мере, я надеюсь на это)
нужна многим, что, безусловно,
радует.</font></p>

<p><font color="#000000" size="3">Тем не менее, нет
необходимости создавать отдельный
форум (группу обсуждений) для
такого пустяка. Если у вас есть что
сказать, то оставляйте запись в
Гостевой книге или на форуме. Буду
рад прочитать ваши рассуждения не
только я один, но (надеюсь!) и многие
подписчики.</font></p>

<p align="center"><font color="#000000" size="3">___________</font></p>

<p><font color="#000000" size="4"><strong>5. Новые
поступления на сайте.</strong></font></p>

<p><font color="#000000" size="3">На нашем сайте (</font><a
href="http://www.Kalashnikoff.ru"><font color="#000000" size="3">http://www.Kalashnikoff.ru</font></a><font
color="#000000" size="3">) теперь можно найти <strong>документацию
на русском языке по работе с SoftIce</strong>.
Берите и качайте на здоровье!</font></p>

<p><font color="#000000" size="3"><strong>Более того,
теперь доступно пособие по написанию вирусов на русском языке</strong>,
причем, в довольно-таки понятном и
простом для начинающего
программиста изложении. В данном
пособии описаны несколько
вариантов вирусов (включая
резидентные вирусы и вирусы,
заражающие *.exe-файлы). Надеюсь, что
вы почерпнете из этого файла много <u>действительно</u>
полезной и нужной информации,
которая поможет вам освоить все
тонкости программирования на
Ассемблере.</font></p>

<p align="center"><font color="#000000" size="3">___________</font></p>

<p><font color="#000000" size="4"><strong>6. Смена
внешнего вида сайта.</strong></font></p>

<p><font color="#000000" size="3">Ничто не стоит на
месте. Все находится в движении,
меняется. Вот и сайт наш уже третий
раз поменял свой облик (условно -
Версия 3.0). Сидел я, мучил свою
несчастную, убитую горем
&quot;четверку&quot; все выходные. Зато
теперь плод моих трудов вы можете
оценить лично. Был бы безмерно
счастлив, если бы вы оставили
запись (ваше мнение) в Гостевой
книге.</font></p>

<p><font color="#000000" size="3">Конечно, пока что
еще не все подразделы сведены к
одному дизайну, стилю (например,
Гостевая и форум). Но, тем не менее,
уже можно сделать однозначные
выводы.</font></p>

<p><font color="#000000" size="3">Я же, в свою
очередь, хотел бы выразить глубокую
благодарность за качественный
хостинг компании </font><a
href="http://www.agava.ru"><font color="#000000" size="3">AGAVA</font></a><font
color="#000000" size="3"> и лично </font><a
href="http://var.agava.ru"><font color="#000000" size="3">Бобу
Марлину</font></a><font color="#000000" size="3"> (BoB
MaRLiN) за помощь в создании настоящей
Гостевой книги и выделенное место
под нее.</font></p>

<p><font color="#000000" size="3">Если у вас есть
время и желание написать форум и
(или) гостевую на нашем сайте, то
буду вам безмерно благодарен.
Естественно, все ваши права будут
соблюдены. Мой провайдер (</font><a
href="http://www.100mb.ru"><font color="#000000" size="3">www.100mb.ru</font></a><font
color="#000000" size="3">) позволяет создавать
свои CGI-скрипты в каталоге cgi-bin. Если
вы надумали написать что-либо, то не
нужно мне слать письмо с
предложениями. Просто сделайте и
пришлите (если не сложно). Я все
выложу на сайт. Главное условие -
чтобы форум и гостевая были одного
стиля с сайтом. Очень на вас
надеюсь...</font></p>

<p><font color="#000000" size="3">Да! Чуть не забыл!
Теперь статистику посещений нашего
сайта можно найти здесь: </font><a
href="http://www.Kalashnikoff.ru/usage"><font color="#000000"
size="3">http://www.Kalashnikoff.ru/usage</font></a><font
color="#000000" size="3">. Она обновляется
ежедневно. Статистика включает в
себя трафик, страны и регионы,
жители которых заходят на сайт,
посещаемость по часам и многое
другое. Зачем это? Да так, вдруг кому
интересно будет...</font></p>

<p><font color="#000000" size="3">И вот еще:
установил на сайте кнопку, которая
сигнализирует всем посетителям о
том, в Сети ли я сейчас или нет. Мне
понравилось это дело... Только
что-то &quot;глючит&quot; она иногда...</font></p>

<hr>

<p><font color="#000000" size="2"><br>
</font></p>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="100%"
bgcolor="#9CCDCD">
<tr>
<td align="center" width="100%"><a name="letters"><font
color="#004080" size="5"><strong>Ваши письма</strong></font></a></td>
</tr>
</table>
</center></div>

<p>Дорогие мои подписчики! Ваши
письма мы рассмотрим в следующем
спецвыпуске, который выйдет до 26
января 2001 года. Дело в том, что писем
ваших очень много, и большинство из
них будут интересны всем
подписчикам рассылки. Только вот
байты сейчас не позволяют сделать
это... Так что подождите, пожалуйста,
спецвыпуск 022.</p>

<hr>

<p><font color="#000000" size="2"><br>
</font></p>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="100%"
bgcolor="#9CCDCD">
<tr>
<td align="center" width="100%"><a name="shell"><font
color="#004080" size="5"><strong>Оболочка</strong></font></a></td>
</tr>
</table>
</center></div>

<p>Как вы уже знаете, наша оболочка
разбита на несколько файлов. Ничего
лучшего, чем разделить эти файлы по
разным окошкам, я не придумал.
Надеюсь, что вы без труда
разберетесь. Как скопировать эти
файлы в DOS-формат - я писал в
предыдущих выпусках.</p>

<p>Тем не менее, если вам лень
копировать каждый файл в DOS-формат,
то вы можете перекачать все целиком
отсюда: <a
href="http://www.Kalashnikoff.ru/Assembler/Issues/Enclosures/Sshell21.rar">http://www.Kalashnikoff.ru/Assembler/Issues/Enclosures/Sshell21.rar</a>.</p>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="80%">
<tr>
<td align="center" colspan="2" width="100%"><font
color="#FF0000" size="4"><strong>Sshell21.asm</strong></font><font
color="#000000" size="2"><br>
</font><font size="4"><!--webbot bot="Validation" b-value-required="TRUE"
  i-minimum-length="1" i-maximum-length="80" --><textarea name="Sshell" rows="5"
cols="21">;              Sshell21.ASM - программа к рассылке № 021

; (С) Авторские права на файлы-приложения принадлежат подписчикам рассылки
; &quot;Ассемблер? Это просто! Учимся программировать&quot;
; Автор рассылки:
; Калашников Олег Александрович (e-mail: Assembler@Kalashnikoff.ru)
;                 http://www.Klashnikoff.ru

; --- Ассемблирование (получение *.com файла) ---
;При использовании MASM:
;ML.EXE Sshell21.asm /AT

;При использовании TASM:
;TASM.EXE Sshell21.asm
;TLINK.EXE Sshell20.obj /t/x

;______________________________________________________

 .286 ;Будем использовать команды 80286 процессора
CSEG segment
assume cs:CSEG, ds:CSEG, es:CSEG, ss:CSEG
org 100h

Start:
        jmp Begin

; ======= Процедуры =========
; Головная
include main.asm

; Работа с дисплеем
include display.asm

; Работа с файлами
include files.asm

; Работа с клавиатурой
include keyboard.asm

; Сообщения
include messages.asm

; Переменные
include data.asm

; Начало программы
Begin:
        call Check_video ;проверим видеорежим и текущую страницу

        mov ah,9
        mov dx,offset Mess_about
        int 21h ;выведем сообщение с приветствием

        call Main_proc ;вызывем головную процедуру

; Сюда мы попадем толко в том случае, если пользователь решил выйти в DOS
        int 20h

Finish equ $

CSEG ends
end Start</textarea></font></td>
    </tr>
    <tr>
        <td align="center" width="50%"><font color="#000000"
        size="2"><br>
        </font><font size="4">Display.asm</font><font
        color="#000000" size="2"><br>
        </font><font size="4"><!--webbot bot="Validation"
          b-value-required="TRUE" i-minimum-length="1" i-maximum-length="80" --><textarea name="Sshell" rows="5"
        cols="21">;        ===== DISPLAY.ASM - процедуры работы с экраном ======

; === Рисуем рамку заданного размера в центре экрана ===
Draw_frame proc
     mov bp,sp ;BP = SP
     add bp,2  ;Увеличим BP на 2, т.к. первые два байта - возврат из процедуры

     push es ;Сохраним ES

     push 0B800h ;ES должен указывать на сегмент 0-ой видеостраницы
     pop es      ;это сработает только на 286+ процессоре!!!

;________________________________________
;
; Производим вычисления для того, чтобы
; разместить ЛЮБУЮ рамку в цетре экрана.
;________________________________________

     mov ax,Height_X ;AX = высота нашей рамки
     shr al,1        ;делим высоту на 2 путем смещения битов вправо на 1
     mov dh,11       ;Середина
     sub dh,al       ;DH (строка) ГОТОВА!!!!!

     mov ax,Width_Y  ;AX = ширина нашей рамки
     shr al,1        ;делим ее на 2
     mov dl,39       ;Середина
     sub dl,al       ;DL (колонка) ГОТОВА!!!!!
;Теперь DH содержит центрированный ряд (строку),
;а DL - колонку относительно размеров рамки (окошка)...
;_________________________________________

  ;Сохраним полученный адрес, с которого начинается вывод рамки
  ;Нужно для того, чтобы выводить сообщения в рамке.
     mov Num_DX,dx

     mov ax,Other ;Получим дополнительную информацию
     test al,1    ;Нулевой бит равен 0?
     jz No_copyscr ;Если так, то копировать экран не нужно.

     mov ax,Height_X ;Иначе копируем в область 2 видеостраницы
     add ax,2        ;+2, т.к. учитываем 'г=¬' и 'L=-'
     call Copy_scr

No_copyscr:
     call Get_linear ;получаем линейный адрес в видеобуфере из DX,
     push di         ;который и сохраним...

     mov ax,Attr ;в AH - атрибуты цвета рамки
     mov al,'г'  ;верхний левый угол...
     stosw       ;заносим два байта (атрибут в AH / символ в AL)

     mov al,'='  ;далее...
     mov cx,Width_Y ;в CX - ширина рамки
     rep stosw   ;поехали...

     mov al,'¬'  ;завершаем верхний ряд
     stosw

     pop di      ;восстановим DI + 160 (следующий ряд)
     add di,160
     inc dh      ;DH &quot;идет в ногу&quot; с текущим рядом
                 ;нужно для того, чтобы вывести внизу рамки сообщение

;теперь у нас примерно такая ситуация на экране:
;г===========================¬
;_
;где _, там у нас DI и DH


     mov cx,Height_X ;CX - кол-во повторов (высота)

Next_lined:
     push cx ;сохраним счетчик
     push di ;сохраним DI

     mov al,'¦' ;вывели этот символ
     stosw

     mov al,32      ;32 - пробел (или 20h или ' ')
     mov cx,Width_Y ;CX = ширина
     rep stosw      ;понеслась...

     mov al,'¦' ;завершаем ряд...
     stosw

     pop di
     add di,160 ;переводим DI на следующий ряд
     inc dh     ;передвигаем DH на 1
     pop cx     ;восстановим счетчик
     loop Next_lined ;следующий ряд...

;теперь у нас примерно такая ситуация на экране:
;г===========================¬
;¦                           ¦
;¦                           ¦
;¦                           ¦
;_ - тут DI и DH


     mov al,'L' ;низ рамки...
     stosw

     mov al,'='
     mov cx,Width_Y
     rep stosw

     mov al,'-'
     stosw

;теперь у нас примерно такая ситуация на экране:
;г===========================¬
;¦                           ¦
;¦                           ¦
;¦                           ¦
;L===========================-


;Выводим сообщение внизу рамки
     mov si,Mess_dn   ;SI = адрес строки для вывода
     call Draw_messfr ;Выводим сообщение ВНИЗУ рамки
     ;Вот зачем нам нужно было постоянно увеличивать DH на 1
     ;(чтобы DH &quot;шло в ногу&quot; с DI)!

;теперь у нас примерно такая ситуация на экране:
;г===========================¬
;¦                           ¦
;¦                           ¦
;¦                           ¦
;L==== Сообщение внизу ======-


;Выводим сообщение вверху рамки
     mov dx,Num_DX
     push dx
;Вот нам и адрес верхнего ряда понадобился!
     mov si,Mess_up   ;SI = адрес строки для вывода
     call Draw_messfr ;Выводим сообщение вверху рамки

;теперь у нас примерно такая ситуация на экране:
;г==== Сообщение вверху =====¬
;¦                           ¦
;¦                           ¦
;¦                           ¦
;L==== Сообщение внизу ======-


     pop dx
     add dx,0101h
     mov si,Mess_ins ;Адрес сообщения, которое будет внутри рамки
     or si,si        ;Если там 0, то не выводим...
     jz No_draw
     mov ah,[si]
     inc si
     call Print_string ;Выводим строку...

;теперь у нас примерно такая ситуация на экране:
;г==== Сообщение вверху =====¬
;¦Сообщение внутри           ¦
;¦                           ¦
;¦                           ¦
;L==== Сообщение внизу ======-


No_draw:
     mov ax,Other ;Получим дополнительную информацию
     test ax,10b  ;Первый бит равен нулю?
     jz No_upline ;Если так, то на метку No_upline

     mov dx,Num_dx ;Получим начальное значение рамки (верхний левый угол - г)
     add dh,2      ;Прибавим 2 для того, чтобы вывести линию (см. ниже)
     call Get_linear

     mov ax,Attr
     mov al,'¦'
     mov cx,1
     stosw

     mov cx,Width_Y ;в CX - ширина рамки
     mov al,'-'
     rep stosw

     mov al,'¦'
     stosw

;теперь у нас примерно такая ситуация на экране:
;г==== Сообщение вверху =====¬
;¦Сообщение внутри           ¦
;¦--------- линия -----------¦
;¦                           ¦
;¦                           ¦
;L==== Сообщение внизу ======-


No_upline:
     pop es ;восстановим ES

     ret 14 ;Выходим, очистив стек от переменных в 14 байт (7 слов)
            ;Посмотрите, в MAIN.ASM как мы вызываем данную процедуру.
Draw_frame endp


; --- Вывод сообщениий вверху и внизу рамки ---
;Вспомогательна процедура.
Draw_messfr proc
     or si,si ;SI = 0?..
     jz No_drawup ;тогда ничего выводить не надо, выходим

     mov ah,[si]  ;Первый символ строки - атрибут (см. DATA.ASM)
     inc si       ;Следующий байт - начало строки
     call Count_strmid ;Вычисляем середину строки

     call Print_string ;Выводим строку на экран

No_drawup:
     ret
Draw_messfr endp

; === Вычисляем середину строки ===
;Вход: CS:SI - адрес строки
;Выход: DL - середина адреса для вывода строки
Count_strmid proc
     push es ;Сохраним регистры...
     push di
     push ax

     push cs ;ES=CS
     pop es
     mov di,si ;DI=SI
     xor al,al ;AL=0
     mov cx,0FFFFh ;сколько символов перебирать (возьмем максимум)...
     repne scasb ;Ищем 0 в строке
     ;0 найден! DI указывает на следующий символ за найденным 0

;SI=начало строки
;DI=конец строки+1
     sub di,si ;DI=DI-SI-1 = длина строки
     dec di

     shr di,1  ;Делим длину на 2
     mov ax,40 ;Делим кол-во символов в строке на 2 = 40
     sub ax,di ;AX=40-половина длины строки = нужная колонка
     mov dl,al ;DL=колонка, с которой следует выводить строку!

     pop ax    ;Восстановим регистры
     pop di
     pop es
     ret
Count_strmid endp

; === Вывод стоки на экран ===
;Вход: DS:SI - адрес строки для вывода
;      DX - координаты для вывода
;      AH - атрибуты строки
;Выход: ничего
Print_string proc
     call Get_linear ;Получаем линейный адрес строки

Next_symstr:
     lodsb          ;Получаем очередной символ строки
     or al,al       ;Это 0 (конец строки?)
     jz Stop_outstr ;Да - выходим...
     stosw          ;Иначе заносим в видеобуфер атрибут (AH) и символ (AL)
     jmp short Next_Symstr ;Следующий символ

Stop_outstr:
     ret
Print_string endp

; === Преобразование DH:DL в линейный массив ===
Get_linear proc
    push ax    ;сохраним все используемые регистры
    push bx
    push dx

    shl dl,1   ;математика: умножаем DL на 2 (DL=DL*2)...

    mov al,dh  ;в AL - ряд,
    mov bl,160 ;который нужно умножить на 160
    mul bl     ;умножаем: AL(ряд)*160; результат --- в AX

    mov di,ax ;результат умножения - в DI
    xor dh,dh ;аннулируем DH
    add di,dx ;теперь в DI линейный адрес в видеобуфере.

    pop dx    ;восстанавливаем регистры...
    pop bx
    pop ax
    ret

Get_linear endp

; === Проверяем видеорежим монитора и текущую видеостраницу ===
Check_video proc
     mov ah,0Fh
     int 10h
     cmp al,3  ;Текстовый режим?
     je Ok_video

     mov ax,3
     int 10h

Ok_video:
     or bh,bh  ;Нулевая страница?
     jz Ok_page

     mov ax,0500h
     int 10h

Ok_page:
     ret
Check_video endp

; === Сохраним экран ===
Save_mainscr proc
    pusha       ;Сохраним регистры...
    push es
    push ds

    push 0B800h ;с нулевой страницы
    pop ds
    xor si,si   ;нулевого символа

    push 0B900h ;в первую страницу...
    pop es
    xor di,di   ;нулевой символ...

    mov cx,2000 ;4000 байт
    rep movsw   ;делаем копию.

    pop ds      ;восстановим регистры.
    pop es
    popa
    ret
Save_mainscr endp

; === Восстановим экран ===
Restore_mainscr proc
    pusha
    push es
    push ds

    push 0B900h ;с первой видеостраницы
    pop ds
    xor si,si

    push 0B800h ;в нулевую...
    pop es
    xor di,di

    mov cx,2000
    rep movsw

    pop ds ;очень просто и быстро!!!
    pop es
    popa
    ret
Restore_mainscr endp

; === Копируем часть экрана ===
;Вход: DH - ряд, с которого необходимо начать копирование
;      AL - количество рядов для копирования
;Выход: ничего
Copy_scr proc
    pusha   ;Как обычно сохраним регистры
    push es
    push ds

    xor dl,dl       ;Обнулим DL на всякий случай. Теперь DH = ряд, DL = 0
    call Get_linear ;Получим линейный адрес

    mov bl,160  ;Получим количество байт, котрые нужно копировать
    mul bl
    mov cx,ax   ;Их - в CX (будем использовать CX как счетчик)

    mov si,di   ;DS:SI - откуда копируем
    xor di,di   ;ES:SI - куда копируем
    mov Num_copySI,si ;Сохраним полученные значения для восстановления
    mov Num_copyDI,di
    mov Num_copyCX,cx
    push 0B800h ;Настроим сегментные регистры
    pop ds
    push 0BA00h
    pop es
    rep movsb  ;Копируем...

    pop ds     ;Восстановим регистры и выйдем...
    pop es
    popa
    ret        ;Теперь есть копия в самом начале 2-ой видеостраницы.

Num_copySI dw ?
Num_copyDI dw ?
Num_copyCX dw ?
Copy_scr endp

; === Восстанавливаем часть экрана ===
;Вход: ничего (все уже сохранено в переменных &amp;#x0018)
;Выход: ничего
Restore_scr proc
    pusha      ;Сохраним регистры
    push es
    push ds

    mov di,Num_copySI ;Получим сохраненные процедурой Copy_scr значения
    mov si,Num_copyDI
    mov cx,Num_copyCX
    push 0BA00h       ;Настроим сегментные регистры
    pop ds
    push 0B800h
    pop es
    rep movsb  ;Копируем со 2-ой страницы в 0-ую...

    pop ds     ;Восстановим регистры
    pop es
    popa
    ret
Restore_scr endp

; === Прячем курсор, сохранив предварительно его текущую позицию ===
Hide_cursor proc
    mov ah,3          ;получаем текущую позицию курсора
    mov bh,Video_page
    int 10h
    mov Pos_cursor,dx ;теперь она в DX (отсчет с нуля!)

    mov ah,2  ;Установим курсор на первую страницу как на нулевой
    mov bh,1  ;Нужно для того, если пользователь захочет
    int 10h   ;посмотреть, что там DOS написАла (Ctrl+F5)

    mov bh,Video_page ;прячем курсор на 0-ой видеостранице
    mov dx,1900h      ;(установим его на 25 строку (19h))
    int 10h

    ret
Hide_cursor endp

; === Восстановим курсор ===
Restore_cursor proc
    mov ah,2
    mov bh,Video_page ;видеостраница
    mov dx,Pos_cursor ;сохраненная позиция
    int 10h           ;установим (позиционируем) курсор
    ret
Restore_cursor endp</textarea></font></td>
        <td align="center" width="50%"><font color="#000000"
        size="2"><br>
        </font><font size="4">Files.asm</font><font
        color="#000000" size="2"><br>
        </font><font size="4"><!--webbot bot="Validation"
          b-value-required="TRUE" i-minimum-length="1" i-maximum-length="80" --><textarea name="Sshell" rows="5"
        cols="21">; ==== FILES.ASM - процедуры работы с файлами ====

; === Читаем файлы в текущем каталоге ===
Get_files proc
      call Get_first    ;Получаем первый файл
      jc No_morefiles   ;Если нет файлов вообще - на выход

      cmp word ptr cs:[DTA+1Eh],002Eh ;Первый файл - '.'?
      je Next_file    ;Если так, то ищем следующий файл...

      call Move_file  ;Если нет, то переносим файл в память.

Next_file:
      call Get_other  ;Получаем следующий файл...
      jc No_morefiles ;Файлы закончились - на выход.

      call Move_file  ;Если нет, то переносим файл в память.
      jmp short Next_file ;Ищем следующий файл...

No_morefiles:
      ret
Get_files endp

; === Поиск первого файла в текущем каталоге ===
Get_first proc
;Атрибуты файла (в CX):
;000001 - только чтение
;000010 - спрятанный
;000100 - системный
;001000 - метка тома
;010000 - подкаталог
;100000 - архивный

      mov ah,4Eh       ;Функция поиска первого файла
      mov cx,110111b   ;С атрибутами:
                       ;архивный (archive), подкаталог (directory),
                       ;системный (system), спрятанный (hidden)
                       ;только чтение (read-only)
      mov dx,offset All_files ;Маска поиска
      int 21h
      ret
Get_first endp

; === Поиск следующих файлов ===
Get_other proc
      mov ah,4Fh ;Функция поиска следующих файлов
      mov dx,9Eh ;DX указывает на DTA
      int 21h

      ret
Get_other endp

; --- Перенос файла из DTA в сегмент файлов ---
Move_file proc
      push es
      mov si,DTA+1Eh  ;SI=DTA+1Eh=имя найденного файла
      mov di,Current_offset ;Текущее свободное смещение
      mov es,Seg_files  ;ES=сегмент для найденных файлов

Next_fbyte:
      lodsb         ;Получаем первый символ имени файла
      or al,al      ;Это нуль (конец имени)?
      jz End_offile ;Да - на выход
      stosb         ;Нет - сохраним символ в памяти
      jmp short Next_fbyte ;Следующий символ...

End_offile:
      stosb         ;Запишем нуль в память после имени файла
      mov Current_offset,di ;Сохраним текущее смещение
      stosb         ;Запишем еще один нуль...
      pop es
      ret
Move_file endp

; === Вывод наденных файлов на экран ===
Out_files proc
      mov bl,Number_files  ;BL указывает на количество выводимых файлов
      push ds
      push es
      mov ds,Seg_files ;DS=сегмент найденных файлов в памяти
      push 0B800h
      pop es

      xor si,si
      mov ah,1Bh   ;Атрибуты
      mov dx,0302h ;Начало для вывода файлов

Next_fileout:
      call Print_string ;Выводим очередной файл

      cmp byte ptr [si],0 ;Следующий байт=0? Значит, это был последный файл...
      jz Exit_files  ;Тогда выходим.

      add dx,0100h ;Иначе увеличиваем DH на 1 для вывода следующего имени...
      dec bl       ;Уменьшаем количество выводимых файлов на 1
      jnz short Next_fileout ;Уже 0? Тогда больше выводить не нужно...

Exit_files:
      pop es
      pop ds
      ret

Number_files db 20 ;Количество выводимых файлов на экран.
Out_files endp</textarea></font></td>
    </tr>
    <tr>
        <td align="center" width="50%"><font color="#000000"
        size="2"><br>
        </font><font size="4">Keyboard.asm</font><font
        color="#000000" size="2"><br>
        </font><font size="4"><!--webbot bot="Validation"
          b-value-required="TRUE" i-minimum-length="1" i-maximum-length="80" --><textarea name="Sshell" rows="5"
        cols="21">; ==== KEYBOARD.ASM - процедуры работы с клавиатурой ====

;  === Ждем нажатия клавиши ===
Pause proc
      mov ah,10h
      int 16h
      ret
Pause endp</textarea></font></td>
        <td align="center" width="50%"><font color="#000000"
        size="2"><br>
        </font><font size="4">Main.asm</font><font
        color="#000000" size="2"><br>
        </font><font size="4"><!--webbot bot="Validation"
          b-value-required="TRUE" i-minimum-length="1" i-maximum-length="80" --><textarea name="Sshell" rows="5"
        cols="21">;                  === MAIN.ASM - Головная процедура ===

Main_proc proc

      call Hide_cursor ;прячем курсор

      call Prepare_all

      call Save_mainscr ;сохраним содержимое экрана...

      push 23     ;высота рамки без 'г=¬' и 'L=-'
      push 78     ;ширина рамки (т.е. на весь экран) без '¦' и '¦'
      push 1F00h  ;цвет - светло-белый на синем фоне
      push offset Mess_head ;надпись вверху рамки (если 0, то не выводить)
      push offset Mess_down ;надпись внизу рамки (если 0, то не выводить)
      push 0      ;сообщение внутри рамки (если 0, то не выводить)
      push 10b    ;Экран не копировать, но вывести верхнюю линию.
      call Draw_frame ;Рисуем рамку на весь экран
;ИТОГО: в стек заносим 14 байт вместо 20!

      call Get_files

      call Out_files

Next_key:
      call Pause ;давим кнопку!!!
      or al,al
      jz Ext_code  ;Это расширенный ASCII-код клавиши? Да - проверяем его. &amp;#x0019

      cmp al,27    ;Нажали ESC?
      jne Next_key ;Нет - ждем дальше... &amp;#x0018

      call Quit_prog ;Удостоверимся у пользователя о выходе из программы. &amp;#x0019
      jnc Next_key   ;Пользователь подтвердил выход? НЕТ? Тогда на Next_key &amp;#x0018

;Да, подтвердил (а жаль!). Тогда выходим.
      call Restore_mainscr ;восстановим содержимое экрана
      call Restore_cursor  ;восстановим позицию курсор

      ret ;выход!

Ext_code:
      cmp ah,62h         ;Нажали Ctrl+F5?
      je User_screenl    ;Да - показываем экран пользователю &amp;#x0019.
      jmp short Next_key ;Нет - ждем другую клавишу &amp;#x0018

User_screenl:
      mov ax,0501h ;Показываем пользователю 1 видеостраницу.
      int 10h
      call Pause   ;Может быть, подождем?.. Клавишу, а не мою маму!

      mov ax,0500h ;Опять на нулевую устанавливаем.
      int 10h
      jmp short Next_key ;Ждем дальше... &amp;#x0018
Main_proc endp

; === Готовим все необходимое для работы ===
Prepare_all proc
      call Set_DTA
      call Prepare_memory

      ret
Prepare_all endp

;--- Ужимаем память ---
Prepare_memory proc
      mov bx,offset Finish
      shr bx,4
      inc bx
      mov ah,4Ah
      int 21h

      mov ah,48h
      mov bx,1000h
      int 21h

      mov Seg_files,ax

      ret
Prepare_memory endp

; --- Установим DTA ---
Set_DTA proc
    mov ah,1Ah
    mov dx,80h
    int 21h
    ret
Set_DTA endp

; === Выходим из программы? ===
Quit_prog proc
      push 1     ;высота рамки
      push offset Mess_quitl ;ширина рамки
      push 4F00h ;цвет - светло-белый на синем фоне
      push offset Mess_qup   ;надпись вверху рамки (если 0, то не выводить)
      push 0     ;надпись внизу рамки (если 0, то не выводить)
      push offset Mess_quit  ;сообщение внутри рамки
      push 01b   ;Копировать экран, но не выводить верхнюю линию
      call Draw_frame ;Рисуем рамку

      call Pause
      call Restore_scr ;Восстановим сохранунную часть экрана.

      cmp al,'Y'       ;Нажали 'Y' / 'y' / Enter (13)?
      je Yes_quit      ;Да! &amp;#x0019
      cmp al,'y'
      je Yes_quit
      cmp al,13
      je Yes_quit

      clc  ;Ставим меточку, что нажали другую клавишу (сбросим флаг переноса).
      ret

Yes_quit:
      stc  ;Установим флаг переноса (нажали 'Y', значит выходим)...
      ret
Quit_prog endp</textarea></font></td>
    </tr>
    <tr>
        <td align="center"><p align="center"><font
        color="#000000" size="2"><br>
        </font><font size="4">Messages.asm</font><font
        color="#000000" size="2"><br>
        </font><font size="4"><!--webbot bot="Validation"
          b-value-required="TRUE" i-minimum-length="1" i-maximum-length="80" --><textarea name="Sshell" rows="5"
        cols="21">;   === MESSAGES.ASM - сообщения, выводимые оболочкой ===

Mess_about db 0Ah, 0Dh, 'SuperShell - оболочка для DOS, написанная на Ассемблере.',0Ah, 0Dh
           db 'Рассылка &quot;Ассемблер? Это просто! Учимся программировать&quot;, Выпуск № 021',0Ah,0Dh
           db 'http://www.Kalashnikoff.ru. E-mail: Assembler@Kalashnikoff.ru',0Ah,0Dh,0Ah
           db '(C) Авторские права на файлы-приложения принадлежат всем подписчикам рассылки.',0Ah, 0Dh, 0Ah
           db 9,9,'=== Россия, Москва, 2001 год ===',0Ah,0Dh,'$'

Mess_head db 1Eh, ' Super Shell, Версия 1.0 ',0
Mess_down db 1Dh, ' Россия, Москва, 2001 ',0

Mess_qup db 4Eh, ' Выход ',0
Mess_quit db 4Bh, ' Вы действительно хотите выйти в DOS (Y/N)?',0
Mess_quitl equ $-Mess_quit</textarea></font></p>
        </td>
        <td align="center"><font size="4">Data.asm</font><font
        color="#000000" size="2"><br>
        </font><font size="4"><!--webbot bot="Validation"
          b-value-required="TRUE" i-minimum-length="1" i-maximum-length="80" --><textarea name="Sshell" rows="5"
        cols="21">;  === DATA.ASM - данные оболочки ===

;               ==== ПЕРЕМЕННЫЕ ====

Num_attr db ? ;переменная для атрибутов

Num_DX dw ?

Video_page db 0 ;текущая видеостраница

Pos_cursor dw ? ;главная позиция курсора


; --- Данные для процедуры Draw_frame ---
Height_X equ [bp+12] ;высота рамки
Width_Y  equ [bp+10] ;ширина рамки
Attr     equ [bp+8]  ;атрибуты рамки
Mess_up  equ [bp+6]  ;сообщение вверху рамки
Mess_dn  equ [bp+4]  ;сообщение внизу рамки
Mess_ins equ [bp+2]  ;сообщение внутри рамки
Other    equ [bp]    ;иная конфигурация окна

All_files db '*.*',0
DTA equ 80h
Seg_files dw ? ; Сегментный адрес буфера файлов
Current_offset dw 0</textarea></font></td>
</tr>
</table>
</center></div>

<hr>

<p><strong>Итак, поехали...</strong></p>

<p>Если вы уже запустили нашу
&quot;оболочку&quot;, то ничего особенно
интересного вы, скорее всего, не
нашли. Мы просто читаем содержимое
текущего каталога в память и
выводим первые двадцать найденных
файлов на экран.</p>

<p>Однако, присмотревшись, вы
поймете, что наша оболочка
проделывает уйму работы. А именно:</p>

<p align="center">_______</p>

<p>1. Ищет первый файл;</p>

<p>2. Если это '.', то см. пункт 4; *</p>

<p>3. Заносит в память имя найденного
файла;</p>

<p>4. Ищет следующий файл;</p>

<p>5. Заносит имя найденного файла в
память;</p>

<p>6. Файлы закончились?</p>

<p>7. Нет - см. пункт 4.</p>

<p>8. Да - начинает выводить файлы на
экран.</p>

<p>9. Выведено уже 20 файлов? Нет - см.
пункт 8. Да - см. пункт 10.</p>

<p>10. Ждет нажатия на клавишу.</p>

<p>11. Пользователь нажал ESC? Да - см.
пункт 12. Нет - см. пункт 10.</p>

<p>12. Запрашивает пользователя:
уверен ли он, что хочет выйти в DOS.</p>

<p>13. Не уверен (т.е. нажал все, что
угодно, кроме 'Y' или 'y') - см. пункт 10.</p>

<p>14. Уверен (т.е. нажал 'Y' или 'y') -
выходит в DOS.</p>

<p>Вот, собственно, и алгоритм работы
нашей оболочки.</p>

<p><em>* Примечание</em>. В любом
подкаталоге первый файл всегда '.' .
Точнее, это не файл, а каталог. Если
в командной строке набрать 'CD .' , то
директория не изменится. Т.е. данный
каталог - это просто текущий
каталог. Нам его не нужно выводить в
оболочке. Команда DIR выводить эту
директорию на экран, в отличие от
оболочек.</p>

<p>Теперь подробнее...</p>

<p align="center">_______</p>

<p><strong>Новшество первое.</strong></p>

<p>Обратите внимание, как мы
вызываем процедуру Draw_frame (MAIN.ASM,
Main_proc). На первый взгляд - ничего
особенного. Но это только кажется...
Раньше мы заносили в стек адреса
строк, которые будут выводится
вверху и внизу нашей рамки, а также
их атрибуты. Теперь мы атрибуты в
стек не заносим. Но как же тогда
сообщения выводятся в нужном цвете?
Обратите внимание, <strong>что</strong>
находится перед строками Mess_head и
Mess_down:</p>

<p>Mess_head db <strong>1Eh</strong>, ' Super Shell, Версия
1.0 ',0<br>
Mess_down db <strong>1Dh</strong>, ' Россия, Москва,
2001 ',0</p>

<p>Вот это и есть как раз нужные нам
атрибуты соответствующих строк.
Поступая таким образом, мы экономим
байты нашей оболочки, более того, мы
не нагружаем стек. Отпадает
необходимость заносить в стек два
слова атрибутов для верхней строки
и два слова для нижней. Процедура
вывода строк на экран (DISPLAY.ASM,
Draw_messfr) перед тем, как выводить
строку, занесет в AH первый символ,
который и будет являться атрибутом!
Это проще!</p>

<p><strong>mov ah,[si]</strong> <em>;Первый символ
строки - это атрибут</em><br>
inc si <em>;Следующий байт - начало
строки</em><br>
call Count_strmid <em>;Вычисляем середину
строки</em></p>

<p>call Print_string <em>;Выводим строку на
экран</em></p>

<p align="center">_______</p>

<p><strong>Новшество второе.</strong></p>

<p>Теперь процедура рисования рамки
(DISPLAY.ASM, Draw_frame) выводит еще и линию
вверху окошка по нашему требованию.
А что мы добавили перед вызовом данной процедуры? Да ничего почти!
Просто изменили один бит:</p>

<p>push 10b ;<em>Экран не копировать, но
вывести верхнюю линию.</em><br>
call Draw_frame ;<em>Рисуем рамку на весь
экран</em></p>

<p>Т.е. нулевой бит последнего
заносимого слова в стек (если он
включен (установлен)) указывает на
то, следует ли копировать экран в
буфер или нет. Второй бит - следует
ли рисовать линии вверху окошка или
нет.</p>

<p>Видите, как наша процедура
совершенствуется на глазах. А это
далеко не предел! Еще дальше пойдем
- еще больше будет!</p>

<p><font size="4"><strong>Внимание!</strong></font>
&quot;А как же нам проверить, включен
ли нулевой бит или нет? Скорее
всего, оператором CMP здесь не
обойтись.&quot; Да, действительно, не
обойтись. И вот почему.</p>

<p>Представьте, что первый раз мы
выводим окошко, предварительно
скопировав экран, но не выводим
линию вверху. Тогда нулевой бит
будет равен 1:</p>

<p>push 1</p>

<p>Следовательно, можно проверить
так (в процедуре draw_frame данное слово
будет называться Other (иное)):</p>

<p>cmp Other,1</p>

<p>Если флаг нуля устанавливается,
т.е. Other = 1, то нужно предварительно
скопировать экран в память.</p>

<p>Хорошо. Теперь представим, что
нужно вывести окошко с линией
вверху, но не копировать экран (т.е.
первый бит будет равен единице, а
нулевой - 0):</p>

<p>push 10b <em>;или push 2</em></p>

<p>...</p>

<p>cmp Other,2</p>

<p>И, наконец, представим, что нужно
вывести и линию вверху, и сохранить
экран:</p>

<p>push 11b ;или push 3</p>

<p>...</p>

<p>cmp Other,3</p>

<p>Вроде все нормально... Однако, тем
не менее, существует проблема.
Нулевой бит (т.е. следует ли
копировать экран или нет) мы
проверяем в начале процедуры Draw_frame
(т.е. до того, как вывели окошко), а
вывод верхней линии - после того,
как экран скопирован (если нужно), и
выведено окошко. <strong>Теперь
подумайте: можно ли с помощью CMP
проверить установлен ли бит
нулевой, игнорируя (умышленно не
замечая) все оставшиеся биты
проверяемого слова (Other)?</strong>
Вдумайтесь в вопрос. Не спешите
читать дальше. Правда, подумайте!
Возьмите листок бумаги и
поэкспериментируйте! Если сами
поймете что да как, то будет гораздо
проще разобраться с новым оператором...</p>

<p>...</p>

<p>Не сомневаюсь, что вы нашли выход
из положения. Например, так:</p>

<p>mov ax,Other <em>;Перенесем временно в AX
значение переменной Other</em><br>
push ax<br>
and ax,1 <em>;Аннулируем все биты, кроме
нулевого (вспомним логические
команды)</em><br>
cmp ax,1 <em>;Проверим, равен ли теперь AX
1?</em><br>
pop ax<br>
mov Other,ax <em>;Восстановим переменную
Other</em><br>
je Ravno <em>;Перейдем, если равен</em></p>

<p><strong>Следует отметить, что
операторы MOV и POP флаги (в частности,
флаг нуля) не меняют!</strong></p>

<p>Хорошо получилось! Или не очень?
Вероятно, есть другие способы?
Безусловно есть! Ассемблер такой
гибкий язык, что может делать
невероятные, нет - поистине
невероятные вещи!</p>

<p>Чтобы временно не сохранять
регистр или переменную перед
проверкой одного-двух-трех... битов,
используется оператор TEST:</p>
<div align="left">

<table border="1" cellspacing="1" bordercolorlight="#FFFFFF">
<tr>
<td width="25%" bgcolor="#8CC8C8"><strong>Название</strong></td>
<td width="25%" bgcolor="#8CC8C8"><strong>Перевод</strong></td>
<td width="20%" bgcolor="#8CC8C8"><strong>Применение</strong></td>
<td width="20%" bgcolor="#8CC8C8"><strong>Процессор</strong></td>
</tr>
<tr>
<td width="25%">TEST приемник, источник</td>
<td width="25%">Test - тест, проверка</td>
<td width="20%">Проверка одного и
более битов</td>
<td width="20%">8086</td>
</tr>
</table>
</div>

<p><em>Примеры:</em></p>

<p>mov ax,10100001b<br>
test ax,1 <em>;Проверим на то, равен ли
нулевой бит единице.</em><br>
<strong>jnz</strong> Ravno <em>;Переход, если
равен</em></p>

<p>Обратите внимание, что после CMP мы
ставим JE (JZ), если хотим перейти на
определенную метку в случае, если
приемник и источник равны. В
команде TEST все идет
&quot;шиворот-навыворот&quot;. Т.е. JE (JZ)
перейдут на метку, если приемник и
источник <strong>НЕ</strong> равны и
наоборот: JNE (JNZ) перейдут на метку,
если приемник и источник равны. Не
надо путать!</p>

<p><em>Еще пример:</em></p>

<p>mov cl,100101b<br>
test cl,1000b ;Проверим на то, равен ли
третий бит единице<br>
<strong>jz</strong> Ne_ravno ;Переход, если <strong>НЕ</strong>
равен</p>

<p>Поехали дальше...</p>

<p>Мы остановились на том, что
переменная Other будет содержать
более одного параметра. Причем эти
параметры должны отвечать на
вопрос ДА или НЕТ, т.е. РАВНО или НЕ
РАВНО. Как, например, в нашей
процедуре Draw_frame. Повторю: первый
бит отвечает за рисование линии
вверху окошка, а нулевой - за
копирование участка экрана перед
выводом окошка. Вспомните окно
подтверждения выхода из оболочки.
Экран-то прежде копируется в
память. А вдруг пользователь
передумает выходить? Нам что тогда,
заново рисовать основное окно и
перечитывать каталоги? Или проще
сохранить часть затираемого
экрана, а затем моментально
восстановить его? Да что я говорю?!
Прошли мы уже это...</p>

<p>Использование битов переменной
для подобных целей подходит как
никогда лучше. Мы экономим байты.
Вместо, скажем, 8 или 16 переменных мы
используем всего одну! Красота...</p>

<p>Вот кусок из нашего
файла-приложения (этим мы подведем
черту с TESTом):</p>

<p>mov ax,Other <em>;Получим дополнительную
информацию</em><br>
test al,1 <em>;Нулевой бит равен 0?</em><br>
jz No_copyscr <em>;Если так, то копировать
экран не нужно.</em></p>

<p align="center"><em>___________</em></p>

<p align="center"><font size="4"><strong>Основы
работы с памятью в DOS.</strong></font></p>

<p>Сразу отмечу, что пока мы будем
работать с основной памятью, т.е. с
640 Кб.</p>

<p>Подробно рассмотреть управление
памятью в DOS за один выпуск
невозможно. Мы сегодня затронем
лишь ключевые, основополагающие
моменты.</p>

<p>Как только программа загрузилась,
DOS автоматически отводит для нее
всю свободную память. Программист
может по своему усмотрению урезать
блоки памяти, отводить другие
(сколько памяти хватит), а также
освобождать отведенные участки
(блоки) памяти.</p>

<p><strong>Зачем это нужно?</strong></p>

<p>Представьте ситуацию. Мы написали
программу, которая, в свою очередь,
загружает другую. Но так как вся
память изначально выделена только
нашей программе, то мы не сможем
загрузить никакую программу из
нашей. Ведь ей тоже нужно некоторое
количество памяти?</p>

<p>Для того, чтобы урезать память,
используется <strong>функция 4Ah
прерывания 21h</strong>:</p>
<div align="left">

<table border="1" cellpadding="0" cellspacing="0" width="70%"
bgcolor="#A3D1D1">
<tr>
<td valign="top" width="15%"><font size="4"><strong>Вход:</strong></font></td>
<td valign="top" width="45%" bgcolor="#B6DADA">AH=4Ah<br>
ES=сегмент распределенного
блока<br>
BX=размер блока в 16-и байтовых
параграфах</td>
</tr>
<tr>
<td valign="top" width="15%"><font size="4"><strong>Выход:</strong></font></td>
<td valign="top" width="45%" bgcolor="#B6DADA">JC -
ошибка, при этом:<br>
AX-код ошибки</td>
</tr>
</table>
</div>

<p>Распределенный блок в нашем
случае - вся память, отведенная
программе, начиная от нулевого
смещения сегмента CS и заканчивая
последним свободным байтом.
Поэтому перед вызовом функции 4Ah
следует убедиться в том, что ES
указывает на сегмент, куда мы
загрузились (см. таблицу выше)!</p>

<p>Вот какая ситуация после загрузки
нашей программы в память не будем
брать адреса; какая разница?):</p>

<p>1. Системные файлы; --- память
занята от 0 до текущего байта</p>

<p>2. Резидентные программы; --- память
занята от 0 до текущего байта</p>

<p>3. Наша программа; --- память занята
от 0 до текущего байта</p>

<p>4. Метка Finish; --- память занята от 0
до текущего байта</p>

<p>5. Отведенная память нашей
программе. --- память занята от 0 до
конца.</p>

<p>Получается, что ВСЯ память (640 Кб)
занята после того, как программа
загрузилась. Наша задача - урезать
занятую нашей программой память до
метки Finish (см. п. 3). Для чего это
нужно - рассмотрим позже.</p>

<p>Обратите внимание, как мы ужимаем
существующий блок памяти (MAIN.ASM,
Prepare_memory):</p>

<p>mov bx,offset Finish <em>;BX=последний байт
нашей программы</em><br>
shr bx,4 <em>;Т.к. BX должен содержать </em><em><strong>не
количество байт, а количество
блоков по 16 байт</strong></em><em>, то мы
должны сдвинуть биты вправо на 4</em><br>
inc bx <em>;Увеличим BX на один (на всякий
случай!)</em><br>
mov ah,4Ah <em>;Функция уменьшения/расширения
существующего блока памяти</em><br>
int 21h <em>;В данном случае урезаем, т.к.
наша программа, естественно, меньше
отведенного блока памяти после
загрузки.</em></p>

<p>Теперь картина такая:</p>

<p>1. Системные файлы; --- память
занята от 0 до текущего байта</p>

<p>2. Резидентные программы; --- память
занята от 0 до текущего байта</p>

<p>3. Наша программа; --- память занята
от 0 до текущего байта</p>

<p>4. Метка Finish; --- память занята от 0
до текущего байта</p>

<p>5. Память за меткой Finish. --- <font
color="#800000"><strong>память свободна до
конца 640 Килобайта, начиная с
первого байта, следующего за меткой
Finish!</strong></font></p>

<p>Размер памяти примерно такой: 640Кб
минус смещение метки Finish.</p>

<p>Теперь отведем кусок памяти
размером 1000h 16-и байтовых блоков
(параграфов) или 65536 байт:</p>

<p>mov ah,48h<br>
mov bx,1000h<br>
int 21h<br>
<br>
mov Seg_files,ax</p>

<p><strong>Функция 48h прерывания 21h -
выделить блок памяти:</strong></p>
<div align="left">

<table border="1" cellpadding="0" cellspacing="0" width="70%"
bgcolor="#A3D1D1">
<tr>
<td valign="top" width="15%"><font size="4"><strong>Вход:</strong></font></td>
<td valign="top" width="45%" bgcolor="#B6DADA">AH=48h<br>
BX=размер блока в 16-и байтовых
параграфах</td>
</tr>
<tr>
<td valign="top" width="15%"><font size="4"><strong>Выход:</strong></font></td>
<td valign="top" width="45%" bgcolor="#B6DADA">JC -
ошибка, при этом:<br>
AX-код ошибки;<br>
Иначе: AX=сегмент выделенного
блока.</td>
</tr>
</table>
</div>

<p>Думаю, что объяснять приведенный
над таблицей пример не нужно. Все и
так понятно. Рассмотрим только, что
получилось:</p>

<p>1. Системные файлы; --- память
занята от 0 до текущего байта</p>

<p>2. Резидентные программы; --- память
занята от 0 до текущего байта</p>

<p>3. Наша программа; --- память занята
от 0 до текущего байта</p>

<p>4. Метка Finish; --- память занята от 0
до текущего байта</p>

<p>5. Память за меткой Finish + 65536 байт; ---
память занята</p>

<p>6. Память, начиная с адреса Finish + 65537
байт --- <font color="#800000"><strong>свободна</strong></font></p>

<p><strong>Зачем мы выделили блок памяти
размером 64Кб?</strong></p>

<p>В эту память мы будем загружать
информацию о найденных файлах в
текущем каталоге. А как вы думаете NC
показывает вам файлы в окошечке?
Элементарно! Просто считывает их к
себе в память, а затем с ними
работает (точнее, вы работаете).
Команда DIR, например, не загружает в
память найденные файлы. А зачем? Она
нашла файл, вывела информацию на
экран и - следующий...</p>

<p><em><strong>Подписчик </strong></em><em>(задумчиво)</em><em><strong>:</strong></em><em>
Я тут сейчас вот как бы нечайно
подумал... Мне кажется, это так
сложно все... Нет, наверное, это не
для меня... Пусть другие пишут на
Ассемблере, а я лучше на Бейсике...
Сдался мне Асм... Калашников этот
вечно лишние проблемы
накручивает... Спал раньше так
хорошо по ночам...</em></p>

<p>Ну и очень плохо, что вы спешите
делать выводы, не попробовав даже
написать простейшую программку. На
ваш взгляд - это сложно. На самом
деле - элементарщина! Не пугайтесь!!!
Все самое интересное только
начинается! Конечно, сложные и
неинтересные вещи. Но это вам пока
только кажется, что они нудные, и
знать их не надо. На самом деле, в
Ассемблере не бывает неинтересных
вещей. Это сложно понять сразу. Со
временем вы все выучите...</p>

<p><strong>Как записываем в память
найденные файлы?</strong></p>

<p>Алгоритм простейший:</p>

<p>1. Ищем первый файл. Нет файлов - см.
п. 5;</p>

<p>2. Заносим имя файла в отведенный
блок памяти. Дописываем после имени
файла нуль;</p>

<p>3. Ищем следующий файл. Нет больше
файлов - см. п. 5;</p>

<p>4. Заносим следующий файл в память
сразу же за найденным предыдущим.
На пункт 3;</p>

<p>5. Заносим еще один нуль после
последнего найденного файла для
того, чтобы дать понять процедурам
нашей оболочки, что это был
последний найденный файл.</p>

<p>6. Выводим указанное количество
файлов на экран (сколько находится
в переменной Number_files) (FILES.ASM, Out_files).</p>

<p>Думаю, что труда разобраться с
тонкостями процедур не составит,
тем более, что в файле-приложении
достаточно комментариев.</p>

<p><strong>Удачного вам изучения!</strong></p>

<p><strong>До скорой встречи!</strong></p>

<hr>

<p><font size="4"><em><strong>С уважением,</strong></em></font></p>

<p><font size="3" face="Arial Cyr"><strong>Автор
рассылки:</strong> Калашников Олег <br>
<strong>URL сайта подписчиков:</strong> </font><a
href="http://www.Kalashnikoff.ru"><font size="3" face="Arial Cyr">http://www.Kalashnikoff.ru</font></a><font
face="Arial Cyr"> <br>
<strong>E-mail автора:</strong> </font><a
href="mailto:Assembler@Kalashnikoff.ru"><font face="Arial Cyr">Assembler@Kalashnikoff.ru</font></a><font
face="Arial Cyr"> <br>
<strong>ICQ:</strong> 68951340</font></p>

<p>Москва, 2001.</p>

<hr>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="100%"
bgcolor="#DDEEFF" bordercolor="#808080"
bordercolorlight="#FFFFFF">
<tr>
<td colspan="3" bgcolor="#BDDEFF"><font color="#400040"
size="1"><strong>(C) Авторское право
принадлежит автору рассылки.</strong>
Использование материала из
рассылки в коммерческих и иных
подобных целях, а также
публичное публикование без
письменного согласия автора
влечет ответственность за
нарушение авторских прав. </font></td>
</tr>
</table>
</center></div>

<hr>

<p align="center">[<a href="022.htm">Следующий выпуск</a>] [<a target=_BLANK href="http://www.Kalashnikoff.ru/">На главную страницу</a>]</p>

<HR NOSHADE><CENTER>
<!-- SpyLOG v2 f:0211 --><script language="javascript">  
u="u496.71.spylog.com";d=document;nv=navigator;na=nv.appName;p=1;  
bv=Math.round(parseFloat(nv.appVersion)*100);  
n=(na.substring(0,2)=="Mi")?0:1;rn=Math.random();z="p="+p+"&rn="+rn;y="";  
y+="<a href='http://"+u+"/cnt?f=3&p="+p+"&rn="+rn+"' target=_blank>";  
y+="<img src='http://"+u+"/cnt?"+z+  
"&r="+escape(d.referrer)+"&pg="+escape(window.location.href)+"' border=0 width=88 height=31 alt='SpyLOG'>";  
y+="</a>"; d.write(y);if(!n) { d.write("<"+"!--"); }//--></script><noscript><p align="center"><a 
href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" 
target="_blank"><img src="http://u496.71.spylog.com/cnt?p=1" alt="SpyLOG" align="middle" border="0"></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"></noscript></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"> 
<script language="javascript1.2"><!-- if(!n) { d.write("--"+">"); }//--></script></a> 
<!-- SpyLOG --> 
 
 <a target=_top href="http://www.one.ru"><img src="http://cnt.one.ru/cgi-bin/cnt.cgi?id=16871&t=9" width=88 height=31 alt="be number one" border=0></a> 
 
 <script language="JavaScript"><!-- 
d=document;a='';a+=';r='+escape(d.referrer) 
js=10//--></script><script language="JavaScript1.1"><!-- 
a+=';j='+navigator.javaEnabled() 
js=11//--></script><script language="JavaScript1.2"><!-- 
s=screen;a+=';s='+s.width+'*'+s.height 
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth) 
js=12//--></script><script language="JavaScript1.3"><!-- 
js=13//--></script><script language="JavaScript"><!-- 
d.write('<a href="http://top.list.ru/jump?from=87856"'+ 
' target=_top><img src="http://top.list.ru/counter'+ 
'?id=87856;t=54;js='+js+a+';rand='+Math.random()+ 
'" alt="TopList"'+' border=0 height=31 width=88></a>') 
if(js>11)d.write('<'+'!-- ')//--></script><noscript><a 
target=_top href="http://top.list.ru/jump?from=87856"><img 
src="http://top.list.ru/counter?js=na;id=87856;t=54" 
border=0 height=31 width=88 
alt="TopList"></a></noscript><script language="JavaScript"><!-- 
if(js>11)d.write('--'+'>')//--></script> 
 
<br><br> 

</body>
</html>
