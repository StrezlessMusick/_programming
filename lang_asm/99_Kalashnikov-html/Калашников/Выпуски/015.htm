<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<title>Калашников.ru - Ассемблер? Это просто!.. (Выпуск № 015)</title>
</head>

<body bgcolor="#EBD2A5" text="#000000" link="#660000"
vlink="#000000" alink="#000000">

<P align=center><A 
href="http://ad.ir.ru/bb.cgi?cmd=go&pubid=128269&pg=2&vbn=10001&nocache=77524" 
target=_top><IMG alt="InterReklama " border=0 
src="http://ad.ir.ru/bb.cgi?cmd=ad&pubid=128269&pg=2&vbn=10001&nocache=77524"></A></P>
<P align=center><A href="http://www.ir.ru" target=_top><FONT size=1>InterReklama 
Advertising</FONT></A> </P>
<HR>

<div align="center"><center>

<table border="3" cellpadding="3" cellspacing="3" width="100%"
bgcolor="#8DC7C7" bordercolor="#000040">
<tr>
<td width="100%"><div align="center"><center><table
border="3" cellpadding="3" cellspacing="3" width="100%"
bgcolor="#009797" bordercolor="#000040">
<tr>
<td width="100%"><p align="center"><font size="5"><strong>Доброе
время суток, друзья мои!</strong></font></p>
<hr>
<p align="center"><font size="4"><em><strong>Выпуск
N 015</strong></em></font></p>
</td>
</tr>
</table>
</center></div><p align="right"><em>А ты опять
сегодня не пришла.</em></p>
<p align="right"><em>А я так ждал,
наде-еялся и верил,</em></p>
<p align="right"><em>Что зазвоня-я-ят
опять колокола-а-а-а,</em></p>
<p align="right"><em>И я тебя увижу на
дисплее.</em></p>
<hr>
<p align="center"><font size="4"><em><strong>Чего у
нас сегодня?</strong></em></font></p>
<ul>
<li><a href="#experts"><font color="#800040">Еще
несколько слов о клубе
экспертов</font></a></li>
<li><a href="#resident"><font color="#800040">Резидент.
Механизм работы
прерываний</font></a></li>
</ul>
<hr>
<p align="center"><a name="experts"><font size="5"><strong>Несколько
слов о клубе экспертов</strong></font></a></p>
<p align="left"><font size="3">Вот-вот-вот,
дорогие мои! Начинает, вроде
работать наш клуб экспертов.
Только возник парадокс: когда
экспертов не было, письма с
вопросами приходили тоннами, а
как появились эксперты,
вопросы приходят граммами... В
данный момент экспертов
больше, чем людей, задающих
вопросы!</font></p>
<p align="center"><font size="3"><strong>___________</strong></font></p>
<p align="left"><font color="#000080" size="4"><strong>Новая
система.</strong></font></p>
<p align="left"><font size="3">Несколько
слов о новой системе. Теперь
все письма можно направлять
напрямую экспертам (без моего
участия). Адреса экспертов
указаны ниже. Я использую
систему eGroup, которую мне
посоветовал один подписчик.
Зачем это нужно? Все ваши
вопросы будут пересылаться
экспертам немедленно. До этого
письма получал я, а затем
перенаправлял их экспертам.
Т.о. чтобы эксперт смог
получить ваш вопрос, я должен
был включить компьютер и
получить почту. А если я
заболею? Тогда вопросы лежали
бы в ящике до тех пор, пока я не
пришел бы на работу. Теперь все
быстрее и проще.</font></p>
<p align="center"><font size="3"><strong>___________</strong></font></p>
<p align="left"><font color="#000080" size="4"><strong>Нужны
еще эксперты!</strong></font></p>
<p align="left"><font size="3">В данный
момент ощущается острая нехватка экспертов по
следующим вопросам:</font></p>
<ul>
<li><p align="left"><font size="3"><strong>Эксперты
по AFD;</strong></font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты
по CV;</strong></font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты
по TD.</strong></font></p>
</li>
</ul>
<p align="left"><font size="3">Т.е. по
отладчикам.</font></p>
<p align="left"><font size="3">&quot;Укомплектована&quot;
в данный момент одна группа:</font></p>
<ul>
<li><p align="left"><font size="3"><strong>Эксперты
по DOS.</strong></font></p>
</li>
</ul>
<p align="left"><font size="3">Заявки в
данную группу пока не
принимаются!</font></p>
<p align="center"><font size="3"><strong>___________</strong></font></p>
<p align="left"><font color="#000080" size="4"><strong>Как
стать экспертом?</strong></font></p>
<p align="left"><font size="3">Для этого
необходимо направить мне
письмо в произвольной форме с
просьбой включить вас в ту или
иную группу экспертов. В данный
момент существуют следующие
группы (которые еще &quot;не
укомплектованы&quot;, помимо
вышеперечисленных):</font></p>
<ul>
<li><p align="left"><font size="3"><strong>Эксперты
по ассемблерам (MASM/TASM) </strong>(параметры
командной строки, работа
под разными ОС и пр.);</font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты
по общим вопросам
программирования на
Ассемблере под Win32;</strong></font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты по общим вопросам
программирования на
ассемблере под DOS </strong>(то,
что рассматривается в
рассылке, а также все
остальное, связанное с
Ассемблером под DOS)<strong>;</strong></font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты
по моделям, видам и типам
компьютеров и все, что с
ними связано (hard);</strong></font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты
по дизассемблерам </strong>(принцип
работы, для чего нужны, как
пользоваться в общих
чертах и т.п.);</font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты
по оболочкам DOS </strong>(Norton
Commander, Volcov Commander, DOS Navigator, Far);</font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты
по работе с Windows </strong>(пользовательский
уровень).</font></p>
</li>
</ul>
<p align="center"><font size="3"><strong>___________</strong></font></p>
<p align="left"><font color="#000080" size="4"><strong>Как
задать вопрос экспертам?</strong></font></p>
<p align="left"><font size="3">Итак, у вас
возник вопрос в той или иной
области. Как его задать
эксперту? Очень просто: ниже
приведен список адресов
экспертов, куда необходимо
послать ваш вопрос:</font></p>
<ul>
<li><p align="left"><font size="3"><strong>Эксперты
по ассемблерам (MASM/TASM) - </strong></font><a
href="mailto:ExpertAssm@egroups.com"><font
size="3"><strong>ExpertAssm@egroups.com</strong></font></a><font
size="3">;</font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты
по дизассемблерам - </strong></font><a
href="mailto:ExpertDisassm@egroups.com"><font
size="3"><strong>ExpertDisassm@egroups.com</strong></font></a><font
size="3">;</font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты
по моделям, видам и типам
компьютеров и все, что с
ними связано (hard) - </strong></font><a
href="mailto:ExpertComputers@egroups.com"><font
size="3"><strong>ExpertComputers@egroups.com</strong></font></a><font
size="3"><strong>;</strong></font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты
по общим вопросам
программирования на
Ассемблере под Win32 - </strong></font><a
href="mailto:ExpertAssmWin32@egroups.com"><font
size="3"><strong>ExpertAssmWin32@egroups.com</strong></font></a><font
size="3"><strong>;</strong></font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперы
по общим вопросам
программирования на
ассемблере под DOS - </strong></font><a
href="mailto:ExpertGeneralAssm@egroups.com"><font
size="3"><strong>ExpertGeneralAssm@egroups.com</strong></font></a><font
size="3"><strong>;</strong></font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты
по работе с Windows </strong>(<em>пользовательский
уровень</em>) - </font><a
href="mailto:ExpertWin@egroups.com"><font
size="3"><strong>ExpertWin@egroups.com</strong></font></a><font
size="3">;</font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты
по работе с DOS </strong>(<em>пользовательский
уровень</em>)<strong> - </strong></font><a
href="mailto:ExpertDOS@egroups.com"><font
size="3"><strong>ExpertDOS@egroups.com</strong></font></a><font
size="3">;</font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты
по оболочкам DOS </strong>- </font><a
href="mailto:ExpertDOSShells@egroups.com"><font
size="3"><strong>ExpertDOSShells@egroups.com</strong></font></a><font
size="3">;</font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты
по AFD - </strong></font><a
href="mailto:ExpertAFD@egroups.com"><font
size="3"><strong>ExpertAFD@egroups.com</strong></font></a><font
size="3">;</font></p>
</li>
<li><p align="left"><font size="3"><strong>Эксперты
по CV - </strong></font><a
href="mailto:ExpertCV@egroups.com"><font size="3"><strong>ExpertCV@egroups.com</strong></font></a><font
size="3">;</font></p>
</li>
</ul>
<ul>
<li><p align="left"><font size="3"><strong>Эксперты
по TD - </strong></font><a
href="mailto:ExpertTD@egroups.com"><font size="3"><strong>ExpertTD@egroups.com</strong></font></a><font
size="3">.</font></p>
</li>
</ul>
<p align="center"><font size="3">___________</font></p>
<p align="left"><font color="#004080" size="4"><strong>Как
отказаться от участия в группе
экспертов?</strong></font></p>
<p align="left"><font size="3">Необходимо
написать мне письмо в
произвольной форме, в котором
указать ваш e-mail и желание выйти
из состава экспертов. Все!</font></p>
<p align="center"><font size="3">___________</font></p>
<p align="left"><font color="#0000FF" size="4"><strong>Экспертам:</strong></font></p>
<p align="left"><font size="3">Пожалуйста, не
забывайте высылать мне копию
письма с ответом.</font></p>
<p align="left"><font color="#0000FF" size="4"><strong>Подписчикам:</strong></font></p>
<p align="left"><font size="3">Пожалуйста, не
забывайте указывать в теле
письма ваш обратный адрес и
ставить оценку за полученный
ответ от эксперта.</font></p>
<p align="left"><font size="3"><em><strong>Спасибо
всем, кто решил принять участие
в этом нелегком деле - отвечать
на вопросы подписчиков!</strong></em></font></p>
<hr>
<p align="center"><a name="resident"><font size="4"><strong>Резидент</strong></font></a></p>
<p>Сегодня рассмотрим
&quot;многофункциональный&quot;
резидент. Будет сложно, но
интересно.</p>
<p><strong>Что же делает наш
резидент теперь?</strong></p>
<p>1. Записывает в файл
содержимое текстового экрана
(то, что в момент нажатия
определенных клавиш находится
в области экрана);</p>
<p>2. Заменяет на экране все
символы &quot;A&quot; и &quot;a&quot; на
&quot;О&quot; и &quot;о&quot;
соответственно;</p>
<p>3. Передает неверные данные о
файлах оболочкам NC, VC, DN.</p>
<p>И все это один резидент,
который занимает всего 746 байт
(вместе с текстом)!</p>
<p><strong>Итак, засучите рукава,
вдохните глубже и - вперед!</strong></p>
<p>________</p>
<p><strong>Файл-приложение можно
взять здесь: </strong><a
href="http://www.Kalashnikoff.ru/Assembler/Programs/Lessons/Resid15.rar">http://www.Kalashnikoff.ru/Assembler/Programs/Lessons/Resid15.rar</a></p>
<p><em>Если у вас нет выхода в
Сеть, то напишите мне письмо с
просьбой выслать данный файл. Я
также включу ваш адрес в базу
данных. Затем, перед выходом
очередной рассылки, вы
получите этот файл по почте. На
сайте есть также </em><em><strong>rar.exe</strong></em><em>
(150 Кб), который необходим для
распаковки файла-приложения.</em></p>
<p>Разобраться в инициализации
резидента (метка Init) труда не
составит. В двух словах мы
делаем следующее: проверяем на
повторную загрузку в память
путем отправления нашего
&quot;позывного&quot; (в данном
случае - 9889h в AX) и получения (или
неполучения) &quot;отклика&quot;
(число 8998h тоже в AX). Если после
вызова 21h прерывания с числом
9889h мы получаем число 8998h, то наш
резидент уже в памяти (он-то и
меняет местами AH и AL). См. первые
четыре строки процедуры
Int_21h_proc, которые как раз это-то и
делают (то бишь меняют местами
AH/AL)... Но делают только в том
случае, если наш резидент уже
загружен в память. Проведем
эксперимент. Перенесем
приведенные ниже строки перед
вызовом int 27h, но после
установки прерывания 21h (это
делать не обязательно!):</p>
<p>mov ax,9889h<br>
int 21h<br>
cmp ax,8998h<br>
jne Set_resident</p>
<p>Что мы увидим? Наша программа
выдаст сообщение о том, что она
уже загружена в память, хотя и
загружается первый раз.
Следовательно, наш обработчик
(Int_21h_proc) уже в памяти и
работает! Т.е. обработчик
начинает работать сразу после
того, как мы установили на него
вектор прерывания (а мы это
сделали, используя функцию 25h
прерывания 21h):</p>
<p><em>; Теперь 21h-ое...</em><br>
mov ax,3521h<br>
int 21h ;получим и сохраним адрес
(вектор) 21h прерывания<br>
mov word ptr Int_21h_vect,bx ;вначале
младшее слово (смещение)...<br>
mov word ptr Int_21h_vect+2,es ;затем старшее
(сегмент)</p>
<p>mov ax,2521h<br>
mov dx,offset Int_21h_proc<br>
int 21h ;&quot;повесим&quot; нашу
процедуру на 21h прерывание</p>
<p>После выполнения последней
строки (int 21h) наш обработчик
(Int_21h_proc) начинает работать.
Чтобы он продолжил свою работу
и после выхода в DOS, нам нужно
оставить программу
резидентной в памяти. Если мы
после установки прерываний
выйдем в DOS, используя int 20h, то
компьютер просто
&quot;зависнет&quot;! Память-то, где
находятся наши обработчики
(Int_05h_proc, Int_21h_proc, Int_1Ch_proc)
освободится, и на ее место
загрузятся совсем другие
программы. Тем самым, адрес 21h
прерывания будет указывать на
процедуру Int_21h_proc, которой
больше нет в памяти, и что
находится вместо нее - одному
богу известно. Компьютер
&quot;зависнет&quot; (или перестанет
работать должным образом) на
100%, если мы (или кто-то другой)
попробуем вызвать одно из
перечисленных выше прерываний
(кроме 1Ch).</p>
<p>А зачем мы запоминаем старый
вектор 21h-ого? Думаю, что многие
уже догадались, но я объясню
еще раз.</p>
<p>DOS, при смене вектора
прерывания, нигде не
запоминает его прежний адрес.
Т.о., если мы не запомним
прежний вектор, то будет
работать <strong>только</strong> наша
процедура. Куда мы передадим
управление после того, как наша
процедура отработала? Вот-вот.
Мы и передаем управление по
прежнему (сохраненному) адресу
21h-ого (или любого другого)
прерывания. Сохраняем же мы его
в определенной переменной,
которую обзываем по-своему:</p>
<p>Int_21h_vect dd ?</p>
<p>или</p>
<p>Int_1Ch_vect dd ?</p>
<p>и т.п.</p>
<p><strong>DD</strong> означает то, что
данная переменная может
хранить два слова (т.е. в данном
случае адрес (сегмент и
смещение) оригинального
(прежнего) обработчика).</p>
<p>Существует два способа
передачи управления на старый
адрес (вектор) прерывания:</p>
<p><font size="4"><strong>1. jmp dword ptr
cs:[Int_21h_vect]</strong></font></p>
<p><strong>DWORD PTR</strong> означает, что
надо &quot;прыгнуть&quot; используя
не только смещение, но и
сегмент (т.е. сегмент:смещение).</p>
<p><strong>CS:</strong> указывает на то,
что переменная находится в
текущем сегменте (а CS всегда
указывает на текущий сегмент
(т.е. на тот сегмент, где мы
сейчас находимся), а вот все
остальные сегменты (DS, ES, SS) не
меняются при переходе в другой
сегмент. Если мы опустим CS:, то
процессор по умолчанию будет
работать так:</p>
<p>jmp dword ptr DS:[Int_21h_vect], а это
неверно, т.к. DS будет содержать
совсем другой сегмент (а не тот,
в котором мы сейчас находимся
(см. файл-приложение)).</p>
<p>Переход в другой сегмент
происходит когда мы, например,
вызываем какое-нибудь
прерывание, что мы и делаем в
нашем примере (Resid15.asm)). При
вызове прерывания из
сегментных регистров меняется
только CS (Code Segment - сегмент кода,
т.е. кода, который в данный
момент выполняется), а
остальные остаются прежними
(т.е. имеют те значения, которые
были перед вызовом прерывания)
(подробнее ниже).</p>
<p><strong>Скобки</strong> (<strong>[ ]</strong>)
указывают на то, что нужно
&quot;прыгнуть&quot; на тот адрес,
который находится в переменной
Int_21h_vect.</p>
<p>Данная команда (jmp dword ptr)
называется дальний jmp, в
отличие от короткого (например,
jmp Init, т.е. без всяких
&quot;прибамбасов&quot; после jmp,
только метка). Со временем все
станет на свои места.</p>
<p><font size="4"><strong>2. call dword ptr
cs:[Int_21h_vect]</strong></font></p>
<p>Что здесь? Да здесь
рассуждаем по аналогии с jmp. Но
есть некоторые отличия.</p>
<p>Итак, вы привыкли к тому, что
call используется для вызова
процедур внутри нашего
сегмента (такие процедуры
называют ближними). Это же -
дальняя процедура. В чем
отличие? При вызове ближней
процедуры в стеке сохраняется
только смещение, куда
необходимо вернуться, при
вызове же дальней процедуры в
стеке сохраняется не только
смещение, но и сегмент.</p>
<p>Вот примеры:</p>
<p>;Предположим, что стек пустой
(SS=1234h, SP=0FFFFh).</p>
<p>(1) [1234:0100h] mov ax,0A0Bh</p>
<p>(2) [1234:0103] call Our_proc</p>
<p>(3) [1234:0105h] mov dx,123h</p>
<p>...</p>
<p>(4) [1234:0200h] Our_proc proc</p>
<p>(5) [1234:0200h] mov dx,offset Message</p>
<p>...</p>
<p>(6) [1234:0250h] ret</p>
<p>(7) [1234:0250h] Our_proc endp</p>
<p>Итак, что же в данном примере
происходит? Давайте
предположим, что строка (1)
расположилась по адресу 1234:0100h,
а процедура Our_proc находится по
адресу 1234:0200h. Когда программа
дойдет до строки (2), CS (сегмент)
будет содержать адрес текущего
сегмента (т.е. 1234h), а IP (смещение)
- 0105h (т.е. адрес следующей
команды). В момент выполнения
строки (2) в стек заносится
текущее состояние регистра IP (и
только!), т.е. число 0105h. Затем
процессор переходит на адрес
0200h (т.е. на метку нашей
процедуры). Как видите Our_proc proc
не занимает памяти; эта команда
нужна только ассемблерам
(MASM/TASM). Начинает работать
процедура Our_proc, при этом адрес
возврата находится в стеке. Я
уже говорил, что в процедуре
нужно очень тщательно следить
за стеком, т.к. если мы оставим
какое-нибудь число в стеке
перед выходом из процедуры, то
процессор, дойдя до инструкции
ret, вытащит со стека не адрес
возврата, а то число, которое
находится на вершине стека. Но
это мы забегаем немножко
вперед...</p>
<p>Итак, процедура отработала.
Процессор дошел до команды ret.
RET достает из стека последнее
число (число, находящееся на
вершине стека в данный момент)
и переходит по этому адресу.
Если мы со стеком ничего не
намудрили (ничего в нем не
оставили и ничего не оставили
записанным), то RET вытащит со
стека число 0105h, т.е. то число,
которое сохранила инструкция
call (адрес возврата), и перейдет
по этому адресу. Еще раз: если
мы стек оставили выровненным
(надеюсь, что вы помните, что
это значит), то процедура
выйдет корректно.</p>
<p>Что нужно уяснить: при вызове
ближней процедуры (т.е. call Our_proc,
например), в стек кладется
только смещение следующей за
процедурой инструкции (в
данном случае - только 0105h).</p>
<p>При вызове же дальней
процедуры в стек кладется не
только смещение, но и сегмент
для возврата.</p>
<p>Например, мы точно знаем, что
по адресу 3456:0400h находится
процедура вывода строки на
экран. Проблема в том, что эта
процедура находится в другом
сегменте (не в 1234h, как наша
программа, а в 3456h). Для этого
занесем в некую переменную
(пусть это будет New_proc) два слова
(четыре байта): 3456h и 0400h (адрес
процедуры New_proc, включая
сегмент и смещение). Затем
передаем управление этой
процедуре:</p>
<p><strong>mov word ptr [New_proc],0400h</strong></p>
<p><strong>mov word ptr [New_proc+2],3456h</strong></p>
<p><strong>call dword ptr [New_proc]</strong></p>
<p><strong>...</strong></p>
<p><strong>New_proc dd ?</strong></p>
<p>Здесь мы вначале заносим в
переменную New_proc смещение, а
затем сегмент процедуры
(вспоминаем о том, что в
компьютере данные хранятся &quot;задом наперед&quot;).</p>
<p>К чему это? К тому, что если
после команды (инструкции) call
следует dword ptr, то в стек
заносится не только смещение,
но и сегмент. Возникает второй
вопрос: как компьютер
различает, когда нужно достать
из стека только смещение, а
когда смещение и сегмент? Ответ
простой: существует две
разновидности инструкции ret:</p>
<p><strong>ret</strong> и <strong>retf</strong>.</p>
<p>RETF (RETurn Far - дальний возврат) -
достает из стека не только
смещение, но и сегмент (в
отличие от RET, который достает
только смещение). Если мы
вызовем дальнюю процедуру (call
dword ptr [Far_proc]), а выйдем из нее,
используя RET, то компьютер
просто &quot;зависнет&quot;.
Надеюсь, вы поняли почему...</p>
<p>Вот примеры:</p>
<p>[<strong><u>1234</u></strong>:0200h] call Near_proc</p>
<p>...</p>
<p>[<strong><u>1234</u></strong>:4569h] Near_proc proc</p>
<p>...</p>
<p>[<strong><u>1234</u></strong>:6789h] <strong>ret</strong>
;<em>Правильный выход из ближней
процедуры (процедуры, которая
располагается в том же
сегменте, что и программа, ее
вызывающая)</em></p>
<p>[<strong><u>1234</u></strong>:6789h] Near_proc endp</p>
<p>...</p>
<p>____________</p>
<p>...</p>
<p>[<strong><u>1234</u></strong>:0200h] call dword ptr
[New_proc]</p>
<p>...</p>
<p>[<strong><u>3456</u></strong>:0300h] New_proc proc</p>
<p>...</p>
<p>[<strong><u>3456</u></strong>:0534h] <strong>retf</strong>
;<em>Правильный выход из дальней
процедуры (процедуры, которая
находится в другом сегменте, в
отличие от программы ее
вызывающей)</em></p>
<p>[<strong><u>3456</u></strong>:0534h] New_proc endp</p>
<p>Иначе говоря, процессор,
дойдя до оператора call <em>имя
процедуры</em>, сохранит в стеке <strong>только
смещение</strong> следующей за call
команды (возврат - RET), а call dword ptr <em>имя
процедуры</em> сохранит в стеке <strong>сегмент
и смещение</strong> следующей за call
dword ptr (возврат - RETF) команды.</p>
<p>Возможно, это покажется вам
на первый взгляд сложно, но,
поверьте, все на самом деле
очень просто. Более того, путаницы не возникает с
вызовами и возвратами. Нужен
прежде всего опыт работы с
Ассемблером. Остальное придет
само собой.</p>
<p>&quot;Ага! - скажает читатель. -
Что-то ты, Калаш, &quot;лапшу
гонишь&quot;. А почему тогда перед
call dword ptr [Int_21h_vect] мы заносим в
стек регистр флагов (pushf), и
впоследствии его не достаем?
Куда он девается? А?!&quot;</p>
<p>Верно замечено! Этому есть
объяснение. Смотрим:</p>
<p>...</p>
<p>pushf</p>
<p>call dword ptr [Int_21h_vect]</p>
<p>...</p>
<p>Зачем нужно заносить флаги в
стек (pushf) <strong>перед вызовом
оригинального обработчика
прерываний</strong>? Хороший
вопрос... Длинный ответ... Но
попробуем затронуть эту тему,
раз уж вы настаиваете... Если
что-то непонятно будет - не
плачьте! Впоследствии все
рассмотрим подробнее.</p>
<p>Зачем вообще вызываются
прерывания? Вот кусок кода:</p>
<p>______________</p>
<p><em>;Это </em><em><strong>обработчик
прерывания 09h</strong></em><em> где-то в
памяти, который
&quot;срабатывает&quot; при нажатии
и отпускании какой-нибудь
клавиши:</em></p>
<p>[0900:0050h] mov al,bl <em>;Здесь неважно,
какой код находится. Главное
то, что сегмент другой,
отличный от того, в котором
находится наша программа (см.
ниже).</em></p>
<p>[0900:0052h] ...</p>
<p>[0900:0345h] iret</p>
<p>=============</p>
<p><em>;Это кусок </em><em><strong>нашей
программы</strong></em><em>, которая в
данный момент выполняется:</em></p>
<p>...</p>
<p>(1) [1234:0200h] mov ax,Num_regAX</p>
<p>(2) [1234:0205h] cmp ax,17</p>
<p>(3) [1234:0208h] jne Not_equal</p>
<p>...</p>
<p>_____________</p>
<p>Программа работает, работает.
И вдруг пользователь с
перепугу нажимает какую-нибудь
клавишу, причем нажимает ее в
тот момент, когда наша
программа только что выполнила
строку (2). Что происходит? На
первый взгляд кажется, что
ничего особенного не произойдет. Процессор занесет
клавишу в буфер, которая будет
храниться там до того момента,
пока DOS ее от туда не запросит и,
по желанию, не выведет на экран
или выполнит определенные
действия (например, клавиша F9 в
NC). Но это только кажется и на
словах звучит просто. На самом
деле процессор выполнит уйму
работы за считанные доли
миллисекунд, а именно:</p>
<p>У нас в регистрах находятся определенные числа. Более того,
после выполнения строки (2)
изменится регистр флагов. В
строке (3) мы ведь проверяем
состояние флага нуля, который
сигнализирует нам в данном
случае о том, равен ли AX 17.</p>
<p>Мы (наша программа) находимся
в момент вызова прерывания в
сегменте 1234h, смещение 0208h
(адрес следующей команды). Как
сделать так, чтобы передать
управление 09h прерыванию,
которое выполнит свою работу
(занесет в буфер клавиатуры код
клавиши, которую мы затем
проверяем при помощи функции 10h
прерывания 21h), при этом
вернуться в то место, с
которого произошло прерывание,
не нарушив работы нашей
программы? Длинный вопрос...</p>
<p><em>К слову.</em> 09h прерывание
вызывается всегда, когда
пользователь нажимает
какую-нибудь клавишу, даже
тогда, когда процессор чем-то
занят (не ждет от пользователя
клавишу; например, копирует
файл или форматирует диск).</p>
<p>Вернемся к нашему длинному
вопросу. Итак, пользователь
нажал на клавишу после
выполнения строки (2) нашей
программы. Процессору нужно
запомнить текущий сегмент (CS),
смещение следующей команды
(оно всегда в IP), а также флаги в
стеке. Этого достаточно для того,
чтобы вернуться назад после
того, как прерывание 09h
отработало. Заметьте, что при
вызове прерывания регистры
(кроме CS:IP и флаги) НЕ
сохраняются. Их должно
сохранять то прерывание,
которое получило управление (в
случае нажатия клавиши - 09h).
После того, как процессор
сохранил регистры CS:IP и флаги в
стеке, он передает управление
обработчику прерывания (в
нашем случае - 09h), адрес
которого находится в
определенном месте в памяти
(где именно находятся адреса
прерываний, мы рассмотрим
позже). Что значит &quot;передает
управление&quot;? Да просто
&quot;прыгает&quot; на определенный
адрес. Это будет называться
что-то вроде &quot;дальний
безусловный переход&quot;, т.к. мы
прыгаем не только на смещение
внутри сегмента (как в случаях,
которые мы рассматривали уже;
например, jmp Init в нашем
резиденте в начале), а на
сегмент и смещение.
Улавливаете разницу?</p>
<p>Итак, управление получило
прерывание 09h. Помним, что
процессор хранит в стеке
сегмент (CS):смещение (IP) команды
на которую нужно вернуться (в
нашем примере - строка (3)), а
также регистр флагов.
Прерывание 09h работает. Если в
процессе работы меняются какие-то регистры, то оно
должно их предварительно
сохранить, иначе наша
программа (после отработки 09h
прерывания) получит совсем
другие значения в регистрах
(например, если 09h изменяет AX, не
сохраняя его, а затем,
соответственно не
восстанавливая, то при выходе
из данного прерывания мы
получаем то, что AX не равен
Num_RegAX (1)). <strong><u>Отсюда жесткое
правило:</u></strong><strong> если вы
пишите свой обработчик, то
обязательно сохраняйте все
регистры, которые он меняет</strong>.
Иначе может произойти
непредвиденное... Если вы
написали обработчик 21h-ого
прерывания, и после загрузки
его в память компьютер
&quot;зависает&quot; или ведет себя
не так, как хотелось бы, то
ищите ошибку в вашем резиденте.
Возможно, вы забыли сохранить
тот или иной регистр в стеке.
Хотя причин по которым
&quot;виснет&quot; компьютер может
быть очень много...</p>
<p>Что-то мы отвлекаемся
постоянно... Информации просто
много...</p>
<p>Итак, прерывание 09h (правильнее:
обработчик 09h прерывания)
отработало: процессор дошел до
инструкции iret (Interrupt RETurn). Эта
инструкция отличается от ret
тем, что при ее выполнении
процессор достанет со стека
сегмент (CS), смещение (IP) и
регистр флагов, вместо
смещения (IP) (как ret). Вот и вся
разница между ret и iret...
Пожалуйста, не путайте их!</p>
<p><strong><u>Резюмируем:</u></strong></p>
<p><strong>RET</strong> достает из стека
только смещение для возврата;
процедура должна находится в
том же сегменте, из которого ее
вызывают (ближняя процедура -
NEAR (по умолчанию));</p>
<p><strong>RETF</strong> достает из стека
сегмент и смещение; процедура
может находится в любом
сегменте, независимо от того,
откуда ее вызывают (дальняя
процедура - FAR или DWORD PTR);</p>
<p><strong>IRET</strong> достает из стека
сегмент, смещение и адрес
флагов. Используется для
выхода из прерываний.</p>
<p>Вернемся. Команда iret
вытаскивает со стека адрес
возврата (CS:IP). В нашем случае: CS
= 1234h, IP = 0208h, а в регистре флагов
установлен флаг нуля, т.е. равен
1. Затем просто передает
управление на этот адрес. Наша
программа продолжает работать,
не догадываясь даже о том, что
кто-то ее прервал. Естественно,
все эти процедуры происходят
мгновенно.</p>
<p>Теперь ответ на вопрос:
почему перед вызовом
прерывания командой вида call dword
ptr cs:Int_21h_vect] мы заносим в стек
регистр флагов командой pushf?</p>
<p>Все просто. Стоит только
посмотреть на отличие
оператора RETF от IRET (см. выше).
При передаче управления
(вызове) прерывания командой call
dowrd ptr... процессор заносит в
стек только сегмент (CS) и
смещение (IP) следующей за
командой call инструкции. А IRET
(который выполняется при
возврате из прерываний)
достанет со стека
сегмент:смещение и флаги. Но
флаги-то не заносятся командой
call dword ptr...! Мы их заносим сами,
&quot;вручную&quot;. Иначе
произойдет нарушение работы
стека, и компьютер
&quot;зависнет&quot;. Как я уже
говорил, <strong>за стеком нужно
следить очень внимательно</strong>!</p>
<p>Что мы там начали
рассматривать? Забыл уже... Ща
гляну...</p>
<p>Что делает наш обработчик 21h-ого
прерывания? Он передает
программе, которая ищет файлы в
каталоге, используя функции 4Eh
и 4Fh. Подробнее эти функции мы
рассмотрим, когда будем писать
оболочку. Здесь все вкратце.</p>
<p>Функция 4Eh ищет первый файл
или каталог на диске, и, если
какой-нибудь файл найден,
заносит в DTA информацию о
данном файле. Программа,
вызывающая эту функцию
использует эту информацию из DTA
для анализа файлов. В DTA
заносится в частности:</p>
<ul>
<li>имя и расширение файла;</li>
<li>размер файла;</li>
<li>дата и время создания
файла;</li>
<li>атрибуты файла.</li>
</ul>
<p>Тоже самое делает функция 4Fh.
Ее отличие только в том, что она
ищет второй и последующие
файлы. Ну вот так устроена MS-DOS!</p>
<p>Наш резидент контролирует 21h
прерывание. Если вызывается
одна из упомянутых выше
функций, то резидент подменяет
информацию, которая находится
в DTA после вызова 21h прерывания.</p>
<p>Вот пример:</p>
<p><em>______________</em></p>
<p><em>;Проверяем: вызывает ли
какая-то программа функцию 4Eh
или 4Fh (поиск файлов)</em></p>
<p>cmp ah,4Eh</p>
<p>je Do_not</p>
<p>cmp ah,4Fh</p>
<p>je Do_not</p>
<p><em>;Если вызывается другая
функция, то просто передадим
управление оригинальному
обработчку 21h</em></p>
<p><em>;Передаем дальним jmp'ом.
Здесь заносить в стек флаги не
нужно, т.к. мы больше не
вернемся в наш обработчик.
Уходим навсегда...</em></p>
<p>Go_21h:</p>
<p>jmp dword ptr cs:[Int_21h_vect]</p>
<p><em>;Итак, кто-то вызывает
функцию 4Fh или 4Eh...</em></p>
<p>Do_not:</p>
<p>pushf</p>
<p>call dword ptr cs:[Int_21h_vect]</p>
<p><em>______________</em></p>
<p>Прежде, чем менять информацию
о найденных файлах в DTA, нам
нужно вызвать 21h прерывание
самим для того, чтобы оно
занесло эти данные в DTA. Мы,
конечно, можем сами записать
туда чего угодно, но это будет
неинтересно. Обратите внимание
на две команды, следующие за
меткой Do_not. Здесь мы вызываем 21h
прерывание. Но как! Ведь данный
кусок кода - это и есть наш
обработчик 21h прерывания.
Следовательно, если мы вызовем прерывание стандартной
командой int 21h, то она нас
приведет на наш же обработчик.
Нам это надо? Нет. Поэтому мы
вызываем прежний обработчик 21h-ого
прерывания, т.е. тот обработчик,
который работал до того
момента, как мы &quot;повисли&quot; в
памяти (перехватили его и
загрузились в память).
Получается своего рода
&quot;фильтр&quot; 21h-ого. Мы можем
&quot;фильтровать&quot; те или иные
функции прерывания и делать с
ними все, что захотим. Вот он,
контроль над программами! Не
то, что Windows!</p>
<p>Итак, вызвали прежний
обработчик прерывания. Он нам
вернул информацию о найденном
файле в DTA. Что дальше? А что
дальше?! &quot;Где же этот DTA в
памяти мы-то не знаем!&quot; -
воскликните вы. Верно, не знаем.
Он может быть где угодно.
Получить адрес DTA позволяет
функция 2Fh, прерывания 21h. Но
обратите внимание, как мы
теперь вызываем 21h... Почему так?
Вызвав 21h командой int 21h
процессор попадет на начало
нашего обработчика. Т.е. в самое
начало процедуры Int_21h_proc.
Теперь думаем: в AH у нас число 2Fh.
Теперь смотрите, что
произойдет, если наша
процедура (Int_21h_proc) получит
управление с находящимся в AH
числом 2Fh? Проследите... А-а-а!
Понятно? А если она же получит
управление с числом 4Fh в AH?
То-то... Поэтому мы в случае
вызова прерывания 21h с числом 4Eh
или 4Fh вызываем напрямую
прежний обработчик (call dword ptr
cs:[Int_21h_vect]), а с любым другим
числом - наш обработчик (int 21h).
Второй вариант занимает меньше
байт, да и работает быстрее...</p>
<p>Адрес DTA получили. Теперь
получим случайное число. Это
можно сделать, вызвав функцию 2Ch
прерывания 21h, которая вернет в
определенных регистрах
текущее время. В
файле-приложении все написано
подробно.</p>
<p>Мы пока не будем углубляться
в поля DTA (где что находится).
Давайте лучше рассмотрим <strong>логические
команды</strong>.</p>
<p>Логических команд всего
несколько:</p>
<ul>
<li>and</li>
<li>or</li>
<li>xor</li>
</ul>
<p>Проще всего объяснить
принципы работы на примерах.
Главное - поймите принцип. Мы
еще на раз будем возвращаться и
использовать логические
операторы. Это одна из быстрых
и простых вещей Ассемблера в
отличие от языков высокого
уровня.</p>
<p><strong>Пример N 1. Оператор OR
(ИЛИ).</strong></p>
<p>Оператор OR служит для
включения определенных битов
(не байтов!) в регистре,
переменной или в памяти.</p>
<p>mov ax,1010b</p>
<p>or ax,1111b</p>
<p>Теперь AX=1111b. Т.о. мы включили
(установили) первые четыре
бита.</p>
<ul>
<li>1 OR 1 = 1</li>
<li>1 OR 0 = 1</li>
<li>0 OR 0 = 0</li>
</ul>
<p>mov ah,1001b</p>
<p>or ah,1000b</p>
<p>Теперь AX=1001b. Т.о. мы
установили нулевой бит, а
третий был уже установлен до
нас, но он не тронут!</p>
<p><strong>Пример N 2. Оператор AND (И).</strong></p>
<p>Оператор AND служит для
выключения битов.</p>
<p>mov ax,1010b</p>
<p>and ax,0101b</p>
<p>Теперь AX=0000b. Т.о. мы выключили
первый и третий биты (отсчет
справа налево, начиная с нуля).</p>
<ul>
<li>1 AND 1 = 1</li>
<li>1 AND 0 = 0</li>
<li>0 AND 0 = 0</li>
</ul>
<p>mov ah,1001b</p>
<p>and ah,1</p>
<p>Теперь AH=0001b. Т.о. мы выключили
третий бит.</p>
<p><strong>Пример N 3. Оператор XOR
(исключающее ИЛИ).</strong></p>
<p>Опертор XOR используется в
основном для кодирования
данных. Вот, что он делает:</p>
<p>mov ah,1010b</p>
<p>xor ah,1100b</p>
<p>Теперь AH=0110b.</p>
<ul>
<li>1 XOR 1 = 0</li>
<li>1 XOR 0 = 1</li>
<li>0 XOR 0 = 0</li>
</ul>
<p>Очень удобен также для
вкл/выкл одного бита:</p>
<p>mov al,0 ;AL=0</p>
<p>xor al,1 ;AL=1</p>
<p>xor al,1 ;AL=0</p>
<p>xor al,1 ;AL=1 и т.д.</p>
<p>Теперь вы поняли, почему
команда xor ax,ax обнуляет регистр
AX?</p>
<p>Больше в процедуре обработки
21h прерывания мы пока
рассматривать не будем. В
принципе, в файле-приложении
есть описания к командам,
которых вполне достаточно для
понимания программы. Но даже
если вы не поняли - не
отчаивайтесь! Придет время, мы
все рассмотрим.</p>
<p><strong>Прерывание 05h.</strong></p>
<p>Что делает прерывание 05h? Оно
активизируется (т.е. процессор
передает управление процедуре
обработки 05h прерывания) при
нажатии на клавиши Shift+Print Screen. В
этот момент содержимое
текстового экрана выводится на
принтер. Наверное, вам уже
приходилось это делать. Теперь
вы знаете, какая процедура
печатает экран на принтер.</p>
<p>Ничего не мешает программисту установить свой
обработчик на 05h прерывание. Мы
это и делаем в нашем резиденте
(процедура Int_05h_proc).</p>
<p>После загрузки резидента в
память, пользователь нажимает
клавиши Shift+Print Screen и... экран
выводится не на принтер, а
сохраняется в текстовый файл в
текущем каталоге. Имя файла
Screen.txt. Это работает наша
процедура! Ура!</p>
<p>Абсолютно ничего сложного в
ней нет. Почитайте примечания в
файле-приложении. Все будет
понятно. В двух словах:</p>
<p>Как вы уже знаете, один символ
на экране занимает 2 байта:
символ и его атрибут.
Атрибут-то нам не надо
сохранять! Иначе ерунда
получится. Поэтому нужно атрибуты &quot;отсеять&quot;, оставив
только символы. Для временного
хранения символов мы
используем память первой
видеостраницы.</p>
<p>Затем, используя функцию 40h
прерывания 21h, мы сохраняем
отделенные от атрибутов символы
в текстовый файл Screen.txt. Все!
Можно смотреть его в любой
оболочке...</p>
<p><strong>Прерывание 09h.</strong></p>
<p>Как я уже говорил, это
прерывание вызывается в
случае, если пользователь
нажал какую-нибудь клавишу.</p>
<p>В компьютере есть такое
понятие, как порты
ввода-вывода. Углубляться
сейчас в это мы не будем. Нажав
клавишу, в порт 60h заносится
скан-код этой клавиши. Чтобы
получить из порта число, нужно
пользоваться оператором in.</p>
<p>Следует отличать ASCII код от
скан-кода. Одна из функций
прерывания 09h - преобразование
скан-кода в ASCII код. Для чего это
нужно - рассмотрим позже.
Сейчас главное уловить принцип
работы разных прерываний.</p>
<p>______________</p>
<p>(1) Int_09h_proc proc<br>
(2) pusha<br>
(3) in al,60h<br>
(4) cmp al,58h<br>
(5) jne No_F12</p>
<p>(6) xor cs:Num_status,1</p>
<p>(7) No_F12:<br>
(8) popa<br>
(9) jmp dword ptr cs:[Int_09h_vect]<br>
<br>
(10) Int_09h_vect dd ?<br>
(11) Int_09h_proc endp<br>
______________</p>
<p>Вот и вся процедурка. Что она
делает?</p>
<p>Скан-код клавиши F12 - 58h. Мы
вначале получаем из порта 60h
скан-код нажатой клавиши. Если
это F12, то инвертируем нулевой
бит некой переменной Num_status и
передаем управление
оригинальному обработчику 09h.
Если мы этого не сделаем, то
пользователь не сможет
работать с клавиатурой, т.к.
прерывание 09h заносит в буфер
клавиатуры ASCII код нажатой
клавиши. Но мы-то этого не
делаем! Можно, конечно, самому
написать подобную процедуру.
Если у вас есть время -
пожалуйста... Что же касается
&quot;таинственной&quot; переменной
Num_status, мы рассмотрим в
следующем разделе.</p>
<p><strong>Прерывание 1Ch.</strong></p>
<p>Это прерывание примечательно
тем, что оно само по себе
вызывается примерно 18 раз в
секунду. Если мы напишем
какую-нибудь процедуру и
установим на нее вектор
прерывания 1Ch, то она будет
вызываться 18 раз в секунду.</p>
<p>В нашем случае процедура
Int_1Ch_proc &quot;просматривает&quot;
содержимое нулевой страницы и
заменяет символы &quot;A&quot; и
&quot;a&quot; на &quot;O&quot; и &quot;o&quot;.
Причем, все это происходит с
частотой 18 раз в секунду.</p>
<p>Начало данной процедуры
такое:</p>
<p>cmp cs:Num_status,0<br>
jnz Go_1Ch</p>
<p>Вот она, эта таинственная
переменная Num_status. Как видите,
процедура Int_1Ch_proc проверяет,
равна ли она нулю или нет. И
если не равна, то переходит на
метку Go_1Ch. А там:</p>
<p>Go_1Ch:<br>
jmp dword ptr cs:[Int_1Ch_vect]</p>
<p>Просто передача на
оригинальный обработчик 1Ch. Т.о.
если переменная Num_status равна
единице, то наш обработчик
работать не будет. Т.е. символы
на экране заменяться не будут.</p>
<p>Теперь вспомним про
прерывание 09h, которое меняло
переменную Num_status при нажатии
на клавишу F12. Причем меняло
командой XOR. А что делает XOR? См.
выше. Понятно, что происходит?</p>
<p>Повторю еще раз: ваша задача
сейчас не полностью разобрать
программу, а понять принцип
работы прерываний, причем на
довольно-таки сложном примере.
Зачем я это сделал? Во-первых,
вы хотите быстрее перейти к Win?
Во-вторых, попробуйте
разобрать ее сами. Вдруг
получится? Зато сколько
удовольствия!!!</p>
<hr>
<p><font size="4"><strong>Удачного Вам
программирования и не
забывайте про наших экспертов!</strong></font></p>
<p><strong>С уважением,</strong></p>
<hr>
<div align="center"><center><table border="4"
cellpadding="2" width="100%" bgcolor="#53A6A6"
bordercolor="#808080" bordercolorlight="#FFFFFF">
<tr>
<td width="33%"><p align="center"><font size="4"><strong>Автор
рассылки:</strong></font></p>
<p align="center"><em><strong>Калашников
Олег</strong></em></p>
<p align="center"><a
href="http://www.Kalashnikoff.ru"><strong>www.Kalashnikoff.ru</strong></a></p>
</td>
<td width="33%"><p align="center"><font size="5"><strong>E-mail:</strong></font></p>
<p align="center"><a
href="mailto:assembler@beep.ru">assembler@beep.ru</a></p>
</td>
<td width="34%"><p align="center"><font size="4"><strong>UIN
(Тетя Ася):</strong></font></p>
<p align="center"><font color="#0000FF">68951340</font></p>
</td>
</tr>
<tr>
<td colspan="3" bgcolor="#448686"><font
color="#400040" size="1"><strong>(С)
Авторское право.</strong>
Запрещается использование
материала из рассылки в
коммерческих целях без
письменного согласия
автора.</font></td>
</tr>
</table>
</center></div></td>
</tr>
</table>
</center></div>

<hr>

<p align="center">[<a href="016.htm">Следующий выпуск</a>] [<a target=_BLANK href="http://www.Kalashnikoff.ru/">На главную страницу</a>]</p>


<HR NOSHADE><CENTER>
<!-- SpyLOG v2 f:0211 --><script language="javascript">  
u="u496.71.spylog.com";d=document;nv=navigator;na=nv.appName;p=1;  
bv=Math.round(parseFloat(nv.appVersion)*100);  
n=(na.substring(0,2)=="Mi")?0:1;rn=Math.random();z="p="+p+"&rn="+rn;y="";  
y+="<a href='http://"+u+"/cnt?f=3&p="+p+"&rn="+rn+"' target=_blank>";  
y+="<img src='http://"+u+"/cnt?"+z+  
"&r="+escape(d.referrer)+"&pg="+escape(window.location.href)+"' border=0 width=88 height=31 alt='SpyLOG'>";  
y+="</a>"; d.write(y);if(!n) { d.write("<"+"!--"); }//--></script><noscript><p align="center"><a 
href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" 
target="_blank"><img src="http://u496.71.spylog.com/cnt?p=1" alt="SpyLOG" align="middle" border="0"></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"></noscript></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"> 
<script language="javascript1.2"><!-- if(!n) { d.write("--"+">"); }//--></script></a> 
<!-- SpyLOG --> 
 
 <a target=_top href="http://www.one.ru"><img src="http://cnt.one.ru/cgi-bin/cnt.cgi?id=16871&t=9" width=88 height=31 alt="be number one" border=0></a> 
 
 <script language="JavaScript"><!-- 
d=document;a='';a+=';r='+escape(d.referrer) 
js=10//--></script><script language="JavaScript1.1"><!-- 
a+=';j='+navigator.javaEnabled() 
js=11//--></script><script language="JavaScript1.2"><!-- 
s=screen;a+=';s='+s.width+'*'+s.height 
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth) 
js=12//--></script><script language="JavaScript1.3"><!-- 
js=13//--></script><script language="JavaScript"><!-- 
d.write('<a href="http://top.list.ru/jump?from=87856"'+ 
' target=_top><img src="http://top.list.ru/counter'+ 
'?id=87856;t=54;js='+js+a+';rand='+Math.random()+ 
'" alt="TopList"'+' border=0 height=31 width=88></a>') 
if(js>11)d.write('<'+'!-- ')//--></script><noscript><a 
target=_top href="http://top.list.ru/jump?from=87856"><img 
src="http://top.list.ru/counter?js=na;id=87856;t=54" 
border=0 height=31 width=88 
alt="TopList"></a></noscript><script language="JavaScript"><!-- 
if(js>11)d.write('--'+'>')//--></script> 
 
<br><br> 

</body>
</html>
