<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>Калашников.ru - Ассемблер? Это просто!.. (Выпуск № 018)</title>
</head>

<body bgcolor="#EBD2A5" text="#000000" link="#660000" vlink="#000000" alink="#000000">

<P align=center><A 
href="http://ad.ir.ru/bb.cgi?cmd=go&pubid=128269&pg=2&vbn=10001&nocache=77524" 
target=_top><IMG alt="InterReklama " border=0 
src="http://ad.ir.ru/bb.cgi?cmd=ad&pubid=128269&pg=2&vbn=10001&nocache=77524"></A></P>
<P align=center><A href="http://www.ir.ru" target=_top><FONT size=1>InterReklama 
Advertising</FONT></A> </P>
<HR>

<div align="center"><center>

<table border="3" cellpadding="3" cellspacing="3" width="100%"
bgcolor="#8DC7C7" bordercolor="#000040">
<tr>
<td width="100%"><div align="center"><center><table
border="3" cellpadding="3" cellspacing="3" width="100%"
bgcolor="#009797" bordercolor="#000040">
<tr>
<td width="100%"><p align="center"><font size="5"><strong>Здравствуйте,
уважаемые подписчики!</strong></font></p>
<hr>
<p align="center"><font size="4"><em><strong>Выпуск
N 018</strong></em></font></p>
</td>
</tr>
</table>
</center></div><p align="center"><font size="4"><em><strong>Сегодня
в рассылке:</strong></em></font></p>
<ul>
<li><a href="#error"><font color="#800040">Ошибка</font></a></li>
<li><a href="#shell"><font color="#800040">Оболочка</font></a></li>
<li><a href="#newop"><font color="#800040">Новый
оператор</font></a></li>
</ul>
<hr>
<p align="center"><u><b>Учимся
оптимизировать программы</u></b></p>
<p>Информация для тренировки.</p>
<p>Письмо от одного из наших
экспертов, которого зовут Slava V.:</p>
<p><em>Hi Олег!<br>
Собственно вот тут усмотрел у
тебя в программе оболочки: &quot;С
моей точки зрения - это
довольно-таки оптимальный
алгоритм... Если кто сможет
написать лучше - прочту с
удовольствием и опубликую в
рассылке.&quot;</em></p>
<p><font size="4"><strong>Это твой
вариант... (14 строк)</strong></font></p>
<p>========= из файла display asm Procedure
Get_linear ===========<br>
push ax <em>;сохраним все
используемые регистры</em><br>
push bx<br>
push dx<br>
shl dl, 1 <em>;математика: умножаем DL
на 2 (DL=DL*2)...</em><br>
mov al, dh <em>;в AL - ряд, </em><br>
mov bl, 160 <em>;который нужно
умножить на 160</em><br>
mul bl <em>;умножаем: AL(ряд)*160;
результат --- в AX</em><br>
mov di,ax <em>;результат умножения в
DI</em><br>
xor dh,dh <em>;аннулируем DH</em><br>
add di,dx <em>;теперь в DI линейный
адрес в видеобуфере...</em><br>
pop dx <em>;восстанавливаем
регистры...</em><br>
pop bx<br>
pop ax<br>
ret <br>
</p>
<p><font size="4"><strong>А вот мой вариант
(12 строк):</strong></font><br>
================================<br>
push ax<br>
push dx<br>
xor ax, ax<br>
xchg dh, al ; <em>Имеем в dx =dl, а в ax = dh</em><br>
mov di, ax<br>
shl ax, 6 <em>; dh*64</em><br>
shl di, 4 <em>; dh*16</em><br>
add di, ax<br>
add di, dx<br>
shl di, 1 <em>; *2</em><br>
pop dx<br>
pop ax<br>
ret<br>
==================</p>
<p><em>То что мой вариант короче
на 2 строки - это мелочи. Не в
этом соль. Он быстрее, так как я
использую команду сдвига (shl), а
не умножения (mul). И регистров
использует меньше (только ax).</em></p>
<p><em>Тут еще вот какой момент:</em></p>
<p><em>Ты используешь 160, т.е. уже
умножил ширину экрана на 2. Но
ведь ты потом все равно
умножаешь на 2 dl. И почему
только сдвиги:<br>
Линейный адрес = (COL*80+RAW)*2<br>
Отсюда:<br>
Линейный адрес = (COL*64+COL*16+RAW)*2<br>
Или:<br>
Линейный адрес = ((COL shl 6) + (COL shl 4)
+ RAW) shl 1<br>
<br>
Good luck. Slava V.</em></p>
<p><font size="4">___________</font></p>
<p><font size="3">Все верно! Алгоритм,
который привел Slava V. работает
гораздо быстрее. Если сможете
разобраться - молодцы! А нам
осталось поблагодарить Slav'у!</font></p>
<p><font size="3">Вообще запомните:
команды DIV (деление) и MUL
(умножение) работают
(выполняются) гораздо
медленнее, чем операции сдвига.</font></p>
<p>_____________</p>
<p>Письмо от подписчика Sokol:</p>
<p><em>Я являюсь подписчиком
твоей рассылки почти с самого
начала и отслеживаю всякого
рода изменения (мы даже немного
переписывались на моих первых
шагах). И когда только
подписался, я был просто полным
чайником в ассемблере. (А я
проявлял дикий интерес к этому
языку очень давно, но не мог
найти ничего стоящего в
интернет'е). Но с помощью твоей
рассылки я стал разбираться в
asm. Конечно не без помощи книг.
(Кстати, для профессионалов
советую Зубкова С.В.
&quot;Ассемблер для DOS, Windows и
Unix&quot;, Москва 2000). Огромное тебе
спасибо и не в первый раз.</em></p>
<p>Спасибо тебе!</p>
<p>_____________</p>
<p>Ссылка на ресурс от
подписчика Andrey:</p>
<p><em>P.S. Еще одна неплохая
библиотека компьютерной
документации:<br>
</em><a href="http://www.infocity.kiev.ua"><em>http://www.infocity.kiev.ua</em></a><em>.
Чем она удобна - все статьи
готовы для скачивания и чтения
в off-line.</em></p>
<p>Спасибо!</p>
<p>_____________</p>
<p>Приходит много писем с
вопросом о том, будем ли мы
программировать под Windows. Еще
раз сообщаю: <strong>мы будем
писать программы под Win32 после
того, как пройдем DOS</strong>.</p>
<hr>
<p align="center"><a name="error"><font size="4"><strong>Ошибка</strong></font></a></p>
<p align="left"><font size="3">В прошлом
выпуске я допустил одну ошибку.
Вероятно, все уже это заметили.
Что можно сказать: плохо это
или хорошо? Я думаю, что мои
ошибки идут вам на пользу.
Почему? Вот вы читаете
рассылку. И вдруг - опа! Что-то
не стыкуется. Что вы начинаете
делать? Правильно! Начинаете
думать: почему так?</font></p>
<p align="left"><font size="3">Покопавшись в
рассылке, изучив
файл-приложение вы вдруг
находите ошибку! Разве это не
счастье? Разве вы не радуетесь,
как ребенок. А если бы я не
допустил эту ошибку? Вы такое
бы испытали?</font></p>
<p align="left"><font size="3">Тем не менее,
друзья мои, я постараюсь быть
повнимательней...</font></p>
<hr>
<p align="center"><a name="shell"><font size="4"><strong>Оболочка
Super Shell</strong></font></a></p>
<p>В прошлый раз мы с вами
болтали много о жизни. Поэтому
сегодня придется хорошо
поработать.</p>
<p>Итак, возьмите, пожалуйста,
файл-приложение здесь: <a
href="http://www.Kalashnikoff.ru/Assembler/Programs/Lessons/Sshell18.rar">http://www.Kalashnikoff.ru/Assembler/Programs/Lessons/Sshell18.rar</a></p>
<p>Прежде всего запустите
полученный файл (SHELL18.COM), и
посмотрите что он делает.
Понажимайте на Ctrl+F5, ESC. Теперь
будет разбирать...</p>
<p>Сразу же открывайте MAIN.ASM.
Смотрите, как мы теперь
вызываем процедуру Draw_frame. Это
называется передача данных
процедуре через стек. При
программировании под Windows
вызов всех процедур
производится таким способом. В
Windows нет понятия
&quot;прерывание&quot;. Есть понятие
&quot;системная функция&quot;. Но
это так, к слову. Самое главное
для вас - понять принцип
передачи данных в стеке. Хотя,
на самом деле все очень просто.</p>
<p>Принцип таков: занося в стек,
например, 20 байт, процедура,
получившая управление с
параметрами в стеке, должна
самостоятельно их достать,
чтобы выровнять стек. Как?</p>
<p>Существует оператор RET N, где N
- это количество освобождаемых
байт из стека. В принципе,
оператор RET N аналогичен RET.</p>
<p>Давайте рассмотрим все на
простом примере:</p>
<p>_________</p>
<p>(1) push 123h<br>
(2) call Our_pr<br>
(3) pop ax</p>
<p>...</p>
<p>(4) Our_pr proc<br>
...<br>
(5) ret<br>
(6) Our_pr endp</p>
<p>_________</p>
<p>Здесь мы вызываем процедуру
Our_pr (2), предварительно занеся в
стек какой-то параметр для
данной процедуры (1). Что такое
параметр? Например, для вывода
строки на экран с помощью
функции 09 мы должны передать
данной функции параметр - адрес
строки для вывода.</p>
<p>Процедура Our_pr отработает и
выйдет, при этом в стеке
останется этот параметр (123h).
Нам нужно вытащить его со
стека, т.к. стек у нас остается
невыровненным. Мы это и делаем
в строке (3).</p>
<p>Вроде все понятно. Но что
делать, если мы передаем не
один, а 20 параметров. Каждый раз
при вызове процедуры доставать
их со стека? Громоздко,
неудобно и медленно. Более
того, нам нужно использовать
какой-нибудь регистр, куда
можно будет доставать
параметры. А регистры нужно
беречь! Их не так уж и много,
чтобы ими
&quot;разбазариваться&quot;. Можно
воспользоваться оператором RET
N. Вот как будет выглядеть
приведенный выше пример с
использованием данного
оператора:</p>
<p>_________</p>
<p>(1) push 123h<br>
(2) call Our_pr<br>
...</p>
<p>(3) Our_pr proc<br>
...<br>
(4) ret 2<br>
(5) Our_pr endp</p>
<p>_________</p>
<p>Оператор RET 2 вытащит со стека
прежде всего адрес для
возврата, а затем увеличит SP на
2 (т.е. как бы
&quot;искусственно&quot; достанет
со стека данные, причем не
используя никаких регистров).</p>
<p>Для чего нужно использовать
метод передачи параметров
через стек? Дело в том, что если
той или иной процедуре нужно
передавать огромное число
параметров, то нам, во-первых,
не хватит регистров, во-вторых,
придется заводить
соответствующее количество
переменных, где будут
храниться параметры, в-третьих,
это увеличивает размер
программы, а в-четвертых -
уменьшает скорость работы.</p>
<p>Конечно, если процедуре нужно
передать два-три параметра, то
можно (и желательно) передавать
их и в регистрах. А если 10, как у
нас при вызове Draw_frame? В прошлый
раз мы заводили специальные
три переменные. Но теперь мы
существенно усовершенствовали
нашу процедуру. Мы уже передаем
10 параметров. Следовательно,
будем передавать их в стеке:</p>
<p>__________</p>
<p>push 23 <em>;высота</em><br>
push 78 <em>;ширина</em><br>
push 1F00h <em>;цвет</em><br>
push offset Mess_head <em>;надпись вверху</em><br>
push 1E00h <em>;ее цвет</em><br>
push offset Mess_down <em>;надпись внизу</em><br>
push 1D00h <em>;ее цвет</em><br>
push 0 <em>;сообщение внутри рамки</em><br>
push 0 <em>;его цвет</em><br>
push 0 <em>;копировать ли экран?</em><br>
call Draw_frame <em><strong>;Рисуем рамку</strong></em></p>
<p>__________</p>
<p>Сразу отмечу, что команды
вида PUSH 23, PUSH 0 и т.п. толкают в
стек <strong>два</strong> байта, а не
один.</p>
<p>Теперь считаем количество
&quot;запиханных&quot; в стек байт:</p>
<p>push 23 <em>- 2 байта</em><br>
push 78 <em>- 2 байта</em><br>
push 1F00h <em>- 2 байта</em><br>
push offset Mess_head <em>- 2 байта</em></p>
<p>и т.д.</p>
<p>Итого: 20 байт. Следовательно,
процедура Draw_frame должна
доставать со стека столько же
байт. Т.о. выход из этой
процедуры будет таким: RET 20.
Следует также иметь в виду, что
при вызове данной процедуры
нужно будет <strong>всегда</strong>
заносить в стек 20 байт (10 слов),
даже если эти данные ей не
нужны. Иначе мы оставляем стек
невыровненным!</p>
<p>Возникает вопрос: как нам
получить доступ в процедуре к
занесенным в стек параметрам?
Очень просто!</p>
<p>Для этой цели принято
использовать регистр BP,
который мы мало где
использовали в наших
предыдущих примерах. Только
еще раз напоминаю: стек растет
снизу вверх. <strong>Первый
параметр, занесенный в стек -
последний для нашей процедуры.</strong>
И наоборот.</p>
<p>Давайте сперва возьмем самый
простой пример:</p>
<p>__________</p>
<p>...<br>
(1) push offset Message1<br>
(2) push offset Message2<br>
(3) call Print_string<br>
...<br>
(4) Print_string proc<br>
(5) mov bp,sp<br>
(6) add bp,2<br>
(7) mov ah,9<br>
(8) mov dx,[BP]<br>
(9) int 21h<br>
(10) mov dx,[BP+2]<br>
(11) int 21h<br>
<strong>(12) ret 4</strong><br>
(13) Print_string endp<br>
...<br>
(14) Message1 db 'Привет!$'<br>
(15) Message2 db 'Это я!$'</p>
<p>__________</p>
<p>Здесь мы вывели две строки на
экран, используя дважды
функцию 09 прерывания 21h. Это,
конечно, ужасно, но для
теоретического исследования
пойдет.</p>
<p>Как вы думаете, что
произойдет?</p>
<p>Если вы хорошенько подумали,
то сообразили, что сперва
выведется строка &quot;Это я!&quot;,
а затем - &quot;Привет&quot;. Если вы
не поняли, то повторю: стек
растет снизу вверх.
Следовательно, первый
параметр, занесенный в стек
будет последним! Строка (8)
получает адрес Message2, а (10) - Message1.
<u>Попрошу не путать!</u></p>
<p>Обратите внимание, что в
самом начале процедуры (строки
(5) - (6)) мы заносим в BP текущее
состояние стека, а затем
увеличиваем BP на 2. Это нужно
для того, чтобы
&quot;перепрыгнуть&quot; адрес
возврата, который занесла
инструкция в строке (3). Так
просто удобней немного будет
считать.</p>
<p>И еще не забывайте выходить
из процедуры соответствующим
образом, как в строке (12). Мы
занесли 4 байта, нам и выйти
нужно, используя RET 4.</p>
<p><em>&quot;У-у-у, Калашников, ну ты
даешь! Это ж как неудобно-то!
Лучше я заведу 10, 50, 100
переменных и буду работать с
ними, чем через стек. Бог сними,
с этими байтами, зато
удобно!&quot;</em> - слышу возгласы.
Друзья мои, не спешите делать
выводы! Я же еще не закрыл
данную тему!</p>
<p>Для удобства работы со стеком
(и не только с ним) используется
директива EQU (EQUivalent -
эквивалент) (помните Finish equ $ ?).
Так вот, с помощью данной
директивы мы можем очень
просто получить доступ к
параметрам, занесенным в стек.
Теперь внимательно смотрите,
что мы сделаем с приведенным
выше примером, используя EQU:</p>
<p>__________</p>
<p>...<br>
(1) push offset Message1<br>
(2) push offset Message2<br>
(3) call Print_string<br>
...<br>
(4) Print_string proc<br>
(5) mov bp,sp<br>
(6) add bp,2<br>
(7) mov ah,9<br>
(8) mov dx,Mess1<br>
(9) int 21h<br>
(10) mov dx,Mess2<br>
(11) int 21h<br>
(12) ret 4<br>
(13) Print_string endp<br>
...<br>
(14) Message1 db 'Привет!$'<br>
(15) Message2 db 'Это я!$'</p>
<p><strong>(16) Mess1 equ [BP+2]<br>
(17) Mess2 equ [BP]</strong></p>
<p>__________</p>
<p>Теперь строки выведутся в
так: &quot;Привет&quot;, а затем
&quot;Это я&quot;. Строки (16) - (17)
места в памяти НЕ занимают. При
ассемблировании MASM / TASM заменит
строки</p>
<p>mov dx,Mess1<br>
и<br>
mov dx,Mess2</p>
<p>на</p>
<p>mov dx,[BP+2]<br>
mov dx,[BP]</p>
<p>соответственно. Т.е. стоит
один раз позаботиться, а затем
все будет просто! Еще нужно
будет вам немного &quot;руку
набить&quot;: написать три-четыре
подобные программы и - все! Вы
будете счастливы!</p>
<p>Смотрите, как мы делаем
подобные вещи в нашей оболочке
(DATA.ASM):</p>
<p>Height_X equ [bp+18] <em>;высота рамки</em><br>
Width_Y equ [bp+16] <em>;ширина рамки</em><br>
Attr equ [bp+14] <em>;атрибуты рамки</em><br>
и т.д.</p>
<p>Получаем же доступ таким
образом (DRAW_FRAME, DISPLAY.ASM):</p>
<p>mov ax,Height_X<br>
mov ax,Attr<br>
и т.п.</p>
<p>Один раз посчитали, записали
и пользуемся! Еще раз обращаю
ваше внимание (т.к. много ошибок
происходит): Heigt_X заносится в
стек первой, а считываем ее
последней (Height_X equ [<font size="4"><strong>bp+18</strong></font>]).
Возврат из процедуры RET 20, т.к.
заносим 20 байт. Ошибки
(упущения) у вас, конечно, будут.
Но сразу проверяйте: <strong>а
правильно ли вы передали и
получили параметры в/из стека,
а также верно ли вы выходите из
процедуры.</strong></p>
<p>Поверьте, это очень удобно. Я
скажу более. При
программировании под Windows мы
будем постоянно передавать
параметры в стеке, причем очень
много! Так что, готовьтесь и
привыкайте!</p>
<p>__________</p>
<p>Еще несколько слов о данной
процедуре.</p>
<p>Обратите внимание, на
параметр Other. В нем мы будем
передавать (и уже передаем
один) параметры, которые
требуют проверки на &quot;да&quot;
или &quot;нет&quot;. Для этого
используется всего один бит
данной переменной. В нашем
примере мы, например, решили,
что нулевой бит (крайний
справа) будет указывать на то,
стоит ли перед выводим рамки
копировать часть экрана или
нет (ниже рассмотрим). В
дальнейшем, когда мы добавим
функций, будем проверять уже не
байты, а биты.</p>
<p>Допустим, третий бит
параметра Other указывает на то,
выводить подчеркнутую линию
или нет (например). Если третий
бит установлен, то выводим, а
если нет, то - нет. Т.о. один байт
в Ассемблере может нести 8
различных параметров (в байте,
как мы помним, 8 бит). Потом
будем серьезно работать с
битами. Для этого и изучали мы
двоичную систему счисления
(если вы ее, конечно, помните. А
если нет - то не страшно. Скоро
вспомните всё!) Удобно ли
использовать 8 бит одного байта
для передачи параметров?
Ес-сно!</p>
<p>__________</p>
<p>Обратите внимание, как мы
заносим в стек смещение строки:</p>
<p>push offset Mess_head</p>
<p>Просто, да?</p>
<p>__________</p>
<p>Еще обращаю ваше внимание,
как мы делаем:</p>
<p>push offset Mess_head <em>;надпись вверху
рамки </em><em><strong>(если 0, то не
выводить)</strong></em><br>
push 1E00h ;цвет надписи вверху
рамки</p>
<p>Т.е. если заносим просто нуль,
то строка выводиться не будет.
Может ли быть такое, что
смещение некоторой строки
будет нулевым? Вряд ли...</p>
<p>Тем не менее, если нам не
нужно выводить строку, то
атрибут строки все равно надо
заносить (просто любое число).
Если мы этого не сделаем, то
стек останется невыровненным.
Т.к. занесли мы 16 байт, а
процедура вытащит 20. Что
получается? Нарушение работы
стека...</p>
<p>Может, это сложно читается.
Если так, то смотрите
файл-приложение. Исследуйте.
Все действительно очень
просто!</p>
<p>__________</p>
<p>Обратите внимание, как мы
просто вычисляем длину строки.
Но это только в том случае, если
длина строки известна:</p>
<p>Mess_quit db 'Ассемблер',0<br>
Mess_quitl equ $-Mess_quit</p>
<p>Причем, последняя строка
занимать памяти не будет! В
отладчике строка</p>
<p>mov dx,offset Mess_quitl</p>
<p>будет выглядеть как</p>
<p>mov dx,9</p>
<p>Зачем это нужно? Вспомните
ситуацию со строками вида mov
ax,23+5*2. Это удобно. Более того, добавив или удалив что-либо
в/из строки Mess_quit,
программа-ассемблер (MASM/ TASM)
автоматически посчитает ее
размер. А иначе нам придется
делать это самостоятельно...</p>
<hr>
<p><strong>Процедуры Copy_scr / Restore_scr
(DISPLAY.ASM).</strong></p>
<p>Прежде, чем вывести на экран
рамку (окошко), нам нужно
сохранить ту информацию (те
символы), которые будут
потеряны (затерты выводимым
окошком). Попробуйте нажать в
Norton Commander'е F5, а затем ESC. Вы
задумывались, как так окошко
появляется на экране, а затем
исчезает, восстановив затертые
символы. Создается ощущение
того, что окошко просто
располагается поверх чего-то
другого. Кажется, мелочь. А это
все, дорогие мои, надо
собственными рученьками
делать (точно так же, как и
восстановление
пользовательского экрана (при
нажатии на Ctrl+O)). А как иначе вы
думали? Мы еще будем и тень от
окошка рисовать потом.</p>
<p>Для этой цели напишем две
процедуры: Copy_scr (копирование в
буфер) и Restore_scr (восстановление)
(DISPLAY.ASM).</p>
<p>Принцип такой: получаем DH
(ряд) с которого следует начать
сохранение, причем DL (колонка)
будет всегда нулевым (так
удобнее для программиста). В AX
заносится количество рядов,
которое нужно будет сохранить
относительно DH.<br>
Сперва нужно получить линейный
адрес (просто вызовем
известную нам процедуру Get_linear,
хотя можно было бы самим
умножить. Но зачем? Увеличивать
код?):</p>
<p>xor dl,dl <em>;Обнулим DL на всякий
случай. Теперь DH = ряд, DL = 0</em><br>
call Get_linear <em>;Получим линейный
адрес</em></p>
<p>После этого нужно получить
количество байт для сохранения
(вспоминаем, как расположены
символы в видеокарте). Для
этого количество рядов нужно
умножить на 160:</p>
<p>mov bl,160 <em>;Получим количество
байт, которые нужно копировать</em><br>
mul bl<br>
mov cx,ax <em>;Их - в CX (будем
использовать CX как счетчик)</em></p>
<p>AL у нас указывается на входе.
MUL BL умножает BL на AL, результат -
в AX, который переносим в CX.</p>
<p>Сохраним все эти данные в
переменных для восстановления.</p>
<p>Копировать будем целыми
рядами, т.е. от начала левого
угла до конца (DL от 0 до 79; для
этого мы и обнуляя DL &quot;на
всякий случай&quot;). Копируется
столько рядов, сколько будет
занимать окошко.</p>
<p>Все готово! Переносим данные
в область второй видео
страницы (первую занимает наша
оболочка, вторую -
пользовательский экран).</p>
<p>mov si,di <em>;DS:SI - откуда копируем</em><br>
xor di,di <em>;ES:SI - куда копируем</em><br>
mov Num_copySI,si <em>;Сохраним
полученные значения для
восстановления</em><br>
mov Num_copyDI,di<br>
mov Num_copyCX,cx<br>
push 0B800h <em>;Настроим сегментные
регистры</em><br>
pop ds<br>
push 0BA00h<br>
pop es<br>
rep movsb <em>;Копируем...</em></p>
<p>Восстанавливать очень
просто. Посмотрите Restore_scr...</p>
<hr>
<p align="center"><a name="newop"><font size="4"><strong>Новый
оператор SCAS</strong></font></a></p>
<p>Рассмотрим еще один оператор,
позволяющий работать со
строками (массивами данных).</p>
<div align="left"><table border="1" cellspacing="1"
bordercolorlight="#FFFFFF">
<tr>
<td width="25%" bgcolor="#52A5A5"><strong>Название</strong></td>
<td width="25%" bgcolor="#52A5A5"><strong>Перевод</strong></td>
<td width="20%" bgcolor="#52A5A5"><strong>Применение</strong></td>
<td width="20%" bgcolor="#52A5A5"><strong>Процессор</strong></td>
</tr>
<tr>
<td width="25%">SCAS</td>
<td width="25%">SCAn String -
сканирование строки</td>
<td width="20%">Поиск символа</td>
<td width="20%">8086</td>
</tr>
</table>
</div><p>Данный оператор имеет две
разновидности. Какие-какие? Все
верно! Вы уже мыслите по
аналогии с MOVS и STOS.</p>
<p>Вот они: SCASB и SCASW. Первый
служит для поиска первого
попавшегося байта, а второй -
первого попавшегося слова.</p>
<p>При этом ES:DI должен содержать
адрес строки.</p>
<p>Пример:</p>
<p>________</p>
<p>...</p>
<p>(1) mov di,offset String <em>;ES:DI - адрес
троки</em><br>
(2) mov cx,offset String_len <em>;CX -
максимальное количество
сканируемых байт/слов</em><br>
(3) mov al,9 <em>;Символ для поиска</em><br>
(4) repne scasb <em>;Ищем первый байт,
который находится в AL</em><br>
...</p>
<p>(5) String db 1,2,3,4,5,6,7,8,9,10,11,12<br>
(6) String_len equ $-String</p>
<p>________</p>
<p>В CX заносим длину (количество
символов/байт) в строке String, т.е.
12. В AL - символ, который нам
нужно найти.</p>
<p>После выполнения строки (4) DI
будет указывать на адрес
следующего после найденного
символа байт (т.е. на смещение
числа 10). Вроде, все понятно, но
есть четыре вопроса:</p>
<p>1. Что за REPNE? Мы ведь только REP
знаем.</p>
<p>2. Есть ли REPE (по аналогии с JNE /
JE)?</p>
<p>2. Что будет, если в
приведенном выше примере мы
занесем в AL 13?</p>
<p>3. Что будет, если мы в CX
занесем, например, 7?</p>
<p>Итак, оператор REPNE (REPeat in Not Equal
- повторять, если не равно)
сканирует строку (повторяет) до
тех пор, пока число в AL/AX не
будет найдено в строке. Он
обычно используется для поиска
первого символа в отличие от
оператора REPE (REPeat if Equal -
повторять, если равно).</p>
<p>Пример с оператором REPNE:</p>
<p>__________</p>
<p>...</p>
<p>(1) mov di,offset String <em>;ES:DI - адрес
троки</em><br>
(2) mov cx,offset String_len <em>;CX -
максимальное количество
сканируемых байт/слов</em><br>
(3) mov al,1 <em>;Символ для поиска</em><br>
(4) repe scasb <em>;Ищем первый байт,
который находится в AL</em><br>
...</p>
<p>(5) String db 1,1,1,1,1,6,1,1,1,1,1,1<br>
(6) String_len equ $-String</p>
<p>__________</p>
<p>В данном случае после
выполнения строки (4) DI будет
указывать на адрес следующего
за цифрой 6 байта (т.е. 1). Данный
префикс (REPE) обычно
используется для поиска
первого символа не равного
тому, который содержится в AL/AX.
В принципе, вопросов не должно
возникать.</p>
<p>Однако, вы пока что не имеете
понятия, где бы можно было
применить данные операторы.
Могу сказать только одно: нужна
практика. Я в свое время изучал
Ассемблер по книге Джордейна.
Сперва никак не мог понять
принцип языка. Я брал просто
примеры из книги и печатал их.
Со временем появлялись мысли,
алгоритмы, начал понимать, что
представляет из себя
Ассемблер. Так по-тихоньку и
научился...</p>
<p>В первой части книги я писал
так (выдержка):</p>
<p><em>&quot;...Может быть, Вам
показался язык Ассемблера
чрезвычайно сложным, но это,
поверьте, с первого взгляда. Вы
должны научиться строить
алгоритм программы на
Ассемблере в голове, а для
этого нужно будет написать
несколько программ
самостоятельно, опираясь на
информацию из данной книги. Я
буду постепенно учить Вас
мыслить структурой Ассемблера,
учить составлять алгоритмы,
программы, используя операторы
языка. После изучения
очередной главы, Вы будете
чувствовать, что постепенно
начинаете осваивать Ассемблер,
будет становиться все проще и
проще…<br>
Например, если Вы знакомы с
Бейсиком, то, ставя перед собой
задачу написать программу,
выводящую 10 слов &quot;Привет&quot;,
Вы будете использовать
операторы FOR, NEXT, PRINT и пр.,
которые тут же появятся в Ваших
мыслях. Вы строите
определенный алгоритм
программы из этих операторов,
который в какой-то степени
применим только к Бейсику. Тоже
самое и с Ассемблером. При
постановке задачи написать ту
или иную программу, Вы мысленно
создаете алгоритм, который
применим к Ассемблеру и только,
т.к. языков, похожих на
Ассемблер, просто не
существует. Моя задача -
научить Вас создавать в уме
алгоритмы, применимые к
Ассемблеру, т.е. научить
&quot;мыслить на
Ассемблере&quot;...&quot;</em></p>
<p>Так что, не волнуйтесь! Все
нормально!</p>
<hr>
<p>Вернемся к оболочке.</p>
<p>Мы вкратце рассмотрели
оператор SCAS потому, что теперь
мы используем его в нашей
оболочке для подсчета длины
строки (Count_strmid, DISPLAY.ASM). Как?</p>
<p>У нас признаком окончания
строки является символ ASCII 0.
Считаем количество символов в
строке для того, чтобы вывести
строку в центре ряда. В
дальнейшем мы будем часто
вызывать данную процедуру.
Давайте поподробней
рассмотрим ее.</p>
<p>___________</p>
<p>(1) push cs <em>;ES=CS</em><br>
(2) pop es<br>
(3) mov di,si <em>;DI=SI</em><br>
(4) xor al,al <em>;AL=0</em><br>
(5) mov cx,0FFFFh <em>;сколько символов
перебирать (возьмем максимум)...</em><br>
(6) repne scasb <em>;Ищем 0 в строке</em><br>
<em>;0 найден! DI указывает на
следующий символ за найденным 0</em></p>
<p><em>;SI=начало строки<br>
;DI=конец строки+1</em><br>
(7) sub di,si <em>;DI=DI-SI-1 = длина строки</em><br>
(8) dec di</p>
<p>(9) shr di,1 <em>;Делим длину на 2</em><br>
(10) mov ax,40 <em>;Делим кол-во
символов в строке на 2 = 40</em><br>
(11) sub ax,di <em>;AX=40-половина длины
строки = нужная колонка</em><br>
(12) mov dl,al <em>;DL=колонка, с которой
следует выводить строку!</em></p>
<p>___________</p>
<p>На входе мы в SI указываем
адрес строки, в которой следует
посчитать количество символов.
SCAS работает с парой регистров
ES:DI, следовательно нам нужно в DI
занести SI (строка (3)). Затем
обнулим AL (4), занесем в CX
максимальное число (длину-то
строки мы не знаем, поэтому
предположим, что она (длина)
максимально возможно для CX).
Начали поиск (6)...</p>
<p>Итак, нашли символ '0' (7). Мы его
просто не можем не найти.</p>
<p>Что мы теперь имеем? В SI
начальное смещение строки, в DI -
конец строки + 1. Чтобы получить
длину нужно из DI вычесть SI и еще
вычесть 1 (7) - (8):</p>
<p>DI=DI-SI-1=длина строки</p>
<p>Затем разделим полученную
длину на два (9). Т.к. на экране в
одном ряду 80 символов (режим 3),
то 80 делим на два, чтобы
получить середину ряда. Из
середины ряда вычитаем
половину длины строки. Полная
формула:</p>
<p>DI=длина строки</p>
<p>DL=(80/2)-(DI/2)</p>
<p>Теперь DL содержит колонку, с
которой следует начинать
выводить строку. Это и будет
центр ряда.</p>
<p>____________</p>
<p><strong>Вывод строки на экран
путем прямого отображения в
видеобуфер (Print_string, DISPLAY.ASM).</strong></p>
<p>______</p>
<p>Print_string proc<br>
(1) call Get_linear <em>;Получаем
линейный адрес строки</em></p>
<p>Next_symstr:<br>
(2) lodsb <em>;Получаем очередной
символ строки</em><br>
(3) or al,al <em>;Это 0 (конец строки?)</em><br>
(4) jz Stop_outstr <em>;Да - выходим...</em><br>
(5) stosw <em>;Иначе заносим в
видеобуфер атрибут (AH) и символ
(AL)</em><br>
(6) jmp short Next_Symstr <em>;Следующий
символ</em></p>
<p>(7) Stop_outstr:<br>
(8) ret<br>
Print_string endp</p>
<p>______</p>
<p>Перед вызовом данной
процедуры мы должны указать в
DS:SI адрес строки для вывода, DX -
координаты для вывода (DH -
столбец, DL - строка (ряд)), AH -
атрибуты выводимой строки.</p>
<p>Сперва мы вызовем сразу
процедуру перевода DX в
линейный адрес. Зачем? Так ведь
мы замедляем работу. Во-первых,
это делается для удобства
написания программы. Как вы
думаете, было бы удобно
постоянное вычислять самим
линейный адрес перед тем, как
вывести строку? И вообще, что
удобней указать строку/столбец
или одно число (линейный адрес)?
Конечно же первый вариант
предпочтительней. Ну а
во-вторых, скорость не
настолько уж падает. Я бы даже
сказал, что на глаз на 8086 это
абсолютно незаметно (я раньше
писал оболочку именно на 8086
процессоре). Так что, можете
быть спокойны!</p>
<p>Строка должна быть ASCIZ (т.е.
заканчиваться символом 0).
Конечно, вы можете придумать
другое ограничение строки
(например, как у функции 09 - '$').
Но вряд ли это будет удобно...</p>
<p>Понять работу данной
процедуры труда не составит.
Все элементарно!</p>
<p>_______</p>
<p>Обратите внимание, как у нас
организована проверка нажатых
клавиш (MAIN_PROC, MAIN.ASM), а также
посмотрите процедуру Quit_prog в
этом же файле. В дальнейшем мы
усовершенствуем вывод рамок на
экран с запросом &quot;Да&quot; /
&quot;Нет&quot;. Эти окошки, как
правило, аналогичны.</p>
<p>_______</p>
<p>Что еще? Посмотрите, как
просто мы показываем
пользовательский экран (при
нажатии на Ctrl+F5) (MAIN_PROC, MAIN.ASM).
Очень быстро и просто!</p>
<hr>
<p>Вот, вроде, и рассмотрели еще
один выпуск с оболочкой. На мой
взгляд, вы уже можете написать
самостоятельно оболочку типа
Norton Commander, используя программу
helpassm (у кого нет - возьмите на
нашем сайте). Моя задача теперь
заключается в том, чтобы
показать вам &quot;подводные
камни&quot;, алгоритмы, и пр. Как
видите, мы уже написали
несколько мощных процедур
(например, Draw_frame, Print_string),
которыми вы можете
пользоваться. Просто
вставляйте их в собственные
программы и вызывайте на
здоровье! Сложно? Да, в общем-то,
нет... Просто много времени
уходит на написание процедуры.
Зато какой выигрыш мы получаем
во времени и в размере!</p>
<p>И кто сказал, что Ассемблер
сложный язык?</p>
<p>До встречи через неделю!</p>
<p><strong>P.S. Скоро Новый год...</strong></p>
<hr>
<p><strong>С уважением,</strong></p>
<div align="center"><center><table border="4"
cellpadding="2" width="100%" bgcolor="#53A6A6"
bordercolor="#808080" bordercolorlight="#FFFFFF">
<tr>
<td width="33%"><p align="center"><font size="4"><strong>Автор
рассылки:</strong></font></p>
<p align="center"><em><strong>Калашников
Олег</strong></em></p>
<p align="center"><a
href="http://www.Kalashnikoff.ru"><font
color="#804040"><strong>www.Kalashnikoff.ru</strong></font></a></p>
</td>
<td width="33%"><p align="center"><font size="5"><strong>E-mail:</strong></font></p>
<p align="center"><a
href="mailto:assembler@beep.ru">assembler@beep.ru</a></p>
</td>
<td width="34%"><p align="center"><font size="4"><strong>UIN
(Тетя Ася):</strong></font></p>
<p align="center"><font color="#0000FF">68951340</font></p>
</td>
</tr>
<tr>
<td colspan="3" bgcolor="#448686"><font
color="#400040" size="1"><strong>(С)
Авторское право.</strong>
Запрещается использование
материала из рассылки в
коммерческих целях без
письменного согласия
автора.</font></td>
</tr>
</table>
</center></div></td>
</tr>
</table>
</center></div>

<hr>

<p align="center">[<a href="019.htm">Следующий выпуск</a>] [<a target=_BLANK href="http://www.Kalashnikoff.ru/">На главную страницу</a>]</p>


<HR NOSHADE><CENTER>
<!-- SpyLOG v2 f:0211 --><script language="javascript">  
u="u496.71.spylog.com";d=document;nv=navigator;na=nv.appName;p=1;  
bv=Math.round(parseFloat(nv.appVersion)*100);  
n=(na.substring(0,2)=="Mi")?0:1;rn=Math.random();z="p="+p+"&rn="+rn;y="";  
y+="<a href='http://"+u+"/cnt?f=3&p="+p+"&rn="+rn+"' target=_blank>";  
y+="<img src='http://"+u+"/cnt?"+z+  
"&r="+escape(d.referrer)+"&pg="+escape(window.location.href)+"' border=0 width=88 height=31 alt='SpyLOG'>";  
y+="</a>"; d.write(y);if(!n) { d.write("<"+"!--"); }//--></script><noscript><p align="center"><a 
href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" 
target="_blank"><img src="http://u496.71.spylog.com/cnt?p=1" alt="SpyLOG" align="middle" border="0"></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"></noscript></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"> 
<script language="javascript1.2"><!-- if(!n) { d.write("--"+">"); }//--></script></a> 
<!-- SpyLOG --> 
 
 <a target=_top href="http://www.one.ru"><img src="http://cnt.one.ru/cgi-bin/cnt.cgi?id=16871&t=9" width=88 height=31 alt="be number one" border=0></a> 
 
 <script language="JavaScript"><!-- 
d=document;a='';a+=';r='+escape(d.referrer) 
js=10//--></script><script language="JavaScript1.1"><!-- 
a+=';j='+navigator.javaEnabled() 
js=11//--></script><script language="JavaScript1.2"><!-- 
s=screen;a+=';s='+s.width+'*'+s.height 
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth) 
js=12//--></script><script language="JavaScript1.3"><!-- 
js=13//--></script><script language="JavaScript"><!-- 
d.write('<a href="http://top.list.ru/jump?from=87856"'+ 
' target=_top><img src="http://top.list.ru/counter'+ 
'?id=87856;t=54;js='+js+a+';rand='+Math.random()+ 
'" alt="TopList"'+' border=0 height=31 width=88></a>') 
if(js>11)d.write('<'+'!-- ')//--></script><noscript><a 
target=_top href="http://top.list.ru/jump?from=87856"><img 
src="http://top.list.ru/counter?js=na;id=87856;t=54" 
border=0 height=31 width=88 
alt="TopList"></a></noscript><script language="JavaScript"><!-- 
if(js>11)d.write('--'+'>')//--></script> 
 
<br><br> 

</body>
</html>
