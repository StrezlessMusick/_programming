<HTML><HEAD>
<TITLE>Калашников.ru - Ассемблер? Это просто!.. (Выпуск № 008)</TITLE>
</HEAD><BODY BGCOLOR=#EBD2A5 link=#660000 alink=#000000 vlink=#000000 text=#000000>

<P align=center><A 
href="http://ad.ir.ru/bb.cgi?cmd=go&pubid=128269&pg=2&vbn=10001&nocache=77524" 
target=_top><IMG alt="InterReklama " border=0 
src="http://ad.ir.ru/bb.cgi?cmd=ad&pubid=128269&pg=2&vbn=10001&nocache=77524"></A></P>
<P align=center><A href="http://www.ir.ru" target=_top><FONT size=1>InterReklama 
Advertising</FONT></A> </P>
<HR>

<div align="center"><center>

<table border="2" width="100%" bgcolor="#9BDEEC">
 <tr>
<td width="100%"><div align="center"><center><table
border="3" width="100%" bgcolor="#3C89B7">
<tr>
 <td width="100%"><p align="center"><font size="5"><strong>Здравствуйте,
 уважаемые любители
 Ассемблера!</strong></font></p>
 <hr>
 <p align="center">Выпуск N 008</p>
 </td>
</tr>
</table>
</center></div><hr>
<p align="left"><font size="5"><strong>Сегодня в
нашей рассылке:</strong></font></p>
<ul>
<li><p align="left"><a href="#letters"><font
 color="#800000" size="3"><strong>Ваши
 письма</strong></font></a><font
 color="#800000" size="3"><strong>;</strong></font></p>
</li>
<li><p align="left"><a href="#previous"><font
 color="#800000" size="3"><strong>Программа
 из прошлого выпуска</strong></font></a><font
 color="#800000" size="3"><strong>;</strong></font></p>
</li>
<li><p align="left"><a href="#theory"><font
 color="#800000" size="3"><strong>Немного
 теории</strong></font></a><font
 color="#800000" size="3"><strong>;</strong></font></p>
</li>
<li><p align="left"><a href="#prog"><font
 color="#800000" size="3"><strong>Программка
 для практики</strong></font></a><font
 color="#800000" size="3"><strong>.</strong></font></p>
</li>
</ul>
<hr>
<p align="center"><a name="letters"><font size="5"><strong>Ваши
письма</strong></font></a></p>
<p>Спасибо всем, кто высказал
свое мнение по поводу терракта.
Я на сайте разместил некоторые
ваши письма.</p>
<p>Еще хотел бы обратить ваше
внимание на такой момент:
рассылки могут приходить с
большим опозданием (2-4 дня).
Может даже случиться так, что
рассылка не дойдет вовсе, если
сервер Subscribe.ru не сможет
отправить письмо в течение
суток.</p>
<p>Выпуски выходят в субботу -
понедельник. Если до пятницы вы
не получите очередной номер -
пишите мне, либо перекачайте с
архива:</p>
<p><a
href="http://www.subscribe.ru/archive/comp.prog.assembler">www.subscribe.ru/archive/comp.prog.assembler</a>.</p>
<p>Более того, случается и такое,
что Subscribe.ru отправляет рассылку
кому-нибудь два раза. Даже не
знаю, с чем это связано. Прошлый
раз была моя вина в том, что
рассылка вышла в двойном
экземпляре. Первый раз, когда я
пытался отправить, произошла
ошибка. Я подумал, что выпуск не
выйдет и переслал его. Однако, я
ошибался... В итоге, все
получили две копии рассылки.</p>
<p>Я, к сожалению, тут бессилен
что-либо сделать...</p>
<p align="center">_______________________</p>
<p>Еще несколько моментов.</p>
<p>Друзья мои! Я просто
физически не могу ответить на
все ваши вопросы. Для этого мне
нужно было бы забросить
рассылку, работу и рефераты и
отвечать только на ваши письма.
Очень много вопросов поступает
по поводу того, что программу
из выпуска набрал, а она не
работает. Что делать?</p>
<p><strong>Пожалуйста, внимательно
набирайте текст программы.</strong>
Мне приходится самому
проверять, в процессе чего
обнаруживается ваша опечатка.
Пока программы небольшие, и это
не отнимает у меня много
времени. Но что мы будем делать,
когда начнем писать оболочку
или резидент? Представьте,
сколько времени займет у меня
поиск ошибки...</p>
<p>Многие также просят выслать
какую-нибудь информацию. Все,
что у меня есть - находится на
сайте, где вы можете скачать.
Конечно, там пока информация
довольно-таки устаревшая, но на
настоящий момент ее более чем
достаточно. Если вы хотите
найти дополнительно что-либо -
ищите в <a href="http://www.yandex.ru">Яндексе</a>
или еще где-нибудь.</p>
<p align="center">_______________________</p>
<p>Чат. Он, конечно, далек от
совершенства. Наблюдаются
некоторые ошибки. Например,
невозможно ввести e-mail, если он
содержит более 15 знаков либо
числа (0-9). Вводите какое-нибудь
другое имя. Например:</p>
<p><a href="mailto:oleg@mail.ru">oleg@mail.ru</a></p>
<p><a href="mailto:dimon@pisem.net">dimon@pisem.net</a></p>
<p>и т.п.</p>
<p align="center">_______________________</p>
<p>Некоторым я отправлял ответ,
но письмо вернулось, т.к.
адресат не был найден. В теле
письма мне не удалось найти
какой-нибудь ответный адрес. Я
пытался два раза, но так ничего
не получилось. Извините, кто не
получил ответ. Ничего не смог
поделать...</p>
<p align="center">_______________________</p>
<p>В <a href="http://www.Kalashnikoff.ru">прошлом
выпуске</a> я писал о том, что
программа не работает на 486
процессорах (помните?). Пришло
несколько ответов, которые я
опубликую (возможно, вам это
будет интересно):</p>
<p><em>В 486 процессорах есть 
ошибка в схемотехнике,
приводящая к тому, что при
записи в память по адресу большему
текущего IP, но меньшему длины
очереди
предвыборки команд, содержимое очереди не
перечитывается, а
выполняется то, что уже было
считано процессором. Поэтому
процессор никак
не реагирует на изменения в коде. Эта ошибка была исправлена
только в Пентиуме.</em></p>
<p><strong>Прислал Alex.</strong></p>
<p align="center">_______</p>
<p><em>Мне кажется, я могу дать
объяснение данному
&quot;феномену&quot; :) Дело в том, что
у процессоров 80486 работа
механизма кэширования отлична
от механизма реализованного в
процессорах Pentium. Попробую
разъяснить.</em></p>
<p><em>Дело в том, что процессор, 
при выполнении команд,
считывает их в кэш. И на
выполнение команды поступают
уже из кэша. Так вот. Секрет в
том, что при изменении участка
кода, который уже закэшировал
процессор 486, не обновляет
содержимое кэша!!! Т.е. на 486
процессорах возможен вариант
затирания NOP-ами всей
программы, и, тем не менее, она
выполнится. В случае с Pentium-ами, 
ситуация выглядит более
правильной. При изменении
участка памяти, который уже
закэширован, процессор
сбрасывает содержимое кэша и
заново считывает данные из
памяти. Поэтому пример
работает на Pentium и не работает
на 486.</em></p>
<p><em>Остается один момент:
почему на 486 под SoftIce
программа-таки да выполняется?
Тут дело в том, что когда
отладчик прерывает выполнение
программы, то меняются
значения всех сегментных
регистров. И процессор
принудительно сбрасывает кэш,
так как его содержимое ему уже
не нужно. А так как кэш
сбрасывается, то его новое
содержимое уже будет отражать
текущее содержимое памяти, и,
следовательно, программа
выполняется по командам,
которые лежат в памяти. А там
как раз лежат именно нами
прописанные NOP-ы.</em></p>
<p><strong>Прислал Slava V.</strong></p>
<p align="center">_______________________</p>
<p>Вот еще одно интересное
письмо, на которое стоит дать
ответ в рассылке:</p>
<p><em>Здравствуйте Олег,</em></p>
<p><em>Если посмотреть
возможности языка Ассемблера,
то получается, что языки
высшего уровня могут делать
практически тоже самое и даже
лучше.</em></p>
<p><em>Зачем нужен Ассемблер? Что
он может делать, что не сможет
сделать любой другой язык?</em></p>
<p><em>Ведь это неинтересно
изучать то, что не понимаешь!</em></p>
<p><strong>Прислал Роман.</strong></p>
<p>И в самом деле, друзья! Я ведь
даже и словом не обмолвился о
том, чем же Ассемблер лучше
других языков, какие его плюсы
и какие минусы? Полагая, что
многие уже догадались, я, тем не
менее, перечислю достоинства и
недостатки Ассемблера:</p>
<p><font size="4"><strong>Плюсы:</strong></font></p>
<ul>
<li><em>Программа, написанная на
 Ассемблере, максимально
 быстро работает (в 50-200 раз
 быстрее Бейсика и в 3-20 раз
 быстрее С++);</em></li>
<li><em>Код программы
 максимально компактен;</em></li>
<li><em>Позволяет сделать то,
 что ни один язык высокого
 уровня не способен
 сделать.</em></li>
</ul>
<p><font size="4"><strong>Минусы:</strong></font></p>
<ul>
<li><em>Больше времени
 затрачивается на
 написание программы;</em></li>
<li><em>Код длиннее, чем в других
 языках;</em></li>
<li><em>Сложнее любых других
 языков.</em></li>
</ul>
<p>Однако, вы в дальнейшем
поймете, что стоит один раз
написать процедуры (например,
вывод рамки на экран, получение
строки символов и пр.), а затем
вызывать их из других программ.
В итоге, времени у вас займет не
настолько больше, чем писать,
например, на Паскале.</p>
<p>Наибольший эффект (я бы
сказал, оптимальный вариант)
достигается при
комбинировании двух языков:
Pascal+Assembler или C+Assembler. Это
особенно становится
актуальным при
программировании под Windows.</p>
<p>Кстати, о Windows. После выхода
предыдущего выпуска ко мне
стало приходить много писем с
просьбой быстрее перейти к Win32.
Я не спорю, это интересней на
первый взгляд. Стоит отметить,
что программирование под Win32 на
Ассемблере мало чем отличается
от программирования на языках
высокого уровня. Если в DOS
скорость работы зависит от
использования языка и
профессионализма
программиста, то в Win скорость
зависит <strong><u>только</u></strong> от
операционной системы.</p>
<p>Многие мне возразят: зачем,
мол, учитывать скорость,
считать такты, оптимизировать
программы, уменьшать код, если
и так большинство людей
используют Pentium-200 (32Мб / 6Гб) и
выше, где плюс-минус 1000 тактов
на глаз не заметно?</p>
<p>Вот, что я могу сказать. Дома у
меня, к сожалению, пока стоит
486DX2-80. Программа WinAmp (кажется,
такое название) не успевает
проигрывать MP3-файлы (задержки
большие). Но другая программа
(Xing Mpeg) воспроизводит их
прекрасно! Алгоритмы разные. В
любом случае хочется, чтобы
ваша любимая игра или
программа работала быстрее...</p>
<p>В связи с тем, что многие
очень хотят научится писать
программы под Windows, я провожу на
сайте голосование по этому
поводу:</p>
<p><strong>Как будем изучать
Ассемблер:</strong></p>
<p>1. Только DOS;</p>
<p>2. Быстро DOS, а затем Win</p>
<p>3. Сразу Win.</p>
<p>Несколько комментариев.</p>
<p><font size="4"><strong><u>Внимание:</u></strong></font>
DOS мы будем проходить и
одновременно изучать три
программы (за которые вы проголосовали):</p>
<p>1. Оболочка (на которую, судя
по всему, будем делать акцент,
хотя голосование еще
продолжается);</p>
<p>2. Вирус;</p>
<p>3. Резидент.</p>
<p>Думаю, что изучить только DOS
будет не интересно. По крайней
мере, наш курс будет неполным
без Win.</p>
<p>Изучать сразу Win будет <strong><u>очень
тяжело</u></strong> для тех, кто
вообще не знаком с Ассемблером.</p>
<p>На мой взгляд оптимальный
вариант 2: Быстро DOS, а затем Win.</p>
<p>Тем не менее, выбор за вами.
Те, кто уже посетил сайт и
проголосовал (всего 39 человек),
считают именно второй вариант
лучшим. Но, прошу вас, голосуйте
еще! Уроки-то вы строите, а не я.</p>
<p>Ниже привожу наш <strong>примерный</strong>
план обучения по DOS (по просьбе
многих подписчиков):</p>
<ul>
<li>прерывания;</li>
<li>работа с файлами и дисками;</li>
<li>работа со строками;</li>
<li>немного графики;</li>
<li>резиденты;</li>
<li>структура DOS в общих
 чертах;</li>
<li>переменные;</li>
<li>способы адресации;</li>
<li>строковые операции;</li>
<li>управление флагами;</li>
<li>макроопределения;</li>
<li>клавиатура;</li>
<li>мышь;</li>
<li>принтер;</li>
<li>управление памятью (UMB, HMA,
 EMS, XMS);</li>
<li>загрузка и выполнение
 программ;</li>
<li>командные параметры и
 переменные среды;</li>
<li>программирование на
 уровне портов
 ввода-вывода;</li>
<li>и пр.</li>
</ul>
<p>Много? Но зато как интересно!!!</p>
<p>Если большинством голосов
победит второй вариант (быстро
DOS, а затем Win), то все это мы
пройдем быстрее (в одном
выпуске, где это возможно,
рассмотрим 2-3 темы).</p>
<p>Здесь есть несколько
&quot;но&quot;:</p>
<p>1. Вам нужно будет запастись
программой-ассемблером для Win.
В принципе, я помещу
&quot;голые&quot; файлы на сайт, но
этого будет недостаточно. Я
рекомендую найти и скачать MASM
6.14 вот здесь: <a
href="http://win32asm.newmail.ru">http://win32asm.newmail.ru</a>.
Хотя это не к спеху...</p>
<p>2. У меня нет <strong><u>опыта</u></strong>
программирования под Win.
Поэтому изучать будем вместе.
Можно создать хороший форум,
где будут обсуждаться вопросы,
проблемы и пр. Получится у нас
что-то вроде клуба
программистов на Ассемблере.
Как вы думаете? Можно присылать
мне пожелания по следующему
адресу.</p>
<p><a
href="mailto:oleg77@online.ru?Subject=Клуб программистов">oleg77@online.ru?Subject=Клуб
программистов</a></p>
<p align="center">___________________</p>
<p>Еще хотел бы сказать по
поводу Интернета. В офисе, где я
работаю в настоящий момент, в
Интернет можно выйти только по
модему. Со следующей недели я
буду находиться в другом офисе,
где Интернет будет по
световому кабелю и бесплатно
для меня. Я буду висеть в сети с
10:00 до 19:00 по Московскому
времени (если куда-нибудь не
отлучусь на время - работа
все-таки). В связи с этим
сообщаю вам номер своей ICQ:
68951340. Обращаю ваше внимание на
то, что пока никакие программы
не настроены. На установку и
настройку может уйти несколько
дней. Так что доступ ко мне
может быть не с понедельника.
Вероятно, и e-mail поменяется. Но я
об этом сообщу немедленно, хотя
текущий будет еще действовать
около месяца после перехода на
новый.</p>
<p>Может случиться так, что я не
смогу выйти на связь в течение
нескольких дней. Причиной
может служить следующее: попал
в аварию, сломал нос, вывихнул
ухо и т.п., лежу дома, пью
лекарство. Хотя самое страшное,
что может произойти (боюсь
подумать!) - отключение от
Интернет...</p>
<p>Вот, вроде бы все, что хотел
сказать.</p>
<hr>
<p align="center"><a name="previous"><font size="5"><strong>Программа
из прошлого выпуска.</strong></font></a></p>
<p>Спасибо всем, кто прислал мне
свои варианты решения!
Некоторые я поместил на сайт.
Хотел бы попросить: указывайте,
пожалуйста, в письме, стоит ли
опубликовывать ваш e-mail.</p>
<p>В принципе, ничего сложно в
ней не было. Единственное, на
что я хотел обратить ваше
внимание, это на перевод
шестнадцатеричных чисел в
десятичные.</p>
<p>Совет такой: необходимо
запомнить (или запомнится само
со временем) некоторые
частоиспользуемые
шестнадцатеричные числа и
десятичные:</p>
<p>20h - 32</p>
<p>100h - 256</p>
<p>1Bh- 27</p>
<p>21h - 33</p>
<p>и пр.</p>
<p>...</p>
<p>(1) call Wait_key ;ждем клавишу...</p>
<p>(2) cmp al,27 ;это ESC?</p>
<p>(3) je Quit_prog ;если да - то на метку
Quit_prog (quit - выход; prog (program) -
программа)</p>
<p>(4) cmp al,0 ;код клавиши
расширенный? (F1-F12 и т.п.)</p>
<p>(5) je Begin ;да - повторим запрос...</p>
<p>(6) call Out_char ;вызываем процедуру
вывода нажатой клавиши на
экран</p>
<p>(7) jmp Begin ;ждем дальше....</p>
<p>(8) Quit_prog: ;метка, на которую
придет программа в случае
нажатия ESC</p>
<p>(9) mov al,32 ;помещаем в AL
&lt;пробел&gt;</p>
<p>(10) call Out_char ;вызываем
процедуру вывода символа в AL (в
данном случае - пробела). Здесь
мы как бы &quot;обманываем&quot;
процедуру Out_char, которая нужна
для вывода нажатого символа на
экран. Мы симулируем нажатие
клавиши пробел и вызываем
процедуру. Подумайте над этим...</p>
<p>(11) int 20h ;выходим...</p>
<p>(12) ...</p>
<p>(13) ; --- Out_char --- ;процедура
(комментарий)</p>
<p>(14) Out_char proc ;начало</p>
<p>(15) push cx ;сохраним все
регистры, которые будут
изменены подпрограммой...</p>
<p>(16) push ax ;...сделаем это для
того, чтобы в последствии не
было путаницы</p>
<p>(17) push es ;сохраним сегментный
регистр</p>
<p>(18) push ax ;сохраним AX, т.к. в нем
код нажатой клавиши...</p>
<p>(19) mov ax,0B800h ;установим ES на
сегмент видеобуфера</p>
<p>(20) mov es,ax</p>
<p>(21) mov di,0 ;DI - первый символ
первой строки</p>
<p>(22) mov cx,2000 ;выводим 2000 символов
(80 символов в строке * 25 строк)</p>
<p>(23) pop ax ;восстановим код
клавиши (см. строку 18)...</p>
<p>(24) mov ah,31 ;цвет символа</p>
<p>(25) Next_sym: ;метка для цикла</p>
<p>(26) mov es:[di],ax ;заносим код
клавиши и ее цвет (цвет всегда
31)</p>
<p>(27) inc di ;увеличиваем указатель
на 2 (первый байт - символ,
второй байт - цвет)</p>
<p>(28) inc di</p>
<p>(29) loop Next_sym ;обработка
следующего символа</p>
<p>(30) pop es ;восстановим
сохраненные регистры и
выровним стек</p>
<p>(31) pop ax</p>
<p>(32) pop cx</p>
<p>(33) ret ;вернемся из процедуры</p>
<p>(34) Out_char endp</p>
<p>...</p>
<p>В строке (12) опущена процедура
ожидания клавиши от
пользователя в целях экономии
места. Я думаю, что вы без труда
разберетесь...</p>
<p>Программа делает следующее:</p>
<ul>
<li>ждет от пользователя
 клавиши;</li>
<li>если это расширенный ASCII
 (F1-F12, стрелки), то
 игнорирует ее;</li>
<li>если это не расширенный ASCII
 (A-Z, 0-9 и т.п.) - заполнить
 экран данным символом;</li>
<li>если нажимаем ESC (27 или 1Bh),
 то заполнить экран
 пробелами (mov al,32) и выйти.</li>
</ul>
<p>Нич-чего сложного...</p>
<hr>
<p align="center"><a name="theory"><font size="5"><strong>Немного
теории.</strong></font></a></p>
<p>Пришло время рассмотреть
работу с файлами.</p>
<p>Для того, чтобы прочитать
содержимое файла необходимо
вначале открыть его. Это
позволяет сделать функция 3Dh
прерывания 21h:</p>
<p><font color="#804040">Функция 3Dh
прерывания 21h - открытие файла:</font></p>
<table border="1" cellpadding="2" bordercolor="#000000">
<tr>
 <td bordercolordark="#000000"
 bordercolorlight="#000000"><strong>Вход: </strong></td>
 <td bordercolordark="#000000"
 bordercolorlight="#000000">AH = 3Dh<p>AL = тип
 открытия (00 - только чтение,
 01 - только запись, 02 - чтение
 / запись)</p>
 <p>DS:DX = адрес ASCII-строки с
 именем файла</p>
 </td>
</tr>
<tr>
 <td bordercolordark="#000000"
 bordercolorlight="#000000"><strong>Выход:</strong></td>
 <td bordercolordark="#000000"
 bordercolorlight="#000000">AX - номер
 файла<p>JC - ошибка</p>
 </td>
</tr>
</table>
<p>Итак, на входе AL должен
содержать тип открытия (что мы
будем делать с файлом: только
прочитаем в память, только
запишем что-нибудь или будем
делать и то и другое).
Естественно, при открытии
файла для чтения / записи (AL=3) мы
не обязаны прочитать его, а
затем что-то записать. Можно
просто записать, можно просто
прочитать, а можно вообще
ничего не делать.</p>
<p>Однако, следует иметь в виду,
что если мы попытаемся открыть
файл с атрибутом &quot;Только
чтение&quot; (&quot;read-only&quot;) для
записи (AL=2) или для чтения /
записи (AL=3), то функция вернет
ошибку.</p>
<p>Следующий код открывает файл
для чтения / записи:</p>
<p>...</p>
<p>mov ax,3D02h</p>
<p>mov dx,offset File_name</p>
<p>int 21h</p>
<p>...</p>
<p>File_name db 'command.com',0</p>
<p>Обратите внимание, что мы в AX
загружаем сразу два числа: 3Dh и
02h. Это будет работать быстрее,
если бы мы делали так:</p>
<p>mov ah,3Dh</p>
<p>mov al,02h</p>
<p>Строку</p>
<p>File_name db ....</p>
<p>можно помещать где угодно.
Главное, чтобы она не
перемешивалась с кодом. Я это
уже объяснял, но, тем не менее,
ко мне приходят вопросы по
этому поводу. Например, нельзя
делать так:</p>
<p>...</p>
<p>mov ax,3D02h</p>
<p>mov dx,offset File_name</p>
<p>File_name db 'command.com',0</p>
<p>int 21h</p>
<p>...</p>
<p>В данном случае, программа
сассемблируется без ошибок, но
зависнет при запуске.
Процессор распознает 'command.com'
как набор инструкций, а не
строку символов. Скорее всего,
это не имеет никакой логики...</p>
<p>Имя файла можно указывать
даже так:</p>
<p>File_name db 'C:\ASSM\command.com',0</p>
<p>ПРОПИСНЫЕ и строчные символы
значения не имеют. Можно
записать и так:</p>
<p>My_file db 'a:\myfile.doc',0</p>
<p>Если диск и путь к файлу
опущен, то программа будет
искать файл в текущем каталоге.</p>
<p>Теперь о том, что возвращает
функция. Вот код:</p>
<p>...</p>
<p>mov ax,3D00h</p>
<p>mov dx,offset Just_file</p>
<p>int 21h</p>
<p>...</p>
<p>Just_file db 'file',0</p>
<p>Допустим, в текущем каталоге
файла &quot;file&quot; не было найдено.
Тогда, функция
3Dh устанавливает в единицу
флаг переноса (помните схожую
ситуацию с флагом нуля из
прошлых выпусков?). Если же файл
все-таки найден и успешно
открыт, то флаг переноса
устанавливается в нуль.</p>
<p>Для проверки состояния флага
переноса используется
оператор JC (Jump if Carry - переход,
если установлен флаг переноса)
и JNC (Jump if Not Carry - переход, если
флаг переноса не установлен):</p>
<p>...</p>
<p>int 21h</p>
<p>jc Error</p>
<p>Ok:</p>
<p>....</p>
<p>Error:</p>
<p>...</p>
<p>или так:</p>
<p>...</p>
<p>int 21h</p>
<p>jnc Ok</p>
<p>Error:</p>
<p>...</p>
<p>Ok:</p>
<p>...</p>
<p>Естественно, вместо меток Ok и
Error (ошибка) можно задавать
любые другие имена.</p>
<p>Вы уже можете сделать вывод,
что JC и JNC - команды условного
перехода.</p>
<p>Все функции прерывания 21h
устанавливают в единицу флаг
переноса, если произошла
ошибка и сбрасывают его, если
ошибки не было.</p>
<p>Вот полный пример открытия
файла:</p>
<p>...</p>
<p>mov ax,3D00h</p>
<p>mov dx,offset File_name</p>
<p>int 21h</p>
<p>jc Bad_file</p>
<p>mov dx,offset Mess1</p>
<p>Quit_prog:</p>
<p>mov ah,9</p>
<p>int 21h</p>
<p>int 20h</p>
<p>Bad_file:</p>
<p>mov dx,offset Mess2</p>
<p>jmp Quit_prog</p>
<p>Далее. При успешном открытии
файла в AX возвращается
уникальный идентификационный
номер файла. В дальнейшем, при
обращении к данному файлу,
будет указываться не его имя, а
этот номер. После вызова
функции 3Dh сохраните номер
файла!</p>
<p>После того, как мы закончили
работу с файлом (записали или
прочитали что-нибудь), его
необходимо закрыть функцией 3Eh
прерывания 21h:</p>
<p><font color="#804040">Функция 3Eh
прерывания 21h - закрытие файла:</font></p>
<table border="1" cellpadding="2" bordercolor="#000000" width="419">
<tr>
 <td bordercolordark="#000000"
 bordercolorlight="#000000" width="53"><strong>Вход: </strong></td>
 <td bordercolordark="#000000"
 bordercolorlight="#000000" width="346">AH = 3Eh<p>BX -
 номер файла</p>
 </td>
</tr>
<tr>
 <td bordercolordark="#000000"
 bordercolorlight="#000000" width="53"><strong>Выход:</strong></td>
 <td bordercolordark="#000000"
 bordercolorlight="#000000" width="346">ничего</td>
</tr>
</table>
<p>Все данные, которые мы
записывали в файл, на самом
деле не записываются сразу на
диск. Они хранятся в памяти до
тех пор, пока файл не будет
закрыт. Только после этого
сбрасываются все дисковые
буферы, и файл сохраняется на
диске. Это не совсем так, но
принцип такой.</p>
<p>Не забывайте закрывать файл!</p>
<p>mov ah,3Eh</p>
<p>mov bx,Handle</p>
<p>int 21h</p>
<p>Файл закрыт.</p>
<p>Обратите внимание на запись
mov bx,Handle. Здесь Handle - это
переменная, в которую
необходимо будет занести номер
файла после открытия.
Переменные мы подробно
рассмотрим в следующих
выпусках, а сейчас коснемся
только того, как создать
переменную Handle. Вот пример:</p>
<p>Handle dw 0</p>
<p>Здесь мы резервируем два
байта для хранения
каких-нибудь данных. В данном
случае - для хранения номера
файла. Таким образом,
рассмотрим фрагмент программы,
которая открывает файл для
чтения, сохраняет номер файла в
переменную, а затем закрывает
файл:</p>
<p>...</p>
<p>mov ax,3D00h</p>
<p>mov dx,offset File_name</p>
<p>int 21h</p>
<p>jc Error</p>
<p>mov Handle,ax</p>
<p>; файл открыт успешно...</p>
<p>mov ah,3Eh</p>
<p>mov bx, Handle</p>
<p>int 21h</p>
<p>;файл закрыт</p>
<p>Error:</p>
<p>int 20h</p>
<p>...</p>
<p>Handle dw 0</p>
<p>...</p>
<p align="center">__________</p>
<p>Для чтения информации из
файла используется функция 3Fh,
а для записи в файл - 40h. При этом
BX должен содержать тот самый
номер файла (Handle), CX - количество
читаемых или записываемых
байт, DS:DX - адрес буфера для
чтения / записи.</p>
<hr>
<p align="center"><a name="prog"><font size="5"><strong>Программка
для практики.</strong></font></a></p>
<p>Ой! Тут столько объяснять
придется. Давайте поступим как
в первом выпуске: кое-что мы
рассмотрим позже.</p>
<p>Итак, вот образец чтения
файла (до 64000 байт) в память, а,
точнее, в наш сегмент (это и
будет программкой для
практики):</p>
<p>CSEG segment</p>
<p>assume cs:CSEG, ds:CSEG, es:CSEG, ss:CSEG</p>
<p>org 100h</p>
<p>;начало</p>
<p>Begin: mov ax,3D00h</p>
<p>mov dx,offset File_name</p>
<p>int 21h</p>
<p>jc Error_file</p>
<p>mov Handle,ax</p>
<p>mov bx,ax</p>
<p>mov ah,3Fh</p>
<p>mov cx,0FF00h</p>
<p>mov dx,offset Buffer</p>
<p>int 21h</p>
<p>mov ah,3Eh</p>
<p>mov bx,Handle</p>
<p>int 21h</p>
<p>mov dx,offset Mess_ok</p>
<p>Out_prog:</p>
<p>mov ah,9</p>
<p>int 21h</p>
<p>int 20h</p>
<p>Error_file:</p>
<p>mov dx,offset Mess_error</p>
<p>jmp Out_prog</p>
<p>;конец</p>
<p>Handle dw 0</p>
<p>Mess_ok db 'Файл загружен в память!
Смотрите в отладчике!$'</p>
<p>Mess_error db 'Не удалось открыть
(найти) файл '</p>
<p>File_name db 'c:\msdos.sys',0,'!$'</p>
<p>Buffer equ $</p>
<p>CSEG ends</p>
<p>end Begin</p>
<p>Из этого примера вы узнаете
очень много. Еще раз хочу
сказать: <font size="4"><strong>пользуйтесь
отладчиком</strong></font>! Смотрите
адреса, которые загружаются в
DX. Там будет много чего
интересного!!!</p>
<p>Ваши решения принимаются
здесь: <a
href="mailto:oleg77@online.ru?Subject=Решение">oleg77@online.ru?Subject=Решение</a></p>
<p>В течение следующей недели
они будут помещаться на сайт.
Пожалуйста, указывайте также,
хотите ли вы, чтобы на сайте был
опубликован ваш e-mail.</p>
<p><strong>До встречи, друзья мои!</strong></p>
<p><strong>С уважением,</strong></p>
<p><strong>Калашников Олег</strong> ( <a
href="mailto:oleg77@online.ru?Subject=Ассемблер:"><font
color="#0000FF">oleg77@online.ru?Subject=Ассемблер:</font></a>
)</p>
<p><strong>Сайт: </strong><a
href="http://www.Kalashnikoff.ru"><strong>www.Kalashnikoff.ru</strong></a></p>
</td>
 </tr>
</table>
</center></div>

<hr>

<p align="center">[<a href="009.htm">Следующий выпуск</a>] [<a target=_BLANK href="http://www.Kalashnikoff.ru/">На главную страницу</a>]</p>

<HR NOSHADE><CENTER>
<!-- SpyLOG v2 f:0211 --><script language="javascript">  
u="u496.71.spylog.com";d=document;nv=navigator;na=nv.appName;p=1;  
bv=Math.round(parseFloat(nv.appVersion)*100);  
n=(na.substring(0,2)=="Mi")?0:1;rn=Math.random();z="p="+p+"&rn="+rn;y="";  
y+="<a href='http://"+u+"/cnt?f=3&p="+p+"&rn="+rn+"' target=_blank>";  
y+="<img src='http://"+u+"/cnt?"+z+  
"&r="+escape(d.referrer)+"&pg="+escape(window.location.href)+"' border=0 width=88 height=31 alt='SpyLOG'>";  
y+="</a>"; d.write(y);if(!n) { d.write("<"+"!--"); }//--></script><noscript><p align="center"><a 
href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" 
target="_blank"><img src="http://u496.71.spylog.com/cnt?p=1" alt="SpyLOG" align="middle" border="0"></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"></noscript></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"> 
<script language="javascript1.2"><!-- if(!n) { d.write("--"+">"); }//--></script></a> 
<!-- SpyLOG --> 
 
 <a target=_top href="http://www.one.ru"><img src="http://cnt.one.ru/cgi-bin/cnt.cgi?id=16871&t=9" width=88 height=31 alt="be number one" border=0></a> 
 
 <script language="JavaScript"><!-- 
d=document;a='';a+=';r='+escape(d.referrer) 
js=10//--></script><script language="JavaScript1.1"><!-- 
a+=';j='+navigator.javaEnabled() 
js=11//--></script><script language="JavaScript1.2"><!-- 
s=screen;a+=';s='+s.width+'*'+s.height 
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth) 
js=12//--></script><script language="JavaScript1.3"><!-- 
js=13//--></script><script language="JavaScript"><!-- 
d.write('<a href="http://top.list.ru/jump?from=87856"'+ 
' target=_top><img src="http://top.list.ru/counter'+ 
'?id=87856;t=54;js='+js+a+';rand='+Math.random()+ 
'" alt="TopList"'+' border=0 height=31 width=88></a>') 
if(js>11)d.write('<'+'!-- ')//--></script><noscript><a 
target=_top href="http://top.list.ru/jump?from=87856"><img 
src="http://top.list.ru/counter?js=na;id=87856;t=54" 
border=0 height=31 width=88 
alt="TopList"></a></noscript><script language="JavaScript"><!-- 
if(js>11)d.write('--'+'>')//--></script> 
 
<br><br> 

</BODY></HTML>
