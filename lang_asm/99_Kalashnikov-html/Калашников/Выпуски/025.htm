<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<title>Калашников.ru - Ассемблер? Это просто!.. (Выпуск № 025)</title>
<STYLE>
<!-- a:link, a:visited, a:active { text-decoration: none; color: #226622} 
a:hover { text-decoration: bold; color: #662266; } 
 .ff { 
font-family : Arial, helvetica, sans-serif; 
font-style : normal; 
font-variant : normal; 
} -->
</STYLE>
</head>

<body bgcolor="#CFE7E7" body>
<div align="center"><center>

<p align="center"><a
href="http://ad.ir.ru/bb.cgi?cmd=go&amp;pubid=128269&amp;pg=1&amp;vbn=10001&amp;nocache=9460"
target="_top"><img
src="http://ad.ir.ru/bb.cgi?cmd=ad&amp;pubid=128269&amp;pg=1&amp;vbn=10001&amp;nocache=9460"
alt="InterReklama " border="0"></a><br>
<a href="http://www.ir.ru" target="_top"><font size="1">InterReklama
Advertising</font></a> <!-- BannerBank.  ИнтерРеклама --> </p>

<hr noshade>

<table border="1" cellpadding="0" cellspacing="0" width="100%"
bgcolor="#CDCD9C">
<tr>
<td colspan="3" width="100%"><p align="center"><font color="#004080" size="5">
<em><strong>Ассемблер? Это просто! Учимся программировать</strong></em></font>
<font color="#000000" size="2"><br>
______________________________________</font></p>
<p align="center"><font size="4">Выпуск N 025 (<a href="#shell">Оболочка</a>)</font></p>
</td>
</tr>
</table>
</center></div>

<p align="right"><font color="#008000" size="3"><em>
Я пiду до рiченкi стрiчати зiрочки,<br>
Зазiраць як падаюць, ловити iх жменями.<br>
Забiрусь на райдуго, взлечу по-пiд хмарами.<br>
Перадам по радiо: &quot;Прощай рiдна Бацьковщино!&quot;<br>
</font><font color="#800000" size="3">
Весна, весна, весна прийде,<br>
Весна, весна, весна вгамуе...</em></font></p>

<p align="center"><font color="#004080" size="5"><strong><u>Здравствуйте,
уважаемые подписчики!</p>

<p align="center"><em>Долгожданная весна наступила! УРА!</u></strong></em></font></p>

<p align="left"><font color="#000000" size="4"><strong>
Сегодня в номере:</strong></font></p>

<dir type="disc">
<li><p align="left"><a href="#business">Командировка. Иные вопросы</a></p>
</li>
<li><p align="left"><a href="#Coproc">Основы работы с сопроцессором</a></p>
</li>
<li><p align="left"><a href="#shell">Оболочка. Вывод десятичных чисел. Длинные имена файлов</a></p>
</li>
</dir>

<hr>

<br>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#9CCDCD">
<tr>
<td align="center" width="100%"><a name="business">
<font color="#004080" size="5"><strong>Командировка</a>. Прочие вопросы</strong></font>
</td>
</tr>
</table>
</center></div>

<div align="left">
<p><font size="3">Уважаемые подписчики! У нас был небольшой перерыв в связи с тем, что мне пришлось съездить в Санкт-Петербург в 
командировку почти на целую неделю, о чем я написал на сайте. У меня просто не было времени напечатать рассылку. Я искренне извиняюсь за такое 
долгое молчание.</p>

<p>Ну а что можно сказать о Питере? Это красивый город, который отличается своей архитектурой. Впечатляют размеры разводных мостов (кстати, 
зимой не разводятся). Запомнились станции метро, в которых двери открываются не только в поездах, но и на самих станциях. Ощущения, скажу 
вам, немного жутковатые. Словно в бункер какой-то попадаю, особенно, когда много народу...</p>

<p>Побывал в классном ночном клубе &quot;Сахара&quot;. К сожалению, адрес так и не запомнил. Однако, рекомендую всем туристам!</p>

<p align="center">_________</p>

<p>Ко мне пришло много писем, в которых вы просили выслать файлы-приложения. Но т.к. я 
не имел возможности получить почту, то высылка файлов также была с большой задержкой...</p>

<p>Кстати, о файлах-приложениях. Почему получается так, что вы скачиваете все выпуски рассылки, но без 
файлов-приложений? В высылаемом архиве, а также в архиве на сайте эти файлы присутствуют. Неужели вы качаете выпуски по одному? Ведь 
проще получить архив целиком.</p>

<p>Выпуски вынесены для того, чтобы новые посетители смогли ознакомиться с любым номером (не перекачивая весь архив) 
и решить для себя: стоит ли подписываться на рассылку или нет. Вот, собственно, и все!</p>

<p align="center">_________</p>

<p>Наши экспертные группы начинают хорошо работать. Приходит большое количество вопросов. Эксперты справляются с 
поставленной задачей. В следующем выпуске я напишу подробней о наших экспертах, посчитаю количество 
отвеченных вопросов, грамотность ответов и опубликую лидеров в рассылке.</p>

<p align="center">_________</p>

<p>Я теперь разместил на сайте полный дистрибутив MASM 6.12. Если вы еще не запаслись им, то - 
качайте! На сайте теперь также найти TurboDebugger 5.0, Multi-Editor 8.0 и многое другое. Пользуйтесь!!!</p>

<p align="center">_________</p>

<p>В предыдущих выпусках я писал про уникальный сайт Эдуарда Дмитриева &quot;Библиотека программиста&quot; 
(<a href="http://prog.agava.ru">http://prog.agava.ru</a>), где можно найти много полезной информации по 
программированию на различных языках. К сожалению, я поспешил немного. Т.к. у AGAVA были проблемы, то вся информация потерялась. В 
результате, многие, обратившиеся на данный сайт, не нашли там того, что искали. Теперь ситуация более-менее 
исправлена. Заходите! Это действительно неплохая вещь! А я пока с Эдуардом подумаю по поводу объединения наших рассылок...</font></p>
</div>

<hr>

<p><font color="#000000" size="2"><br>
</font></p>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="100%"
bgcolor="#9CCDCD">
    <tr>
        <td align="center" width="100%"><a name="Coproc"><font
        color="#004080" size="5"><strong>Основы
        работы с сопроцессором</strong></font></a></td>
    </tr>
</table>
</center></div>

<p align="left"><font size="3">Итак, уважаемые
мои подписчики, пришло время
разобрать работу сопроцессора.</font></p>

<p align="center"><font size="4"><strong>FAQ по
сопроцессору, придуманный мной
лично.</strong></font></p>

<p align="left"><strong>Что такое сопроцессор?</strong>
<br>
Сопроцессор (FPU - Floating Point Unit - устройство для работы с плавающей точкой) -
это, как понятно из перевода, специальное устройство,
устанавливающееся либо на
материнскую плату, либо
встраиваемое внутрь основного
процессора (располагающееся на одном кристалле с ним).</p>

<p align="left"><strong>Для чего нужен сопроцессор?</strong>
<br>
Сопроцессор служит для
выполнения арифметических
операций (сложение, вычитание,
умножение, деление, вычисление
квадратного корня и пр.) с плавающей
точкой. Обычно для выполнения
простых операций с <u>целыми</u> числами
используется основной процессор,
однако, иногда можно прибегать к
помощи сопроцессора. Сразу
подчеркну, что арифметические
операции с <u>целыми</u> числами с помощью
сопроцессора выполняются
медленней, чем основным
процессором.</p>

<p align="left"><strong>&quot;Есть ли в моем компьютере сопроцессор?&quot;</strong>
<br>
В старых машинах сопроцессор
устанавливался на материнскую
плату как отдельное устройство.
Начиная с 80486DX сопроцессор
встраивается внутрь основного
процессора. Смею вас уверить, что
если на вашем столе стоит 80486DX-40 или
(на худой конец!) Pentium, то
сопроцессор в нем присутствует.</p>

<p align="left">Наличие сопроцессора в
машине с некоторой уверенностью
можно было определить из названия
(типа) (386<strong>SX</strong> - сопроцессор
отсутствует, 386<strong>DX</strong> -
сопроцессор присутствует.
Аналогичная ситуация и с
&quot;четверками&quot;). Хотя были
&quot;умельцы&quot;, которые умудрялись
выпаивать (!) сопроцессоры из машин
класса DX! Наверное, ценились они
раньше... Я имею в виду сопроцессоры...</p>

<p align="left">Во всех Pentium'ах, как я уже
сказал, сопроцессор <u>обязательно</u>
присутствует. В любом случае, всегда можно
программным путем проверить
наличие сопроцессора в машине.</p>

<p align="left"><strong>А как вообще узнать,
использует ли сопроцессор та или
иная программа во время работы?</strong>
<br>
В принципе, большинству
программ не требуется помощь
сопроцессора. Они просто не
производят сложные математические
расчеты. Однако я встречал даже
антивирусы, которые требовали
наличие FPU! Что там чрезвычайно
сложное считали они - не совсем
понятно...</p>

<p align="left">Программы можно условно разделить на следующие типы:</p>

<p align="left">1. Не использующие сопроцессор;</p>

<p align="left">2. Использующие
сопроцессор. При его отсутствии
выводят соответствующее сообщение
на экран и завершаются;</p>

<p align="left">3. Использующие
сопроцессор, но при его отсутствии
обходятся командами центрального
процессора. Причем скорость работы
в таком случае существенно
замедляется относительно того,
если бы сопроцессор присутствовал.
Наличие сопроцессора проверяется программой 
сразу после ее загрузки.</p>

<p align="left">Определить, использует ли
та или иная программа команды FPU
возможно только одним способом:
дизассемблировать ее и поискать
команды сопроцессора (либо сделать
это в процессе отладки).</p>

<p align="left"><strong>&quot;А если мне нужно
произвести сложные математические
расчеты, могу ли я не использовать
сопроцессор вообще, а обойтись
инструкциями центрального
процессора?&quot;</strong>
<br>
В принципе, да. Но это будет
о-о-очень сложно и довольно-таки
медленно...</p>

<p align="left"><strong>Сложно ли программировать сопроцессор на Ассемблере?</strong>
<br>
Да, в общем-то, нет. Главное - навык...</p>

<p align="left">P.S. Вдумайтесь в фразу:
&quot;Да, в общем-то, нет&quot;. Все-таки русский язык - самый гибкий...</p>

<p align="left"><strong>&quot;А почему мы начали
рассматривать сопроцессор в данном
выпуске? Что, наша оболочка будет
работать только с ним?&quot;</strong>
<br>
Да.
<br>
<strong>&quot;А зачем? Можно ведь обойтись без него.&quot;</strong>
<br>
Во-первых, мы должны изучить
не поверхности программирования на
Ассемблере, а затронуть по
возможности все области. В том
числе и сопроцессор.</p>

<p align="left">Во-вторых, наши программы
носят сугубо обучающий характер.
Пройдя полный курс
программирования на Ассемблере, вы
сможете написать свою собственную
программу так, как вам этого
хочется.</p>

<p align="left">В-третьих, то, что мы делаем с помощью сопроцессора, сложно
реализовать без него.</p>

<p align="left"><strong>&quot;А что мы делаем с сопроцессором?&quot;</strong>
<br>
Мы будем выводить целые десятичные числа на экран.
Например, размеры файлов. Это, скажу вам, гораздо проще, чем
использовать только процессор.</p>

<p align="left"><strong>&quot;А что, в Ассемблере
очень сложно вывести десятичное
число на экран? В Бейсике, например,
достаточно набрать PRINT 25*4 и мы
увидим результат умножения...&quot;</strong>
<br>
На Ассемблере очень просто вывести на экран шестнадцатеричные
и двоичные числа, но никак не десятичные. Поэтому только в 25
выпуске мы затрагиваем данную тему, так как вы должны уже неплохо
разбираться в командах Ассемблера и понимать принцип
программирования на этом мощном и очень простом языке.</p>

<p align="left"><strong>Сильно ли отличаются
ассемблерные команды сопроцессора и принцип его работы от
программирования процессора?</strong>
<br>
Да, довольно-таки сильно. Сегодня вы сами
лично &quot;нащупаете&quot; эту маленькую микросхемку. По крайней
мере, увидите, как она работает...</p>

<p align="left"><strong>&quot;А если я ничего не пойму?&quot;</strong>
<br>
Не отчаивайтесь! Все станет понятно со временем. Вспомните, у
вас, вероятно, были трудности с тем или иным оператором, процедурой. Но
в процессе экспериментов все стало на свои места. Так и здесь. Если вы
сразу поймете все, что написано в данном выпуске, то, можно сказать,
что я добился того, чего хотел. Если нет - экспериментируйте,
спрашивайте. Эту тему <u>желательно</u> усвоить ВСЕМ!</p>

<p align="center">___________</p>

<p align="left"><strong>Итак, приступим.</strong></p>

<p align="left">Прежде всего стоит отметить, что для того, чтобы
использовать инструкции сопроцессора, необходимо включить
в начале программы директиву .8087 (.287, .387). Т.е. указать, команды какого
сопроцессора мы будем использовать. Принцип такой же, как
и при указании процессора: либо только 8086 (.8086), либо 8086 и 80286 (.286) и
т.д. Вот пример включения директивы, которая указывает
программе-ассемблеру (MASM / TASM) инструкции какого сопроцессора будут использоваться:</p>

<p align="left">.386 <em>- не забывайте указывать процессор, 
если вы собираетесь использовать команды не только 8086!</em><br>
.287 <em>- будем использовать команды не только 386 процессора, но и 8087, а
также 80287 сопроцессоров.</em></p>

<p align="left">В некоторых случаях TASM может выдавать
сообщение при попытке ассемблирования программы,
начинающейся с указанных выше строк. Что-то типа: &quot;Внимание:
Вы используете команды 386 процессора и 287 сопроцессора!&quot; 
Зачем нужно было это делать - ума не приложу! Программист может использовать,
например, команды 486 процессора, а также 8087 сопроцессора. Ничего
страшного в этом нет и быть не может! В любом случае просто
игнорируйте это сообщение.</p>

<p align="center">_________</p>

<p align="left">В распоряжении сопроцессора имеется набор нескольких инструкций
и 8 регистров (я бы даже сказал, 8 ячеек памяти). Принцип загрузки числа в
тот или иной регистр похож на принцип работы стека. Как так? Да
очень просто! Ниже будем много тренироваться. Пока только теория.</p>

<p align="left">Регистры имеют следующие названия: ST(0), ST(1), ST(2) ... ST(7).
Иногда для краткости ST(0) называют просто ST. Загрузить в любой из указанных
регистров число командой MOV не получится. Для этого существуют
специальные команды сопроцессора.</p>

<p align="left">Хорошим тоном перед использованием сопроцессора
является его инициализация командой FINIT. Вообще, все команды
сопроцессора начинаются с символа F, что является их отличительной чертой.</p>

<p align="left">Инструкция FINIT инициализирует сопроцессор. При
этом сбрасываются все регистры, биты, флаги, а также
очищаются 8 регистров ST. Т.о. после инициализации сопроцессора программист
может быть уверен в том, что никакой регистр не занят и не получится
&quot;каши&quot; или переполнения стека (регистров) при попытке выполнить
ту или иную операцию.</p>

<p align="left">Сопроцессор может работать с 16 - 80 разрядными числами.
Следовательно, в регистры ST(0) - ST(7) можно загружать число в указанных
выше пределах. Сопроцессор сам определит, 16-разрядное ли это число
или 64-х разрядное.</p>

<p align="left">Все числа из переменных загружаются в регистр сопроцессора
ST(0) и выгружаются из него в обычные переменные. Регистр ST(0) является,
скажем так, главным. Только в него можно загружать числа из
переменных и выгружать в переменные.</p>

<p align="left">Например. Возьмем команду FILD, которая загружает в регистр ST(0)
число из переменной в памяти:</p>

<p align="left">FILD Number1</p>

<p align="left">...</p>

<p align="left">Number1 dw 10</p>

<p align="left">Как видите, здесь мы указываем только имя переменной,
значение которой будет загружено в регистр ST(0) и только в него (как уже
упоминалось).</p>

<p align="left">Допустим, нам нужно сложить два целых числа, используя
сопроцессор. Для этого мы загружаем в ST(0) число 10. Затем загружаем
второе число - 3 (для сложения ведь нужно как минимум два числа):</p>

<p align="left">(1) FILD Number1<br>
(2) FILD Number2</p>
<p align="left">...</p>
<p align="left">Number1 dw 10<br>
Number2 dw 3</p>

<p align="left"><strong>Теперь внимание!</strong> После выполнения
строки (1) ST(0) будет содержать число 10. После выполнения строки (2) число
из ST(0) переместится в регистр ST(1), а его место в ST(0) займет число 3. Т.е.
система похожа на работу стека! Далее нужно сложить числа, которые
находятся в ST и ST(1). Вот так:</p>

<p align="left">FADD</p>

<p align="left">Команда FADD без параметров складывает два
числа, которые находятся в регистрах ST(0) и ST(1), при этом очищая
ST(1) и помещая результат сложения в ST(0).</p>

<p align="left">Рассмотрим, что происходит в регистрах в
процессе выполнения данных команд. Итак, пока никаких действий мы не
выполняли:</p>

<table border="1" cellspacing="1">
    <tr>
        <td><strong>ST(0)</strong></td>
        <td>Пусто</td>
    </tr>
    <tr>
        <td><strong>ST(1)</strong></td>
        <td>Пусто</td>
    </tr>
    <tr>
        <td><strong>ST(2)</strong></td>
        <td>Пусто</td>
    </tr>
    <tr>
        <td>...</td>
        <td>...</td>
    </tr>
    <tr>
        <td><strong>ST(7)</strong></td>
        <td>Пусто</td>
    </tr>
</table>

<p align="left">Заносим первое число в регистр ST командой FILD Number1:</p>

<table border="1" cellspacing="1">
    <tr>
        <td><strong>ST(0)</strong></td>
        <td>10</td>
    </tr>
    <tr>
        <td><strong>ST(1)</strong></td>
        <td>Пусто</td>
    </tr>
    <tr>
        <td><strong>ST(2)</strong></td>
        <td>Пусто</td>
    </tr>
    <tr>
        <td>...</td>
        <td>...</td>
    </tr>
    <tr>
        <td><strong>ST(7)</strong></td>
        <td>Пусто</td>
    </tr>
</table>

<p align="left">Теперь второе число командой FILD Number2:</p>

<table border="1" cellspacing="1">
    <tr>
        <td><strong>ST(0)</strong></td>
        <td>3</td>
    </tr>
    <tr>
        <td><strong>ST(1)</strong></td>
        <td>10</td>
    </tr>
    <tr>
        <td><strong>ST(2)</strong></td>
        <td>Пусто</td>
    </tr>
    <tr>
        <td>...</td>
        <td>...</td>
    </tr>
    <tr>
        <td><strong>ST(7)</strong></td>
        <td>Пусто</td>
    </tr>
</table>

<p align="left">Обратите внимание, что числа как бы вталкиваются внутрь.
Как уже отмечалось, заносить числа в сопроцессор можно только в
регистр ST(0). Поэтому-то второй параметр в команде FILD отсутствует:
и так все понятно...</p>

<p align="left">Теперь складываем оба числа командой FADD:</p>

<table border="1" cellspacing="1">
    <tr>
        <td><strong>ST(0)</strong></td>
        <td>13</td>
    </tr>
    <tr>
        <td><strong>ST(1)</strong></td>
        <td>Пусто</td>
    </tr>
    <tr>
        <td><strong>ST(2)</strong></td>
        <td>Пусто</td>
    </tr>
    <tr>
        <td>...</td>
        <td>...</td>
    </tr>
    <tr>
        <td><strong>ST(7)</strong></td>
        <td>Пусто</td>
    </tr>
</table>

<p align="left">Вот, что получилось!</p>

<p align="left"><strong>Как нам теперь получить результат?</strong></p>

<p align="left">Существует также команда, противоположная FILD:</p>

<p align="left">FIST Result</p>

<p align="left">Эта команда сохранит число, которое находится в регистре
ST(0), в переменную Result.</p>

<p align="left">Ниже приведена короткая программа, которая производит
сложение двух чисел с использованием сопроцессора:</p>

<p align="center"><font size="4"><!--webbot bot="Validation"
b-value-required="TRUE" i-minimum-length="1" i-maximum-length="80" --><textarea name="First_coproc" rows="7"
cols="47">.8087 ;Использовать будем инструкции 8086 процессора и 8087 сопроцессора
CSEG SEGMENT
ASSUME CS:CSEG, DS:CSEG, ES:CSEG, SS:CSEG

ORG 100h
Begin:
	finit  ;Инициализируем сопроцессор
	fild Number1 ;ST(0)=Первое число
	fild Number2 ;ST(1)=ST(0); ST(0)=Второе число
	fadd ;Складываем
	fist Result ;Результат сложения - в переменную Result
ret

Number1 dw 10
Number2 dw 3
Result dw ?

CSEG ENDS
END Begin</textarea></font></p>

<p align="left">Теперь ассемблируйте, запускайте отладчик и смотрите, что
происходит. Полагаю, что многие из вас столкнутся с проблемой: AFD
выводит на экран совсем не то, что мы набрали, а именно: какие-то WAIT, ESC
и пр. Здесь ошибки нет. Просто одна команда сопроцессора на самом деле
преобразуется в выражения вида:</p>

<p align="left">WAIT<br>
ESC ...</p>

<p align="left">Однако, лучше всего отлаживать программу, которая
использует инструкции сопроцессора, в отладчике TurboDebugger.
Если у вас нет этого отладчика, то его можно найти на нашем сайте (версия 5.0).
Я настоятельно рекомендую отлаживать программы и смотреть
результаты выполнения именно в этом отладчике, т.к. он очень удобен
и наглядно отображает все, что вам нужно. Более того, я специально
настроил рабочий стол TD 5.0 так, чтобы вы видели все необходимое (регистры
сопроцессора, результаты вычислений, код программы, дамп памяти).</p>

<p align="left">Если вы посмотрели работу приведенной выше программы в TD, то
читаем дальше...</p>

<p align="left">Вопрос: вот мы сложили два
числа, получили результат, но ведь в ST(0) осталось число 13! Получается,
что нам нужно перед каждой арифметической операцией инициализировать сопроцессор
командой FINIT чтобы очистить регистры от результатов вычислений?
Можно ли как-то убрать это число иным способом? Например, за один раз
(одной командой) перенести его в переменную Result и освободить ST(0)?</p>

<p align="left">Ответ: конечно, можно. Существует ряд команд, облегчающий
работу с сопроцессором. Изучить все в одной рассылке невозможно. В
данном выпуске мы рассмотрим определенное количество команд,
используя которые вы уже сможете выполнять многие операции.</p>

<p align="left">Как правило, мнемоника команд сопроцессора имеет
определенную систему, подобную мнемоникам команд процессора, а
именно: команды представляют из себя сокращения английских слов
(например, известная вам инструкция XCHG - eXCHanGe - обменять). Вот пример:</p>

<ul>
<li><p align="left">FILD - Integer LoaD - загрузка
целого числа (в регистр сопроцессора)</p>
</li>
<li><p align="left">FADD - ADDition - сложение</p>
</li>
<li><p align="left">FIST - Integer STore -
сохранение целого числа (в переменную в памяти)</p>
</li>
<li><p align="left">FISTP - Integer STore and Pop -
сохранение целого числа и выталкивание его из ST(0)</p>
</li>
</ul>

<p align="left">Если мы заменим</p>

<p align="left">FIST Result</p>

<p align="left">на</p>

<p align="left">FISTP Result</p>

<p align="left">из приведенной выше программы, то в ST(0) ничего не останется. 
Думаю, что это достаточно удобно. Советую поэкспериментировать с этим...</p>

<p align="center">________</p>

<p align="left">Прежде, чем пойдем дальше, я хотел бы сказать еще
несколько слов о работе сопроцессора.</p>

<p align="left">Сопроцессор имеет специальный регистр управления. Он
необходим, в частности, для указания сопроцессору метода
округления действительного числа (вещественного числа, числа с
точкой или еще говорят &quot;числа с плавающей точкой&quot;). Например,
число 23,8 может быть округлено следующим образом (в зависимости от
установленных битов в регистре управления): до 24, либо до 23, либо без
округления вообще. Или, например, если установлен тот или иной бит
определенного регистра, то сопроцессор производит вычисления
с более высокой точностью или с более низкой. Как в некоторых
калькуляторах стоит переключатель разрядности (количества знаков после запятой).</p>

<p align="left">Для чего я это говорю? Дело в том, что мы будем устанавливать
биты регистра управления сопроцессором RC, которые отвечают за округление числа. На практике
все увидите... Позже рассмотрим все подробней.</p>

<p align="center">________</p>

<p align="left">Теперь практикуемся на более сложном примере. Ниже приведена программа, 
которая выводит в центре нулевой строки заданное число в десятичной форме. Все очень просто!
Самое главное, что нужно сделать, - посмотреть эту программу под
отладчиком TD да так, чтобы были видны регистры сопроцессора при отладке.</p>

<p align="left">Ну-с, друзья мои, приступим!!!</p>

<p align="left"><strong>Как вывести десятичное число на экран в Ассемблере?</strong></p>

<p align="left">Возьмем простое число 1234. Естественно, в десятичном формате.</p>

<p align="left">На первый взгляд кажется, что достаточно отделить четверку и
вывести ее на экран, затем 3, дальше - 2 и т.д. Например, используя
известную нам команду AND:</p>

<p align="left">mov AX,1234<br>
and AX,0004 или and ax,0Fh</p>

<p align="left">Либо как-то иным способом. Но проблема в том, что число 1234
будет представлено в шестнадцатеричном формате или (что вернее) в двоичном. Вот, что мы
увидим в отладчике:</p>

<p align="left">mov ax,4D2h<br>
and AX,4</p>

<p align="left">И что же мы получаем в AX? В первом случае (and AX,0004) 
- нуль, а во втором (and ax,0Fh) - 2. Почему? Подумайте хорошо! Ведь мы уже
проходили двоичную и шестнадцатеричную системы счисления, а также логические
команды. Прежде, чем читать дальше, вы должны понять почему так происходит...
Еще раз рекомендую отладчик и калькулятор DN или Win для перевода чисел из
одной системы в другую.
</p>

<p align="left">Как тут не крути, но подобные способы не годятся.</p>

<p align="left">Тогда как? Нужно делить число на десять, записывая остаток
от деления, до тех пор, пока не останется нуль. Вот пример:</p>

<p align="left">1234/10=123 остаток 4<br>
123/10=12 остаток 3<br>
12/10=1 остаток 2<br>
1/10=0 остаток 1</p>

<p align="left">Что получили: 4321. Т.е. 1234 в обратном порядке. Следовательно, и
выводить на экран будем &quot;задом наперед&quot;.</p>

<p align="left">&quot;А можно сразу в &quot;нормальном&quot; порядке выводить?&quot;
Можно, конечно, разделить на 1000, затем на 100, 10... Но ведь числа
бывают разные! Длинные, короткие, средние... Можно даже завести массив из
20-30 байт, в каждый байт которого заносить одну цифру.</p>

<p align="left">Однако, проще всего, как уже отмечалось, делить на десять до тех
пор, пока делимое (т.е. выводимое число, т.е. в нашем примере - 1234) не
будет равно нулю, хоть и придется для этого выводить в обратном порядке.</p>

<p align="left"><em>&quot;Хорошо, тогда как нам разделить число на 10 и
вывести остаток от деления на экран?&quot;</em> Вот это мы и будем
делать с помощью сопроцессора. Подобный алгоритм используется в нашей оболочке
(пока!). Я специально вынес его в отдельный файл, чтобы вам было
удобнее разобраться, что происходит. Сразу отмечу, что более &quot;корявых&quot; алгоритмов уже не
придумаешь. Я имею в виду, что наш алгоритм будет слишком сложный и
замудреный. Зачем я сделал так? Хоть этот алгоритм и далек от
совершенства, но зато он даст вам возможность понять принцип
работы сопроцессора. Для этого (еще раз подчеркну) следует разобрать
приведенную ниже программу в отладчике TurboDebugger или подобном ему.</p>

<p align="left">Видите, сколько разных программ нужно иметь под рукой для
того, чтобы писать на Ассемблере! И это еще не предел! Скоро будем
работать с SoftIce'ом, дизассемблером и пр. Так что, готовьтесь и привыкайте
потихоньку... Зато ваши знания будут несравнимы со знаниями
программистов, работающих с языками высокого уровня. После
того, как вы изучите Ассемблер (если хватит терпения), вы сможете без
особого труда разобраться с любой программой, написанной на языке
высокого уровня. Так или иначе, можно будет ее скомпилировать, а
затем дизассемблировать и посмотреть код. Но это так,
&quot;лирическое отступление&quot;...</p>

<p align="center"><font size="4"><strong>Файл !coproc!.asm</strong></font></p>

<p align="center"><font size="4"><!--webbot bot="Validation"
b-value-required="TRUE" i-minimum-length="1" i-maximum-length="80" --><textarea name="!Coproc!.asm" rows="5"
cols="52">;       !Coproc!.asm - дополнительный файл к рассылке № 025
;              !!! Для просмотра в TurboDebugger'е !!!

.386 ;Будем использовать команды 80386 процессора,
.287 ;А также 287 сопроцессора
CSEG segment use16
assume cs:CSEG, ds:CSEG, es:CSEG, ss:CSEG
org 100h

Start:
    mov ax,3
    int 10h      ;Чистим экран

    mov ah,2
    mov dx,40
    int 10h      ;Установим курсор на середину 0-ой строки

    call Out_dec ;Процедура вывода десятичного числа, которое в Number_dec

    ret   ;Выход в DOS



;=== Вывод десятичного числа на экран с использованием сопроцессора ===
Out_dec proc
    finit        ;Инициализация сопроцессора

;На приведенные ниже строки не обращайте пока внимания!
;-------
    fstcw Dat    ;Получим регистр управления сопроцессором и установим RC
    or Dat,0C00h ;Округление: просто урезаем числа после запятой
    fldcw Dat    ;Загрузим изменения назад в сопроцессор
;-------

;!!! Теперь следим очень внимательно !!!

    fldz            ;Загрузим нуль (LoaD Zero)
    fild Divider    ;Загрузим делитель (10)
    fild Number_dec ;Загрузим делимое (выводимое число)
    fst st(7)       ;Дублируем делимое ST(7)=ST(0) (STore)

Next_sym:
    fprem            ;Делим ST(0) на ST(1) и получаем остаток от деления
    fistp Dat        ;Остаток - в переменную Dat

    call Out_sym     ;Выводим остаток от деления на экран

    fld st(6)        ;ST(0)=ST(6)

    fdiv st,st(1)    ;Делим на 10   ST(0)=ST(0)/ST(1)

    frndint          ;Округляем до целого ST(0) (RouND INTeger)
    fst st(7)        ;Дублируем округленное число

    fcom st(2)       ;ST(0)=ST(2)? (COMpare)
    fstsw ax         ;Получим состояние сопроцессора
    and ax,4500h     ;=100010100000000b - Обнулим ненужные нам биты
    cmp ax,4000h     ;=100000000000000b - Проверим...
    jnz Next_sym     ;Не нуль? Тогда следующую цифру...

Finish_dec:
    ret              ;Число полностью выведено!!! Выходим из процедуры...

 ;64-х разрядная переменная для выводимого числа
Number_dec dq 1234   ;<=== Выводим это число!

 ;В данную переменную можно занести два регистра EAX или
 ;0FFFF:FFFF:FFFF:FFFFh или
 ;16^16 (16 в 16 степени) или
 ;18.446.744.073.709.551.600
 ;Однако, учитывая, что крайний левый бит сигнализирует сопроцессору о знаке
 ;числа (положительное или отрицательное), то вывести приведенное выше число
 ;не удастся. Реально же почти в два раза меньше. Но этого достаточно...


 Divider dw 10    ;Делитель всегда 10
 Dat dw ?         ;Временная переменная
Out_dec endp

;=== Вывод одного символа на экран в текущую позицию курсора ===
Out_sym proc
    push dx  ;DX содержит текущую позицию курсора, которую нужно сохранить
    mov ah,2
    mov dl,byte ptr Dat ;DL=остаток от деления на 10
    add dl,'0'          ;Добавим '0'
    int 21h  ;Выводим остаток от деления
    pop dx

    dec dx   ;Курсор назад , т.к. вывод идет "задом наперед"
    mov ah,2
    int 10h

    ret
Out_sym endp

CSEG ends
end Start</textarea></font></p>

<p align="left">Читайте описания, ассемблируйте, запускайте под отладчиком и... познавайте!</p>

<hr>

<p><br></p>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#9CCDCD">
<tr>
<td align="center" width="100%"><a name="shell">
<font color="#004080" size="5"><strong>Оболочка</strong></font></a></td>
</tr>
</table>
</center></div>

<p align="center"><br></p>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="80%">
<tr>
<td align="center" colspan="2" width="100%">
<font color="#FF0000" size="4"><strong>Sshell25.asm (головной файл)</strong></font>
<br><font size="4">
<!--webbot bot="Validation" b-value-required="TRUE" i-minimum-length="1"
i-maximum-length="80" --><textarea name="Sshell" rows="5" cols="33">;              Sshell25.ASM - программа к рассылке № 025

; (С) Авторские права на файлы-приложения принадлежат подписчикам рассылки
; "Ассемблер? Это просто! Учимся программировать"
; Автор рассылки:
; Калашников Олег Александрович (e-mail: Assembler@Kalashnikoff.ru)
;                 http://www.Kalashnikoff.ru

; --- Ассемблирование (получение *.com файла) ---
;При использовании MASM 6.11 - 6.13:
;ML.EXE Sshell25.asm /AT

;При использовании TASM:
;TASM.EXE Sshell25.asm
;TLINK.EXE Sshell25.obj /t/x

;______________________________________________________

.386 ;Будем использовать регистры и команды 80386 процессора,
.287 ;А также команды 80287 сопроцессора
CSEG segment use16
assume cs:CSEG, ds:CSEG, es:CSEG, ss:CSEG
org 100h

Start:
        jmp Begin

; ======= Процедуры =========
; Головная
include main.asm

; Работа с дисплеем
include display.asm

; Работа с файлами
include files.asm

; Работа с клавиатурой
include keyboard.asm

; Сообщения
include messages.asm

; Переменные
include data.asm

; Начало программы
Begin:
        call Check_video ;проверим видеорежим и текущую страницу

        mov ah,9
        mov dx,offset Mess_about
        int 21h ;выводим сообщение с приветствием

        call Main_proc ;головная процедура

; Выходим в DOS
        int 20h

Finish equ $    ;Это финиш!

CSEG ends
end Start</textarea></font></td>
</tr>
<tr>
<td align="center" width="50%"><br>
<font size="4">Display.asm</font>
<br>
<font size="4"><!--webbot bot="Validation" b-value-required="TRUE"
i-minimum-length="1" i-maximum-length="80" --><textarea name="Display.asm"
rows="5" cols="21">;        ===== DISPLAY.ASM - процедуры работы с экраном ======

; === Рисуем рамку заданного размера в центре экрана ===
Draw_frame proc
     mov bp,sp
     add bp,2

     push es

     push 0B800h
     pop es

;________________________________________
;
; Производим вычисления для того, чтобы
; разместить ЛЮБУЮ рамку в цетре экрана.
;________________________________________

     mov ax,Height_X
     shr al,1
     mov dh,11
     sub dh,al

     mov ax,Width_Y
     shr al,1
     mov dl,39
     sub dl,al
;Теперь DH содержит центрированный ряд (строку),
;а DL - колонку относительно размеров рамки (окошка)...
;_________________________________________

  ;Сохраним полученный адрес, с которого начинается вывод рамки
  ;Нужно для того, чтобы выводить сообщения в рамке.
     mov Num_DX,dx

     mov ax,Other  ;Получим дополнительную информацию
     test al,1     ;Нулевой бит равен 0?
     jz No_copyscr ;Если так, то копировать экран не нужно.

     mov ax,Height_X ;Иначе копируем в область 2 видеостраницы
     add ax,2
     call Copy_scr

No_copyscr:
     call Get_linear
     push di

     mov ax,Attr
     mov al,'г'
     stosw

     mov al,'='
     mov cx,Width_Y
     rep stosw

     mov al,'¬'  ;завершаем верхний ряд
     stosw

     pop di      ;восстановим DI + 160 (следующий ряд)
     add di,160
     inc dh


;теперь у нас примерно такая ситуация на экране:
;г===========================¬
;_
;где _, там у нас DI и DH


     mov cx,Height_X ;CX - кол-во повторов (высота)

Next_lined:
     push cx
     push di

     mov al,'¦'
     stosw

     mov al,32
     mov cx,Width_Y
     rep stosw

     mov al,'¦'
     stosw

     pop di
     add di,160 ;переводим DI на следующий ряд
     inc dh     ;передвигаем DH на 1
     pop cx     ;восстановим счетчик
     loop Next_lined ;следующий ряд...

;теперь у нас примерно такая ситуация на экране:
;г===========================¬
;¦                           ¦
;¦                           ¦
;¦                           ¦
;_ - тут DI и DH


     mov al,'L' ;низ рамки...
     stosw

     mov al,'='
     mov cx,Width_Y
     rep stosw

     mov al,'-'
     stosw

;теперь у нас примерно такая ситуация на экране:
;г===========================¬
;¦                           ¦
;¦                           ¦
;¦                           ¦
;L===========================-


;Выводим сообщение внизу рамки
     mov si,Mess_dn   ;SI = адрес строки для вывода
     call Draw_messfr ;Выводим сообщение ВНИЗУ рамки

;теперь у нас примерно такая ситуация на экране:
;г===========================¬
;¦                           ¦
;¦                           ¦
;¦                           ¦
;L==== Сообщение внизу ======-


;Выводим сообщение вверху рамки
     mov dx,Num_DX
     push dx
     mov si,Mess_up
     call Draw_messfr

;теперь у нас примерно такая ситуация на экране:
;г==== Сообщение вверху =====¬
;¦                           ¦
;¦                           ¦
;¦                           ¦
;L==== Сообщение внизу ======-


     pop dx
     add dx,0101h
     mov si,Mess_ins ;Адрес сообщения, которое будет внутри рамки
     or si,si        ;Если там 0, то не выводим...
     jz No_draw
     mov ah,[si]
     inc si
     call Print_string

;теперь у нас примерно такая ситуация на экране:
;г==== Сообщение вверху =====¬
;¦Сообщение внутри           ¦
;¦                           ¦
;¦                           ¦
;L==== Сообщение внизу ======-


No_draw:
     mov ax,Other ;Получим дополнительную информацию
     test ax,10b
     jz No_upline

     mov dx,Num_dx
     add dh,2
     call Get_linear

     mov ax,Attr
     mov al,'¦'
     mov cx,1
     stosw

     mov cx,Width_Y
     mov al,'-'
     rep stosw

     mov al,'¦'
     stosw

;теперь у нас примерно такая ситуация на экране:
;г==== Сообщение вверху =====¬
;¦Сообщение внутри           ¦
;¦--------- линия -----------¦
;¦                           ¦
;¦                           ¦
;L==== Сообщение внизу ======-


No_upline:
     pop es
     ret 14
Draw_frame endp


; --- Вывод сообщениий вверху и внизу рамки ---
;Вспомогательна процедура.
Draw_messfr proc
     or si,si ;SI = 0?..
     jz No_drawup ;тогда ничего выводить не надо, выходим

     mov ah,[si]
     inc si
     call Count_strmid ;Вычисляем середину строки

     call Print_string ;Выводим строку на экран

No_drawup:
     ret
Draw_messfr endp

; === Вычисляем середину строки ===
;Вход: CS:SI - адрес строки
;Выход: DL - середина адреса для вывода строки
Count_strmid proc
     push es ;Сохраним регистры...
     push di
     push ax

     push cs ;ES=CS
     pop es
     mov di,si ;DI=SI
     xor al,al ;AL=0
     mov cx,0FFFFh ;сколько символов перебирать (возьмем максимум)...
     repne scasb ;Ищем 0 в строке

;SI=начало строки
;DI=конец строки+1
     sub di,si ;DI=DI-SI-1 = длина строки
     dec di

     shr di,1  ;Делим длину на 2
     mov ax,40 ;Делим кол-во символов в строке на 2 = 40
     sub ax,di ;AX=40-половина длины строки = нужная колонка
     mov dl,al ;DL=колонка, с которой следует выводить строку!

     pop ax    ;Восстановим регистры
     pop di
     pop es
     ret
Count_strmid endp

; === Вывод стоки на экран ===
;Вход: DS:SI - адрес строки для вывода
;      DX - координаты для вывода
;      AH - атрибуты строки
;Выход: ничего
Print_string proc
     call Get_linear

Next_symstr:
     lodsb          ;Получаем очередной символ строки
     or al,al       ;Это 0 (конец строки?)
     jz Stop_outstr
     stosw
     jmp short Next_Symstr ;Следующий символ

Stop_outstr:
     ret
Print_string endp

; === Вывод символа на экран ===
;Вход: AL - символ для вывода
;      AH - атрибуты символа
;      DX - координаты для вывода
;Выход: ничего
Print_sym proc
     call Get_linear ;Получаем линейный адрес строки
     stosw           ;Заносим в видеобуфер атрибут (AH) и символ (AL)
     ret
Print_sym endp

; === Преобразование DH:DL в линейный массив ===
Get_linear proc
    push ax    ;сохраним все используемые регистры
    push bx
    push dx

    shl dl,1   ;умножаем DL на 2 (DL=DL*2)...

    mov al,dh  ;в AL - ряд,
    mov bl,160 ;который нужно умножить на 160
    mul bl     ;умножаем: AL(ряд)*160; результат --- в AX

    mov di,ax  ;результат умножения - в DI
    xor dh,dh  ;аннулируем DH
    add di,dx  ;теперь в DI линейный адрес в видеобуфере.

    pop dx     ;восстанавливаем регистры...
    pop bx
    pop ax
    ret
Get_linear endp

; === Проверяем видеорежим монитора и текущую видеостраницу ===
Check_video proc
     mov ah,0Fh
     int 10h
     cmp al,3  ;Текстовый режим?
     je Ok_video

     mov ax,3
     int 10h

Ok_video:
     or bh,bh  ;Нулевая страница?
     jz Ok_page

     mov ax,0500h
     int 10h

Ok_page:
     ret
Check_video endp

; === Сохраним экран ===
Save_mainscr proc
    pusha       ;Сохраним регистры...
    push es
    push ds

    push 0B800h ;с нулевой страницы
    pop ds
    xor si,si

    push 0B900h ;в первую страницу...
    pop es
    xor di,di

    mov cx,2000 ;4000 байт
    rep movsw

    pop ds      ;восстановим регистры.
    pop es
    popa
    ret
Save_mainscr endp

; === Восстановим экран ===
Restore_mainscr proc
    pusha
    push es
    push ds

    push 0B900h ;с первой видеостраницы
    pop ds
    xor si,si

    push 0B800h ;в нулевую...
    pop es
    xor di,di

    mov cx,2000
    rep movsw

    pop ds
    pop es
    popa
    ret
Restore_mainscr endp

; === Копируем часть экрана ===
;Вход: DH - ряд, с которого необходимо начать копирование
;      AL - количество рядов для копирования
;Выход: ничего
Copy_scr proc
    pusha   ;Как обычно сохраним регистры
    push es
    push ds

    xor dl,dl
    call Get_linear

    mov bl,160  ;Получим количество байт, котрые нужно копировать
    mul bl
    mov cx,ax   ;Их - в CX (будем использовать CX как счетчик)

    mov si,di   ;DS:SI - откуда копируем
    xor di,di   ;ES:SI - куда копируем
    mov Num_copySI,si ;Сохраним полученные значения для восстановления
    mov Num_copyDI,di
    mov Num_copyCX,cx
    push 0B800h
    pop ds
    push 0BA00h
    pop es
    rep movsb

    pop ds
    pop es
    popa
    ret

Num_copySI dw ?
Num_copyDI dw ?
Num_copyCX dw ?
Copy_scr endp

; === Восстанавливаем часть экрана ===
;Вход: ничего (все уже сохранено в переменных )
;Выход: ничего
Restore_scr proc
    pusha
    push es
    push ds

    mov di,Num_copySI ;Получим сохраненные процедурой Copy_scr значения
    mov si,Num_copyDI
    mov cx,Num_copyCX
    push 0BA00h
    pop ds
    push 0B800h
    pop es
    rep movsb  ;Копируем со 2-ой страницы в 0-ую...

    pop ds
    pop es
    popa
    ret
Restore_scr endp

; === Прячем курсор, сохранив предварительно его текущую позицию ===
Hide_cursor proc
    mov ah,3          ;получаем текущую позицию курсора
    mov bh,Video_page
    int 10h
    mov Pos_cursor,dx ;теперь она в DX (отсчет с нуля!)

    mov ah,2  ;Установим курсор на первую страницу как на нулевой
    mov bh,1
    int 10h

    mov bh,Video_page ;прячем курсор на 0-ой видеостранице
    mov dx,1900h
    int 10h

    ret
Hide_cursor endp

; === Восстановим курсор ===
Restore_cursor proc
    mov ah,2
    mov bh,Video_page ;видеостраница
    mov dx,Pos_cursor ;сохраненная позиция
    int 10h           ;установим (позиционируем) курсор
    ret
Restore_cursor endp

; === Вывод десятичных чисел на экран (сопроцессор) ===
;Вход: Number_dec - 64-х битное число для вывода
;      DX - адрес для вывода
;      AH - атрибуты для вывода
;Выход: ничего
Out_dec proc
    pusha       ;Сохраним все регистры
    push es
    push 0B800h ;ES установим на сегмент дисплея (для вывода чисел)
    pop es

    xor cx,cx   ;CX - счетчик для точек (см. ниже )

    finit       ;Инициализация сопроцессора
;Состояние регистров сопроцессора после выполнения привденной выше команды
;(Empty - пусто, Zero - нуль, Valid - некоторое число):

;Empty ST(0)
;Empty ST(1)
;Empty ST(2)
;Empty ST(3)
;Empty ST(4)
;Empty ST(5)
;Empty ST(6)
;Empty ST(7)

;Проведем необходимую настройку сопроцессора для округления чисел...
    fstcw Dat    ;Получим регистр управления процессором и установим RC
    or Dat,0C00h ;= or Dat,0000110000000000b
    fldcw Dat    ;Загрузим измененный регистр в сопроцессор

    fldz         ;Загрузим нуль (для проверки) (LoaD Zero)
; Zero ST(0) 0
;Empty ST(1)
;Empty ST(2)
;Empty ST(3)
;Empty ST(4)
;Empty ST(5)
;Empty ST(6)
;Empty ST(7)

    fild Divider ;Загрузим делитель (т.е. число 10)
;Valid ST(0) 10
; Zero ST(1) 0
;Empty ST(2)
;Empty ST(3)
;Empty ST(4)
;Empty ST(5)
;Empty ST(6)
;Empty ST(7)

    fild Number_dec ;Загрузим делимое (выводимое число)
;Valid ST(0) 256   - допустим, размер файла = 256 байт
;Valid ST(1) 10
; Zero ST(2) 0
;Empty ST(3)
;Empty ST(4)
;Empty ST(5)
;Empty ST(6)
;Empty ST(7)

    fst st(7)       ;Дублируем делимое ( ST(7)=ST(0) )
;Valid ST(0) 256
;Valid ST(1) 10
; Zero ST(2) 0
;Empty ST(3)
;Empty ST(4)
;Empty ST(5)
;Empty ST(6)
;Valid ST(7) 256

Next_sym:
    fprem            ;Делим и получаем остаток от деления в ST(0)
;Valid ST(0) 6       - первый раз 256/10=25 и 6 в остатке (видим это в ST(0))
;Valid ST(1) 10
; Zero ST(2) 0
;Empty ST(3)
;Empty ST(4)
;Empty ST(5)
;Empty ST(6)
;Valid ST(7) 256

    fistp Dat        ;Остаток - в переменную Dat ( Dat=ST(0) )
;Valid ST(0) 10       - Dat=6. Стек "подтянулся" вверх, т.к. fistP, т.е.
; Zero ST(1) 0          загрузить в переменную число из ST(0) с
;Empty ST(2)            выталкиванием его из регистра сопроцессора
;Empty ST(3)
;Empty ST(4)
;Empty ST(5)
;Valid ST(6) 256     ;Обращаем также внимание, что 256 "подтянулось" вверх
;Empty ST(7)


;Выводим остаток от деления, который загружен в Dat.
    mov al,byte ptr Dat
    add al,'0'      ;Выводим "нормальную" цифру (остаток от деления на 10)
    call Print_sym
    dec dx          ;Вывели. DX=DX-1 - следующий символ

;Подготовимся к выводу следующего символа...
    fld st(6)       ;ST(0)=ST(6)
;Valid ST(0) 256     - Стек "протолкнулся" вниз
;Valid ST(1) 10
; Zero ST(2) 0
;Empty ST(3)
;Empty ST(4)
;Empty ST(5)
;Empty ST(6)
;Valid ST(7) 256

    fdiv st,st(1)   ;Теперь делим ST(0) на ST(1)
;Valid ST(0) 25.6    - разделили 256 на 10. Результат - в ST(0)
;Valid ST(1) 10
; Zero ST(2) 0
;Empty ST(3)
;Empty ST(4)
;Empty ST(5)
;Empty ST(6)
;Valid ST(7) 256

    frndint         ;Округлим полученное число
;Valid ST(0) 25      - !!!обратите внимание на округление!!!
;Valid ST(1) 10
; Zero ST(2) 0
;Empty ST(3)
;Empty ST(4)
;Empty ST(5)
;Empty ST(6)
;Valid ST(7) 256

    fst st(7)       ;ST(7)=ST(0). Предыдущее число в ST(7) затирается.
;Valid ST(0) 25
;Valid ST(1) 10
; Zero ST(2) 0
;Empty ST(3)
;Empty ST(4)
;Empty ST(5)
;Empty ST(6)
;Valid ST(7) 25

;Теперь проверим, равно ли делимое нулю.
;Проверку будем осуществлять путем сравнения ST(0) с ST(2). Для этого мы,
;собственно, и заносили в самом начале нуль.
    push ax
    fcom st(2)      ;ST(0)=ST(2)?
    fstsw ax        ;AX=состояние сопроцессора
    and ax,100010100000000b ;Аннулируем ненужные нам биты
    cmp ax,100000000000000b ;ST(0)=ST(2)?
    pop ax
    je Finish_dec           ;Если равно, то на выход 
;Если не равно, то в ST(0) будет вместо 256 число 25, затем 2, затем 0...
;Более подробно смотрите прилагаемый файл !Coproc!.asm в TurboDebugger'e

;Точкой будем отделять три цифры для удобства. Пример: 1.568
;Для этого мы и заводим счетчик (CX), который и будет считать количество
;выведенных цифр. Если три уже вывели, и делимое не равно 0, то ставим точку.
    inc cx          ;Увеличим счетчик точек
    cmp cx,3        ;Три цифры выведено?
    jne Next_sym    ;Пока нет. Следующая цифра 

    mov al,'.'      ;Выводим разделитель разрядов (точку)
    call Print_sym
    dec dx          ;DX на один меньше.
    xor cx,cx       ;Обнулим счетчик
    jmp short Next_sym ;Следующая цифра 

Finish_dec:
    pop es
    popa
    ret

 Number_dec dq ?  ;64-х разрядная переменная для выводимого числа
 Divider dw 10    ;Делитель всегда 10
 Dat dw ?         ;Временная переменная для хранения остатка от деления на 10
Out_dec endp</textarea></font></td>

<td align="center" width="50%"><br><font size="4">Files.asm</font>
<br><font size="4"><!--webbot bot="Validation" b-value-required="TRUE"
  i-minimum-length="1" i-maximum-length="80" --><textarea name="Files.asm"
rows="5" cols="21">; ==== FILES.ASM - процедуры работы с файлами ====

; === Читаем файлы в текущем каталоге ===
Get_files proc
      push es
      mov es,Seg_files

      call Get_first  ;Получаем первый файл
      jc No_morefiles ;Если нет файлов вообще - на выход

      cmp word ptr es:[2Ch],002Eh ;Первый файл - '.'?
      je Next_file    ;Если так, то ищем следующий файл...

      call Move_file  ;Если нет, то переносим файл в память.

Next_file:
      call Get_other  ;Получаем следующий файл...
      jc No_morefiles ;Файлы закончились - на выход.

      call Move_file  ;Если нет, то переносим файл в память.
      jmp short Next_file ;Ищем следующий файл...

No_morefiles:
      pop es
      ret

All_files db '*.*',0
;DTA equ 80h <--- он нам больше не нужен!
Seg_files dw ? ;Сегментный адрес буфера файлов
Current_offset dw 500
Get_files endp

; === Поиск первого файла в текущем каталоге ===
Get_first proc
;Здесь можно поставить инструкцию int 3 и в процессе отладки позволить
;отладчику выполнить программу до конца (Run). Дойдя до int 3 отладчик
;обязательно остановится, что позволит вам проанализировать работу
;приведенных ниже строк. Попробуйте!

;     int 3        ;<=== Как точка останова для отладчика (BreakPoint)

      mov ax,714Eh ;Функция поиска первого файла
      xor di,di ;DI должен указывать на буфер, куда будут записываться
      xor si,si ;данные о найденном файле (типа DTA). SI пока остается тайной!
      mov cx,0FFh ;Ищем все возможные файлы. Это что-то вроде атрибутов файла
      mov dx,offset All_files ;Маска поиска
      int 21h
      mov Handle,ax ;Сохраним номер процесса поиска файлов для 714Fh
      ret
Get_first endp

; === Поиск следующих файлов ===
Get_other proc
      mov bx,Handle ;Указываем номер процесса.
      mov ax,714Fh  ;Функция поиска следующих файлов
      xor si,si
      xor di,di     ;DI должен указывать на буфер, куда будут записываться
      int 21h       ;данные о найденном файле (типа DTA).
      ret
Get_other endp

; --- Перенос имени найденного файла в сегмент файлов нашей программы ---
Move_file proc
;Рекомендую здесь также установить точку останова, как показано выше 
      push ds
      mov di,Current_offset ;Текущее свободное смещение
      mov ds,Seg_files
      mov si,2Ch     ;SI=имя найденного файла

Next_fbyte:
      lodsb          ;Получаем первый символ имени файла
      stosb          ;Сохраним символ в памяти
      or al,al       ;Это нуль (конец имени)?
      jnz Next_fbyte ;Следующий символ...

;Заносим размер файла
      mov si,1Ch     ;По этому смещению будет размер файла (4 слова)
      lodsd
      stosd
      lodsd
      stosd

      pop ds
      mov Current_offset,di ;Сохраним текущее смещение
      xor al,al
      stosb          ;Запишем еще один нуль...
      ret

;Итак, в буфер, на который указывает DI перед вызовом
;714Eh и 714Fh, заносятся:
;* По смещению 2Ch - имя найденного файла
;* По смещению 1Ch - размер файла (4 слова = 8 байт)
;* А также многое другое. Рассмотрим позже...
Move_file endp

; === Вывод наденных файлов на экран ===
Out_files proc
      mov bl,Number_files  ;BL указывает на количество выводимых файлов
      push ds
      push es
      push 0B800h
      pop es

      mov si,Start_file ;SI = начальную позицию при выводе на экран
      mov ah,1Bh        ;Атрибуты
      mov dx,0302h      ;Начало для вывода файлов
      mov ds,Seg_files  ;DS=сегмент найденных файлов в памяти

Next_fileout:
      call Print_string ;Выводим очередной файл

      call Print_fsize

      add si,8
      cmp byte ptr [si],0 ;Следующий байт=0? Значит, это был последный файл...
      jz Exit_files       ;Тогда выходим.

      add dx,0100h ;Иначе увеличиваем DH на 1 для вывода следующего имени...
      dec bl       ;Уменьшаем количество выводимых файлов на 1
      jnz short Next_fileout ;Уже 0? Тогда больше выводить не нужно...

Exit_files:
      pop es
      pop ds
      ret

Number_files db 21 ;Количество выводимых файлов на экран.
Start_file dw 500  ;Адрес (смещение) стартового файла для вывода на экран
                   ;Первые 500 байт отводятся для функций 714Eh и 714Fh, куда
                   ;они будут помещать информацию о найденном файле.
                   ;Что-то вроде DTA, только "посовременней"...
Out_files endp

; === Выводим размер файла ===
Print_fsize proc
      pusha
      push ds

      mov eax,ds:[si]   ;Получим первую часть размера файла
      mov ebx,ds:[si+4] ;Получим вторую часть

      push cs
      pop ds

;Обратите внимание, что переменная Number_dec - 64-х разрядная, а регистр
;EAX - 32-х. Для того, чтобы загрузить переменную полностью понадобится
;два раза занести EAX (или EBX и т.п.)!
      mov si,offset Number_dec ;Занесем размер файла в переменную Number_dec
      mov dword ptr [si],ebx   ;Процедура Out_dec будет выводить число,
      mov dword ptr [si+4],eax ;которое находится именно в этой переменной.

      mov dl,50        ;DL указывает на колонку
      mov ah,1Bh       ;AH содержит атрибуты для выводимого числа
      call Out_dec     ;Выводим число

      pop ds
      popa
      ret
Print_fsize endp</textarea></font></td>
</tr>
<tr>
<td align="center" width="50%">
<br><font size="4">Keyboard.asm</font>
<br>
<font size="4"><!--webbot bot="Validation" b-value-required="TRUE"
i-minimum-length="1" i-maximum-length="80" --><textarea name="Sshell" rows="5"
cols="21">; ==== KEYBOARD.ASM - процедуры работы с клавиатурой ====

;  === Ждем нажатия клавиши ===
Pause proc
      mov ah,10h
      int 16h
      ret
Pause endp</textarea></font></td>
<td align="center" width="50%"><br>
<font size="4">Main.asm</font>
<br><font size="4"><!--webbot bot="Validation" b-value-required="TRUE"
  i-minimum-length="1" i-maximum-length="80" --><textarea name="Main" rows="5"
cols="21">;                  === MAIN.ASM - Головная процедура ===

Main_proc proc

      call Hide_cursor ;прячем курсор

      call Prepare_all

      call Save_mainscr ;сохраним содержимое экрана...

      push 23     ;высота рамки без 'г=¬' и 'L=-'
      push 78     ;ширина рамки (т.е. на весь экран) без '¦' и '¦'
      push 1F00h  ;цвет - светло-белый на синем фоне
      push offset Mess_head ;надпись вверху рамки (если 0, то не выводить)
      push offset Mess_down ;надпись внизу рамки (если 0, то не выводить)
      push 0      ;сообщение внутри рамки (если 0, то не выводить)
      push 10b    ;Экран не копировать, но вывести верхнюю линию.
      call Draw_frame ;Рисуем рамку на весь экран
;ИТОГО: в стек заносим 14 байт вместо 20!

      call Get_files

      call Out_files

Next_key:
      call Pause ;давим кнопку!!!
      or al,al
      jz Ext_code  ;Это расширенный ASCII-код клавиши? Да - проверяем его. &#25;

      cmp al,27    ;Нажали ESC?
      jne Next_key ;Нет - ждем дальше... &#24;

      call Quit_prog ;Удостоверимся у пользователя о выходе из программы. &#25;
      jnc Next_key   ;Пользователь подтвердил выход? НЕТ? Тогда на Next_key &#24;

;Да, подтвердил (а жаль!). Тогда выходим.
      call Restore_mainscr ;восстановим содержимое экрана
      call Restore_cursor  ;восстановим позицию курсор

      ret ;выход!

Ext_code:
      cmp ah,62h         ;Нажали Ctrl+F5?
      je User_screenl    ;Да - показываем экран пользователю &#25;.
      jmp short Next_key ;Нет - ждем другую клавишу &#24;

User_screenl:
      mov ax,0501h ;Показываем пользователю 1 видеостраницу.
      int 10h
      call Pause   ;Может быть, подождем?.. Клавишу, а не мою маму!

      mov ax,0500h ;Опять на нулевую устанавливаем.
      int 10h
      jmp short Next_key ;Ждем дальше... &#24;
Main_proc endp

; === Готовим все необходимое для работы ===
Prepare_all proc
      call Set_DTA
      call Prepare_memory

      ret
Prepare_all endp

;--- Ужимаем память ---
Prepare_memory proc
      mov bx,offset Finish
      shr bx,4
      inc bx
      mov ah,4Ah
      int 21h

      mov ah,48h
      mov bx,1000h
      int 21h

      mov Seg_files,ax

      ret
Prepare_memory endp

; --- Установим DTA ---
Set_DTA proc
    mov ah,1Ah
    mov dx,80h
    int 21h
    ret
Set_DTA endp

; === Выходим из программы? ===
Quit_prog proc
      push 1     ;высота рамки
      push offset Mess_quitl ;ширина рамки
      push 4F00h ;цвет - светло-белый на синем фоне
      push offset Mess_qup   ;надпись вверху рамки (если 0, то не выводить)
      push 0     ;надпись внизу рамки (если 0, то не выводить)
      push offset Mess_quit  ;сообщение внутри рамки
      push 01b   ;Копировать экран, но не выводить верхнюю линию
      call Draw_frame ;Рисуем рамку

      call Pause
      call Restore_scr ;Восстановим сохранунную часть экрана.

      cmp al,'Y'       ;Нажали 'Y' / 'y' / Enter (13)?
      je Yes_quit      ;Да! &#25;
      cmp al,'y'
      je Yes_quit
      cmp al,13
      je Yes_quit

      clc  ;Ставим меточку, что нажали другую клавишу (сбросим флаг переноса).
      ret

Yes_quit:
      stc  ;Установим флаг переноса (нажали 'Y', значит выходим)...
      ret
Quit_prog endp</textarea></font></td>
</tr>
<tr>
<td align="center"><p align="center">
<br><font size="4">Messages.asm</font>
<br><font size="4"><!--webbot bot="Validation" b-value-required="TRUE"
i-minimum-length="1" i-maximum-length="80" --><textarea name="Messages.asm"
rows="5" cols="21">;   === MESSAGES.ASM - сообщения, выводимые оболочкой ===

Mess_about db 0Ah, 0Dh, 'SuperShell - оболочка для DOS, написанная на Ассемблере.',0Ah, 0Dh
           db 'Рассылка &quot;Ассемблер? Это просто! Учимся программировать&quot;, Выпуск № 025',0Ah,0Dh
           db 'http://www.Kalashnikoff.ru. E-mail: Assembler@Kalashnikoff.ru',0Ah,0Dh,0Ah
           db '(C) Авторские права на файлы-приложения принадлежат всем подписчикам рассылки.',0Ah, 0Dh, 0Ah
           db 9,9,'=== Россия, Москва, 2001 год ===',0Ah,0Dh,'$'

Mess_head db 1Eh, ' Super Shell, Версия 1.0 ',0
Mess_down db 1Dh, ' Россия, Москва, 2001 ',0

Mess_qup db 4Eh, ' Выход ',0
Mess_quit db 4Bh, ' Вы действительно хотите выйти в DOS (Y/N)?',0
Mess_quitl equ $-Mess_quit-1</textarea></font></p>
</td>
<td align="center"><font size="4">Data.asm</font>
<br><font size="4"><!--webbot bot="Validation" b-value-required="TRUE"
  i-minimum-length="1" i-maximum-length="80" --><textarea name="Data.asm"
rows="5" cols="21">;  === DATA.ASM - данные оболочки ===

;               ==== ПЕРЕМЕННЫЕ ====

Num_attr db ? ;переменная для атрибутов

Num_DX dw ?

Video_page db 0 ;текущая видеостраница

Pos_cursor dw ? ;главная позиция курсора

Handle dw ? ;Номер файла

; --- Данные для процедуры Draw_frame ---
Height_X equ [bp+12] ;высота рамки
Width_Y  equ [bp+10] ;ширина рамки
Attr     equ [bp+8]  ;атрибуты рамки
Mess_up  equ [bp+6]  ;сообщение вверху рамки
Mess_dn  equ [bp+4]  ;сообщение внизу рамки
Mess_ins equ [bp+2]  ;сообщение внутри рамки
Other    equ [bp]    ;иная конфигурация окна</textarea></font></td>
</tr>
</table>
</center></div>

<p>Файл-приложение в Интернете (включая &quot;!coproc!.asm&quot;): 
<a href="http://www.Kalashnikoff.ru/Assembler/Issues/Enclosures/Sshell25.rar">
http://www.Kalashnikoff.ru/Assembler/Issues/Enclosures/Sshell25.rar</a>.</p>

<p>Ну а что тут? Да, в принципе, все просто. Как всегда. Теперь мы
выводим длинные имена файлов, а также их размер.</p>

<p>Как получить и вывести длинное имя файла? Для этого следует
воспользоваться НЕ функциями 4Eh и 4Fh, а 714Eh и 714Fh прерывания 21h. Вот так:</p>

<p>mov ax,714Eh <em>;Функция поиска первого
файла</em><br>
xor di,di <em>;DI должен указывать на буфер, куда будут записываться
данные о найденном файле (типа DTA).</em><br>
xor si,si <em>;SI пока остается тайной!</em><br>
mov cx,0FFh <em>;Ищем все возможные файлы. Это что-то вроде атрибутов файла</em><br>
mov dx,offset All_files <em>;Маска поиска (*.*)</em><br>
int 21h <em>;Теперь в ES:DI находится информация о найденном файле!</em><br>
mov Handle,ax <em>;Номер процесса поиска файлов</em></p>

<p>Отличие данной функции еще в том, что она требует указания номера,
который мы сохраняем после вызова 714Eh.</p>

<p>Все остальное подробно описано в файле-приложении (см. FILES.ASM).</p>

<p>Процедура вывода десятичных чисел находится в файле DISPLAY.ASM. Я
очень надеюсь, что труда разобраться с программой не составит.</p>

<p>Как обычно все файлы-приложения содержат большое количество
комментариев. Как обычно совет: пользуйтесь отладчиком!</p>

<p>Ваши варианты вывода десятичных чисел на экран можно присылать по
адресу: <a href="mailto:Assembler@Kalashnikoff.ru">Assembler@Kalashnikoff.ru</a>.
В последующих выпусках они будут опубликованы в обязательном порядке.</p>

<p>А я закругляюсь, т.к. байты заканчиваются. И вообще, надо
придумать что-нибудь другое. Я имею в виду файл-приложение, который
входит в рассылку. Очень уж много места он занимает...</p>

<p><font size="4"><strong>До встречи через неделю!!!</strong></font></p>

<hr>

<p><font size="4" face="Arbat-Bold"><strong>С уважением,</strong></font></p>

<p><font size="3"><strong>Калашников Олег: 
<a href="mailto:Assembler@Kalashnikoff.ru">Assembler@Kalashnikoff.ru</a>
<br>
ICQ No.: 68951340
<br>
URL сайта подписчиков: <a href="http://www.Kalashnikoff.ru">http://www.Kalashnikoff.ru</font></a></p>

<p align="left">______________</p>

<p align="left">По вопросам сотрудничества, рекламы и спонсорства обращайтесь:</strong></font></p>

<font size="2">
<li>Публичное размещение материала из рассылки: 
<a href="mailto:Cooperation@Kalashnikoff.ru">Cooperation@Kalashnikoff.ru</a></li>
<li>Реклама на сайте: 
<a href="http://www.Kalashnikoff.ru/Reklama.html">http://www.Kalashnikoff.ru/Reklama.html</a>, <a href="mailto:Reklama@Kalashnikoff.ru">Reklama@Kalashnikoff.ru</a></li>
<li>Издание книги (спонсорство): 
<a href="mailto:Sponsor@Kalashnikoff.ru">Sponsor@Kalashnikoff.ru</font></a></li>

<hr>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#DDEEFF" bordercolor="#808080" bordercolorlight="#FFFFFF">
<tr>
<td colspan="3" bgcolor="#BDDEFF"><font color="#400040" size="1"><strong>
(C) Москва, 2001. Авторское право принадлежит Калашникову О.А.</strong> 
Публичное размещение материала из рассылки, а также его использование 
полностью или частично в коммерческих или иных подобных целях без письменного 
согласия автора влечет ответственность за нарушение авторских прав.</font></td>
</tr>
</table>
</center></div>

<hr>

<p align="center">[<a href="026.htm">Следующий выпуск</a>] [<a target=_BLANK href="http://www.Kalashnikoff.ru/">На главную страницу</a>]</p>

<HR NOSHADE><CENTER>
<!-- SpyLOG v2 f:0211 --><script language="javascript">  
u="u496.71.spylog.com";d=document;nv=navigator;na=nv.appName;p=1;  
bv=Math.round(parseFloat(nv.appVersion)*100);  
n=(na.substring(0,2)=="Mi")?0:1;rn=Math.random();z="p="+p+"&rn="+rn;y="";  
y+="<a href='http://"+u+"/cnt?f=3&p="+p+"&rn="+rn+"' target=_blank>";  
y+="<img src='http://"+u+"/cnt?"+z+  
"&r="+escape(d.referrer)+"&pg="+escape(window.location.href)+"' border=0 width=88 height=31 alt='SpyLOG'>";  
y+="</a>"; d.write(y);if(!n) { d.write("<"+"!--"); }//--></script><noscript><p align="center"><a 
href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" 
target="_blank"><img src="http://u496.71.spylog.com/cnt?p=1" alt="SpyLOG" align="middle" border="0"></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"></noscript></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"> 
<script language="javascript1.2"><!-- if(!n) { d.write("--"+">"); }//--></script></a> 
<!-- SpyLOG --> 
 
 <a target=_top href="http://www.one.ru"><img src="http://cnt.one.ru/cgi-bin/cnt.cgi?id=16871&t=9" width=88 height=31 alt="be number one" border=0></a> 
 
 <script language="JavaScript"><!-- 
d=document;a='';a+=';r='+escape(d.referrer) 
js=10//--></script><script language="JavaScript1.1"><!-- 
a+=';j='+navigator.javaEnabled() 
js=11//--></script><script language="JavaScript1.2"><!-- 
s=screen;a+=';s='+s.width+'*'+s.height 
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth) 
js=12//--></script><script language="JavaScript1.3"><!-- 
js=13//--></script><script language="JavaScript"><!-- 
d.write('<a href="http://top.list.ru/jump?from=87856"'+ 
' target=_top><img src="http://top.list.ru/counter'+ 
'?id=87856;t=54;js='+js+a+';rand='+Math.random()+ 
'" alt="TopList"'+' border=0 height=31 width=88></a>') 
if(js>11)d.write('<'+'!-- ')//--></script><noscript><a 
target=_top href="http://top.list.ru/jump?from=87856"><img 
src="http://top.list.ru/counter?js=na;id=87856;t=54" 
border=0 height=31 width=88 
alt="TopList"></a></noscript><script language="JavaScript"><!-- 
if(js>11)d.write('--'+'>')//--></script> 
 
<br><br> 

</body>
</html>