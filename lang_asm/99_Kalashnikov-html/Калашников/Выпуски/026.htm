<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<title>Калашников.ru - Ассемблер? Это просто!.. (Выпуск № 026)</title>
<STYLE>
<!-- a:link, a:visited, a:active { text-decoration: none; color: #226622} 
a:hover { text-decoration: bold; color: #662266; } 
 .ff { 
font-family : Arial, helvetica, sans-serif; 
font-style : normal; 
font-variant : normal; 
} -->
</STYLE>
</head>

<body bgcolor="#CFE7E7" body>
<div align="center"><center>

<p align="center"><a
href="http://ad.ir.ru/bb.cgi?cmd=go&amp;pubid=128269&amp;pg=1&amp;vbn=10001&amp;nocache=9460"
target="_top"><img
src="http://ad.ir.ru/bb.cgi?cmd=ad&amp;pubid=128269&amp;pg=1&amp;vbn=10001&amp;nocache=9460"
alt="InterReklama " border="0"></a><br>
<a href="http://www.ir.ru" target="_top"><font size="1">InterReklama
Advertising</font></a> <!-- BannerBank.  ИнтерРеклама --> </p>

<hr noshade>

<table border="1" cellpadding="0" cellspacing="0" width="100%"
bgcolor="#CDCD9C">
    <tr>
        <td colspan="3" width="100%"><p align="center"><font
        color="#004080" size="5"><em><strong>Ассемблер?
        Это просто! Учимся
        программировать</strong></em></font> <font
        color="#000000" size="2"><br>
        ______________________________________</font></p>
        <p align="center"><font size="4">Выпуск N 026 (</font><a
        href="#shell"><font size="4">Оболочка</font></a><font
        size="4">)</font></p>
        </td>
    </tr>
</table>
</center></div>

<p align="center"><font color="#004080" size="5"
face="Monotype Corsiva"><b>Доброе время суток,
дорогие подписчики!</b></font></p>

<p align="left"><font color="#000000" size="4"><strong>Сегодня
в номере:</strong></font></p>

<dir type="disc">
    <li><p align="left"><a href="#newsfornew">Информация
        для новых подписчиков</a></p>
    </li>
    <li><p align="left"><a href="#letters">Ваши письма.</a></p>
    </li>
    <li><p align="left"><a href="#history">История
        развития IBM-совместимых
        компьютеров (кратко)</a></p>
    </li>
    <li><p align="left"><a href="#shell">Оболочка</a></p>
    </li>
    <li><p align="left">!!! <a href="#surprise">Сюрприз</a>
        !!!</p>
    </li>
</dir>

<hr>

<table border="0" cellpadding="0" cellspacing="0" width="100%"
bgcolor="#9CCDCD">
    <tr>
        <td align="center" width="100%"><a name="newsfornew"><font
        color="#004080" size="5" face="Times New Roman"><strong>Информация
        для новых подписчиков</strong></font></a>
        </td>
    </tr>
</table>

<p align="left"><font size="3">Благодарю Вас, что
подписались на рассылку <em>&quot;Ассемблер?
Это просто! Учимся
программировать&quot;</em>. Надеюсь, что
Вы не останетесь равнодушны к ней и
почерпнете море полезной
информации, а также повысите свой
уровень в &quot;общении&quot; с
IBM-совместимыми компьютерами.</font></p>

<p align="left"><font size="3">Прежде, чем
приступать к изучению материала в
данном выпуске, Вам необходимо
внимательно ознакомиться с
предыдущими. Я уверен, что Вы очень
быстро и без труда догоните
остальных подписчиков, не смотря на
то, что у нас уже 26 выпуск.</font></p>

<p align="left"><font size="3">Все, что нужно для
изучения Ассемблера (предыдущие
выпуски, адреса экспертов,
необходимые программы,
документацию, а также многое
другое), можно найти на сайте </font><a
href="http://www.Kalashnikoff.ru"><font size="3">http://www.Kalashnikoff.ru</font></a><font
size="3">. Рекомендую Вам сперва
ознакомиться с разделом <em>&quot;Информация
для новых подписчиков&quot;</em>.</font></p>

<p align="left"><font size="2">Если у Вас нет
выхода в Сеть, то предыдущие
выпуски рассылки, информацию для
новеньких и адреса экспертов можно
получить по почте, направив пустое
письмо по адресу </font><a
href="mailto:AssmIssues@Kalashnikoff.ru"><font size="2">AssmIssues@Kalashnikoff.ru</font></a><font
size="2">. Информация (350 Кб) будет
выслана Вам в течение <strong><u>двух
рабочих</u></strong> дней с момента
получения Вашего письма. <em><strong>Однако,
пожалуйста, не злоупотребляйте
этим</strong></em><em>, т. к. высылка писем
подобного объема несет
существенную нагрузку на почтовые
сервера</em>.</font></p>

<hr>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="100%"
bgcolor="#9CCDCD">
    <tr>
        <td align="center" width="100%"><a name="letters"><font
        color="#004080" size="5" face="Times New Roman"><strong>Ваши
        письма.</strong></font></a></td>
    </tr>
</table>
</center></div>

<p align="left"><font size="3">В предыдущих
выпусках рассылки я писал про язык
С и, видимо, допустил ошибку.
Заострю на этом внимание, т.к. мне
кажется, что многим подписчикам
данная информация будет полезна
(учитывая то, что вскоре приступим к
Windows + С). Ко мне пришло письмо от
Алексея следующего содержания
(привожу выдержки):</font></p>

<p align="left"><font size="3"><b><i>Здравствуйте,
уважаемый Олег!<br>
</i></b><i>Вы действительно ошиблись по
поводу языка C. Файл stdio.h (и другие *.h)
не содержит самих функций, они
находятся в различных (в
зависимости от модели памяти)
библиотечных файлах. А файлы *.h (они
называются заголовочными) содержат
прототипы (заголовки) функций и
представляют собой обычные
текстовые файлы.</i></font></p>

<p align="left"><font size="3"><i>Прототип
показывает компилятору, какого
типа, в каком порядке и каким
образом (через стек или регистры)
функции передаются аргументы, а так
же какого типа функция возвращает
значения. Можно в библиотеку
включить свои функции, написанные
на C или ассемблере, и пользоваться
этими функциями как стандартными,
создав свой заголовочный файл.<br>
Практически каждый стандартный
заголовочный файл содержит
несколько десятков прототипов, но в
код программы включаются ТОЛЬКО
ИСПОЛЬЗУЕМЫЕ В ДАННОЙ ПРОГРАММЕ
ФУНКЦИИ.</i></font></p>

<p align="left"><font size="3"><i>Причины большего
объёма программы, написанной на C в
другом.<br>
Во-первых, в каждую C-программу
включается так называемый
загрузчик C (находящийся в файлах
c0?.obj, различных в зависимости от
модели памяти). С него начинается
работа программы, затем вызывается
функция main С-программы, завершает
программу опять же загрузчик C. А в
нём содержатся обработчики
некоторых прерываний, переменные,
определение версии операционной
системы и много ещё чего (в комплект
поставки C/C++ входит файл c0.asm, так
что его можно посмотреть).<br>
Во-вторых, ... Впрочем, я начинаю
увлекаться. Ведь это не рассылка по
C/C++, а я не автор. Хочется только
добавить, что С-компилятор
генерирует довольно эффективный
код, в этом можно убедиться, задав
при компиляции ключ -S и посмотрев
листинг на ассемблере.</i></font></p>

<p align="center"><font size="3">____________</font></p>

<p align="left"><font size="3">Некотрые
уточнения по поводу 386/486 SX/DX машин. В
принципе, пришло несколько
подобных писем (от: Serge I.Driantsov,
Дмитрий Сердюк). Однако, письмо
Максима Белова более-менее точно
описывало ситуацию с SX/DX машинами:</font></p>

<p align="left"><font size="3"><i>...С процессорами
ситуация несколько иная была.</i></font></p>

<p align="left"><font size="3"><i>1. 486 начались с 16
или с 20 или с 25 МГц (у меня на рабочем
ящике стоял такой уродец - 486SX-25).</i></font></p>

<p align="left"><font size="3"><i>2. 486 DX-33 (домашний
первый ящик) - сопроцессор был уже
там.</i></font></p>

<p align="left"><font size="3"><i>3. 386 серия -
совершенно отдельная песня. Если в
486 сопроцессор был встроен и
отключен (процент выхода годных
чипов), то в 386 индекс DX/SX говорит о
ширине внешней шины данных
процессора - 32/16 бит. (как 8086/8088 - 16
разрядный внутри, а вот снаружи 16/8).</i></font></p>

<p align="left"><font size="3"><i>4. Что-то я еще
слышал про 486SX/387DX связку, но плохо
себе это представляю, как это
возможно.</i></font></p>

<p align="left"><font size="3"><i>5. Говоря о
выпайке, может быть, имелось в виду
выпаивание распаянного на
материнской плате процессора?</i></font></p>

<p align="left"><font size="3">___________</font></p>

<p align="left"><font color="#000080" size="3">Мой
комментарий.</font></p>

<p align="left"><font size="3">1. Читайте
следующий раздел: &quot;</font><a href="#history"><font
size="3">История развития
IBM-совместимых компьютеров</font></a><font
size="3">&quot;.</font></p>

<p><font size="3">3. Полностью согласен, что
индекс SX в 386 машинах
свидетельствовал о разрядности
шины.</font></p>

<p><font size="3">4. Дело в том, что 487
сопроцессор ничем не отличается от
387. Поэтому структура и принцип
работы, а также команды 387
сопроцессора аналогичны 487. Иначе говоря, в
&quot;четверках&quot; стоял обычный
&quot;трешный&quot; сопроцессор, только
располагался он на одном кристалле
с основным процессором.</font></p>

<p><font size="3">5. Лично я купил в свое
время 386DX-40, рассчитывая, что в нем
присутствует сопроцессор (теперь
понятно, что я ошибался). При
вскрытии системного блока,
оказалось, что сопроцессор
действительно присутствовал
когда-то, но его выпаяли. Это было
явно видно на разъеме...</font></p>

<p align="center"><font size="3">____________</font></p>

<p><font size="3">Granit прислал алгоритм
вывода десятичных чисел на экран.
Спасибо!</font></p>

<p><font size="3">Но! Дело в том, что
максимальное число, которое может
вывести данная процедура, гораздо
меньше, чем то, которое выводим мы в
нашем примере. Тем не менее, я
опубликовываю данный алгоритм (без
проверки с моей стороны):</font></p>

<p align="center"><font size="3"><b><u>DEC.ASM</u></b></font></p>

<p align="center"><font size="4"><!--webbot bot="Validation"
b-value-required="TRUE" i-minimum-length="1" i-maximum-length="80" --><textarea name="Sshell" rows="4"
cols="25">p486

ideal
model	small

dataseg

dest	db	5 dup (0)
source	dd	0ffffffffh

codeseg


start:		mov	ax,@data
		mov	ds,ax
		mov	es,ax

		mov	eax,[source]
		mov	ecx,32
;--------------------------------------
next:		push	cx
		mov	cx,5
		mov	bx,offset dest
;----------------------------
j0:		mov	dl,[bx]
		and	dl,0fh
		cmp	dl,5
		jc	short j1
		add	[byte bx],3
j1:		mov	dl,[bx]
		and	dl,0f0h
		cmp	dl,80
		jc	short j2
		add	[byte bx],48
j2:		inc	bx
		loop	j0
;----------------------------
		shl	eax,1
		mov	cx,5
		mov	bx,offset dest +4
j3:		rcl	[byte bx],1
		dec	bx
		loop	j3
;--------------------------------------
		pop	cx
		loop	next

;====================================================================

		mov	ecx,5
		mov	bx,offset dest
next2:		push	cx
		mov	dl,[bx]
		and	dl,0f0h
		ror	dl,4
		add	dl,48
		mov	al,0
		mov	ah,2
		int	21h
		mov	dl,[bx]
		and	dl,0fh
		add	dl,48
		mov	al,0
		mov	ah,2
		int	21h
		inc	bx
		pop	cx
		loop	next2

		mov	ax,4c00h
		int	21h

stack		200h

end		start
</textarea></font></p>

<p><font size="3"><b>ВНИМАНИЕ!</b> Это -
типичный формат *.exe-файла.
Ассемблировать его нужно следующим
образом:</font></p>

<p><font size="3">ML.EXE DEC.ASM</font></p>

<p><font size="3">Или:</font></p>

<p><font size="3">TASM DEC.ASM</font></p>

<p><font size="3">TLINK DEC.OBJ</font></p>

<p><font size="3">И все! Никаких параметров!
В результате должен получиться
DEC.EXE. Судя по структуре файла, видно,
что Granit использует TASM...</font></p>

<p align="center"><font size="3">___________</font></p>

<p><font size="3"><b><i>Добрый день или другое
какое время суток!</i></b></font></p>

<p><font size="3"><i>Я решил узнать, что же
такое Ассемблер и подписался на
рассылку, не забыв и заказать
предыдущие выпуски. Но вот одно
немного смущает еще до начала всех
проб и ошибок. Как-то кто-то говорил
мне, что для программирования на
Ассемблере надо знать архитектуру
именного того процессора, для
которого пишется код на Ассемблере:
Pentium ли это, Pentium Pro, Pentium-II или Pentium-III.
А у меня дома машина на AMD-K6 бегает. Действительно
ли этот процессор
имеет свою систему команд, и правда
ли то, что книги или рассылки по
программированию на Ассеблере для
Пентиума или 486 ничем не помогут
мне, так как я хочу работать на AMD-K6?
Спасибо заранее за разъяснения.</i></font></p>

<p><font size="3"><i>С уважением, Michael.</i></font></p>

<p><font size="3">___________</font></p>

<p><font color="#000080" size="3">Мой комментарий.</font></p>

<p><font size="3">Уважаемый Михаил!</font></p>

<p><font size="3">Дело в том, что в 1981 году
появились первые компьютеры на
базе процессора Intel. Назывались они
IBM PC. Со временем появились IBM PC/XT, IBM
PC/Jr, IBM PC/AT, IBM PS/2 и т.д. Главное не это.
Главное то, что программа,
написанная для процессора Intel 8086
должна работать и на Pentium-III, т.к. Pentium
- это процессор, совместимый с 8086.
Иначе говоря, совместимость
программ идет снизу вверх.
Например, многие любят старые
XT-шные игры: Pirates, Civilization, King's Bounty,
Arcanoid и пр. Естественно, они были
написаны для 8086 процессора, но
работают также на 386-Pentium. AMD - это
IBM-совместимый компьютер. Это
означает, что программы, написанные
для IBM PC/XT, будут работать на Pentium, на
AMD и на других IBM-совместимых
компьютерах. Отсюда правило - если
Вы пишите программу, используя
инструкции 8086 процессора, то я даю
гарантию (точнее не я, а
фирма-производитель процессоров),
что они будут корректно работать на
последующих процессорах (80286, 80386, AMD,
Compaq и пр.).</font></p>

<p align="center"><font size="3">___________</font></p>

<p align="left"><font size="3">Хочу выразить
благодарность Сергею Юрьевичу за
проделанную работу по переводу
*.txt-файлов в формат DOC. Спасибо!</font></p>

<hr>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="100%"
bgcolor="#9CCDCD">
    <tr>
        <td align="center" width="100%"><a name="history"><font
        color="#004080" size="5"><strong>История
        развития IBM-совместимых
        компьютеров</strong></font></a></td>
    </tr>
</table>
</center></div>

<p align="left"><font size="3">Если я не ошибаюсь,
то ситуация такая:</font></p>
<div align="left">

<table border="1" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td align="center" width="14%"><font size="3"><b>Процессор</b></font></td>
        <td align="center" width="14%"><font size="3"><b>Тип
        (SX/DX)</b></font></td>
        <td align="center" width="14%"><font size="3"><b>ОЗУ</b></font></td>
        <td align="center" width="14%"><font size="3"><b>Винчестер
        (Мб)</b></font></td>
        <td align="center" width="14%"><font size="3"><b>Мегагерцы
        (Mhz)</b> </font></td>
        <td align="center" width="15%"><font size="3"><b>Монитор</b></font></td>
        <td align="center" width="15%"><font size="3"><b>Отечественный
        вариант</b></font></td>
    </tr>
    <tr>
        <td align="center" width="14%"><font size="3">8086/8088</font></td>
        <td align="center" width="14%"><font size="3">---</font></td>
        <td align="center" width="14%"><font size="3">256-640
        Кб</font></td>
        <td align="center" width="14%"><font size="3">10-20</font></td>
        <td align="center" width="14%"><font size="3">4,77 - 8</font></td>
        <td align="center" width="15%"><font size="3">Mono, CGA</font></td>
        <td align="center" width="15%"><font size="3">ЕС-1840,
        1841, 1851 и пр.</font></td>
    </tr>
    <tr>
        <td align="center" width="14%"><font size="3">80286</font></td>
        <td align="center" width="14%"><font size="3">---</font></td>
        <td align="center" width="14%"><font size="3">до 4 Мб</font></td>
        <td align="center" width="14%"><font size="3">20-60</font></td>
        <td align="center" width="14%"><font size="3">6 - 16</font></td>
        <td align="center" width="15%"><font size="3">CGA - VGA</font></td>
        <td align="center" width="15%"><font size="3">EC-1849</font></td>
    </tr>
    <tr>
        <td align="center" width="14%"><font size="3">80386</font></td>
        <td align="center" width="14%"><font size="3">SX/DX</font></td>
        <td align="center" width="14%"><font size="3">4-8 Мб</font></td>
        <td align="center" width="14%"><font size="3">40-120</font></td>
        <td align="center" width="14%"><font size="3">16-40</font></td>
        <td align="center" width="15%"><font size="3">EGA - VGA</font></td>
        <td align="center" width="15%"><font size="3">EC-1863</font></td>
    </tr>
    <tr>
        <td align="center" width="14%"><font size="3">80486</font></td>
        <td align="center" width="14%"><font size="3">SX/DX </font></td>
        <td align="center" width="14%"><font size="3">4-12 Мб</font></td>
        <td align="center" width="14%"><font size="3">80-370</font></td>
        <td align="center" width="14%"><font size="3">25-120</font></td>
        <td align="center" width="15%"><font size="3">EGA - VGA</font></td>
        <td align="center" width="15%"><font size="3">Не
        помню</font></td>
    </tr>
    <tr>
        <td align="center" width="14%"><font size="3">Pentium</font></td>
        <td align="center" width="14%"><font size="3">---</font></td>
        <td align="center" width="14%"><font size="3">16 Мб</font></td>
        <td align="center" width="14%"><font size="3">300-800</font></td>
        <td align="center" width="14%"><font size="3">60</font></td>
        <td align="center" width="15%"><font size="3">VGA - sVGA</font></td>
        <td align="center" width="15%"><font size="3">---</font></td>
    </tr>
</table>
</div>

<p><font size="3"><i>Некоторые комментарии</i>.
Приведенную в таблице информацию
не следует считать обязательной
для того или иного компьютера.
Например, при желании можно было
укомплектовать такую машину: IBM 486
SX-25, 10Мб - винчестер, 32Мб - ОЗУ, MDA -
монитор...</font></p>

<p><font size="3">Что же касается
отечественных вариантов, то могу
сказать, что лучшим
конструкторским решением (не беру
во внимание форму системного блока
и шум вентилятора) можно считать
ЕC-1849 (12Mhz, 640 Кб основной + 384 КБ
расширенной (XMS) памяти, 40Мб
винчестер, EGA - изначальная
конфигурация завода МЗВТ). Самыми
неудачными оказались: ЕС-1840 (не имел
возможности подключать винчестер вообще, содержал ошибки
в ПЗУ, а также  (как и в ЕС-1841 - 1843) два
здоровых ящика (системный блок),
которые нужно было включать
(дисководы и сам компьютер)), ЕС-1863
(&quot;мутант&quot; 386SX - 2 Мб памяти,
EGA-монитор, 16 Mhz, высокая цена).</font></p>

<p><font size="3">Чем же отличались эти
компьютеры друг от друга? Я считаю, что
каждый ассемблерщик должен знать историю
развития ПК. Ну, хотя бы вкратце. Иначе
можете попасть впросак...</font></p>

<p><b>С чего все начиналось (речь идет о IBM'ках!).</b></p>

<p><font size="3">В 1981 году на свет появляется
первый персональный компьютер IBM PC. Затем,
как уже писалось, XT, AT и т.д.</font></p>

<p><font size="3">286 процессор мало чем отличался от
своих старших &quot;братьев&quot;. Имел несколько новых
команд (например, PUSH число), а также позволял
переводить компьютер в т.н. &quot;защищенный
режим&quot; (protected mode). Сомневаюсь, что многие
программы им пользовались, т.к. этот режим
сильно отличался от &quot;трешного&quot;.
Немного увеличилась скорость работы, да
памяти чуть-чуть нарастили. Вот, собственно,
и все.</font></p>

<p><font size="3">&quot;Тройки&quot; (т.е. 386 процессоры)
существенно отличались от всех
предшествующих поколений компьютеров.
Прежде всего - полноценный защищенный режим,
много дополнительных команд для работы с
ним, возможность управлять до 4 Гб ОЗУ и
многое другое. По сути дела, современный
Пентиум - это не что иное, как обычная &quot;тройка&quot;,
только работающая в несколько раз быстрее,
да имеющая несколько дополнительных
операторов (MMX, SSE).</font></p>

<p><font size="3">&quot;Четверки&quot; далеко не ушли от
386. Единственное, что их отличало от &quot;трешек&quot;,
так это расположение сопроцессора на одном
кристалле с основным процессором.
Существенно увеличилась скорость работы,
добавилось несколько новых команд и др. по
мелочам. Все остальное было также, как у &quot;тройки&quot;.</font></p>

<p><font size="3">Ну, а &quot;Пентиум&quot; - он, как
говорится, и в Африке &quot;Пентиум&quot;...</font></p>

<p><font size="3">Вот это вкратце. Надеюсь, о компьютерах
мы еще
поговорим подробней позже...</font></p>

<hr>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="100%"
bgcolor="#9CCDCD">
    <tr>
        <td align="center" width="100%"><a name="shell"><font
        color="#004080" size="5"><strong>Оболочка</strong></font></a></td>
    </tr>
</table>
</center></div>

<p align="center"><br>
</p>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="80%">
    <tr>
        <td align="center" colspan="2" width="100%"><font
        color="#FF0000" size="4"><strong>Sshell26.asm
        (головной файл)</strong></font> <br>
        <font size="4"><!--webbot bot="Validation" b-value-required="TRUE"
        i-minimum-length="1" i-maximum-length="80" --><textarea name="Sshell" rows="5"
        cols="33">;              Sshell26.ASM - программа к рассылке № 026

; (С) Авторские права на файлы-приложения принадлежат подписчикам рассылки
; "Ассемблер? Это просто! Учимся программировать"
; Автор рассылки:
; Калашников Олег Александрович (e-mail: Assembler@Kalashnikoff.ru)
;                 http://www.Kalashnikoff.ru

; --- Ассемблирование (получение *.com файла) ---
;При использовании MASM 6.11 - 6.13:
;ML.EXE Sshell26.asm /AT

;При использовании TASM:
;TASM.EXE Sshell26.asm
;TLINK.EXE Sshell26.obj /t/x

;______________________________________________________

.386 ;Будем использовать регистры и команды 80386 процессора,
.287 ;А также команды 80287 сопроцессора
CSEG segment use16
assume cs:CSEG, ds:CSEG, es:CSEG, ss:CSEG
org 100h

Start:
        jmp Begin

; ======= Процедуры =========
; Головная
include main.asm

; Работа с дисплеем
include display.asm

; Работа с файлами
include files.asm

; Работа с клавиатурой
include keyboard.asm

; Сообщения
include messages.asm

; Переменные
include data.asm

; Начало программы
Begin:
        call Check_video ;Проверим видеорежим и текущую страницу

        mov ah,9
        mov dx,offset Mess_about
        int 21h ;выводим сообщение с приветствием

        call Main_proc ; === Головная процедура ===

; Выходим в DOS
        int 20h

Current_dir equ $             ;Область хранения текущего каталога

Finish equ Current_dir+300    ;Это финиш!

CSEG ends
end Start</textarea></font></td>
    </tr>
    <tr>
        <td align="center" width="50%"><br>
        <font size="4">Display.asm</font> <br>
        <font size="4"><!--webbot bot="Validation" b-value-required="TRUE"
        i-minimum-length="1" i-maximum-length="80" --><textarea name="Display"
        rows="5" cols="21">;        ===== DISPLAY.ASM - процедуры работы с экраном ======

; === Рисуем рамку заданного размера в центре экрана ===
Draw_frame proc
     mov bp,sp
     add bp,2

     push es

     push 0B800h
     pop es

;Производим вычисления для того, чтобы разместить ЛЮБУЮ рамку в цетре экрана.
     mov ax,Height_X
     shr al,1
     mov dh,11
     sub dh,al

     mov ax,Width_Y
     shr al,1
     mov dl,39
     sub dl,al
;Теперь DH содержит центрированный ряд (строку),
;а DL - колонку относительно размеров рамки (окошка)...

  ;Сохраним полученный адрес, с которого начинается вывод рамки
     mov Num_DX,dx

     mov ax,Other
     test al,1     ;Нулевой бит равен 0?
     jz No_copyscr ;Если так, то копировать экран не нужно.

     mov ax,Height_X ;Иначе копируем в область 2 видеостраницы
     add ax,2
     call Copy_scr

No_copyscr:
     call Get_linear
     push di

     mov ax,Attr
     mov al,'г'
     stosw

     mov al,'='
     mov cx,Width_Y
     rep stosw

     mov al,'¬'  ;завершаем верхний ряд
     stosw

     pop di      ;восстановим DI + 160 (следующий ряд)
     add di,160
     inc dh

     mov cx,Height_X ;CX - кол-во повторов (высота)

Next_lined:
     push cx
     push di

     mov al,'¦'
     stosw

     mov al,32
     mov cx,Width_Y
     rep stosw

     mov al,'¦'
     stosw

     pop di
     add di,160
     inc dh
     pop cx
     loop Next_lined ;следующий ряд...


     mov al,'L' ;низ рамки...
     stosw

     mov al,'='
     mov cx,Width_Y
     rep stosw

     mov al,'-'
     stosw


;Выводим сообщение внизу рамки
     mov si,Mess_dn
     call Draw_messfr


;Выводим сообщение вверху рамки
     mov dx,Num_DX
     push dx
     mov si,Mess_up
     call Draw_messfr

     pop dx
     add dx,0101h
     mov si,Mess_ins ;Адрес сообщения, которое будет внутри рамки
     or si,si        ;Если там 0, то не выводим...
     jz No_draw
     mov ah,[si]
     inc si
     call Print_string

;теперь у нас примерно такая ситуация на экране:
;г==== Сообщение вверху =====¬
;¦Сообщение внутри           ¦
;¦                           ¦
;¦                           ¦
;L==== Сообщение внизу ======-


No_draw:
     mov ax,Other ;Получим дополнительную информацию
     test ax,10b
     jz No_upline

     mov dx,Num_dx
     add dh,2
     call Get_linear

     mov ax,Attr
     mov al,'¦'
     mov cx,1
     stosw

     mov cx,Width_Y
     mov al,'-'
     rep stosw

     mov al,'¦'
     stosw

;теперь у нас примерно такая ситуация на экране:
;г==== Сообщение вверху =====¬
;¦Сообщение внутри           ¦
;¦--------- линия -----------¦
;¦                           ¦
;¦                           ¦
;L==== Сообщение внизу ======-


No_upline:
     pop es
     ret 14
Draw_frame endp


; --- Вывод сообщениий вверху и внизу рамки ---
;Вспомогательна процедура.
Draw_messfr proc
     or si,si ;SI = 0?..
     jz No_drawup ;тогда ничего выводить не надо, выходим

     mov ah,[si]
     inc si
     call Count_strmid ;Вычисляем середину строки

     call Print_string ;Выводим строку на экран

No_drawup:
     ret
Draw_messfr endp

; === Вычисляем середину строки ===
;Вход: CS:SI - адрес строки
;Выход: DL - середина адреса для вывода строки
Count_strmid proc
     push es
     push di
     push ax

     push cs
     pop es
     mov di,si
     xor al,al
     mov cx,0FFFFh ;сколько символов перебирать (возьмем максимум)...
     repne scasb ;Ищем 0 в строке

;SI=начало строки
;DI=конец строки+1
     sub di,si ;DI=DI-SI-1 = длина строки
     dec di

     shr di,1  ;Делим длину на 2
     mov ax,40 ;Делим кол-во символов в строке на 2 = 40
     sub ax,di ;AX=40-половина длины строки = нужная колонка
     mov dl,al ;DL=колонка, с которой следует выводить строку!

     pop ax
     pop di
     pop es
     ret
Count_strmid endp

; === Вывод стоки на экран ===
;Вход: DS:SI - адрес строки для вывода
;      DX - координаты для вывода
;      AH - атрибуты строки
;Выход: ничего
Print_string proc
     call Get_linear

Next_symstr:
     lodsb          ;Получаем очередной символ строки
     or al,al       ;Это 0 (конец строки?)
     jz Stop_outstr
     stosw
     jmp short Next_Symstr ;Следующий символ

Stop_outstr:
     ret
Print_string endp

; === Вывод символа на экран ===
;Вход: AL - символ для вывода
;      AH - атрибуты символа
;      DX - координаты для вывода
;Выход: ничего
Print_sym proc
     call Get_linear ;Получаем линейный адрес строки
     stosw           ;Заносим в видеобуфер атрибут (AH) и символ (AL)
     ret
Print_sym endp

; === Преобразование DH:DL в линейный массив ===
Get_linear proc
    push ax    ;сохраним все используемые регистры
    push bx
    push dx

    shl dl,1   ;умножаем DL на 2.

    mov al,dh  ;в AL - ряд,
    mov bl,160 ;который нужно умножить на 160
    mul bl     ;умножаем: AL(ряд)*160; результат --- в AX

    mov di,ax  ;результат умножения - в DI
    xor dh,dh  ;аннулируем DH
    add di,dx  ;теперь в DI линейный адрес в видеобуфере.

    pop dx
    pop bx
    pop ax
    ret
Get_linear endp

; === Проверяем видеорежим монитора и текущую видеостраницу ===
Check_video proc
     mov ah,0Fh
     int 10h
     cmp al,3  ;Текстовый режим?
     je Ok_video

     mov ax,3
     int 10h

Ok_video:
     or bh,bh  ;Нулевая страница?
     jz Ok_page

     mov ax,0500h
     int 10h

Ok_page:
     ret
Check_video endp

; === Сохраним экран ===
Save_mainscr proc
    pusha
    push es
    push ds

    push 0B800h ;с нулевой страницы
    pop ds
    xor si,si

    push 0B900h ;в первую страницу...
    pop es
    xor di,di

    mov cx,2000 ;4000 байт
    rep movsw

    pop ds      ;восстановим регистры.
    pop es
    popa
    ret
Save_mainscr endp

; === Восстановим экран ===
Restore_mainscr proc
    pusha
    push es
    push ds

    push 0B900h ;с первой видеостраницы
    pop ds
    xor si,si

    push 0B800h ;в нулевую...
    pop es
    xor di,di

    mov cx,2000
    rep movsw

    pop ds
    pop es
    popa
    ret
Restore_mainscr endp

; === Копируем часть экрана ===
;Вход: DH - ряд, с которого необходимо начать копирование
;      AL - количество рядов для копирования
;Выход: ничего
Copy_scr proc
    pusha
    push es
    push ds

    xor dl,dl
    call Get_linear

    mov bl,160  ;Получим количество байт, котрые нужно копировать
    mul bl
    mov cx,ax   ;Их - в CX (будем использовать CX как счетчик)

    mov si,di   ;DS:SI - откуда копируем
    xor di,di   ;ES:SI - куда копируем
    mov Num_copySI,si ;Сохраним полученные значения для восстановления
    mov Num_copyDI,di
    mov Num_copyCX,cx
    push 0B800h
    pop ds
    push 0BA00h
    pop es
    rep movsb

    pop ds
    pop es
    popa
    ret

Num_copySI dw ?
Num_copyDI dw ?
Num_copyCX dw ?
Copy_scr endp

; === Восстанавливаем часть экрана ===
;Вход: ничего (все уже сохранено в переменных )
;Выход: ничего
Restore_scr proc
    pusha
    push es
    push ds

    mov di,Num_copySI ;Получим сохраненные процедурой Copy_scr значения
    mov si,Num_copyDI
    mov cx,Num_copyCX
    push 0BA00h
    pop ds
    push 0B800h
    pop es
    rep movsb  ;Копируем со 2-ой страницы в 0-ую...

    pop ds
    pop es
    popa
    ret
Restore_scr endp

; === Прячем курсор, сохранив предварительно его текущую позицию ===
Hide_cursor proc
    mov ah,3          ;получаем текущую позицию курсора
    mov bh,Video_page
    int 10h
    mov Pos_cursor,dx

    mov ah,2  ;Установим курсор на первую страницу как на нулевой
    mov bh,1
    int 10h

    mov bh,Video_page ;прячем курсор на 0-ой видеостранице
    mov dx,1900h
    int 10h

    ret
Hide_cursor endp

; === Восстановим курсор ===
Restore_cursor proc
    mov ah,2
    mov bh,Video_page ;видеостраница
    mov dx,Pos_cursor ;сохраненная позиция
    int 10h           ;установим (позиционируем) курсор
    ret
Restore_cursor endp

; === Вывод десятичных чисел на экран (сопроцессор) ===
;Вход: Number_dec - 64-х битное число для вывода
;      DX - адрес для вывода
;      AH - атрибуты для вывода
;Выход: ничего
Out_dec proc
    pusha
    push es
    push 0B800h
    pop es

    xor cx,cx   ;CX - счетчик для точек (см. ниже )

    finit       ;Инициализация сопроцессора

;Проведем необходимую настройку сопроцессора для округления чисел...
    fstcw Dat
    or Dat,0C00h
    fldcw Dat

    fldz

    fild Divider

    fild Number_dec

    fst st(7)       ;ST(7)=ST(0)

Next_sym:
    fprem            ;Делим и получаем остаток от деления в ST(0)

    fistp Dat        ;Dat=ST(0)

;Выводим остаток от деления, который загружен в Dat.
    mov al,byte ptr Dat
    add al,'0'
    call Print_sym
    dec dx          ;Вывели. DX=DX-1 - следующий символ

;Подготовимся к выводу следующего символа...
    fld st(6)       ;ST(0)=ST(6)

    fdiv st,st(1)   ;Теперь делим ST(0) на ST(1)

    frndint         ;Округлим полученное число

    fst st(7)       ;ST(7)=ST(0).

;Теперь проверим, равно ли делимое нулю.
    push ax
    fcom st(2)      ;ST(0)=ST(2)?
    fstsw ax        ;AX=состояние сопроцессора
    and ax,100010100000000b ;Аннулируем ненужные нам биты
    cmp ax,100000000000000b ;ST(0)=ST(2)?
    pop ax
    je Finish_dec           ;Если равно, то на выход 

;Точкой будем отделять три цифры для удобства. Пример: 1.568
    inc cx
    cmp cx,3        ;Три цифры выведено?
    jne Next_sym    ;Пока нет. Следующая цифра 

    mov al,'.'      ;Выводим разделитель разрядов (точку)
    call Print_sym
    dec dx
    xor cx,cx       ;Обнулим счетчик
    jmp short Next_sym ;Следующая цифра 

Finish_dec:
    pop es
    popa
    ret

 Number_dec dq ?  ;64-х разрядная переменная для выводимого числа
 Divider dw 10    ;Делитель всегда 10
 Dat dw ?         ;Временная переменная для хранения остатка от деления на 10

;Данная процедура выводит всего лишь одно число на экран. Представляете,
;сколько работы проделывает процессор за считанные доли миллисекунд, выводя
;на экран несколько файлов?
;А ведь кроме вывода чисел мы еще проверяем текущий режим монитора и текущую
;видеостраницу, копируем пользовательский экран, читаем и сохраняем
;текущую позицию курсора, рисуем рамку, производя необходимые расчеты,
;читаем каталог в память и выводим первые файлы на экран по одному символу...
;Имейте также в виду, что наши алгоритмы пока не совсем оптимальны.
;Уверяю вас, что даже на PC/XT вывод будет осуществлен мгновенно. Т.е.
;на глаз совсем не заметно... Впечатляет скорость работы процессора?
;Надеюсь, что так...
Out_dec endp

; === Выделяем строку определенным цветом ===
;На входе: DX - координаты
;          CX - длина строки
;          AH - атрибут
Color_line proc
      pusha
      push es
      push 0B800h
      pop es
      call Get_linear
      inc di         ;Указываем не на символ, а на атрибут

Next_symbc:
      mov es:[di],ah ;Заносим атрибут...
      inc di         ;Следующий...
      inc di
      loop Next_symbc

      pop es
      popa
      ret
Color_line endp</textarea></font></td>
        <td align="center" width="50%"><br>
        <font size="4">Files.asm</font> <br>
        <font size="4"><!--webbot bot="Validation" b-value-required="TRUE"
        i-minimum-length="1" i-maximum-length="80" --><textarea name="Files"
        rows="5" cols="21">; ==== FILES.ASM - процедуры работы с файлами ====

; !!! Здесь придется повозиться не меньше, чем с Keyboard.asm !!!

; === Читаем файлы в текущем каталоге ===
Get_files proc
      push es
      mov es,Seg_files

      mov Current_offset,500
      mov Prev_file,0

      mov di,Current_offset
      xor eax,eax
      stosd

      call Get_first  ;Получаем первый файл
      jc No_morefiles ;Если нет файлов вообще - на выход

      cmp word ptr es:[2Ch],002Eh ;Первый файл - '.'?
      je Next_file_   ;Если так, то ищем следующий файл...

      call Move_file  ;Если нет, то переносим файл в память.

Next_file_:
      call Get_other  ;Получаем следующий файл...
      jc No_morefiles ;Файлы закончились - на выход.

      call Move_file  ;Если нет, то переносим файл в память.
      jmp short Next_file_ ;Ищем следующий файл...

No_morefiles:
      mov di,Next_file
      xor ax,ax
      stosw

      mov di,500
      mov Current_file,di
;Будет указывать на то, что первый файл - текущий
      mov di,Current_file
      or byte ptr es:[di+4],1

      pop es
      ret

All_files db '*.*',0
Seg_files dw ? ;Сегментный адрес буфера файлов
Current_offset dw 500
Next_file dw ?
Prev_file dw 0
Get_files endp

; === Поиск первого файла в текущем каталоге ===
Get_first proc
;Здесь можно поставить инструкцию int 3 и в процессе отладки позволить
;отладчику выполнить программу до конца (Run). Дойдя до int 3 отладчик
;обязательно остановится, что позволит вам проанализировать работу
;приведенных ниже строк. Попробуйте!

;     int 3        ;<=== Как точка останова для отладчика (BreakPoint)

      mov ax,714Eh ;Функция поиска первого файла
      xor di,di ;DI должен указывать на буфер, куда будут записываться
      xor si,si ;данные о найденном файле (типа DTA). SI пока остается тайной!
      mov cx,0FFh ;Ищем все возможные файлы. Это что-то вроде атрибутов файла
      mov dx,offset All_files ;Маска поиска
      int 21h
      mov Handle,ax ;Сохраним номер процесса поиска файлов для 714Fh
      ret
Get_first endp

; === Поиск следующих файлов ===
Get_other proc
      mov bx,Handle ;Указываем номер процесса.
      mov ax,714Fh  ;Функция поиска следующих файлов
      xor si,si
      xor di,di     ;DI должен указывать на буфер, куда будут записываться
      int 21h       ;данные о найденном файле (типа DTA).
      ret
Get_other endp

; --- Перенос имени найденного файла в сегмент файлов нашей программы ---
Move_file proc
;Рекомендую здесь также установить точку останова, как показано выше 
;      int 3
      push ds
      mov di,Current_offset ;Текущее свободное смещение
      push di

;Пропустим 4 байта, в которые будут занесены адреса предыдущего и следующего
;файлов в цепочке. 0000h будет свидетельствовать о первом или последнем файле.
      add di,4

      xor al,al      ;Занесем 0, что будет свидетельствовать...
      stosb          ;...о статусе файла (текущий и/или отмеченный)
      mov ds,Seg_files
      mov si,2Ch     ;SI=имя найденного файла

Next_fbyte:
      lodsb          ;Получаем первый символ имени файла
      stosb          ;Сохраним символ в памяти
      or al,al       ;Это нуль (конец имени)?
      jnz Next_fbyte ;Следующий символ...

;Заносим размер файла
      mov si,1Ch     ;По этому смещению будет размер файла (4 слова)
      lodsd
      stosd
      lodsd
      stosd

      pop si
      pop ds
      mov es:[si],di   ;Адрес следующего файла
      mov Next_file,si

      mov ax,Prev_file ;Адрес предыдущего файла
      mov es:[si+2],ax
      mov Prev_file,si

      mov Current_offset,di ;Сохраним текущее смещение
      ret
Move_file endp

; === Вывод наденных файлов на экран ===
Out_files proc
      ;int 3  ;--- !!! ОБЯЗАТЕЛЬНО установите здесь точку останова !!!

      mov bl,Number_files  ;BL указывает на количество выводимых файлов
      push ds
      push es
      push 0B800h
      pop es

      mov si,Start_file ;SI = начальную позицию при выводе на экран
      mov ah,1Bh
      mov dx,0302h      ;Начало для вывода файлов
      mov ds,Seg_files  ;DS=сегмент найденных файлов в памяти

Next_fileout:
      mov di,[si]

      mov bh,[si+4]
      push di
      add si,5

      call Print_string     ;Выводим очередной файл...

      call Print_fsize      ;Выводим размер файла...

      call Get_status       ;Проверим статус файла...

      pop si
      or si,si          ;Последний файл?
      jz Exit_files     ;Тогда выходим.

      add dx,0100h ;Иначе увеличиваем DH на 1 для вывода следующего имени...
      dec bl       ;Уменьшаем количество выводимых файлов на 1
      jnz short Next_fileout ;Уже 0? Тогда больше выводить не нужно...

Exit_files:
      pop es
      pop ds
      ret

Number_files db 21 ;Количество выводимых файлов на экран.
Start_file dw 500  ;Адрес (смещение) стартового файла для вывода на экран
                   ;Первые 500 байт отводятся для функций 714Eh и 714Fh, куда
                   ;они будут помещать информацию о найденном файле.
                   ;Что-то вроде DTA, только "посовременней"...
Out_files endp

; === Проверяем статус файла ===
Get_status proc
      pusha
      mov ah,1Bh   ;Обычный файл...

      or bh,bh     ;Есть какие-нибудь метки?
      jz Quit_sts  ;Нет - на выход 

      mov ah,30h
      cmp bh,1     ;Это текущий файл?
      jz Quit_sts  ;Да - на выход 

      mov ah,1Eh
      cmp bh,2     ;Это отмеченный файл?
      jz Quit_sts  ;Да - на выход 

      mov ah,3Eh   ;Получается, что текущий + отмеченный...

Quit_sts:
      mov dl,1     ;Разрисовываем его...
      mov cx,78
      call Color_line
      popa
      ret
Get_status endp

; === Выводим размер файла ===
Print_fsize proc
      pusha
      push ds

      mov eax,ds:[si]   ;Получим первую часть размера файла
      mov ebx,ds:[si+4] ;Получим вторую часть

      push cs
      pop ds

      mov si,offset Number_dec ;Занесем размер файла в переменную Number_dec
      mov dword ptr [si],ebx   ;Процедура Out_dec будет выводить число,
      mov dword ptr [si+4],eax ;которое находится именно в этой переменной.

      mov dl,50        ;DL указывает на колонку
      mov ah,1Bh       ;AH содержит атрибуты для выводимого числа
      call Out_dec     ;Выводим число

      pop ds
      popa
      ret
Print_fsize endp</textarea></font></td>
    </tr>
    <tr>
        <td align="center" width="50%"><br>
        <font size="4">Keyboard.asm</font> <br>
        <font size="4"><!--webbot bot="Validation" b-value-required="TRUE"
        i-minimum-length="1" i-maximum-length="80" --><textarea name="Keyboard" rows="5"
        cols="21">; ==== KEYBOARD.ASM - процедуры работы с клавиатурой ====

;!!! Теперь над этими процедурами придется поработать "на славу" !!!

;Хотите выучить Ассемблер, научиться "ковыряться" в коде других программ -
;разбирайте!

;  === Ждем нажатия клавиши ===
Pause proc
      mov ah,0
      int 16h
      ret
Pause endp

; === Клавиша вниз ===
;Пользователь нажал клавишу вниз! Переводим курсор на следующий файл...
Down_pressed proc
      ;int 3  ;--- !!! ОБЯЗАТЕЛЬНО установите здесь точку останова !!!

      push es
      mov es,Seg_files
      mov di,Current_file

      mov ax,es:[di]
      or ax,ax
      jz Lowest_file

      mov Current_file,ax
      and byte ptr es:[di+4],11111110b

      mov di,ax
      or byte ptr es:[di+4],1

Lowest_file:
      pop es
      ret
Down_pressed endp

; === Клавиша вверх ===
;Пользователь нажал клавишу вврех! Переводим курсор на предыдущий файл...
Up_pressed proc
      ;int 3  ;--- !!! ОБЯЗАТЕЛЬНО установите здесь точку останова !!!

      push es
      mov es,Seg_files
      mov di,Current_file

      mov ax,es:[di+2]
      or ax,ax
      jz Uppest_file

      mov Current_file,ax
      and byte ptr es:[di+4],11111110b

      mov di,ax
      or byte ptr es:[di+4],1

Uppest_file:
      pop es
      ret
Up_pressed endp

; === Клавиша Enter ===
Enter_pressed proc
;Пользователь нажал клавишу Enter! Меняем текущий каталог...
;!!! Обратите внимание, что мы пока не проверяем, нажал ли пользователь Enter
;на каталоге или файле !!!
;!!! Более того, мы "коряво" переходим на каталог верхнего уровня (..) !!!

      push ds
      push cs
      pop es

      mov si,Current_file
      add si,5

      mov di,Current_dir
      mov cx,0FFFFh
      xor al,al
      repne scasb
      dec di

      mov ds,Seg_files

Next_cdir:
      lodsb
      or al,al
      jz Got_dir
      stosb
      jmp short Next_cdir

Got_dir:
      mov ax,005Ch  ;'\'
      stosw

      pop ds

      call Draw_main_frame
      call Change_dir
      call Get_files
      call Out_files

      ret
Enter_pressed endp</textarea></font></td>
        <td align="center" width="50%"><br>
        <font size="4">Main.asm</font> <br>
        <font size="4"><!--webbot bot="Validation" b-value-required="TRUE"
        i-minimum-length="1" i-maximum-length="80" --><textarea name="Main" rows="5"
        cols="21">;                  === MAIN.ASM - Головная процедура ===

Main_proc proc

      call Hide_cursor ;прячем курсор

      call Prepare_all

      call Save_mainscr ;сохраним содержимое экрана...

Re_Read_dir:
      call Draw_main_frame ;Рисуем головную рамку

      call Get_curdir ;Получаем текущий каталог

      call Change_dir ;Делаем его текущим

      call Get_files  ;Читаем каталог в память

Out_filesl:
      call Out_files ;Выводим файлы на экран

Next_key:
      call Pause
      or al,al
      jz Ext_code  ;Это расширенный ASCII-код клавиши? Да - проверяем его. 

      cmp al,27    ;Нажали ESC?
      je Quit_prg  ;Да! На метку 

      cmp al,13
      je Enter_prsd

      jmp short Next_key

Quit_prg:
      call Quit_prog ;Подтвердим намерения пользователя выйти из программы.
      jnc Next_key   ;Пользователь подтвердил выход? НЕТ? Тогда на Next_key 

;Да, подтвердил (а жаль!). Тогда выходим.
      call Restore_mainscr ;восстановим содержимое экрана
      call Restore_cursor  ;восстановим позицию курсор

      ret ;Выходим из процедуры MAIN.ASM, а затем сразу в DOS!

Enter_prsd:
      call Enter_pressed
      jmp short Next_key

Ext_code:
      cmp ah,60h         ;Нажали Ctrl+F3?
      je Re_read_dir     ;Да - перечитываем каталог .

      cmp ah,62h         ;Нажали Ctrl+F5?
      je User_screenl    ;Да - показываем экран пользователю .

      cmp ah,50h         ;Стрелка вниз?
      je Key_down

      cmp ah,48h
      je Key_up

      jmp short Next_key ;Нет - ждем другую клавишу 

Key_down:
      call Down_pressed
      jmp Out_filesl

Key_up:
      call Up_pressed
      jmp Out_filesl

User_screenl:
      mov ax,0501h ;Показываем пользователю 1 видеостраницу.
      int 10h
      call Pause   ;Ждем до тех пор, пока пользователь не налюбуется...

      mov ax,0500h ;Опять на нулевую устанавливаем.
      int 10h
      jmp short Next_key ;Ждем дальше... 
Main_proc endp

; === Готовим все необходимое для работы ===
Prepare_all proc
      call Prepare_memory ;Отводим память

      ret
Prepare_all endp

;--- Ужимаем память ---
Prepare_memory proc
      mov bx,offset Finish
      shr bx,4
      inc bx
      mov ah,4Ah
      int 21h

      mov ah,48h
      mov bx,1000h
      int 21h

      mov Seg_files,ax

      ret
Prepare_memory endp

; === Получаем текущий диск+каталог ===
Get_curdir proc
      mov dword ptr [Current_dir],005C3A43h ;Заносим ASCIZ C:\

      mov ah,19h
      int 21h   ;Получаем текущий диск
      add al,'A'
      mov byte ptr [Current_dir],al

      ret
Get_curdir endp

; === Change_dir ===
Change_dir proc
      mov ax,713Bh
      mov dx,offset Current_dir
      int 21h

      push 0B800h
      pop es
      mov ah,1Fh
      mov dx,0102h
      mov si,offset Current_dir
      call Print_string

      ret
Change_dir endp


; === Выходим из программы? ===
Quit_prog proc
      push 1     ;высота рамки
      push offset Mess_quitl ;ширина рамки
      push 4F00h ;цвет - светло-белый на синем фоне
      push offset Mess_qup   ;надпись вверху рамки (если 0, то не выводить)
      push 0     ;надпись внизу рамки (если 0, то не выводить)
      push offset Mess_quit  ;сообщение внутри рамки
      push 01b   ;Копировать экран, но не выводить верхнюю линию
      call Draw_frame ;Рисуем рамку

      call Pause
      call Restore_scr ;Восстановим сохранунную часть экрана.

      cmp al,'Y'       ;Нажали 'Y' / 'y' / Enter (13)?
      je Yes_quit      ;Да! 
      cmp al,'y'
      je Yes_quit
      cmp al,13
      je Yes_quit

      clc  ;Ставим меточку, что нажали другую клавишу (сбросим флаг переноса).
      ret

Yes_quit:
      stc  ;Установим флаг переноса (нажали 'Y', значит выходим)...
      ret
Quit_prog endp

; === Рисуем головную рамку ===
Draw_main_frame proc
      push 23     ;высота рамки
      push 78     ;ширина рамки (т.е. на весь экран)
      push Main_color ;цвет - светло-белый на синем фоне
      push offset Mess_head ;надпись вверху рамки (если 0, то не выводить)
      push offset Mess_down ;надпись внизу рамки (если 0, то не выводить)
      push 0      ;сообщение внутри рамки (если 0, то не выводить)
      push 10b    ;Экран не копировать, но вывести верхнюю линию.
      call Draw_frame ;Рисуем рамку на весь экран
      ret
Draw_main_frame endp</textarea></font></td>
    </tr>
    <tr>
        <td align="center"><p align="center"><br>
        <font size="4">Messages.asm</font> <br>
        <font size="4"><!--webbot bot="Validation" b-value-required="TRUE"
        i-minimum-length="1" i-maximum-length="80" --><textarea name="Messages"
        rows="5" cols="21">;   === MESSAGES.ASM - Конфигурационный файл ===

Begin_ini equ $

Mess_about db 0Ah, 0Dh, 'SuperShell - оболочка для DOS, написанная на Ассемблере.',0Ah, 0Dh
           db 'Рассылка "Ассемблер? Это просто! Учимся программировать", Выпуск № 026',0Ah,0Dh
           db 'http://www.Kalashnikoff.ru. E-mail: Assembler@Kalashnikoff.ru',0Ah,0Dh,0Ah
           db '(C) Авторские права на файлы-приложения принадлежат всем подписчикам рассылки.',0Ah, 0Dh, 0Ah
           db 9,9,'=== Россия, Москва, 2001 год ===',0Ah,0Dh,'$'

Main_color dw 1F00h
Mess_head db 1Eh, ' Super Shell, Версия 1.0 ',0
Mess_down db 1Dh, ' Россия, Москва, 2001 ',0

Mess_qup db 4Eh, ' Выход ',0
Mess_quit db 4Bh, ' Вы действительно хотите выйти в DOS (Y/N)?',0
Mess_quitl equ $-Mess_quit-1 ;Один байт занимает код цвета (4Bh)

Size_ini equ $-Begin_ini</textarea></font></p>
        </td>
        <td align="center"><font size="4">Data.asm</font> <br>
        <font size="4"><!--webbot bot="Validation" b-value-required="TRUE"
        i-minimum-length="1" i-maximum-length="80" --><textarea name="Data"
        rows="5" cols="21">;  === DATA.ASM - данные оболочки ===

;               ==== ПЕРЕМЕННЫЕ ====

Num_attr db ?   ;переменная для атрибутов

Num_DX dw ?

Video_page db 0 ;текущая видеостраница

Pos_cursor dw ? ;главная позиция курсора

Handle dw ?     ;Номер файла

Current_file dw ? ;Текущий файл


; --- Данные для процедуры Draw_frame ---
Height_X equ [bp+12] ;высота рамки
Width_Y  equ [bp+10] ;ширина рамки
Attr     equ [bp+8]  ;атрибуты рамки
Mess_up  equ [bp+6]  ;сообщение вверху рамки
Mess_dn  equ [bp+4]  ;сообщение внизу рамки
Mess_ins equ [bp+2]  ;сообщение внутри рамки
Other    equ [bp]    ;иная конфигурация окна</textarea></font></td>
    </tr>
</table>
</center></div>

<p align="center"><a TARGET=_blank href="http://www.Kalashnikoff.ru/cgi-bin/download.cgi?Assembler/Issues/Enclosures/Sshell26.exe"><font size="4"><b><u>Приложение в Интернете</u></b></font></a></p>


<p><b>ВНИМАНИЕ!</b> Прилагаемый алгоритм
перехода по файлам при нажатии на &quot;стрелку
вниз&quot; и &quot;стрелку вверх&quot; очень
сложный и не доделанный (т.е. содержит море
ошибок)! Читайте ниже...</p>

<p align="center">_____________</p>

<p>Что нового у нас? Теперь оболочка сразу
после загрузки переходит в корневой
каталог текущего диска, читает файлы,
выводит их длинные имена на экран, размеры,
текущий каталог вверху, а также...</p>

<p>...А также теперь мы можем самостоятельно
менять каталоги, т.е. лазить по диску! И еще
перечитывать его (Ctrl+F3)!</p>

<p>Обратите внимание, что теперь &quot;бегает&quot;
(как это?) &quot;курсорчик&quot; (что ли?). В общем,
почти как в &quot;настоящем &quot;Нортоне&quot;! Только это все
далеко не доделано (например, программа
пытается перейти в каталог, которые на
самом деле является файлом! Или не делает
прокрутку на экране. Если файлов много, и
они не вмещаются на экран, то курсор просто
исчезает из поля видения, когда мы
переходим нижнюю границу. Проще всего самим
посмотреть, что делает оболочка и прямо
сейчас). Почему мы не доделали ее?</p>

<p>Дело в том, что все не так просто, как
кажется. Я вообще, когда увидел &quot;Нортон&quot;
первый раз, то подумал, что курсорчик должен
бегать по файлам обязательно. Т.е. это как бы
не забота программы, а так, само собой. Потом,
со временем, я понял, что все, что происходит
на экране, должен делать программист. Даже
этот злосчастный курсорчик...</p>

<p>Интересно, как вообще
можно сделать выбор файла (т.е. найти
отмеченный или текущий файл в памяти, куда
мы прочитали каталог)? Насколько это
сложно - судить вам...</p>

<p>Рассмотрим алгоритм считывания файлов в
память и перемещение по ним &quot;стрелками&quot;.</p>

<p><b>Чтение файлов из каталога и размещение
их в отведенной памяти.</b></p>

<p>Есть несколько способов размещения
файлов в отведенной памяти программы.</p>

<p>1. Самый примитивный и простой.
Предположим, что работаем мы ТОЛЬКО с
короткими именами файлов (как в предыдущих
версиях DOS, когда никто и &quot;слыхом не
слыхивал&quot; об имени файла длиной более 200
символов). Раньше все файлы имели длину не
больше чем 12 байт (8 символов имя файла + &quot;точка&quot;
+ 3 символа расширение). Тогда отводим 13 байт
памяти для каждого файла. Почему 13? Первый
байт будет сигнализировать о статусе файла
(т.е. либо отмеченный, либо текущий (на
который будет указывать курсорчик), либо
текущий + отмеченный). Статус файла будем
получать при проведении некоторых операций
с файлами (копирование, удаление, запуск и
пр.). Т.о. в 64Кб отведенной памяти можно
поместить более 5.000 файлов!</p>

<p>Чем хорош данный способ?</p>

<p>По файлам просто &quot;бегать&quot; и искать
отмеченный или текущий. Просто перемещаем
указатель на 13 и... получаем смещение
следующего файл. Вы улавливаете мысль? Если
нет, то попробуйте &quot;проработать&quot; наш
файл-приложение под отладчиком. Будет о-о-очень
сложно, но нужно!</p>

<p>2. Второй способ гораздо сложнее, зато
экономит память. Файлы с длинными именами
могут содержать чуть более 255 символов.
Теперь посчитаем, сколько файлов мы сможем
поместить в 64Кб: 65536/255=256. Но некоторые
каталоги содержат 400 и более файлов... Тогда
нужно отводить еще один, два, три сегмента или
использовать расширенную память (но этим
будем заниматься позже), что усложнит
задачу.</p>

<p><b>Как мы поступаем в оболочке?</b></p>

<p>Допустим, в некотором каталоге существуют
следующие файлы/каталоги:</p>

1. assm.txt<br>


2. Мои документы<br>


3. Супер новый файл!.asm
<p>Теперь внимательно следите за тем, как
размещаем их в памяти. Для этого нужно будет
вооружиться листком и ручкой (что я и делал
при составлении данной таблицы). Допустим,
мы размещаем файлы в сегменте 1234h, начиная со
смещения 0000h (обратите внимание, что в
оболочке файлы размещаются со смещения 500!):</p>
<table border="1" width="100%" cellspacing="0">
  <tr>
    <td width="13%" align="center" bgcolor="#9CCDCD"><b>Адрес</b></td>
    <td width="18%" align="center" bgcolor="#9CCDCD"><b>Статус файла
      (один байт)</b></td>
    <td width="24%" align="center" bgcolor="#9CCDCD"><b>Адрес
      следующего файла (два байта)</b></td>
    <td width="25%" align="center" bgcolor="#9CCDCD"><b>Адрес
      предыдущего файла (два байта)</b></td>
    <td width="45%" align="center" bgcolor="#9CCDCD"><b>Имя файла +
      ASCII 0</b></td>
  </tr>
  <tr>
    <td width="13%" align="center">1234:0000h</td>
    <td width="18%" align="center">0000h</td>
    <td width="24%" align="center">0001h</td>
    <td width="25%" align="center">0003h</td>
    <td width="45%" align="center">0005h&nbsp;<br>


      (assm.txt (8 + ASCCI 0 = 9 байт)</td>
  </tr>
  <tr>
    <td width="13%" align="center">1234:000Dh</td>
    <td width="18%" align="center">000Dh</td>
    <td width="24%" align="center">000Eh</td>
    <td width="25%" align="center">0010h</td>
    <td width="45%" align="center">0012h (Мои документы = 13 + ASCII
      0 = 14 байт)</td>
  </tr>
  <tr>
    <td width="13%" align="center">1234:001Fh</td>
    <td width="18%" align="center">001Fh</td>
    <td width="24%" align="center">0020h</td>
    <td width="25%" align="center">0022h</td>
    <td width="45%" align="center">0024h (Супер новый файл!.asm =
      21 + ASCII 0 = 22 байта)</td>
  </tr>
</table>
<p><i>Примечание.</i> <b>ВНИМАТЕЛЬНО</b> изучите
таблицу. Посмотрите, насколько поля,
приведенные в данной таблице отличаются от
нашей оболочки.</p>
<p>Теперь два слова.</p>
<p>Перед первым файлом мы заносим в поле &quot;<b>Адрес
предыдущего файла</b>&quot; 0000h. Когда
пользователь нажмет &quot;стрелку вверх&quot; на
верхнем файле, то наша программа, прочитав
смещение предыдущего файла, &quot;поймет&quot;,
что &quot;выше&quot; уже файлов нет и ничего не
сделает.</p>
<p>Перед последним файлом занесем в поле <b>&quot;Адрес
следующего файла&quot;</b> также 0000h. Когда
пользователь нажмет &quot;стрелку вниз&quot;, то
наша программа &quot;поймет&quot;, что &quot;ниже&quot;
уже файлов нет и ничего не произойдет.</p>
<p>Если вы до сих пор не поняли, о чем идет
речь, то нужно посидеть еще над файлом-приложением
и поковыряться в нем до утра. Уверяю вас: то,
что делает наша оболочка, когда заносит
файлы в буфер, - почти &quot;ювелирная&quot;
работа. Занесенный по ошибке один байт (&quot;плюс-минус&quot;)
разрушит всю базу данных по файлам.
Надеюсь, что принцип будет понятен, когда вы
проведете несколько часов перед монитором...</p>
<p><b><i>&quot;Зачем мне нужно сидеть перед
монитором и ковыряться&quot;?</i></b></p>
<p>Отвечу вопросом на вопрос: &quot;Вы хотите
научиться &quot;разбирать по полочкам&quot;
чужие программы?&quot; Поверьте, простая
программа, написанная на Паскале, гораздо
сложнее &quot;понимается&quot; под отладчиком, чем аналогичная
на&nbsp; Ассемблере. Сегодня-завтра вы
захотите разобрать чужую программу (ну, или
уже захотели!), да мало что получится, если
вы не разберете наш файл-приложение. Опыт
приходит со временем, и знания
увеличиваются пропорционально часам,
проведенным за отладчиком! Помните это!</p>
<p><b>На сегодня все!</b></p>

<hr>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="100%"
bgcolor="#9CCDCD">
    <tr>
        <td align="center" width="100%"><a name="Surprise"><font
        color="#004080" size="5"><strong>Сюрприз</strong></font></a></td>
    </tr>
</table>
</center></div>

<p align="left"><font size="4"><strong>Уважаемые
подписчики!</strong></font></p>

<p align="left"><font size="3">Я благодарен всем
вам за то, что читаете
рассылку, что присылаете вопросы,
программы, стараетесь всеми силами
помочь мне, поддерживаете морально.
Поверьте: я внимательно знакомлюсь
со всеми письмами, приходящими ко
мне на ящик. А писем, уверяю вас, немало... Если есть возможность -
отвечаю. Кто все-таки не получил
ответ - извините... Времени у меня не
так и много, вы знаете...</font></p>

<p align="left"><font size="3">В общем,
отвлекаюсь я. Дело в том, что я
приготовил вам небольшой сюрприз, ма-а-аленький подарок...
К сожалению, не все вы сможете им
воспользоваться (если можно так
сказать), но все же... Итак, дорогие
мои, жду вас всех прямо сейчас </font><a
href="http://www.Kalashnikoff.ru/surprise.html"><font size="3">здесь</font></a><font
size="3">. Очень надеюсь, что... В общем,
обсудим позже...</font></p>

<hr>

<p><font size="4" face="Arbat-Bold"><strong>С
уважением,</strong></font></p>

<p><font size="3"><strong>Калашников Олег: </strong></font><a
href="mailto:Assembler@Kalashnikoff.ru"><font size="3"><strong>Assembler@Kalashnikoff.ru</strong></font></a><font
size="3"><strong> <br>
ICQ No.: </strong></font><font color="#226622" size="3"><strong>68951340</strong></font><font
size="3"><strong> <br>
URL сайта подписчиков: </strong></font><a
href="http://www.Kalashnikoff.ru"><font size="3"><strong>http://www.Kalashnikoff.ru</strong></font></a></p>

<p align="left"><strong>______________</strong></p>

<p align="left"><strong>По вопросам
сотрудничества, рекламы и
спонсорства обращайтесь:</strong></p>

<ol>
    <li><font size="2">Публичное размещение
        материала из рассылки: </font><a
        href="mailto:Cooperation@Kalashnikoff.ru"><font size="2">Cooperation@Kalashnikoff.ru</font></a></li>
    <li><font size="2">Реклама на сайте, в книге и рассылках: </font><a
        href="http://www.Kalashnikoff.ru/Reklama.html"><font
        size="2">http://www.Kalashnikoff.ru/Reklama.html</font></a><font
        size="2">, </font><a
        href="mailto:Reklama@Kalashnikoff.ru"><font size="2">Reklama@Kalashnikoff.ru</font></a></li>
    <li><font size="2">Издание книги
        (спонсорство): </font><a
        href="mailto:Sponsor@Kalashnikoff.ru"><font size="2">Sponsor@Kalashnikoff.ru</font></a></li>
</ol>

<hr>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0" width="100%"
bgcolor="#DDEEFF" bordercolor="#808080"
bordercolorlight="#FFFFFF">
    <tr>
        <td colspan="3" bgcolor="#BDDEFF"><font color="#400040"
        size="1"><strong>(C) Москва, 2001.
        Авторское право принадлежит
        Калашникову О.А.</strong> Публичное
        размещение материала из
        рассылки, а также его
        использование полностью или
        частично в коммерческих или
        иных подобных целях без
        письменного согласия автора
        влечет ответственность за
        нарушение авторских прав.</font></td>
    </tr>
</table>
</center></div>

<hr>

<p align="center">[<a href="027.htm">Следующий выпуск</a>] [<a target=_BLANK href="http://www.Kalashnikoff.ru/">На главную страницу</a>]</p>

<HR NOSHADE><CENTER>
<!-- SpyLOG v2 f:0211 --><script language="javascript">  
u="u496.71.spylog.com";d=document;nv=navigator;na=nv.appName;p=1;  
bv=Math.round(parseFloat(nv.appVersion)*100);  
n=(na.substring(0,2)=="Mi")?0:1;rn=Math.random();z="p="+p+"&rn="+rn;y="";  
y+="<a href='http://"+u+"/cnt?f=3&p="+p+"&rn="+rn+"' target=_blank>";  
y+="<img src='http://"+u+"/cnt?"+z+  
"&r="+escape(d.referrer)+"&pg="+escape(window.location.href)+"' border=0 width=88 height=31 alt='SpyLOG'>";  
y+="</a>"; d.write(y);if(!n) { d.write("<"+"!--"); }//--></script><noscript><p align="center"><a 
href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" 
target="_blank"><img src="http://u496.71.spylog.com/cnt?p=1" alt="SpyLOG" align="middle" border="0"></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"></noscript></a> 
<a href="http://u496.71.spylog.com/cnt?f=3&amp;p=1" target="_blank"> 
<script language="javascript1.2"><!-- if(!n) { d.write("--"+">"); }//--></script></a> 
<!-- SpyLOG --> 
 
 <a target=_top href="http://www.one.ru"><img src="http://cnt.one.ru/cgi-bin/cnt.cgi?id=16871&t=9" width=88 height=31 alt="be number one" border=0></a> 
 
 <script language="JavaScript"><!-- 
d=document;a='';a+=';r='+escape(d.referrer) 
js=10//--></script><script language="JavaScript1.1"><!-- 
a+=';j='+navigator.javaEnabled() 
js=11//--></script><script language="JavaScript1.2"><!-- 
s=screen;a+=';s='+s.width+'*'+s.height 
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth) 
js=12//--></script><script language="JavaScript1.3"><!-- 
js=13//--></script><script language="JavaScript"><!-- 
d.write('<a href="http://top.list.ru/jump?from=87856"'+ 
' target=_top><img src="http://top.list.ru/counter'+ 
'?id=87856;t=54;js='+js+a+';rand='+Math.random()+ 
'" alt="TopList"'+' border=0 height=31 width=88></a>') 
if(js>11)d.write('<'+'!-- ')//--></script><noscript><a 
target=_top href="http://top.list.ru/jump?from=87856"><img 
src="http://top.list.ru/counter?js=na;id=87856;t=54" 
border=0 height=31 width=88 
alt="TopList"></a></noscript><script language="JavaScript"><!-- 
if(js>11)d.write('--'+'>')//--></script> 
 
<br><br> 

</body>
</html>
