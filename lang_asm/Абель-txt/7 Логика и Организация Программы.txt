ГЛАВА 7. Логика и Организация Программы

------------------------------------------------------------

Логика и Организация Программы

Цель:  Раскрыть  механизм  передачи  управления  в программе
(циклы  и переходы)  для логических сравнений  и программной
организации.

ВВЕДЕНИЕ
------------------------------------------------------------

   До этой главы примеры выполнялись последовательно команда
за командой. Однако, программируемые задачи редко бывают так
просты.  Большинство программ содержат ряд циклов, в которых
несколько  команд  повторяются  до  достижения определенного
требования,  и  различные  проверки,  определяюшие  какие из
нескольких действий  следует выполнять.  Обычным требованием
является   проверка   -   должна   ли   программа  завершить
выполнение.
   Эти требования  включают  передачу  управления  по адресу
команды, которая не находится непосредственно за выполняемой
в текущий момент командой. Передача управления может осущест
вляться вперед для выполнения новой группы команд  или назад
для повторения уже выполненных команд.
   Некоторые команды  могут  передавать  управление, изменяя
нормальную    последовательность    шагов   непосредственной
модификацией  значения смещения в командном  указателе. Ниже
приведены  четыре  способа  передачи  управления  (все будут
рассмотрены в этой главе):

          Безусловный переход:  JMP
          Цикл:                 LOOP
          Условный переход:     Jnnn (больше,меньше,равно)
          Вызов процедуры:      CALL

   Заметим, что имеется три типа адресов: SHORT, NEAR и FAR.
Адресация SHORT используется при  циклах, условных пеpеходах
и некоторых  безусловных  переходах.  Адресация  NEAR  и FAR
используется  для  вызовов  процедур  (CALL)  и  безусловных
переходов,  которые не квалифицируются ,  как SHORT. Все три
типа передачи управления воздействуют на содержимое регистра
IP; тип FAR также изменяет регистр CS.

КОМАНДА JMP
------------------------------------------------------------

   Одной из команд обычно используемых  для передачи управле
ния является команда JMP.  Эта команда выполняет безусловный
переход,  т.е.  обеспечивает  передачу  управления при любых
обстоятельствах.




Ассемблер для IBM PC. Глава 7                            133


   В COM-программе на рис.  7.1  используется команда JMP. В
pегистры AX,  BX,  и CX  загружается значение  1,  и затем в
цикле выполняются следующие операции:

          прибавить 1 к регистру AX,
          прибавить AX к BX,
          удвоить значение в регистре CX.

Повторение цикла приводит к увеличению  содержимого регистра
AX:  1,2,3,4...,  регистра BX:  1,3,6,10...,  и регистра CX:
1,2,4,8... Начало цикла имеет метку, в данном случае, A20: -
двоетичие  oбозначает,  что метка находится внутри процедуры
(в  данном  случае  BEGIN)  в сегменте  кода.  В конце цикла
находится команда

                         JMP  A20

которая указывает на то, что управление должно быть передано
команде c меткой A20.  Обратите внимание, что адресная метка
в операнде  команды   указывается без двоеточия. Данный цикл
не имеет выхода и приводит к бесконечному выполнению - такие
циклы обычно не используются.

------------------------------------------------------------
------------------------------------------------------------
          Рис.7.1. Использование команды JMP.

   Метку можно кодировать на одной строке с командой:

                    A20:   ADD   AX,01

или на отдельной строке:

                    A20:
                           ADD   AX,01

В обоих случаях адрес  A20  указывает на первый байт команды
ADD.  Двоеточие в метке A20  указывает на тип метки  - NEAR.
Запомните:  отсутствие  двоеточия  в  метке  является частой
ошибкой.  В нашем примере  A20  соответствует  -9  байтам от
команды  JMP,  в  чем  можно  убедиться  по  объектному коду
команды -  EBF7.  EB  представляет  собой  машинный  код для
короткого  перехода  JMP,  а  F7  -  отрицательное  значение
смещения  (-9).  Команда  JMP  прибавляет  F7  к  командному
указателю  (IP),  котоpый  содержит адрес  команды после JMP
(0112):

                              Дес. Шест.
     Командный указатель:     274  112
     Адрес в команде JMP:      -9   F7 (двоичное дополнение)
     Адрес перехода:          265  109





Ассемблер для IBM PC. Глава 7                            134


В результате сложения получается адрес перехода - шест. 109.
Проверьте  по  листингу  программы,  что относительный адрес
метки  действительно соответствует  шест.109. Соответственно
операнд в команде  JMP для перехода  вперед имеет положитель
ное значение.
   Команда JMP для перехода  в пределах  -128  до  +127 байт
имеет  тип   SHORT.   Ассемблер  генерирует  в  этом  случае
однобайтовый операнд в пределах  от  00  до FF. Команда JMP,
превосходящая эти пределы,  получает  тип FAR,  для которого
генерируется другой  машинный  код  и  двухбайтовый операнд.
Ассемблер в первом  просмотре исходной  программы определяет
длину каждой команды.  Однако, команда JMP может быть длиной
два  или три байта.  Если  к моменту  просмотра  команды JMP
ассемблер  уже  вычислил  значение  опеpанда  (при  переходе
назад):
               A50:
                    ...
                    JMP  A50

то он генерирует двухбайтовую команду. Если ассемблер еще не
вычислил значение операнда (при переходе вперед)

                    JMP  A90
                    ...
               A90:

то он  не знает тип  перехода NEAR или FAR,  и автоматически
генерирует  3-х байтовую  команду.  Для того,  чтобы указать
ассемблеру на необходимость  генерации двухбайтовой команды,
следует использовать оператор SHORT:

                    JMP  SHORT A90
                    ...
               A90:

   В  качестве  полезного  упражнения,   введите  программу,
проассемблируйте ее,  скомпануйте и переведите в COM-формат.
Определение данных не  требуется, поскольку непосредственные
операнды  генерируют  все  необходимые  данные.  Используйте
отладчик  DEBUG  для  пошагового  выполнения   COM-модуля  и
просмотрите несколько  повторений  цикла.  Когда  регистр AX
будет содержать 08,  BX и CX  увеличатся  до  шест. 24 (дес.
36)  и  шест.  80  (дес. 128), соответственно. Для выхода из
отладчика используйте команду Q.

КОМАНДА LOOP
------------------------------------------------------------

   Команда JMP в  примере на рис.  7.1 реализует бесконечный
цикл.   Но  более  вероятно  подпрограмма  должна  выполнять
определенное число циклов.  Команда LOOP, которая служит для
этой цели,  использует начальное значение  в регистре  CX. В
каждом цикле команда LOOP автоматически уменьшает содержимое



Ассемблер для IBM PC. Глава 7                            135


регистра  CX  на  1.  Пока  значение  в  CX  не  равно нулю,
управление  передается  по адресу,  указанному в операнде, и
если в CX будет 0,  управление переходит  на слудующую после
LOOP команду.
   Программа на рис. 7.2, иллюстрирующая использование коман
ды LOOP, выполняет действия, аналогичные примеру на рис. 7.1
за  исключением  того,  что  после  десяти  циклов программа
завершается. Команда MOV инициализирует регистр CX значением
10.  Так  как  команда  LOOP  использует  регистр  CX,  то в
программе для удвоения начального значения 1 вместо регистра
CX используется DX.  Команда JMP A20  заменена командой LOOP
и для эффективности команда ADD AX,01  заменена командой INC
AX (увеличение AX на 1).
   Аналогично команде JMP,  операнд команды  LOOP определяет
расстояние от конца команды LOOP  до адреса метки  A20, кото
рое прибавляется  к  содержимому  командного  указателя. Для
команды LOOP это расстояние  должно быть в пределах  от -128
до +127 байт. Если  операнд превышает эти границы, то ассемб
лер выдаст сообщение "Relative jump out of range" (превышены
границы перехода).
   Для   проверки   команды   LOOP   рекомендуется  изменить
соответствующим  образом программу,  приведенную на рис.7.1,
выполнить ее ассемблирование,  компановку и преобразование в
COM-файл.  Для трассировки  всех  десяти  циклов используйте
отладчик DEBUG.  Когда в значение регистре CX  уменьшится до
нуля,  содержимое регистpов AX, BX и DX будет соответственно
шест.  000B,  0042  и 0400.  Для выхода из отладчика введите
команду Q.
   Дополнительно существует две разновидности команды LOOP -
это LOOPE (или  LOOPZ)  и LOOPNE  (или  LOOPNZ). Обе команды
также  уменьшают значение  регистра  CX на 1.  Команда LOOPE
передает управление  по  адресу  операнда,  если  регистр CX
имеет ненулевое  значение  и  флаг  нуля  установлен (ZF=1).
Команда LOOPNE передает управление по  адресу операнда, если
регистр CX  имеет ненулевое значение  и  флаг  нуля  сброшен
(ZF=0).

------------------------------------------------------------
------------------------------------------------------------
          Рис. 7.2. Использование команды LOOP.

ФЛАГОВЫЙ РЕГИСТР
------------------------------------------------------------

   Следующий материал данной главы  требует более детального
ознакомления с флаговым регистром.  Этот pегистр содержит 16
бит  флагов,  которые  управляются различными  командами для
индикации состояния операции.  Во всех случаях флаги сохраня
ют свое значение до тех пор,  пока другая команда не изменит
его. Флаговый регистр содержит следующие девять используемых
бит (звездочками отмечены неиспользуемые биты):

     Номер бита:    15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0



Ассемблер для IBM PC. Глава 7                            136


     Флаг:           *  *  *  *  O  D I T S Z * A * P * C

Рассмотрим эти флаги в последовательности справа налево.

   CF  (Carry  Flag)  -  флаг  переноса.  Содержит  значение
"переносов"  (0  или 1) из  старшего разряда при арифметичес
ких  операциях и некоторых операциях  сдвига  и циклического
сдвига (см. гл.12).

   PF  (Parity   Flag)  -  флаг  четности. Проверяет младшие
восемь бит pезультатов операций над данными.  Нечетное число
бит приводит к установке этого флага в 0, а четное - в 1. Не
следует путать флаг четности с битом контроля на четность.

   AF (Auxiliary Carry Flag) - дополнительный флаг переноса.
Устанавливается в 1,  если  арифметическая операция приводит
к   переносу четвертого справа бита (бит номер 3) в регистро
вой однобайтовой  команде.  Данный  флаг   имеет отношение к
арифметическим  операциям  над  символами  кода  ASCII  и  к
десятичным упакованным полям.

   ZF (Zero Flag)  -  флаг  нуля. Устанавливается в качестве
результата  aрифметических  команд   и команд сравнения. Как
это  ни  странно,  ненулевой  результат приводит к установке
нулевого  значения  этого   флага,  а нулевой -  к установке
единичного  значения.  Кажущееся   несоответствие  является,
однако,  логически  правильным,  так  как 0 обозначает "нет"
(т.е.  результат не равен нулю),  а единица  обозначаeт "да"
(т.е. результат равен нулю). Команды условного перехода JE и
JZ проверяют этот флаг.

   SF (SIgn Flag) - знаковый флаг. Устанавливается в соответ
ствии со  знаком результата (старшего бита)  после  арифмети
ческих опеpаций:  положительный результат устанавливает 0, а
отрицательный  -  1.  Команды  условного  перехода  JG  и JL
проверяют этот флаг.

   TF  (Trap Flag)  -  флаг пошагового выполнения. Этот флаг
вам уже приходилось устанавливать,  когда  использовалась ко
манда Т в отладчике DEBUG.  Если этот флаг  установлен в еди
ничное cостояние, то  процессор переходит в режим пошагового
выполнения   команд,  т.е.  в каждый момент выполняется одна
команда под пользовательским управлением.

   IF (Interrupt Flag) - флаг прерывания. При нулевом состоя
нии  этого  флага  прерывания  запрещены,  при  единичном  -
разрешены.

   DF (DIrection  Flag)   - флаг направления. Используется в
строковых операциях   для  определения  направления передачи
данных. При нулевом состоянии команда увеличивает содержимое





Ассемблер для IBM PC. Глава 7                            137


регистров SI и  DI,   вызывая передачу данных слева направо,
при нулевом  -  уменьшает содержимое этих регистров, вызывая
передачу данных справа налево (см. гл.11).

   OF (Overflow Flag)  - флаг переполнения. Фиксирует арифме
тическое  переполнение,  т.е. перенос в/из старшего (знаково
го) бита при знаковых арифметических операциях.
   В качестве примера:  команда CMP сравнивает  два операнда
и воздействуте на флаги AF,  CF, OF, PF, SF, ZF. Однако, нет
необходимости проверять все эти флаги по отдельности. В сле-
дующем  примере проверяется содержит  ли  регистр BX нулевое
значение:

               CMP  BX,00          ;Сравнение BX с нулем
               JZ   B50            ;Переход на B50 если нуль
               .    (действия при ненуле)
               .
     B50:      ...                 ;Точка перехода при BX=0

Если BX содержит нулевое значение, команда CMP устанавливает
флаг нуля ZF в единичное состояние, и возможно изменяет (или
нет)  другие флаги. Команда JZ (перехлд если нуль) проверяет
только флаг  ZF.  При  единичном  значении  ZF, обозначающее
нулевой  признак,  команда  передает  управление  на  адрес,
указанный в ее операнде, т.е. на метку B50.

КОМАНДЫ УСЛОВНОГО ПЕРЕХОДА
------------------------------------------------------------

   В предыдущих  примерах  было  показано,  что команда LOOP
уменьшает на единицу содержимое регистра CX и проверяет его:
если не ноль, то управление передается по адресу, указанному
в операнде.  Таким  образом,  передача управления зависит от
конкретного   состояния.   Ассемблер   поддерживает  большое
количество  команд условного  перехода, которые осуществляют
передачу управления  в  зависимости  от  состояний флагового
регистра.  Например,  при сравнении  содержимого  двух полей
последующий переход зависит от значения флага.
   Команду LOOP в программе на рис.7.2 можно заменить на две
команды:  одна  уменьшает содержимое  регистра  CX, а другая
выполняет условный переход:

   Использование LOOP    Использование условного перехода

          LOOP A20                 DEC  CX
                                   JNZ  A20
Команды  DEC  и  JNZ  действуют   аналогично  команде  LOOP:
уменьшают содержимое регистра CX на 1 и выполняет переход на
метку  A20,  если  в CX  не  ноль.  Команда  DEC  кроме того
устанавливает флаг нуля во  флаговом регистре в  состояние 0
или 1.  Команда JNZ затем проверяет эту установку. В рассмот
ренном примере команда LOOP хотя и имеет огпаниченное исполь
зование, но более эффективна, чем две команды: DEC и JNZ.



Ассемблер для IBM PC. Глава 7                            138


   Аналогично  командам  JMP и LOOP  операнд  в  команде JNZ
cодержит  значение  расстояния  между концом  команды  JNZ и
адресом  A20,  которое прибавляется  к командному указателю.
Это расстояние должно быть в пределах от -128  до +127 байт.
В случае перехода за эти границы ассемблер  выдаст сообщение
"Relative jump out of range"  (превышены относительные грани
цы перехода).

   Знаковые и беззнаковые данные.

   Рассматривая назначение команд условного перехода следует
пояснить характер их использования.  Типы данных, над которы
ми выполняются арифметические операции и  операции сравнения
определяют  какими командами  пользоваться: беззнаковыми или
знаковыми.  Беззнаковые данные используют все  биты как биты
данных;  характерным  примером  являются  символьные строки:
имена,  адреса и натуральные числа.  В знаковых данных самый
левый бит представляет собой знак,  причем если его значение
равно  нулю,  то число  положительное,  и  если  единице, то
отрицательное.  Многие  числовые  значения  могут  быть  как
положительными так и отрицательными.
   В качестве примера предположим,  что регистр  AX содержит
11000110, а BX - 00010110. Команда

                         CMP  AX,BX

сравнивает  содержимое  регистров  AX  и  BX.   Если  данные
беззнаковые,  то значение в AX больше,  а если знаковые - то
меньше.

   Переходы для беззнаковых данных.

Мнемоника      Описание                 Проверяемые флаги

JE/JZ     Переход, если равно/нуль                ZF
JNE/JNZ   Переход, если не равно/не нуль          ZF
JA/JNBE   Переход, если выше/не ниже или равно    ZF,CF
JAE/JNB   Переход, если выше или равно/не ниже    CF
JB/JNAE   Переход, если ниже/не выше или равно    CF
JBE/JNA   Переход, если ниже или равно/не выше    CF,AF

   Любую проверку можно кодировать одним из  двух мнемоничес
ких  кодов.  Например,  JB и JNAE  генерирует один и  тот же
объектный код,  хотя положительную проверку JB легче понять,
чем отрицательную JNAE.

   Переходыдля знаковых данных

Мнемоника      Описание                 Проверяемые флаги

JE/JZ     Переход, если равно/нуль                  ZF
JNE/JNZ   Переход, если не равно/не нуль            ZF
JG/JNLE   Переход, если больше/не меньше или равно  ZF,SF,OF



Ассемблер для IBM PC. Глава 7                            139


JGE/JNL   Переход, если больше или равно/не меньше     SF,OF
JL/JNGE   Переход, если меньше/не больше или равно     SF,OF
JLE/JNG   Переход, если меньше или равно/не больше  ZF,SF,OF

   Команды перехода для условия равно или ноль (JE/JZ)  и не
равно  или не  ноль  (JNE/JNZ)  присутствуют в обоих списках
для беззнаковых   и  знаковых  данных. Состояние  равно/нуль
происходит вне зависимости от наличия знака.

   Специальныеарифметическиепроверки

Мнемоника      Описание                 Проверяемые флаги

     JS   Переход, если есть знак (отрицательно)       SF
     JNS  Переход, если нет знака(положительно)        SF
     JC   Переход, если есть перенос (аналогично JB)   CF
     JNC  Переход, если нет переноса                   CF
     JO   Переход, если есть переполнение              OF
     JNO  Переход, если нет переполнения               OF
     JP/JPE Переход, если паритет четный               PF
     JNP/JP Переход, если паритет нечетный             PF

   Еще  одна  команда условного перехода  проверяет равно ли
содержимое  регистра  CX  нулю.  Эта  команда  необязательно
должна pасполагаться непосредственно  за командой арифметики
или  сравнения.  Одним из  мест для команды  JCXZ может быть
начало  цикла,  где она  проверяет  содержит  ли  регистр CX
ненулевое значение.
   Не спешите пока заучивать эти команды наизусть. Запомните
только,  что для беззнаковых данных есть  переходы по состоя
ниям  равно,  выше  или ниже,  а  для беззнаковых  -  равно,
больше или меньше.  Переходы по  проверкам  флагов переноса,
переполнения  и паритета имеют  особое назначение. Ассемблер
транслирует  мнемонические коды  в объектный  код независимо
от того,  какую из двух команд вы применили. Однако, команды
JAE и  JGE  являясь  явно  одинаковыми,  проверяют различные
флаги.

ПРОЦЕДУРЫ И ОПЕРАТОР CALL
------------------------------------------------------------

   В предыдущих главах примеры содержали в  кодовом сегменте
только oдну процедуру, оформленную следующим образом:

                    BEGIN     PROC FAR
                         .
                         .
                    BEGIN     ENDP

Операнд FAR информирует систему о том, что данный адрес явля
ется точкой входа для выполнения,  а директива ENDP определя
ет конец процедуры. Кодовый сегмент, однако, может содержать




Ассемблер для IBM PC. Глава 7                            140


любое  количество процедур,  которые разделяются директивами
PROC и ENDP. Типичная организация многопроцедурной программы
приведена на рис. 7.3.
   Обратите внимание на следующие особенности:

ъ    директивы PROC по меткам  B10  и C10 имеют операнд NEAR
     для указания того,  что эти процедуры находятся  в теку
     щем  кодовом сегменте.  Во многих  последующих примерах
     этот операнд опущен,  так  как  по  умолчанию ассемблер
     принимает тип NEAR.

ъ    Каждая  процедура имеет уникальное  имя и  содержит соб
     ственную директиву ENDP для указания конца процедуры.

ъ    Для передачи  управления в процедуре  BEGIN имеются две
     команды: CALL B10 и CALL C10. В результате первой коман
     ды CALL управление передается процедуре  B10 и начинает
     ся  ее  выполнение.  Достигнув  команды RET, управление
     возвращается на  команду  непосредственно  следующую за
     CALL  B10.  Вторая команда CALL действует  аналогично -
     передает  управление  в  процедуру  C10,  выполняет  ее
     команды и возвращает управление по команде RET.

------------------------------------------------------------
------------------------------------------------------------
               Рис. 7.3. Вызов процедур.

ъ    Команда RET всегда  выполняет возврат в  вызывающую про
     грамму.  Программа BEGIN вызывает процедуры  B10 и C10,
     которые  возвращают  управление  обратно  в  BEGIN. Для
     выполнения самой программы  BEGIN  операционная система
     DOS вызывает ее и в конце выполнения команда RET возвра
     щает управление в DOS.  Если процедура  B10 не содержит
     завершающей команды RET, то выполнение команд продолжит
     ся  из  B10   непосредственно  в  процедуре  C10.  Если
     процедура C10  не содержит команды RET,  то будут выпол
     няться команды,  оказавшиеся за процедурой C10 с непред
     сказуемым результатом.

   Использование процедур дает  хорошую возможность организо
вать  логическую  структуру программы.  Кроме того, операнды
для команды CALL могут иметь значения,  выходящие за границу
от -128 до +127 байт.
   Технически управление  в процедуру типа  NEAR  может быть
передано с помощью команд перехода или даже  обычным построч
ным  кодированием.  Но в  большенстве  случаев рекомендуется
использовать команду CALL  для передачи  управления  в проце
дуру и команду RET для возврата.

СЕГМЕНТ СТЕКА
------------------------------------------------------------





Ассемблер для IBM PC. Глава 7                            141


   До этого раздела в приводимых примерах встретились только
две команды,  использующих стек, - это команды PUSH в начале
сегмента кодов,  которые обеспечивают  возврат в  DOS, когда
EXE-программа  завершается.  Естественно  для  этих программ
требуется  стек  oчень малого размера.  Однако, команда CALL
автоматически записывает в стек относительный адрес команды,
следующей  непосредственно за  командой  CALL, и увеличивает
после этого указатель вершины стека.  В вызываемой процедуре
команда RET использует этот адрес для  возврата в вызывающую
процедуру и  при  этом  автоматически  уменьшается указатель
вершины стека.
   Таким образом,  команды PUSH записывают  в стек двухбайто
вые адреса или другие значения.  Команды POP обычно выбирают
из стека записанные в него слова. Эти операции изменяют отно
сительный адрес в регистре SP  (т.е.  в указатели стека) для
доступа к следующему  слову.  Данное  свойство стека требует
чтобы команды RET  и CALL соответствовали  друг другу. Кроме
того,  вызванная  процедура может вызвать с  помощью команды
CALL другую процедуру, а та в свою очередь - следующую. Стек
должен иметь достаточные размеры для того, чтобы хранить все
записываемые в него адреса.  Для большенства  примеров в дан
ной книге стек объемом в 32 слова является достаточным.
   Команды  PUSH,  PUSHF,  CALL,  INT, и INTO заносят в стек
адрес  возврата или содержимое флагового  регистра.  Команды
POP,  POPF,  RET и IRET извлекают эти aдреса   или  флаги из
стека.
   При передаче управления в EXE-программу система устанавли
вает в регистрах следующие значения:

DS и ES:  Адрес  префикса программного  сегмента - область в
256  (шест.  100)  байт,  которая  предшествует выполняемому
программному модулю в памяти.

CS:  Адрес точки входа в программу (адрес первой выполняемой
команды).

IP: Нуль.

SS: Адрес сегмента стека.

SP:  Относительный  адрес,  указывающий  на  вершину  стека.
Например, для стека в 32 слова (64 байта), определенного как

                    DW   32 DUP(?)

SP содержит 64, или шест. 40.

   Выполним  трассировку простой  EXE-программы, приведенной
на рис.7.4.  На практике вызываемые процедуры содержат любое
число команд.
   Текущая  доступная   ячейка  стека   для   занесения  или
извлечения слова является вершина стека. Первая команда PUSH
уменьшает значение   SP на  2  и заносит содержимое регистра



Ассемблер для IBM PC. Глава 7                            142


DS (в данном примере 049f)  в вершину стека,  т.е. по адресу
4B00+3E.  Вторая команда PUSH также уменьшает значение SP на
2  и  записывает  содержимое  регистра  AX  (0000) по адресу
4B00+3C. Команда CALL B10 уменьшает значение SP и записывает
относительный  адрес  следующей  команды  (0007)  в  стек по
адресу  4B00+3A.  Команда CALL  C10  уменьшает значение SP и
записывает относительный адрес  следующей  команды  (000B) в
стек по адресу 4B00+38.
   При возврате из процедуры C10  команда RET извлекает 000B
из стека (4B00+38),  помещает  его в указатель  команд  IP и
увеличивает значение SP на  2.  При этом происходит автомати
ческий  возврат  по  относительному  адресу  000B  в кодовом
сегменте, т.е. в процедуру B10.

------------------------------------------------------------
------------------------------------------------------------
     Рис. 7.4. Воздействие выполнения программы на стек.

   Команда RET в конце процедуры B10 извлекает адрес 0007 из
стека (4B00+3A), помещают его в IP и увеличивает значение SP
на 2.  При этом происходит автоматический возврат  по относи
тельному  адресу  0007  в кодовом сегменте.  Команда  RET по
адресу  0007  завершает  выполнение  программы,  осуществляя
возврат типа FAR.
   Ниже показано  воздействие на стек при  выполнении каждой
команды.   Для  трассировки   программы  можно  использовать
отладчик DEBUG.  Приведено только содержимое памяти с адреса
0034 до 003F и содержимое регистра SP:

     Команда                       Стек                  SP

Начальное значение:     хххх хххх хххх хххх хххх хххх   0040
PUSH DS  (запись 049F)  хххх хххх хххх хххх хххх 049F   003E
PUSH AX  (запись 0000)  хххх хххх хххх хххх 0000 049F   003C
CALL B10 (запись 0007)  хххх хххх хххх 0700 0000 049F   003A
CALL C10 (запись 000B)  хххх хххх 0B00 0700 0000 049F   0038
RET      (выборка 000B) хххх хххх хххх 0700 0000 049F   003A
RET      (выборка 0007) хххх хххх хххх хххх 0000 049F   003C
                         |    |    |    |    |    |
Смещение в стеке:      0034 0036 0038 003A 003C 003E

   Обратите внимание на два момента. Во-первых, слова в памя
ти содержат  байты в обратной  последовательности,  так 0007
записывается в  виде  0700.  Во-вторых,  отладчик  DEBUG при
использовании его для просмотра стека заносит в  стек другие
значения, включая содержимое IP, для собственных нужд.

ПРОГРАММА: РАСШИРЕННЫЕ ОПЕРАЦИИ ПЕРЕСЫЛКИ
------------------------------------------------------------

   В  предыдущих программах были  показаны команды пересылки
непосредcтвенных  данных  в  регистр,  пересылки  данных  из
памяти в регистр,  пересылки содержимого регистра в память и



Ассемблер для IBM PC. Глава 7                            143


пересылки содержимого  oдного  регистра  в  другой.  Во всех
случаях длина данных была огpаничена одним или двумя байтами
и не предусмотрена пересылка данных из одной  области памяти
непосредственно другую область. В данном разделе объясняется
процесс пересылки данных,  которые  имееют  длину более двух
байт.  В главе 11  будет показано использование операций над
строками  для  пересылки  данных  из  одной  области  памяти
непосредственно в другую область.
   В EXE-программе,  приведенной на рис. 7.5, сегмент данных
cодержит три девятибайтовых поля,  NAME1, NAME2, NAME3. Цель
программы -  переслать данные из  поля NAME1  в поле NAME2 и
переслать  данные  из поля NAME2  в поле NAME3.  Так как эти
поля имеют длину девять байт каждая, то для пересылки данных
кроме  простой команды MOV потребуются  еще  другие команды.
Программа содержит несколько новых особенностей.
   Процедура  BEGIN  инициализирует  сегментные  регистры  и
затем  вызывает  процедуры  B10MOVE  и   C10MOVE.  Процедура
B10MOVE пересылает содержимое  поля NAME1  в поле NAME2. Так
как каждый раз  пересылается только один  байт, то процедура
начинает с самого левого байта в поле NAME1 и в цикле пересы
лает затем второй байт, третий и т.д.:

------------------------------------------------------------
------------------------------------------------------------
          Рис. 7.5. Расширенные операции пересылки.

               NAME1:    A  B  C  D  E  F  G  H  I
                         |  |  |  |  |  |  |  |  |
               NAME2:    J  K  L  M  N  O  P  Q  R

Для продвижения в полях NAME1 и NAME2 в регистр CX заносится
значение 9,  а регистры  SI  и  DI  используются  в качестве
индексных.  Две команды LEA  загружают  относительные aдреса
полей NAME1 и NAME2 в регистры SI и DI:

          LEA  SI,NAME1  ;Загрузка относительных адресов
          LEA  DI,NAME2  ;  NAME1 и NAME2

Для  пересылки содержимого первого  байта  из  поля  NAME1 в
первый байт поля NAME2  используются адреса в регистрах SI и
DI.  kвадратные  скобки  в командах MOV  обозначают, что для
доступа к памяти используется адрес в регистре,  указанном в
квадратных cкобках. Таким образом, команда

                    MOV  AL,[SI]

означает:  использовать адрес в регистре  SI (т.е.NAME1) для
пересылки соответствующего байта в регистр AL. А команда

                    MOV  [DI],AL

означает:  пересылать  содержимое  регистра  AL  по  адресу,
лежащему в регистре DI (т.е. NAME2).



Ассемблер для IBM PC. Глава 7                            144


   Следующие команды увеличивают значения регистров SI  и DI
и уменьшают  значение в регистре SH.  Если в регистре  CX не
нулевое значение,  управление передается  на  следующий цикл
(на метку  B20).Т ак как содержимое  регистров SI  и DI было
увеличено на 1,  то следующие команды MOV будут иметь дело с
адресами NAME1+1 и NAME2+1. Цикл продолжается таким образом,
пока не будет передано содержимое NAME1+8 и NAME2+8.
   Процедура C10MOVE аналогична  процедуре  B10MOVE  с двумя
исключениями:  она  пересылает  данные из поля  NAME2 в поле
NAME3 и использует команду LOOP вместо DEC и JNZ.
   Задание:   Введите  программу,  приведенную  на  рис.7.5,
выполните ее  ассемблирование,  компановку  и  трассировку с
помощью  отладчика DEBUG.  Обратите внимание на  изменения в
регистрах,  командном указателе  и  в  стеке.  Для просмотра
изменений в полях NAME2 и NAME3 используйте команду D DS:0.

КОМАНДЫ ЛОГИЧЕСКИХ ОПЕРАЦИЙ: AND, OR, XOR, TEST, NOT
------------------------------------------------------------

   Логические   операции   являются   важным   элементом   в
проектировании  микросхем  и  имеют  много  общего  в логике
программирования.  Команды   AND, OR, XOR и TEST  - являются
командами логических операций.  Эти команды используются для
сброса и установки бит и для арифметических операций  в коде
ASCII (см.гл.13). Все эти команды обрабатывают один байт или
одно слово в регистре  или в памяти,  и  устанавливают флаги
CF, OF, PF, SF, ZF.

AND:  Если оба из  сравниваемых битов равны  1, то результат
равен 1; во всех остальных случаях результат - 0.

OR:  Если хотя  бы  один  из сравниваемых битов равен  1, то
результат  равен  1;  если  сравниваемые  биты  равны  0, то
результат - 0.

XOR: Если один из сравниваемых битов равен 0, а другой равен
1,  то результат  равен 1;  если сравниваемые биты одинаковы
(оба - 0 или оба - 1) то результат - 0.

TEST:  действует как AND-устанавливает флаги, но не изменяет
биты.

   Первый  операнд в логических  командах  указывает на один
байт или слово в регистре или в памяти  и является единствен
ным  значением,  которое  может  изменятся  после выполнения
команд.  В  следующих командах  AND,  OR  и XOR используются
одинаковые битовые значения:

                    AND       OR        XOR
                    0101      0101      0101
                    0011      0011      0011
     Результат:     0001      0111      0110




Ассемблер для IBM PC. Глава 7                            145


   Для  следующих несвязанных примеров,  предположим, что AL
содержит 1100 0101, а BH содержит 0101 1100:

   1.     AND  AL,BH     ;Устанавливает в AL 0100 0100
   2.     OR   BH,AL     ;Устанавливает в BH 1101 1101
   3.     XOR  AL,AL     ;Устанавливает в AL 0000 0000
   4.     AND  AL,00     ;Устанавливает в AL 0000 0000
   5.     AND  AL,0FH    ;Устанавливает в AL 0000 0101
   6.     OR   CL,CL     ;Устанавливает флаги SF и ZF

Примеры  3  и  4  демонстрируют  способ  очистки регистра. В
примере 5   обнуляются  левые четыре бита регистра  AL. Хотя
команды сравнения  CMP могут быть  понятнее, можно применить
команду OR для следующих целей:

   1.     OR   CX,CX     ;Проверка CX на нуль
          JZ   ...       ;Переход, если нуль
   2.     OR   CX,CX     ;Проверка знака в CX
          JS   ...       ;Переход, если отрицательно

   Команда  TEST  действует   аналогично  команде   AND,  но
устанавливает только  флаги,  а операнд не  изменяется. Ниже
придено несколько примеров:

   1.     TEST BL,11110000B   ;Любой из левых бит в BL
          JNZ  ...            ;  равен единице?
   2.     TEST AL,00000001B   ;Регистр AL содержит
          JNZ  ...            ;  нечетное значение?
   3.     TEST DX,OFFH        ;Регистр DX содержит
          JZ   ...            ;  нулевое значение?

Еще одна логическая команда NOT устанавливает обpатное значе
ние бит в байте или в слове,  в регистре или  в памяти: нули
становятся  единицами,  а единицы -  нулями. Если, например,
pегистр  AL содержит 1100  0101,  то команда NOT AL изменяет
это значение на 0011 1010. Флаги не меняются. Команда NOT не
эквивалентна  команде   NEG,   которая  меняет   значение  с
положительного  на  отрицательное  и  наоборот,  посредством
замены бит на противоположное значение и прибавления единицы
(см."Отрицательные числа" в гл.1.).

ПРОГРАММА: ИЗМЕНЕНИЕ СТРОЧНЫХ БУКВ НА ЗАГЛАВНЫЕ
------------------------------------------------------------

   Существуют  различные  причины  для  преобразований между
строчными и заглавными буквами.  Например, вы могли получить
файл  данных,  созданный  на  компьютере,  который  работает
только  с заглавными  буквами.  Или  некая  программа должна
позволить пользователям вводить команды  как заглавными, так
и строчными буквами (например,  YES или yes) и преобразовать
их в заглавные для проверки. Заглавные буквы от A до Z имеют





Ассемблер для IBM PC. Глава 7                            146


шест.коды  от  41  до 5A,  а строчные буквы от a до  z имеют
шест.коды от 61 до 7A. Единственная pазница в том, что пятый
бит равен 0 для заглавных букв и 1 для строчных:

             Биты:  76543210          Биты:  76543210
          Буква A:  01000001       Буква a:  01100001
          Буква Z:  01011010       Буква z:  01111010

   COM-программа,   приведенная  на  рис.  7.6,  преобразует
данные в поле TITLEX из строчных букв в прописные, начиная с
адреса TITLEX+1. Программа инициализирует регистр BX адресом
TITLEX+1  и использует его для пересылки  символов в регистр
AH,  начиная с TITLEX+1.  Если полученное   значение лежит в
пределах от  шест.61  и до 7A,  то команда AND устанавливает
бит 5 в 0:

                    AND  AH,11011111B

Все символы,  отличные  от  строчных  букв  (от a до  z), не
изменяются.  Измененные символы засылаются обратно в область
TITLEX,  значение в регистре BX увеличивается для очередного
символа и осуществляется переход на следующий цикл.
   Используемый  таким  образом  регистр  BX  действует  как
индексный  регистр для адресации в  памяти.  Для  этих целей
можно использовать также регистры SI и DI.

------------------------------------------------------------
------------------------------------------------------------
     Рис. 7.6. Изменение строчных букв на прописные.

КОМАНДЫ СДВИГА И ЦИКЛИЧЕСКОГО СДВИГА
------------------------------------------------------------

   Команды сдвига и циклического сдвига,  которые представля
ют собой  часть  логических  возможностей  компьютера, имеют
следующие свойства:
   - обрабатывают байт или слово;
   - имеют доступ к регистру или к памяти;
   - сдвигают влево или вправо;
   - сдвигают на величину до 8 бит (для байта) и 16 бит (для
слова);
   - сдвигают  логически (без  знака)  или арифметически (со
знаком).
   Значение сдвига на 1 может быть закодировано как непосред
cтвенный операнд,  значение  больше  1  должно  находиться в
регистре CL.

   Команды сдвига

   При выполнении команд сдвига флаг CF  всегда содержит зна
чение  последнего  выдвинутого  бита.  Существуют  следующие
команды cдвига:




Ассемблер для IBM PC. Глава 7                            147


          SHR  ;Логический (беззнаковый) сдвиг вправо
          SHL  ;Логический (беззнаковый) сдвиг влево
          SAR  ;Арифметический сдвиг вправо
          SAL  ;Арифметический сдвиг влево

   Следующий фрагмент иллюстрирует выполнение команды SHR:

     MOV  CL,03          ;    AX:
     MOV  AX,10110111B   ; 10110111
     SHR  AX,1           ; 01011011   ;Сдвиг вправо на 1
     SHR  AX,CL          ; 00001011   ;Сдвиг вправо на 3

Первая команда SHR сдвигает содержимое регистра AX вправо на
1  бит. Выдвинутый в результате один бит попадает в флаг CF,
а  самый левый бит  регистра  AX  заполняется  нулем. Вторая
команда cдвигает содержимое регистра AX еще на три бита. При
этом флаг CF последовательно принимает значения 1, 1, 0, а в
три левых бита в регистре AX заносятся нули.
   Рассмотрим действие команд арифметического вправо SAR:

     MOV  CL,03          ;    AX:
     MOV  AX,10110111B   ; 10110111
     SAR  AX,1           ; 11011011   ;Сдвиг вправо на 1
     SAR  AX,CL          ; 11111011   ;Сдвиг вправо на 3

Команда SAR имеет важное отличие от команды SHR: для заполне
ния  левого  бита используется знаковый  бит. Таким образом,
положительные и отрицательные величины  сохраняют свой знак.
В приведенном примере знаковый бит содержит единицу.
   При сдвигах  влево правые биты заполняются  нулями. Таким
обpазом, результат команд сдвига SHL и SAL индентичен.
   Сдвиг  влево часто используется  для удваивания  чисел, а
сдвиг вправо - для деления на 2. Эти операции осуществляются
значительно  быстрее,  чем  команды  умножения  или деления.
Деление пополам нечетных чисел (например,  5 или 7) образует
меньшие значения (2  или 3, соответственно) и устанавливаеют
флаг CF в 1.  Кроме того, если необходимо выполнить сдвиг на
2  бита,  то использование двух команд сдвига более эффектив
но,  чем использование одной команды с загрузкой регистра CL
значением 2.
   Для проверки  бита,  занесенного  в флаг  CF используется
команда JC (переход, если есть перенос).

   Команды циклического сдвига

   Циклический сдвиг представляет собой операцию сдвига, при
которой  выдвинутый  бит  занимает   освободившийся  разряд.
Существуют следующие команды циклического сдвига:

          ROR  ;Циклический сдвиг вправо
          ROL  ;Циклический сдвиг влево
          RCR  ;Циклический сдвиг вправо с переносом
          RCL  ;Циклический сдвиг влево с переносом



Ассемблер для IBM PC. Глава 7                            148



   Следующая последовательность команд иллюстрирует операцию
циклического сдвига ROR:

     MOV  CL,03          ;    BX:
     MOV  BX,10110111B   ; 10110111
     ROR  BX,1           ; 11011011   ;Сдвиг вправо на 1
     ROR  BX,CL          ; 01111011   ;Сдвиг вправо на 3

   Первая  команда ROR  при  выполнении  циклического сдвига
переносит правый единичный бит регистра BX  в освободившуюся
левую  позицию.  Вторая команда ROR  переносит таким образом
три правых бита.
   В командах RCR и RCL в сдвиге участвует флаг CF. Выдвигае
мый из регистра бит заносится в  флаг CF,  а значение CF при
этом поступает в освободившуюся позицию.
   Рассмотрим   пример,   в   котором  используются  команды
циклического и простого сдвига.  Предположим, что 32-битовое
значение находится в регистрах DX:AX так,  что левые  16 бит
лежат в регистре  DX,  а правые -  в AX.  Для умножения на 2
этого значения возможны cледующие две команды:

               SHL  AX,1      ;Умножение пары регистров
               RCL  DX,1      ;  DX:AX на 2

Здесь команда SHL сдвигает  все   биты   регистра  AX влево,
причем самый левый бит попадает в флаг CF. Затем команда RCL
сдвигает все  биты  регистра  DX  влево  и  в освободившийся
правый бит заносит значение из флага CF.

ОРГАНИЗАЦИЯ ПРОГРАММ
------------------------------------------------------------

   Ниже даны  основные рекомендации для  написания ассемблер
ных программ:

1.   Четко представляйте себе задачу, которую должна  решить
     программа

2.   Сделайте  эскиз задачи  в  общих  чертах  и спланируйте
     общую логику программы. Например, если необходимо прове
     рить операции пеpесылки нескольких  байт (как в примере
     на рис.7.5), начните c определения полей с  пересылаемы
     ми  данными.  Затем спланируйте   общую  стратегию  для
     инициализации,  условного  перехода  и   команды  LOOP.
     Приведем  основную  логику,  которую  используют многие
     программисты в таком случае:
          инициализация стека и сегментных регистров
          вызов подпрограммы цикла
          возврат
     Подпрограмма цикла может быть спланирована следующим
     образом:
               инициализация регистров значениями адресов



Ассемблер для IBM PC. Глава 7                            149


               и числа циклов
     Метка:    пересылка одного байта
               увеличение адресов на 1
               уменьшение счетчика на 1:
                    если счетчик не ноль, то идти на метку
                    если ноль, возврат

3.   Представьте программу в виде логических  блоков, следую
     щих друг за другом.  Процедуры не превышающие  25 строк
     (размер экрана) удобнее для отладки.

4.   Пользуйтесь тестовыми примерами программ. Попытки запом
     нить все технические детали и  программирование сложных
     программ "из головы"  часто  приводят  к многочисленным
     ошибкам.

5.   Используйте комментарии для описания  того,  что должна
     делать  процедура,  какие  арифметические  действия или
     операции сравнения будут выполняться и что делают редко
     используемые  команды.   (Например,  команда  XLAT,  не
     имеющая операндов).

6.   Для кодирования программы используйте заготовку програм
     мы, скопированной в файл с новым именем.

   В  следующих  программах  данной  книги  важным  является
использование  команды LEA,  индексных  регистров  SI  и DI,
вызываемых  процедур.   Получив  теперь  базовые  знания  по
ассемблеру,  можем перейти  к  более  развитому  и полезному
программированию.

ОСНОВНЫЕ ПОЛОЖЕНИЯ НА ПАМЯТЬ
------------------------------------------------------------

ъ    Метки процедур (например, B20:) должны завершаться двое
     точием  для указания  типа  NEAR.  Отсутствие двоеточия
     приводит к ассемблерной ошибке.

ъ    Метки  для  команд  условного  перехода  и  LOOP должны
     лежать в границах  -128  до  +127  байт.  Операнд таких
     команд генерирует  один байт объектного  кода. Шест. от
     01  до 7F  соответствует десятичным значениям  от +1 до
     +127,  а шест.  от FF до 80 покрывает значения от -1 до
     +128. Так как длина машинной команды может быть от 1 до
     4  байт,  то соблюдать границы  не  просто. Практически
     можно ориентироваться на размер в  два экрана исходного
     текста (примерно 50 строк).

ъ    При использовании команды LOOP, инициализируйте регистр
     CX  положительным  числом.  Команда  LOOP  контролирует
     только  нулевое значение,  при  отрицательном программа
     будет продолжать циклиться.




Ассемблер для IBM PC. Глава 7                            150


ъ    Если некоторая команда  устанавливает  флаг,  то данный
     флаг сохраняет это значение, пока другая команда его не
     изменит.  Например,  если  за  арифметической командой,
     которая устанавливает флаги,  следуют  команды  MOV, то
     они  не  изменят   флаги. Однако, для минимизации числа
     возможных ошибок,  cледует кодировать команды условного
     перехода непосредственно  после команд, устанавливающих
     проверяемые флаги.

ъ    Выбирайте  команды  условного  перехода  соответственно
     операциям над знаковыми или беззнаковыми данными.

ъ    Для  вызова  процедуры используйте команду CALL,  а для
     возврата из процедуры - команду RET. Вызываемая процеду
     ра может,  в свою очередь,  вызвать другую процедуру, и
     если следовать существующим соглашениям, то команда RET
     всегда будет выбирать из стека  правильный адрес возвра
     та. Единственные примеры в этой книге, где используется
     переход  в процедуру вместо  ее вызова -  в начале COM-
     программ.

ъ    Будьте  внимательны при использовании  индексных операн
     дов. Сравните:
                         MOV  AX,SI
                         MOV  AX,[SI]

     Первая команда  MOV пересылает в  регистр AX содержимое
     регистра SI. Вторая команда MOV для доступа к пересылае
     мому слову в памяти  использует  относительный  адрес в
     регистре SI.

ъ    Используйте  команды сдвига для  удванивания значений и
     для деления пополам,  но при этом внимательно выбирайте
     соответствующие  команды  для  знаковых  и  беззнаковых
     данных.

ВОПРОСЫ ДЛЯ САМОПРОВЕРКИ
------------------------------------------------------------

7.1.   Какое максимальное количество байт могут обойти коман
       ды коpоткий JMP,  LOOP и относительный переход? Какой
       машинный код операнда при этом генерируется?
7.2.   Команда  JMP  начинается  на  шест.  0624. Определите
       адрес перехода, если шест. объектный код для операнда
       команды JMP: а) 27, б) 6B, в) C6.
7.3.   Напишите  программу вычисления 12  чисел Фибоначи: 1,
       1,   2,   3,   5,   8,   13,...   (каждое   число   в
       последовательности  представляет   собой  сумму  двух
       предыдущих чисел).  Для организации цикла используйте
       команду LOOP. Выполните ассемблирование, компановку и
       с помощью отладчика DEBUG трассировку программы.





Ассемблер для IBM PC. Глава 7                            151


7.4.   Предположим,  что регистры AX и  BX содержат знаковые
       данные,  a CX и DX -  беззнаковые. Определите команды
       CMP (где необходимо)  и команды безусловного перехода
       для следующих проверок:
       а) значение в DX больше, чем в CX?
       б) значение в BX больше, чем в AX?
       в) CX содержит нуль?
       г) было ли переполнение?
       д) значение в BX равно или меньше, чем в AX?
       е) значение в DX равно или меньше, чем в CX?
7.5.   На какие флаги воздействуют следующие события и какое
       значение этих флагов?
       a) произошло переполнение;
       б) результат отрицательный;
       в) результат нулевой;
       г) обработка в одношаговом режиме;
       д) передача данных должна быть справа налево.
7.6.   Что произойдет при выполнении программы , приведенной
       на   рис.7.4,    если   в   процедуре   BEGIN   будет
       отсутствовать команда RET?
7.7.   Какая  разница между  кодированием  в  директиве PROC
       опеpанда с типом FAR и с типом NEAR?
7.8.   Каким  образом  может  программа   начать  выполнение
       процедуры?
7.9.   В  EXE-программе  процедура  A10  вызывает  B10,  B10
       вызывает C10,  а C10  вызывает D10.  Сколько адресов,
       кроме  начальных  адресов  возврата  в  DOS, содержит
       стек?
7.10.  Предположим , что регистр BL содержит 11100011 и поле
       по имени BOONO содержит 01111001. Определите воздейст
       вие  на  регистр  BL  для  следующих  команд:  а) XOR
       BL,BOONO;  б)  AND BL,BOONO;  в) OR  BL,BOONO; г) XOR
       BL,11111111B; д) AND BL,00000000B.
7.11.  Измените  программу на  рис.7.6  для:  а) определения
       содержимого TITLEX заглавными буквами; б) преобразова
       ние заглавных букв  в  строчные.
7.12.  Предположим,   что  регистр   DX   содержит  10111001
       10111001,  а  pегистр CL -  03. Определите содержимое
       регистра  DX  после следующих несвязанных  команд: а)
       SHR DX,1;  б)  SHR DX,CL;  в) SHL DX,CL; г) SHL DL,1;
       д) ROR DX,CL; е) ROR DL,CL; ж) SAL DH,1.
7.13.  Используя  команды  сдвига,   пересылки  и  сложения,
       умножьте содержимое  регистра  AX  на 10.
7.14.  Пример программы,  приведенной в конце раздела "сдвиг
       и   циклический  сдвиг",   умножает  содержимое  пары
       регистров  DX:AX на  2.  Измените  программу  для: а)
       умножения на 4;  б) деления на 4; в) умножения 48 бит
       в регистрах DX:AX:BX на 2.








Ассемблер для IBM PC. Глава 8                            172



