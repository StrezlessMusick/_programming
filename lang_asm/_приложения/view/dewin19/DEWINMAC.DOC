Описание макроязыка постпроцессора DeWin


Постпроцессор предназначен для ретрансляции листинга на
языке ассемблера в исходный текст на Си или Паскале.

Для преобразования программа использует список правил поиска-замены, далее
называемый скриптом. Скрипт состоит из нескольких секций, по одной на
каждое желаемое изменение листинга, и пишется в соответствии с несложными
правилами. При запуске программы с ключем -2 (делать второй проход) она
читает файл скрипта и проводит построчный поиск в листинге всех секций,
заменяя при необходимости группы строк их новым представлением. Длина
листинга ограничена обьемом дисковой памяти. Выдается краткая статистика
по количеству использованных макросов (можно исключить из скрипта те,
что не были задействованы, увеличив тем самым скорость обработки текста).


Правила написания скрипта.

Скрипт - обычный текстовый ASCII файл. Пустые строки игнорируются.
Строки, начинающиеся с двух точек с запятой (;;) считаются комментарием и
также игнорируются.

Каждый макрос (секция) скрипта состоит из двух обязательных разделов.
Раздел отмечается соответствующим оператором в начале строки.
Оператор <find> указывает, что последующие строки будут содержать аргумент
поиска. Оператор <repl> отмечает начало раздела, содержащего строку
замены.

 │ Пример:
 │
 │ <find>
 │ mov     ax,bx
 │ <repl>
 │ ax = bx
 │
 │ В результате все строки "mov     ax,bx" будут заменены на "ax = bx"

Если секция <find> содержит несколько строк, все они, кроме первой,
изымаются из листинга, первая заменяется на строку замены (должна быть
одна).

Необязательный оператор <base>nn задает столбец, начиная с 0, относительно
которого будет проводиться сравнение и замена строк. Например
<base>35
позволит игнорировать при поиске символы левее 35-го, например в листинге
Sourcer (c) V.Communications. Этот оператор может появляться в любой
секции <find> и действует до следующего определения или конца скрипта.

Для листинга 16-разрядного приложения <base> следует установить 8, а
файлы FLAT .EXE из-за большей разрядности адреса требуют <base> равную 16.
Данные значения не обязательно должны быть именно такими, но с точки зрения
настройки файла макросов удобно, чтобы команды начинались без какого-либо
отступа вправо, в первой же колонке (с точки зрения постпроцессора это 
колонка 0).

Оператор <end> явно определяет конец скрипта (строки после него не
читаются и могут являться дополнительными пояснениями)

Макросы поиска и замены

Все макросы заключаются в треугольные скобки, кроме символа '?',
заменяющего при поиске любой одиночный символ, и '*' которому
соответствует 0 и больше любых символов.
Следующие строки считаются совпавшими:
mov     ax,[bp-2h]          mov     ??,[bp-?h]
mov     ax,*-2h]            mov     ??,es:[di-2h]

<xdigit> при поиске соответствует шестнадцатиричному числу.
Условие сравнения "mov     ax,<xdigit>" позволит найти строки вида
mov     ax,10
mov     ax,0A2h
mov     ax,1045h (т.е. начинается с цифры, содержит 0..9 A..F, кончается
                  нецифрой, например 'h', пробелом, скобкой и др.)

<astring> соответствует строке латинских букв, цифр и знака подчеркивания,
позволяя находить метки. Например
mov     ax,<astring>
позволит найти строки вида "mov     ax,Friday_13"


В строке замены могут использоваться следующие макросы.


<mid 1,5,'['> соответствует подстроке второй по счету найденной строки
(нумерация с 0), с пятого символа до квадратной скобки (не включая ее)

 │ Например
 │ <find>
 │ push    cx
 │ mov     ax,ds:[si]
 │ <repl>
 │ <mid 1,11,':'>
 │ соответствует строке "ds". Если нужно получить подстроку до конца, третий
 │ параметр макроса должен быть 0: <mid 1,11,0>


<lookup 1,5,'['> действует аналогично <mid >, но полученная подстрока
(с пятого символа до скобки) не помещается в качестве замены, а
используется для поиска в текстовом файле lookup и вместо нее вставляется
найденное в lookup значение. Если поиск неудачен, то сама подстрока поиска
копируется "как есть".

Пусть деассемблируется модуль COMMDLG.DLL и существует файл COMMDLG.LKP
со следующим содержимым (подробнее см. dewin.doc)

1230 "Select file"
1234 "Choose color"
1235 "Save As..."

Известно, что функция LoadStringA() используется для чтения текстовых строк
из ресурсов текущего приложения. Один из ее параметров - номер (id) строки.
Чтобы в деассемблированном листинге получить вместо номеров сами строки,
нужно использовать следующее:

 │ Например
 │ <find>
 │ push    1234
 │ call    LoadStringA
 │ <repl>
 │ <lookup 0,8,0>
 │ соответствует строке "1234", вместо которой будет подставлено "Choose color".

Конечно, лучше в разделе <find> указывать не одно точное число, а например
<xdigit>, чтобы макрос сработал на большем количестве строк.


<dec 4,12> подставит десятичное значение шестнадцатиричного числа из 12
позиции пятой строки.

 │ Пример
 │ <find>
 │ mov     ax,0Fh
 │ call    <astring>
 │ <repl>
 │ <mid 1,8,0>( <dec 0,11> )
 │ Результат будет "MyProc( 15 )"


<out s,p,c> используется в отладочных целях для вывода на stdout (экран)
подстроки аналогично макросу <mid >, т.е. в данном случае из строки номер
s начиная с p-го символа до символа c.

В макросах <out > и <mid > могут использоваться отрицательные значения
столбца, в этом случае подстрока извлекается левее границы, заданной
параметром <base>, например <out 0,-10,0> вырежет часть строки, начиная с
десятого слева от <base > символа и до правого конца строки, и выдаст на
экран.

Для наиболее эффективной замены более длинные секции <find> должны идти
раньше коротких, так как поиск выполняется в порядке написания скрипта.




end of file