TABLE OF CONTENTS
CHAPTER 1
GETTING STARTED PAGE
1.1. HOW TO USE THIS MANUAL................................................................................. 1-1
1.1.1. Part I—Application and Numeric Programming..................................................... 1-2
1.1.2. Part II—System Programming ............................................................................. 1-2
1.1.3. Part III—Compatibility .......................................................................................... 1-4
1.1.4. Part IV—Optimization .......................................................................................... 1-4
1.1.5. Part V—Instruction Set ........................................................................................ 1-4
1.1.6. Appendices.......................................................................................................... 1-5
1.2. RELATED LITERATURE ......................................................................................... 1-5
1.3. NOTATIONAL CONVENTIONS............................................................................... 1-5
1.3.1. Bit and Byte Order............................................................................................... 1-6
1.3.2. Undefined Bits and Software Compatibility........................................................... 1-6
1.3.3. Instruction Operands ........................................................................................... 1-7
1.3.4. Hexadecimal Numbers......................................................................................... 1-7
1.3.5. Segmented Addressing........................................................................................ 1-8
1.3.6. Exceptions........................................................................................................... 1-8
CHAPTER 2
INTRODUCTION TO THE INTEL PENTIUM® PROCESSOR FAMILY
PART I — APPLICATION AND
NUMERIC PROGRAMMING
CHAPTER 3
BASIC PROGRAMMING MODEL
3.1. MEMORY ORGANIZATION .................................................................................... 3-1
3.1.1. Unsegmented or "Flat" Model .............................................................................. 3-2
3.1.2. Segmented Model ............................................................................................... 3-3
3.2. DATA TYPES.......................................................................................................... 3-4
3.3. REGISTERS ........................................................................................................... 3-8
3.3.1. General Registers................................................................................................ 3-8
3.3.2. Segment Registers .............................................................................................3-10
3.3.3. Stack Implementation .........................................................................................3-12
3.3.4. Flags Register ....................................................................................................3-13
3.3.4.1. STATUS FLAGS.............................................................................................3-14
3.3.4.2. CONTROL FLAG............................................................................................3-15
3.3.5. Instruction Pointer...............................................................................................3-15
3.4. INSTRUCTION FORMAT .......................................................................................3-15
CONTENTS E
PAGE
3.5. OPERAND SELECTION.........................................................................................3-17
3.5.1. Immediate Operands ..........................................................................................3-18
3.5.2. Register Operands .............................................................................................3-19
3.5.3. Memory Operands..............................................................................................3-19
3.5.3.1. SEGMENT SELECTION .................................................................................3-20
3.5.3.2. EFFECTIVE-ADDRESS COMPUTATION........................................................3-20
3.6. INTERRUPTS AND EXCEPTIONS.........................................................................3-23
CHAPTER 4
APPLICATION PROGRAMMING
4.1. DATA MOVEMENT INSTRUCTIONS....................................................................... 4-1
4.1.1. General-Purpose Data Movement Instructions..................................................... 4-1
4.1.2. Stack Manipulation Instructions............................................................................ 4-2
4.1.3. Type Conversion Instructions............................................................................... 4-5
4.2. BINARY ARITHMETIC INSTRUCTIONS.................................................................. 4-6
4.2.1. Addition and Subtraction Instructions ................................................................... 4-7
4.2.2. Comparison and Sign Change Instruction ............................................................ 4-8
4.2.3. Multiplication Instructions..................................................................................... 4-8
4.2.4. Division Instructions............................................................................................. 4-9
4.3. DECIMAL ARITHMETIC INSTRUCTIONS..............................................................4-10
4.3.1. Packed BCD Adjustment Instructions..................................................................4-10
4.3.2. Unpacked BCD Adjustment Instructions..............................................................4-10
4.4. LOGICAL INSTRUCTIONS.....................................................................................4-11
4.4.1. Boolean Operation Instructions ...........................................................................4-11
4.4.2. Bit Test and Modify Instructions ..........................................................................4-12
4.4.3. Bit Scan Instructions...........................................................................................4-12
4.4.4. Shift and Rotate Instructions...............................................................................4-13
4.4.4.1. SHIFT INSTRUCTIONS..................................................................................4-13
4.4.4.2. DOUBLE-SHIFT INSTRUCTIONS...................................................................4-16
4.4.4.3. ROTATE INSTRUCTIONS..............................................................................4-17
4.4.4.4. FAST "bit blt" USING DOUBLE-SHIFT INSTRUCTIONS..................................4-19
4.4.4.5. FAST BIT STRING INSERT AND EXTRACT...................................................4-19
4.4.5. Byte-Set-On-Condition Instructions .....................................................................4-23
4.4.6. Test Instruction...................................................................................................4-23
4.5. CONTROL TRANSFER INSTRUCTIONS ...............................................................4-23
4.5.1. Unconditional Transfer Instructions .....................................................................4-23
4.5.1.1. JUMP INSTRUCTION.....................................................................................4-24
4.5.1.2. CALL INSTRUCTIONS ...................................................................................4-24
4.5.1.3. RETURN AND RETURN-FROM-INTERRUPT INSTRUCTIONS ......................4-24
4.5.2. Conditional Transfer Instructions.........................................................................4-25
4.5.2.1. CONDITIONAL JUMP INSTRUCTIONS..........................................................4-25
4.5.2.2. LOOP INSTRUCTIONS ..................................................................................4-26
4.5.2.3. EXECUTING A LOOP OR REPEAT ZERO TIMES..........................................4-27
4.5.3. Software Interrupts .............................................................................................4-27
4.6. STRING OPERATIONS..........................................................................................4-28
4.6.1. Repeat Prefixes..................................................................................................4-29
4.6.2. Indexing and Direction Flag Control ....................................................................4-30
4.6.3. String Instructions...............................................................................................4-30
4.7. INSTRUCTIONS FOR BLOCK-STRUCTURED LANGUAGES.................................4-31
4.8. FLAG CONTROL INSTRUCTIONS.........................................................................4-38
4.8.1. Carry and Direction Flag Control Instructions ......................................................4-38
4.8.2. Flag Transfer Instructions ...................................................................................4-38
E CONTENTS
PAGE
4.9. NUMERIC INSTRUCTIONS....................................................................................4-40
4.10. SEGMENT REGISTER INSTRUCTIONS................................................................4-40
4.10.1. Segment-Register Transfer Instructions ..............................................................4-41
4.10.2. Far Control Transfer Instructions.........................................................................4-41
4.10.3. Data Pointer Instructions.....................................................................................4-41
4.11. MISCELLANEOUS INSTRUCTIONS ......................................................................4-42
4.11.1. Address Calculation Instruction...........................................................................4-43
4.11.2. No-Operation Instruction.....................................................................................4-43
4.11.3. Translate Instruction ...........................................................................................4-43
4.11.4. Byte Swap Instruction .........................................................................................4-43
4.11.5. Exchange-and-Add Instruction............................................................................4-45
4.11.6. Compare-and-Exchange Instructions ..................................................................4-45
4.11.7. CPUID Instruction...............................................................................................4-46
CHAPTER 5
FEATURE DETERMINATION
5.1. CPU IDENTIFICATION............................................................................................ 5-1
5.2. FPU DETECTION.................................................................................................... 5-2
5.3. SAMPLE CPUID IDENTIFICATION/FPU DETECTION CODE.................................. 5-2
CHAPTER 6
NUMERIC APPLICATIONS
6.1. INTRODUCTION TO NUMERIC APPLICATIONS.................................................... 6-1
6.1.1. History................................................................................................................. 6-1
6.1.2. Performance........................................................................................................ 6-2
6.1.3. Ease of Use......................................................................................................... 6-2
6.1.4. Applications......................................................................................................... 6-4
6.1.5. Programming Interface ........................................................................................ 6-5
6.2. ARCHITECTURE OF THE FLOATING-POINT UNIT................................................ 6-7
6.2.1. Numerical Registers ............................................................................................ 6-7
6.2.1.1. THE FPU REGISTER STACK .......................................................................... 6-8
6.2.1.2. THE FPU STATUS WORD............................................................................... 6-9
6.2.1.3. CONTROL WORD..........................................................................................6-11
6.2.1.4. THE FPU TAG WORD....................................................................................6-14
6.2.1.5. OPCODE FIELD OF LAST INSTRUCTION .....................................................6-15
6.2.1.6. THE NUMERIC INSTRUCTION AND DATA POINTERS..................................6-16
6.2.2. Computation Fundamentals ................................................................................6-19
6.2.2.1. NUMBER SYSTEM.........................................................................................6-19
6.2.2.2. DATA TYPES AND FORMATS .......................................................................6-21
6.2.2.2.1. Binary Integers............................................................................................6-21
6.2.2.2.2. Decimal Integers .........................................................................................6-21
6.2.2.2.3. Real Numbers.............................................................................................6-23
6.2.2.3. ROUNDING CONTROL..................................................................................6-25
6.2.2.4. PRECISION CONTROL..................................................................................6-26
6.3. FLOATING-POINT INSTRUCTION SET.................................................................6-26
6.3.1. Source and Destination Operands ......................................................................6-27
6.3.2. Data Transfer Instructions...................................................................................6-27
6.3.3. Nontranscendental Instructions...........................................................................6-28
6.3.4. Comparison Instructions .....................................................................................6-30
6.3.5. Transcendental Instructions................................................................................6-31
6.3.6. Constant Instructions..........................................................................................6-33
CONTENTS E
PAGE
6.3.7. Control Instructions.............................................................................................6-33
6.4. NUMERIC APPLICATIONS ....................................................................................6-35
6.4.1. High-Level Languages ........................................................................................6-36
6.4.1.1. C PROGRAMS...............................................................................................6-36
6.4.1.2. PL/M-386/486.................................................................................................6-36
6.4.1.3. ASM386/486...................................................................................................6-38
6.4.1.3.1. Defining Data ..............................................................................................6-38
6.4.1.3.2. Records and Structures...............................................................................6-40
6.4.1.3.3. Addressing Methods ...................................................................................6-41
6.4.1.4. COMPARATIVE PROGRAMMING EXAMPLE.................................................6-42
6.4.1.5. CONCURRENT PROCESSING.......................................................................6-47
6.4.1.6. MANAGING CONCURRENCY........................................................................6-47
6.4.1.7. EXCEPTION SYNCHRONIZATION.................................................................6-49
6.4.1.8. PROPER EXCEPTION SYNCHRONIZATION.................................................6-49
CHAPTER 7
SPECIAL COMPUTATIONAL SITUATIONS
7.1. SPECIAL NUMERIC VALUES ................................................................................. 7-1
7.1.1. Denormal Real Numbers...................................................................................... 7-7
7.1.2. Zeros................................................................................................................... 7-9
7.1.3. Infinity ................................................................................................................. 7-9
7.1.4. NaN (Not-a-Number) ..........................................................................................7-15
7.1.4.1. SIGNALING NaNs ..........................................................................................7-16
7.1.4.2. QUIET NaNs...................................................................................................7-16
7.1.5. Indefinite ............................................................................................................7-17
7.1.6. Encoding of Data Types......................................................................................7-18
7.1.6.1. UNSUPPORTED FORMATS...........................................................................7-18
7.1.7. Numeric Exceptions............................................................................................7-18
7.1.8. Handling Numeric Exceptions .............................................................................7-19
7.1.8.1. AUTOMATIC EXCEPTION HANDLING...........................................................7-19
7.1.8.2. SOFTWARE EXCEPTION HANDLING............................................................7-20
7.1.9. Invalid Operation ................................................................................................7-21
7.1.9.1. STACK EXCEPTION.......................................................................................7-22
7.1.9.2. INVALID ARITHMETIC OPERATION..............................................................7-22
7.1.10. Division by Zero..................................................................................................7-23
7.1.11. Denormal Operand .............................................................................................7-23
7.1.12. Numeric Overflow and Underflow........................................................................7-24
7.1.12.1. OVERFLOW...................................................................................................7-24
7.1.12.2. UNDERFLOW.................................................................................................7-26
7.1.13. Inexact (Precision)..............................................................................................7-27
7.1.14. Exception Priority................................................................................................7-28
7.1.15. Standard Underflow/Overflow Exception Handler ................................................7-28
E CONTENTS
CHAPTER 8
NUMERIC PROGRAMMING EXAMPLES
PAGE
8.1. CONDITIONAL BRANCHING EXAMPLE................................................................. 8-1
8.2. EXCEPTION HANDLING EXAMPLES..................................................................... 8-4
8.3. FLOATING POINT TO ASCII CONVERSION EXAMPLES....................................... 8-7
8.3.1. Function Partitioning ...........................................................................................8-22
8.3.2. Exception Considerations ...................................................................................8-22
8.3.3. Special Instructions.............................................................................................8-22
8.3.4. Description of Operation .....................................................................................8-23
8.3.5. Scaling the Value................................................................................................8-24
8.3.5.1. INACCURACY IN SCALING............................................................................8-24
8.3.5.2. AVOIDING UNDERFLOW AND OVERFLOW..................................................8-24
8.3.5.3. FINAL ADJUSTMENTS...................................................................................8-25
8.3.6. Output Format ....................................................................................................8-25
8.4. TRIGONOMETRIC CALCULATION EXAMPLES ....................................................8-25
PART II — SYSTEM PROGRAMMING
CHAPTER 9
REAL-ADDRESS MODE SYSTEM ARCHITECTURE
9.1. ADDRESS TRANSLATION...................................................................................... 9-1
9.2. REGISTERS AND INSTRUCTIONS......................................................................... 9-2
9.3. INTERRUPT AND EXCEPTION HANDLING............................................................ 9-3
9.4. REAL-ADDRESS MODE EXCEPTIONS .................................................................. 9-3
CHAPTER 10
PROTECTED-MODE SYSTEM ARCHITECTURE OVERVIEW
10.1. SYSTEM REGISTERS ...........................................................................................10-1
10.1.1. System Flags......................................................................................................10-2
10.1.2. Memory-Management Registers .........................................................................10-4
10.1.3. Control Registers................................................................................................10-5
10.1.4. Debug Registers.................................................................................................10-9
10.2. SYSTEM INSTRUCTIONS ...................................................................................10-11
CHAPTER 11
PROTECTED-MODE MEMORY MANAGEMENT
11.1. SELECTING A SEGMENTATION MODEL..............................................................11-2
11.1.1. Flat Model ..........................................................................................................11-3
11.1.2. Protected Flat Model...........................................................................................11-4
11.1.3. Multisegment Model............................................................................................11-5
11.2. SEGMENT TRANSLATION ....................................................................................11-6
11.2.1. Segment Registers .............................................................................................11-9
11.2.2. Segment Selectors ...........................................................................................11-10
11.2.3. Segment Descriptors ........................................................................................11-11
11.2.4. Segment Descriptor Tables...............................................................................11-15
11.2.5. Descriptor Table Base Registers.......................................................................11-16
11.3. PAGE TRANSLATION..........................................................................................11-17
11.3.1. Paging Options.................................................................................................11-18
CONTENTS E
PAGE
11.3.3. Page Tables .....................................................................................................11-19
11.3.4. Page-Table Entries ...........................................................................................11-19
11.3.4.1. PAGE FRAME ADDRESS.............................................................................11-20
11.3.4.2. PRESENT BIT ..............................................................................................11-20
11.3.4.3. ACCESSED AND DIRTY BITS......................................................................11-21
11.3.4.4. READ/WRITE AND USER/SUPERVISOR BITS ............................................11-22
11.3.4.5. PAGE-LEVEL CACHE CONTROL BITS........................................................11-22
11.3.5. Translation Lookaside Buffers...........................................................................11-22
11.4. COMBINING SEGMENT AND PAGE TRANSLATION...........................................11-23
11.4.1. Flat Model ........................................................................................................11-23
11.4.2. Segments Spanning Several Pages ..................................................................11-23
11.4.3. Pages Spanning Several Segments ..................................................................11-23
11.4.4. Non-Aligned Page and Segment Boundaries.....................................................11-24
11.4.5. Aligned Page and Segment Boundaries ............................................................11-24
11.4.6. Page-Table Per Segment..................................................................................11-25
CHAPTER 12
PROTECTION
12.1. SEGMENT-LEVEL PROTECTION..........................................................................12-1
12.2. SEGMENT DESCRIPTORS AND PROTECTION....................................................12-2
12.2.1. Type Checking....................................................................................................12-2
12.2.2. Limit Checking....................................................................................................12-5
12.2.3. Privilege Levels ..................................................................................................12-6
12.3. RESTRICTING ACCESS TO DATA........................................................................12-8
12.3.1. Accessing Data in Code Segments ...................................................................12-10
12.4. RESTRICTING CONTROL TRANSFERS..............................................................12-10
12.5. GATE DESCRIPTORS.........................................................................................12-12
12.5.1. Stack Switching ................................................................................................12-15
12.5.2. Returning from a Procedure..............................................................................12-18
12.6. INSTRUCTIONS RESERVED FOR THE OPERATING SYSTEM..........................12-20
12.6.1. Privileged Instructions.......................................................................................12-20
12.6.2. Sensitive Instructions........................................................................................12-21
12.7. INSTRUCTIONS FOR POINTER VALIDATION.....................................................12-21
12.7.1. Descriptor Validation.........................................................................................12-23
12.7.2. Pointer Integrity and RPL..................................................................................12-23
12.8. PAGE-LEVEL PROTECTION ...............................................................................12-24
12.8.1. Page-Table Entries Hold Protection Parameters................................................12-24
12.8.1.1. RESTRICTING ADDRESSABLE DOMAIN ....................................................12-25
12.8.1.2. TYPE CHECKING.........................................................................................12-25
12.8.2. Combining Protection of Both Levels of Page Tables ........................................12-26
12.8.3. Overrides to Page Protection ............................................................................12-26
12.9. COMBINING PAGE AND SEGMENT PROTECTION............................................12-27
CHAPTER 13
PROTECTED-MODE MULTITASKING
13.1. TASK STATE SEGMENT .......................................................................................13-2
13.2. TSS DESCRIPTOR................................................................................................13-4
13.3. TASK REGISTER...................................................................................................13-5
13.4. TASK GATE DESCRIPTOR....................................................................................13-6
13.5. TASK SWITCHING.................................................................................................13-8
13.6. TASK LINKING.....................................................................................................13-11
E CONTENTS
PAGE
13.6.1. Busy Bit Prevents Loops...................................................................................13-13
13.6.2. Modifying Task Linkages...................................................................................13-14
13.7. TASK ADDRESS SPACE .....................................................................................13-14
13.7.1. Task Linear-to-Physical Space Mapping............................................................13-14
13.7.2. Task Logical Address Space.............................................................................13-15
CHAPTER 14
PROTECTED-MODE EXCEPTIONS AND INTERRUPTS
14.1. EXCEPTION AND INTERRUPT VECTORS............................................................14-1
14.2. INSTRUCTION RESTART......................................................................................14-3
14.3. ENABLING AND DISABLING INTERRUPTS...........................................................14-3
14.3.1. NMI Masks Further NMIs....................................................................................14-3
14.3.2. IF Masks INTR ...................................................................................................14-4
14.3.3. RF Masks Debug Faults .....................................................................................14-4
14.3.4. MOV or POP to SS Masks Some Exceptions and Interrupts ...............................14-5
14.4. PRIORITY AMONG SIMULTANEOUS EXCEPTIONS AND INTERRUPTS..............14-5
14.5. INTERRUPT DESCRIPTOR TABLE .......................................................................14-6
14.6. IDT DESCRIPTORS...............................................................................................14-8
14.7. INTERRUPT TASKS AND INTERRUPT PROCEDURES.........................................14-9
14.7.1. Interrupt Procedures.........................................................................................14-10
14.7.1.1. STACK OF INTERRUPT PROCEDURE........................................................14-11
14.7.1.2. RETURNING FROM AN INTERRUPT PROCEDURE....................................14-11
14.7.1.3. FLAG USAGE BY INTERRUPT PROCEDURE..............................................14-12
14.7.1.4. PROTECTION IN INTERRUPT PROCEDURES............................................14-12
14.7.2. Interrupt Tasks .................................................................................................14-12
14.8. ERROR CODE.....................................................................................................14-14
14.9. EXCEPTION CONDITIONS..................................................................................14-14
14.9.1. Interrupt 0—Divide Error...................................................................................14-15
14.9.2. Interrupt 1—Debug Exceptions .........................................................................14-15
14.9.3. Interrupt 3—Breakpoint.....................................................................................14-15
14.9.4. Interrupt 4—Overflow .......................................................................................14-16
14.9.5. Interrupt 5—Bounds Check...............................................................................14-16
14.9.6. Interrupt 6—Invalid Opcode ..............................................................................14-16
14.9.7. Interrupt 7—Device Not Available .....................................................................14-16
14.9.8. Interrupt 8—Double Fault..................................................................................14-17
14.9.9. Interrupt 9—(Intel reserved. Do not use.) ..........................................................14-18
14.9.10. Interrupt 10—Invalid TSS..................................................................................14-18
14.9.11. Interrupt 11—Segment Not Present ..................................................................14-19
14.9.12. Interrupt 12—Stack Exception ..........................................................................14-20
14.9.13. Interrupt 13—General Protection ......................................................................14-21
14.9.14. Interrupt 14—Page Fault...................................................................................14-22
14.9.14.1. PAGE FAULT DURING TASK SWITCH ........................................................14-23
14.9.14.2. PAGE FAULT WITH INCONSISTENT STACK POINTER ..............................14-23
14.9.15. Interrupt 16—Floating-Point Error .....................................................................14-24
14.9.15.1. NUMERICS EXCEPTION HANDLING...........................................................14-25
14.9.15.2. SIMULTANEOUS EXCEPTION RESPONSE.................................................14-26
14.9.16. Interrupt 17—Alignment Check .........................................................................14-27
14.9.17. Interrupt 18—Machine Check ...........................................................................14-28
14.10. EXCEPTION SUMMARY......................................................................................14-28
14.11. ERROR CODE SUMMARY ..................................................................................14-30
CONTENTS E
CHAPTER 15
INPUT/OUTPUT PAGE
15.1. I/O ADDRESSING..................................................................................................15-1
15.1.1. I/O Address Space .............................................................................................15-1
15.1.2. Memory-Mapped I/O...........................................................................................15-3
15.2. I/O INSTRUCTIONS...............................................................................................15-4
15.2.1. Register I/O Instructions .....................................................................................15-4
15.2.2. Block I/O Instructions..........................................................................................15-4
15.3. PROTECTED-MODE I/O........................................................................................15-5
15.3.1. I/O Privilege Level ..............................................................................................15-6
15.3.2. I/O Permission Bit Map .......................................................................................15-6
15.3.3. Paging and Caching............................................................................................15-8
15.4. ORDERING OF I/O ................................................................................................15-8
CHAPTER 16
INITIALIZATION AND MODE SWITCHING
16.1. PROCESSOR INITIALIZATION..............................................................................16-1
16.1.1. Processor State after Reset................................................................................16-2
16.1.2. First Instruction Executed ...................................................................................16-5
16.2. FPU INITIALIZATION .............................................................................................16-5
16.2.1. Configuring the Numerics Environment ...............................................................16-6
16.2.2. FPU Software Emulation.....................................................................................16-8
16.3. CACHE ENABLING................................................................................................16-9
16.4. SOFTWARE INITIALIZATION IN REAL-ADDRESS MODE.....................................16-9
16.4.1. System Tables..................................................................................................16-10
16.4.2. NMI Interrupt ....................................................................................................16-10
16.5. SOFTWARE INITIALIZATION IN PROTECTED MODE.........................................16-10
16.5.1. System Tables..................................................................................................16-10
16.5.2. Interrupts..........................................................................................................16-11
16.5.3. Paging..............................................................................................................16-11
16.5.4. Tasks ...............................................................................................................16-12
16.5.5. TLB, BTB and Cache Testing............................................................................16-12
16.6. MODE SWITCHING .............................................................................................16-12
16.6.1. Switching to Protected Mode ............................................................................16-13
16.6.2. Switching Back to Real-Address Mode..............................................................16-13
16.7. INITIALIZATION AND MODE SWITCHING EXAMPLE .........................................16-14
16.7.1. Goal of this Example.........................................................................................16-14
16.7.2. Memory Layout Following Reset .......................................................................16-14
16.7.3. The Algorithm ...................................................................................................16-15
16.7.4. Tool Usage.......................................................................................................16-17
16.7.5. STARTUP.ASM Listing .....................................................................................16-18
16.7.6. MAIN.ASM Source Code ..................................................................................16-26
16.7.7. Supporting Files................................................................................................16-29
E CONTENTS
CHAPTER 17
DEBUGGING PAGE
17.1. DEBUGGING SUPPORT........................................................................................17-1
17.2. DEBUG REGISTERS .............................................................................................17-2
17.2.1. Debug Address Registers (DR0-DR3).................................................................17-3
17.2.2. Debug Control Register (DR7) ............................................................................17-3
17.2.3. Debug Status Register (DR6)..............................................................................17-4
17.2.4. Debug Registers DR4 and DR5 ..........................................................................17-5
17.2.5. Breakpoint Field Recognition...............................................................................17-5
17.3. DEBUG EXCEPTIONS...........................................................................................17-6
17.3.1. Interrupt 1—Debug Exceptions ...........................................................................17-6
17.3.1.1. INSTRUCTION-BREAKPOINT FAULT............................................................17-7
17.3.1.2. DATA MEMORY AND I/O BREAKPOINTS......................................................17-8
17.3.1.3. GENERAL-DETECT FAULT............................................................................17-8
17.3.1.4. SINGLE-STEP TRAP......................................................................................17-9
17.3.1.5. TASK-SWITCH TRAP.....................................................................................17-9
17.3.2. Interrupt 3—Breakpoint Instruction....................................................................17-10
CHAPTER 18
CACHING, PIPELINING AND BUFFERING
18.1. INTERNAL INSTRUCTION AND DATA CACHES ...................................................18-1
18.1.1. Data Cache ........................................................................................................18-2
18.1.2. Data Cache Update Policies ...............................................................................18-3
18.1.3. Instruction Cache................................................................................................18-3
18.2. OPERATION OF THE INTERNAL CACHES...........................................................18-3
18.2.1. Cache Control Bits..............................................................................................18-4
18.2.2. Cache Management Instructions.........................................................................18-4
18.2.3. Self-Modifying Code ...........................................................................................18-5
18.3. PAGE-LEVEL CACHE MANAGEMENT ..................................................................18-5
18.3.1. PCD Bit ..............................................................................................................18-6
18.3.2. PWT Bit..............................................................................................................18-6
18.4. ADDRESS TRANSLATION CACHES......................................................................18-6
18.5. CACHE REPLACEMENT ALGORITHM..................................................................18-7
18.6. EXECUTION PIPELINING AND PAIRING...............................................................18-7
18.7. WRITE BUFFERS ..................................................................................................18-7
18.8. SERIALIZING INSTRUCTIONS..............................................................................18-7
CHAPTER 19
MULTIPROCESSING
19.1. LOCKED BUS CYCLES..........................................................................................19-1
19.1.1. LOCK Prefix and the LOCK# Signal....................................................................19-2
19.1.2. Automatic Locking ..............................................................................................19-2
19.2. MEMORY ACCESS ORDERING............................................................................19-3
19.3. Pentium® Processor (735\90, 815\100, 1000\120, 1110\133) INTEGRATED APIC ..19-4
19.3.1. Interrupt Control Mechanism...............................................................................19-6
19.3.1.1. VALID INTERRUPTS......................................................................................19-6
19.3.1.2. INTERRUPT SOURCES .................................................................................19-6
19.3.1.3. BUS ARBITRATION........................................................................................19-6
19.3.1.4. THE LOCAL APIC STRUCTURE.....................................................................19-7
19.3.1.5. INTERRUPT DESTINATION AND APIC ID .....................................................19-9
19.3.1.6. INTERRUPT DISTRIBUTION MODES ..........................................................19-11
19.3.1.7. LOCAL VECTOR TABLE ..............................................................................19-12
CONTENTS E
PAGE
19.3.1.8. INTER-PROCESSOR AND SELF INTERRUPTS...........................................19-14
19.3.1.9. INTERRUPT ACCEPTANCE.........................................................................19-18
19.3.1.9.1. Interrupt Acceptance Decision Flow Chart .................................................19-19
19.3.1.9.2. Task Priority Register ................................................................................19-21
19.3.1.9.3. Processor Priority Register (PPR) .............................................................19-21
19.3.1.9.4. Arbitration Priority Register (APR) .............................................................19-21
19.3.1.9.5. Spurious Interrupt .....................................................................................19-22
19.3.1.9.6. End-Of-Interrupt (EOI) ..............................................................................19-22
19.3.1.10. READING REMOTE APIC REGISTERS........................................................19-22
19.3.1.11. LOCAL APIC STATE ....................................................................................19-23
19.3.1.11.1. Spurious Interrupt Vector Register.............................................................19-23
19.3.1.11.2. Local APIC Initialization.............................................................................19-24
19.3.1.11.3. Local APIC State After Power-Up Reset and Init........................................19-24
19.3.1.12. LOCAL APIC VERSION REGISTER .............................................................19-25
19.3.2. APIC Bus And Inter-APIC Communication Protocol...........................................19-26
19.3.2.1. BUS ARBITRATION......................................................................................19-26
19.3.2.2. BUS MESSAGE FORMATS..........................................................................19-26
19.3.3. Error Handling In APIC .....................................................................................19-33
19.3.4. Timer................................................................................................................19-34
19.3.4.1. OVERVIEW ..................................................................................................19-34
19.3.5. APIC Valid/Invalid Programming Combination...................................................19-38
19.3.6. Software Visible Differences Between APIC and 82489DX................................19-39
19.3.7. Dual Processing Bootup Handshake Protocol Sequence With Examples...........19-40
CHAPTER 20
POWER MANAGEMENT
20.1. PENTIUM® PROCESSOR (510\60,567\66) POWER MANAGEMENT.....................20-1
20.1.1. Introduction to System Management Mode Architecture......................................20-1
20.1.2. Terminology........................................................................................................20-1
20.1.3. Pentium® Processor System Management Interrupt Processing..........................20-2
20.1.3.1. SMRAM..........................................................................................................20-2
20.1.3.2. SMRAM STATE SAVE MAP ...........................................................................20-4
20.1.3.3. EXIT FROM SMM...........................................................................................20-6
20.1.4. System Management Mode Programming Model ................................................20-7
20.1.4.1. SMM ENTRY..................................................................................................20-7
20.1.4.2. PROCESSOR ENVIRONMENT ......................................................................20-9
20.1.4.3. EXECUTING SYSTEM MANAGEMENT MODE HANDLER...........................20-10
20.1.4.4. EXCEPTIONS AND INTERRUPTS WITHIN SMM.........................................20-10
20.1.5. SMM Features..................................................................................................20-11
20.1.5.1. SMM REVISION IDENTIFIER .......................................................................20-11
20.1.5.2. HALT AUTO RESTART.................................................................................20-12
20.1.5.3. SMM BASE RELOCATION...........................................................................20-12
20.1.6. Pentium® Processor SMM - Software Considerations........................................20-14
20.1.6.1. SMM CODE CONSIDERATIONS..................................................................20-14
20.1.6.2. EXCEPTION HANDLING..............................................................................20-15
20.1.6.3. HALT DURING SMM ....................................................................................20-15
20.1.6.4. RELOCATING SMRAM TO AN ADDRESS ABOVE ONE MEGABYTE..........20-15
20.2. PENTIUM® PROCESSOR (735\90, 815\100, 1000\120, 1110\133) POWER
MANAGEMENT....................................................................................................20-16
20.2.1. System Management Mode Architecture...........................................................20-16
20.2.2. Pentium® Processor (735\90, 815\100, 1000\120, 1110\133) Power Management
Differences vs. Pentium Processor (510\60, 567\66) .........................................20-16
E CONTENTS
PAGE
20.2.3. System Management Interrupt Via APIC...........................................................20-17
20.2.4. I/O Instruction Restart.......................................................................................20-17
20.2.4.1. ENABLING I/O INSTRUCTION RESTART ....................................................20-17
20.2.4.2. SMRAM STATE SAVE MAP .........................................................................20-17
20.2.4.2.1. I/O Instruction Restart Slot ........................................................................20-19
20.2.4.3. BACK-TO-BACK SMI# AND I/O INSTRUCTION RESTART...........................20-20
20.2.4.4. EXIT FROM SMM.........................................................................................20-20
20.2.5. System Management Mode Revision Identifier..................................................20-20
20.2.6. SMM — Dual Processing Considerations..........................................................20-21
20.2.6.1. DP SMI DELIVERY.......................................................................................20-22
20.2.6.2. DP SMRAM ..................................................................................................20-22
20.2.6.3. DP SMIACT#................................................................................................20-22
CONTENTS E
PART III — COMPATIBILITY
CHAPTER 21
MIXING 16-BIT AND 32-BIT CODE
21.1. USING 16-BIT AND 32-BIT ENVIRONMENTS........................................................21-1
21.2. MIXING 16-BIT AND 32-BIT OPERATIONS ...........................................................21-2
21.3. SHARING DATA AMONG MIXED-SIZE CODE SEGMENTS...................................21-3
21.4. TRANSFERRING CONTROL AMONG MIXED-SIZE CODE SEGMENTS ...............21-4
21.4.1. Size of Code-Segment Pointer............................................................................21-4
21.4.2. Stack Management for Control Transfer..............................................................21-4
21.4.2.1. CONTROLLING THE OPERAND SIZE FOR A CALL ......................................21-7
21.4.2.2. CHANGING SIZE OF A CALL.........................................................................21-7
21.4.3. Interrupt Control Transfers..................................................................................21-8
21.4.4. Parameter Translation ........................................................................................21-8
21.4.5. The Interface Procedure .....................................................................................21-8
CHAPTER 22
VIRTUAL-8086 MODE
22.1. EXECUTING 8086 CPU CODE...............................................................................22-1
22.1.1. Registers and Instructions ..................................................................................22-2
22.1.2. Address Translation............................................................................................22-3
22.2. STRUCTURE OF A VIRTUAL-8086 TASK..............................................................22-4
22.2.1. Paging for Virtual-8086 Tasks.............................................................................22-4
22.2.2. Protection within a Virtual-8086 Task ..................................................................22-5
22.3. ENTERING AND LEAVING VIRTUAL-8086 MODE.................................................22-5
22.3.1. Transitions Through Task Switches.....................................................................22-7
22.3.2. Transitions Through Trap Gates and Interrupt Gates ..........................................22-8
22.4. SENSITIVE INSTRUCTIONS..................................................................................22-9
22.5. VIRTUAL INTERRUPT SUPPORT..........................................................................22-9
22.6. EMULATING 8086 OPERATING SYSTEM CALLS ...............................................22-10
22.7. VIRTUAL I/O ........................................................................................................22-10
22.7.1. I/O-Mapped I/O ................................................................................................22-11
22.7.2. Memory-Mapped I/O.........................................................................................22-11
22.7.3. Special I/O Buffers............................................................................................22-12
22.8. DIFFERENCES FROM 8086 CPU........................................................................22-12
22.9. DIFFERENCES FROM INTEL 286 CPU ...............................................................22-15
22.9.1. Privilege Level ..................................................................................................22-15
22.9.2. Bus Lock ..........................................................................................................22-16
22.10. DIFFERENCES FROM Intel386™ AND Intel486™ CPUs ....................................22-16
CHAPTER 23
COMPATIBILITY
23.1. RESERVED BITS...................................................................................................23-1
23.2. INTEGER UNIT......................................................................................................23-2
23.2.1. New Functions and Modes..................................................................................23-2
23.2.2. Serializing Instructions........................................................................................23-2
23.2.3. Detecting the Presence of New Features ............................................................23-2
23.2.4. Undefined Opcodes ............................................................................................23-3
23.2.5. Clock Counts ......................................................................................................23-3
23.2.6. Initialization and Reset........................................................................................23-3
23.2.6.1. INTEGER UNIT INITIALIZATION AND RESET................................................23-3
E CONTENTS
PAGE
23.2.6.2. FPU/NPX INITIALIZATION AND RESET.........................................................23-4
23.2.6.3. Intel486 SX MICROPROCESSOR AND Intel487™ SX MATH COPROCESSOR
INITIALIZATION .............................................................................................23-7
23.2.7. New Instructions.................................................................................................23-8
23.2.7.1. NEW PENTIUM® PROCESSOR INSTRUCTIONS...........................................23-8
23.2.7.2. NEW Intel486 PROCESSOR INSTRUCTIONS................................................23-9
23.2.7.3. NEW Intel386 PROCESSOR INSTRUCTIONS................................................23-9
23.2.8. Obsolete Instructions..........................................................................................23-9
23.2.9. Flags ..................................................................................................................23-9
23.2.9.1. NEW PENTIUM® PROCESSOR FLAGS.......................................................23-10
23.2.9.2. NEW Intel486 PROCESSOR FLAGS ............................................................23-10
23.2.10. Control Registers..............................................................................................23-11
23.2.10.1. PENTIUM® PROCESSOR CONTROL REGISTERS......................................23-11
23.2.10.2. Intel486 PROCESSOR CONTROL REGISTERS...........................................23-12
23.2.11. Debug Registers...............................................................................................23-14
23.2.11.1. DIFFERENCES IN DR6 ................................................................................23-14
23.2.11.2. DIFFERENCES IN DR7 ................................................................................23-14
23.2.11.3. DEBUG REGISTERS 4 AND 5......................................................................23-14
23.2.12. Test Registers ..................................................................................................23-15
23.2.13. Model Specific Registers...................................................................................23-15
23.2.14. Exceptions........................................................................................................23-15
23.2.14.1. NEW PENTIUM® PROCESSOR EXCEPTIONS ............................................23-15
23.2.14.2. NEW Intel486 PROCESSOR EXCEPTIONS .................................................23-16
23.2.14.3. NEW Intel386 PROCESSOR EXCEPTIONS .................................................23-16
23.2.14.4. INTERRUPT PROPAGATION DELAY...........................................................23-16
23.2.14.5. PRIORITY OF EXCEPTIONS........................................................................23-16
23.2.14.6. DIVIDE-ERROR EXCEPTIONS.....................................................................23-17
23.2.14.7. WRITES USING THE CS REGISTER PREFIX..............................................23-17
23.2.14.8. NMI INTERRUPTS........................................................................................23-17
23.2.14.9. INTERRUPT VECTOR TABLE LIMIT............................................................23-18
23.2.14.10. INTERRUPTS INSIDE SYSTEM MANAGEMENT MODE..............................23-18
23.2.15. Descriptor Types and Contents.........................................................................23-18
23.2.16. Changes in Segment Descriptor Loads .............................................................23-18
23.2.17. Task Switching and Task State Segments.........................................................23-18
23.2.17.1. PENTIUM® PROCESSOR TASK STATE SEGMENTS ..................................23-18
23.2.17.2. TSS SELECTOR WRITES ............................................................................23-19
23.2.17.3. ORDER OF READS/WRITES TO THE TSS..................................................23-19
23.2.17.4. USING A 16-BIT TSS WITH 32-BIT CONSTRUCTS......................................23-19
23.2.17.4.1. Differences in I/O Map Base Addresses ....................................................23-19
23.2.17.4.2. Caching, Pipe-lining, Prefetching...............................................................23-20
23.2.17.5. SELF MODIFYING CODE WITH CACHE ENABLED.....................................23-21
23.2.18. Paging..............................................................................................................23-21
23.2.18.1. PENTIUM® PROCESSOR PAGING..............................................................23-22
23.2.18.2. Intel486 PROCESSOR PAGING...................................................................23-22
23.2.18.3. ENABLING AND DISABLING PAGING .........................................................23-22
23.2.19. Stack Operations..............................................................................................23-22
23.2.19.1. PUSH SP......................................................................................................23-22
23.2.19.2. FLAGS PUSHED ON THE STACK................................................................23-23
23.2.19.3. SELECTOR PUSHES/POPS.........................................................................23-23
23.2.19.4. ERROR CODE PUSHES ..............................................................................23-23
23.2.19.5. FAULT HANDLING EFFECTS ON THE STACK............................................23-24
CONTENTS E
PAGE
23.2.19.6. INTERLEVEL RET/IRET FROM A 16-BIT INTERRUPT OR CALL GATE.......23-24
23.2.20. Mixing 16- and 32-Bit Segments .......................................................................23-24
23.2.21. Segment and Address Wraparound ..................................................................23-25
23.2.21.1. SEGMENT WRAPAROUND..........................................................................23-25
23.2.22. Write Buffers and Memory Ordering..................................................................23-26
23.2.23. Bus Locking......................................................................................................23-26
23.2.24. Bus Hold...........................................................................................................23-27
23.2.25. Two Ways to Run Intel 286 CPU Tasks.............................................................23-27
23.3. FLOATING-POINT UNIT ......................................................................................23-28
23.3.1. Control Register Bits.........................................................................................23-28
23.3.1.1. EXTENSION TYPE (ET) BIT.........................................................................23-28
23.3.1.2. NUMERIC EXCEPTION (NE) BIT .................................................................23-28
23.3.1.3. MONITOR COPROCESSOR (MP) BIT .........................................................23-29
23.3.1.4. FPU STATUS WORD....................................................................................23-29
23.3.1.5. CONTROL WORD........................................................................................23-30
23.3.1.6. TAG WORD..................................................................................................23-30
23.3.2. Data Types.......................................................................................................23-30
23.3.2.1. NaNs ............................................................................................................23-31
23.3.2.2. PSEUDOZERO, PSEUDO-NaN, PSEUDEOINFINITY, AND UNNORMAL
FORMATS....................................................................................................23-31
23.3.3. Exceptions........................................................................................................23-31
23.3.3.1. DENORMAL EXCEPTIONS..........................................................................23-31
23.3.3.2. OVERFLOW EXCEPTIONS..........................................................................23-32
23.3.3.3. UNDERFLOW EXCEPTIONS........................................................................23-32
23.3.3.4. EXCEPTION PRECEDENCE ........................................................................23-33
23.3.3.5. CS AND IP FOR FPU EXCEPTIONS ............................................................23-33
23.3.3.6. FPU ERROR SIGNALS.................................................................................23-33
23.3.3.7. INVALID OPERATION ON DENORMALS .....................................................23-34
23.3.3.8. ALIGNMENT EXCEPTIONS..........................................................................23-34
23.3.3.9. SEGMENT FAULT DURING FLDENV...........................................................23-34
23.3.3.10. INTERRUPT 7 — DEVICE NOT AVAILABLE ................................................23-34
23.3.3.11. INTERRUPT 9 — COPROCESSOR SEGMENT OVERRUN..........................23-34
23.3.3.12. INTERRUPT 13 — GENERAL PROTECTION...............................................23-35
23.3.3.13. INTERRUPT 16 — FLOATING-POINT ERROR.............................................23-35
23.3.4. Instructions.......................................................................................................23-35
23.3.5. Transcendental Instructions ..............................................................................23-38
23.3.6. Obsolete Instructions........................................................................................23-38
23.3.6.1. WAIT PREFIX DIFFERENCES......................................................................23-38
23.3.6.2. OPERANDS SPLIT ACROSS SEGMENTS/PAGES ......................................23-39
23.3.6.3. FPU INSTRUCTION SYNCHRONIZATION...................................................23-39
23.3.7. Numeric Exceptions: Interrupt Sampling Window ..............................................23-39
23.3.7.1. USAGE OF THE “NO-WAIT” FLOATING-POINT INSTRUCTION CLASS......23-41
E CONTENTS
PART IV — OPTIMIZATION
CHAPTER 24
OPTIMIZATION PAGE
24.1. ADDRESSING MODES AND REGISTER USAGE..................................................24-1
24.2. ALIGNMENT ..........................................................................................................24-2
24.2.1. Code Alignment..................................................................................................24-2
24.2.2. Data Alignment...................................................................................................24-3
24.3. PREFIXED OPCODES...........................................................................................24-3
24.4. OPERAND AND REGISTER USAGE......................................................................24-3
24.5. INTEGER INSTRUCTION SELECTION..................................................................24-4
PART V — INSTRUCTION SET
CHAPTER 25
INSTRUCTION SET
25.1. OPERAND-SIZE AND ADDRESS-SIZE ATTRIBUTES............................................25-1
25.1.1. Default Segment Attribute...................................................................................25-1
25.1.2. Operand-Size and Address-Size Instruction Prefixes...........................................25-1
25.1.3. Address-Size Attribute for Stack .........................................................................25-2
25.2. INSTRUCTION FORMAT .......................................................................................25-2
25.2.1. ModR/M and SIB Bytes ......................................................................................25-4
25.2.2. How to Read the Instruction Set Pages...............................................................25-9
25.2.2.1. OPCODE COLUMN........................................................................................25-9
25.2.2.2. INSTRUCTION COLUMN .............................................................................25-10
25.2.2.3. CLOCKS COLUMN.......................................................................................25-12
25.2.2.4. DESCRIPTION COLUMN .............................................................................25-13
25.2.2.5. OPERATION ................................................................................................25-13
25.2.2.6. DESCRIPTION .............................................................................................25-18
25.2.2.7. FLAGS AFFECTED ......................................................................................25-18
25.2.2.8. PROTECTED MODE EXCEPTIONS.............................................................25-19
25.2.2.9. REAL ADDRESS MODE EXCEPTIONS........................................................25-20
25.2.2.10. VIRTUAL-8086 MODE EXCEPTIONS...........................................................25-20
AAA—ASCII Adjust after Addition ....................................................................................25-21
AAD—ASCII Adjust AX before Division ............................................................................25-23
AAM—ASCII Adjust AX after Multiply ...............................................................................25-24
AAS—ASCII Adjust AL after Subtraction ..........................................................................25-25
ADC—Add with Carry ......................................................................................................25-27
ADD—Add.......................................................................................................................25-29
AND—Logical AND..........................................................................................................25-31
ARPL—Adjust RPL Field of Selector ................................................................................25-33
BOUND—Check Array Index Against Bounds ..................................................................25-35
BSF—Bit Scan Forward ...................................................................................................25-37
BSR—Bit Scan Reverse...................................................................................................25-39
BSWAP—Byte Swap .......................................................................................................25-41
BT—Bit Test ....................................................................................................................25-42
BTC—Bit Test and Complement ......................................................................................25-44
BTR—Bit Test and Reset.................................................................................................25-46
BTS—Bit Test and Set.....................................................................................................25-48
CALL—Call Procedure.....................................................................................................25-50
CBW/CWDE—Convert Byte to Word/Convert Word to Doubleword..................................25-57
CONTENTS E
PAGE
CDQ—Convert Double to Quad .......................................................................................25-58
CLC—Clear Carry Flag ....................................................................................................25-59
CLD—Clear Direction Flag...............................................................................................25-60
CLI—Clear Interrupt Flag .................................................................................................25-61
CLTS—Clear Task-Switched Flag in CR0.........................................................................25-63
CMC—Complement Carry Flag........................................................................................25-64
CMP—Compare Two Operands.......................................................................................25-65
CMPS/CMPSB/CMPSW/CMPSD—Compare String Operands.........................................25-67
CMPXCHG—Compare and Exchange .............................................................................25-70
CMPXCHG8B—Compare and Exchange 8 Bytes.............................................................25-72
CPUID—CPU Identification..............................................................................................25-74
CWD/CDQ—Convert Word to Double/Convert Double to Quad........................................25-76
CWDE—Convert Word to Doubleword .............................................................................25-77
DAA—Decimal Adjust AL after Addition............................................................................25-78
DAS—Decimal Adjust AL after Subtraction.......................................................................25-79
DEC—Decrement by 1.....................................................................................................25-80
DIV—Unsigned Divide......................................................................................................25-81
ENTER—Make Stack Frame for Procedure Parameters...................................................25-83
F2XM1—Compute 2x–1...................................................................................................25-85
FABS—Absolute Value ....................................................................................................25-86
FADD/FADDP/FIADD—Add.............................................................................................25-87
FBLD—Load Binary Coded Decimal.................................................................................25-89
FBSTP—Store Binary Coded Decimal and Pop................................................................25-91
FCHS—Change Sign.......................................................................................................25-92
FCLEX/FNCLEX—Clear Exceptions.................................................................................25-93
FCOM/FCOMP/FCOMPP—Compare Real.......................................................................25-94
FCOS—Cosine................................................................................................................25-96
FDECSTP—Decrement Stack-Top Pointer.......................................................................25-97
FDIV/FDIVP/FIDIV—Divide..............................................................................................25-98
FDIVR/FDIVRP/FIDIVR—Reverse Divide.......................................................................25-100
FFREE—Free Floating-Point Register............................................................................25-102
FICOM/FICOMP—Compare Integer...............................................................................25-103
FILD—Load Integer .......................................................................................................25-105
FINCSTP—Increment Stack-Top Pointer .......................................................................25-106
FINIT/FNINIT—Initialize Floating-Point Unit....................................................................25-107
FIST/FISTP—Store Integer............................................................................................25-109
FLD—Load Real............................................................................................................25-110
FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ—Load Constant........................25-112
FLDCW—Load Control Word.........................................................................................25-114
FLDENV—Load FPU Environment.................................................................................25-116
FMUL/FMULP/FIMUL—Multiply .....................................................................................25-118
FNOP—No Operation ....................................................................................................25-120
FPATAN—Partial Arctangent .........................................................................................25-121
FPREM—Partial Remainder...........................................................................................25-122
FPREM1—Partial Remainder.........................................................................................25-124
FPTAN—Partial Tangent................................................................................................25-126
FRNDINT—Round to Integer .........................................................................................25-128
FRSTOR—Restore FPU State.......................................................................................25-129
FSAVE/FNSAVE—Store FPU State...............................................................................25-131
FSCALE—Scale ............................................................................................................25-133
FSIN—Sine....................................................................................................................25-134
FSINCOS—Sine and Cosine..........................................................................................25-135
E CONTENTS
PAGE
FSQRT—Square Root ...................................................................................................25-137
FST/FSTP—Store Real..................................................................................................25-138
FSTCW/FNSTCW—Store Control Word.........................................................................25-140
FSTENV/FNSTENV—Store FPU Environment ...............................................................25-141
FSTSW/FNSTSW—Store Status Word ..........................................................................25-143
FSUB/FSUBP/FISUB—Subtract.....................................................................................25-145
FSUBR/FSUBRP/FISUBR—Reverse Subtract................................................................25-147
FTST—TEST.................................................................................................................25-149
FUCOM/FUCOMP/FUCOMPP—Unordered Compare Real............................................25-151
FWAIT—Wait.................................................................................................................25-153
FXAM—Examine ...........................................................................................................25-154
FXCH—Exchange Register Contents.............................................................................25-156
FXTRACT—Extract Exponent and Significand................................................................25-158
FYL2X—Compute y ? log2x...........................................................................................25-160
FYL2XP1—Compute y ? log2(x +1) ...............................................................................25-161
HLT—Halt......................................................................................................................25-163
IDIV—Signed Divide ......................................................................................................25-164
IMUL—Signed Multiply...................................................................................................25-166
IN—Input from Port........................................................................................................25-168
INC—Increment by 1 .....................................................................................................25-170
INS/INSB/INSW/INSD—Input from Port to String ...........................................................25-171
INT/INTO—Call to Interrupt Procedure...........................................................................25-173
INVD—Invalidate Cache ................................................................................................25-181
INVLPG—Invalidate TLB Entry ......................................................................................25-183
IRET/IRETD—Interrupt Return.......................................................................................25-184
Jcc—Jump if Condition is Met ........................................................................................25-190
JMP—Jump...................................................................................................................25-193
LAHF—Load Flags into AH Register ..............................................................................25-198
LAR—Load Access Rights Byte .....................................................................................25-199
LDS/LES/LFS/LGS/LSS—Load Full Pointer ...................................................................25-201
LEA—Load Effective Address ........................................................................................25-204
LEAVE—High Level Procedure Exit ...............................................................................25-206
LES—Load Full Pointer..................................................................................................25-207
LFS—Load Full Pointer..................................................................................................25-208
LGDT/LIDT—Load Global/Interrupt Descriptor Table Register........................................25-209
LGS—Load Full Pointer .................................................................................................25-211
LLDT—Load Local Descriptor Table Register.................................................................25-212
LIDT—Load Interrupt Descriptor Table Register.............................................................25-213
LMSW—Load Machine Status Word ..............................................................................25-214
LOCK—Assert LOCK# Signal Prefix ..............................................................................25-215
LODS/LODSB/LODSW/LODSD—Load String Operand..................................................25-217
LOOP/LOOPcond—Loop Control with CX Counter.........................................................25-219
LSL—Load Segment Limit .............................................................................................25-221
LSS—Load Full Pointer..................................................................................................25-223
LTR—Load Task Register..............................................................................................25-224
MOV—Move Data..........................................................................................................25-225
MOV—Move to/from Control Registers ..........................................................................25-228
MOV—Move to/from Debug Registers ...........................................................................25-229
MOVS/MOVSB/MOVSW/MOVSD—Move Data from String to String ..............................25-231
MOVSX—Move with Sign-Extend ..................................................................................25-233
MOVZX—Move with Zero-Extend ..................................................................................25-234
MUL—Unsigned Multiplication of AL, AX, or EAX...........................................................25-235
CONTENTS E
PAGE
NEG—Two's Complement Negation...............................................................................25-237
NOP—No Operation ......................................................................................................25-238
NOT—One's Complement Negation...............................................................................25-239
OR—Logical Inclusive OR..............................................................................................25-240
OUT—Output to Port .....................................................................................................25-242
OUTS/OUTSB/OUTSW/OUTSD—Output String to Port .................................................25-244
POP—Pop a Word from the Stack .................................................................................25-247
POPA/POPAD—Pop all General Registers ....................................................................25-250
POPF/POPFD—Pop Stack into FLAGS or EFLAGS Register.........................................25-252
PUSH—Push Operand onto the Stack ...........................................................................25-254
PUSHA/PUSHAD—Push all General Registers..............................................................25-256
PUSHF/PUSHFD—Push Flags Register onto the Stack .................................................25-258
RCL/RCR/ROL/ROR-—Rotate.......................................................................................25-260
RDMSR—Read from Model Specific Register ................................................................25-263
RDTSC—Read from Time Stamp Counter .....................................................................25-265
REP/REPE/REPZ/REPNE/REPNZ—Repeat Following String Operation.........................25-267
RET—Return from Procedure ........................................................................................25-271
ROL/ROR—Rotate ........................................................................................................25-275
RSM—Resume from System Management Mode ..........................................................25-276
SAHF—Store AH into Flags ...........................................................................................25-277
SAL/SAR/SHL/SHR—Shift Instructions ..........................................................................25-278
SBB—Integer Subtraction with Borrow ...........................................................................25-281
SCAS/SCASB/SCASW/SCASD—Compare String Data..................................................25-283
SETcc—Byte Set on Condition.......................................................................................25-285
SGDT/SIDT—Store Global/Interrupt Descriptor Table Register.......................................25-287
SHL/SHR—Shift Instructions..........................................................................................25-289
SHLD—Double Precision Shift Left ................................................................................25-290
SHRD—Double Precision Shift Right..............................................................................25-292
SIDT—Store Interrupt Descriptor Table Register ............................................................25-294
SLDT—Store Local Descriptor Table Register................................................................25-295
SMSW—Store Machine Status Word .............................................................................25-297
STC—Set Carry Flag .....................................................................................................25-298
STD—Set Direction Flag................................................................................................25-299
STI—Set Interrupt Flag ..................................................................................................25-300
STOS/STOSB/STOSW/STOSD—Store String Data .......................................................25-302
STR—Store Task Register.............................................................................................25-304
SUB—Integer Subtraction..............................................................................................25-305
TEST—Logical Compare ...............................................................................................25-307
VERR, VERW—Verify a Segment for Reading or Writing ...............................................25-308
WAIT—Wait...................................................................................................................25-310
WBINVD—Write-Back and Invalidate Cache ..................................................................25-311
WRMSR—Write to Model Specific Register....................................................................25-313
XADD—Exchange and Add............................................................................................25-315
XCHG—Exchange Register/Memory with Register.........................................................25-317
XLAT/XLATB—Table Look-up Translation......................................................................25-319
XOR—Logical Exclusive OR ..........................................................................................25-321
E CONTENTS
CHAPTER 26
PERFORMANCE MONITORING PAGE
26.1. MODEL SPECIFIC REGISTERS ............................................................................26-1
26.1.1. Model Specific Register Usage Restrictions ........................................................26-1
26.1.2. Model Specific Registers Related to Performance Monitoring ..............................26-2
26.2. PERFORMANCE MONITORING............................................................................26-2
26.2. PERFORMANCE MONITORING............................................................................26-2
26.2.1. Performance Monitoring Feature Overview .........................................................26-3
26.2.2. Time Stamp Counter - TSC.................................................................................26-3
26.2.3. Programmable Event Counters - CTR0, CTR1 ....................................................26-3
26.2.4. Control and Event Select Register - CESR..........................................................26-4
26.2.4.1. EVENT SELECT - ES0, ES1...........................................................................26-4
26.2.4.2. COUNTER CONTROL - CC0, CC1 .................................................................26-4
26.2.4.3. PIN CONTROL - PC0, PC1.............................................................................26-5
26.2.5. Events................................................................................................................26-6
APPENDIX A
OPCODE MAP
APPENDIX B
FLAG CROSS-REFERENCE
APPENDIX C
STATUS FLAG SUMMARY
APPENDIX D
CONDITION CODE
APPENDIX E
NUMERIC EXCEPTION SUMMARY
APPENDIX F
INSTRUCTION FORMAT AND TIMING
APPENDIX G
REPORT ON TRANSCENDENTAL FUNCTIONS
APPENDIX H
ADVANCED FEATURES
CONTENTS E
Figures
Figure Title Page
1-1. Bit and Byte Order............................................................................................... 1-6
3-1. Segmented Addressing........................................................................................ 3-3
3-2. Fundamental Data Types..................................................................................... 3-4
3-3. Bytes, Words, Doublewords and Quadwords in Memory ...................................... 3-5
3-4. Data Types.......................................................................................................... 3-7
3-5. Application Register Set....................................................................................... 3-9
3-6. An Unsegmented Memory ..................................................................................3-11
3-7. A Segmented Memory........................................................................................3-11
3-8. Stacks ................................................................................................................3-13
3-9. EFLAGS Register ...............................................................................................3-14
3-10. Effective Address Computation ...........................................................................3-21
4-1. PUSH Instruction ................................................................................................. 4-2
4-2. PUSHA Instruction............................................................................................... 4-3
4-3. POP Instruction ................................................................................................... 4-4
4-4. POPA Instruction................................................................................................. 4-4
4-5. Sign Extension..................................................................................................... 4-5
4-6. SHL/SAL Instruction ...........................................................................................4-14
4-7. SHR Instruction ..................................................................................................4-15
4-8. SAR Instruction ..................................................................................................4-15
4-9. SHLD Instruction ................................................................................................4-16
4-10. SHRD Instruction................................................................................................4-17
4-11. ROL Instruction ..................................................................................................4-18
4-12. ROR Instruction..................................................................................................4-18
4-13. RCL Instruction...................................................................................................4-18
4-14. RCR Instruction ..................................................................................................4-19
4-15. Nested Procedures.............................................................................................4-33
4-16. Stack Frame after Entering MAIN .......................................................................4-34
4-17. Stack Frame after Entering PROCEDURE A.......................................................4-35
4-18. Stack Frame after Entering PROCEDURE B.......................................................4-36
4-19. Stack Frame after Entering PROCEDURE C.......................................................4-37
4-20. Low Byte of EFLAGS Register ............................................................................4-39
4-21. Flags Used with PUSHF and POPF ....................................................................4-39
4-22. EAX Following the CPUID Instruction..................................................................4-47
6-1. Floating-Point Unit Register Set ........................................................................... 6-8
6-2. FPU Status Word................................................................................................6-10
6-3. FPU Control Word Format ..................................................................................6-13
6-4. Tag Word Format ...............................................................................................6-14
6-5. Opcode Field......................................................................................................6-16
6-6. Protected-Mode Numeric Instruction and Data Pointer Image in Memory,
32-Bit Format .....................................................................................................6-17
6-7. Real Mode Numeric Instruction and Data Pointer Image in Memory, 32-Bit Format6-17
6-8. Protected-Mode Numeric Instruction and Data Pointer Image in Memory,
16-Bit Format .....................................................................................................6-18
6-9. Real Mode Numeric Instruction and Data Pointer Image in Memory, 16-Bit Format6-18
6-10. Double-Precision Number System.......................................................................6-20
6-11. Numerical Data Formats .....................................................................................6-22
6-12. Instructions and Register Stack...........................................................................6-46
7-1. Arithmetic Example Using Infinity........................................................................7-20
8-1. Relationships Between Adjacent Joints ...............................................................8-26
9-1. 8086 Address Translation .................................................................................... 9-2
E CONTENTS
Figure Title Page
10-1. System Flags......................................................................................................10-2
10-2. Memory Management Registers .........................................................................10-4
10-3. Control Registers................................................................................................10-6
10-4. Debug Registers...............................................................................................10-10
11-1. Flat Model ..........................................................................................................11-4
11-2. Protected Flat Model...........................................................................................11-5
11-3. Multisegment Model............................................................................................11-6
11-4. TI Bit Selects Descriptor Table............................................................................11-8
11-5. Segment Translation...........................................................................................11-9
11-6. Segment Registers .............................................................................................11-9
11-7. Segment Selector.............................................................................................11-10
11-8. Segment Descriptors ........................................................................................11-12
11-9. Segment Descriptor (Segment Not Present) .....................................................11-15
11-10. Descriptor Tables .............................................................................................11-16
11-11. Pseudo-Descriptor Format................................................................................11-17
11-12. Format of a Linear Address ..............................................................................11-18
11-13. Page Translation ..............................................................................................11-19
11-14. Format of Page Directory and Page Table Entries for 4K Pages.......................11-20
11-15. Format of a Page Table Entry for a Not-Present Page.......................................11-21
11-16. Combined Segment and Page Address Translation...........................................11-24
11-17. Each Segment Can Have Its Own Page Table ..................................................11-25
12-1. Descriptor Fields Used for Protection ..................................................................12-3
12-2. Protection Rings .................................................................................................12-8
12-3. Privilege Check for Data Access .........................................................................12-9
12-4. Privilege Check for Control Transfer Without Gate ............................................12-11
12-5. Call Gate ..........................................................................................................12-12
12-6. Call Gate Mechanism .......................................................................................12-13
12-7. Privilege Check for Control Transfer with Call Gate ...........................................12-14
12-8. Initial Stack Pointers in a TSS ...........................................................................12-16
12-9. Stack Frame during Interlevel Call ....................................................................12-18
12-10. Protection Fields of a Page Table Entry ............................................................12-25
13-1. 32-Bit Task State Segment .................................................................................13-3
13-2. TSS Descriptor ...................................................................................................13-4
13-3. Task Register .....................................................................................................13-6
13-4. Task Gate Descriptor..........................................................................................13-7
13-5. Task Gates Reference Tasks..............................................................................13-8
13-6. Nested Tasks ...................................................................................................13-12
13-7. Overlapping Linear-to-Physical Mappings .........................................................13-16
14-1. IDTR Locates IDT in Memory..............................................................................14-7
14-2. IDT Gate Descriptors..........................................................................................14-9
14-3. Interrupt Procedure Call....................................................................................14-10
14-4. Stack Frame after Exception or Interrupt...........................................................14-11
14-5. Interrupt Task Switch ........................................................................................14-13
14-6. Error Code........................................................................................................14-14
14-7. Page Fault Error Code......................................................................................14-23
15-1. Memory-Mapped I/O...........................................................................................15-3
15-2. I/O Permission Bit Map .......................................................................................15-7
16-1. Contents of the EDX Register after Reset ...........................................................16-2
16-2. Contents of CR0 Register after Reset .................................................................16-3
16-3. Processor State after Reset..............................................................................16-15
16-4. Constructing Temp_GDT and Switching to Protected Mode (Lines 162-172 of List
File)..................................................................................................................16-27
CONTENTS E
Figure Title Page
16-5. Moving the GDT, IDT and TSS from ROM to RAM (Lines 196-261 of List File)..16-28
16-6. Task Switching (Lines 282-296 of List File) .......................................................16-29
17-1. Debug Registers.................................................................................................17-3
19-1. Local APIC Within a Pentium Processor (735\90, 815\100, 1000\120, 1110\133)-
Based MP System..............................................................................................19-5
19-2. Local APIC Structure ..........................................................................................19-8
19-3. Local APIC ID Register.......................................................................................19-9
19-4. Logical Destination Register (LDR) ...................................................................19-10
19-5. Destination Format Register (DFR) ...................................................................19-10
19-6. Local Vector Table (LVT) ..................................................................................19-12
19-7. Interrupt Command Register (ICR) ...................................................................19-15
19-8. IRR, ISR and TMR Registers ............................................................................19-19
19-9. Interrupt Acceptance Flow Chart for Local APIC...............................................19-20
19-10. Task Priority Register (TPR) .............................................................................19-21
19-11. EOI Register.....................................................................................................19-22
19-12. Remote Register (RR) ......................................................................................19-23
19-13. Spurious Interrupt Vector Register (SVR)..........................................................19-24
19-14. Local APIC Version Register.............................................................................19-25
19-15. Error Status Register (ESR)..............................................................................19-34
19-16. Divide Configuration Register............................................................................19-35
19-17. Initial Count and Current Count Registers .........................................................19-35
20-1. Redirecting System Memory Addresses to SMRAM............................................20-3
20-2. Transition to and from System Management Mode .............................................20-8
20-3. SMM Revision Identifier ....................................................................................20-11
20-4. Halt Auto Restart ..............................................................................................20-12
20-5. SMM Base Relocation ......................................................................................20-13
20-6. SMRAM Usage.................................................................................................20-14
20-7. I/O Instruction Restart Slot................................................................................20-19
20-8. System Revision Identifier.................................................................................20-21
21-1. Stack after Far 16- and 32-Bit Calls ....................................................................21-6
22-1. 8086 Address Translation ...................................................................................21-3
22-2. Entering and Leaving Virtual-8086 Mode.............................................................21-6
22-3. Privilege Level 0 Stack after Interrupt in Virtual-8086 Mode.................................21-7
23-1. Pentium® Processor EFLAGS Register ............................................................23-10
23-2. Control Register Extensions..............................................................................23-11
23-3. I/O Map Base Address Differences ...................................................................23-20
23-4. The two cases that arise depending on the timing of the receipt of the external
interrupt............................................................................................................23-40
25-1. Instruction Format ..............................................................................................25-3
25-2. ModR/M and SIB Byte Formats ..........................................................................25-5
25-3. Bit Offset for BIT[EAX,21] .................................................................................25-17
25-4. Memory Bit Indexing.........................................................................................25-18
26-1. Control and Event Select Register ......................................................................26-4
E CONTENTS
Tables
Table Title Page
3-1. Register Names..................................................................................................3-10
3-2. Status Flags .......................................................................................................3-14
3-3. Default Segment Selection Rules........................................................................3-20
3-4. Exceptions and Interrupts ...................................................................................3-24
4-1. Operands for Division .........................................................................................4-10
4-2. Bit Test and Modify Instructions ..........................................................................4-12
4-3. Conditional Jump Instructions .............................................................................4-26
4-4. Repeat Instructions.............................................................................................4-29
4-5. Flag Control Instructions .....................................................................................4-38
6-1. Numeric Processing Speed Comparisons ............................................................ 6-2
6-2. Numeric Data Types............................................................................................ 6-6
6-3. Principal Numeric Instructions.............................................................................. 6-7
6-4. Condition Code Interpretation .............................................................................6-12
6-5. Correspondence Between FPU and IU Flag Bits .................................................6-13
6-6. Summary of Format Parameters.........................................................................6-23
6-7. Real Number Notation ........................................................................................6-24
6-8. Rounding Modes ................................................................................................6-26
6-9. Data Transfer Instructions...................................................................................6-27
6-10. Nontranscendental Instructions (Besides Arithmetic) ...........................................6-28
6-11. Basic Arithmetic Instructions and Operands ........................................................6-29
6-12. Comparison Instructions .....................................................................................6-30
6-13. TEST Constants for Conditional Branching..........................................................6-31
6-14. Transcendental Instructions ................................................................................6-31
6-15. Constant Instructions ..........................................................................................6-33
6-16. Control Instructions.............................................................................................6-35
6-17. PL/M-386/486 Built-In Procedures ......................................................................6-38
6-18. ASM386/486 Storage Allocation Directives..........................................................6-39
6-19. Addressing Method Examples.............................................................................6-42
7-1. Arithmetic and Nonarithmetic Instructions ............................................................ 7-2
7-2. Binary Integer Encodings..................................................................................... 7-3
7-3. Packed Decimal Encodings.................................................................................. 7-4
7-4. Single and Double Real Encodings ...................................................................... 7-5
7-5. Extended Real Encodings.................................................................................... 7-6
7-6. Unsupported Formats.......................................................................................... 7-7
7-7. Denormalized Values........................................................................................... 7-8
7-8. Zero Operands and Results ................................................................................7-10
7-9. Infinity Operands and Results .............................................................................7-13
7-10. Rules for Generating QNaNs ..............................................................................7-17
7-11. Masked Responses to Invalid Operations ...........................................................7-22
7-12. Masked Overflow Results ...................................................................................7-25
7-13. Transcendental Core Ranges .............................................................................7-27
9-1. Exceptions and Interrupts .................................................................................... 9-4
11-1. Application Segment Types...............................................................................11-14
12-1. System Segment and Gate Types ......................................................................12-4
12-2. Interlevel Return Checks...................................................................................12-20
12-3. Valid Descriptor Types for LSL Instruction.........................................................12-22
12-4. Combined Page Directory and Page Protection.................................................12-27
13-1. Checks Made during a Task Switch ..................................................................13-11
13-2. Effect of a Task Switch on Busy, NT and Link Fields .........................................13-13
14-1. Exception and Interrupt Vectors..........................................................................14-2
CONTENTS E
Table Title Page
14-2. Priority Among Simultaneous Exceptions and Interrupts......................................14-6
14-3. Interrupt and Exception Classes .......................................................................14-17
14-4. Double Fault Conditions....................................................................................14-17
14-5. Invalid TSS Conditions......................................................................................14-19
14-6. Alignment Requirements by Data Type .............................................................14-27
14-7. Exception Summary..........................................................................................14-29
14-8. Error Code Summary........................................................................................14-30
15-1. I/O Serialization ..................................................................................................15-9
16-1. Processor State Following Reset ........................................................................16-4
16-2. FPU State Following FINIT or FNINIT .................................................................16-6
16-3. EM and MP Bits Interpretations ..........................................................................16-7
16-4. Recommended Values by Processor ..................................................................16-7
16-5. Action Taken for Different Combinations of EM, MP and TS................................16-8
16-6. Software Emulation Settings ...............................................................................16-9
16-7. The Algorithm and Related Listing Line Numbers ..............................................16-16
16-8. Relationship Between BLD Item and ASM Source File ......................................16-18
17-1. Breakpointing Examples .....................................................................................17-6
17-2. Debug Exception Conditions...............................................................................17-7
18-1. MESI Cache Line States.....................................................................................18-2
18-2. Cache Operating Modes.....................................................................................18-4
19-1. 14-Cycle EOI Message.....................................................................................19-27
19-2. 21-Cycle Short Message...................................................................................19-28
19-3. 34-Cycle Non-Focused Lowest Priority Message...............................................19-29
19-4. 39-Cycle Remote Read Message......................................................................19-31
19-5. APIC Bus Status Cycles Interpretation ..............................................................19-33
19-6. APIC Registers Address Map............................................................................19-36
19-7. Interrupt Command Register.............................................................................19-38
19-8. Local Vector Table............................................................................................19-39
20-1. SMRAM State Save Map....................................................................................20-5
20-3. SMM Initial CPU Core Register Settings .............................................................20-9
20-2. SMRAM State Save Map..................................................................................20-18
22-1. Software Interrupt Operation.............................................................................22-10
23-1. Processor State Following Power-Up ..................................................................23-5
23-2. FPU and NPX State Following Power-Up............................................................23-6
23-3. Recommended Values of the FP Related Bits for Intel486™ SX
Microprocessor/Intel487™ SX Math CoProcessor System ..................................23-7
23-4. EM and MP Bits Interpretations ..........................................................................23-8
23-5. Cache Mode Differences Between the Pentium® and Intel486™ Processors ....23-13
25-1. Effective Size Attributes ......................................................................................25-2
25-2. 16-Bit Addressing Forms with the ModR/M Byte..................................................25-6
25-3. 32-Bit Addressing Forms with the ModR/M Byte..................................................25-7
25-4. 32-Bit Addressing Forms with the SIB Byte .........................................................25-8
25-5. Task Switch Times for Exceptions.....................................................................25-13
25-6. Exceptions........................................................................................................25-19
26-1. Model Specific Registers Related to Performance Monitoring..............................26-2
26-2. Architectural Performance Monitoring Features...................................................26-3
26-3. Model Specific Performance Monitoring Features................................................26-3
26-4. Performance Monitoring Events ..........................................................................26-8
E CONTENTS
Examples
Examples Title Page
4-1. ENTER Definition................................................................................................4-32
4-2. ASCII Arithmetic Using BSWAP..........................................................................4-44
5-1. CPU Identification and FPU Detection.................................................................. 5-2
6-1. Modifying the Tag Word......................................................................................6-14
6-2. Sample C Program .............................................................................................6-37
6-3. Sample Numeric Constants ................................................................................6-39
6-4. Status Word Record Definition ............................................................................6-40
6-5. Structure Definition .............................................................................................6-41
6-6. Sample PL/M-386/486 Program..........................................................................6-42
6-7. Sample ASM386/486 Program............................................................................6-43
8-1. Conditional Branching for Compares.................................................................... 8-1
8-2. Conditional Branching for FXAM .......................................................................... 8-2
8-3. Full-State Exception Handler................................................................................ 8-5
8-4. Reduced-Latency Exception Handler ................................................................... 8-6
8-5. Reentrant Exception Handler ............................................................................... 8-6
8-6. Floating Point to ASCII Conversion Routine ......................................................... 8-8
8-7. Robot Arm Kinematics Example..........................................................................8-27
16-1. STARTUP.ASM................................................................................................16-18
16-2. MAIN.ASM .......................................................................................................16-26
16-3. Batch File to Assemble, Compile and Build the Application................................16-29
16-4. Build File ..........................................................................................................16-30