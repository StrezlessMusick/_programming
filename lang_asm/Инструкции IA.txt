      2.1  Инструкции архитектуры x86
      2.1.1  Инструкции перемещения данных
      2.1.2 Инструкции преобразования типов.
      2.1.3 Двоичные арифметические инструкции
      2.1.4  Десятичные арифметические инструкции
      2.1.5  Логические инструкции
      2.1.6 Инструкции передачи управления
      2.1.7  Инструкции ввода-вывода
      2.1.8  Строковые операции
      2.1.9  Инструкции управления флагами
      2.1.10  Условные операции
      2.1.11  Разные инструкции
      2.1.12  Системные инструкции
      2.1.13  Инструкции FPU
      2.1.14  Инструкции MMX
      2.1.15  Инструкции SSE


2.1  Инструкции архитектуры x86

В этом параграфе вы найдете всю информацию о синтаксисе и назначении инструкций ассемблера. Если вам нужно больше технической информации, смотрите Intel Architecture Software Developer's Manual. Инструкции ассемблера состоят из мнемоника (имени инструкции) и нескольких операндов (от нуля до трех). Если операндов два или три, то обычно первым идет адресат, а вторым источник. Операндом может быть регистр, память или непосредственное значение (подробнее о синтаксисе операндов смотрите в 1.2). После описания каждой инструкции ниже будут примеры разных комбинаций операндов, если, конечно, она содержит операнды.
    Некоторые инструкции работают как префиксы и могут быть перед другой инструкцией на той же строке. На одной строке может несколько префиксов. Каждое имя сегментного регистра это тоже мнемоник инструкции-префикса, хотя рекомендуется использовать замещение сегмента внутри квадратных скобок вместо этих префиксов.


2.1.1  Инструкции перемещения данных

"mov" переносит байт, слово или двойное слово из операнда-источника в операнд-адресат. Этот мнемоник может передавать данные между регистрами общего назначения, из этих регистров в память, обратно, но не может перемещать данные из памяти в память. Он также может передавать непосредственное значение в регистр общего назачения или в память, сегментный регистр в регистр общего назначения или в память, регистр общего назначения в сегментный регистр или в память, контрольный или отладочный регистр в регистр общего назначения и назад. "mov" может быть ассемблирована только если размер операнда-источника и размер операнда-адресата совпадают. Ниже приведены примеры каждой из перечисленных комбинаций:

    mov bx,ax       ; из регистра общего назначения в регистр общего назначения
    mov [char],al   ; из регистра общего назначения в память
    mov bl,[char]   ; из памяти в регистр общего назначения
    mov dl,32       ; непосредственное значение в регистр общего назначения
    mov [char],32   ; непосредственное значение в память
    mov ax,ds       ; из сегментного регистра в регистр общего назначения
    mov [bx],ds     ; из сегментного регистра в память
    mov ds,ax       ; из регистра общего назначения в сегментный регистр
    mov ds,[bx]     ; из памяти в сегментный регистр
    mov eax,cr0     ; из контрольного регистра в регистр общего назначения
    mov cr3,ebx     ; из регистра общего назначения в контрольный регистр

    "xchg" меняет местами значения двух операндов. Инструкция может поменять два байтовых операнда, операнды размером в слово и размером в двойное слово. Порядок операндов не важен. В их роли могут выступать два регистра общего назначения либо регистр общего назначения и адрес в памяти. Например:

    xchg ax,bx      ; меняет местами два регистра общего назначения
    xchg al,[char]  ; регистр общего назначения и память

"push" уменьшает значение указателя стекового фрейма (регистр ESP), потом переводит операнд на верх стека, на который указывает ESP. Операндом может быть память, регистр общего назначения, сегментный регистр или непосредственное значение размером в слово или двойное слово. Если операнд - это непосредственное значение и его размер не определен, то в 16-битном режиме по умолчанию он обрабатывается как слово, а в 32-битном режиме как двойное слово. Мнемоники "pushw" и "pushd" - это варианты этой инструкции, которые сохраняют соответственно слова и двойные слова. Если на одной строке содержится несколько операндов (разделенных пробелами, а не запятыми), компилятор проассемблирует цепь инструкций "push" с этими операндами. Вот примеры с одиночными операндами:

    push ax         ; сохраняет регистр общего назначения
    push es         ; сохраняет сегментный регистр
    pushw [bx]      ; сохраняет память
    push 1000h      ; сохраняет непосредственное значение

   Инструкция "pusha" сохраняет в стек содержимое восьми регистров общего назначения. У неё нет операндов. Существует две версии этой инструкции: 16-битная и 32-битная. Ассемблер автоматически генерирует версию, соответствующую текущему режиму, но, используя мнемоники "pushaw" или "pushad",это можно изменить для того, чтобы всегда получать, соответственно, 16- или 32-битную версию. 16-битная версия этой инструкции сохраняет регистры общего назначения в таком порядке: AX, CX, DX, BX, значение регистра SP перед тем, как был сохранен AX, далее BP, SI и DI. 32-битная версия сохраняет эквивалентные 32-битные регистры в том же порядке.
    "pop" переводит слово или двойное слово из текущей верхушки стека в операд-адресат и после уменьшает ESP на указатель на новую верхушку стека. Операндом может служить память, регистр общего назначения или сегментный регистр. Мнемоники "popw" и "popd" - это варианты этой инструкции, восстанавливающие соответственно слова и двойные слова. Если на одной строке содержится несколько операндов, разделенных пробелами, компилятор ассемблирует цепочку инструкций с этими операндами.

    pop bx          ; восстанавливает регистр общего назначения
    pop ds          ; восстанавливает сегментный регистр
    popw [si]       ; восстанавливает память

"popa" восстанавливает регистры, сохраненные в стек инструкцией "pusha", кроме сохраненного значения SP (или ESP)? который будет проигнорирован. У этой инструкции нет операндов. Чтобы ассемблировать 16 или 32-битную версию этой инструкции, используйте мнемоники "popaw" или "popad".


2.1.2 Инструкции преобразования типов.

Инструкции преобразования типов конвертируют байты в слова, слова в двойные слова и двойные слова в четверные слова. Эти преобразования можно совершить, используя знаковое или нулевое расширение. Знаковое расширение заполняют дополнительные биты большего операнда значением бита знака меньшего операнда, нулевое расширение просто забивает их нулями.
    "cwd" и "cdq" удваивают размер регистра AX или EAX соответственно и сохраняет дополнительные биты в регистр DX или EDX. Преобразование делается, используя знаковое расширение.  Эти инструкции не имеют операндов.
    "cbw" растягивает знак байта AL по регистру AX, а "cwde" растягивает знак слова AX на EAX. Эти инструкции также не имеют операндов.
    "movsx" преобразует байт в слово или в двойное слово и слово в двойное слово, используя знаковое расширение. "movzx" делает то же самое, но используя нулевое расширение. Операндом-источником может быть регистр общего назначения или память, тогда как операндом-адресатом должен быть регистр общего назначения. Например:

    movsx ax,al         ; байт в слово
    movsx edx,dl        ; байт в двойное слово
    movsx eax,ax        ; слово в двойное слово
    movsx ax,byte [bx]  ; байт памяти в слово
    movsx edx,byte [bx] ; байт памяти в двойное слово
    movsx eax,word [bx] ; слово памяти в двойное слово


2.1.3 Двоичные арифметические инструкции

"add" заменяет операнд-адресат суммой операнда-источника и адресата и ставит CF, если было переполнение. Операндами могут байты, слова или двойные слова. Адресатом может быть регистр общего назначения или память, источником регистр общего назначени или непосредственное значение. Также это может быть память, если адресат - это регистр.

    add ax,bx       ; прибавляет регистр к регистру
    add ax,[si]     ; прибавляет память к регистру
    add [di],al     ; прибавляет регистр к памяти
    add al,48       ; прибавляет непосредственное значение к регистру
    add [char],48   ; прибавляет непосредственное значение к памяти

    "adc" суммирует операнды, прибавляет единицу, если стоит CF и заменяет адресат результатом. Приавила для операндов такие же как с инстукцей "add". "add" со следующими за ней несколькими инструкциями "adc" может быть использована для сложения чисел длиннее, чем 32 бита.
    "inc" прибавляет к операнду единицу, он не может изменить CF. Операндом может быть регистр общего назначения или память, размером он может быть в байт, слово или двойное слово.

    inc ax          ; прибавляет единицу к регистру
    inc byte [bx]   ; увеличивает единицу к памяти

    "sub" вычитает операнд-источник от операнда адресата и заменяет адресат результатом. Если требуется отрицательный перенос, устанавливается CF. Правила для операндов такие же, как с инструкцией "add".
    "sbb" вычитает источник из адресата, отнимает единицу, если установлен CF и заменяет адресат результатом. Правила для операндов такие же, как с инструкцией "add". "sub" со следущими за ней несколькими инструкциями "sbb" может быть использована для вычитания чисел длиннее, чем 32 бита.
    "dec" вычитает из операнда единицу, не может изменить CF. Правила для операнда такие же, как с инструкцией "inc".
    "cmp" вычитает операнд-источник из оператора-адресата. Эта инструкция может устанавливать флаги, как и "sub", но не вносит изменения в операнды. Правила для операндов такие же, как с инструкцией "sub".
    "neg" отнимает от нуля целочисленный операнд с знаком. Эффект от этой инструкции - это смена знака операнда с положительного на отрицательный или с отрицательного на положительный. Правила для операндов такие же, как с инструкцией "inc".
    "xadd" меняет местами операнд-адресат и операнд-источник, потом загружает сумму двух значений в операнд-адресат. Правила для операндов такие же, как с инструкцией "add". Все вышеперечисленные инструкции изменяют флаги SF, ZF, PF и OF. SF всегда принимает значение, равное биту знака результата, ZF устанавливается, если результат равен нулю, PF устанавливается, если восемь битов нижнего разряда содержат четное число единиц, OF устанавливается, если результат слишком большой для положительного числа или слишком маленький для отрицательного (исключая бит знака) для того, чтобы уместиться в операнде-адресате.
    "mul" выполняет беззнаковое перемножение операнда и аккумулятора. Если операнд - байт, процессор умножает его на содержимое AL и возвращает 16-битный результат в AH и AL. Если операнд - слово, процессор умножает его на содержимое AX и возврщает 32-битный результат в DX и AX. Если же операнд - это двойное слово, процессор умножает его на содержимое EAX и возвращает 64-битный результат в EDX и EAX. "mul"устанавливает CF и OF, если верхняя половина результата ненулевая, иначе они очищаются. Правила для операндов такие же, как с инструкцией "inc".
    "imul" выполняет знаковое перемножение операндов. У этой инструкции есть три вариации. Первая имеет один операнд и работает так же, как инструкция "mul". Вторая имеет два операнда, и здесь операнд-адресат умножается на операнд-источник и результат заменяет операнд-адресат. Этоим операндом может быть регистр общего назначения, память или непосредственное значение. Третья форма инструкции имеет три операнда, операндом-адресатом должен быть регистр общего назначения, длиной в слово или в двойное слово, операндом-источником может быть регистр общего назначения или память, третьим операндом должно быть непосредственное значение. Источник умножается на непосредственное значение и результат помещается в регистр-адресат. Все три формы вычисляют результат размером в два раза больше размера операндов и ставят CF и OF, если верхняя часть результата ненулевая, но вторая и третья формы усекают результат до размера операндов. Так, их можно использовать для беззнаковых операндов, потому что нижняя половина результата одна и та же для знаковых и беззнаковых операндов. Ниже вы видите примеры всех трех форм:

    imul bl         ; умножение аккумулятора на регистр
    imul word [si]  ; умножение аккумулятора на память
    imul bx,cx      ; умножение регистра на регистр
    imul bx,[si]    ; умножение регистра на память
    imul bx,10      ; умножение регистра на непосредственное значение
    imul ax,bx,10   ; регистр, умноженный на непосредственное значение, в регистр
    imul ax,[si],10 ; память, умноженная на непосредственное значение, в регистр

    "div" производит беззнаковое деление аккумулятора на операнд. Делимое (аккумулятор) размером в два раза больше делителя (операнда), частное и остаток такого же размера , как и делитель. Если делитель - байт, делимое берется из регистра AX, частное сохраняется в AL, а остаток - в AH. Если делитель - слово, верхняя половина делимого берется из DX, а нижняя - из AX, частное сохраняется в AX, а остаток - в DX. Если делитель - двойное слово, верхняя половина делимого берется из EDX, а нижняя - из EAX, частное сохраняется в EAX, а остаток - в EDX. Правила для операндов такие же, как с инструкцией "mul".
    "idiv" выполняет знаковое деление аккумулятора на операнд. Инструкция использует те же регистры, что и "div", правила для для операнда тоже такие-же.


2.1.4  Десятичные арифметические инструкции

Десятичная арифметика представлена в виде соединения двоичных арифметических инструкций (описанных в предыдущем параграфе) с десятичными арифметическиими инструкциями. Десятичные арифметические инструкции используются для того, чтобы приспособить результаты предыдущей двоичной арифметической операции для создания допустимого сжатого или несжатого (?) десятичного результата, или приспособить входные данные для последующей двоичной арифметической операции так, чтобы эта операция также давала допустимый сжатый или несжатый десятичный результат.
    "daa" прилаживает результат сложения двух допустимых сжатых десятичных числа к AL. "daa" всегда должна следовать за суммированием двух пар сжатых десятичных цифр (один знак в каждой половине байта), чтобы получить как результат пару допустимых сжатых десятичных символов. Если потребуется перенос, будет установлен флаг переноса. У этой инструкции нет операндов.
    "das" прилаживает результат вычитания двух допустимых сжатых десятичных числа к AL. "das" всегда должна следовать за вычитанием одной пары сжатых десятичных цифр (один знак в каждой половине байта) из другой, чтобы получить как результат пару допустимых сжатых десятичных символов. Если потребуется отрицательный перенос, будет установлен флаг переноса. У этой инструкции нет операндов.
    "aaa" изменяет содержимое регистра AL на допустимое несжатое десятичное число и обнуляет верхние четыре бита. "aaa" всегда должна следовать за сложением двух несжатых десятичных операндов в AL. Если необходим перенос, устанавливется флаг переноса и увеличивается на единицу AH. У этой инструкции нет операндов.
    "aas" изменяет содержимое регистра AL на допустимое несжатое десятичное число и обнуляет верхние четыре бита. "aas" всегда должна следовать за вычитанием одного несжатого десятичного операнда из другого в AL. Если необходим перенос, устанавливется флаг переноса и уменьшается на единицу AH. У этой инструкции нет операндов.
    "aam" корректирует результат умножения двух допустимых несжатых десятичных чисел. Для создания правильного десятичного результата инструкция должна всегда следовать за умножением двух десятичных чисел. Цифра верхнего регистра передается в AH, а нижнего - в AL. Обобщенная версия этой инструкции делает возможной подгонку содержимого AX для создания двух несжатых цифр с любым основанием. Стандартная версия этой инструкции не имеет операндов, у обобщенной версии есть один операнд - непосредственное значение, определяющее основание создавакмых чисел.
    "aad" модифицирует делимое в AH и AL, чтобы подготовится к делению двух допустимых несжатых десятичных операндов так, чтобы частное стало доустимым несжатым десятичным числом. AH должен содержать цифру верхнего регистра, а AL - цифру нижнего регистра. Эта инструкция корректирует значение и помещает результат в AL, тогда как AH будет содержать ноль. Обобщенная версия этой инструкции делает возможной подгонку двух несжатых цифр с любым основанием. Правила для операнда такие же, как с инструкцией "aam".


2.1.5  Логические инструкции

"not" инвертирует биты в заданном операнде к форме обратного кода операнда. Не оказывает влияния на флаги. Правила для операнда таки же, как с инструкцией "inc".
    "and", "or" и "xor" производят стандартные логические операции. Они изменяют флаги SF, ZF и PF. Правила для операнда таки же, как с инструкцией "add".
    "bt", "bts", "btr" и "btc" оперируют с единичным битм, который может быть в памяти или регистре общего назначения. Расположения бита определяется как смещение от конца нижнего регистра операнда. Значение смещения берется из второго операнда, это может быть либо регистр общего назначения, либо байт. Эти инструкции первым делом присваивают флагу CF значение выбранного байта. "bt" больше ничего не делает, "bts" присваивает выбранному биту значение 1, "btr" сбрасывает его на 0, "btc" изменяет значение бита на его дополнение. Первый операнд может быть словом или двойным словом.

    bt  ax,15        ; тестирует бит в регистре
    bts word [bx],15 ; тестирует и ставит бит в памяти
    btr ax,cx        ; тестирует и сбрасывает бит в регистре
    btc word [bx],cx ; тестирует и дополняет бит в памяти

    Инструкции "bsf" и "bsr" ищут в слове или двойном слове первый установленный бит и сохраняют индекс этого бита в операнд-адресат, которым должен быть регистр общего назначения. Сканируемая строка битов определяется операндом-источником, им может быть либо регистр общего назначения, либо память. Если срока нулевая (ни одного единичного бита), то установливается флаг ZF; иначе он очищается. Если не найдено ни одного установленного бита, значение операнда адресата не определено. "bsf" сканирует от нижнего регистра к верхнему (начиная с бита с индексом ноль). "bsr" сканирует от верхнего регистра к нижнему (начиная с бита с индексом 15 в слове или с индекса 31 в двойном слове).


    bsf ax,bx        ; сканирование регистра по возрастанию
    bsr ax,[si]      ; скнирование пмяти в обратном порядке

    "shl" сдвигает операнд-адресат влево на определенное вторым операндом количество битов. Операндом-адресатом может быть регистр общего назначения или память размером в байт, слово или двойное слово. Вторым операндом может быть непосредственное значение или регистр CL. Процессор "задвигает" нули справа (с нижнего регистра), и биты "выходят" слева. Последний "вышедший" бит запоминается в CF. "sal" - это синоним "shl".

    shl al,1         ; сдвиг регистра влево на один бит
    shl byte [bx],1  ; сдвиг памяти влево на один бит
    shl ax,cl        ; сдвиг регистра влево на количество из CL
    shl word [bx],cl ; сдвиг памяти влево на количество из CL

    "shr" и "sar" сдвигают операнд-адресат вправо на число битов, определенное во втором операнде. Правила для операндо такие же, как с инструкцией "shl". "shr" "задвигает" нули с левой стороны операнда-адресата, биты "выходят" справа. Последний "вышедщий" бит запоминается в CF. "sar" сохраняет знак операнда, "забивая" слева нулями, если значение положительное, и единицами, если значение отрицательное.
    "shld" сдвигает биты операнда-адресата влево за заданное в третьем операнде число битов, в то время как справа "задвигаются" биты верхних регистров операнда-источника. Операнд-источник не изменяется. Операндом-адресатом может быть регистр общего назначения или память размером в слово или двойное слово, операндом-источником должен быть регистр общего назначения, третьим операндом может быть непосредственное значение либо CL.

    shld ax,bx,1     ; сдвиг регистра влево на один бит
    shld [di],bx,1   ; сдвиг памяти влево на один бит
    shld ax,bx,cl    ; сдвиг регистра влево на количество из CL
    shld [di],bx,cl  ; сдвиг памяти влево на количество из CL

    "shrd" cдвигает биты операнда-адресата вправо, в то время как слева "задвигаются" биты нижних регистров операнда-источника. Операнд-источник остается неизменным. Правила для операндов такие же, как с инструкцией "shld".
    "rol" и "rcl" циклически сдвигают байт, слово или двойное слово влево на число битов, заданное во втором операнде. Для каждой заданной ротации старший бит, выходящий слева, появляется справа и становится самым младшим битом. "rcl" дополнительно помещает в CF каждый бит высшего регистра, выходящий слева, перед тем, как он возвратится в операнд как младший бит во время следующего цикла ротации. Правила для операндов такие же, как с инструкцией "shl".
    "ror" и "rcr" циклически сдвигают байт, слово или двойное слово вправо на число битов, заданное во втором операнде. Для каждой заданной ротации младший бит, выходящий справа, появляется слева и становится самым старшим битом. "rcr" дополнительно помещает в CF каждый бит низшего регистра, выходящий слева, перед тем, как он возвратится в операнд как старший бит во время следующего цикла ротации. Правила для операндов такие же, как с инструкцией "shl".
    "test" производит такое же действие, как инструкция "and", но не изменяет операнд-адресат, только обновляет флаги. Правила для операндов такие же, как с инструкцией "and".
    "bswap" переворачивает порядок битов в 32-битном регистре общего назначения: биты от 0 до 7 меняются местами с битами от 24 до 31, а биты от 8 до 15 меняются с битами от 16 до 23. Эта инструкция предусмотрена для преобразования значений с прямым порядком байтов к формату с обратномым порядком и наоборот.

    bswap edx        ; перестановка байтов в регистре

2.1.6 Инструкции передачи управления


"jmp" безоговорочно передает управление а заданное место. Адрес назначения может быть определен непосредственно в инструкции или косвенно через регистр или память, допустимый размер адреса зависит от того, какой переход, близкий или дальний, а также от того, какая инструкция, 16-битная или 32-битная. Операнд для близкого перехода должен быть размером "word" для 16-битной инструкции и размером "dword" для 32-битной инструкции. Операнд для дальнего перехода должен быть размером "dword" для 16-битной инструкции и размером "pword" для 32-битной инструкции. Прямая инструкция "jmp" содержит адрес назначения как часть инструкции, операндом, определяющим этот адрес, должно быть числовое выражение для близкого перехода и два числа, разделенные двоеточием, для дальнего перехода, первое определяет номер сегмента, второе - смещение внутри сегмента. Непрямая инструция "jmp" получает адрес назначения через регистр или переменную-указатель, операндом должен быть регистр общего назначения или память. Для более подробной информации смотрите также 1.2.5.

    jmp 100h         ; прямой близкий переход
    jmp 0FFFFh:0     ; прямой дальний переход
    jmp ax           ; непрямой близкий переход
    jmp pword [ebx]  ; непрямой дальний переход

    "call" передает управление процедуре, сохраняя в стеке адрес инструкции, следующей за "call", для дальнейшего возвращения к ней инструкцией "ret". Правила для операндов такие же, что с инструкцией "jmp", но "call" не имеет короткого варианта в виде прямой инструкции, и поэтому не оптимизирована.
    "ret", "retn" и "retf" прекращают выполнение процедуры передают управление назад программе, которая изначально вызвала эту процедуру, используя адрес, который был сохранен в стеке инструкцией "call". "ret" это эквивалент "retn", которая возвращает из процедуры, которая была вызвана с использованием близкого перехода, тогда как "retf" возвращает из процедуры, которая была вызвана с использованием дальнего перехода. Эти инструкции подразумевают размер адреса, соответствующий текущей установке кода, но этот размер может быть изменен на 16-битный с помощью мнемоников "retw", "retnw" и "retfw" и на 32-битный с помощью "retd", "retnd" и "retfd". Все эти инструкции могут опционально предписывать непосредственный операнд, если добавить константу к указателю стека, они эффективно удаляют любые аргументы, которые вызвающая программа положила в стек перед выполнением инструкции "call".
    "iret" возвращает управление прерванной процедуре. Эта инструкция отличается от "ret" в том, что она также выводит из стека флаги в регистр флагов. Флаги сохраняются в стек механизмом прерывания. Инструкция подразумевает размер адреса, соответствующий текущей установке кода, но этот размер может быть изменен на 16-битный или на 32-битный с помощью мнемоников "iretw" или "iretd".
    Условные инструкции перехода осуществляют или не осуществляют передачу управления в зависимости от состояния флагов CPU во время вызова этих инструкций. Мнемоники условных переходов могут быть получены добавлением условных мнемоников (смотри таблицу 2.1) к символу "j", например инструкция "jc" осуществляет передачу управления, если установлен флаг CF. Условные переходы могут быть только близкие и прямые и могут быть оптимизированы (смотри 1.2.5), операндом должно быть число, определяющее адрес назначения.

   Таблица 2.1  Условия
  -----------T-----------------------T------------------------¬
  ¦ Мнемоник ¦ Тестируемое условие   ¦ Описание               ¦
  ¦==========+=======================+========================¦
  ¦ o        ¦ OF = 1                ¦ переполнение           ¦
  +----------+-----------------------+------------------------+
  ¦ no       ¦ OF = 0                ¦ нет переполнения       ¦
  +----------+-----------------------+------------------------+
  ¦ c        ¦                       ¦ перенос                ¦
  ¦ b        ¦ CF = 1                ¦ меньше                 ¦
  ¦ nae      ¦                       ¦ не больше и не равно   ¦
  +----------+-----------------------+------------------------+
  ¦ nc       ¦                       ¦ нет переноса           ¦
  ¦ ae       ¦ CF = 0                ¦ выше или равно         ¦
  ¦ nb       ¦                       ¦ не ниже                ¦
  +----------+-----------------------+------------------------+
  ¦ e        ¦ ZF = 1                ¦ равно                  ¦
  ¦ z        ¦                       ¦ ноль                   ¦
  +----------+-----------------------+------------------------+
  ¦ ne       ¦ ZF = 0                ¦ не равно               ¦
  ¦ nz       ¦                       ¦ не ноль                ¦
  +----------+-----------------------+------------------------+
  ¦ be       ¦ CF or ZF = 1          ¦ ниже или равно         ¦
  ¦ na       ¦                       ¦ не выше                ¦
  +----------+-----------------------+------------------------+
  ¦ a        ¦ CF or ZF = 0          ¦ выше                   ¦
  ¦ nbe      ¦                       ¦ не ниже и не равно     ¦
  +----------+-----------------------+------------------------+
  ¦ s        ¦ SF = 1                ¦ знаковое               ¦
  +----------+-----------------------+------------------------+
  ¦ ns       ¦ SF = 0                ¦ беззнаковое            ¦
  +----------+-----------------------+------------------------+
  ¦ p        ¦ PF = 1                ¦ четное                 ¦
  ¦ pe       ¦                       ¦                        ¦
  +----------+-----------------------+------------------------+
  ¦ np       ¦ PF = 0                ¦ нечетное               ¦
  ¦ po       ¦                       ¦                        ¦
  +----------+-----------------------+------------------------+
  ¦ l        ¦ SF xor OF = 1         ¦ меньше                 ¦
  ¦ nge      ¦                       ¦ не больше и не равно   ¦
  +----------+-----------------------+------------------------+
  ¦ ge       ¦ SF xor OF = 0         ¦ больше или равно       ¦
  ¦ nl       ¦                       ¦ не меньше              ¦
  +----------+-----------------------+------------------------+
  ¦ le       ¦ (SF xor OF) or ZF = 1 ¦ меньше или равно       ¦
  ¦ ng       ¦                       ¦ не больше              ¦
  +----------+-----------------------+------------------------+
  ¦ g        ¦ (SF xor OF) or ZF = 0 ¦ больше                 ¦
  ¦ nle      ¦                       ¦ не меньше и не равно   ¦
  L----------+-----------------------+-------------------------

    "loop" - это условные переходы, которые используют значение из CX (или ECX) для определения количества повторений цикла. Все инструкции "loop" автоматически уменьшают на единицу CX (или ECX) и завершают цикл, когда CX (или ECX) равно нулю. CX или ECX  используется в зависимости от от текущей утановки битности кода - 16-ти или 32-битной, но вы можете принудительно использовать CX с помощью мнемоника "loopw", или ECX с помощью мнемоника "loopd".
    "loope" и "loopz" это синонимы этой инструкции, которые работают так же, как стандартный "loop", но еще завершают работу, если установлен ZF. "loopew" и "loopzw" заставляют использовать регистр CX, а "looped" и "loopzd" заставляют использовать регистр ECX.
    "loopne" и "loopnz" это тоже синонимы той же инструкции, которые работают так же, как стандартный "loop", но еще завершают работу, если ZF сброшен на ноль. "loopnew" и "loopnzw" заставляют использовать регистр CX, а "loopned" и "loopnzd" заставляют использовать регистр ECX.
    Каждая инструкция "loop" требует операндом число, определяющее адрес назначения, причем это может быть только близкий переход (в пределах 128 байт назад и 127 байт вперед от адреса инструкции, следующей за "loop").
    "jcxz" переходит к метке, указанной в инструкции, если находит в CX ноль, "jecxz" делает то же, но проверяет регистр ECX. Правила для операндов такие же, как с инструкцией "loop".
    "int" активирует стандартный сервис прерывания, который соответствует числу, указанному как операнд в мнемонике. Это число должно находиться в пределах от 1 до 255. Стандартный сервис прерывания заканчивается мнемоником "iret", которая возвращает управление инструкции, следующей за "int". "int3" кодирует короткое (в один байт) системное прерывание, которое вызывает прерывание 3. "into" вызывает прерывание 4, если установлен флаг OF.
    "bound" проверяет, находится ли знаковое число, содержащееся в указанном регистре в нужных пределах. Если число в регистре меньше нижней гранцы или больше верхней, вызывается прерывание 5. Инструкция нуждается в двух операндах, первый - это тестируемый регистр, вторым должен быть адрес в памяти для двух знаковых чисел, указывающих границы. Операнды могут быть размером "word" или "dword".

    bound ax,[bx]    ; тестирует слово на границы
    bound eax,[esi]  ; тестирует двойное слово на границы


2.1.7  Инструкции ввода-вывода

"in" переводит байт, слово или двойное слово из порта ввода в AL, AX или EAX. Порты ввода-вывода могут быть адресованы либо напрямую, непосредственно с помощью байтового значения, либо непрямо через регистр DX. Операндом-адресатом должен быть регистр AL, AX или EAX. Операндом-источником должно быть число от 0 до 255 либо регистр DX.

    in al,20h        ; ввод байта из порта 20
    in ax,dx         ; ввод слова из порта, адресованного регистром DX

    "out" переводит байт, слово или двойное слово из порта вывода в AL, AX или EAX. Программа может может определить номер порта, используя те же методы, что и в инструкции "in".  Операндом-адресатом должен быть регистр AL, AX или EAX. Операндом-источником должно быть число от 0 до 255 либо регистр DX.

    out 20h,ax       ; вывод байта в порт 20
    out dx,al        ; вывод слова в порт, адресованный регистром DX


2.1.8  Строковые операции

Строковые операции работают с одним элементом строки. Этим элементом может быть байт, слово или двойное слово. Строковые элементы адресуются регистрами SI и DI (или ESI и EDI). После каждой сроковой операции SI и/или DI (или ESI и/или EDI) автоматически обновляются до указателя на следующий элемент строки. Если DF (флаг направления) равен нулю, регистры индекса увеличиваются, если DF равен единице, они уменьшаются. Число, на которое они увеличиваются или уменьшаются равно 1, 2 или 4 в зависимости от размера элемента строки. Каждая инструкция строковой операции имеет короткую форму без операндов, использующую SI и/или DI если тип кода 16-битный, и ESI и/или EDI если тип кода 32-битный. SI и ESI по умолчанию адрес данных в сегменте, адресованном регистром DS, DI и EDI всегда адресует данные в сегменте, выбранном в ES. Короткая форма образуется добавлением к мнемонику строковой операции буквы, определяющей размер элемента строки, для байта это "b", для слова это "w", для двойного слова это "d". Полная форма инструкции требует операнды, указывающие размер оператора, и адресы памяти, которыми могут быть SI или ESI с любым сегментным префиксом, или DI или EDI всегда с сегментным префиксом ES.
    "movs" переводит строковый элемент, на который указывает SI (или ESI) в место, на которое указывает DI (или EDI). Размер операнда может быть байтом, словом или двойным словом. Операндом-адресатом должна быть память, адресованная DI или EDI, операндом-источником должна быть память, адресованная SI или ESI с любым сегментным префиксом.

    movs byte [di],[si]        ; переводит байт
    movs word [es:di],[ss:si]  ; переводит слово
    movsd                      ; переводит двойное слово

    "cmps" вычитает строковый элемент-адресат из строкового элемента-источника и обновляет флаги AF, SF, PF, CF и OF, но не изменяет никакой из сравниваемых элементов. Если стрововые элементы эквивалентны, устанавливается ZF, иначе он очищается. Первым операндом этой инструкции должен быть строковый элемент, адресованный SI или ESI с любым сегментным префиксом, вторым операндом должен быть строковый элемент, адресованный DI или EDI.

    cmpsb                      ; сравнение байтов
    cmps word [ds:si],[es:di]  ; сравнение слов
    cmps dword [fs:esi],[edi]  ; сравнение двойных слов

    "scas" вычитает строковый элемент-адресат из AL, AX или EAX (в зависимости от размера этого элемента) и обновляет флаги AF, SF, ZF, PF, CF и OF. Если значения эквивалентны, устанавливается ZF, иначе он очищается. Операндом должен быть строковый элемент, адресованный DI или EDI.

    scas byte [es:di]          ; сканирует байт
    scasw                      ; сканирует слово
    scas dword [es:edi]        ; сканирует двойное слово

    "stos" помещает значение AL, AX или EAX в строковый элемент-адресат. Правила для операндов такие же, как с инструкцией "scas".
    "lods" строковый элемент в AL, AX или EAX. Операндом должен быть строковый элемент, адресованный SI или ESI с любым префиксом сегмента.

    lods byte [ds:si]          ; загружает байт
    lods word [cs:si]          ; загружает слово
    lodsd                      ; загружает двойное слово

    "ins" переводит байт, слово или двойное слово порта ввода, адресованного регистром DX в строковый элемент-приемник. Операндом-адресатом должна быть память, адресованная DI или EDI, операндом-источником должен быть регистр DX.

    insb                       ; ввод байта
    ins word [es:di],dx        ; ввод слова
    ins dword [edi],dx         ; ввод двойного слова

    "outs" переводит строковый элемент-источник в порт вывода, адресованный регистром DX. Операндом-адресатом должн быть регистр DX, а операндом-источником должна быть память, адресованная SI или ESI с любым префиксом сегмента.

    outs dx,byte [si]          ; вывод байта
    outsw                      ; вывод слова
    outs dx,dword [gs:esi]     ; вывод двойного слова

    Префиксы повторения "rep", "repe"/"repz" и "repne"/"repnz" определяют повторяющуюся строковую операцию. Если инструкция строковой операции имеет префикс повторения, операция выполняется повторно, каждый раз используя другой элемент строки. Повторение прекратится, когда будет выполнено одно из условий, указанных префиксом. Все три префикса автоматически уменьшают регистр CX или ECX (в зависимости от того, какую адресацию использует инструкция строковой операции, 16-битную или 32-битную) после каждой операции и повторяют ассоциированную операцию, пока CX или ECX не станет равным нулю. "repe"/"repz" и "repne"/"repnz" используются только с инструкциями "scas" и "cmps" (описанными выше). Когда используются эти префиксы, повторение следующей инструкции зависит также от флага нуля (ZF), "repe" и "repz" прекращают выполнение, если ZF равен нулю, "repne" и "repnz" прекращают выполнение, если ZF равен единице.

    rep  movsd       ; переводит несколько двойных слов
    repe cmpsb       ; сравнивает байты, пока эквивалентны


2.1.9  Инструкции управления флагами

Инструкции управления флагами обеспечивают метод прямого изменения состояния битов во флаговом регистре. Все инструкции, описанные в этом разделе, не имеют операндов.
    "stc" устанавливает CF (флаг переноса) в 1, "clc" обнуляет CF, "cmc" изменяет  CF на его дополнение.
    "std" устанавливает DF (флаг направления) в 1, "cld" обнуляет DF.
    "sti" устанавливает IF (флаг разрешения прерываний) в 1 и таким образом разрешает прерывания, "cli" обнуляет IF и таким образом запрещает прерывания.
    "lahf" копирует SF, ZF, AF, PF и CF в биты 7, 6, 4, 2 и 0 регистра AH. Содержание остальных битов неопределено. Флаги остаются неизменными.
    "sahf" переводит биты 7, 6, 4, 2 и 0 из регистра AH в SF, ZF, AF, PF и CF.
    "pushf" уменьшает ESP на два или на четыре и сохраняет нижнее слово или двойного слово флагового регистра в вершине стека. Размер сохраненной информации зависит от текущей настройки кода. Вариант "pushfw" сохранят слово, независимо от настройки кода, "pushfd" также независимо от настройки кода сохраняет двойное слово.
    "popf" переводит определенные биты из слова или двойного слова в вершине стека и увеличивает ESP на два или на четывре, в зависимости от текущей настройки кода. Вариант "popfw" сохранят слово, независимо от настройки кода, "popfd" также независимо от настройки кода сохраняет двойное слово.


2.1.10  Условные операции

Инструкции, образванные с помощью добавления условного мнемоника (смотрите таблицу 2.1) к мнемонику "set" присваивают байту единицу, если условие истинно, и ноль, если если условие не выполняется. Операндом должен быть 8-битный регистр общего назначения либо байт в памяти.

    setne al         ; единицу в al, если флаг нуля пустой
    seto byte [bx]   ; единицу в байт, если есть переполнение

    "calc" присваивает всем битам регистра AL единицу, если стоит флаг переноса, и нули в другом случае. У этой инстркции нет аргументов.
    Иннструкции, образованные добавлением условного мнемоника к "cmov" переводят слово или двойное слово из регистра общего назначения или памяти в регистр общего назначения только если условие верно. Операндом-адресатом должен быть регистр общего назначения, операндом-источником - регистр общего назначения либо память.

    cmove ax,bx      ; переводит, если установлен флаг нуля
    cmovnc eax,[ebx] ; переводит, если очищен флаг переноса

    "cmpxchg" сравнивает значение в регистре AL, AX или EAX с операндом-адресатом. Если значения равны, операнд-источник загружается в операнд-адресат, иначе операнд-адресат загружается в регистр AL, AX или EAX. Операндом-адресатом должен быть регистр общего назначения или память, операндом-источником - регистр общего назначения.

    cmpxchg dl,bl    ; сравнивает и меняет с регистром
    cmpxchg [bx],dx  ; сравнивает и меняет с памятью

    "cmpxchg8b" сравнивает с операндом 64-битное значение в регистрах EDX и EAX. Если значения раны, 64-битное значение в регистрах EDX и EAX сохраняется в операнде, иначе значение из операнда загружается в эти регистры. Операндом должно быть четверное слово в памяти.

    cmpxchg8b [bx]   ; сравнивает и меняет 8 битов


2.1.11  Разные инструкции

"nop" занимает один бит, но ничего не значит, кроме как указатель инструкции. У неё нет операндов и она ничего не совершает.
    "ud2" генерирует недопустимый опкод. Эта инструкция создана для тестирования прграммного обеспечения, чтобы недвусмысленно генерировать недопустимый опкод. У инструкции нет операндов.
    "xlat" заменяет байт в регистре AL байтом, индексированным его значением в таблице перевода, адресованной BX или EBX. Операндом должен быть байт памяти, адресованный регистром BX или EBX с любым сегментным префиксом. Эта инструкция также имеет короткую форму "xlatb", которая не использует операнды и использует адрес из BX или EBX (в зависимости от настройки кода) в сегменте, адресованном DS.
    "lds" переводит переменный указатель из операнда-источника в DS и регистр-адресат. Операндом-источником должна быть память, а операндом-адресатом - регистр общего назначения. Регистр DS получает селектор сегмента указателя, а регистр-адресат получает его смещение. "les", "lfs" "lgs" и "lss" работают точно так же, как "lds", только вместо регистра DS используются соответственно ES, FS, GS или SS.

    lds bx,[si]      ; загружает указатель в ds:bx

    "lea" переводит смещение операнда-источника (вместо его значения) в операнд-адресат. Операндом-источником должна быть память, а операндом-адресатом должен быть регистр общего назначения.

    lea dx,[bx+si+1] ; загружает исполнительный адрес в dx

    "cpuid" возвращает идентификацию процессора и информацию о его свойствах в регистры EAX, EBX, ECX и EDX. Выдаваемая информация выбирается вводом нужного значения в регистр EAX перед тем, как выполнить иструкцию. У этой инструкции нет операндов.
    "pause" задерживает выполнение следующей инструкции, реализуясь оперделенное количество времени. Эта инструкция может быть использована, чтобы улучшить выполнение циклов ожидания. У инструкции нет операндов.
    "enter" создает стековый фрейм, который может быть использован для реализации свода правил блочных языков высокого уровня. Инструкция "leave" в конце процедуры дополняет "enter" в начале процедуры, чтобы упростить управление стеком и контролировать доступ к переменным для вложенных процедур. Инструкция "enter" имеет два параметра. Первый параметр определяет количество байт динамической памяти, которое должно быть отведено для введенной подпрограммы. Второй параметр соответствует лексическому уровню вложенности подпрограммы, может находится в области от 0 до 31. Указанный лексический уровень устанавливает, сколько наборов указателей стековых фреймов CPU копирует в новый стековый фрейм из предыдущего фрейма. Этот список указателей стековых фреймов иногда называется дисплеем. Первое слово (или двойное слово, если код 32-битный) дисплея - это указатель на последний стековый фрейм. Этот указатель делает возможным для инструкции "leave" совершить в обратном порядке действия предыдущей инструкции "enter", эффективно сбрасывая последний стековый фрейм. После того, как "enter" создает новый дисплей для процедуры, инструкция выделяет для неё место в динамической памяти, уменьшая ESP на количество байтов, определенных в первом параметре. Чтобы процедура могла адресовать свой дисплей, "enter" передает указатель BP (или EBP) в начало нового стекового фрейма. Если лексический уровень равен нулю, "enter" сохраняет BP (или EBP), копирует SP в BP (или ESP в EBP) и далее вычитает первый операнд из SP (или ESP). Для уровней вложенности больших нуля процессор сохраняет дополнительные указатели фреймов в стек перед подгонкой указателя стека.

    enter 2048,0     ; ввод и выделение 2048 байтов в стеке


2.1.12  Системные инструкции

"lmsw" загружает операнд в слово машинного статуса (биты от 0 до 15 регистра CR0), тогда как "smsw" сохраняет слово машинного статуса в операнд-адресат. Операндом может быть 16-битный или 32-битный регистр общего назначения или слово в памяти.

    lmsw ax          ; загружает машинный статус из регистра
    smsw [bx]        ; сохраняет машинный статус в память

    "lgdt" и "lidt" загружают значения из операнда в регистр таблицы глобальных дескрипторов или в регистр таблицы дескриптров прерываний соответственно. "sgdt" и "sidt" сохраняют содержимое регистра таблицы глобальных дескрипторов или регситра таблицы дескриптров прерываний в операнд-адресат. Операндом должны быть 6 байтов в памяти.

    lgdt [ebx]       ; загружает таблицу глобальных дескрипторов

    "lldt" загружает операнд в поле селектора сегмента регистра таблицы локальных дескрипторов, а "sldt" сохраняет селектор сегмента из регистра таблицы локальных дескрипторов в операнд. "ltr" загружает операнд в поле селектора сегмента регистра задачи, а "str" сохраняет селектор сегмента из регистра задачи в операнд. Правила для операндов такие же, как в инструкциях "lmsw" и "smsw".
    "lar" загружает права доступа из сегментного дескриптора, указанного селектором в операнде-источнике, в операнд-адресат и ставит флаг ZF. Операндом-адресатом может быть 16-битный или 32-битный регистр общего назначения. Операндом-источником должен быть 16-битный регистр общего назначения или память.

    lar ax,[bx]      ; загружает права доступа в слово
    lar eax,dx       ; загружает права доступа в двойное слово

    "lsl" загружает сегментный предел из сегментного дескриптора, указанного селектором в операнде-источнике, в операнд-адресат и ставит флаг ZF. Правила для операндов такие же, как в инструкции "lsl".
    "verr" и "verw" проверяют, поддаётся ли чтению или записи на данном уровне привилегий сегмент кода или данных, заданный в операнде. Операндом должно быть слово, это может быть регистр общего назначения или память. Если сегмент доступен и читаем (для "verr") или изменяем, устанавливается флаг ZF, иначе он очищается. Правила для операндов такие же, как в инструкции "lldt".
    "arpl" сравнивает поля RPL (уровень привилегий запрашивающего) двух селекторов сегментов. Первый операнд содержит один селектор сегмента, второй содержит другой. Если поле RPL операнда-адресата меньше, чем поле RPL операнда-источника, то устанавливается флаг ZF, и поле RPL операнда-адресата увеличивается до соответствия операнду-источнику. Иначе флаг ZF очищается и в операнде никаких изменений не производится. Операндом-адресатом должен быть регистр общего назначения или память длиной в слово, операндом-источником должен быть регистр общего назначения тоже длиной в слово.

    arpl bx,ax       ; подгоняет RPL селектора в регистре
    arpl [bx],ax     ; подгоняет RPL селектора в памяти

    "clts" очищает флаг TS (переключение задач) в регистре CR0. У этой инструкции нет операндов.
    Префикс "lock" заставляет процессор объявить сигнал "bus-lock" (или LOCK#) во время выполнения сопутсвующей инструкции. В многопроцессорной среде сигнал "bus-lock" гарантирует, что пока он объявлен, процессор эксклюзивно использует любую общую память. Префикс "lock" может быть присоединен только к следующим инструкциям и причем только к тем их формам, в которых операндом-адресатом является память: "add", "adc", "and", "btc", "btr", "bts", "cmpxchg", "cmpxchg8b", "dec", "inc", "neg", "not", "or", "sbb", "sub", "xor", "xadd" и "xchg". Если этот префикс используется с одной из этих инструкций, но операндом-источником является память, может быть сгенерирован не определенный ошибочный опкод. Он может быть сгенерирован также, если префикс "lock" используется с инструкцией, не перечисленной выше. Инструкция "xchg" всегда объявляет сигнал "bus-lock", независимо от отсутствия или присутствия преикса "lock".
    "hlt" прекращает выполнение инструкции и переводит прощессор в состояние остановки. Запущенное прерывание, отладочное исключение, BINIT, INIT или RESET продолжат выполнение. У этой инструкции нет операндов.
    "rdmsr" загружает содержимое 64-битного MSR (модельно-специфический регистр) по адресу, определенному в ECX, в EDX и EAX. "wrmsr" загружает содержимое регистров EDX и EAX в 64-битный MSR по адресу, определенному в ECX. "rdtsc" загружает текущее значение счетчика времени процессора из 64-битного MSR в регистры EDX и EAX. Процессор увеличивает значение счетчика времени MSR каждый цикл тактового генератора и сбрасывается на 0, когда процессор перезагружается. "rdpmc" загружает содержимое 40-битного счетчика событий производительности, заданного в ECX, в EDX и EAX. Эти инструкции не имеют операндов.
    "wbinvd" совершает обратную запись модифицированных строк внутреннего кэша процессора в основную память и аннулирует (очищает) внутренние кэши. Далее инструкция запускает специальный цикл шины, который предназначает внешним кэшам также совершить обратную запись модифицированных данных и другой цикл шины, который указывает, что внешние кэши должны аннулироваться. Эта инструкция не имеет операндов.
    "rsm" возвращает программное управление из из системного режима управления программе, которая была прервана, когда процессор получил прерывание SMM. Эта инструкция не имеет операндов.
    "sysenter" выполняет быстрый вызов системный вызов процедуры уровня 0, "sysexit" выполняет быстрый возврат к коду пользователя уровня 3. Адреса, использованные этими инструкциями, сохраняются в MSR-ах. Эти инструкции не имеют операндов.


2.1.13  Инструкции FPU

    Инструкции FPU (модуль операций с плавающей точкой) оперируют со значениями с плавающей точкой в трех форматах: одинарная точность (32-битная), двойная точность (64-битная) и расширенная точность (80-битная). Регистры FPU формируют стек и каждый из них вмещает значение с плавающей точкой расширенной точности. Если некоторые значения задвигаются в стек или вытаскиваются из вершины, регистры FPU сдвигаются, таким образом ST0 - это всегда значение в вершине стека FPU, ST1 - это первое значение ниже вершины и т. д.. Название ST0 имеет также синоним ST.
    "fld" задвигает значение с плавающей точкой стек регистров FPU. Операндом может быть 32-битное, 64-битное или 80-битное расположение в памяти или регистр FPU, его значение загружается в вершину стека регистров FPU (регистр ST0) и автоматически конвертируется в формат расширенной точности.

    fld dword [bx]   ; загружает значение одинарной точности из памяти
    fld st2          ; загружает значение st2 в вершину стека

    "fld1", "fldz", "fldl2t", "fldl2e", "fldpi", "fldlg2" и "fldln2" загружают часто ипользуемые константы в стек регистров FPU. Эти константы +1.0, +0.0, lb 10, lb e, pi, lg 2 и ln 2 соответственно.  Эти инструкции не имеют операндов.
    "fild" конвертирует знаковый целочисленный операнд-источник в расширенный формат с плавающей точкой и задвигает результат в стэк регистров FPU. Операндом-источником может быть 16-битное, 32-битное или 64-битное расположение в памяти.

    fild qword [bx]  ; загружает 64-битное целое число из памяти

"fst" копирует значение из регистра ST0 в операнд-адресат, которым может быть 32-битное или 64-битное расположение в памяти или другой регистр FPU. "fstp" совершает ту же операцию, но далее выдвигает стек регистров, освобождая ST0. "fstp" поддерживает те же операнды, что и "fst" и ещё может сохранять 80-битное значение в память.

    fst st3          ; копирует значение ST0 в регистр ST3
    fstp tword [bx]  ; сохраняет значение в память и выдвигает стэк

    "fist" конвертирует значение из ST0 в знаковое целое число и сохраняет результат в операнд-адресат. Операндом может быть 32-битное или 64-битное расположение в памяти. "fistp" совершает ту же операцию, но далее выдвигает стек регистров. Инструкция поддерживает те же операнды, что и "fist" и ещё может сохранять 64-битное целочисленное значение в память, таким образом, у неё правила для операндов такие же, как с инструкцией "fild".
    "fbld" конвертирует сжатое целое число BCD в  в расширенный формат с плавающей точкой и задвигает это значение в стек FPU. "fbstp" конвертирует значение из ST0 в 18-знаковое сжатое число BCD, сохраняет результат в операнд-адресат и выдвигает стэк регистров. Операндом должно быть 80-битное расположение в памяти.
    "fadd" складывает операнд-источник и операнд-адресат и сохраняет сумму в адресате. Операндом-адресатом всегда должен быть регистр FPU, если источник - это расположение в памяти, то адресат это регистр ST0 и нужно указать только источник. Если обоими операндами являются регистры FPU, то одним из них должен быть ST0. Операндом в памяти может быть 32-битное или 64-битное значение.

    fadd qword [bx]  ; прибавляет значение двойной точности к ST0
    fadd st2,st0     ; прибавляет ST0 к ST2

    "faddp" складывает операнд-источник и операнд-адресат, сохраняет сумму в адресате и далее выдвигает стэк регистров. Операндом-адресатом должен быть регистр FPU, а операндом-источником - ST0. Если операнды не указаны, то в качестве операнда-адресата используется ST1.

    faddp            ; прибавляет st0 к st1 и выдвигает стэк
    faddp st2,st0    ; прибавляет st0 к st2 и выдвигает стэк

    "fiadd" конвертирует целочисленный операнд-источник в расширенный  формат с плавающей точкой и прибавляет его операндe-адресату. Операндом должно быть 32-битное или 64-битное расположение в памяти.

    fiadd word [bx]  ; прибавляет целочисленное слово к st0

    "fsub", "fsubr", "fmul", "fdiv" и "fdivr" похожи на "fadd", имеют такие же правила для операндов и различаются только в совершаемых вычислениях. "fsub" вычитает операнд-источник из операнда-адресата, "fsubr" вычитает операнд-адресат из операнда-источника, "fmul" перемножает источник и адресат, "fdiv" делит операнд-адресат на операнд-источник, "fdivr" делит операнд-источник на операнд-адресат. "fsubp", "fsubrp", "fmulp" "fdivrp" и "fdivrp" совершают те же операции и выдвигают стек регистров, правила для операнда такие же, как с инструкцией "faddp". "fisub", "fisubr", "fimul" "fidivr" и "fidivr" совершают те же операции после конвертации целочисленного операнда-источника в формат с плавающей точкой, они имеют такие же правила для операндов, как и инструкция "fiadd".
    "fsqrt" вычисляет квадратный корень из значения в регистре ST0, "fsin" вычисляет синус этого значения, "fcos" вычисляет его косинус, "fchs" дополняет его знаковый бит, "fabs" очищает знак, чтобы создать абсолютное значение, "frndint" округляет до ближайшего целого значения, зависящего от текущего режима округления. "f2xm1" вычисляет экспоненциальное значение 2 в степени ST0 и вычитает из результата 1.0 (2^x-1), значение в ST0 должно лежать в пределах от -1.0 до +1.0. Все вышеперецисленные инструкции сохраняют значение в ST0 и не имеют операндов.
    "fsincos" вычисляет синус и косинус значения в ST0, сохраняет синус в ST0 и задвигает косинус в вершину стека регистров FPU. "fptan" вычисляет тангенс значения в ST0, сохраняет результат в ST0 и задвигает 1.0 в вершину стека регистров FPU. "fpatan" вычисляет арктангенс значения в ST1, деленного на значение в ST0, сохраняет результат в ST1 и выдвигает стек регистров FPU. "fyl2x" вычисляет двоичный логарифм ST0, умножает его на ST1, сохраняет результат в ST1 и выдвигает стек регистров FPU; "fyl2xp1" совершает ту же операцию, перед вычислением логарифма помешает в ST0 значение 1.0. "fprem" вычисляет остаток, зависящий от деления значения из ST0 на значение из ST1, и сохраняет результат в ST0. "fprem1" совершает ту же операцию, что и "fprem", но вычисляет остаток способом, указанном в стандарте IEEE 754. "fscale" оставляет целую часть значения в ST1 и увеличивает экспоненту ST0 на полученное число. "fxtract" разделяет значение в ST0 на экспоненту и мантиссу, сохраняет экспоненту в ST0 и задвигает мантиссу в стек регистров. "fnop" не делает ничего. Эти инструкции не имеют операндов.
    "fxch" меняет местами содержимое регистра ST0 и другого регистра FPU. Операндом должен служить регистр FPU, а если он не указан, меняются местами регистры ST0 и ST1.
     "fcom" и "fcomp" сравнивают содержимое ST0 и операнда-источника и в зависимости от результатов ставят флаги статуса FPU. "fcomp" дополнительно после сравнения выдвигает стек регистров. Операндом может служить значение одинарной или двойной точности в памяти или регистр FPU. Если операнд не определен, в этой роли используется ST1.

    fcom             ; сравнивает st0 с st1
    fcomp st2        ; сравнивает st0 с st2 и выдвигает стек

    "fcompp" сравнивает содержимое ST0 и ST1, устанавливает флаги вслове статуса FPU и дважды выдвигает стек регистров. У этой инструкции нет операндов.
    "fucom", "fucomp" и "fucompp" совершают неупорядоченное сравнение двух регистров FPU. Правила для операндов такие же, как с инструкциями "fcom", "fcomp" и "fcompp", но операндом-источником должен быть регистр FPU.
    "ficom" и "ficomp" сравнивают значение в ST0 с целочисленным операндом-источником и устанавливают флаги в слове статуса FPU в зависимости от результатов.  "ficomp" дополнительно после сравнения выдвигает стек регистров. Перед операцией сравнения целочисленный операнд-источник конвертируется в расширенный  формат с плавающей точкой. Операндом должно служить 16-битное или 32-битное расположение в памяти.

    ficom word [bx]  ; сравнивает st0 с 16-битным целым числом

    "fcomi", "fcomip", "fucomi", "fucomip" сравнивают ST0 с другим регистром FPU и ставят, в зависимости от результатов, флаги ZF, PF и CF. "fcomip" и "fucomip" ещё выдвигают стек регистров после завершения сравнения. Инструкции, образованные добавлением условного мнемоника FPU (смотрите таблицу 2.2) к мнемонику "fcmov", переводят указанный регистр FPU в регистр ST0, если данное условие выполняется. Эти инструкции поддерживают два разных синтаксиса, первый с одним операндом, определяющим регистр FPU, второй с двумя операндами, где операнд-адресат - регистр ST0, а операнд-источник, идущий вторым, - нужный регистр FPU.

    fcomi st2        ; сравнивает st0 с st2 и устанавливает флаги
    fcmovb st0,st2   ; переводит st2 в st0 если меньше

   Таблица 2.2  Условия FPU
  -----------T---------------------T------------------------¬
  ¦ Мнемоник ¦ Тестируемое условие ¦ Описание               ¦
  ¦==========+=====================+========================¦
  ¦ b        ¦ CF = 1              ¦ меньше                 ¦
  ¦ e        ¦ ZF = 1              ¦ равно                  ¦
  ¦ be       ¦ CF or ZF = 1        ¦ меньше или равно       ¦
  ¦ u        ¦ PF = 1              ¦ неномализованное       ¦
  ¦ nb       ¦ CF = 0              ¦ не меньше              ¦
  ¦ ne       ¦ ZF = 0              ¦ не равно               ¦
  ¦ nbe      ¦ CF and ZF = 0       ¦ не меньше и не равно   ¦
  ¦ nu       ¦ PF = 0              ¦ нормализованное        ¦
  L----------+---------------------+-------------------------

    "ftst" сравнивает значение в ST0 с 0.0 и в зависимости от результатов устанавливает флаги в слове статуса FPU. "fxam" проверяет содержимое регистра ST0 и устанавливает флаги в слове статуса FPU, показывая класс значения в регистре. Эти инструкции не имеют операндов.
    "fstsw" и "fnstsw" сохраняют текущее значение слова статуса FPU в указанном месте. Операндом-адресатом может быть либо 16 бит в памяти, либо регистр AX. "fstsw" перед сохранением слова проверяет на подвешенные немаскируемые численные исключения, "fnstsw" этого не делает.
    "fstcw" и "fnstcw" сохраняют текущее значение управляющего слова FPU в указанном месте в памяти. "fstcw" перед сохранением слова проверяет на подвешенные немаскируемые численные исключения, "fnstcw" этого не делает. "fldcw" загружает операнд в управляющее слово FPU. Операндом должно быть 16-битное расположение в памяти.
    "fstenv" и "fnstenv" сохраняют текущий контекст FPU в расположении в памяти, указанном в операнде-адресате, и далее маскируют все исключения  операций с плавающей  точкой. "fstenv" перед совершением операции проверяет на подвешенные немаскируемые численные исключения, "fnstenv" этого не делает. "fldenv" загружает полный контекст FPU из памяти в FPU. "fsave" и "fnsave" сохраняют текущий статус FPU (контекст и регистры стека) в указанном месте в памяти и затем ре-инициализируют FPU. "fsave" перед совершением операции проверяет на подвешенные немаскируемые численные исключения, "fnsave" этого не делает. "frstor" загружает статус FPU из указанного места в памяти. Все эти инструкции в качестве операнда требуют роасположение в памяти.
    "finit" и "fninit" устанавливают контекст FPU в его значение по умолчанию. "finit" перед совершением операции проверяет на подвешенные немаскируемые численные исключения, "fninit" этого не делает. "fclex" and "fnclex" очищают флаги исключений FPU в слове статуса FPU."fclex" перед совершением операции проверяет на подвешенные немаскируемые численные исключения, "fnclex" этого не делает. "wait" и "fwait" - это синонимы одной и той же инструкции, которая указывает процессор проверить наличие подвешенных немаскируемых численных исключений и разобраться с ними до продолжения работы. Эти инструкции не имеют операндов.
    "ffree" помечает тэг, асооциированный с указанным регистром FPU, как пустой. Операндом должен служить регистр FPU.
    "fincstp" и "fdecstp" вращают стек FPU на единицу, прибавляя или отнимая единицу от поля TOP слова статуса FPU. У этих инструкций нет операндов.


2.1.14  Инструкции MMX

Инструкции MMX оперируют со сжатыми целочисленными типами и используют регистры MMX, которыми являются нижние 64-битные части 80-битных регистров FPU. Поэтому инструкции MMX не могут использоваться в одно и то же время с инструкциями FPU. Они могут оперировать со сжатыми байтами (восемь 8-битных целых чисел), сжатыми словами (четыре 16-битных целых чисел) или сжатыми двойными словами (два 32-битных целых числа). Использование сжатых форматов позволяет совершать операции одновременно над многими данными.
    "movq" копирует четверное слово из операнда-источника в операнд-адресат. По крайней мере одним из операндов должен являться регистр MMX, вторым может быть либо регистр  MMX, либо 64-битное расположение в памяти.

    movq mm0,mm1     ; копирует четверное слово из регистра в регистр
    movq mm2,[ebx]   ; копирует четверное слово из памяти в регистр

    "movd" копирует двойное слово из операнда-источника в операнд-адресат. Одним из операндов должен быть регистр MMX, вторым может быть регистр общего назначения либо 32-битное расположение в памяти. Используется только нижнее двойное слово регистра MMX.
    Все основные операции MMX имеют два операнда, где операндом-адресатом должен быть регистр MMX, а операндом-источником может быть либо регистр MMX, либо 64-битное расположение в памяти. Операция совершается на соответствующих элементах данных источника и адресата и сохраняется элементах данных адресата. "paddb", "paddw" и "paddd" совершают сложение сжатых байтов, сжатых слов и сжатых двойных слов. "psubb", "psubw" и "psubd" совершают вычитание соответсвующих типов. "paddsb","paddsw", "psubsb" и "psubsw" совершают сложение или вычитание сжатых байтов или сжатых слов со знаковым насыщением. "paddusb", "paddusw", "psubusb", "psubusw" - это аналоги, но без знакового насыщения. "pmulhw" и "pmullw" совершают знаковое умножение сжатых слов и сохраняют верхние или нижние слова результатов в операнде-адресате. "pmaddwd" совершает умножение сжатых слов и складывает четыре промежуточных продукта в виде двойных слов в парах, чтобы получить результат в виде сжатых двойных слов. "pand", "por" и "pxor" совершают логические операции над четверными словами, "pandn" также производит логическое отрицание перед операцией "and". "pcmpeqb", "pcmpeqw" и "pcmpeqd" сравнивают на эквиваленитность сжатые байты, сжатые слова или сжатые двойные слова. Если пара элементов данных эквивалентна, то соответствующий элемент данных операнда-адресата покрывается единичными битам, иначе нулевыми. "pcmpgtb", "pcmpgtw" и "pcmpgtd" совершают похожую операцию, но они проверяют, больше ли элементы данных в операнде-адресате, чем соответствующие элементы данных в операнде-источнике. "packsswb" конвертирует сжатые знаковые слова в сжатые знаковые байты, "packssdw" конвертирует сжатые знаковые двойные слова в сжатые знаковые слова, используя насыщение, чтобы удовлетворить условиям переполнения. "packuswb" конвертирует сжатые знаковые слова в сжатые беззнаковые байты. Сконвертированные элементы данных из операнда-источника сохраняются в нижней части операнда-адресата, тогда как сконвертированные элементы данных операнда-адресата сохраняются в его верхней части. "punpckhbw", "punpckhwd" и "punpckhdq" чередуют элементы данных из верхних частей источника и адресата и сохраняют результат в операнд-адресат. "punpcklbw", "punpcklwd" и "punpckldq" совершают те же операции, но с нижними частями операндов.

    paddsb mm0,[esi] ; складывает сжатые байты со знаковым насыщением
    pcmpeqw mm3,mm7  ; проверяет сжатые слова на эквивалентность

    "psllw", "pslld" и "psllq" совершают логический сдвиг влево сжатых слов, сжатых двойных слов или одиночных четверных слов в операнде-адресате, на число битов, указанное в операнде-источнике.  "psrlw", "psrld" и "psrlq" совершают логический сдвиг вправо сжатых слов, сжатых двойных слов или одиночных четверных слов.  "psraw" и "psrad" совершают арифметический сдвиг сжатых слов или двойных слов. Операндом-адресатом должен быть регистр MMX, а операндом-источником может быть регистр MMX, 64-битное расположение в памяти или 8-битное непосредственное значение.

    psllw mm2,mm4    ; сдвигает слова влево логически
    psrad mm4,[ebx]  ; сдвигает двойные слова вправо арифметически

    "emms" делает регистры FPU используемыми для инструкций FPU. Эта инструкция должна быть примененена перед использованием инструкций FPU, если в ход пускались инструкции MMX.


2.1.15  Инструкции SSE

Расширение SSE добавляет больше инструкций MMX, а также представляет операции со сжатыми значениями одинарной точности с плавающей точкой. 128-битный сжатый формат одинарной точности содержит четыре значения одинарной точности с плавающей точкой. 128-битные регистры SSE созданы для поддержки операций этого типа данных.
    "movaps" и "movups" переводят операнд размером в двойное четверное слово, содержащий значения одинарной точности из операнда-источника в операнд-адресат. По крайней мере одним из операндов должен быть регистр SSE, вторым может быть либо тоже регистр SSE, либо 128-битное располжение в памяти.  Операнды в памяти для "movaps" должны быть выровнены по 16-битной меже, для "movups" этого не требуется.

    movups xmm0,[ebx]  ; переводит невыровненное двойное четверное слово

    "movlps" переводит два сжатых значения одинарной точности из нижнего четверного слова регистра-источника в верхнее четверное слово регистра-адресата. "movhlps" переводит два сжатых значения одинарной точности из верхнего четверного слова регистра-источника в нижнее четверное слово регистра-адресата. Обоими операндами должны быть регистры SSE.
    "movmskps" переводит знаковые биты всех значений одинарной точности в регистре SSE в нижние четыре бита регистра общего назначения. Операндом-источником должен быть регистр SSE, операндом-адресатом должен быть регистр общего назначения.
    "movss" переводит значение одинарной точности между источником и адресатом (переводится только нижнее двойное слово). По крайней мере одним из операндов должен быть регистр SSE, вторым может быть либо тоже регистр SSE, либо 32-битное располжение в памяти.

    movss [edi],xmm3   ; переводит нижнее двойное слово из xmm3 в память

    Каждая арифметическая операция SSE имеет два варианта. Если мнемоник заканчивается на "ps", операндом-источником может быть 128-битное расположение в памяти или регистр SSE, операндом-адресатом должен быть регистр SSE, и операция производится над четыремя сжатыми значениями одинарной точности, для каждой пары соответствующих элементов данных отдельно, и результат сохраняется в регистре-адресате.  Если мнемоник заканчивается на "ss", то операндом-источником может быть 32-битное расположение в памяти или регистр SSE, операндом-адресатом должен быть регистр SSE, и операция производится над одним значением одинарной точности, используются только нижние двойные слова регистров SSE,  и результат сохраняется в нижнем двойном слове регистра-адресата. "addps" и "addss" складывают значения, "subps" и "subss" вычитают источник из адресата, "mulps" и "mulss" перемножают значения, "divps" и "divss" делят адресат на источник, "rcpps" и "rcpss" вычисляют аппроксимированную обратную величину источника, "sqrtps" и "sqrtss" вычисляют квадратный корень источника, "rsqrtps" и "rsqrtss" вычисляют аппроксимированную обратную величину квадратного корня источника, "maxps" и "maxss" сравнивают источник и адресат и возвращают большее значение, "minps" и "minss" сравнивают источник и адресат и возвращают меньшее значение.

    mulss xmm0,[ebx]   ; перемножает значения одинарной точности
    addps xmm3,xmm7    ; складывает сжатые значения одинарной точности

    "andps", "andnps", "orps" и "xorps" производят логические операции над сжатыми значениями одинарной точности. Операндом-источником может быть 128-битное расположение в памяти или регистр SSE, операндом-адресатом должен быть регистр SSE.
    "cmpps" сравнивает сжатые значения одинарной точности и возвращают маскируемый результат в операнд-адресат, которым должен быть регистр SSE. Операндом-источником может быть либо регистр SSE, либо 128-битное расположение в памяти, третьим операндом должно быть непосредственное значение, выбирающее код одного из восьми условий сравнения (таблица 2.3). "cmpss" совершает ту же над значениями одинарной точности, изменяется только нижнее двойное слово регистра-адресата, таким образом операндом-источником должен быть либо регистр SSE, либо 32-битное расположение в памяти. Эти две инструкции имеют также варианты с двумя операндами и условие, закодированным в мнемоник. Их мнемоники образуются путем добавления мнемоников из таблицы 2.3 к "cmp" и после добавления к ним в конце "ps" илои "ss".

    cmpps xmm2,xmm4,0  ; сравнивает сжатые значения одинарной точности
    cmpltss xmm0,[ebx] ; сравнивает значения одинарной точности

   Table 2.3  Условия SSE
  -------T----------T-------------------------¬
  ¦ Код  ¦ Мнемоник ¦ Описание                ¦
  ¦======+==========+=========================¦
  ¦ 0    ¦ eq       ¦ равно                   ¦
  ¦ 1    ¦ lt       ¦ меньше                  ¦
  ¦ 2    ¦ le       ¦ меньше или равно        ¦
  ¦ 3    ¦ unord    ¦ ненормализованное       ¦
  ¦ 4    ¦ neq      ¦ не равно                ¦
  ¦ 5    ¦ nlt      ¦ не меньше               ¦
  ¦ 6    ¦ nle      ¦ не меньше и не равно    ¦
  ¦ 7    ¦ ord      ¦ нормализованное         ¦
  L------+----------+--------------------------

    "comiss" и "ucomiss" сравнивают значения одинарной точности и ставят в зависимости от результата флаги ZF, PF и CF. Операндом-адресатом должен быть регистр SSE, операндом-источником может быть 32-битное расположение в памяти или регистр SSE.
    "shufps" переводит некоторые два из четырех значений одинарной точности из операнда-адресата в нижнее четверное слово операнда-адресата и некоторые два из четырех значений одинарной точности из операнда-источника в верхнее четверное слово операнда-адресата. Операндом-адресатом должен быть регистр SSE, операндом-источником может быть 128-битное расположение в памяти или регистр SSE, а третьим операндом должно быть 8-битное непосредственное значение, какие конкретно  значения будут задействованы. Биты 0 и 1 указывают значение из адресата, которое должно быть в нижнем двойном слове результата, биты 2 и 3 указывают значение из адресата, которое должно быть во втором двойном слове результата, биты 4 и 5 указывают значение из источника, которое должно быть в третьем двойном слове результата, биты 6 и 7 указывают значение из источника, которое должно быть в нижнем верхнем слове результата.

    shufps xmm0,xmm0,10010011b ; перемешивает двойные слова

    "unpckhps" совершает перемежающуюся распаковку значений из верхних частей источника и адресата и сохраняет результат в адресат, которым должен быть регистр SSE. Операндом-источником может быть 128-битное расположение в памяти или регистр SSE. "unpcklps" совершает перемежающуюся распаковку значений из нижних частей источника и адресата и сохраняет результат в адресат, правила для операндов такие же.
    "cvtpi2ps" конвертирует два сжатых целых числа размером в двойное слово в два сжатых значения с плавающей точкой одинарной точности и сохраняет результат в нижнем четверном слове адресата, которым должен быть регистр SSE. Операндом-источником может быть 64-битное расположение в памяти или регистр MMX.

    cvtpi2ps xmm0,mm0  ; конвертирует целые числа в значения одинарной точности

"cvtsi2ss" конвертирует целое число размером в двойное слово в сжатое значение с плавающей точкой одинарной точности и сохраняет результат в нижнем двойном слове адресата, которым должен быть регистр SSE. Операндом-источником может быть 32-битное расположение в памяти или 32-битный регистр общего назначения.

    cvtsi2ss xmm0,eax  ; конвертирует целое число в значение одинарной точности

"cvtps2pi" конвертирует два сжатых значения с плавающей точкой одинарной точности в два сжатых целых числа размером в двойное слово и сохраняет результат в адресате, которым должен быть регистр MMX. Операндом-источником может быть 64-битное расположение в памяти либо регистр SSE, в котором будет использовано только нижнее четверное слово. "cvttps2pi" совершает похожую операцию, но для округления здесь используется отбрасывание дробной части, правила для операндов у этой инструкции такие же.
    
    cvtps2pi mm0,xmm0  ; конвертирует значения одинарной точности в целые числа

    "cvtss2si" конвертирует сжатое значение с плавающей точкой одинарной точности в сжатое целое число размером в двойное слово и сохраняет результат в адресате, которым должен быть 32-битный регистр общего назначения. Операндом-источником может быть 32-битное расположение в памяти либо регистр SSE, в котором будет использовано только нижнее двойное слово. "cvttss2si" совершает похожую операцию, но для округления здесь используется отбрасывание дробной части, правила для операндов у этой инструкции такие же.

    cvtss2si eax,xmm0  ; конвертирует значение одинарной точности в целое число

    "pextrw" копирует слово, указанное третьим операндом, из источника в адресат. Операндом-источником должен быть регистр MMX, операндом-адресатом должен быть 32-битный регистр общего назначения (но используется только нижнее его слово), третьим операндом должно быть 8-битное непосредственное значение.

    pextrw eax,mm0,1   ; извлекает слово в eax

"pinsrw" вставляет слово из источника в место в адресате, указанное третьим операндом, которым  должно быть 8-битное непосредственное значение. Операндом-адресатом должен быть регистр MMX, операндом-источником должен быть 32-битный регистр общего назначения (но используется только нижнее его слово).

    pinsrw mm1,ebx,2   ; вставляет слово из ebx

"pavgb" and "pavgw" вычисляют среднее сжатых байтов или слов. "pmaxub" возвращает максимум сжатых беззнаковых байтов, "pminub" возвращает минимум сжатых беззнаковых байтов, "pmaxsw" возвращает максимум сжатых знаковых слов, "pminsw" возвращает минимум сжатых знаковых слов. "pmulhuw" совершает беззнаковое умножение сжатых слов и сохраняет верхние слова результатов в операнд-адресат. "psadbw" вычисляет абсолютные разности сжатых беззнаковых байтов, суммирует эти разности и сохраняет результат в нижнее слово операнда-адресата. Все эти инструкции следуют тем же правилам для операндов, что и основные операции MMX, описанные в предыдущем параграфе.
    "pmovmskb" создает маску из знаковых битов всех байтов в источнике и сохраняет результат в нижнем байте адресата. Операндом-источником должен быть регистр MMX, операндом-адресатом должен быть 32-битный регистр общего назначения.
    "pshufw" копирует слова, указанные третьим операндом, из источника в адресат. Операндом-адресатом долже быть регистр MMХ, операндом-источником может быть 64-битное расположение в памяти или регистр MMX, третьим операндом должно быть 8-битное непосредственное значение, выбирающее, какие значения будут помещены в адресат, таким же образом как третий операнд в инструкции "shufps".
    "movntq" переводит четверное слово из операнда-источника в память, используя "не-временное малое количество" (non-temporal hint), чтобы минимизировать загрязнение кэша. Операндом-источником должен быть регистр MMX, операндом-адресатом должно быть 64-битное расположение в памяти. "movntps" сохраняет сжатые значения одинарной точности из регистра SSE в память, используя "не-временное малое количество". Операндом-источником должен быть регистр SSE, операндом-адресатом должно быть 128-битное расположение в памяти. "maskmovq" сохраняет выбранные байты из первого операнда в 64-битное расположение в памяти, используя "не-временное малое количество". Обоими операндами должны служить регистры MMX, второй операнд указывает, какие байты из первого операнда должны быть записаны в память. Расположение в памяти указывается регистром DI (или EDI) в сегменте, определенном в DS.
    "prefetcht0", "prefetcht1", "prefetcht2" and "prefetchnta" помещает строку данных из памяти, которая содержит байт, указанный в операнде, в определенное место в иерархии кеша. Операндом должно быть 8-битное расположение в памяти.
    "sfence" переводит в последовательный режим все предыдущие команды, совершающие запись в память. У этой инструкции нет операндов.
    "ldmxcsr" загружает 32-битный операнд в памяти в регистр MXCSR. "stmxsr" сохраняет содержимое MXCSR в 32-битный операнд в памяти.
    "fxsave" сохраняет текущий статус FPU, регистр MXCSR и все регистры FPU и SSE в 512-байтное расположение в памяти, указанное в операнде-адресате. "fxstor" перезагружает данные, ранее сохраненные инструкцией "fxsave" из 512-байтного расположения в памяти. Операнд для обеих этих инструкций должен быть выровнен по 16 байтам, нужно объявить операнд неопределенного размера.


in Russian by Paranoik